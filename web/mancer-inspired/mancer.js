
document.addEventListener('DOMContentLoaded', function () {
    JqueryUtil.initEnhancements();
    //test_AddClassPage();
});
window.addEventListener('load', function () {
   
    //console.log(Vetools._getMaybeLocalUrl("data/class/index.json"));
    //test_loadJSON().then(() => {console.log("Done pinging");});

    //Test using 5etools import
    test_nativeImportContent();
    
    //test_AddClassPage();
});

async function test_nativeImportContent(){
    const content = await SourceSelectorTest.getOutputEntities();
    ContentGetter._cachedData = content;
    await ContentGetter.cookClassFeatures(content); //unfortunately this function pulls from _cachedData, so we need to set it before that (i know, needs fixing)
    
    let window = new ParentWindow(ContentGetter._cachedData);
}
async function test_loadJSON(){
    const localClassIndexUrl = "data/class/index.json";
    const classIndex = await DataUtil.loadRawJSON(localClassIndexUrl);
    let classDatas = [];
    let addresses = [];
    Object.keys(classIndex).forEach((k,v) => {
        const name = classIndex[k]; addresses.push(name);
    });
    for(let a of addresses){
        let path = "data/class/" + a;
        let result = await DataUtil.loadRawJSON(path);
        if(result){classDatas.push(result);}
    }

    console.log(classDatas);
    //console.log("num classes: ", Object.keys(classIndex).length);

}
async function test_AddClassPage(){

    //Let's grab all the data we can
    let allData = await loadContentData();
    let window = new ParentWindow(allData);
    //Any content we pass on will be enabled by the filter by default
    //It will toggle all the sources as active
    //So we need to find a way to toggle all non-PHB sources as disabled, as a test

    
    
    //Lets try to add it to our DOM
    //comp.render();
}
async function loadContentData(){
    let allData = await ContentGetter._getBase();
    await ContentGetter._cookData(allData);
    return allData;
}
class SETTINGS{
    static FILTERS = true;
    static PARENTLESS_MODE = true;
    static DO_RENDER_DICE = false;
    static USE_EXISTING = false;
    static LOCALPATH_REDIRECT = true;
}
class ParentWindow {
    tabButtonParent;
    tabClass;
    tabRace;
    tabAbilities;
    tabBackground;
    tabSpells;
    tabEquipment;
    tabFeats;
    tabSheet;
    compClass;
    compRace;
    compAbility;
    compBackground;
    compStartingEquipment;
    compSpell;
    compFeat;
    compSheet;
    tabs;
    
    constructor(data){

        this.parent = this;
        this.createTabs();

        const _root = $("#window-root");
        const $tabClass = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabClass = new WindowTab($tabClass);
        const $tabRace = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabRace = new WindowTab($tabRace);
        const $tabAbilities = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabAbilities = new WindowTab($tabAbilities);
        const $tabBackground = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabBackground = new WindowTab($tabBackground);
        const $tabEquipment = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabEquipment = new WindowTab($tabEquipment);
        const $tabSpells = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabSpells = new WindowTab($tabSpells);
        const $tabFeats = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabFeats = new WindowTab($tabFeats);
        const $tabSheet = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabSheet = new WindowTab($tabSheet);

        const DEFAULT_SOURCES = [Parser.SRC_PHB, Parser.SRC_DMG, Parser.SRC_XGE, Parser.SRC_VGM, Parser.SRC_MPMM];

        this.data = data;

        this._featureSourceTracker = new Charactermancer_FeatureSourceTracker();

        this.compClass = new ActorCharactermancerClass(this);
        this.compRace = new ActorCharactermancerRace(this);
        this.compAbility = new ActorCharactermancerAbility(this);
        this.compBackground = new ActorCharactermancerBackground(this);
        this.compStartingEquipment = new ActorCharactermancerEquipment(this);
        this.compSpell = new ActorCharactermancerSpell(this);
        this.compFeat = new ActorCharactermancerFeat(this);
        this.compSheet = new ActorCharactermancerSheet(this);

        

        const testApplyDefaultSources = () => {
            HelperFunctions.setModalFilterSourcesStrings(this.compBackground.modalFilterBackgrounds, DEFAULT_SOURCES);
            HelperFunctions.setModalFilterSourcesStrings(this.compRace.modalFilterRaces, DEFAULT_SOURCES);
        }
        

        this.pLoad().then(() => this.renderComponents()).then(() => testApplyDefaultSources()).then(() => this.e_switchTab("class"));
    }

    _createTabWrapper(name, rootDiv){
        const el = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(rootDiv);
        this[name] = new WindowTab(el);
    }
    createTabs(){
        const tabHolder = $(`.tab_button_holder`);
        //Create the tabs

        //Class tab (mark as active)
        const clsBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Class</button>`).click(()=>{
            this.e_switchTab("class");
        }).appendTo(tabHolder);
        const raceBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Race</button>`).click(()=>{
            this.e_switchTab("race");
        }).appendTo(tabHolder);
        const ablBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Abilities</button>`).click(()=>{
            this.e_switchTab("abilities");
        }).appendTo(tabHolder);
        const bckBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Background</button>`).click(()=>{
            this.e_switchTab("background");
        }).appendTo(tabHolder);
        const startEqBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Starting Equipment</button>`).click(()=>{
            this.e_switchTab("startingEquipment");
        }).appendTo(tabHolder);
        /*
        const eqShopBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Equipment Shop</button>`).click(()=>{

        }).appendTo(tabHolder);*/
        const spellsBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Spells</button>`).click(()=>{
            this.e_switchTab("spells");
        }).appendTo(tabHolder);

        const featsBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Feats</button>`).click(()=>{
            this.e_switchTab("feats");
        }).appendTo(tabHolder); 
        const shtBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Sheet</button>`).click(()=>{
            this.e_switchTab("sheet");
        }).appendTo(tabHolder);
        

        this.tabButtonParent = tabHolder;
        clsBtn.addClass("active");
    }
    async pLoad(){
        if(!SETTINGS.FILTERS){return;}
        await this.compRace.pLoad();
        await this.compBackground.pLoad();
        await this.compClass.pLoad();
        await this.compSpell.pLoad();
        await this.compFeat.pLoad();
    }
    renderComponents(){
        this.compClass.render();
        this.compRace.render();
        this.compAbility.render();
        this.compBackground.render();
        this.compStartingEquipment.pRenderStarting();
        this.compSpell.pRender();
        this.compFeat.render();
        this.compSheet.render();
    }

    //#region Events
    e_switchTab(tabName){
        //TODO: improve this
        let newActivePanel = null;
        let tabIx = 0;
        this.tabButtonParent.children().each(function() {$(this).removeClass("active");});
        this.setActive(this.tabClass.$wrpTab, false);
        this.setActive(this.tabRace.$wrpTab, false);
        this.setActive(this.tabAbilities.$wrpTab, false);
        this.setActive(this.tabBackground.$wrpTab, false);
        this.setActive(this.tabEquipment.$wrpTab, false);
        this.setActive(this.tabSpells.$wrpTab, false);
        this.setActive(this.tabFeats.$wrpTab, false);
        this.setActive(this.tabSheet.$wrpTab, false);

        switch(tabName){
            case "class": newActivePanel = this.tabClass; tabIx = 0; break;
            case "race": newActivePanel = this.tabRace; tabIx = 1; break;
            case "abilities": newActivePanel = this.tabAbilities; tabIx = 2; break;
            case "background": newActivePanel = this.tabBackground; tabIx = 3; break;
            case "startingEquipment": newActivePanel = this.tabEquipment; tabIx = 4; break;
            case "spells": newActivePanel = this.tabSpells; tabIx = 5; break;
            case "feats": newActivePanel = this.tabFeats; tabIx = 6; break;
            case "sheet": newActivePanel = this.tabSheet; tabIx = 7; break;
        }
        const pressedBtn = this.tabButtonParent.children().eq(tabIx);
        pressedBtn.addClass("active");
        this.setActive(newActivePanel.$wrpTab, true);
    }
    //#endregion
    //#region Getters
    get featureSourceTracker_() {
        return this._featureSourceTracker;
    }
    //#endregion
    
    setActive($tab, active){
        const hi = "ve-hidden";
        if(!$tab){return;}
        if(active && $tab.hasClass(hi)){$tab.removeClass(hi);}
        else if(!active && !$tab.hasClass(hi)){$tab.addClass(hi);}
   }

}
/**Don't think of this as a tab button, but more as a tab screen */
class WindowTab {
    $wrpTab;
    constructor(parentDiv){
        this.$wrpTab = parentDiv;
    }
    
}

//#region UTILITIES 1
//#region Parser
globalThis.Parser = {};
Parser._parse_aToB = function(abMap, a, fallback) {
    if (a === undefined || a === null)
        throw new TypeError("undefined or null object passed to parser");
    if (typeof a === "string")
        a = a.trim();
    if (abMap[a] !== undefined)
        return abMap[a];
    return fallback !== undefined ? fallback : a;
}
;

Parser._parse_bToA = function(abMap, b, fallback) {
    if (b === undefined || b === null)
        throw new TypeError("undefined or null object passed to parser");
    if (typeof b === "string")
        b = b.trim();
    for (const v in abMap) {
        if (!abMap.hasOwnProperty(v))
            continue;
        if (abMap[v] === b)
            return v;
    }
    return fallback !== undefined ? fallback : b;
}
;

Parser.attrChooseToFull = function(attList) {
    if (attList.length === 1)
        return `${Parser.attAbvToFull(attList[0])} modifier`;
    else {
        const attsTemp = [];
        for (let i = 0; i < attList.length; ++i) {
            attsTemp.push(Parser.attAbvToFull(attList[i]));
        }
        return `${attsTemp.join(" or ")} modifier (your choice)`;
    }
}
;

Parser.numberToText = function(number) {
    if (number == null)
        throw new TypeError(`undefined or null object passed to parser`);
    if (Math.abs(number) >= 100)
        return `${number}`;

    return `${number < 0 ? "negative " : ""}${Parser.numberToText._getPositiveNumberAsText(Math.abs(number))}`;
}
;

Parser.numberToText._getPositiveNumberAsText = num=>{
    const [preDotRaw,postDotRaw] = `${num}`.split(".");

    if (!postDotRaw)
        return Parser.numberToText._getPositiveIntegerAsText(num);

    let preDot = preDotRaw === "0" ? "" : `${Parser.numberToText._getPositiveIntegerAsText(Math.trunc(num))} and `;

    switch (postDotRaw) {
    case "125":
        return `${preDot}one-eighth`;
    case "2":
        return `${preDot}one-fifth`;
    case "25":
        return `${preDot}one-quarter`;
    case "375":
        return `${preDot}three-eighths`;
    case "4":
        return `${preDot}two-fifths`;
    case "5":
        return `${preDot}one-half`;
    case "6":
        return `${preDot}three-fifths`;
    case "625":
        return `${preDot}five-eighths`;
    case "75":
        return `${preDot}three-quarters`;
    case "8":
        return `${preDot}four-fifths`;
    case "875":
        return `${preDot}seven-eighths`;

    default:
        {
            const asNum = Number(`0.${postDotRaw}`);

            if (asNum.toFixed(2) === (1 / 3).toFixed(2))
                return `${preDot}one-third`;
            if (asNum.toFixed(2) === (2 / 3).toFixed(2))
                return `${preDot}two-thirds`;

            if (asNum.toFixed(2) === (1 / 6).toFixed(2))
                return `${preDot}one-sixth`;
            if (asNum.toFixed(2) === (5 / 6).toFixed(2))
                return `${preDot}five-sixths`;
        }
    }
}
;

Parser.numberToText._getPositiveIntegerAsText = num=>{
    switch (num) {
    case 0:
        return "zero";
    case 1:
        return "one";
    case 2:
        return "two";
    case 3:
        return "three";
    case 4:
        return "four";
    case 5:
        return "five";
    case 6:
        return "six";
    case 7:
        return "seven";
    case 8:
        return "eight";
    case 9:
        return "nine";
    case 10:
        return "ten";
    case 11:
        return "eleven";
    case 12:
        return "twelve";
    case 13:
        return "thirteen";
    case 14:
        return "fourteen";
    case 15:
        return "fifteen";
    case 16:
        return "sixteen";
    case 17:
        return "seventeen";
    case 18:
        return "eighteen";
    case 19:
        return "nineteen";
    case 20:
        return "twenty";
    case 30:
        return "thirty";
    case 40:
        return "forty";
    case 50:
        return "fifty";
    case 60:
        return "sixty";
    case 70:
        return "seventy";
    case 80:
        return "eighty";
    case 90:
        return "ninety";
    default:
        {
            const str = String(num);
            return `${Parser.numberToText._getPositiveIntegerAsText(Number(`${str[0]}0`))}-${Parser.numberToText._getPositiveIntegerAsText(Number(str[1]))}`;
        }
    }
}
;

Parser.textToNumber = function(str) {
    str = str.trim().toLowerCase();
    if (!isNaN(str))
        return Number(str);
    switch (str) {
    case "zero":
        return 0;
    case "one":
    case "a":
    case "an":
        return 1;
    case "two":
    case "double":
        return 2;
    case "three":
    case "triple":
        return 3;
    case "four":
    case "quadruple":
        return 4;
    case "five":
        return 5;
    case "six":
        return 6;
    case "seven":
        return 7;
    case "eight":
        return 8;
    case "nine":
        return 9;
    case "ten":
        return 10;
    case "eleven":
        return 11;
    case "twelve":
        return 12;
    case "thirteen":
        return 13;
    case "fourteen":
        return 14;
    case "fifteen":
        return 15;
    case "sixteen":
        return 16;
    case "seventeen":
        return 17;
    case "eighteen":
        return 18;
    case "nineteen":
        return 19;
    case "twenty":
        return 20;
    case "thirty":
        return 30;
    case "forty":
        return 40;
    case "fifty":
        return 50;
    case "sixty":
        return 60;
    case "seventy":
        return 70;
    case "eighty":
        return 80;
    case "ninety":
        return 90;
    }
    return NaN;
}
;

Parser.numberToVulgar = function(number, {isFallbackOnFractional=true}={}) {
    const isNeg = number < 0;
    const spl = `${number}`.replace(/^-/, "").split(".");
    if (spl.length === 1)
        return number;

    let preDot = spl[0] === "0" ? "" : spl[0];
    if (isNeg)
        preDot = `-${preDot}`;

    switch (spl[1]) {
    case "125":
        return `${preDot}⅛`;
    case "2":
        return `${preDot}⅕`;
    case "25":
        return `${preDot}¼`;
    case "375":
        return `${preDot}⅜`;
    case "4":
        return `${preDot}⅖`;
    case "5":
        return `${preDot}½`;
    case "6":
        return `${preDot}⅗`;
    case "625":
        return `${preDot}⅝`;
    case "75":
        return `${preDot}¾`;
    case "8":
        return `${preDot}⅘`;
    case "875":
        return `${preDot}⅞`;

    default:
        {
            const asNum = Number(`0.${spl[1]}`);

            if (asNum.toFixed(2) === (1 / 3).toFixed(2))
                return `${preDot}⅓`;
            if (asNum.toFixed(2) === (2 / 3).toFixed(2))
                return `${preDot}⅔`;

            if (asNum.toFixed(2) === (1 / 6).toFixed(2))
                return `${preDot}⅙`;
            if (asNum.toFixed(2) === (5 / 6).toFixed(2))
                return `${preDot}⅚`;
        }
    }

    return isFallbackOnFractional ? Parser.numberToFractional(number) : null;
}
;

Parser.vulgarToNumber = function(str) {
    const [,leading="0",vulgar=""] = /^(\d+)?([⅛¼⅜½⅝¾⅞⅓⅔⅙⅚])?$/.exec(str) || [];
    let out = Number(leading);
    switch (vulgar) {
    case "⅛":
        out += 0.125;
        break;
    case "¼":
        out += 0.25;
        break;
    case "⅜":
        out += 0.375;
        break;
    case "½":
        out += 0.5;
        break;
    case "⅝":
        out += 0.625;
        break;
    case "¾":
        out += 0.75;
        break;
    case "⅞":
        out += 0.875;
        break;
    case "⅓":
        out += 1 / 3;
        break;
    case "⅔":
        out += 2 / 3;
        break;
    case "⅙":
        out += 1 / 6;
        break;
    case "⅚":
        out += 5 / 6;
        break;
    case "":
        break;
    default:
        throw new Error(`Unhandled vulgar part "${vulgar}"`);
    }
    return out;
}
;

Parser.numberToSuperscript = function(number) {
    return `${number}`.split("").map(c=>isNaN(c) ? c : Parser._NUMBERS_SUPERSCRIPT[Number(c)]).join("");
}
;
Parser._NUMBERS_SUPERSCRIPT = "⁰¹²³⁴⁵⁶⁷⁸⁹";

Parser.numberToSubscript = function(number) {
    return `${number}`.split("").map(c=>isNaN(c) ? c : Parser._NUMBERS_SUBSCRIPT[Number(c)]).join("");
}
;
Parser._NUMBERS_SUBSCRIPT = "₀₁₂₃₄₅₆₇₈₉";

Parser._greatestCommonDivisor = function(a, b) {
    if (b < Number.EPSILON)
        return a;
    return Parser._greatestCommonDivisor(b, Math.floor(a % b));
}
;
Parser.numberToFractional = function(number) {
    const len = number.toString().length - 2;
    let denominator = 10 ** len;
    let numerator = number * denominator;
    const divisor = Parser._greatestCommonDivisor(numerator, denominator);
    numerator = Math.floor(numerator / divisor);
    denominator = Math.floor(denominator / divisor);

    return denominator === 1 ? String(numerator) : `${Math.floor(numerator)}/${Math.floor(denominator)}`;
}
;

Parser.ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

Parser.attAbvToFull = function(abv) {
    return Parser._parse_aToB(Parser.ATB_ABV_TO_FULL, abv);
}
;

Parser.attFullToAbv = function(full) {
    return Parser._parse_bToA(Parser.ATB_ABV_TO_FULL, full);
}
;

Parser.sizeAbvToFull = function(abv) {
    return Parser._parse_aToB(Parser.SIZE_ABV_TO_FULL, abv);
}
;

Parser.getAbilityModNumber = function(abilityScore) {
    return Math.floor((abilityScore - 10) / 2);
}
;

Parser.getAbilityModifier = function(abilityScore) {
    let modifier = Parser.getAbilityModNumber(abilityScore);
    if (modifier >= 0)
        modifier = `+${modifier}`;
    return `${modifier}`;
}
;

Parser.getSpeedString = (ent,{isMetric=false, isSkipZeroWalk=false}={})=>{
    if (ent.speed == null)
        return "\u2014";

    const unit = isMetric ? Parser.metric.getMetricUnit({
        originalUnit: "ft.",
        isShortForm: true
    }) : "ft.";
    if (typeof ent.speed === "object") {
        const stack = [];
        let joiner = ", ";

        Parser.SPEED_MODES.filter(mode=>!ent.speed.hidden?.includes(mode)).forEach(mode=>Parser._getSpeedString_addSpeedMode({
            ent,
            prop: mode,
            stack,
            isMetric,
            isSkipZeroWalk,
            unit
        }));

        if (ent.speed.choose && !ent.speed.hidden?.includes("choose")) {
            joiner = "; ";
            stack.push(`${ent.speed.choose.from.sort().joinConjunct(", ", " or ")} ${ent.speed.choose.amount} ${unit}${ent.speed.choose.note ? ` ${ent.speed.choose.note}` : ""}`);
        }

        return stack.join(joiner) + (ent.speed.note ? ` ${ent.speed.note}` : "");
    }

    return (isMetric ? Parser.metric.getMetricNumber({
        originalValue: ent.speed,
        originalUnit: Parser.UNT_FEET
    }) : ent.speed) + (ent.speed === "Varies" ? "" : ` ${unit} `);
}
;
Parser._getSpeedString_addSpeedMode = ({ent, prop, stack, isMetric, isSkipZeroWalk, unit})=>{
    if (ent.speed[prop] || (!isSkipZeroWalk && prop === "walk"))
        Parser._getSpeedString_addSpeed({
            prop,
            speed: ent.speed[prop] || 0,
            isMetric,
            unit,
            stack
        });
    if (ent.speed.alternate && ent.speed.alternate[prop])
        ent.speed.alternate[prop].forEach(speed=>Parser._getSpeedString_addSpeed({
            prop,
            speed,
            isMetric,
            unit,
            stack
        }));
}
;
Parser._getSpeedString_addSpeed = ({prop, speed, isMetric, unit, stack})=>{
    const ptName = prop === "walk" ? "" : `${prop} `;
    const ptValue = Parser._getSpeedString_getVal({
        prop,
        speed,
        isMetric
    });
    const ptUnit = speed === true ? "" : ` ${unit}`;
    const ptCondition = Parser._getSpeedString_getCondition({
        speed
    });
    stack.push([ptName, ptValue, ptUnit, ptCondition].join(""));
}
;
Parser._getSpeedString_getVal = ({prop, speed, isMetric})=>{
    if (speed === true && prop !== "walk")
        return "equal to your walking speed";

    const num = speed === true ? 0 : speed.number != null ? speed.number : speed;

    return isMetric ? Parser.metric.getMetricNumber({
        originalValue: num,
        originalUnit: Parser.UNT_FEET
    }) : num;
}
;
Parser._getSpeedString_getCondition = ({speed})=>speed.condition ? ` ${Renderer.get().render(speed.condition)}` : "";

Parser.SPEED_MODES = ["walk", "burrow", "climb", "fly", "swim"];

Parser.SPEED_TO_PROGRESSIVE = {
    "walk": "walking",
    "burrow": "burrowing",
    "climb": "climbing",
    "fly": "flying",
    "swim": "swimming",
};

Parser.speedToProgressive = function(prop) {
    return Parser._parse_aToB(Parser.SPEED_TO_PROGRESSIVE, prop);
}
;

Parser._addCommas = function(intNum) {
    return `${intNum}`.replace(/(\d)(?=(\d{3})+$)/g, "$1,");
}
;

Parser.raceCreatureTypesToFull = function(creatureTypes) {
    const hasSubOptions = creatureTypes.some(it=>it.choose);
    return creatureTypes.map(it=>{
        if (!it.choose)
            return Parser.monTypeToFullObj(it).asText;
        return [...it.choose].sort(SortUtil.ascSortLower).map(sub=>Parser.monTypeToFullObj(sub).asText).joinConjunct(", ", " or ");
    }
    ).joinConjunct(hasSubOptions ? "; " : ", ", " and ");
}
;

Parser.crToXp = function(cr, {isDouble=false}={}) {
    if (cr != null && cr.xp)
        return Parser._addCommas(`${isDouble ? cr.xp * 2 : cr.xp}`);

    const toConvert = cr ? (cr.cr || cr) : null;
    if (toConvert === "Unknown" || toConvert == null || !Parser.XP_CHART_ALT[toConvert])
        return "Unknown";
    if (toConvert === "0")
        return "10";
    const xp = Parser.XP_CHART_ALT[toConvert];
    return Parser._addCommas(`${isDouble ? 2 * xp : xp}`);
}
;

Parser.crToXpNumber = function(cr) {
    if (cr != null && cr.xp)
        return cr.xp;
    const toConvert = cr ? (cr.cr || cr) : cr;
    if (toConvert === "Unknown" || toConvert == null)
        return null;
    return Parser.XP_CHART_ALT[toConvert] ?? null;
}
;

Parser.LEVEL_TO_XP_EASY = [0, 25, 50, 75, 125, 250, 300, 350, 450, 550, 600, 800, 1000, 1100, 1250, 1400, 1600, 2000, 2100, 2400, 2800];
Parser.LEVEL_TO_XP_MEDIUM = [0, 50, 100, 150, 250, 500, 600, 750, 900, 1100, 1200, 1600, 2000, 2200, 2500, 2800, 3200, 3900, 4100, 4900, 5700];
Parser.LEVEL_TO_XP_HARD = [0, 75, 150, 225, 375, 750, 900, 1100, 1400, 1600, 1900, 2400, 3000, 3400, 3800, 4300, 4800, 5900, 6300, 7300, 8500];
Parser.LEVEL_TO_XP_DEADLY = [0, 100, 200, 400, 500, 1100, 1400, 1700, 2100, 2400, 2800, 3600, 4500, 5100, 5700, 6400, 7200, 8800, 9500, 10900, 12700];
Parser.LEVEL_TO_XP_DAILY = [0, 300, 600, 1200, 1700, 3500, 4000, 5000, 6000, 7500, 9000, 10500, 11500, 13500, 15000, 18000, 20000, 25000, 27000, 30000, 40000];

Parser.LEVEL_XP_REQUIRED = [0, 300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000];

Parser.CRS = ["0", "1/8", "1/4", "1/2", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30"];

Parser.levelToXpThreshold = function(level) {
    return [Parser.LEVEL_TO_XP_EASY[level], Parser.LEVEL_TO_XP_MEDIUM[level], Parser.LEVEL_TO_XP_HARD[level], Parser.LEVEL_TO_XP_DEADLY[level]];
}
;

Parser.isValidCr = function(cr) {
    return Parser.CRS.includes(cr);
}
;

Parser.crToNumber = function(cr, opts={}) {
    const {isDefaultNull=false} = opts;

    if (cr === "Unknown" || cr === "\u2014" || cr == null)
        return isDefaultNull ? null : VeCt.CR_UNKNOWN;
    if (cr.cr)
        return Parser.crToNumber(cr.cr, opts);

    const parts = cr.trim().split("/");
    if (!parts.length || parts.length >= 3)
        return isDefaultNull ? null : VeCt.CR_CUSTOM;
    if (isNaN(parts[0]))
        return isDefaultNull ? null : VeCt.CR_CUSTOM;

    if (parts.length === 2) {
        if (isNaN(Number(parts[1])))
            return isDefaultNull ? null : VeCt.CR_CUSTOM;
        return Number(parts[0]) / Number(parts[1]);
    }

    return Number(parts[0]);
}
;

Parser.numberToCr = function(number, safe) {
    if (safe && typeof number === "string" && Parser.CRS.includes(number))
        return number;

    if (number == null)
        return "Unknown";

    return Parser.numberToFractional(number);
}
;

Parser.crToPb = function(cr) {
    if (cr === "Unknown" || cr == null)
        return 0;
    cr = cr.cr || cr;
    if (Parser.crToNumber(cr) < 5)
        return 2;
    return Math.ceil(cr / 4) + 1;
}
;

Parser.levelToPb = function(level) {
    if (!level)
        return 2;
    return Math.ceil(level / 4) + 1;
}
;
Parser.SKILL_TO_ATB_ABV = {
    "athletics": "str",
    "acrobatics": "dex",
    "sleight of hand": "dex",
    "stealth": "dex",
    "arcana": "int",
    "history": "int",
    "investigation": "int",
    "nature": "int",
    "religion": "int",
    "animal handling": "wis",
    "insight": "wis",
    "medicine": "wis",
    "perception": "wis",
    "survival": "wis",
    "deception": "cha",
    "intimidation": "cha",
    "performance": "cha",
    "persuasion": "cha",
};


Parser.skillToAbilityAbv = function(skill) {
    return Parser._parse_aToB(Parser.SKILL_TO_ATB_ABV, skill);
}
;

Parser.SKILL_TO_SHORT = {
    "athletics": "ath",
    "acrobatics": "acro",
    "sleight of hand": "soh",
    "stealth": "slth",
    "arcana": "arc",
    "history": "hist",
    "investigation": "invn",
    "nature": "natr",
    "religion": "reli",
    "animal handling": "hndl",
    "insight": "ins",
    "medicine": "med",
    "perception": "perp",
    "survival": "surv",
    "deception": "decp",
    "intimidation": "intm",
    "performance": "perf",
    "persuasion": "pers",
};

Parser.skillToShort = function(skill) {
    return Parser._parse_aToB(Parser.SKILL_TO_SHORT, skill);
}
;

Parser.LANGUAGES_STANDARD = ["Common", "Dwarvish", "Elvish", "Giant", "Gnomish", "Goblin", "Halfling", "Orc", ];

Parser.LANGUAGES_EXOTIC = ["Abyssal", "Aquan", "Auran", "Celestial", "Draconic", "Deep Speech", "Ignan", "Infernal", "Primordial", "Sylvan", "Terran", "Undercommon", ];

Parser.LANGUAGES_SECRET = ["Druidic", "Thieves' cant", ];

Parser.LANGUAGES_ALL = [...Parser.LANGUAGES_STANDARD, ...Parser.LANGUAGES_EXOTIC, ...Parser.LANGUAGES_SECRET, ].sort();

Parser.acToFull = function(ac, renderer) {
    if (typeof ac === "string")
        return ac;
    renderer = renderer || Renderer.get();

    let stack = "";
    let inBraces = false;
    for (let i = 0; i < ac.length; ++i) {
        const cur = ac[i];
        const nxt = ac[i + 1];

        if (cur.special != null) {
            if (inBraces)
                inBraces = false;

            stack += cur.special;
        } else if (cur.ac) {
            const isNxtBraces = nxt && nxt.braces;

            if (!inBraces && cur.braces) {
                stack += "(";
                inBraces = true;
            }

            stack += cur.ac;

            if (cur.from) {
                if (cur.braces) {
                    stack += " (";
                } else {
                    stack += inBraces ? "; " : " (";
                }

                inBraces = true;

                stack += cur.from.map(it=>renderer.render(it)).join(", ");

                if (cur.braces) {
                    stack += ")";
                } else if (!isNxtBraces) {
                    stack += ")";
                    inBraces = false;
                }
            }

            if (cur.condition)
                stack += ` ${renderer.render(cur.condition)}`;

            if (inBraces && !isNxtBraces) {
                stack += ")";
                inBraces = false;
            }
        } else {
            stack += cur;
        }

        if (nxt) {
            if (nxt.braces) {
                stack += inBraces ? "; " : " (";
                inBraces = true;
            } else
                stack += ", ";
        }
    }
    if (inBraces)
        stack += ")";

    return stack.trim();
}
;

Parser.MONSTER_COUNT_TO_XP_MULTIPLIER = [1, 1.5, 2, 2, 2, 2, 2.5, 2.5, 2.5, 2.5, 3, 3, 3, 3, 4];
Parser.numMonstersToXpMult = function(num, playerCount=3) {
    const baseVal = (()=>{
        if (num >= Parser.MONSTER_COUNT_TO_XP_MULTIPLIER.length)
            return 4;
        return Parser.MONSTER_COUNT_TO_XP_MULTIPLIER[num - 1];
    }
    )();

    if (playerCount < 3)
        return baseVal >= 3 ? baseVal + 1 : baseVal + 0.5;
    else if (playerCount > 5) {
        return baseVal === 4 ? 3 : baseVal - 0.5;
    } else
        return baseVal;
}
;

Parser.armorFullToAbv = function(armor) {
    return Parser._parse_bToA(Parser.ARMOR_ABV_TO_FULL, armor);
}
;

Parser.weaponFullToAbv = function(weapon) {
    return Parser._parse_bToA(Parser.WEAPON_ABV_TO_FULL, weapon);
}
;

Parser._getSourceStringFromSource = function(source) {
    if (source && source.source)
        return source.source;
    return source;
}
;
Parser._buildSourceCache = function(dict) {
    const out = {};
    Object.entries(dict).forEach(([k,v])=>out[k.toLowerCase()] = v);
    return out;
}
;
Parser._sourceJsonCache = null;
Parser.hasSourceJson = function(source) {
    Parser._sourceJsonCache = Parser._sourceJsonCache || Parser._buildSourceCache(Object.keys(Parser.SOURCE_JSON_TO_FULL).mergeMap(k=>({
        [k]: k
    })));
    return !!Parser._sourceJsonCache[source.toLowerCase()];
}
;
Parser._sourceFullCache = null;
Parser.hasSourceFull = function(source) {
    Parser._sourceFullCache = Parser._sourceFullCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_FULL);
    return !!Parser._sourceFullCache[source.toLowerCase()];
}
;
Parser._sourceAbvCache = null;
Parser.hasSourceAbv = function(source) {
    Parser._sourceAbvCache = Parser._sourceAbvCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_ABV);
    return !!Parser._sourceAbvCache[source.toLowerCase()];
}
;
Parser._sourceDateCache = null;
Parser.hasSourceDate = function(source) {
    Parser._sourceDateCache = Parser._sourceDateCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_DATE);
    return !!Parser._sourceDateCache[source.toLowerCase()];
}
;
Parser.sourceJsonToJson = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceJson(source))
        return Parser._sourceJsonCache[source.toLowerCase()];
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToSource(source).json;
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToSource(source).json;
    return source;
}
;
Parser.sourceJsonToFull = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceFull(source))
        return Parser._sourceFullCache[source.toLowerCase()].replace(/'/g, "\u2019");
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToFull(source).replace(/'/g, "\u2019");
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToFull(source).replace(/'/g, "\u2019");
    return Parser._parse_aToB(Parser.SOURCE_JSON_TO_FULL, source).replace(/'/g, "\u2019");
}
;
Parser.sourceJsonToFullCompactPrefix = function(source) {
    return Parser.sourceJsonToFull(source).replace(Parser.UA_PREFIX, Parser.UA_PREFIX_SHORT).replace(/^Unearthed Arcana (\d+): /, "UA$1: ").replace(Parser.AL_PREFIX, Parser.AL_PREFIX_SHORT).replace(Parser.PS_PREFIX, Parser.PS_PREFIX_SHORT);
}
;
Parser.sourceJsonToAbv = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceAbv(source))
        return Parser._sourceAbvCache[source.toLowerCase()];
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToAbv(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToAbv(source);
    return Parser._parse_aToB(Parser.SOURCE_JSON_TO_ABV, source);
}
;
Parser.sourceJsonToDate = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceDate(source))
        return Parser._sourceDateCache[source.toLowerCase()];
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToDate(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToDate(source);
    return Parser._parse_aToB(Parser.SOURCE_JSON_TO_DATE, source, null);
}
;

Parser.sourceJsonToColor = function(source) {
    return `source${Parser.sourceJsonToAbv(source)}`;
}
;

Parser.sourceJsonToStyle = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceJson(source))
        return "";
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToStyle(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToStyle(source);
    return "";
}
;

Parser.sourceJsonToStylePart = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceJson(source))
        return "";
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToStylePart(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToStylePart(source);
    return "";
}
;

Parser.stringToSlug = function(str) {
    return str.trim().toLowerCase().toAscii().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
}
;

Parser.stringToCasedSlug = function(str) {
    return str.toAscii().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
}
;

Parser.ITEM_SPELLCASTING_FOCUS_CLASSES = ["Artificer", "Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"];

Parser.itemValueToFull = function(item, opts={
    isShortForm: false,
    isSmallUnits: false
}) {
    return Parser._moneyToFull(item, "value", "valueMult", opts);
}
;

Parser.itemValueToFullMultiCurrency = function(item, opts={
    isShortForm: false,
    isSmallUnits: false
}) {
    return Parser._moneyToFullMultiCurrency(item, "value", "valueMult", opts);
}
;

Parser.itemVehicleCostsToFull = function(item, isShortForm) {
    return {
        travelCostFull: Parser._moneyToFull(item, "travelCost", "travelCostMult", {
            isShortForm
        }),
        shippingCostFull: Parser._moneyToFull(item, "shippingCost", "shippingCostMult", {
            isShortForm
        }),
    };
}
;

Parser.spellComponentCostToFull = function(item, isShortForm) {
    return Parser._moneyToFull(item, "cost", "costMult", {
        isShortForm
    });
}
;

Parser.vehicleCostToFull = function(item, isShortForm) {
    return Parser._moneyToFull(item, "cost", "costMult", {
        isShortForm
    });
}
;

Parser._moneyToFull = function(it, prop, propMult, opts={
    isShortForm: false,
    isSmallUnits: false
}) {
    if (it[prop] == null && it[propMult] == null)
        return "";
    if (it[prop] != null) {
        const {coin, mult} = Parser.getCurrencyAndMultiplier(it[prop], it.currencyConversion);
        return `${(it[prop] * mult).toLocaleString(undefined, {
            maximumFractionDigits: 5
        })}${opts.isSmallUnits ? `<span class="small ml-1">${coin}</span>` : ` ${coin}`}`;
    } else if (it[propMult] != null)
        return opts.isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;
    return "";
}
;

Parser._moneyToFullMultiCurrency = function(it, prop, propMult, {isShortForm, multiplier}={}) {
    if (it[prop]) {
        const conversionTable = Parser.getCurrencyConversionTable(it.currencyConversion);

        const simplified = it.currencyConversion ? CurrencyUtil.doSimplifyCoins({
            [conversionTable[0]?.coin || "cp"]: it[prop] * (multiplier ?? conversionTable[0]?.mult ?? 1),
        }, {
            currencyConversionId: it.currencyConversion,
        }, ) : CurrencyUtil.doSimplifyCoins({
            cp: it[prop] * (multiplier ?? 1),
        });

        return [...conversionTable].reverse().filter(meta=>simplified[meta.coin]).map(meta=>`${simplified[meta.coin].toLocaleString(undefined, {
            maximumFractionDigits: 5
        })} ${meta.coin}`).join(", ");
    }

    if (it[propMult])
        return isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;

    return "";
}
;

Parser.DEFAULT_CURRENCY_CONVERSION_TABLE = [{
    coin: "cp",
    mult: 1,
}, {
    coin: "sp",
    mult: 0.1,
}, {
    coin: "gp",
    mult: 0.01,
    isFallback: true,
}, ];
Parser.FULL_CURRENCY_CONVERSION_TABLE = [{
    coin: "cp",
    mult: 1,
}, {
    coin: "sp",
    mult: 0.1,
}, {
    coin: "ep",
    mult: 0.02,
}, {
    coin: "gp",
    mult: 0.01,
    isFallback: true,
}, {
    coin: "pp",
    mult: 0.001,
}, ];
Parser.getCurrencyConversionTable = function(currencyConversionId) {
    const fromPrerelease = currencyConversionId ? PrereleaseUtil.getMetaLookup("currencyConversions")?.[currencyConversionId] : null;
    const fromBrew = currencyConversionId ? BrewUtil2.getMetaLookup("currencyConversions")?.[currencyConversionId] : null;
    const conversionTable = fromPrerelease?.length ? fromPrerelease : fromBrew?.length ? fromBrew : Parser.DEFAULT_CURRENCY_CONVERSION_TABLE;
    if (conversionTable !== Parser.DEFAULT_CURRENCY_CONVERSION_TABLE)
        conversionTable.sort((a,b)=>SortUtil.ascSort(b.mult, a.mult));
    return conversionTable;
}
;
Parser.getCurrencyAndMultiplier = function(value, currencyConversionId) {
    const conversionTable = Parser.getCurrencyConversionTable(currencyConversionId);

    if (!value)
        return conversionTable.find(it=>it.isFallback) || conversionTable[0];
    if (conversionTable.length === 1)
        return conversionTable[0];
    if (!Number.isInteger(value) && value < conversionTable[0].mult)
        return conversionTable[0];

    for (let i = conversionTable.length - 1; i >= 0; --i) {
        if (Number.isInteger(value * conversionTable[i].mult))
            return conversionTable[i];
    }

    return conversionTable.last();
}
;

Parser.COIN_ABVS = ["cp", "sp", "ep", "gp", "pp"];
Parser.COIN_ABV_TO_FULL = {
    "cp": "copper pieces",
    "sp": "silver pieces",
    "ep": "electrum pieces",
    "gp": "gold pieces",
    "pp": "platinum pieces",
};
Parser.COIN_CONVERSIONS = [1, 10, 50, 100, 1000];

Parser.coinAbvToFull = function(coin) {
    return Parser._parse_aToB(Parser.COIN_ABV_TO_FULL, coin);
}
;

Parser.getDisplayCurrency = function(currency, {isDisplayEmpty=false}={}) {
    return [...Parser.COIN_ABVS].reverse().filter(abv=>isDisplayEmpty ? currency[abv] != null : currency[abv]).map(abv=>`${currency[abv].toLocaleString()} ${abv}`).join(", ");
}
;

Parser.itemWeightToFull = function(item, isShortForm) {
    if (item.weight) {
        if (Math.round(item.weight) === item.weight)
            return `${item.weight} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

        const integerPart = Math.floor(item.weight);

        const vulgarGlyph = Parser.numberToVulgar(item.weight - integerPart, {
            isFallbackOnFractional: false
        });
        if (vulgarGlyph)
            return `${integerPart || ""}${vulgarGlyph} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

        return `${(item.weight < 1 ? item.weight * 16 : item.weight).toLocaleString(undefined, {
            maximumFractionDigits: 5
        })} ${item.weight < 1 ? "oz" : "lb"}.${(item.weightNote ? ` ${item.weightNote}` : "")}`;
    }
    if (item.weightMult)
        return isShortForm ? `×${item.weightMult}` : `base weight ×${item.weightMult}`;
    return "";
}
;

Parser.ITEM_RECHARGE_TO_FULL = {
    round: "Every Round",
    restShort: "Short Rest",
    restLong: "Long Rest",
    dawn: "Dawn",
    dusk: "Dusk",
    midnight: "Midnight",
    week: "Week",
    month: "Month",
    year: "Year",
    decade: "Decade",
    century: "Century",
    special: "Special",
};
Parser.itemRechargeToFull = function(recharge) {
    return Parser._parse_aToB(Parser.ITEM_RECHARGE_TO_FULL, recharge);
}
;

Parser.ITEM_MISC_TAG_TO_FULL = {
    "CF/W": "Creates Food/Water",
    "TT": "Trinket Table",
};
Parser.itemMiscTagToFull = function(type) {
    return Parser._parse_aToB(Parser.ITEM_MISC_TAG_TO_FULL, type);
}
;

Parser._decimalSeparator = (0.1).toLocaleString().substring(1, 2);
Parser._numberCleanRegexp = Parser._decimalSeparator === "." ? new RegExp(/[\s,]*/g,"g") : new RegExp(/[\s.]*/g,"g");
Parser._costSplitRegexp = Parser._decimalSeparator === "." ? new RegExp(/(\d+(\.\d+)?)([csegp]p)/) : new RegExp(/(\d+(,\d+)?)([csegp]p)/);

Parser.coinValueToNumber = function(value) {
    if (!value)
        return 0;
    if (value === "Varies")
        return 0;

    value = value.replace(/\s*/, "").replace(Parser._numberCleanRegexp, "").toLowerCase();
    const m = Parser._costSplitRegexp.exec(value);
    if (!m)
        throw new Error(`Badly formatted value "${value}"`);
    const ixCoin = Parser.COIN_ABVS.indexOf(m[3]);
    if (!~ixCoin)
        throw new Error(`Unknown coin type "${m[3]}"`);
    return Number(m[1]) * Parser.COIN_CONVERSIONS[ixCoin];
}
;

Parser.weightValueToNumber = function(value) {
    if (!value)
        return 0;

    if (Number(value))
        return Number(value);
    else
        throw new Error(`Badly formatted value ${value}`);
}
;

Parser.dmgTypeToFull = function(dmgType) {
    return Parser._parse_aToB(Parser.DMGTYPE_JSON_TO_FULL, dmgType);
}
;

Parser.skillProficienciesToFull = function(skillProficiencies) {
    function renderSingle(skProf) {
        if (skProf.any) {
            skProf = MiscUtil.copyFast(skProf);
            skProf.choose = {
                "from": Object.keys(Parser.SKILL_TO_ATB_ABV),
                "count": skProf.any
            };
            delete skProf.any;
        }

        const keys = Object.keys(skProf).sort(SortUtil.ascSortLower);

        const ixChoose = keys.indexOf("choose");
        if (~ixChoose)
            keys.splice(ixChoose, 1);

        const baseStack = [];
        keys.filter(k=>skProf[k]).forEach(k=>baseStack.push(Renderer.get().render(`{@skill ${k.toTitleCase()}}`)));

        const chooseStack = [];
        if (~ixChoose) {
            const chObj = skProf.choose;
            if (chObj.from.length === 18) {
                chooseStack.push(`choose any ${!chObj.count || chObj.count === 1 ? "skill" : chObj.count}`);
            } else {
                chooseStack.push(`choose ${chObj.count || 1} from ${chObj.from.map(it=>Renderer.get().render(`{@skill ${it.toTitleCase()}}`)).joinConjunct(", ", " and ")}`);
            }
        }

        const base = baseStack.joinConjunct(", ", " and ");
        const choose = chooseStack.join("");
        if (baseStack.length && chooseStack.length)
            return `${base}; and ${choose}`;
        else if (baseStack.length)
            return base;
        else if (chooseStack.length)
            return choose;
    }

    return skillProficiencies.map(renderSingle).join(" <i>or</i> ");
}
;

Parser.spSchoolAndSubschoolsAbvsToFull = function(school, subschools) {
    if (!subschools || !subschools.length)
        return Parser.spSchoolAbvToFull(school);
    else
        return `${Parser.spSchoolAbvToFull(school)} (${subschools.map(sub=>Parser.spSchoolAbvToFull(sub)).join(", ")})`;
}
;

Parser.spSchoolAbvToFull = function(schoolOrSubschool) {
    const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_FULL, schoolOrSubschool);
    if (Parser.SP_SCHOOL_ABV_TO_FULL[schoolOrSubschool])
        return out;
    if (PrereleaseUtil.getMetaLookup("spellSchools")?.[schoolOrSubschool])
        return PrereleaseUtil.getMetaLookup("spellSchools")?.[schoolOrSubschool].full;
    if (BrewUtil2.getMetaLookup("spellSchools")?.[schoolOrSubschool])
        return BrewUtil2.getMetaLookup("spellSchools")?.[schoolOrSubschool].full;
    return out;
}
;

Parser.spSchoolAndSubschoolsAbvsShort = function(school, subschools) {
    if (!subschools || !subschools.length)
        return Parser.spSchoolAbvToShort(school);
    else
        return `${Parser.spSchoolAbvToShort(school)} (${subschools.map(sub=>Parser.spSchoolAbvToShort(sub)).join(", ")})`;
}
;

Parser.spSchoolAbvToShort = function(school) {
    const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_SHORT, school);
    if (Parser.SP_SCHOOL_ABV_TO_SHORT[school])
        return out;
    if (PrereleaseUtil.getMetaLookup("spellSchools")?.[school])
        return PrereleaseUtil.getMetaLookup("spellSchools")?.[school].short;
    if (BrewUtil2.getMetaLookup("spellSchools")?.[school])
        return BrewUtil2.getMetaLookup("spellSchools")?.[school].short;
    if (out.length <= 4)
        return out;
    return `${out.slice(0, 3)}.`;
}
;

Parser.spSchoolAbvToStyle = function(school) {
    const stylePart = Parser.spSchoolAbvToStylePart(school);
    if (!stylePart)
        return stylePart;
    return `style="${stylePart}"`;
}
;

Parser.spSchoolAbvToStylePart = function(school) {
    return Parser._spSchoolAbvToStylePart_prereleaseBrew({
        school,
        brewUtil: PrereleaseUtil
    }) || Parser._spSchoolAbvToStylePart_prereleaseBrew({
        school,
        brewUtil: BrewUtil2
    }) || "";
}
;

Parser._spSchoolAbvToStylePart_prereleaseBrew = function({school, brewUtil}) {
    const rawColor = brewUtil.getMetaLookup("spellSchools")?.[school]?.color;
    if (!rawColor || !rawColor.trim())
        return "";
    const validColor = BrewUtilShared.getValidColor(rawColor);
    if (validColor.length)
        return `color: #${validColor};`;
}
;

Parser.getOrdinalForm = function(i) {
    i = Number(i);
    if (isNaN(i))
        return "";
    const j = i % 10;
    const k = i % 100;
    if (j === 1 && k !== 11)
        return `${i}st`;
    if (j === 2 && k !== 12)
        return `${i}nd`;
    if (j === 3 && k !== 13)
        return `${i}rd`;
    return `${i}th`;
}
;

Parser.spLevelToFull = function(level) {
    if (level === 0)
        return "Cantrip";
    else
        return Parser.getOrdinalForm(level);
}
;

Parser.getArticle = function(str) {
    str = `${str}`;
    str = str.replace(/\d+/g, (...m)=>Parser.numberToText(m[0]));
    return /^[aeiou]/i.test(str) ? "an" : "a";
}
;

Parser.spLevelToFullLevelText = function(level, {isDash=false, isPluralCantrips=true}={}) {
    return `${Parser.spLevelToFull(level)}${(level === 0 ? (isPluralCantrips ? "s" : "") : `${isDash ? "-" : " "}level`)}`;
}
;

Parser.spLevelToSpellPoints = function(lvl) {
    lvl = Number(lvl);
    if (isNaN(lvl) || lvl === 0)
        return 0;
    return Math.ceil(1.34 * lvl);
}
;

Parser.spMetaToArr = function(meta) {
    if (!meta)
        return [];
    return Object.entries(meta).filter(([_,v])=>v).sort(SortUtil.ascSort).map(([k])=>k);
}
;

Parser.spMetaToFull = function(meta) {
    if (!meta)
        return "";
    const metaTags = Parser.spMetaToArr(meta);
    if (metaTags.length)
        return ` (${metaTags.join(", ")})`;
    return "";
}
;

Parser.spLevelSchoolMetaToFull = function(level, school, meta, subschools) {
    const levelPart = level === 0 ? Parser.spLevelToFull(level).toLowerCase() : `${Parser.spLevelToFull(level)}-level`;
    const levelSchoolStr = level === 0 ? `${Parser.spSchoolAbvToFull(school)} ${levelPart}` : `${levelPart} ${Parser.spSchoolAbvToFull(school).toLowerCase()}`;

    const metaArr = Parser.spMetaToArr(meta);
    if (metaArr.length || (subschools && subschools.length)) {
        const metaAndSubschoolPart = [(subschools || []).map(sub=>Parser.spSchoolAbvToFull(sub)).join(", "), metaArr.join(", "), ].filter(Boolean).join("; ").toLowerCase();
        return `${levelSchoolStr} (${metaAndSubschoolPart})`;
    }
    return levelSchoolStr;
}
;

Parser.spTimeListToFull = function(times, isStripTags) {
    return times.map(t=>`${Parser.getTimeToFull(t)}${t.condition ? `, ${isStripTags ? Renderer.stripTags(t.condition) : Renderer.get().render(t.condition)}` : ""}`).join(" or ");
}
;

Parser.getTimeToFull = function(time) {
    return `${time.number ? `${time.number} ` : ""}${time.unit === "bonus" ? "bonus action" : time.unit}${time.number > 1 ? "s" : ""}`;
}
;

Parser.getMinutesToFull = function(mins) {
    const days = Math.floor(mins / (24 * 60));
    mins = mins % (24 * 60);

    const hours = Math.floor(mins / 60);
    mins = mins % 60;

    return [days ? `${days} day${days > 1 ? "s" : ""}` : null, hours ? `${hours} hour${hours > 1 ? "s" : ""}` : null, mins ? `${mins} minute${mins > 1 ? "s" : ""}` : null, ].filter(Boolean).join(" ");
}
;

Parser.RNG_SPECIAL = "special";
Parser.RNG_POINT = "point";
Parser.RNG_LINE = "line";
Parser.RNG_CUBE = "cube";
Parser.RNG_CONE = "cone";
Parser.RNG_RADIUS = "radius";
Parser.RNG_SPHERE = "sphere";
Parser.RNG_HEMISPHERE = "hemisphere";
Parser.RNG_CYLINDER = "cylinder";
Parser.RNG_SELF = "self";
Parser.RNG_SIGHT = "sight";
Parser.RNG_UNLIMITED = "unlimited";
Parser.RNG_UNLIMITED_SAME_PLANE = "plane";
Parser.RNG_TOUCH = "touch";
Parser.SP_RANGE_TYPE_TO_FULL = {
    [Parser.RNG_SPECIAL]: "Special",
    [Parser.RNG_POINT]: "Point",
    [Parser.RNG_LINE]: "Line",
    [Parser.RNG_CUBE]: "Cube",
    [Parser.RNG_CONE]: "Cone",
    [Parser.RNG_RADIUS]: "Radius",
    [Parser.RNG_SPHERE]: "Sphere",
    [Parser.RNG_HEMISPHERE]: "Hemisphere",
    [Parser.RNG_CYLINDER]: "Cylinder",
    [Parser.RNG_SELF]: "Self",
    [Parser.RNG_SIGHT]: "Sight",
    [Parser.RNG_UNLIMITED]: "Unlimited",
    [Parser.RNG_UNLIMITED_SAME_PLANE]: "Unlimited on the same plane",
    [Parser.RNG_TOUCH]: "Touch",
};

Parser.spRangeTypeToFull = function(range) {
    return Parser._parse_aToB(Parser.SP_RANGE_TYPE_TO_FULL, range);
}
;

Parser.UNT_FEET = "feet";
Parser.UNT_YARDS = "yards";
Parser.UNT_MILES = "miles";
Parser.SP_DIST_TYPE_TO_FULL = {
    [Parser.UNT_FEET]: "Feet",
    [Parser.UNT_YARDS]: "Yards",
    [Parser.UNT_MILES]: "Miles",
    [Parser.RNG_SELF]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_SELF],
    [Parser.RNG_TOUCH]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_TOUCH],
    [Parser.RNG_SIGHT]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_SIGHT],
    [Parser.RNG_UNLIMITED]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_UNLIMITED],
    [Parser.RNG_UNLIMITED_SAME_PLANE]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_UNLIMITED_SAME_PLANE],
};

Parser.spDistanceTypeToFull = function(range) {
    return Parser._parse_aToB(Parser.SP_DIST_TYPE_TO_FULL, range);
}
;

Parser.SP_RANGE_TO_ICON = {
    [Parser.RNG_SPECIAL]: "fa-star",
    [Parser.RNG_POINT]: "",
    [Parser.RNG_LINE]: "fa-grip-lines-vertical",
    [Parser.RNG_CUBE]: "fa-cube",
    [Parser.RNG_CONE]: "fa-traffic-cone",
    [Parser.RNG_RADIUS]: "fa-hockey-puck",
    [Parser.RNG_SPHERE]: "fa-globe",
    [Parser.RNG_HEMISPHERE]: "fa-globe",
    [Parser.RNG_CYLINDER]: "fa-database",
    [Parser.RNG_SELF]: "fa-street-view",
    [Parser.RNG_SIGHT]: "fa-eye",
    [Parser.RNG_UNLIMITED_SAME_PLANE]: "fa-globe-americas",
    [Parser.RNG_UNLIMITED]: "fa-infinity",
    [Parser.RNG_TOUCH]: "fa-hand-paper",
};

Parser.spRangeTypeToIcon = function(range) {
    return Parser._parse_aToB(Parser.SP_RANGE_TO_ICON, range);
}
;

Parser.spRangeToShortHtml = function(range) {
    switch (range.type) {
    case Parser.RNG_SPECIAL:
        return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="Special"></span>`;
    case Parser.RNG_POINT:
        return Parser.spRangeToShortHtml._renderPoint(range);
    case Parser.RNG_LINE:
    case Parser.RNG_CUBE:
    case Parser.RNG_CONE:
    case Parser.RNG_RADIUS:
    case Parser.RNG_SPHERE:
    case Parser.RNG_HEMISPHERE:
    case Parser.RNG_CYLINDER:
        return Parser.spRangeToShortHtml._renderArea(range);
    }
}
;
Parser.spRangeToShortHtml._renderPoint = function(range) {
    const dist = range.distance;
    switch (dist.type) {
    case Parser.RNG_SELF:
    case Parser.RNG_SIGHT:
    case Parser.RNG_UNLIMITED:
    case Parser.RNG_UNLIMITED_SAME_PLANE:
    case Parser.RNG_SPECIAL:
    case Parser.RNG_TOUCH:
        return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(dist.type)} help-subtle" title="${Parser.spRangeTypeToFull(dist.type)}"></span>`;
    case Parser.UNT_FEET:
    case Parser.UNT_YARDS:
    case Parser.UNT_MILES:
    default:
        return `${dist.amount} <span class="ve-small">${Parser.getSingletonUnit(dist.type, true)}</span>`;
    }
}
;
Parser.spRangeToShortHtml._renderArea = function(range) {
    const size = range.distance;
    return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(Parser.RNG_SELF)} help-subtle" title="Self"></span> ${size.amount}<span class="ve-small">-${Parser.getSingletonUnit(size.type, true)}</span> ${Parser.spRangeToShortHtml._getAreaStyleString(range)}`;
}
;
Parser.spRangeToShortHtml._getAreaStyleString = function(range) {
    return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="${Parser.spRangeTypeToFull(range.type)}"></span>`;
}
;

Parser.spRangeToFull = function(range) {
    switch (range.type) {
    case Parser.RNG_SPECIAL:
        return Parser.spRangeTypeToFull(range.type);
    case Parser.RNG_POINT:
        return Parser.spRangeToFull._renderPoint(range);
    case Parser.RNG_LINE:
    case Parser.RNG_CUBE:
    case Parser.RNG_CONE:
    case Parser.RNG_RADIUS:
    case Parser.RNG_SPHERE:
    case Parser.RNG_HEMISPHERE:
    case Parser.RNG_CYLINDER:
        return Parser.spRangeToFull._renderArea(range);
    }
}
;
Parser.spRangeToFull._renderPoint = function(range) {
    const dist = range.distance;
    switch (dist.type) {
    case Parser.RNG_SELF:
    case Parser.RNG_SIGHT:
    case Parser.RNG_UNLIMITED:
    case Parser.RNG_UNLIMITED_SAME_PLANE:
    case Parser.RNG_SPECIAL:
    case Parser.RNG_TOUCH:
        return Parser.spRangeTypeToFull(dist.type);
    case Parser.UNT_FEET:
    case Parser.UNT_YARDS:
    case Parser.UNT_MILES:
    default:
        return `${dist.amount} ${dist.amount === 1 ? Parser.getSingletonUnit(dist.type) : dist.type}`;
    }
}
;
Parser.spRangeToFull._renderArea = function(range) {
    const size = range.distance;
    return `Self (${size.amount}-${Parser.getSingletonUnit(size.type)}${Parser.spRangeToFull._getAreaStyleString(range)}${range.type === Parser.RNG_CYLINDER ? `${size.amountSecondary != null && size.typeSecondary != null ? `, ${size.amountSecondary}-${Parser.getSingletonUnit(size.typeSecondary)}-high` : ""} cylinder` : ""})`;
}
;
Parser.spRangeToFull._getAreaStyleString = function(range) {
    switch (range.type) {
    case Parser.RNG_SPHERE:
        return " radius";
    case Parser.RNG_HEMISPHERE:
        return `-radius ${range.type}`;
    case Parser.RNG_CYLINDER:
        return "-radius";
    default:
        return ` ${range.type}`;
    }
}
;

Parser.getSingletonUnit = function(unit, isShort) {
    switch (unit) {
    case Parser.UNT_FEET:
        return isShort ? "ft." : "foot";
    case Parser.UNT_YARDS:
        return isShort ? "yd." : "yard";
    case Parser.UNT_MILES:
        return isShort ? "mi." : "mile";
    default:
        {
            const fromPrerelease = Parser._getSingletonUnit_prereleaseBrew({
                unit,
                isShort,
                brewUtil: PrereleaseUtil
            });
            if (fromPrerelease)
                return fromPrerelease;

            const fromBrew = Parser._getSingletonUnit_prereleaseBrew({
                unit,
                isShort,
                brewUtil: BrewUtil2
            });
            if (fromBrew)
                return fromBrew;

            if (unit.charAt(unit.length - 1) === "s")
                return unit.slice(0, -1);
            return unit;
        }
    }
}
;

Parser._getSingletonUnit_prereleaseBrew = function({unit, isShort, brewUtil}) {
    const fromBrew = brewUtil.getMetaLookup("spellDistanceUnits")?.[unit]?.["singular"];
    if (fromBrew)
        return fromBrew;
}
;

Parser.RANGE_TYPES = [{
    type: Parser.RNG_POINT,
    hasDistance: true,
    isRequireAmount: false
},
{
    type: Parser.RNG_LINE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_CUBE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_CONE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_RADIUS,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_SPHERE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_HEMISPHERE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_CYLINDER,
    hasDistance: true,
    isRequireAmount: true
},
{
    type: Parser.RNG_SPECIAL,
    hasDistance: false,
    isRequireAmount: false
}, ];

Parser.DIST_TYPES = [{
    type: Parser.RNG_SELF,
    hasAmount: false
}, {
    type: Parser.RNG_TOUCH,
    hasAmount: false
},
{
    type: Parser.UNT_FEET,
    hasAmount: true
}, {
    type: Parser.UNT_YARDS,
    hasAmount: true
}, {
    type: Parser.UNT_MILES,
    hasAmount: true
},
{
    type: Parser.RNG_SIGHT,
    hasAmount: false
}, {
    type: Parser.RNG_UNLIMITED_SAME_PLANE,
    hasAmount: false
}, {
    type: Parser.RNG_UNLIMITED,
    hasAmount: false
}, ];

Parser.spComponentsToFull = function(comp, level, {isPlainText=false}={}) {
    if (!comp)
        return "None";
    const out = [];
    if (comp.v)
        out.push("V");
    if (comp.s)
        out.push("S");
    if (comp.m != null) {
        const fnRender = isPlainText ? Renderer.stripTags.bind(Renderer) : Renderer.get().render.bind(Renderer.get());
        out.push(`M${comp.m !== true ? ` (${fnRender(comp.m.text != null ? comp.m.text : comp.m)})` : ""}`);
    }
    if (comp.r)
        out.push(`R (${level} gp)`);
    return out.join(", ") || "None";
}
;

Parser.SP_END_TYPE_TO_FULL = {
    "dispel": "dispelled",
    "trigger": "triggered",
    "discharge": "discharged",
};
Parser.spEndTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.SP_END_TYPE_TO_FULL, type);
}
;

Parser.spDurationToFull = function(dur) {
    let hasSubOr = false;
    const outParts = dur.map(d=>{
        switch (d.type) {
        case "special":
            return "Special";
        case "instant":
            return `Instantaneous${d.condition ? ` (${d.condition})` : ""}`;
        case "timed":
            return `${d.concentration ? "Concentration, " : ""}${d.concentration ? "u" : d.duration.upTo ? "U" : ""}${d.concentration || d.duration.upTo ? "p to " : ""}${d.duration.amount} ${d.duration.amount === 1 ? d.duration.type : `${d.duration.type}s`}`;
        case "permanent":
            {
                if (d.ends) {
                    const endsToJoin = d.ends.map(m=>Parser.spEndTypeToFull(m));
                    hasSubOr = hasSubOr || endsToJoin.length > 1;
                    return `Until ${endsToJoin.joinConjunct(", ", " or ")}`;
                } else {
                    return "Permanent";
                }
            }
        }
    }
    );
    return `${outParts.joinConjunct(hasSubOr ? "; " : ", ", " or ")}${dur.length > 1 ? " (see below)" : ""}`;
}
;

Parser.DURATION_TYPES = [{
    type: "instant",
    full: "Instantaneous"
}, {
    type: "timed",
    hasAmount: true
}, {
    type: "permanent",
    hasEnds: true
}, {
    type: "special"
}, ];

Parser.DURATION_AMOUNT_TYPES = ["turn", "round", "minute", "hour", "day", "week", "year", ];

Parser.spClassesToFull = function(sp, {isTextOnly=false, subclassLookup={}}={}) {
    const fromSubclassList = Renderer.spell.getCombinedClasses(sp, "fromSubclass");
    const fromSubclasses = Parser.spSubclassesToFull(fromSubclassList, { isTextOnly, subclassLookup });
    const fromClassList = Renderer.spell.getCombinedClasses(sp, "fromClassList");
    return `${Parser.spMainClassesToFull(fromClassList, { isTextOnly })}${fromSubclasses ? `, ${fromSubclasses}` : ""}`;
};

Parser.spMainClassesToFull = function(fromClassList, {isTextOnly=false}={}) {
    return fromClassList.map(c=>({
        hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](c),
        c
    })).filter(it=>!ExcludeUtil.isInitialised || !ExcludeUtil.isExcluded(it.hash, "class", it.c.source)).sort((a,b)=>SortUtil.ascSort(a.c.name, b.c.name)).map(it=>{
        if (isTextOnly)
            return it.c.name;

        return `<span title="${it.c.definedInSource ? `Class source` : "Source"}: ${Parser.sourceJsonToFull(it.c.source)}${it.c.definedInSource ? `. Spell list defined in: ${Parser.sourceJsonToFull(it.c.definedInSource)}.` : ""}">${Renderer.get().render(`{@class ${it.c.name}|${it.c.source}}`)}</span>`;
    }
    ).join(", ") || "";
}
;

Parser.spSubclassesToFull = function(fromSubclassList, {isTextOnly=false, subclassLookup={}}={}) {
    return fromSubclassList.filter(mt=>{
        if (!ExcludeUtil.isInitialised)
            return true;
        const excludeClass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](mt.class), "class", mt.class.source);
        if (excludeClass)
            return false;

        return !ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
            shortName: mt.subclass.name,
            source: mt.subclass.source,
            className: mt.class.name,
            classSource: mt.class.source,
        }), "subclass", mt.subclass.source, {
            isNoCount: true
        }, );
    }
    ).sort((a,b)=>{
        const byName = SortUtil.ascSort(a.class.name, b.class.name);
        return byName || SortUtil.ascSort(a.subclass.name, b.subclass.name);
    }
    ).map(c=>Parser._spSubclassItem({
        fromSubclass: c,
        isTextOnly
    })).join(", ") || "";
}
;

Parser._spSubclassItem = function({fromSubclass, isTextOnly}) {
    const c = fromSubclass.class;
    const sc = fromSubclass.subclass;
    const text = `${sc.shortName}${sc.subSubclass ? ` (${sc.subSubclass})` : ""}`;
    if (isTextOnly)
        return text;

    const classPart = `<span title="Source: ${Parser.sourceJsonToFull(c.source)}${c.definedInSource ? ` From a class spell list defined in: ${Parser.sourceJsonToFull(c.definedInSource)}` : ""}">${Renderer.get().render(`{@class ${c.name}|${c.source}}`)}</span>`;

    return `<span class="italic" title="Source: ${Parser.sourceJsonToFull(fromSubclass.subclass.source)}">${Renderer.get().render(`{@class ${c.name}|${c.source}|${text}|${sc.shortName}|${sc.source}}`)}</span> ${classPart}`;
}
;

Parser.SPELL_ATTACK_TYPE_TO_FULL = {};
Parser.SPELL_ATTACK_TYPE_TO_FULL["M"] = "Melee";
Parser.SPELL_ATTACK_TYPE_TO_FULL["R"] = "Ranged";
Parser.SPELL_ATTACK_TYPE_TO_FULL["O"] = "Other/Unknown";

Parser.spAttackTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.SPELL_ATTACK_TYPE_TO_FULL, type);
}
;

Parser.SPELL_AREA_TYPE_TO_FULL = {
    ST: "Single Target",
    MT: "Multiple Targets",
    C: "Cube",
    N: "Cone",
    Y: "Cylinder",
    S: "Sphere",
    R: "Circle",
    Q: "Square",
    L: "Line",
    H: "Hemisphere",
    W: "Wall",
};
Parser.spAreaTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.SPELL_AREA_TYPE_TO_FULL, type);
}
;

Parser.SP_MISC_TAG_TO_FULL = {
    HL: "Healing",
    THP: "Grants Temporary Hit Points",
    SGT: "Requires Sight",
    PRM: "Permanent Effects",
    SCL: "Scaling Effects",
    SMN: "Summons Creature",
    MAC: "Modifies AC",
    TP: "Teleportation",
    FMV: "Forced Movement",
    RO: "Rollable Effects",
    LGTS: "Creates Sunlight",
    LGT: "Creates Light",
    UBA: "Uses Bonus Action",
    PS: "Plane Shifting",
    OBS: "Obscures Vision",
    DFT: "Difficult Terrain",
    AAD: "Additional Attack Damage",
    OBJ: "Affects Objects",
    ADV: "Grants Advantage",
};
Parser.spMiscTagToFull = function(type) {
    return Parser._parse_aToB(Parser.SP_MISC_TAG_TO_FULL, type);
}
;

Parser.SP_CASTER_PROGRESSION_TO_FULL = {
    full: "Full",
    "1/2": "Half",
    "1/3": "One-Third",
    "pact": "Pact Magic",
};
Parser.spCasterProgressionToFull = function(type) {
    return Parser._parse_aToB(Parser.SP_CASTER_PROGRESSION_TO_FULL, type);
}
;

Parser.monTypeToFullObj = function(type) {
    const out = {
        types: [],
        tags: [],
        asText: "",
        asTextShort: "",

        typeSidekick: null,
        tagsSidekick: [],
        asTextSidekick: null,
    };

    if (typeof type === "string") {
        out.types = [type];
        out.asText = type.toTitleCase();
        out.asTextShort = out.asText;
        return out;
    }

    if (type.type?.choose) {
        out.types = type.type.choose;
    } else {
        out.types = [type.type];
    }

    if (type.swarmSize) {
        out.tags.push("swarm");
        out.asText = `swarm of ${Parser.sizeAbvToFull(type.swarmSize)} ${out.types.map(typ=>Parser.monTypeToPlural(typ).toTitleCase()).joinConjunct(", ", " or ")}`;
        out.asTextShort = out.asText;
        out.swarmSize = type.swarmSize;
    } else {
        out.asText = out.types.map(typ=>typ.toTitleCase()).joinConjunct(", ", " or ");
        out.asTextShort = out.asText;
    }

    const tagMetas = Parser.monTypeToFullObj._getTagMetas(type.tags);
    if (tagMetas.length) {
        out.tags.push(...tagMetas.map(({filterTag})=>filterTag));
        const ptTags = ` (${tagMetas.map(({displayTag})=>displayTag).join(", ")})`;
        out.asText += ptTags;
        out.asTextShort += ptTags;
    }

    if (type.note)
        out.asText += ` ${type.note}`;

    if (type.sidekickType) {
        out.typeSidekick = type.sidekickType;
        if (!type.sidekickHidden)
            out.asTextSidekick = `${type.sidekickType}`;

        const tagMetas = Parser.monTypeToFullObj._getTagMetas(type.sidekickTags);
        if (tagMetas.length) {
            out.tagsSidekick.push(...tagMetas.map(({filterTag})=>filterTag));
            if (!type.sidekickHidden)
                out.asTextSidekick += ` (${tagMetas.map(({displayTag})=>displayTag).join(", ")})`;
        }
    }

    return out;
}
;

Parser.monTypeToFullObj._getTagMetas = (tags)=>{
    return tags ? tags.map(tag=>{
        if (typeof tag === "string") {
            return {
                filterTag: tag.toLowerCase(),
                displayTag: tag.toTitleCase(),
            };
        } else {
            return {
                filterTag: tag.tag.toLowerCase(),
                displayTag: `${tag.prefix} ${tag.tag}`.toTitleCase(),
            };
        }
    }
    ) : [];
}
;

Parser.monTypeToPlural = function(type) {
    return Parser._parse_aToB(Parser.MON_TYPE_TO_PLURAL, type);
}
;

Parser.monTypeFromPlural = function(type) {
    return Parser._parse_bToA(Parser.MON_TYPE_TO_PLURAL, type);
}
;

Parser.monCrToFull = function(cr, {xp=null, isMythic=false}={}) {
    if (cr == null)
        return "";

    if (typeof cr === "string") {
        if (Parser.crToNumber(cr) >= VeCt.CR_CUSTOM)
            return `${cr}${xp != null ? ` (${xp} XP)` : ""}`;

        xp = xp != null ? Parser._addCommas(xp) : Parser.crToXp(cr);
        return `${cr} (${xp} XP${isMythic ? `, or ${Parser.crToXp(cr, {
            isDouble: true
        })} XP as a mythic encounter` : ""})`;
    } else {
        const stack = [Parser.monCrToFull(cr.cr, {
            xp: cr.xp,
            isMythic
        })];
        if (cr.lair)
            stack.push(`${Parser.monCrToFull(cr.lair)} when encountered in lair`);
        if (cr.coven)
            stack.push(`${Parser.monCrToFull(cr.coven)} when part of a coven`);
        return stack.joinConjunct(", ", " or ");
    }
}
;

Parser.getFullImmRes = function(toParse) {
    if (!toParse?.length)
        return "";

    let maxDepth = 0;

    function toString(it, depth=0) {
        maxDepth = Math.max(maxDepth, depth);
        if (typeof it === "string") {
            return it;
        } else if (it.special) {
            return it.special;
        } else {
            const stack = [];

            if (it.preNote)
                stack.push(it.preNote);

            const prop = it.immune ? "immune" : it.resist ? "resist" : it.vulnerable ? "vulnerable" : null;
            if (prop) {
                const toJoin = it[prop].length === Parser.DMG_TYPES.length && CollectionUtil.deepEquals(Parser.DMG_TYPES, it[prop]) ? ["all damage"] : it[prop].map(nxt=>toString(nxt, depth + 1));
                stack.push(depth ? toJoin.join(maxDepth ? "; " : ", ") : toJoin.joinConjunct(", ", " and "));
            }

            if (it.note)
                stack.push(it.note);

            return stack.join(" ");
        }
    }

    const arr = toParse.map(it=>toString(it));

    if (arr.length <= 1)
        return arr.join("");

    let out = "";
    for (let i = 0; i < arr.length - 1; ++i) {
        const it = arr[i];
        const nxt = arr[i + 1];

        const orig = toParse[i];
        const origNxt = toParse[i + 1];

        out += it;
        out += (it.includes(",") || nxt.includes(",") || (orig && orig.cond) || (origNxt && origNxt.cond)) ? "; " : ", ";
    }
    out += arr.last();
    return out;
}
;

Parser.getFullCondImm = function(condImm, {isPlainText=false, isEntry=false}={}) {
    if (isPlainText && isEntry)
        throw new Error(`Options "isPlainText" and "isEntry" are mutually exclusive!`);

    if (!condImm?.length)
        return "";

    const render = condition=>{
        if (isPlainText)
            return condition;
        const ent = `{@condition ${condition}}`;
        if (isEntry)
            return ent;
        return Renderer.get().render(ent);
    }
    ;

    return condImm.map(it=>{
        if (it.special)
            return it.special;
        if (it.conditionImmune)
            return `${it.preNote ? `${it.preNote} ` : ""}${it.conditionImmune.map(render).join(", ")}${it.note ? ` ${it.note}` : ""}`;
        return render(it);
    }
    ).sort(SortUtil.ascSortLower).join(", ");
}
;

Parser.MON_SENSE_TAG_TO_FULL = {
    "B": "blindsight",
    "D": "darkvision",
    "SD": "superior darkvision",
    "T": "tremorsense",
    "U": "truesight",
};
Parser.monSenseTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_SENSE_TAG_TO_FULL, tag);
}
;

Parser.MON_SPELLCASTING_TAG_TO_FULL = {
    "P": "Psionics",
    "I": "Innate",
    "F": "Form Only",
    "S": "Shared",
    "O": "Other",
    "CA": "Class, Artificer",
    "CB": "Class, Bard",
    "CC": "Class, Cleric",
    "CD": "Class, Druid",
    "CP": "Class, Paladin",
    "CR": "Class, Ranger",
    "CS": "Class, Sorcerer",
    "CL": "Class, Warlock",
    "CW": "Class, Wizard",
};
Parser.monSpellcastingTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_SPELLCASTING_TAG_TO_FULL, tag);
}
;

Parser.MON_MISC_TAG_TO_FULL = {
    "AOE": "Has Areas of Effect",
    "HPR": "Has HP Reduction",
    "MW": "Has Weapon Attacks, Melee",
    "RW": "Has Weapon Attacks, Ranged",
    "MLW": "Has Melee Weapons",
    "RNG": "Has Ranged Weapons",
    "RCH": "Has Reach Attacks",
    "THW": "Has Thrown Weapons",
};
Parser.monMiscTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_MISC_TAG_TO_FULL, tag);
}
;

Parser.MON_LANGUAGE_TAG_TO_FULL = {
    "AB": "Abyssal",
    "AQ": "Aquan",
    "AU": "Auran",
    "C": "Common",
    "CE": "Celestial",
    "CS": "Can't Speak Known Languages",
    "D": "Dwarvish",
    "DR": "Draconic",
    "DS": "Deep Speech",
    "DU": "Druidic",
    "E": "Elvish",
    "G": "Gnomish",
    "GI": "Giant",
    "GO": "Goblin",
    "GTH": "Gith",
    "H": "Halfling",
    "I": "Infernal",
    "IG": "Ignan",
    "LF": "Languages Known in Life",
    "O": "Orc",
    "OTH": "Other",
    "P": "Primordial",
    "S": "Sylvan",
    "T": "Terran",
    "TC": "Thieves' cant",
    "TP": "Telepathy",
    "U": "Undercommon",
    "X": "Any (Choose)",
    "XX": "All",
};
Parser.monLanguageTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_LANGUAGE_TAG_TO_FULL, tag);
}
;

Parser.ENVIRONMENTS = ["arctic", "coastal", "desert", "forest", "grassland", "hill", "mountain", "swamp", "underdark", "underwater", "urban"];

Parser.PSI_ABV_TYPE_TALENT = "T";
Parser.PSI_ABV_TYPE_DISCIPLINE = "D";
Parser.PSI_ORDER_NONE = "None";
Parser.psiTypeToFull = type=>Parser.psiTypeToMeta(type).full;

Parser.psiTypeToMeta = type=>{
    let out = {};
    if (type === Parser.PSI_ABV_TYPE_TALENT)
        out = {
            hasOrder: false,
            full: "Talent"
        };
    else if (type === Parser.PSI_ABV_TYPE_DISCIPLINE)
        out = {
            hasOrder: true,
            full: "Discipline"
        };
    else if (PrereleaseUtil.getMetaLookup("psionicTypes")?.[type])
        out = MiscUtil.copyFast(PrereleaseUtil.getMetaLookup("psionicTypes")[type]);
    else if (BrewUtil2.getMetaLookup("psionicTypes")?.[type])
        out = MiscUtil.copyFast(BrewUtil2.getMetaLookup("psionicTypes")[type]);
    out.full = out.full || "Unknown";
    out.short = out.short || out.full;
    return out;
}
;

Parser.psiOrderToFull = (order)=>{
    return order === undefined ? Parser.PSI_ORDER_NONE : order;
}
;

Parser.prereqSpellToFull = function(spell, {isTextOnly=false}={}) {
    if (spell) {
        const [text,suffix] = spell.split("#");
        if (!suffix)
            return isTextOnly ? spell : Renderer.get().render(`{@spell ${spell}}`);
        else if (suffix === "c")
            return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))(`{@spell ${text}} cantrip`);
        else if (suffix === "x")
            return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))("{@spell hex} spell or a warlock feature that curses");
    } else
        return VeCt.STR_NONE;
}
;

Parser.prereqPactToFull = function(pact) {
    if (pact === "Chain")
        return "Pact of the Chain";
    if (pact === "Tome")
        return "Pact of the Tome";
    if (pact === "Blade")
        return "Pact of the Blade";
    if (pact === "Talisman")
        return "Pact of the Talisman";
    return pact;
}
;

Parser.prereqPatronToShort = function(patron) {
    if (patron === "Any")
        return patron;
    const mThe = /^The (.*?)$/.exec(patron);
    if (mThe)
        return mThe[1];
    return patron;
}
;

Parser.OPT_FEATURE_TYPE_TO_FULL = {
    AI: "Artificer Infusion",
    ED: "Elemental Discipline",
    EI: "Eldritch Invocation",
    MM: "Metamagic",
    "MV": "Maneuver",
    "MV:B": "Maneuver, Battle Master",
    "MV:C2-UA": "Maneuver, Cavalier V2 (UA)",
    "AS:V1-UA": "Arcane Shot, V1 (UA)",
    "AS:V2-UA": "Arcane Shot, V2 (UA)",
    "AS": "Arcane Shot",
    OTH: "Other",
    "FS:F": "Fighting Style; Fighter",
    "FS:B": "Fighting Style; Bard",
    "FS:P": "Fighting Style; Paladin",
    "FS:R": "Fighting Style; Ranger",
    "PB": "Pact Boon",
    "OR": "Onomancy Resonant",
    "RN": "Rune Knight Rune",
    "AF": "Alchemical Formula",
};

Parser.optFeatureTypeToFull = function(type) {
    if (Parser.OPT_FEATURE_TYPE_TO_FULL[type])
        return Parser.OPT_FEATURE_TYPE_TO_FULL[type];
    if (PrereleaseUtil.getMetaLookup("optionalFeatureTypes")?.[type])
        return PrereleaseUtil.getMetaLookup("optionalFeatureTypes")[type];
    if (BrewUtil2.getMetaLookup("optionalFeatureTypes")?.[type])
        return BrewUtil2.getMetaLookup("optionalFeatureTypes")[type];
    return type;
}
;

Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL = {
    "SG": "Supernatural Gift",
    "OF": "Optional Feature",
    "DG": "Dark Gift",
    "RF:B": "Replacement Feature: Background",
    "CS": "Character Secret",
};

Parser.charCreationOptionTypeToFull = function(type) {
    if (Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type])
        return Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type];
    if (PrereleaseUtil.getMetaLookup("charOption")?.[type])
        return PrereleaseUtil.getMetaLookup("charOption")[type];
    if (BrewUtil2.getMetaLookup("charOption")?.[type])
        return BrewUtil2.getMetaLookup("charOption")[type];
    return type;
}
;

Parser.alignmentAbvToFull = function(alignment) {
    if (!alignment)
        return null;
    if (typeof alignment === "object") {
        if (alignment.special != null) {
            return alignment.special;
        } else {
            return `${alignment.alignment.map(a=>Parser.alignmentAbvToFull(a)).join(" ")}${alignment.chance ? ` (${alignment.chance}%)` : ""}${alignment.note ? ` (${alignment.note})` : ""}`;
        }
    } else {
        alignment = alignment.toUpperCase();
        switch (alignment) {
        case "L":
            return "lawful";
        case "N":
            return "neutral";
        case "NX":
            return "neutral (law/chaos axis)";
        case "NY":
            return "neutral (good/evil axis)";
        case "C":
            return "chaotic";
        case "G":
            return "good";
        case "E":
            return "evil";
        case "U":
            return "unaligned";
        case "A":
            return "any alignment";
        }
        return alignment;
    }
}
;

Parser.alignmentListToFull = function(alignList) {
    if (!alignList)
        return "";
    if (alignList.some(it=>typeof it !== "string")) {
        if (alignList.some(it=>typeof it === "string"))
            throw new Error(`Mixed alignment types: ${JSON.stringify(alignList)}`);
        alignList = alignList.filter(it=>it.alignment === undefined || it.alignment != null);
        return alignList.map(it=>it.special != null || it.chance != null || it.note != null ? Parser.alignmentAbvToFull(it) : Parser.alignmentListToFull(it.alignment)).join(" or ");
    } else {
        if (alignList.length === 1)
            return Parser.alignmentAbvToFull(alignList[0]);
        if (alignList.length === 2) {
            return alignList.map(a=>Parser.alignmentAbvToFull(a)).join(" ");
        }
        if (alignList.length === 3) {
            if (alignList.includes("NX") && alignList.includes("NY") && alignList.includes("N"))
                return "any neutral alignment";
        }
        if (alignList.length === 5) {
            if (!alignList.includes("G"))
                return "any non-good alignment";
            if (!alignList.includes("E"))
                return "any non-evil alignment";
            if (!alignList.includes("L"))
                return "any non-lawful alignment";
            if (!alignList.includes("C"))
                return "any non-chaotic alignment";
        }
        if (alignList.length === 4) {
            if (!alignList.includes("L") && !alignList.includes("NX"))
                return "any chaotic alignment";
            if (!alignList.includes("G") && !alignList.includes("NY"))
                return "any evil alignment";
            if (!alignList.includes("C") && !alignList.includes("NX"))
                return "any lawful alignment";
            if (!alignList.includes("E") && !alignList.includes("NY"))
                return "any good alignment";
        }
        throw new Error(`Unmapped alignment: ${JSON.stringify(alignList)}`);
    }
}
;

Parser.weightToFull = function(lbs, isSmallUnit) {
    const tons = Math.floor(lbs / 2000);
    lbs = lbs - (2000 * tons);
    return [tons ? `${tons}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}ton${tons === 1 ? "" : "s"}${isSmallUnit ? `</span>` : ""}` : null, lbs ? `${lbs}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}lb.${isSmallUnit ? `</span>` : ""}` : null, ].filter(Boolean).join(", ");
}
;

Parser.RARITIES = ["common", "uncommon", "rare", "very rare", "legendary", "artifact"];
Parser.ITEM_RARITIES = ["none", ...Parser.RARITIES, "unknown", "unknown (magic)", "other"];

Parser.CAT_ID_CREATURE = 1;
Parser.CAT_ID_SPELL = 2;
Parser.CAT_ID_BACKGROUND = 3;
Parser.CAT_ID_ITEM = 4;
Parser.CAT_ID_CLASS = 5;
Parser.CAT_ID_CONDITION = 6;
Parser.CAT_ID_FEAT = 7;
Parser.CAT_ID_ELDRITCH_INVOCATION = 8;
Parser.CAT_ID_PSIONIC = 9;
Parser.CAT_ID_RACE = 10;
Parser.CAT_ID_OTHER_REWARD = 11;
Parser.CAT_ID_VARIANT_OPTIONAL_RULE = 12;
Parser.CAT_ID_ADVENTURE = 13;
Parser.CAT_ID_DEITY = 14;
Parser.CAT_ID_OBJECT = 15;
Parser.CAT_ID_TRAP = 16;
Parser.CAT_ID_HAZARD = 17;
Parser.CAT_ID_QUICKREF = 18;
Parser.CAT_ID_CULT = 19;
Parser.CAT_ID_BOON = 20;
Parser.CAT_ID_DISEASE = 21;
Parser.CAT_ID_METAMAGIC = 22;
Parser.CAT_ID_MANEUVER_BATTLEMASTER = 23;
Parser.CAT_ID_TABLE = 24;
Parser.CAT_ID_TABLE_GROUP = 25;
Parser.CAT_ID_MANEUVER_CAVALIER = 26;
Parser.CAT_ID_ARCANE_SHOT = 27;
Parser.CAT_ID_OPTIONAL_FEATURE_OTHER = 28;
Parser.CAT_ID_FIGHTING_STYLE = 29;
Parser.CAT_ID_CLASS_FEATURE = 30;
Parser.CAT_ID_VEHICLE = 31;
Parser.CAT_ID_PACT_BOON = 32;
Parser.CAT_ID_ELEMENTAL_DISCIPLINE = 33;
Parser.CAT_ID_ARTIFICER_INFUSION = 34;
Parser.CAT_ID_SHIP_UPGRADE = 35;
Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE = 36;
Parser.CAT_ID_ONOMANCY_RESONANT = 37;
Parser.CAT_ID_RUNE_KNIGHT_RUNE = 37;
Parser.CAT_ID_ALCHEMICAL_FORMULA = 38;
Parser.CAT_ID_MANEUVER = 39;
Parser.CAT_ID_SUBCLASS = 40;
Parser.CAT_ID_SUBCLASS_FEATURE = 41;
Parser.CAT_ID_ACTION = 42;
Parser.CAT_ID_LANGUAGE = 43;
Parser.CAT_ID_BOOK = 44;
Parser.CAT_ID_PAGE = 45;
Parser.CAT_ID_LEGENDARY_GROUP = 46;
Parser.CAT_ID_CHAR_CREATION_OPTIONS = 47;
Parser.CAT_ID_RECIPES = 48;
Parser.CAT_ID_STATUS = 49;
Parser.CAT_ID_SKILLS = 50;
Parser.CAT_ID_SENSES = 51;
Parser.CAT_ID_DECK = 52;
Parser.CAT_ID_CARD = 53;

Parser.CAT_ID_TO_FULL = {};
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CREATURE] = "Bestiary";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SPELL] = "Spell";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BACKGROUND] = "Background";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ITEM] = "Item";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS] = "Class";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CONDITION] = "Condition";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FEAT] = "Feat";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELDRITCH_INVOCATION] = "Eldritch Invocation";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PSIONIC] = "Psionic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RACE] = "Race";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OTHER_REWARD] = "Other Reward";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "Variant/Optional Rule";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ADVENTURE] = "Adventure";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DEITY] = "Deity";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OBJECT] = "Object";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TRAP] = "Trap";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_HAZARD] = "Hazard";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_QUICKREF] = "Quick Reference";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CULT] = "Cult";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOON] = "Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DISEASE] = "Disease";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_METAMAGIC] = "Metamagic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "Maneuver; Battlemaster";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE_GROUP] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_CAVALIER] = "Maneuver; Cavalier";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARCANE_SHOT] = "Arcane Shot";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "Optional Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FIGHTING_STYLE] = "Fighting Style";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS_FEATURE] = "Class Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VEHICLE] = "Vehicle";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PACT_BOON] = "Pact Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "Elemental Discipline";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARTIFICER_INFUSION] = "Infusion";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SHIP_UPGRADE] = "Ship Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "Infernal War Machine Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ONOMANCY_RESONANT] = "Onomancy Resonant";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "Rune Knight Rune";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "Alchemical Formula";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER] = "Maneuver";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS] = "Subclass";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS_FEATURE] = "Subclass Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ACTION] = "Action";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LANGUAGE] = "Language";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOOK] = "Book";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PAGE] = "Page";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LEGENDARY_GROUP] = "Legendary Group";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "Character Creation Option";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RECIPES] = "Recipe";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_STATUS] = "Status";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DECK] = "Deck";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CARD] = "Card";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SKILLS] = "Skill";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SENSES] = "Sense";

Parser.pageCategoryToFull = function(catId) {
    return Parser._parse_aToB(Parser.CAT_ID_TO_FULL, catId);
}
;

Parser.CAT_ID_TO_PROP = {};
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CREATURE] = "monster";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SPELL] = "spell";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BACKGROUND] = "background";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ITEM] = "item";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS] = "class";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CONDITION] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FEAT] = "feat";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PSIONIC] = "psionic";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RACE] = "race";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OTHER_REWARD] = "reward";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "variantrule";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ADVENTURE] = "adventure";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DEITY] = "deity";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OBJECT] = "object";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TRAP] = "trap";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_HAZARD] = "hazard";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CULT] = "cult";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOON] = "boon";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DISEASE] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE] = "table";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE_GROUP] = "tableGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VEHICLE] = "vehicle";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELDRITCH_INVOCATION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_CAVALIER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARCANE_SHOT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FIGHTING_STYLE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_METAMAGIC] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PACT_BOON] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARTIFICER_INFUSION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SHIP_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ONOMANCY_RESONANT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_QUICKREF] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS_FEATURE] = "classFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS] = "subclass";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ACTION] = "action";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LANGUAGE] = "language";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOOK] = "book";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PAGE] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "charoption";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RECIPES] = "recipe";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_STATUS] = "status";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DECK] = "deck";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CARD] = "card";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SKILLS] = "skill";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SENSES] = "sense";

Parser.pageCategoryToProp = function(catId) {
    return Parser._parse_aToB(Parser.CAT_ID_TO_PROP, catId);
}
;

Parser.ABIL_ABVS = ["str", "dex", "con", "int", "wis", "cha"];

Parser.spClassesToCurrentAndLegacy = function(fromClassList) {
    const current = [];
    const legacy = [];
    fromClassList.forEach(cls=>{
        if ((cls.name === "Artificer" && cls.source === "UAArtificer") || (cls.name === "Artificer (Revisited)" && cls.source === "UAArtificerRevisited"))
            legacy.push(cls);
        else
            current.push(cls);
    }
    );
    return [current, legacy];
}
;

Parser.spSubclassesToCurrentAndLegacyFull = function(sp, subclassLookup) {
    return Parser._spSubclassesToCurrentAndLegacyFull({
        sp,
        subclassLookup,
        prop: "fromSubclass"
    });
}
;

Parser.spVariantSubclassesToCurrentAndLegacyFull = function(sp, subclassLookup) {
    return Parser._spSubclassesToCurrentAndLegacyFull({
        sp,
        subclassLookup,
        prop: "fromSubclassVariant"
    });
}
;

Parser._spSubclassesToCurrentAndLegacyFull = ({sp, subclassLookup, prop})=>{
    const fromSubclass = Renderer.spell.getCombinedClasses(sp, prop);
    if (!fromSubclass.length)
        return ["", ""];

    const current = [];
    const legacy = [];
    const curNames = new Set();
    const toCheck = [];
    fromSubclass.filter(c=>{
        const excludeClass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
            name: c.class.name,
            source: c.class.source
        }), "class", c.class.source, {
            isNoCount: true
        }, );
        if (excludeClass)
            return false;

        const excludeSubclass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
            shortName: c.subclass.shortName,
            source: c.subclass.source,
            className: c.class.name,
            classSource: c.class.source,
        }), "subclass", c.subclass.source, {
            isNoCount: true
        }, );
        if (excludeSubclass)
            return false;

        return !Renderer.spell.isExcludedSubclassVariantSource({
            classDefinedInSource: c.class.definedInSource
        });
    }
    ).sort((a,b)=>{
        const byName = SortUtil.ascSort(a.subclass.name, b.subclass.name);
        return byName || SortUtil.ascSort(a.class.name, b.class.name);
    }
    ).forEach(c=>{
        const nm = c.subclass.name;
        const src = c.subclass.source;

        const toAdd = Parser._spSubclassItem({
            fromSubclass: c,
            isTextOnly: false
        });

        const fromLookup = MiscUtil.get(subclassLookup, c.class.source, c.class.name, c.subclass.source, c.subclass.name, );

        if (fromLookup && fromLookup.isReprinted) {
            legacy.push(toAdd);
        } else if (SourceUtil.isNonstandardSource(src)) {
            const cleanName = Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent(nm.split("(")[0].trim().split(/v\d+/)[0].trim(), );
            toCheck.push({
                "name": cleanName,
                "ele": toAdd
            });
        } else {
            current.push(toAdd);
            curNames.add(nm);
        }
    }
    );

    toCheck.forEach(n=>{
        if (curNames.has(n.name)) {
            legacy.push(n.ele);
        } else {
            current.push(n.ele);
        }
    }
    );

    return [current.join(", "), legacy.join(", ")];
}
;

Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent = (shortName)=>{
    switch (shortName) {
    case "Favored Soul":
        return "Divine Soul";
    case "Undying Light":
        return "Celestial";
    case "Deep Stalker":
        return "Gloom Stalker";
    }
    return shortName;
}
;

Parser.spVariantClassesToCurrentAndLegacy = function(fromVariantClassList) {
    const current = [];
    const legacy = [];
    fromVariantClassList.forEach(cls=>{
        if (SourceUtil.isPrereleaseSource(cls.definedInSource))
            legacy.push(cls);
        else
            current.push(cls);
    }
    );
    return [current, legacy];
}
;

Parser.attackTypeToFull = function(attackType) {
    return Parser._parse_aToB(Parser.ATK_TYPE_TO_FULL, attackType);
}
;

Parser.trapHazTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.TRAP_HAZARD_TYPE_TO_FULL, type);
}
;

Parser.TRAP_HAZARD_TYPE_TO_FULL = {
    MECH: "Mechanical Trap",
    MAG: "Magical Trap",
    SMPL: "Simple Trap",
    CMPX: "Complex Trap",
    HAZ: "Hazard",
    WTH: "Weather",
    ENV: "Environmental Hazard",
    WLD: "Wilderness Hazard",
    GEN: "Generic",
    EST: "Eldritch Storm",
};

Parser.tierToFullLevel = function(tier) {
    return Parser._parse_aToB(Parser.TIER_TO_FULL_LEVEL, tier);
}
;

Parser.TIER_TO_FULL_LEVEL = {};
Parser.TIER_TO_FULL_LEVEL[1] = "1st\u20134th Level";
Parser.TIER_TO_FULL_LEVEL[2] = "5th\u201310th Level";
Parser.TIER_TO_FULL_LEVEL[3] = "11th\u201316th Level";
Parser.TIER_TO_FULL_LEVEL[4] = "17th\u201320th Level";

Parser.trapInitToFull = function(init) {
    return Parser._parse_aToB(Parser.TRAP_INIT_TO_FULL, init);
}
;

Parser.TRAP_INIT_TO_FULL = {};
Parser.TRAP_INIT_TO_FULL[1] = "initiative count 10";
Parser.TRAP_INIT_TO_FULL[2] = "initiative count 20";
Parser.TRAP_INIT_TO_FULL[3] = "initiative count 20 and initiative count 10";

Parser.ATK_TYPE_TO_FULL = {};
Parser.ATK_TYPE_TO_FULL["MW"] = "Melee Weapon Attack";
Parser.ATK_TYPE_TO_FULL["RW"] = "Ranged Weapon Attack";

Parser.bookOrdinalToAbv = (ordinal,preNoSuff)=>{
    if (ordinal === undefined)
        return "";
    switch (ordinal.type) {
    case "part":
        return `${preNoSuff ? " " : ""}Part ${ordinal.identifier}${preNoSuff ? "" : " \u2014 "}`;
    case "chapter":
        return `${preNoSuff ? " " : ""}Ch. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
    case "episode":
        return `${preNoSuff ? " " : ""}Ep. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
    case "appendix":
        return `${preNoSuff ? " " : ""}App.${ordinal.identifier != null ? ` ${ordinal.identifier}` : ""}${preNoSuff ? "" : ": "}`;
    case "level":
        return `${preNoSuff ? " " : ""}Level ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
    default:
        throw new Error(`Unhandled ordinal type "${ordinal.type}"`);
    }
}
;

Parser.IMAGE_TYPE_TO_FULL = {
    "map": "Map",
    "mapPlayer": "Map (Player)",
};
Parser.imageTypeToFull = function(imageType) {
    return Parser._parse_aToB(Parser.IMAGE_TYPE_TO_FULL, imageType, "Other");
}
;

Parser.nameToTokenName = function(name) {
    return name.toAscii().replace(/"/g, "");
}
;

Parser.bytesToHumanReadable = function(bytes, {fixedDigits=2}={}) {
    if (bytes == null)
        return "";
    if (!bytes)
        return "0 B";
    const e = Math.floor(Math.log(bytes) / Math.log(1024));
    return `${(bytes / Math.pow(1024, e)).toFixed(fixedDigits)} ${`\u200bKMGTP`.charAt(e)}B`;
}
;

Parser.SKL_ABV_ABJ = "A";
Parser.SKL_ABV_EVO = "V";
Parser.SKL_ABV_ENC = "E";
Parser.SKL_ABV_ILL = "I";
Parser.SKL_ABV_DIV = "D";
Parser.SKL_ABV_NEC = "N";
Parser.SKL_ABV_TRA = "T";
Parser.SKL_ABV_CON = "C";
Parser.SKL_ABV_PSI = "P";
Parser.SKL_ABVS = [Parser.SKL_ABV_ABJ, Parser.SKL_ABV_CON, Parser.SKL_ABV_DIV, Parser.SKL_ABV_ENC, Parser.SKL_ABV_EVO, Parser.SKL_ABV_ILL, Parser.SKL_ABV_NEC, Parser.SKL_ABV_PSI, Parser.SKL_ABV_TRA, ];

Parser.SP_TM_ACTION = "action";
Parser.SP_TM_B_ACTION = "bonus";
Parser.SP_TM_REACTION = "reaction";
Parser.SP_TM_ROUND = "round";
Parser.SP_TM_MINS = "minute";
Parser.SP_TM_HRS = "hour";
Parser.SP_TIME_SINGLETONS = [Parser.SP_TM_ACTION, Parser.SP_TM_B_ACTION, Parser.SP_TM_REACTION, Parser.SP_TM_ROUND];
Parser.SP_TIME_TO_FULL = {
    [Parser.SP_TM_ACTION]: "Action",
    [Parser.SP_TM_B_ACTION]: "Bonus Action",
    [Parser.SP_TM_REACTION]: "Reaction",
    [Parser.SP_TM_ROUND]: "Rounds",
    [Parser.SP_TM_MINS]: "Minutes",
    [Parser.SP_TM_HRS]: "Hours",
};
Parser.spTimeUnitToFull = function(timeUnit) {
    return Parser._parse_aToB(Parser.SP_TIME_TO_FULL, timeUnit);
}
;

Parser.SP_TIME_TO_SHORT = {
    [Parser.SP_TM_ROUND]: "Rnd.",
    [Parser.SP_TM_MINS]: "Min.",
    [Parser.SP_TM_HRS]: "Hr.",
};
Parser.spTimeUnitToShort = function(timeUnit) {
    return Parser._parse_aToB(Parser.SP_TIME_TO_SHORT, timeUnit);
}
;

Parser.SP_TIME_TO_ABV = {
    [Parser.SP_TM_ACTION]: "A",
    [Parser.SP_TM_B_ACTION]: "BA",
    [Parser.SP_TM_REACTION]: "R",
    [Parser.SP_TM_ROUND]: "rnd",
    [Parser.SP_TM_MINS]: "min",
    [Parser.SP_TM_HRS]: "hr",
};
Parser.spTimeUnitToAbv = function(timeUnit) {
    return Parser._parse_aToB(Parser.SP_TIME_TO_ABV, timeUnit);
}
;

Parser.spTimeToShort = function(time, isHtml) {
    if (!time)
        return "";
    return (time.number === 1 && Parser.SP_TIME_SINGLETONS.includes(time.unit)) ? `${Parser.spTimeUnitToAbv(time.unit).uppercaseFirst()}${time.condition ? "*" : ""}` : `${time.number} ${isHtml ? `<span class="ve-small">` : ""}${Parser.spTimeUnitToAbv(time.unit)}${isHtml ? `</span>` : ""}${time.condition ? "*" : ""}`;
}
;

Parser.SKL_ABJ = "Abjuration";
Parser.SKL_EVO = "Evocation";
Parser.SKL_ENC = "Enchantment";
Parser.SKL_ILL = "Illusion";
Parser.SKL_DIV = "Divination";
Parser.SKL_NEC = "Necromancy";
Parser.SKL_TRA = "Transmutation";
Parser.SKL_CON = "Conjuration";
Parser.SKL_PSI = "Psionic";

Parser.SP_SCHOOL_ABV_TO_FULL = {};
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ABJ] = Parser.SKL_ABJ;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_EVO] = Parser.SKL_EVO;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ENC] = Parser.SKL_ENC;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ILL] = Parser.SKL_ILL;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_DIV] = Parser.SKL_DIV;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_NEC] = Parser.SKL_NEC;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_TRA] = Parser.SKL_TRA;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_CON] = Parser.SKL_CON;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_PSI] = Parser.SKL_PSI;

Parser.SP_SCHOOL_ABV_TO_SHORT = {};
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ABJ] = "Abj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_EVO] = "Evoc.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ENC] = "Ench.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ILL] = "Illu.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_DIV] = "Divin.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_NEC] = "Necro.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_TRA] = "Trans.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_CON] = "Conj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_PSI] = "Psi.";

Parser.ATB_ABV_TO_FULL = {
    "str": "Strength",
    "dex": "Dexterity",
    "con": "Constitution",
    "int": "Intelligence",
    "wis": "Wisdom",
    "cha": "Charisma",
};

Parser.TP_ABERRATION = "aberration";
Parser.TP_BEAST = "beast";
Parser.TP_CELESTIAL = "celestial";
Parser.TP_CONSTRUCT = "construct";
Parser.TP_DRAGON = "dragon";
Parser.TP_ELEMENTAL = "elemental";
Parser.TP_FEY = "fey";
Parser.TP_FIEND = "fiend";
Parser.TP_GIANT = "giant";
Parser.TP_HUMANOID = "humanoid";
Parser.TP_MONSTROSITY = "monstrosity";
Parser.TP_OOZE = "ooze";
Parser.TP_PLANT = "plant";
Parser.TP_UNDEAD = "undead";
Parser.MON_TYPES = [Parser.TP_ABERRATION, Parser.TP_BEAST, Parser.TP_CELESTIAL, Parser.TP_CONSTRUCT, Parser.TP_DRAGON, Parser.TP_ELEMENTAL, Parser.TP_FEY, Parser.TP_FIEND, Parser.TP_GIANT, Parser.TP_HUMANOID, Parser.TP_MONSTROSITY, Parser.TP_OOZE, Parser.TP_PLANT, Parser.TP_UNDEAD];
Parser.MON_TYPE_TO_PLURAL = {};
Parser.MON_TYPE_TO_PLURAL[Parser.TP_ABERRATION] = "aberrations";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_BEAST] = "beasts";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_CELESTIAL] = "celestials";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_CONSTRUCT] = "constructs";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_DRAGON] = "dragons";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_ELEMENTAL] = "elementals";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_FEY] = "fey";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_FIEND] = "fiends";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_GIANT] = "giants";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_HUMANOID] = "humanoids";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_MONSTROSITY] = "monstrosities";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_OOZE] = "oozes";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_PLANT] = "plants";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_UNDEAD] = "undead";

Parser.SZ_FINE = "F";
Parser.SZ_DIMINUTIVE = "D";
Parser.SZ_TINY = "T";
Parser.SZ_SMALL = "S";
Parser.SZ_MEDIUM = "M";
Parser.SZ_LARGE = "L";
Parser.SZ_HUGE = "H";
Parser.SZ_GARGANTUAN = "G";
Parser.SZ_COLOSSAL = "C";
Parser.SZ_VARIES = "V";
Parser.SIZE_ABVS = [Parser.SZ_TINY, Parser.SZ_SMALL, Parser.SZ_MEDIUM, Parser.SZ_LARGE, Parser.SZ_HUGE, Parser.SZ_GARGANTUAN, Parser.SZ_VARIES];
Parser.SIZE_ABV_TO_FULL = {};
Parser.SIZE_ABV_TO_FULL[Parser.SZ_FINE] = "Fine";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_DIMINUTIVE] = "Diminutive";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_TINY] = "Tiny";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_SMALL] = "Small";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_MEDIUM] = "Medium";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_LARGE] = "Large";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_HUGE] = "Huge";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_GARGANTUAN] = "Gargantuan";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_COLOSSAL] = "Colossal";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_VARIES] = "Varies";

Parser.XP_CHART_ALT = {
    "0": 10,
    "1/8": 25,
    "1/4": 50,
    "1/2": 100,
    "1": 200,
    "2": 450,
    "3": 700,
    "4": 1100,
    "5": 1800,
    "6": 2300,
    "7": 2900,
    "8": 3900,
    "9": 5000,
    "10": 5900,
    "11": 7200,
    "12": 8400,
    "13": 10000,
    "14": 11500,
    "15": 13000,
    "16": 15000,
    "17": 18000,
    "18": 20000,
    "19": 22000,
    "20": 25000,
    "21": 33000,
    "22": 41000,
    "23": 50000,
    "24": 62000,
    "25": 75000,
    "26": 90000,
    "27": 105000,
    "28": 120000,
    "29": 135000,
    "30": 155000,
};

Parser.ARMOR_ABV_TO_FULL = {
    "l.": "light",
    "m.": "medium",
    "h.": "heavy",
};

Parser.WEAPON_ABV_TO_FULL = {
    "s.": "simple",
    "m.": "martial",
};

Parser.CONDITION_TO_COLOR = {
    "Blinded": "#525252",
    "Charmed": "#f01789",
    "Deafened": "#ababab",
    "Exhausted": "#947a47",
    "Frightened": "#c9ca18",
    "Grappled": "#8784a0",
    "Incapacitated": "#3165a0",
    "Invisible": "#7ad2d6",
    "Paralyzed": "#c00900",
    "Petrified": "#a0a0a0",
    "Poisoned": "#4dc200",
    "Prone": "#5e60a0",
    "Restrained": "#d98000",
    "Stunned": "#a23bcb",
    "Unconscious": "#3a40ad",

    "Concentration": "#009f7a",
};

Parser.RULE_TYPE_TO_FULL = {
    "O": "Optional",
    "P": "Prerelease",
    "V": "Variant",
    "VO": "Variant Optional",
    "VV": "Variant Variant",
    "U": "Unknown",
};

Parser.ruleTypeToFull = function(ruleType) {
    return Parser._parse_aToB(Parser.RULE_TYPE_TO_FULL, ruleType);
}
;

Parser.VEHICLE_TYPE_TO_FULL = {
    "SHIP": "Ship",
    "SPELLJAMMER": "Spelljammer Ship",
    "INFWAR": "Infernal War Machine",
    "CREATURE": "Creature",
    "OBJECT": "Object",
    "SHP:H": "Ship Upgrade, Hull",
    "SHP:M": "Ship Upgrade, Movement",
    "SHP:W": "Ship Upgrade, Weapon",
    "SHP:F": "Ship Upgrade, Figurehead",
    "SHP:O": "Ship Upgrade, Miscellaneous",
    "IWM:W": "Infernal War Machine Variant, Weapon",
    "IWM:A": "Infernal War Machine Upgrade, Armor",
    "IWM:G": "Infernal War Machine Upgrade, Gadget",
};

Parser.vehicleTypeToFull = function(vehicleType) {
    return Parser._parse_aToB(Parser.VEHICLE_TYPE_TO_FULL, vehicleType);
}
;

Parser.SRC_5ETOOLS_TMP = "Parser.SRC_5ETOOLS_TMP";
Parser.SRC_CoS = "CoS";
Parser.SRC_DMG = "DMG";
Parser.SRC_EEPC = "EEPC";
Parser.SRC_EET = "EET";
Parser.SRC_HotDQ = "HotDQ";
Parser.SRC_LMoP = "LMoP";
Parser.SRC_MM = "MM";
Parser.SRC_OotA = "OotA";
Parser.SRC_PHB = "PHB";
Parser.SRC_PotA = "PotA";
Parser.SRC_RoT = "RoT";
Parser.SRC_RoTOS = "RoTOS";
Parser.SRC_SCAG = "SCAG";
Parser.SRC_SKT = "SKT";
Parser.SRC_ToA = "ToA";
Parser.SRC_TLK = "TLK";
Parser.SRC_ToD = "ToD";
Parser.SRC_TTP = "TTP";
Parser.SRC_TYP = "TftYP";
Parser.SRC_TYP_AtG = "TftYP-AtG";
Parser.SRC_TYP_DiT = "TftYP-DiT";
Parser.SRC_TYP_TFoF = "TftYP-TFoF";
Parser.SRC_TYP_THSoT = "TftYP-THSoT";
Parser.SRC_TYP_TSC = "TftYP-TSC";
Parser.SRC_TYP_ToH = "TftYP-ToH";
Parser.SRC_TYP_WPM = "TftYP-WPM";
Parser.SRC_VGM = "VGM";
Parser.SRC_XGE = "XGE";
Parser.SRC_OGA = "OGA";
Parser.SRC_MTF = "MTF";
Parser.SRC_WDH = "WDH";
Parser.SRC_WDMM = "WDMM";
Parser.SRC_GGR = "GGR";
Parser.SRC_KKW = "KKW";
Parser.SRC_LLK = "LLK";
Parser.SRC_AZfyT = "AZfyT";
Parser.SRC_GoS = "GoS";
Parser.SRC_AI = "AI";
Parser.SRC_OoW = "OoW";
Parser.SRC_ESK = "ESK";
Parser.SRC_DIP = "DIP";
Parser.SRC_HftT = "HftT";
Parser.SRC_DC = "DC";
Parser.SRC_SLW = "SLW";
Parser.SRC_SDW = "SDW";
Parser.SRC_BGDIA = "BGDIA";
Parser.SRC_LR = "LR";
Parser.SRC_AL = "AL";
Parser.SRC_SAC = "SAC";
Parser.SRC_ERLW = "ERLW";
Parser.SRC_EFR = "EFR";
Parser.SRC_RMBRE = "RMBRE";
Parser.SRC_RMR = "RMR";
Parser.SRC_MFF = "MFF";
Parser.SRC_AWM = "AWM";
Parser.SRC_IMR = "IMR";
Parser.SRC_SADS = "SADS";
Parser.SRC_EGW = "EGW";
Parser.SRC_EGW_ToR = "ToR";
Parser.SRC_EGW_DD = "DD";
Parser.SRC_EGW_FS = "FS";
Parser.SRC_EGW_US = "US";
Parser.SRC_MOT = "MOT";
Parser.SRC_IDRotF = "IDRotF";
Parser.SRC_TCE = "TCE";
Parser.SRC_VRGR = "VRGR";
Parser.SRC_HoL = "HoL";
Parser.SRC_XMtS = "XMtS";
Parser.SRC_RtG = "RtG";
Parser.SRC_AitFR = "AitFR";
Parser.SRC_AitFR_ISF = "AitFR-ISF";
Parser.SRC_AitFR_THP = "AitFR-THP";
Parser.SRC_AitFR_AVT = "AitFR-AVT";
Parser.SRC_AitFR_DN = "AitFR-DN";
Parser.SRC_AitFR_FCD = "AitFR-FCD";
Parser.SRC_WBtW = "WBtW";
Parser.SRC_DoD = "DoD";
Parser.SRC_MaBJoV = "MaBJoV";
Parser.SRC_FTD = "FTD";
Parser.SRC_SCC = "SCC";
Parser.SRC_SCC_CK = "SCC-CK";
Parser.SRC_SCC_HfMT = "SCC-HfMT";
Parser.SRC_SCC_TMM = "SCC-TMM";
Parser.SRC_SCC_ARiR = "SCC-ARiR";
Parser.SRC_MPMM = "MPMM";
Parser.SRC_CRCotN = "CRCotN";
Parser.SRC_JttRC = "JttRC";
Parser.SRC_SAiS = "SAiS";
Parser.SRC_AAG = "AAG";
Parser.SRC_BAM = "BAM";
Parser.SRC_LoX = "LoX";
Parser.SRC_DoSI = "DoSI";
Parser.SRC_DSotDQ = "DSotDQ";
Parser.SRC_KftGV = "KftGV";
Parser.SRC_BGG = "BGG";
Parser.SRC_TDCSR = "TDCSR";
Parser.SRC_PaBTSO = "PaBTSO";
Parser.SRC_PAitM = "PAitM";
Parser.SRC_SatO = "SatO";
Parser.SRC_ToFW = "ToFW";
Parser.SRC_MPP = "MPP";
Parser.SRC_BMT = "BMT";
Parser.SRC_GHLoE = "GHLoE";
Parser.SRC_DoDk = "DoDk";
Parser.SRC_SCREEN = "Screen";
Parser.SRC_SCREEN_WILDERNESS_KIT = "ScreenWildernessKit";
Parser.SRC_SCREEN_DUNGEON_KIT = "ScreenDungeonKit";
Parser.SRC_SCREEN_SPELLJAMMER = "ScreenSpelljammer";
Parser.SRC_HF = "HF";
Parser.SRC_HFFotM = "HFFotM";
Parser.SRC_HFStCM = "HFStCM";
Parser.SRC_CM = "CM";
Parser.SRC_NRH = "NRH";
Parser.SRC_NRH_TCMC = "NRH-TCMC";
Parser.SRC_NRH_AVitW = "NRH-AVitW";
Parser.SRC_NRH_ASS = "NRH-ASS";
Parser.SRC_NRH_CoI = "NRH-CoI";
Parser.SRC_NRH_TLT = "NRH-TLT";
Parser.SRC_NRH_AWoL = "NRH-AWoL";
Parser.SRC_NRH_AT = "NRH-AT";
Parser.SRC_MGELFT = "MGELFT";
Parser.SRC_VD = "VD";
Parser.SRC_SjA = "SjA";
Parser.SRC_HAT_TG = "HAT-TG";
Parser.SRC_HAT_LMI = "HAT-LMI";
Parser.SRC_GotSF = "GotSF";
Parser.SRC_LK = "LK";
Parser.SRC_CoA = "CoA";
Parser.SRC_PiP = "PiP";

Parser.SRC_AL_PREFIX = "AL";

Parser.SRC_ALCoS = `${Parser.SRC_AL_PREFIX}CurseOfStrahd`;
Parser.SRC_ALEE = `${Parser.SRC_AL_PREFIX}ElementalEvil`;
Parser.SRC_ALRoD = `${Parser.SRC_AL_PREFIX}RageOfDemons`;

Parser.SRC_PS_PREFIX = "PS";

Parser.SRC_PSA = `${Parser.SRC_PS_PREFIX}A`;
Parser.SRC_PSI = `${Parser.SRC_PS_PREFIX}I`;
Parser.SRC_PSK = `${Parser.SRC_PS_PREFIX}K`;
Parser.SRC_PSZ = `${Parser.SRC_PS_PREFIX}Z`;
Parser.SRC_PSX = `${Parser.SRC_PS_PREFIX}X`;
Parser.SRC_PSD = `${Parser.SRC_PS_PREFIX}D`;

Parser.SRC_UA_PREFIX = "UA";
Parser.SRC_UA_ONE_PREFIX = "XUA";
Parser.SRC_MCVX_PREFIX = "MCV";
Parser.SRC_MisMVX_PREFIX = "MisMV";
Parser.SRC_AA_PREFIX = "AA";

Parser.SRC_UATMC = `${Parser.SRC_UA_PREFIX}TheMysticClass`;
Parser.SRC_MCV1SC = `${Parser.SRC_MCVX_PREFIX}1SC`;
Parser.SRC_MCV2DC = `${Parser.SRC_MCVX_PREFIX}2DC`;
Parser.SRC_MCV3MC = `${Parser.SRC_MCVX_PREFIX}3MC`;
Parser.SRC_MCV4EC = `${Parser.SRC_MCVX_PREFIX}4EC`;
Parser.SRC_MisMV1 = `${Parser.SRC_MisMVX_PREFIX}1`;
Parser.SRC_AATM = `${Parser.SRC_AA_PREFIX}TM`;

Parser.AL_PREFIX = "Adventurers League: ";
Parser.AL_PREFIX_SHORT = "AL: ";
Parser.PS_PREFIX = "Plane Shift: ";
Parser.PS_PREFIX_SHORT = "PS: ";
Parser.UA_PREFIX = "Unearthed Arcana: ";
Parser.UA_PREFIX_SHORT = "UA: ";
Parser.TftYP_NAME = "Tales from the Yawning Portal";
Parser.AitFR_NAME = "Adventures in the Forgotten Realms";
Parser.NRH_NAME = "NERDS Restoring Harmony";
Parser.MCVX_PREFIX = "Monstrous Compendium Volume ";
Parser.MisMVX_PREFIX = "Misplaced Monsters: Volume ";
Parser.AA_PREFIX = "Adventure Atlas: ";

Parser.SOURCE_JSON_TO_FULL = {};
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CoS] = "Curse of Strahd";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DMG] = "Dungeon Master's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EEPC] = "Elemental Evil Player's Companion";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EET] = "Elemental Evil: Trinkets";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HotDQ] = "Hoard of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LMoP] = "Lost Mine of Phandelver";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MM] = "Monster Manual";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OotA] = "Out of the Abyss";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PHB] = "Player's Handbook";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PotA] = "Princes of the Apocalypse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RoT] = "The Rise of Tiamat";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RoTOS] = "The Rise of Tiamat Online Supplement";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCAG] = "Sword Coast Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SKT] = "Storm King's Thunder";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToA] = "Tomb of Annihilation";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TLK] = "The Lost Kenku";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToD] = "Tyranny of Dragons";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TTP] = "The Tortle Package";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP] = Parser.TftYP_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_AtG] = `${Parser.TftYP_NAME}: Against the Giants`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_DiT] = `${Parser.TftYP_NAME}: Dead in Thay`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_TFoF] = `${Parser.TftYP_NAME}: The Forge of Fury`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_THSoT] = `${Parser.TftYP_NAME}: The Hidden Shrine of Tamoachan`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_TSC] = `${Parser.TftYP_NAME}: The Sunless Citadel`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_ToH] = `${Parser.TftYP_NAME}: Tomb of Horrors`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_WPM] = `${Parser.TftYP_NAME}: White Plume Mountain`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VGM] = "Volo's Guide to Monsters";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_XGE] = "Xanathar's Guide to Everything";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OGA] = "One Grung Above";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MTF] = "Mordenkainen's Tome of Foes";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WDH] = "Waterdeep: Dragon Heist";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WDMM] = "Waterdeep: Dungeon of the Mad Mage";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GGR] = "Guildmasters' Guide to Ravnica";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_KKW] = "Krenko's Way";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LLK] = "Lost Laboratory of Kwalish";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AZfyT] = "A Zib for your Thoughts";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GoS] = "Ghosts of Saltmarsh";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AI] = "Acquisitions Incorporated";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OoW] = "The Orrery of the Wanderer";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ESK] = "Essentials Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DIP] = "Dragon of Icespire Peak";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HftT] = "Hunt for the Thessalhydra";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DC] = "Divine Contention";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SLW] = "Storm Lord's Wrath";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SDW] = "Sleeping Dragon's Wake";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BGDIA] = "Baldur's Gate: Descent Into Avernus";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LR] = "Locathah Rising";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AL] = "Adventurers' League";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SAC] = "Sage Advice Compendium";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ERLW] = "Eberron: Rising from the Last War";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EFR] = "Eberron: Forgotten Relics";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RMBRE] = "The Lost Dungeon of Rickedness: Big Rick Energy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RMR] = "Dungeons & Dragons vs. Rick and Morty: Basic Rules";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MFF] = "Mordenkainen's Fiendish Folio";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AWM] = "Adventure with Muk";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_IMR] = "Infernal Machine Rebuild";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SADS] = "Sapphire Anniversary Dice Set";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW] = "Explorer's Guide to Wildemount";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_ToR] = "Tide of Retribution";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_DD] = "Dangerous Designs";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_FS] = "Frozen Sick";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_US] = "Unwelcome Spirits";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MOT] = "Mythic Odysseys of Theros";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_IDRotF] = "Icewind Dale: Rime of the Frostmaiden";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TCE] = "Tasha's Cauldron of Everything";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VRGR] = "Van Richten's Guide to Ravenloft";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HoL] = "The House of Lament";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RtG] = "Return to Glory";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR] = Parser.AitFR_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_ISF] = `${Parser.AitFR_NAME}: In Scarlet Flames`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_THP] = `${Parser.AitFR_NAME}: The Hidden Page`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_AVT] = `${Parser.AitFR_NAME}: A Verdant Tomb`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_DN] = `${Parser.AitFR_NAME}: Deepest Night`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_FCD] = `${Parser.AitFR_NAME}: From Cyan Depths`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WBtW] = "The Wild Beyond the Witchlight";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoD] = "Domains of Delight";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MaBJoV] = "Minsc and Boo's Journal of Villainy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_FTD] = "Fizban's Treasury of Dragons";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC] = "Strixhaven: A Curriculum of Chaos";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_CK] = "Campus Kerfuffle";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_HfMT] = "Hunt for Mage Tower";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_TMM] = "The Magister's Masquerade";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_ARiR] = "A Reckoning in Ruins";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MPMM] = "Mordenkainen Presents: Monsters of the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CRCotN] = "Critical Role: Call of the Netherdeep";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_JttRC] = "Journeys through the Radiant Citadel";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SAiS] = "Spelljammer: Adventures in Space";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AAG] = "Astral Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BAM] = "Boo's Astral Menagerie";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LoX] = "Light of Xaryxis";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoSI] = "Dragons of Stormwreck Isle";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DSotDQ] = "Dragonlance: Shadow of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_KftGV] = "Keys from the Golden Vault";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BGG] = "Bigby Presents: Glory of the Giants";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TDCSR] = "Tal'Dorei Campaign Setting Reborn";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PaBTSO] = "Phandelver and Below: The Shattered Obelisk";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PAitM] = "Planescape: Adventures in the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SatO] = "Sigil and the Outlands";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToFW] = "Turn of Fortune's Wheel";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MPP] = "Morte's Planar Parade";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BMT] = "The Book of Many Things";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GHLoE] = "Grim Hollow: Lairs of Etharis";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoDk] = "Dungeons of Drakkenheim";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN] = "Dungeon Master's Screen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_WILDERNESS_KIT] = "Dungeon Master's Screen: Wilderness Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_DUNGEON_KIT] = "Dungeon Master's Screen: Dungeon Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_SPELLJAMMER] = "Dungeon Master's Screen: Spelljammer";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HF] = "Heroes' Feast";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HFFotM] = "Heroes' Feast: Flavors of the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HFStCM] = "Heroes' Feast: Saving the Childrens Menu";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CM] = "Candlekeep Mysteries";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH] = Parser.NRH_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_TCMC] = `${Parser.NRH_NAME}: The Candy Mountain Caper`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AVitW] = `${Parser.NRH_NAME}: A Voice in the Wilderness`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_ASS] = `${Parser.NRH_NAME}: A Sticky Situation`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_CoI] = `${Parser.NRH_NAME}: Circus of Illusions`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_TLT] = `${Parser.NRH_NAME}: The Lost Tomb`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AWoL] = `${Parser.NRH_NAME}: A Web of Lies`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AT] = `${Parser.NRH_NAME}: Adventure Together`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MGELFT] = "Muk's Guide To Everything He Learned From Tasha";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VD] = "Vecna Dossier";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SjA] = "Spelljammer Academy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HAT_TG] = "Honor Among Thieves: Thieves' Gallery";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HAT_LMI] = "Honor Among Thieves: Legendary Magic Items";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GotSF] = "Giants of the Star Forge";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LK] = "Lightning Keep";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CoA] = "Chains of Asmodeus";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PiP] = "Peril in Pinebrook";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALCoS] = `${Parser.AL_PREFIX}Curse of Strahd`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALEE] = `${Parser.AL_PREFIX}Elemental Evil`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALRoD] = `${Parser.AL_PREFIX}Rage of Demons`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSA] = `${Parser.PS_PREFIX}Amonkhet`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSI] = `${Parser.PS_PREFIX}Innistrad`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSK] = `${Parser.PS_PREFIX}Kaladesh`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSZ] = `${Parser.PS_PREFIX}Zendikar`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSX] = `${Parser.PS_PREFIX}Ixalan`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSD] = `${Parser.PS_PREFIX}Dominaria`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_XMtS] = `X Marks the Spot`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATMC] = `${Parser.UA_PREFIX}The Mystic Class`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV1SC] = `${Parser.MCVX_PREFIX}1: Spelljammer Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV2DC] = `${Parser.MCVX_PREFIX}2: Dragonlance Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV3MC] = `${Parser.MCVX_PREFIX}3: Minecraft Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV4EC] = `${Parser.MCVX_PREFIX}4: Eldraine Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MisMV1] = `${Parser.MisMVX_PREFIX}1`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AATM] = `${Parser.AA_PREFIX}The Mortuary`;

Parser.SOURCE_JSON_TO_ABV = {};
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CoS] = "CoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DMG] = "DMG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EEPC] = "EEPC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EET] = "EET";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HotDQ] = "HotDQ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LMoP] = "LMoP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MM] = "MM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OotA] = "OotA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PHB] = "PHB";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PotA] = "PotA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RoT] = "RoT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RoTOS] = "RoTOS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCAG] = "SCAG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SKT] = "SKT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToA] = "ToA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TLK] = "TLK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToD] = "ToD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TTP] = "TTP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_AtG] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_DiT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_TFoF] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_THSoT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_TSC] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_ToH] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_WPM] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VGM] = "VGM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_XGE] = "XGE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OGA] = "OGA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MTF] = "MTF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WDH] = "WDH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WDMM] = "WDMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GGR] = "GGR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_KKW] = "KKW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LLK] = "LLK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AZfyT] = "AZfyT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GoS] = "GoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AI] = "AI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OoW] = "OoW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ESK] = "ESK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DIP] = "DIP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HftT] = "HftT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DC] = "DC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SLW] = "SLW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SDW] = "SDW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BGDIA] = "BGDIA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LR] = "LR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AL] = "AL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SAC] = "SAC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ERLW] = "ERLW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EFR] = "EFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RMBRE] = "RMBRE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RMR] = "RMR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MFF] = "MFF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AWM] = "AWM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_IMR] = "IMR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SADS] = "SADS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW] = "EGW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_ToR] = "ToR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_DD] = "DD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_FS] = "FS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_US] = "US";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MOT] = "MOT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_IDRotF] = "IDRotF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TCE] = "TCE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VRGR] = "VRGR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HoL] = "HoL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RtG] = "RtG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR] = "AitFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_ISF] = "AitFR-ISF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_THP] = "AitFR-THP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_AVT] = "AitFR-AVT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_DN] = "AitFR-DN";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_FCD] = "AitFR-FCD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WBtW] = "WBtW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoD] = "DoD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MaBJoV] = "MaBJoV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_FTD] = "FTD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC] = "SCC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_CK] = "SCC-CK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_HfMT] = "SCC-HfMT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_TMM] = "SCC-TMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_ARiR] = "SCC-ARiR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MPMM] = "MPMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CRCotN] = "CRCotN";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_JttRC] = "JttRC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SAiS] = "SAiS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AAG] = "AAG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BAM] = "BAM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LoX] = "LoX";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoSI] = "DoSI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DSotDQ] = "DSotDQ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_KftGV] = "KftGV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BGG] = "BGG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TDCSR] = "TDCSR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PaBTSO] = "PaBTSO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PAitM] = "PAitM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SatO] = "SatO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToFW] = "ToFW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MPP] = "MPP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BMT] = "BMT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GHLoE] = "GHLoE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoDk] = "DoDk";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN] = "Screen";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_WILDERNESS_KIT] = "ScWild";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_DUNGEON_KIT] = "ScDun";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_SPELLJAMMER] = "ScSJ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HF] = "HF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HFFotM] = "HFFotM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HFStCM] = "HFStCM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CM] = "CM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH] = "NRH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_TCMC] = "NRH-TCMC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AVitW] = "NRH-AVitW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_ASS] = "NRH-ASS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_CoI] = "NRH-CoI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_TLT] = "NRH-TLT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AWoL] = "NRH-AWoL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AT] = "NRH-AT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MGELFT] = "MGELFT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VD] = "VD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SjA] = "SjA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HAT_TG] = "HAT-TG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HAT_LMI] = "HAT-LMI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GotSF] = "GotSF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LK] = "LK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CoA] = "CoA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PiP] = "PiP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALCoS] = "ALCoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALEE] = "ALEE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALRoD] = "ALRoD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSA] = "PSA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSI] = "PSI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSK] = "PSK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSZ] = "PSZ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSX] = "PSX";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSD] = "PSD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_XMtS] = "XMtS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATMC] = "UAMy";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV1SC] = "MCV1SC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV2DC] = "MCV2DC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV3MC] = "MCV3MC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV4EC] = "MCV4EC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MisMV1] = "MisMV1";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AATM] = "AATM";

Parser.SOURCE_JSON_TO_DATE = {};
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DMG] = "2014-12-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EEPC] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EET] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HotDQ] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LMoP] = "2014-07-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MM] = "2014-09-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OotA] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PHB] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PotA] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RoT] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RoTOS] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCAG] = "2015-11-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SKT] = "2016-09-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToA] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TLK] = "2017-11-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToD] = "2019-10-22";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TTP] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_AtG] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_DiT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_TFoF] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_THSoT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_TSC] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_ToH] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_WPM] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VGM] = "2016-11-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_XGE] = "2017-11-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OGA] = "2017-10-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MTF] = "2018-05-29";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WDH] = "2018-09-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WDMM] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GGR] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_KKW] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LLK] = "2018-11-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AZfyT] = "2019-03-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GoS] = "2019-05-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AI] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OoW] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ESK] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DIP] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HftT] = "2019-05-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DC] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SLW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SDW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BGDIA] = "2019-09-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LR] = "2019-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SAC] = "2019-01-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ERLW] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EFR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RMBRE] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RMR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MFF] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AWM] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_IMR] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SADS] = "2019-12-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_ToR] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_DD] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_FS] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_US] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MOT] = "2020-06-02";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_IDRotF] = "2020-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TCE] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VRGR] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HoL] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RtG] = "2021-05-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_ISF] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_THP] = "2021-07-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_AVT] = "2021-07-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_DN] = "2021-07-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_FCD] = "2021-07-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WBtW] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoD] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MaBJoV] = "2021-10-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_FTD] = "2021-11-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_CK] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_HfMT] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_TMM] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_ARiR] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MPMM] = "2022-01-25";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CRCotN] = "2022-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_JttRC] = "2022-07-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SAiS] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AAG] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BAM] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LoX] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoSI] = "2022-07-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DSotDQ] = "2022-11-22";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_KftGV] = "2023-02-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BGG] = "2023-08-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TDCSR] = "2022-01-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PaBTSO] = "2023-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PAitM] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SatO] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToFW] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MPP] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BMT] = "2023-11-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GHLoE] = "2023-11-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoDk] = "2023-12-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN] = "2015-01-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_WILDERNESS_KIT] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_DUNGEON_KIT] = "2020-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_SPELLJAMMER] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HF] = "2020-10-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HFFotM] = "2023-11-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HFStCM] = "2023-11-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CM] = "2021-03-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_TCMC] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AVitW] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_ASS] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_CoI] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_TLT] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AWoL] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AT] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MGELFT] = "2020-12-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VD] = "2022-06-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SjA] = "2022-07-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HAT_TG] = "2023-03-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HAT_LMI] = "2023-03-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GotSF] = "2023-08-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LK] = "2023-09-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CoA] = "2023-10-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PiP] = "2023-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALCoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALEE] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALRoD] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSA] = "2017-07-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSI] = "2016-07-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSK] = "2017-02-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSZ] = "2016-04-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSX] = "2018-01-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSD] = "2018-07-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_XMtS] = "2017-12-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATMC] = "2017-03-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV1SC] = "2022-04-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV2DC] = "2022-12-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV3MC] = "2023-03-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV4EC] = "2023-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MisMV1] = "2023-05-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AATM] = "2023-10-17";

Parser.SOURCES_ADVENTURES = new Set([Parser.SRC_LMoP, Parser.SRC_HotDQ, Parser.SRC_RoT, Parser.SRC_RoTOS, Parser.SRC_PotA,
    Parser.SRC_OotA, Parser.SRC_CoS, Parser.SRC_SKT, Parser.SRC_TYP, Parser.SRC_TYP_AtG,Parser.SRC_TYP_DiT,
    Parser.SRC_TYP_TFoF, Parser.SRC_TYP_THSoT, Parser.SRC_TYP_TSC, Parser.SRC_TYP_ToH, Parser.SRC_TYP_WPM, Parser.SRC_ToA,
    Parser.SRC_TLK, Parser.SRC_TTP, Parser.SRC_WDH, Parser.SRC_LLK, Parser.SRC_WDMM, Parser.SRC_KKW, Parser.SRC_AZfyT,
    Parser.SRC_GoS, Parser.SRC_HftT, Parser.SRC_OoW, Parser.SRC_DIP, Parser.SRC_SLW, Parser.SRC_SDW, Parser.SRC_DC,
    Parser.SRC_BGDIA, Parser.SRC_LR, Parser.SRC_EFR, Parser.SRC_RMBRE, Parser.SRC_IMR, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD,
    Parser.SRC_EGW_FS, Parser.SRC_EGW_US, Parser.SRC_IDRotF, Parser.SRC_CM, Parser.SRC_HoL, Parser.SRC_XMtS, Parser.SRC_RtG,
    Parser.SRC_AitFR, Parser.SRC_AitFR_ISF, Parser.SRC_AitFR_THP, Parser.SRC_AitFR_AVT, Parser.SRC_AitFR_DN, Parser.SRC_AitFR_FCD,
    Parser.SRC_WBtW, Parser.SRC_NRH, Parser.SRC_NRH_TCMC, Parser.SRC_NRH_AVitW, Parser.SRC_NRH_ASS, Parser.SRC_NRH_CoI, Parser.SRC_NRH_TLT,
    Parser.SRC_NRH_AWoL, Parser.SRC_NRH_AT, Parser.SRC_SCC, Parser.SRC_SCC_CK, Parser.SRC_SCC_HfMT, Parser.SRC_SCC_TMM, Parser.SRC_SCC_ARiR,
    Parser.SRC_CRCotN, Parser.SRC_JttRC, Parser.SRC_SjA, Parser.SRC_LoX, Parser.SRC_DoSI, Parser.SRC_DSotDQ, Parser.SRC_KftGV,
    Parser.SRC_GotSF, Parser.SRC_PaBTSO, Parser.SRC_LK, Parser.SRC_CoA, Parser.SRC_PiP, Parser.SRC_HFStCM, Parser.SRC_GHLoE,
    Parser.SRC_DoDk,
Parser.SRC_AWM, ]);
Parser.SOURCES_CORE_SUPPLEMENTS = new Set(Object.keys(Parser.SOURCE_JSON_TO_FULL).filter(it=>!Parser.SOURCES_ADVENTURES.has(it)));
Parser.SOURCES_NON_STANDARD_WOTC = new Set([Parser.SRC_OGA, Parser.SRC_LLK, Parser.SRC_AZfyT, Parser.SRC_LR,
    Parser.SRC_TLK, Parser.SRC_TTP, Parser.SRC_AWM, Parser.SRC_IMR, Parser.SRC_SADS, Parser.SRC_MFF,
    Parser.SRC_XMtS, Parser.SRC_RtG, Parser.SRC_AitFR, Parser.SRC_AitFR_ISF, Parser.SRC_AitFR_THP,
    Parser.SRC_AitFR_AVT, Parser.SRC_AitFR_DN, Parser.SRC_AitFR_FCD, Parser.SRC_DoD, Parser.SRC_MaBJoV,
    Parser.SRC_NRH, Parser.SRC_NRH_TCMC, Parser.SRC_NRH_AVitW, Parser.SRC_NRH_ASS, Parser.SRC_NRH_CoI,
    Parser.SRC_NRH_TLT, Parser.SRC_NRH_AWoL, Parser.SRC_NRH_AT, Parser.SRC_MGELFT, Parser.SRC_VD,
    Parser.SRC_SjA, Parser.SRC_HAT_TG, Parser.SRC_HAT_LMI, Parser.SRC_GotSF, Parser.SRC_MCV3MC,
    Parser.SRC_MCV4EC, Parser.SRC_MisMV1, Parser.SRC_LK, Parser.SRC_AATM, Parser.SRC_CoA, Parser.SRC_PiP,
    Parser.SRC_HFStCM, ]);
Parser.SOURCES_PARTNERED_WOTC = new Set([Parser.SRC_RMBRE, Parser.SRC_RMR, Parser.SRC_EGW, Parser.SRC_EGW_ToR,
    Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US, Parser.SRC_CRCotN, Parser.SRC_TDCSR,
    Parser.SRC_HftT, Parser.SRC_GHLoE, Parser.SRC_DoDk, ]);

Parser.SOURCES_VANILLA = new Set([Parser.SRC_DMG, Parser.SRC_MM, Parser.SRC_PHB, Parser.SRC_SCAG,
    Parser.SRC_XGE, Parser.SRC_SAC, Parser.SRC_MFF, Parser.SRC_SADS, Parser.SRC_TCE, Parser.SRC_FTD,
    Parser.SRC_MPMM, Parser.SRC_SCREEN, Parser.SRC_SCREEN_WILDERNESS_KIT, Parser.SRC_SCREEN_DUNGEON_KIT,
    Parser.SRC_VD, Parser.SRC_GotSF, Parser.SRC_BGG, Parser.SRC_MaBJoV, Parser.SRC_CoA, Parser.SRC_BMT, ]);

Parser.SOURCES_COMEDY = new Set([Parser.SRC_AI, Parser.SRC_OoW, Parser.SRC_RMR, Parser.SRC_RMBRE, Parser.SRC_HftT, Parser.SRC_AWM, Parser.SRC_MGELFT, Parser.SRC_HAT_TG, Parser.SRC_HAT_LMI, Parser.SRC_MCV3MC, Parser.SRC_MisMV1, Parser.SRC_LK, Parser.SRC_PiP, ]);

Parser.SOURCES_NON_FR = new Set([Parser.SRC_GGR, Parser.SRC_KKW, Parser.SRC_ERLW, Parser.SRC_EFR,
    Parser.SRC_EGW, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US,
    Parser.SRC_MOT, Parser.SRC_XMtS, Parser.SRC_AZfyT, Parser.SRC_SCC, Parser.SRC_SCC_CK,
    Parser.SRC_SCC_HfMT, Parser.SRC_SCC_TMM, Parser.SRC_SCC_ARiR, Parser.SRC_CRCotN, Parser.SRC_SjA,
    Parser.SRC_SAiS, Parser.SRC_AAG, Parser.SRC_BAM, Parser.SRC_LoX, Parser.SRC_DSotDQ, Parser.SRC_TDCSR,
    Parser.SRC_PAitM, Parser.SRC_SatO, Parser.SRC_ToFW, Parser.SRC_MPP, Parser.SRC_MCV4EC, Parser.SRC_LK,
    Parser.SRC_GHLoE, Parser.SRC_DoDk, ]);

Parser.SOURCES_AVAILABLE_DOCS_BOOK = {};
[Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG, Parser.SRC_SCAG, Parser.SRC_VGM, Parser.SRC_OGA, Parser.SRC_XGE, Parser.SRC_MTF, Parser.SRC_GGR, Parser.SRC_AI, Parser.SRC_ERLW, Parser.SRC_RMR, Parser.SRC_EGW, Parser.SRC_MOT, Parser.SRC_TCE, Parser.SRC_VRGR, Parser.SRC_DoD, Parser.SRC_MaBJoV, Parser.SRC_FTD, Parser.SRC_SCC, Parser.SRC_MPMM, Parser.SRC_AAG, Parser.SRC_BAM, Parser.SRC_HAT_TG, Parser.SRC_SCREEN, Parser.SRC_SCREEN_WILDERNESS_KIT, Parser.SRC_SCREEN_DUNGEON_KIT, Parser.SRC_SCREEN_SPELLJAMMER, Parser.SRC_BGG, Parser.SRC_TDCSR, Parser.SRC_SatO, Parser.SRC_MPP, Parser.SRC_HF, Parser.SRC_HFFotM, Parser.SRC_BMT, ].forEach(src=>{
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = src;
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = src;
}
);
[{
    src: Parser.SRC_PSA,
    id: "PS-A"
}, {
    src: Parser.SRC_PSI,
    id: "PS-I"
}, {
    src: Parser.SRC_PSK,
    id: "PS-K"
}, {
    src: Parser.SRC_PSZ,
    id: "PS-Z"
}, {
    src: Parser.SRC_PSX,
    id: "PS-X"
}, {
    src: Parser.SRC_PSD,
    id: "PS-D"
}, ].forEach(({src, id})=>{
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = id;
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = id;
}
);
Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE = {};
[Parser.SRC_LMoP, Parser.SRC_HotDQ, Parser.SRC_RoT, Parser.SRC_PotA, Parser.SRC_OotA,
    Parser.SRC_CoS, Parser.SRC_SKT, Parser.SRC_TYP_AtG, Parser.SRC_TYP_DiT, Parser.SRC_TYP_TFoF,
    Parser.SRC_TYP_THSoT, Parser.SRC_TYP_TSC, Parser.SRC_TYP_ToH, Parser.SRC_TYP_WPM, Parser.SRC_ToA,
    Parser.SRC_TLK, Parser.SRC_TTP, Parser.SRC_WDH, Parser.SRC_LLK, Parser.SRC_WDMM, Parser.SRC_KKW,
    Parser.SRC_AZfyT, Parser.SRC_GoS, Parser.SRC_HftT, Parser.SRC_OoW, Parser.SRC_DIP, Parser.SRC_SLW,
    Parser.SRC_SDW, Parser.SRC_DC, Parser.SRC_BGDIA, Parser.SRC_LR, Parser.SRC_EFR, Parser.SRC_RMBRE,
    Parser.SRC_IMR, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US,
    Parser.SRC_IDRotF, Parser.SRC_CM, Parser.SRC_HoL, Parser.SRC_XMtS, Parser.SRC_RtG, Parser.SRC_AitFR_ISF,
    Parser.SRC_AitFR_THP, Parser.SRC_AitFR_AVT, Parser.SRC_AitFR_DN, Parser.SRC_AitFR_FCD, Parser.SRC_WBtW,
    Parser.SRC_NRH, Parser.SRC_NRH_TCMC, Parser.SRC_NRH_AVitW, Parser.SRC_NRH_ASS, Parser.SRC_NRH_CoI,
    Parser.SRC_NRH_TLT, Parser.SRC_NRH_AWoL, Parser.SRC_NRH_AT, Parser.SRC_SCC_CK, Parser.SRC_SCC_HfMT,
    Parser.SRC_SCC_TMM, Parser.SRC_SCC_ARiR, Parser.SRC_CRCotN, Parser.SRC_JttRC, Parser.SRC_LoX, Parser.SRC_DoSI,
    Parser.SRC_DSotDQ, Parser.SRC_KftGV, Parser.SRC_GotSF, Parser.SRC_PaBTSO, Parser.SRC_ToFW, Parser.SRC_LK,
    Parser.SRC_CoA, Parser.SRC_PiP, Parser.SRC_HFStCM, Parser.SRC_GHLoE, Parser.SRC_DoDk, ].forEach(src=>{
    Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src] = src;
    Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src.toLowerCase()] = src;
}
);

Parser.getTagSource = function(tag, source) {
    if (source && source.trim())
        return source;

    tag = tag.trim();

    const tagMeta = Renderer.tag.TAG_LOOKUP[tag];

    if (!tagMeta)
        throw new Error(`Unhandled tag "${tag}"`);
    return tagMeta.defaultSource;
}
;

Parser.PROP_TO_TAG = {
    "monster": "creature",
    "optionalfeature": "optfeature",
    "tableGroup": "table",
    "vehicleUpgrade": "vehupgrade",
    "baseitem": "item",
    "itemGroup": "item",
    "magicvariant": "item",
};
Parser.getPropTag = function(prop) {
    if (Parser.PROP_TO_TAG[prop])
        return Parser.PROP_TO_TAG[prop];
    return prop;
}
;

Parser.PROP_TO_DISPLAY_NAME = {
    "variantrule": "Variant Rule",
    "optionalfeature": "Option/Feature",
    "magicvariant": "Magic Item Variant",
    "baseitem": "Item (Base)",
    "item": "Item",
    "adventure": "Adventure",
    "adventureData": "Adventure Text",
    "book": "Book",
    "bookData": "Book Text",
    "makebrewCreatureTrait": "Homebrew Builder Creature Trait",
    "charoption": "Other Character Creation Option",

    "bonus": "Bonus Action",
    "legendary": "Legendary Action",
    "mythic": "Mythic Action",
    "lairActions": "Lair Action",
    "regionalEffects": "Regional Effect",
};
Parser.getPropDisplayName = function(prop, {suffix=""}={}) {
    if (Parser.PROP_TO_DISPLAY_NAME[prop])
        return `${Parser.PROP_TO_DISPLAY_NAME[prop]}${suffix}`;

    const mFluff = /Fluff$/.exec(prop);
    if (mFluff)
        return Parser.getPropDisplayName(prop.slice(0, -mFluff[0].length), {
            suffix: " Fluff"
        });

    const mFoundry = /^foundry(?<prop>[A-Z].*)$/.exec(prop);
    if (mFoundry)
        return Parser.getPropDisplayName(mFoundry.groups.prop.lowercaseFirst(), {
            suffix: " Foundry Data"
        });

    return `${prop.split(/([A-Z][a-z]+)/g).filter(Boolean).join(" ").uppercaseFirst()}${suffix}`;
}
;

Parser.ITEM_TYPE_JSON_TO_ABV = {
    "A": "ammunition",
    "AF": "ammunition",
    "AT": "artisan's tools",
    "EM": "eldritch machine",
    "EXP": "explosive",
    "FD": "food and drink",
    "G": "adventuring gear",
    "GS": "gaming set",
    "HA": "heavy armor",
    "IDG": "illegal drug",
    "INS": "instrument",
    "LA": "light armor",
    "M": "melee weapon",
    "MA": "medium armor",
    "MNT": "mount",
    "MR": "master rune",
    "GV": "generic variant",
    "P": "potion",
    "R": "ranged weapon",
    "RD": "rod",
    "RG": "ring",
    "S": "shield",
    "SC": "scroll",
    "SCF": "spellcasting focus",
    "OTH": "other",
    "T": "tools",
    "TAH": "tack and harness",
    "TG": "trade good",
    "$": "treasure",
    "VEH": "vehicle (land)",
    "SHP": "vehicle (water)",
    "AIR": "vehicle (air)",
    "SPC": "vehicle (space)",
    "WD": "wand",
};

Parser.DMGTYPE_JSON_TO_FULL = {
    "A": "acid",
    "B": "bludgeoning",
    "C": "cold",
    "F": "fire",
    "O": "force",
    "L": "lightning",
    "N": "necrotic",
    "P": "piercing",
    "I": "poison",
    "Y": "psychic",
    "R": "radiant",
    "S": "slashing",
    "T": "thunder",
};

Parser.DMG_TYPES = ["acid", "bludgeoning", "cold", "fire", "force", "lightning", "necrotic", "piercing", "poison", "psychic", "radiant", "slashing", "thunder"];
Parser.CONDITIONS = ["blinded", "charmed", "deafened", "exhaustion", "frightened", "grappled", "incapacitated", "invisible", "paralyzed", "petrified", "poisoned", "prone", "restrained", "stunned", "unconscious"];

Parser.SENSES = [{
    "name": "blindsight",
    "source": Parser.SRC_PHB
}, {
    "name": "darkvision",
    "source": Parser.SRC_PHB
}, {
    "name": "tremorsense",
    "source": Parser.SRC_MM
}, {
    "name": "truesight",
    "source": Parser.SRC_PHB
}, ];

Parser.NUMBERS_ONES = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
Parser.NUMBERS_TENS = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];
Parser.NUMBERS_TEENS = ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"];

Parser.metric = {
    MILES_TO_KILOMETRES: 1.6,
    FEET_TO_METRES: 0.3,
    YARDS_TO_METRES: 0.9,
    POUNDS_TO_KILOGRAMS: 0.5,
    getMetricNumber({originalValue, originalUnit, toFixed=null}) {
        if (originalValue == null || isNaN(originalValue))
            return originalValue;

        originalValue = Number(originalValue);
        if (!originalValue)
            return originalValue;

        let out = null;
        switch (originalUnit) {
        case "ft.":
        case "ft":
        case Parser.UNT_FEET:
            out = originalValue * Parser.metric.FEET_TO_METRES;
            break;
        case "yd.":
        case "yd":
        case Parser.UNT_YARDS:
            out = originalValue * Parser.metric.YARDS_TO_METRES;
            break;
        case "mi.":
        case "mi":
        case Parser.UNT_MILES:
            out = originalValue * Parser.metric.MILES_TO_KILOMETRES;
            break;
        case "lb.":
        case "lb":
        case "lbs":
            out = originalValue * Parser.metric.POUNDS_TO_KILOGRAMS;
            break;
        default:
            return originalValue;
        }
        if (toFixed != null)
            return NumberUtil.toFixedNumber(out, toFixed);
        return out;
    },

    getMetricUnit({originalUnit, isShortForm=false, isPlural=true}) {
        switch (originalUnit) {
        case "ft.":
        case "ft":
        case Parser.UNT_FEET:
            return isShortForm ? "m" : `meter`[isPlural ? "toPlural" : "toString"]();
        case "yd.":
        case "yd":
        case Parser.UNT_YARDS:
            return isShortForm ? "m" : `meter`[isPlural ? "toPlural" : "toString"]();
        case "mi.":
        case "mi":
        case Parser.UNT_MILES:
            return isShortForm ? "km" : `kilometre`[isPlural ? "toPlural" : "toString"]();
        case "lb.":
        case "lb":
        case "lbs":
            return isShortForm ? "kg" : `kilogram`[isPlural ? "toPlural" : "toString"]();
        default:
            return originalUnit;
        }
    },
};

Parser.MAP_GRID_TYPE_TO_FULL = {};
Parser.MAP_GRID_TYPE_TO_FULL["none"] = "None";
Parser.MAP_GRID_TYPE_TO_FULL["square"] = "Square";
Parser.MAP_GRID_TYPE_TO_FULL["hexRowsOdd"] = "Hex Rows (Odd)";
Parser.MAP_GRID_TYPE_TO_FULL["hexRowsEven"] = "Hex Rows (Even)";
Parser.MAP_GRID_TYPE_TO_FULL["hexColsOdd"] = "Hex Columns (Odd)";
Parser.MAP_GRID_TYPE_TO_FULL["hexColsEven"] = "Hex Columns (Even)";

Parser.mapGridTypeToFull = function(gridType) {
    return Parser._parse_aToB(Parser.MAP_GRID_TYPE_TO_FULL, gridType);
}
;
//#endregion
//#region StorageUtil
function StorageUtilBase() {
    this._META_KEY = "_STORAGE_META_STORAGE";

    this._fakeStorageBacking = {};
    this._fakeStorageBackingAsync = {};

    this._getFakeStorageSync = function() {
        return {
            isSyncFake: true,
            getItem: k=>this._fakeStorageBacking[k],
            removeItem: k=>delete this._fakeStorageBacking[k],
            setItem: (k,v)=>this._fakeStorageBacking[k] = v,
        };
    }
    ;

    this._getFakeStorageAsync = function() {
        return {
            pIsAsyncFake: true,
            setItem: async(k,v)=>this._fakeStorageBackingAsync[k] = v,
            getItem: async(k)=>this._fakeStorageBackingAsync[k],
            removeItem: async(k)=>delete this._fakeStorageBackingAsync[k],
        };
    }
    ;

    this._getSyncStorage = function() {
        throw new Error(`Unimplemented!`);
    }
    ;
    this._getAsyncStorage = async function() {
        throw new Error(`Unimplemented!`);
    }
    ;

    this.getPageKey = function(key, page) {
        return `${key}_${page || UrlUtil.getCurrentPage()}`;
    }
    ;

    this.syncGet = function(key) {
        const rawOut = this._getSyncStorage().getItem(key);
        if (rawOut && rawOut !== "undefined" && rawOut !== "null")
            return JSON.parse(rawOut);
        return null;
    }
    ;

    this.syncSet = function(key, value) {
        this._getSyncStorage().setItem(key, JSON.stringify(value));
        this._syncTrackKey(key);
    }
    ;

    this.syncRemove = function(key) {
        this._getSyncStorage().removeItem(key);
        this._syncTrackKey(key, true);
    }
    ;

    this.syncGetForPage = function(key) {
        return this.syncGet(`${key}_${UrlUtil.getCurrentPage()}`);
    }
    ;
    this.syncSetForPage = function(key, value) {
        this.syncSet(`${key}_${UrlUtil.getCurrentPage()}`, value);
    }
    ;

    this.isSyncFake = function() {
        return !!this._getSyncStorage().isSyncFake;
    }
    ;

    this._syncTrackKey = function(key, isRemove) {
        const meta = this.syncGet(this._META_KEY) || {};
        if (isRemove)
            delete meta[key];
        else
            meta[key] = 1;
        this._getSyncStorage().setItem(this._META_KEY, JSON.stringify(meta));
    }
    ;

    this.syncGetDump = function() {
        const out = {};
        this._syncGetPresentKeys().forEach(key=>out[key] = this.syncGet(key));
        return out;
    }
    ;

    this._syncGetPresentKeys = function() {
        const meta = this.syncGet(this._META_KEY) || {};
        return Object.entries(meta).filter(([,isPresent])=>isPresent).map(([key])=>key);
    }
    ;

    this.syncSetFromDump = function(dump) {
        const keysToRemove = new Set(this._syncGetPresentKeys());
        Object.entries(dump).map(([k,v])=>{
            keysToRemove.delete(k);
            return this.syncSet(k, v);
        }
        );
        [...keysToRemove].map(k=>this.syncRemove(k));
    }
    ;

    this.pIsAsyncFake = async function() {
        const storage = await this._getAsyncStorage();
        return !!storage.pIsAsyncFake;
    }
    ;

    this.pSet = async function(key, value) {
        this._pTrackKey(key).then(null);
        const storage = await this._getAsyncStorage();
        return storage.setItem(key, value);
    }
    ;

    this.pGet = async function(key) {
        const storage = await this._getAsyncStorage();
        return storage.getItem(key);
    }
    ;

    this.pRemove = async function(key) {
        this._pTrackKey(key, true).then(null);
        const storage = await this._getAsyncStorage();
        return storage.removeItem(key);
    }
    ;

    this.pGetForPage = async function(key, {page=null}={}) {
        return this.pGet(this.getPageKey(key, page));
    }
    ;
    this.pSetForPage = async function(key, value, {page=null}={}) {
        return this.pSet(this.getPageKey(key, page), value);
    }
    ;
    this.pRemoveForPage = async function(key, {page=null}={}) {
        return this.pRemove(this.getPageKey(key, page));
    }
    ;

    this._pTrackKey = async function(key, isRemove) {
        const storage = await this._getAsyncStorage();
        const meta = (await this.pGet(this._META_KEY)) || {};
        if (isRemove)
            delete meta[key];
        else
            meta[key] = 1;
        return storage.setItem(this._META_KEY, meta);
    }
    ;

    this.pGetDump = async function() {
        const out = {};
        await Promise.all((await this._pGetPresentKeys()).map(async(key)=>out[key] = await this.pGet(key)), );
        return out;
    }
    ;

    this._pGetPresentKeys = async function() {
        const meta = (await this.pGet(this._META_KEY)) || {};
        return Object.entries(meta).filter(([,isPresent])=>isPresent).map(([key])=>key);
    }
    ;

    this.pSetFromDump = async function(dump) {
        const keysToRemove = new Set(await this._pGetPresentKeys());
        await Promise.all(Object.entries(dump).map(([k,v])=>{
            keysToRemove.delete(k);
            return this.pSet(k, v);
        }
        ), );
        await Promise.all([...keysToRemove].map(k=>this.pRemove(k)), );
    }
    ;
}

function StorageUtilMemory$1() {
    StorageUtilBase.call(this);

    this._fakeStorage = null;
    this._fakeStorageAsync = null;

    this._getSyncStorage = function() {
        this._fakeStorage = this._fakeStorage || this._getFakeStorageSync();
        return this._fakeStorage;
    }
    ;

    this._getAsyncStorage = async function() {
        this._fakeStorageAsync = this._fakeStorageAsync || this._getFakeStorageAsync();
        return this._fakeStorageAsync;
    }
    ;
}

globalThis.StorageUtilMemory = StorageUtilMemory$1;

function StorageUtilBacked() {
    StorageUtilBase.call(this);

    this._isInit = false;
    this._isInitAsync = false;
    this._fakeStorage = null;
    this._fakeStorageAsync = null;

    this._initSyncStorage = function() {
        if (this._isInit)
            return;

        if (typeof window === "undefined") {
            this._fakeStorage = this._getFakeStorageSync();
            this._isInit = true;
            return;
        }

        try {
            window.localStorage.setItem("_test_storage", true);
        } catch (e) {
            this._fakeStorage = this._getFakeStorageSync();
        }

        this._isInit = true;
    }
    ;

    this._getSyncStorage = function() {
        this._initSyncStorage();
        if (this._fakeStorage)
            return this._fakeStorage;
        return window.localStorage;
    }
    ;

    this._initAsyncStorage = async function() {
        if (this._isInitAsync)
            return;

        if (typeof window === "undefined") {
            this._fakeStorageAsync = this._getFakeStorageAsync();
            this._isInitAsync = true;
            return;
        }

        try {
            await new Promise((resolve,reject)=>{
                const request = window.indexedDB.open("_test_db", 1);
                request.onerror = reject;
                request.onsuccess = resolve;
            }
            );
            await localforage.setItem("_storage_check", true);
        } catch (e) {
            this._fakeStorageAsync = this._getFakeStorageAsync();
        }

        this._isInitAsync = true;
    }
    ;

    this._getAsyncStorage = async function() {
        await this._initAsyncStorage();
        if (this._fakeStorageAsync)
            return this._fakeStorageAsync;
        else
            return localforage;
    }
    ;
}

globalThis.StorageUtil = new StorageUtilBacked();

//#endregion
//#region MiscUtil
globalThis.MiscUtil = {
    COLOR_HEALTHY: "#00bb20",
    COLOR_HURT: "#c5ca00",
    COLOR_BLOODIED: "#f7a100",
    COLOR_DEFEATED: "#cc0000",

    copy(obj, {isSafe=false, isPreserveUndefinedValueKeys=false}={}) {
        if (isSafe && obj === undefined)
            return undefined;
        return JSON.parse(JSON.stringify(obj));
    },

    copyFast(obj) {
        if ((typeof obj !== "object") || obj == null)
            return obj;

        if (obj instanceof Array)
            return obj.map(MiscUtil.copyFast);

        const cpy = {};
        for (const k of Object.keys(obj))
            cpy[k] = MiscUtil.copyFast(obj[k]);
        return cpy;
    },

    async pCopyTextToClipboard(text) {
        function doCompatibilityCopy() {
            const $iptTemp = $(`<textarea class="clp__wrp-temp"></textarea>`).appendTo(document.body).val(text).select();
            document.execCommand("Copy");
            $iptTemp.remove();
        }

        if (navigator && navigator.permissions) {
            try {
                const access = await navigator.permissions.query({
                    name: "clipboard-write"
                });
                if (access.state === "granted" || access.state === "prompt") {
                    await navigator.clipboard.writeText(text);
                } else
                    doCompatibilityCopy();
            } catch (e) {
                doCompatibilityCopy();
            }
        } else
            doCompatibilityCopy();
    },

    checkProperty(object, ...path) {
        for (let i = 0; i < path.length; ++i) {
            object = object[path[i]];
            if (object == null)
                return false;
        }
        return true;
    },

    get(object, ...path) {
        if (object == null)
            return null;
        for (let i = 0; i < path.length; ++i) {
            object = object[path[i]];
            if (object == null)
                return object;
        }
        return object;
    },

    set(object, ...pathAndVal) {
        if (object == null)
            return null;

        const val = pathAndVal.pop();
        if (!pathAndVal.length)
            return null;

        const len = pathAndVal.length;
        for (let i = 0; i < len; ++i) {
            const pathPart = pathAndVal[i];
            if (i === len - 1)
                object[pathPart] = val;
            else
                object = (object[pathPart] = object[pathPart] || {});
        }

        return val;
    },

    getOrSet(object, ...pathAndVal) {
        if (pathAndVal.length < 2)
            return null;
        const existing = MiscUtil.get(object, ...pathAndVal.slice(0, -1));
        if (existing != null)
            return existing;
        return MiscUtil.set(object, ...pathAndVal);
    },

    getThenSetCopy(object1, object2, ...path) {
        const val = MiscUtil.get(object1, ...path);
        return MiscUtil.set(object2, ...path, MiscUtil.copyFast(val, {
            isSafe: true
        }));
    },

    delete(object, ...path) {
        if (object == null)
            return object;
        for (let i = 0; i < path.length - 1; ++i) {
            object = object[path[i]];
            if (object == null)
                return object;
        }
        return delete object[path.last()];
    },

    deleteObjectPath(object, ...path) {
        const stack = [object];

        if (object == null)
            return object;
        for (let i = 0; i < path.length - 1; ++i) {
            object = object[path[i]];
            stack.push(object);
            if (object === undefined)
                return object;
        }
        const out = delete object[path.last()];

        for (let i = path.length - 1; i > 0; --i) {
            if (!Object.keys(stack[i]).length)
                delete stack[i - 1][path[i - 1]];
        }

        return out;
    },

    merge(obj1, obj2) {
        obj2 = MiscUtil.copyFast(obj2);

        Object.entries(obj2).forEach(([k,v])=>{
            if (obj1[k] == null) {
                obj1[k] = v;
                return;
            }

            if (typeof obj1[k] === "object" && typeof v === "object" && !(obj1[k]instanceof Array) && !(v instanceof Array)) {
                MiscUtil.merge(obj1[k], v);
                return;
            }

            obj1[k] = v;
        }
        );

        return obj1;
    },

    mix: (superclass)=>new MiscUtil._MixinBuilder(superclass),
    _MixinBuilder: function(superclass) {
        this.superclass = superclass;

        this.with = function(...mixins) {
            return mixins.reduce((c,mixin)=>mixin(c), this.superclass);
        }
        ;
    },

    clearSelection() {
        if (document.getSelection) {
            document.getSelection().removeAllRanges();
            document.getSelection().addRange(document.createRange());
        } else if (window.getSelection) {
            if (window.getSelection().removeAllRanges) {
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(document.createRange());
            } else if (window.getSelection().empty) {
                window.getSelection().empty();
            }
        } else if (document.selection) {
            document.selection.empty();
        }
    },

    randomColor() {
        let r;
        let g;
        let b;
        const h = RollerUtil.randomise(30, 0) / 30;
        const i = ~~(h * 6);
        const f = h * 6 - i;
        const q = 1 - f;
        switch (i % 6) {
        case 0:
            r = 1;
            g = f;
            b = 0;
            break;
        case 1:
            r = q;
            g = 1;
            b = 0;
            break;
        case 2:
            r = 0;
            g = 1;
            b = f;
            break;
        case 3:
            r = 0;
            g = q;
            b = 1;
            break;
        case 4:
            r = f;
            g = 0;
            b = 1;
            break;
        case 5:
            r = 1;
            g = 0;
            b = q;
            break;
        }
        return `#${`00${(~~(r * 255)).toString(16)}`.slice(-2)}${`00${(~~(g * 255)).toString(16)}`.slice(-2)}${`00${(~~(b * 255)).toString(16)}`.slice(-2)}`;
    },

    invertColor(hex, opts) {
        opts = opts || {};

        hex = hex.slice(1);
        let r = parseInt(hex.slice(0, 2), 16);
        let g = parseInt(hex.slice(2, 4), 16);
        let b = parseInt(hex.slice(4, 6), 16);

        const isDark = (r * 0.299 + g * 0.587 + b * 0.114) > 186;
        if (opts.dark && opts.light)
            return isDark ? opts.dark : opts.light;
        else if (opts.bw)
            return isDark ? "#000000" : "#FFFFFF";

        r = (255 - r).toString(16);
        g = (255 - g).toString(16);
        b = (255 - b).toString(16);
        return `#${[r, g, b].map(it=>it.padStart(2, "0")).join("")}`;
    },

    scrollPageTop() {
        document.body.scrollTop = document.documentElement.scrollTop = 0;
    },

    expEval(str) {
        return new Function(`return ${str.replace(/[^-()\d/*+.]/g, "")}`)();
    },

    parseNumberRange(input, min=Number.MIN_SAFE_INTEGER, max=Number.MAX_SAFE_INTEGER) {
        if (!input || !input.trim())
            return null;

        const errInvalid = input=>{
            throw new Error(`Could not parse range input "${input}"`);
        }
        ;

        const errOutOfRange = ()=>{
            throw new Error(`Number was out of range! Range was ${min}-${max} (inclusive).`);
        }
        ;

        const isOutOfRange = (num)=>num < min || num > max;

        const addToRangeVal = (range,num)=>range.add(num);

        const addToRangeLoHi = (range,lo,hi)=>{
            for (let i = lo; i <= hi; ++i)
                range.add(i);
        }
        ;

        const clean = input.replace(/\s*/g, "");
        if (!/^((\d+-\d+|\d+),)*(\d+-\d+|\d+)$/.exec(clean))
            errInvalid();

        const parts = clean.split(",");
        const out = new Set();

        for (const part of parts) {
            if (part.includes("-")) {
                const spl = part.split("-");
                const numLo = Number(spl[0]);
                const numHi = Number(spl[1]);

                if (isNaN(numLo) || isNaN(numHi) || numLo === 0 || numHi === 0 || numLo > numHi)
                    errInvalid();

                if (isOutOfRange(numLo) || isOutOfRange(numHi))
                    errOutOfRange();

                if (numLo === numHi)
                    addToRangeVal(out, numLo);
                else
                    addToRangeLoHi(out, numLo, numHi);
                continue;
            }

            const num = Number(part);
            if (isNaN(num) || num === 0)
                errInvalid();

            if (isOutOfRange(num))
                errOutOfRange();
            addToRangeVal(out, num);
        }

        return out;
    },

    findCommonPrefix(strArr, {isRespectWordBoundaries}={}) {
        if (isRespectWordBoundaries) {
            return MiscUtil._findCommonPrefixSuffixWords({
                strArr
            });
        }

        let prefix = null;
        strArr.forEach(s=>{
            if (prefix == null) {
                prefix = s;
                return;
            }

            const minLen = Math.min(s.length, prefix.length);
            for (let i = 0; i < minLen; ++i) {
                const cp = prefix[i];
                const cs = s[i];
                if (cp !== cs) {
                    prefix = prefix.substring(0, i);
                    break;
                }
            }
        }
        );
        return prefix;
    },

    findCommonSuffix(strArr, {isRespectWordBoundaries}={}) {
        if (!isRespectWordBoundaries)
            throw new Error(`Unimplemented!`);

        return MiscUtil._findCommonPrefixSuffixWords({
            strArr,
            isSuffix: true
        });
    },

    _findCommonPrefixSuffixWords({strArr, isSuffix}) {
        let prefixTks = null;
        let lenMax = -1;

        strArr.map(str=>{
            lenMax = Math.max(lenMax, str.length);
            return str.split(" ");
        }
        ).forEach(tks=>{
            if (isSuffix)
                tks.reverse();

            if (prefixTks == null)
                return prefixTks = [...tks];

            const minLen = Math.min(tks.length, prefixTks.length);
            while (prefixTks.length > minLen)
                prefixTks.pop();

            for (let i = 0; i < minLen; ++i) {
                const cp = prefixTks[i];
                const cs = tks[i];
                if (cp !== cs) {
                    prefixTks = prefixTks.slice(0, i);
                    break;
                }
            }
        }
        );

        if (isSuffix)
            prefixTks.reverse();

        if (!prefixTks.length)
            return "";

        const out = prefixTks.join(" ");
        if (out.length === lenMax)
            return out;

        return isSuffix ? ` ${prefixTks.join(" ")}` : `${prefixTks.join(" ")} `;
    },

    calculateBlendedColor(fgHexTarget, fgOpacity, bgHex) {
        const fgDcTarget = CryptUtil.hex2Dec(fgHexTarget);
        const bgDc = CryptUtil.hex2Dec(bgHex);
        return ((fgDcTarget - ((1 - fgOpacity) * bgDc)) / fgOpacity).toString(16);
    },

    debounce(func, wait, options) {
        let lastArgs;
        let lastThis;
        let maxWait;
        let result;
        let timerId;
        let lastCallTime;
        let lastInvokeTime = 0;
        let leading = false;
        let maxing = false;
        let trailing = true;

        wait = Number(wait) || 0;
        if (typeof options === "object") {
            leading = !!options.leading;
            maxing = "maxWait"in options;
            maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing"in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
            let args = lastArgs;
            let thisArg = lastThis;

            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
        }

        function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
            let timeSinceLastCall = time - lastCallTime;
            let timeSinceLastInvoke = time - lastInvokeTime;
            let result = wait - timeSinceLastCall;
            return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result;
        }

        function shouldInvoke(time) {
            let timeSinceLastCall = time - lastCallTime;
            let timeSinceLastInvoke = time - lastInvokeTime;

            return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
        }

        function timerExpired() {
            const time = Date.now();
            if (shouldInvoke(time)) {
                return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
            timerId = undefined;

            if (trailing && lastArgs)
                return invokeFunc(time);
            lastArgs = lastThis = undefined;
            return result;
        }

        function cancel() {
            if (timerId !== undefined)
                clearTimeout(timerId);
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
            return timerId === undefined ? result : trailingEdge(Date.now());
        }

        function debounced() {
            let time = Date.now();
            let isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;

            if (isInvoking) {
                if (timerId === undefined)
                    return leadingEdge(lastCallTime);
                if (maxing) {
                    timerId = setTimeout(timerExpired, wait);
                    return invokeFunc(lastCallTime);
                }
            }
            if (timerId === undefined)
                timerId = setTimeout(timerExpired, wait);
            return result;
        }

        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
    },

    throttle(func, wait, options) {
        let leading = true;
        let trailing = true;

        if (typeof options === "object") {
            leading = "leading"in options ? !!options.leading : leading;
            trailing = "trailing"in options ? !!options.trailing : trailing;
        }

        return this.debounce(func, wait, {
            leading,
            maxWait: wait,
            trailing
        });
    },

    pDelay(msecs, resolveAs) {
        return new Promise(resolve=>setTimeout(()=>resolve(resolveAs), msecs));
    },

    GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST: new Set(["caption", "type", "colLabels", "colLabelGroups", "name", "colStyles", "style", "shortName", "subclassShortName", "id", "path"]),

    getWalker(opts) {
        opts = opts || {};

        if (opts.isBreakOnReturn && !opts.isNoModification)
            throw new Error(`"isBreakOnReturn" may only be used in "isNoModification" mode!`);

        const keyBlocklist = opts.keyBlocklist || new Set();

        const getMappedPrimitive = (obj,primitiveHandlers,lastKey,stack,prop,propPre,propPost)=>{
            if (primitiveHandlers[propPre])
                MiscUtil._getWalker_runHandlers({
                    handlers: primitiveHandlers[propPre],
                    obj,
                    lastKey,
                    stack
                });
            if (primitiveHandlers[prop]) {
                const out = MiscUtil._getWalker_applyHandlers({
                    opts,
                    handlers: primitiveHandlers[prop],
                    obj,
                    lastKey,
                    stack
                });
                if (out === VeCt.SYM_WALKER_BREAK)
                    return out;
                if (!opts.isNoModification)
                    obj = out;
            }
            if (primitiveHandlers[propPost])
                MiscUtil._getWalker_runHandlers({
                    handlers: primitiveHandlers[propPost],
                    obj,
                    lastKey,
                    stack
                });
            return obj;
        }
        ;

        const doObjectRecurse = (obj,primitiveHandlers,stack)=>{
            for (const k of Object.keys(obj)) {
                if (keyBlocklist.has(k))
                    continue;

                const out = fn(obj[k], primitiveHandlers, k, stack);
                if (out === VeCt.SYM_WALKER_BREAK)
                    return VeCt.SYM_WALKER_BREAK;
                if (!opts.isNoModification)
                    obj[k] = out;
            }
        }
        ;

        const fn = (obj,primitiveHandlers,lastKey,stack)=>{
            if (obj === null)
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "null", "preNull", "postNull");

            switch (typeof obj) {
            case "undefined":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "undefined", "preUndefined", "postUndefined");
            case "boolean":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "boolean", "preBoolean", "postBoolean");
            case "number":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "number", "preNumber", "postNumber");
            case "string":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "string", "preString", "postString");
            case "object":
                {
                    if (obj instanceof Array) {
                        if (primitiveHandlers.preArray)
                            MiscUtil._getWalker_runHandlers({
                                handlers: primitiveHandlers.preArray,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            const out = new Array(obj.length);
                            for (let i = 0, len = out.length; i < len; ++i) {
                                out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
                                if (out[i] === VeCt.SYM_WALKER_BREAK)
                                    return out[i];
                            }
                            if (!opts.isNoModification)
                                obj = out;
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.array) {
                                const out = MiscUtil._getWalker_applyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (out === VeCt.SYM_WALKER_BREAK)
                                    return out;
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.array) {
                                const out = MiscUtil._getWalker_applyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (out === VeCt.SYM_WALKER_BREAK)
                                    return out;
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj != null) {
                                const out = new Array(obj.length);
                                for (let i = 0, len = out.length; i < len; ++i) {
                                    if (stack)
                                        stack.push(obj);
                                    out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
                                    if (stack)
                                        stack.pop();
                                    if (out[i] === VeCt.SYM_WALKER_BREAK)
                                        return out[i];
                                }
                                if (!opts.isNoModification)
                                    obj = out;
                            } else {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        }
                        if (primitiveHandlers.postArray)
                            MiscUtil._getWalker_runHandlers({
                                handlers: primitiveHandlers.postArray,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    }

                    if (primitiveHandlers.preObject)
                        MiscUtil._getWalker_runHandlers({
                            handlers: primitiveHandlers.preObject,
                            obj,
                            lastKey,
                            stack
                        });
                    if (opts.isDepthFirst) {
                        if (stack)
                            stack.push(obj);
                        const flag = doObjectRecurse(obj, primitiveHandlers, stack);
                        if (stack)
                            stack.pop();
                        if (flag === VeCt.SYM_WALKER_BREAK)
                            return flag;

                        if (primitiveHandlers.object) {
                            const out = MiscUtil._getWalker_applyHandlers({
                                opts,
                                handlers: primitiveHandlers.object,
                                obj,
                                lastKey,
                                stack
                            });
                            if (out === VeCt.SYM_WALKER_BREAK)
                                return out;
                            if (!opts.isNoModification)
                                obj = out;
                        }
                        if (obj == null) {
                            if (!opts.isAllowDeleteObjects)
                                throw new Error(`Object handler(s) returned null!`);
                        }
                    } else {
                        if (primitiveHandlers.object) {
                            const out = MiscUtil._getWalker_applyHandlers({
                                opts,
                                handlers: primitiveHandlers.object,
                                obj,
                                lastKey,
                                stack
                            });
                            if (out === VeCt.SYM_WALKER_BREAK)
                                return out;
                            if (!opts.isNoModification)
                                obj = out;
                        }
                        if (obj == null) {
                            if (!opts.isAllowDeleteObjects)
                                throw new Error(`Object handler(s) returned null!`);
                        } else {
                            if (stack)
                                stack.push(obj);
                            const flag = doObjectRecurse(obj, primitiveHandlers, stack);
                            if (stack)
                                stack.pop();
                            if (flag === VeCt.SYM_WALKER_BREAK)
                                return flag;
                        }
                    }
                    if (primitiveHandlers.postObject)
                        MiscUtil._getWalker_runHandlers({
                            handlers: primitiveHandlers.postObject,
                            obj,
                            lastKey,
                            stack
                        });
                    return obj;
                }
            default:
                throw new Error(`Unhandled type "${typeof obj}"`);
            }
        }
        ;

        return {
            walk: fn
        };
    },

    _getWalker_applyHandlers({opts, handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        const didBreak = handlers.some(h=>{
            const out = h(obj, lastKey, stack);
            if (opts.isBreakOnReturn && out)
                return true;
            if (!opts.isNoModification)
                obj = out;
        }
        );
        if (didBreak)
            return VeCt.SYM_WALKER_BREAK;
        return obj;
    },

    _getWalker_runHandlers({handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        handlers.forEach(h=>h(obj, lastKey, stack));
    },

    getAsyncWalker(opts) {
        opts = opts || {};
        const keyBlocklist = opts.keyBlocklist || new Set();

        const pFn = async(obj,primitiveHandlers,lastKey,stack)=>{
            if (obj == null) {
                if (primitiveHandlers.null)
                    return MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.null,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            }

            const pDoObjectRecurse = async()=>{
                await Object.keys(obj).pSerialAwaitMap(async k=>{
                    const v = obj[k];
                    if (keyBlocklist.has(k))
                        return;
                    const out = await pFn(v, primitiveHandlers, k, stack);
                    if (!opts.isNoModification)
                        obj[k] = out;
                }
                );
            }
            ;

            const to = typeof obj;
            switch (to) {
            case undefined:
                if (primitiveHandlers.preUndefined)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preUndefined,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.undefined) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.undefined,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postUndefined)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postUndefined,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "boolean":
                if (primitiveHandlers.preBoolean)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preBoolean,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.boolean) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.boolean,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postBoolean)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postBoolean,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "number":
                if (primitiveHandlers.preNumber)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preNumber,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.number) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.number,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postNumber)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postNumber,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "string":
                if (primitiveHandlers.preString)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preString,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.string) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.string,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postString)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postString,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "object":
                {
                    if (obj instanceof Array) {
                        if (primitiveHandlers.preArray)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.preArray,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            const out = await obj.pSerialAwaitMap(it=>pFn(it, primitiveHandlers, lastKey, stack));
                            if (!opts.isNoModification)
                                obj = out;
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.array) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.array) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj != null) {
                                const out = await obj.pSerialAwaitMap(it=>pFn(it, primitiveHandlers, lastKey, stack));
                                if (!opts.isNoModification)
                                    obj = out;
                            } else {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        }
                        if (primitiveHandlers.postArray)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.postArray,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    } else {
                        if (primitiveHandlers.preObject)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.preObject,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            await pDoObjectRecurse();
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.object) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.object,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteObjects)
                                    throw new Error(`Object handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.object) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.object,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteObjects)
                                    throw new Error(`Object handler(s) returned null!`);
                            } else {
                                await pDoObjectRecurse();
                            }
                        }
                        if (primitiveHandlers.postObject)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.postObject,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    }
                }
            default:
                throw new Error(`Unhandled type "${to}"`);
            }
        }
        ;

        return {
            pWalk: pFn
        };
    },

    async _getAsyncWalker_pApplyHandlers({opts, handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        await handlers.pSerialAwaitMap(async pH=>{
            const out = await pH(obj, lastKey, stack);
            if (!opts.isNoModification)
                obj = out;
        }
        );
        return obj;
    },

    async _getAsyncWalker_pRunHandlers({handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        await handlers.pSerialAwaitMap(pH=>pH(obj, lastKey, stack));
    },

    pDefer(fn) {
        return (async()=>fn())();
    },
};
//#endregion
//#region SortUtil
globalThis.SortUtil = {
    ascSort: (a,b)=>{
        if (typeof FilterItem !== "undefined") {
            if (a instanceof FilterItem)
                a = a.item;
            if (b instanceof FilterItem)
                b = b.item;
        }

        return SortUtil._ascSort(a, b);
    }
    ,

    ascSortProp: (prop,a,b)=>{
        return SortUtil.ascSort(a[prop], b[prop]);
    }
    ,

    ascSortLower: (a,b)=>{
        if (typeof FilterItem !== "undefined") {
            if (a instanceof FilterItem)
                a = a.item;
            if (b instanceof FilterItem)
                b = b.item;
        }

        a = a ? a.toLowerCase() : a;
        b = b ? b.toLowerCase() : b;

        return SortUtil._ascSort(a, b);
    }
    ,

    ascSortLowerProp: (prop,a,b)=>{
        return SortUtil.ascSortLower(a[prop], b[prop]);
    }
    ,

    ascSortNumericalSuffix(a, b) {
        if (typeof FilterItem !== "undefined") {
            if (a instanceof FilterItem)
                a = a.item;
            if (b instanceof FilterItem)
                b = b.item;
        }

        function popEndNumber(str) {
            const spl = str.split(" ");
            return spl.last().isNumeric() ? [spl.slice(0, -1).join(" "), Number(spl.last().replace(Parser._numberCleanRegexp, ""))] : [spl.join(" "), 0];
        }

        const [aStr,aNum] = popEndNumber(a.item || a);
        const [bStr,bNum] = popEndNumber(b.item || b);
        const initialSort = SortUtil.ascSort(aStr, bStr);
        if (initialSort)
            return initialSort;
        return SortUtil.ascSort(aNum, bNum);
    },

    _ascSort: (a,b)=>{
        if (b === a)
            return 0;
        return b < a ? 1 : -1;
    }
    ,

    ascSortDate(a, b) {
        return b.getTime() - a.getTime();
    },

    ascSortDateString(a, b) {
        return SortUtil.ascSortDate(new Date(a || "1970-01-0"), new Date(b || "1970-01-0"));
    },

    compareListNames(a, b) {
        return SortUtil._ascSort(a.name.toLowerCase(), b.name.toLowerCase());
    },

    listSort(a, b, opts) {
        opts = opts || {
            sortBy: "name"
        };
        if (opts.sortBy === "name")
            return SortUtil.compareListNames(a, b);
        else
            return SortUtil._compareByOrDefault_compareByOrDefault(a, b, opts.sortBy);
    },

    _listSort_compareBy(a, b, sortBy) {
        const aValue = typeof a.values[sortBy] === "string" ? a.values[sortBy].toLowerCase() : a.values[sortBy];
        const bValue = typeof b.values[sortBy] === "string" ? b.values[sortBy].toLowerCase() : b.values[sortBy];

        return SortUtil._ascSort(aValue, bValue);
    },

    _compareByOrDefault_compareByOrDefault(a, b, sortBy) {
        return SortUtil._listSort_compareBy(a, b, sortBy) || SortUtil.compareListNames(a, b);
    },

    _MON_TRAIT_ORDER: ["special equipment", "shapechanger", ],
    monTraitSort: (a,b)=>{
        if (a.sort != null && b.sort != null)
            return a.sort - b.sort;
        if (a.sort != null && b.sort == null)
            return -1;
        if (a.sort == null && b.sort != null)
            return 1;

        if (!a.name && !b.name)
            return 0;
        const aClean = Renderer.stripTags(a.name).toLowerCase().trim();
        const bClean = Renderer.stripTags(b.name).toLowerCase().trim();

        const isOnlyA = a.name.endsWith(" Only)");
        const isOnlyB = b.name.endsWith(" Only)");
        if (!isOnlyA && isOnlyB)
            return -1;
        if (isOnlyA && !isOnlyB)
            return 1;

        const ixA = SortUtil._MON_TRAIT_ORDER.indexOf(aClean);
        const ixB = SortUtil._MON_TRAIT_ORDER.indexOf(bClean);
        if (~ixA && ~ixB)
            return ixA - ixB;
        else if (~ixA)
            return -1;
        else if (~ixB)
            return 1;
        else
            return SortUtil.ascSort(aClean, bClean);
    }
    ,

    _alignFirst: ["L", "C"],
    _alignSecond: ["G", "E"],
    alignmentSort: (a,b)=>{
        if (a === b)
            return 0;
        if (SortUtil._alignFirst.includes(a))
            return -1;
        if (SortUtil._alignSecond.includes(a))
            return 1;
        if (SortUtil._alignFirst.includes(b))
            return 1;
        if (SortUtil._alignSecond.includes(b))
            return -1;
        return 0;
    }
    ,

    ascSortCr(a, b) {
        if (typeof FilterItem !== "undefined") {
            if (a instanceof FilterItem)
                a = a.item;
            if (b instanceof FilterItem)
                b = b.item;
        }
        if (a === "Unknown")
            a = "998";
        if (b === "Unknown")
            b = "998";
        if (a === "\u2014" || a == null)
            a = "999";
        if (b === "\u2014" || b == null)
            b = "999";
        return SortUtil.ascSort(Parser.crToNumber(a), Parser.crToNumber(b));
    },

    ascSortAtts(a, b) {
        const aSpecial = a === "special";
        const bSpecial = b === "special";
        return aSpecial && bSpecial ? 0 : aSpecial ? 1 : bSpecial ? -1 : Parser.ABIL_ABVS.indexOf(a) - Parser.ABIL_ABVS.indexOf(b);
    },

    ascSortSize(a, b) {
        return Parser.SIZE_ABVS.indexOf(a) - Parser.SIZE_ABVS.indexOf(b);
    },

    initBtnSortHandlers($wrpBtnsSort, list) {
        let dispCaretInitial = null;

        const dispCarets = [...$wrpBtnsSort[0].querySelectorAll(`[data-sort]`)].map(btnSort=>{
            const dispCaret = e_({
                tag: "span",
                clazz: "lst__caret",
            }).appendTo(btnSort);

            const btnSortField = btnSort.dataset.sort;

            if (btnSortField === list.sortBy)
                dispCaretInitial = dispCaret;

            e_({
                ele: btnSort,
                click: evt=>{
                    evt.stopPropagation();
                    const direction = list.sortDir === "asc" ? "desc" : "asc";
                    SortUtil._initBtnSortHandlers_showCaret({
                        dispCarets,
                        dispCaret,
                        direction
                    });
                    list.sort(btnSortField, direction);
                }
                ,
            });

            return dispCaret;
        }
        );

        dispCaretInitial = dispCaretInitial || dispCarets[0];
        SortUtil._initBtnSortHandlers_showCaret({
            dispCaret: dispCaretInitial,
            dispCarets,
            direction: list.sortDir
        });
    },

    _initBtnSortHandlers_showCaret({dispCaret, dispCarets, direction, }, ) {
        dispCarets.forEach($it=>$it.removeClass("lst__caret--active"));
        dispCaret.addClass("lst__caret--active").toggleClass("lst__caret--reverse", direction === "asc");
    },

    initBtnSortHandlersAdditional($wrpBtnsSort, list) {
        [...$wrpBtnsSort[0].querySelectorAll(".sort")].map(btnSort=>{
            const btnSortField = btnSort.dataset.sort;

            e_({
                ele: btnSort,
                click: evt=>{
                    evt.stopPropagation();
                    const direction = list.sortDir === "asc" ? "desc" : "asc";
                    list.sort(btnSortField, direction);
                }
                ,
            });
        }
        );
    },

    ascSortSourceGroup(a, b) {
        const grpA = a.group || "other";
        const grpB = b.group || "other";
        const ixA = SourceUtil.ADV_BOOK_GROUPS.findIndex(it=>it.group === grpA);
        const ixB = SourceUtil.ADV_BOOK_GROUPS.findIndex(it=>it.group === grpB);
        return SortUtil.ascSort(ixA, ixB);
    },

    ascSortAdventure(a, b) {
        return SortUtil.ascSortDateString(b.published, a.published) || SortUtil.ascSortLower(a.parentSource || "", b.parentSource || "") || SortUtil.ascSort(a.publishedOrder ?? 0, b.publishedOrder ?? 0) || SortUtil.ascSortLower(a.storyline, b.storyline) || SortUtil.ascSort(a.level?.start ?? 20, b.level?.start ?? 20) || SortUtil.ascSortLower(a.name, b.name);
    },

    ascSortBook(a, b) {
        return SortUtil.ascSortDateString(b.published, a.published) || SortUtil.ascSortLower(a.parentSource || "", b.parentSource || "") || SortUtil.ascSortLower(a.name, b.name);
    },

    ascSortBookData(a, b) {
        return SortUtil.ascSortLower(a.id || "", b.id || "");
    },

    ascSortGenericEntity(a, b) {
        return SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source);
    },

    ascSortDeity(a, b) {
        return SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source) || SortUtil.ascSortLower(a.pantheon, b.pantheon);
    },

    ascSortCard(a, b) {
        return SortUtil.ascSortLower(a.set, b.set) || SortUtil.ascSortLower(a.source, b.source) || SortUtil.ascSortLower(a.name, b.name);
    },

    ascSortEncounter(a, b) {
        return SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.caption || "", b.caption || "") || SortUtil.ascSort(a.minlvl || 0, b.minlvl || 0) || SortUtil.ascSort(a.maxlvl || Number.MAX_SAFE_INTEGER, b.maxlvl || Number.MAX_SAFE_INTEGER);
    },

    _ITEM_RARITY_ORDER: ["none", "common", "uncommon", "rare", "very rare", "legendary", "artifact", "varies", "unknown (magic)", "unknown"],
    ascSortItemRarity(a, b) {
        const ixA = SortUtil._ITEM_RARITY_ORDER.indexOf(a);
        const ixB = SortUtil._ITEM_RARITY_ORDER.indexOf(b);
        return (~ixA ? ixA : Number.MAX_SAFE_INTEGER) - (~ixB ? ixB : Number.MAX_SAFE_INTEGER);
    },
};
//#endregion
//#region UtilActors

//#endregion
//#region VeCt
globalThis.IS_DEPLOYED = undefined;
globalThis.VERSION_NUMBER = "1.197.0";
globalThis.DEPLOYED_STATIC_ROOT = "";
globalThis.DEPLOYED_IMG_ROOT = undefined;
globalThis.IS_VTT = false;

globalThis.IMGUR_CLIENT_ID = `abdea4de492d3b0`;

globalThis.HASH_PART_SEP = ",";
globalThis.HASH_LIST_SEP = "_";
globalThis.HASH_SUB_LIST_SEP = "~";
globalThis.HASH_SUB_KV_SEP = ":";
globalThis.HASH_BLANK = "blankhash";
globalThis.HASH_SUB_NONE = "null";
globalThis.VeCt = {
    STR_NONE: "None",
    STR_SEE_CONSOLE: "See the console (CTRL+SHIFT+J) for details.",

    HASH_SCALED: "scaled",
    HASH_SCALED_SPELL_SUMMON: "scaledspellsummon",
    HASH_SCALED_CLASS_SUMMON: "scaledclasssummon",

    FILTER_BOX_SUB_HASH_SEARCH_PREFIX: "fbsr",

    JSON_PRERELEASE_INDEX: `prerelease/index.json`,
    JSON_BREW_INDEX: `homebrew/index.json`,

    STORAGE_HOMEBREW: "HOMEBREW_STORAGE",
    STORAGE_HOMEBREW_META: "HOMEBREW_META_STORAGE",
    STORAGE_EXCLUDES: "EXCLUDES_STORAGE",
    STORAGE_DMSCREEN: "DMSCREEN_STORAGE",
    STORAGE_DMSCREEN_TEMP_SUBLIST: "DMSCREEN_TEMP_SUBLIST",
    STORAGE_ROLLER_MACRO: "ROLLER_MACRO_STORAGE",
    STORAGE_ENCOUNTER: "ENCOUNTER_STORAGE",
    STORAGE_POINTBUY: "POINTBUY_STORAGE",
    STORAGE_GLOBAL_COMPONENT_STATE: "GLOBAL_COMPONENT_STATE",

    DUR_INLINE_NOTIFY: 500,

    PG_NONE: "NO_PAGE",
    STR_GENERIC: "Generic",

    SYM_UI_SKIP: Symbol("uiSkip"),

    SYM_WALKER_BREAK: Symbol("walkerBreak"),

    SYM_UTIL_TIMEOUT: Symbol("timeout"),

    LOC_ORIGIN_CANCER: "https://5e.tools",

    URL_BREW: `https://github.com/TheGiddyLimit/homebrew`,
    URL_ROOT_BREW: `https://raw.githubusercontent.com/TheGiddyLimit/homebrew/master/`,
    URL_PRERELEASE: `https://github.com/TheGiddyLimit/unearthed-arcana`,
    URL_ROOT_PRERELEASE: `https://raw.githubusercontent.com/TheGiddyLimit/unearthed-arcana/master/`,
    STR_NO_ATTUNEMENT: "No Attunement Required",

    CR_UNKNOWN: 100001,
    CR_CUSTOM: 100000,

    SPELL_LEVEL_MAX: 9,
    LEVEL_MAX: 20,

    ENTDATA_TABLE_INCLUDE: "tableInclude",
    ENTDATA_ITEM_MERGED_ENTRY_TAG: "item__mergedEntryTag",

    DRAG_TYPE_IMPORT: "ve-Import",
    DRAG_TYPE_LOOT: "ve-Loot",

    Z_INDEX_BENEATH_HOVER: 199,
};
//#endregion
//#region UrlUtil
globalThis.UrlUtil = {
    encodeForHash(toEncode) {
        if (toEncode instanceof Array)
            return toEncode.map(it=>`${it}`.toUrlified()).join(HASH_LIST_SEP);
        else
            return `${toEncode}`.toUrlified();
    },

    encodeArrayForHash(...toEncodes) {
        return toEncodes.map(UrlUtil.encodeForHash).join(HASH_LIST_SEP);
    },

    autoEncodeHash(obj) {
        const curPage = UrlUtil.getCurrentPage();
        const encoder = UrlUtil.URL_TO_HASH_BUILDER[curPage];
        if (!encoder)
            throw new Error(`No encoder found for page ${curPage}`);
        return encoder(obj);
    },

    decodeHash(hash) {
        return hash.split(HASH_LIST_SEP).map(it=>decodeURIComponent(it));
    },

    getSluggedHash(hash) {
        return Parser.stringToSlug(decodeURIComponent(hash)).replace(/_/g, "-");
    },

    getCurrentPage() {
        if (typeof window === "undefined")
            return VeCt.PG_NONE;
        const pSplit = window.location.pathname.split("/");
        let out = pSplit[pSplit.length - 1];
        if (!out.toLowerCase().endsWith(".html"))
            out += ".html";
        return out;
    },

    link(href, {isBustCache=false}={}) {
        if (isBustCache)
            return UrlUtil._link_getWithParam(href, {
                param: `t=${Date.now()}`
            });
        return href;
    },

    _link_getWithParam(href, {param=`v=${VERSION_NUMBER}`}={}) {
        if (href.includes("?"))
            return `${href}&${param}`;
        return `${href}?${param}`;
    },

    unpackSubHash(subHash, unencode) {
        if (subHash.includes(HASH_SUB_KV_SEP)) {
            const keyValArr = subHash.split(HASH_SUB_KV_SEP).map(s=>s.trim());
            const out = {};
            let k = keyValArr[0].toLowerCase();
            if (unencode)
                k = decodeURIComponent(k);
            let v = keyValArr[1].toLowerCase();
            if (unencode)
                v = decodeURIComponent(v);
            out[k] = v.split(HASH_SUB_LIST_SEP).map(s=>s.trim());
            if (out[k].length === 1 && out[k] === HASH_SUB_NONE)
                out[k] = [];
            return out;
        } else {
            throw new Error(`Badly formatted subhash ${subHash}`);
        }
    },

    packSubHash(key, values, opts) {
        opts = opts || {};
        if (opts.isEncodeBoth || opts.isEncodeKey)
            key = key.toUrlified();
        if (opts.isEncodeBoth || opts.isEncodeValues)
            values = values.map(it=>it.toUrlified());
        return `${key}${HASH_SUB_KV_SEP}${values.join(HASH_SUB_LIST_SEP)}`;
    },

    categoryToPage(category) {
        return UrlUtil.CAT_TO_PAGE[category];
    },
    categoryToHoverPage(category) {
        return UrlUtil.CAT_TO_HOVER_PAGE[category] || UrlUtil.categoryToPage(category);
    },

    pageToDisplayPage(page) {
        return UrlUtil.PG_TO_NAME[page] || page;
    },

    getFilename(url) {
        return url.slice(url.lastIndexOf("/") + 1);
    },

    isFullUrl(url) {
        return url && /^.*?:\/\//.test(url);
    },

    mini: {
        compress(primitive) {
            const type = typeof primitive;
            if (primitive === undefined)
                return "u";
            if (primitive === null)
                return "x";
            switch (type) {
            case "boolean":
                return `b${Number(primitive)}`;
            case "number":
                return `n${primitive}`;
            case "string":
                return `s${primitive.toUrlified()}`;
            default:
                throw new Error(`Unhandled type "${type}"`);
            }
        },

        decompress(raw) {
            const [type,data] = [raw.slice(0, 1), raw.slice(1)];
            switch (type) {
            case "u":
                return undefined;
            case "x":
                return null;
            case "b":
                return !!Number(data);
            case "n":
                return Number(data);
            case "s":
                return decodeURIComponent(String(data));
            default:
                throw new Error(`Unhandled type "${type}"`);
            }
        },
    },

    class: {
        getIndexedClassEntries(cls) {
            const out = [];

            (cls.classFeatures || []).forEach((lvlFeatureList,ixLvl)=>{
                lvlFeatureList.filter(feature=>(!feature.gainSubclassFeature || feature.gainSubclassFeatureHasContent) && feature.name !== "Ability Score Improvement" && feature.name !== "Proficiency Versatility").forEach((feature,ixFeature)=>{
                    const name = Renderer.findName(feature);
                    if (!name) {
                        if (BrewUtil2.hasSourceJson(cls.source))
                            return;
                        else
                            throw new Error("Class feature had no name!");
                    }
                    out.push({
                        _type: "classFeature",
                        source: cls.source.source || cls.source,
                        name,
                        hash: `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](cls)}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                            feature: {
                                ixLevel: ixLvl,
                                ixFeature: ixFeature
                            }
                        })}`,
                        entry: feature,
                        level: ixLvl + 1,
                    });
                }
                );
            }
            );

            return out;
        },

        getIndexedSubclassEntries(sc) {
            const out = [];

            const lvlFeatures = sc.subclassFeatures || [];
            sc.source = sc.source || sc.classSource;
            lvlFeatures.forEach(lvlFeature=>{
                lvlFeature.forEach((feature,ixFeature)=>{
                    const subclassFeatureHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
                        name: sc.className,
                        source: sc.classSource
                    })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                        subclass: sc,
                        feature: {
                            ixLevel: feature.level - 1,
                            ixFeature: ixFeature
                        }
                    })}`;

                    const name = Renderer.findName(feature);
                    if (!name) {
                        if (BrewUtil2.hasSourceJson(sc.source))
                            return;
                        else
                            throw new Error("Subclass feature had no name!");
                    }
                    out.push({
                        _type: "subclassFeature",
                        name,
                        subclassName: sc.name,
                        subclassShortName: sc.shortName,
                        source: sc.source.source || sc.source,
                        hash: subclassFeatureHash,
                        entry: feature,
                        level: feature.level,
                    });

                    if (feature.entries) {
                        const namedFeatureParts = feature.entries.filter(it=>it.name);
                        namedFeatureParts.forEach(it=>{
                            if (out.find(existing=>it.name === existing.name && feature.level === existing.level))
                                return;
                            out.push({
                                _type: "subclassFeaturePart",
                                name: it.name,
                                subclassName: sc.name,
                                subclassShortName: sc.shortName,
                                source: sc.source.source || sc.source,
                                hash: subclassFeatureHash,
                                entry: feature,
                                level: feature.level,
                            });
                        }
                        );
                    }
                }
                );
            }
            );

            return out;
        },
    },

    getStateKeySubclass(sc) {
        return Parser.stringToSlug(`sub ${sc.shortName || sc.name} ${sc.source}`);
    },

    getClassesPageStatePart(opts) {
        if (!opts.subclass && !opts.feature)
            return "";

        if (!opts.feature)
            return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_subclass(opts.subclass)]);
        if (!opts.subclass)
            return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_feature(opts.feature)]);

        return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_subclass(opts.subclass), UrlUtil._getClassesPageStatePart_feature(opts.feature), ], );
    },

    _getClassesPageStatePart_subclass(sc) {
        return `${UrlUtil.getStateKeySubclass(sc)}=${UrlUtil.mini.compress(true)}`;
    },
    _getClassesPageStatePart_feature(feature) {
        return `feature=${UrlUtil.mini.compress(`${feature.ixLevel}-${feature.ixFeature}`)}`;
    },
};

UrlUtil.PG_BESTIARY = "bestiary.html";
UrlUtil.PG_SPELLS = "spells.html";
UrlUtil.PG_BACKGROUNDS = "backgrounds.html";
UrlUtil.PG_ITEMS = "items.html";
UrlUtil.PG_CLASSES = "classes.html";
UrlUtil.PG_CONDITIONS_DISEASES = "conditionsdiseases.html";
UrlUtil.PG_FEATS = "feats.html";
UrlUtil.PG_OPT_FEATURES = "optionalfeatures.html";
UrlUtil.PG_PSIONICS = "psionics.html";
UrlUtil.PG_RACES = "races.html";
UrlUtil.PG_REWARDS = "rewards.html";
UrlUtil.PG_VARIANTRULES = "variantrules.html";
UrlUtil.PG_ADVENTURE = "adventure.html";
UrlUtil.PG_ADVENTURES = "adventures.html";
UrlUtil.PG_BOOK = "book.html";
UrlUtil.PG_BOOKS = "books.html";
UrlUtil.PG_DEITIES = "deities.html";
UrlUtil.PG_CULTS_BOONS = "cultsboons.html";
UrlUtil.PG_OBJECTS = "objects.html";
UrlUtil.PG_TRAPS_HAZARDS = "trapshazards.html";
UrlUtil.PG_QUICKREF = "quickreference.html";
UrlUtil.PG_MANAGE_BREW = "managebrew.html";
UrlUtil.PG_MANAGE_PRERELEASE = "manageprerelease.html";
UrlUtil.PG_MAKE_BREW = "makebrew.html";
UrlUtil.PG_DEMO_RENDER = "renderdemo.html";
UrlUtil.PG_TABLES = "tables.html";
UrlUtil.PG_VEHICLES = "vehicles.html";
UrlUtil.PG_CHARACTERS = "characters.html";
UrlUtil.PG_ACTIONS = "actions.html";
UrlUtil.PG_LANGUAGES = "languages.html";
UrlUtil.PG_STATGEN = "statgen.html";
UrlUtil.PG_LIFEGEN = "lifegen.html";
UrlUtil.PG_NAMES = "names.html";
UrlUtil.PG_DM_SCREEN = "dmscreen.html";
UrlUtil.PG_CR_CALCULATOR = "crcalculator.html";
UrlUtil.PG_ENCOUNTERGEN = "encountergen.html";
UrlUtil.PG_LOOTGEN = "lootgen.html";
UrlUtil.PG_TEXT_CONVERTER = "converter.html";
UrlUtil.PG_CHANGELOG = "changelog.html";
UrlUtil.PG_CHAR_CREATION_OPTIONS = "charcreationoptions.html";
UrlUtil.PG_RECIPES = "recipes.html";
UrlUtil.PG_CLASS_SUBCLASS_FEATURES = "classfeatures.html";
UrlUtil.PG_CREATURE_FEATURES = "creaturefeatures.html";
UrlUtil.PG_VEHICLE_FEATURES = "vehiclefeatures.html";
UrlUtil.PG_OBJECT_FEATURES = "objectfeatures.html";
UrlUtil.PG_TRAP_FEATURES = "trapfeatures.html";
UrlUtil.PG_MAPS = "maps.html";
UrlUtil.PG_SEARCH = "search.html";
UrlUtil.PG_DECKS = "decks.html";

UrlUtil.URL_TO_HASH_GENERIC = (it)=>UrlUtil.encodeArrayForHash(it.name, it.source);

UrlUtil.URL_TO_HASH_BUILDER = {};
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE] = (it)=>UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK] = (it)=>UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.pantheon, it.source);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES] = (it)=>`${UrlUtil.encodeArrayForHash(it.name, it.source)}${it._scaleFactor ? `${HASH_PART_SEP}${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}${it._scaleFactor}` : ""}`;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASS_SUBCLASS_FEATURES] = (it)=>(it.__prop === "subclassFeature" || it.subclassSource) ? UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](it) : UrlUtil.URL_TO_HASH_BUILDER["classFeature"](it);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CREATURE_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLE_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECT_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAP_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_QUICKREF] = ({name, ixChapter, ixHeader})=>{
    const hashParts = ["bookref-quick", ixChapter, UrlUtil.encodeForHash(name.toLowerCase())];
    if (ixHeader)
        hashParts.push(ixHeader);
    return hashParts.join(HASH_PART_SEP);
}
;

UrlUtil.URL_TO_HASH_BUILDER["monster"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY];
UrlUtil.URL_TO_HASH_BUILDER["spell"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS];
UrlUtil.URL_TO_HASH_BUILDER["background"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS];
UrlUtil.URL_TO_HASH_BUILDER["item"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["itemGroup"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["baseitem"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["magicvariant"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["class"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES];
UrlUtil.URL_TO_HASH_BUILDER["condition"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["disease"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["status"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["feat"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS];
UrlUtil.URL_TO_HASH_BUILDER["optionalfeature"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES];
UrlUtil.URL_TO_HASH_BUILDER["psionic"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS];
UrlUtil.URL_TO_HASH_BUILDER["race"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES];
UrlUtil.URL_TO_HASH_BUILDER["subrace"] = (it)=>UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES]({
    name: `${it.name} (${it.raceName})`,
    source: it.source
});
UrlUtil.URL_TO_HASH_BUILDER["reward"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS];
UrlUtil.URL_TO_HASH_BUILDER["variantrule"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES];
UrlUtil.URL_TO_HASH_BUILDER["adventure"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES];
UrlUtil.URL_TO_HASH_BUILDER["adventureData"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES];
UrlUtil.URL_TO_HASH_BUILDER["book"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS];
UrlUtil.URL_TO_HASH_BUILDER["bookData"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS];
UrlUtil.URL_TO_HASH_BUILDER["deity"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES];
UrlUtil.URL_TO_HASH_BUILDER["cult"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS];
UrlUtil.URL_TO_HASH_BUILDER["boon"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS];
UrlUtil.URL_TO_HASH_BUILDER["object"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS];
UrlUtil.URL_TO_HASH_BUILDER["trap"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS];
UrlUtil.URL_TO_HASH_BUILDER["hazard"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS];
UrlUtil.URL_TO_HASH_BUILDER["table"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES];
UrlUtil.URL_TO_HASH_BUILDER["tableGroup"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES];
UrlUtil.URL_TO_HASH_BUILDER["vehicle"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES];
UrlUtil.URL_TO_HASH_BUILDER["vehicleUpgrade"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES];
UrlUtil.URL_TO_HASH_BUILDER["action"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS];
UrlUtil.URL_TO_HASH_BUILDER["language"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES];
UrlUtil.URL_TO_HASH_BUILDER["charoption"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS];
UrlUtil.URL_TO_HASH_BUILDER["recipe"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES];
UrlUtil.URL_TO_HASH_BUILDER["deck"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS];

UrlUtil.URL_TO_HASH_BUILDER["subclass"] = it=>{
    return Hist.util.getCleanHash(`${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
        name: it.className,
        source: it.classSource
    })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
        subclass: it
    })}`, );
}
;
UrlUtil.URL_TO_HASH_BUILDER["classFeature"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.className, it.classSource, it.level, it.source);
UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.className, it.classSource, it.subclassShortName, it.subclassSource, it.level, it.source);
UrlUtil.URL_TO_HASH_BUILDER["card"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.set, it.source);
UrlUtil.URL_TO_HASH_BUILDER["legendaryGroup"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["itemEntry"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["itemProperty"] = (it)=>UrlUtil.encodeArrayForHash(it.abbreviation, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemType"] = (it)=>UrlUtil.encodeArrayForHash(it.abbreviation, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemTypeAdditionalEntries"] = (it)=>UrlUtil.encodeArrayForHash(it.appliesTo, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemMastery"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["skill"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["sense"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["raceFeature"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.raceName, it.raceSource, it.source);
UrlUtil.URL_TO_HASH_BUILDER["citation"] = UrlUtil.URL_TO_HASH_GENERIC;

Object.keys(UrlUtil.URL_TO_HASH_BUILDER).filter(k=>!k.endsWith(".html") && k.toLowerCase() !== k).forEach(k=>UrlUtil.URL_TO_HASH_BUILDER[k.toLowerCase()] = UrlUtil.URL_TO_HASH_BUILDER[k]);

Object.keys(UrlUtil.URL_TO_HASH_BUILDER).filter(k=>!k.endsWith(".html")).forEach(k=>UrlUtil.URL_TO_HASH_BUILDER[`raw_${k}`] = UrlUtil.URL_TO_HASH_BUILDER[k]);

Object.keys(UrlUtil.URL_TO_HASH_BUILDER).filter(k=>!k.endsWith(".html")).forEach(k=>{
    UrlUtil.URL_TO_HASH_BUILDER[`${k}Fluff`] = UrlUtil.URL_TO_HASH_BUILDER[k];
    UrlUtil.URL_TO_HASH_BUILDER[`${k}Template`] = UrlUtil.URL_TO_HASH_BUILDER[k];
}
);

UrlUtil.PG_TO_NAME = {};
UrlUtil.PG_TO_NAME[UrlUtil.PG_BESTIARY] = "Bestiary";
UrlUtil.PG_TO_NAME[UrlUtil.PG_SPELLS] = "Spells";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BACKGROUNDS] = "Backgrounds";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ITEMS] = "Items";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CLASSES] = "Classes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CONDITIONS_DISEASES] = "Conditions & Diseases";
UrlUtil.PG_TO_NAME[UrlUtil.PG_FEATS] = "Feats";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OPT_FEATURES] = "Other Options and Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_PSIONICS] = "Psionics";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RACES] = "Races";
UrlUtil.PG_TO_NAME[UrlUtil.PG_REWARDS] = "Supernatural Gifts & Rewards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VARIANTRULES] = "Optional, Variant, and Expanded Rules";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ADVENTURES] = "Adventures";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BOOKS] = "Books";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEITIES] = "Deities";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CULTS_BOONS] = "Cults & Supernatural Boons";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OBJECTS] = "Objects";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TRAPS_HAZARDS] = "Traps & Hazards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_QUICKREF] = "Quick Reference";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_BREW] = "Homebrew Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_PRERELEASE] = "Prerelease Content Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAKE_BREW] = "Homebrew Builder";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEMO_RENDER] = "Renderer Demo";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TABLES] = "Tables";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VEHICLES] = "Vehicles";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ACTIONS] = "Actions";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LANGUAGES] = "Languages";
UrlUtil.PG_TO_NAME[UrlUtil.PG_STATGEN] = "Stat Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LIFEGEN] = "This Is Your Life";
UrlUtil.PG_TO_NAME[UrlUtil.PG_NAMES] = "Names";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DM_SCREEN] = "DM Screen";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CR_CALCULATOR] = "CR Calculator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ENCOUNTERGEN] = "Encounter Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LOOTGEN] = "Loot Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TEXT_CONVERTER] = "Text Converter";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHANGELOG] = "Changelog";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHAR_CREATION_OPTIONS] = "Other Character Creation Options";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RECIPES] = "Recipes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CREATURE_FEATURES] = "Creature Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VEHICLE_FEATURES] = "Vehicle Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OBJECT_FEATURES] = "Object Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TRAP_FEATURES] = "Trap Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAPS] = "Maps";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DECKS] = "Decks";

UrlUtil.CAT_TO_PAGE = {};
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CREATURE] = UrlUtil.PG_BESTIARY;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SPELL] = UrlUtil.PG_SPELLS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BACKGROUND] = UrlUtil.PG_BACKGROUNDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ITEM] = UrlUtil.PG_ITEMS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CONDITION] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FEAT] = UrlUtil.PG_FEATS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELDRITCH_INVOCATION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_METAMAGIC] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_CAVALIER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARCANE_SHOT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FIGHTING_STYLE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PSIONIC] = UrlUtil.PG_PSIONICS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RACE] = UrlUtil.PG_RACES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OTHER_REWARD] = UrlUtil.PG_REWARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = UrlUtil.PG_VARIANTRULES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ADVENTURE] = UrlUtil.PG_ADVENTURE;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DEITY] = UrlUtil.PG_DEITIES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OBJECT] = UrlUtil.PG_OBJECTS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TRAP] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_HAZARD] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_QUICKREF] = UrlUtil.PG_QUICKREF;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CULT] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOON] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DISEASE] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE_GROUP] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VEHICLE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PACT_BOON] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARTIFICER_INFUSION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SHIP_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ONOMANCY_RESONANT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ALCHEMICAL_FORMULA] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ACTION] = UrlUtil.PG_ACTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LANGUAGE] = UrlUtil.PG_LANGUAGES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOOK] = UrlUtil.PG_BOOK;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PAGE] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = UrlUtil.PG_CHAR_CREATION_OPTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RECIPES] = UrlUtil.PG_RECIPES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_STATUS] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DECK] = UrlUtil.PG_DECKS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CARD] = "card";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SKILLS] = "skill";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SENSES] = "sense";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";

UrlUtil.CAT_TO_HOVER_PAGE = {};
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CLASS_FEATURE] = "classfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CARD] = "card";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SKILLS] = "skill";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SENSES] = "sense";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";

/* UrlUtil.HASH_START_CREATURE_SCALED = `${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_SPELL_SUMMON = `${VeCt.HASH_SCALED_SPELL_SUMMON}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_CLASS_SUMMON = `${VeCt.HASH_SCALED_CLASS_SUMMON}${HASH_SUB_KV_SEP}`; */

UrlUtil.SUBLIST_PAGES = {
    [UrlUtil.PG_BESTIARY]: true,
    [UrlUtil.PG_SPELLS]: true,
    [UrlUtil.PG_BACKGROUNDS]: true,
    [UrlUtil.PG_ITEMS]: true,
    [UrlUtil.PG_CONDITIONS_DISEASES]: true,
    [UrlUtil.PG_FEATS]: true,
    [UrlUtil.PG_OPT_FEATURES]: true,
    [UrlUtil.PG_PSIONICS]: true,
    [UrlUtil.PG_RACES]: true,
    [UrlUtil.PG_REWARDS]: true,
    [UrlUtil.PG_VARIANTRULES]: true,
    [UrlUtil.PG_DEITIES]: true,
    [UrlUtil.PG_CULTS_BOONS]: true,
    [UrlUtil.PG_OBJECTS]: true,
    [UrlUtil.PG_TRAPS_HAZARDS]: true,
    [UrlUtil.PG_TABLES]: true,
    [UrlUtil.PG_VEHICLES]: true,
    [UrlUtil.PG_ACTIONS]: true,
    [UrlUtil.PG_LANGUAGES]: true,
    [UrlUtil.PG_CHAR_CREATION_OPTIONS]: true,
    [UrlUtil.PG_RECIPES]: true,
    [UrlUtil.PG_DECKS]: true,
};

UrlUtil.PAGE_TO_PROPS = {};
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_SPELLS] = ["spell"];
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_ITEMS] = ["item", "itemGroup", "itemType", "itemEntry", "itemProperty", "itemTypeAdditionalEntries", "itemMastery", "baseitem", "magicvariant"];
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_RACES] = ["race", "subrace"];
//#endregion
//#endregion

//#region Extension Functions
String.prototype.uppercaseFirst = String.prototype.uppercaseFirst || function() {
    const str = this.toString();
    if (str.length === 0)
        return str;
    if (str.length === 1)
        return str.charAt(0).toUpperCase();
    return str.charAt(0).toUpperCase() + str.slice(1);
}
;

String.prototype.lowercaseFirst = String.prototype.lowercaseFirst || function() {
    const str = this.toString();
    if (str.length === 0)
        return str;
    if (str.length === 1)
        return str.charAt(0).toLowerCase();
    return str.charAt(0).toLowerCase() + str.slice(1);
}
;

String.prototype.toTitleCase = String.prototype.toTitleCase || function() {
    let str = this.replace(/([^\W_]+[^-\u2014\s/]*) */g, m0=>m0.charAt(0).toUpperCase() + m0.substring(1).toLowerCase());

    StrUtil._TITLE_LOWER_WORDS_RE = StrUtil._TITLE_LOWER_WORDS_RE || StrUtil.TITLE_LOWER_WORDS.map(it=>new RegExp(`\\s${it}\\s`,"gi"));
    StrUtil._TITLE_UPPER_WORDS_RE = StrUtil._TITLE_UPPER_WORDS_RE || StrUtil.TITLE_UPPER_WORDS.map(it=>new RegExp(`\\b${it}\\b`,"g"));
    StrUtil._TITLE_UPPER_WORDS_PLURAL_RE = StrUtil._TITLE_UPPER_WORDS_PLURAL_RE || StrUtil.TITLE_UPPER_WORDS_PLURAL.map(it=>new RegExp(`\\b${it}\\b`,"g"));

    const len = StrUtil.TITLE_LOWER_WORDS.length;
    for (let i = 0; i < len; i++) {
        str = str.replace(StrUtil._TITLE_LOWER_WORDS_RE[i], txt=>txt.toLowerCase(), );
    }

    const len1 = StrUtil.TITLE_UPPER_WORDS.length;
    for (let i = 0; i < len1; i++) {
        str = str.replace(StrUtil._TITLE_UPPER_WORDS_RE[i], StrUtil.TITLE_UPPER_WORDS[i].toUpperCase(), );
    }

    for (let i = 0; i < len1; i++) {
        str = str.replace(StrUtil._TITLE_UPPER_WORDS_PLURAL_RE[i], `${StrUtil.TITLE_UPPER_WORDS_PLURAL[i].slice(0, -1).toUpperCase()}${StrUtil.TITLE_UPPER_WORDS_PLURAL[i].slice(-1).toLowerCase()}`, );
    }

    str = str.split(/([;:?!.])/g).map(pt=>pt.replace(/^(\s*)([^\s])/, (...m)=>`${m[1]}${m[2].toUpperCase()}`)).join("");

    return str;
}
;

String.prototype.toSentenceCase = String.prototype.toSentenceCase || function() {
    const out = [];
    const re = /([^.!?]+)([.!?]\s*|$)/gi;
    let m;
    do {
        m = re.exec(this);
        if (m) {
            out.push(m[0].toLowerCase().uppercaseFirst());
        }
    } while (m);
    return out.join("");
}
;

String.prototype.toSpellCase = String.prototype.toSpellCase || function() {
    return this.toLowerCase().replace(/(^|of )(bigby|otiluke|mordenkainen|evard|hadar|agathys|abi-dalzim|aganazzar|drawmij|leomund|maximilian|melf|nystul|otto|rary|snilloc|tasha|tenser|jim)('s|$| )/g, (...m)=>`${m[1]}${m[2].toTitleCase()}${m[3]}`);
}
;

String.prototype.toCamelCase = String.prototype.toCamelCase || function() {
    return this.split(" ").map((word,index)=>{
        if (index === 0)
            return word.toLowerCase();
        return `${word.charAt(0).toUpperCase()}${word.slice(1).toLowerCase()}`;
    }
    ).join("");
}
;

String.prototype.toPlural = String.prototype.toPlural || function() {
    let plural;
    if (StrUtil.IRREGULAR_PLURAL_WORDS[this.toLowerCase()])
        plural = StrUtil.IRREGULAR_PLURAL_WORDS[this.toLowerCase()];
    else if (/(s|x|z|ch|sh)$/i.test(this))
        plural = `${this}es`;
    else if (/[bcdfghjklmnpqrstvwxyz]y$/i.test(this))
        plural = this.replace(/y$/i, "ies");
    else
        plural = `${this}s`;

    if (this.toLowerCase() === this)
        return plural;
    if (this.toUpperCase() === this)
        return plural.toUpperCase();
    if (this.toTitleCase() === this)
        return plural.toTitleCase();
    return plural;
}
;

String.prototype.escapeQuotes = String.prototype.escapeQuotes || function() {
    return this.replace(/'/g, `&apos;`).replace(/"/g, `&quot;`).replace(/</g, `&lt;`).replace(/>/g, `&gt;`);
}
;

String.prototype.qq = String.prototype.qq || function() {
    return this.escapeQuotes();
}
;

String.prototype.unescapeQuotes = String.prototype.unescapeQuotes || function() {
    return this.replace(/&apos;/g, `'`).replace(/&quot;/g, `"`).replace(/&lt;/g, `<`).replace(/&gt;/g, `>`);
}
;

String.prototype.uq = String.prototype.uq || function() {
    return this.unescapeQuotes();
}
;

String.prototype.encodeApos = String.prototype.encodeApos || function() {
    return this.replace(/'/g, `%27`);
}
;

String.prototype.distance = String.prototype.distance || function(target) {
    let source = this;
    let i;
    let j;
    if (!source)
        return target ? target.length : 0;
    else if (!target)
        return source.length;

    const m = source.length;
    const n = target.length;
    const INF = m + n;
    const score = new Array(m + 2);
    const sd = {};
    for (i = 0; i < m + 2; i++)
        score[i] = new Array(n + 2);
    score[0][0] = INF;
    for (i = 0; i <= m; i++) {
        score[i + 1][1] = i;
        score[i + 1][0] = INF;
        sd[source[i]] = 0;
    }
    for (j = 0; j <= n; j++) {
        score[1][j + 1] = j;
        score[0][j + 1] = INF;
        sd[target[j]] = 0;
    }

    for (i = 1; i <= m; i++) {
        let DB = 0;
        for (j = 1; j <= n; j++) {
            const i1 = sd[target[j - 1]];
            const j1 = DB;
            if (source[i - 1] === target[j - 1]) {
                score[i + 1][j + 1] = score[i][j];
                DB = j;
            } else {
                score[i + 1][j + 1] = Math.min(score[i][j], Math.min(score[i + 1][j], score[i][j + 1])) + 1;
            }
            score[i + 1][j + 1] = Math.min(score[i + 1][j + 1], score[i1] ? score[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1) : Infinity);
        }
        sd[source[i - 1]] = i;
    }
    return score[m + 1][n + 1];
}
;

String.prototype.isNumeric = String.prototype.isNumeric || function() {
    return !isNaN(parseFloat(this)) && isFinite(this);
}
;

String.prototype.last = String.prototype.last || function() {
    return this[this.length - 1];
}
;

String.prototype.escapeRegexp = String.prototype.escapeRegexp || function() {
    return this.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
;

String.prototype.toUrlified = String.prototype.toUrlified || function() {
    return encodeURIComponent(this.toLowerCase()).toLowerCase();
}
;

String.prototype.toChunks = String.prototype.toChunks || function(size) {
    const numChunks = Math.ceil(this.length / size);
    const chunks = new Array(numChunks);
    for (let i = 0, o = 0; i < numChunks; ++i,
    o += size)
        chunks[i] = this.substr(o, size);
    return chunks;
}
;

String.prototype.toAscii = String.prototype.toAscii || function() {
    return this.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/Æ/g, "AE").replace(/æ/g, "ae");
}
;

String.prototype.trimChar = String.prototype.trimChar || function(ch) {
    let start = 0;
    let end = this.length;
    while (start < end && this[start] === ch)
        ++start;
    while (end > start && this[end - 1] === ch)
        --end;
    return (start > 0 || end < this.length) ? this.substring(start, end) : this;
}
;

String.prototype.trimAnyChar = String.prototype.trimAnyChar || function(chars) {
    let start = 0;
    let end = this.length;
    while (start < end && chars.indexOf(this[start]) >= 0)
        ++start;
    while (end > start && chars.indexOf(this[end - 1]) >= 0)
        --end;
    return (start > 0 || end < this.length) ? this.substring(start, end) : this;
}
;
Array.prototype.joinConjunct || Object.defineProperty(Array.prototype, "joinConjunct", {
    enumerable: false,
    writable: true,
    value: function(joiner, lastJoiner, nonOxford) {
        if (this.length === 0)
            return "";
        if (this.length === 1)
            return this[0];
        if (this.length === 2)
            return this.join(lastJoiner);
        else {
            let outStr = "";
            for (let i = 0; i < this.length; ++i) {
                outStr += this[i];
                if (i < this.length - 2)
                    outStr += joiner;
                else if (i === this.length - 2)
                    outStr += `${(!nonOxford && this.length > 2 ? joiner.trim() : "")}${lastJoiner}`;
            }
            return outStr;
        }
    },
});
Array.prototype.last || Object.defineProperty(Array.prototype, "last", {
    enumerable: false,
    writable: true,
    value: function(arg) {
        if (arg !== undefined)
            this[this.length - 1] = arg;
        else
            return this[this.length - 1];
    },
});

Array.prototype.filterIndex || Object.defineProperty(Array.prototype, "filterIndex", {
    enumerable: false,
    writable: true,
    value: function(fnCheck) {
        const out = [];
        this.forEach((it,i)=>{
            if (fnCheck(it))
                out.push(i);
        }
        );
        return out;
    },
});

Array.prototype.equals || Object.defineProperty(Array.prototype, "equals", {
    enumerable: false,
    writable: true,
    value: function(array2) {
        const array1 = this;
        if (!array1 && !array2)
            return true;
        else if ((!array1 && array2) || (array1 && !array2))
            return false;

        let temp = [];
        if ((!array1[0]) || (!array2[0]))
            return false;
        if (array1.length !== array2.length)
            return false;
        let key;
        for (let i = 0; i < array1.length; i++) {
            key = `${(typeof array1[i])}~${array1[i]}`;
            if (temp[key])
                temp[key]++;
            else
                temp[key] = 1;
        }
        for (let i = 0; i < array2.length; i++) {
            key = `${(typeof array2[i])}~${array2[i]}`;
            if (temp[key]) {
                if (temp[key] === 0)
                    return false;
                else
                    temp[key]--;
            } else
                return false;
        }
        return true;
    },
});

Array.prototype.segregate || Object.defineProperty(Array.prototype, "segregate", {
    enumerable: false,
    writable: true,
    value: function(fnIsValid) {
        return this.reduce(([pass,fail],elem)=>fnIsValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]], [[], []]);
    },
});

Array.prototype.partition || Object.defineProperty(Array.prototype, "partition", {
    enumerable: false,
    writable: true,
    value: Array.prototype.segregate,
});

Array.prototype.getNext || Object.defineProperty(Array.prototype, "getNext", {
    enumerable: false,
    writable: true,
    value: function(curVal) {
        let ix = this.indexOf(curVal);
        if (!~ix)
            throw new Error("Value was not in array!");
        if (++ix >= this.length)
            ix = 0;
        return this[ix];
    },
});

Array.prototype.shuffle || Object.defineProperty(Array.prototype, "shuffle", {
    enumerable: false,
    writable: true,
    value: function() {
        const len = this.length;
        const ixLast = len - 1;
        for (let i = 0; i < len; ++i) {
            const j = i + Math.floor(Math.random() * (ixLast - i + 1));
            [this[i],this[j]] = [this[j], this[i]];
        }
        return this;
    },
});

Array.prototype.mergeMap || Object.defineProperty(Array.prototype, "mergeMap", {
    enumerable: false,
    writable: true,
    value: function(fnMap) {
        return this.map((...args)=>fnMap(...args)).filter(it=>it != null).reduce((a,b)=>Object.assign(a, b), {});
    },
});

Array.prototype.first || Object.defineProperty(Array.prototype, "first", {
    enumerable: false,
    writable: true,
    value: function(fnMapFind) {
        for (let i = 0, len = this.length; i < len; ++i) {
            const result = fnMapFind(this[i], i, this);
            if (result)
                return result;
        }
    },
});

Array.prototype.pMap || Object.defineProperty(Array.prototype, "pMap", {
    enumerable: false,
    writable: true,
    value: async function(fnMap) {
        return Promise.all(this.map((it,i)=>fnMap(it, i, this)));
    },
});

Array.prototype.pSerialAwaitMap || Object.defineProperty(Array.prototype, "pSerialAwaitMap", {
    enumerable: false,
    writable: true,
    value: async function(fnMap) {
        const out = [];
        for (let i = 0, len = this.length; i < len; ++i)
            out.push(await fnMap(this[i], i, this));
        return out;
    },
});

Array.prototype.pSerialAwaitFilter || Object.defineProperty(Array.prototype, "pSerialAwaitFilter", {
    enumerable: false,
    writable: true,
    value: async function(fnFilter) {
        const out = [];
        for (let i = 0, len = this.length; i < len; ++i) {
            if (await fnFilter(this[i], i, this))
                out.push(this[i]);
        }
        return out;
    },
});

Array.prototype.pSerialAwaitFind || Object.defineProperty(Array.prototype, "pSerialAwaitFind", {
    enumerable: false,
    writable: true,
    value: async function(fnFind) {
        for (let i = 0, len = this.length; i < len; ++i)
            if (await fnFind(this[i], i, this))
                return this[i];
    },
});

Array.prototype.pSerialAwaitSome || Object.defineProperty(Array.prototype, "pSerialAwaitSome", {
    enumerable: false,
    writable: true,
    value: async function(fnSome) {
        for (let i = 0, len = this.length; i < len; ++i)
            if (await fnSome(this[i], i, this))
                return true;
        return false;
    },
});

Array.prototype.pSerialAwaitFirst || Object.defineProperty(Array.prototype, "pSerialAwaitFirst", {
    enumerable: false,
    writable: true,
    value: async function(fnMapFind) {
        for (let i = 0, len = this.length; i < len; ++i) {
            const result = await fnMapFind(this[i], i, this);
            if (result)
                return result;
        }
    },
});

Array.prototype.pSerialAwaitReduce || Object.defineProperty(Array.prototype, "pSerialAwaitReduce", {
    enumerable: false,
    writable: true,
    value: async function(fnReduce, initialValue) {
        let accumulator = initialValue === undefined ? this[0] : initialValue;
        for (let i = (initialValue === undefined ? 1 : 0), len = this.length; i < len; ++i) {
            accumulator = await fnReduce(accumulator, this[i], i, this);
        }
        return accumulator;
    },
});

Array.prototype.unique || Object.defineProperty(Array.prototype, "unique", {
    enumerable: false,
    writable: true,
    value: function(fnGetProp) {
        const seen = new Set();
        return this.filter((...args)=>{
            const val = fnGetProp ? fnGetProp(...args) : args[0];
            if (seen.has(val))
                return false;
            seen.add(val);
            return true;
        }
        );
    },
});

Array.prototype.zip || Object.defineProperty(Array.prototype, "zip", {
    enumerable: false,
    writable: true,
    value: function(otherArray) {
        const out = [];
        const len = Math.max(this.length, otherArray.length);
        for (let i = 0; i < len; ++i) {
            out.push([this[i], otherArray[i]]);
        }
        return out;
    },
});

Array.prototype.nextWrap || Object.defineProperty(Array.prototype, "nextWrap", {
    enumerable: false,
    writable: true,
    value: function(item) {
        const ix = this.indexOf(item);
        if (~ix) {
            if (ix + 1 < this.length)
                return this[ix + 1];
            else
                return this[0];
        } else
            return this.last();
    },
});

Array.prototype.prevWrap || Object.defineProperty(Array.prototype, "prevWrap", {
    enumerable: false,
    writable: true,
    value: function(item) {
        const ix = this.indexOf(item);
        if (~ix) {
            if (ix - 1 >= 0)
                return this[ix - 1];
            else
                return this.last();
        } else
            return this[0];
    },
});

Array.prototype.findLast || Object.defineProperty(Array.prototype, "findLast", {
    enumerable: false,
    writable: true,
    value: function(fn) {
        for (let i = this.length - 1; i >= 0; --i)
            if (fn(this[i]))
                return this[i];
    },
});

Array.prototype.findLastIndex || Object.defineProperty(Array.prototype, "findLastIndex", {
    enumerable: false,
    writable: true,
    value: function(fn) {
        for (let i = this.length - 1; i >= 0; --i)
            if (fn(this[i]))
                return i;
        return -1;
    },
});

Array.prototype.sum || Object.defineProperty(Array.prototype, "sum", {
    enumerable: false,
    writable: true,
    value: function() {
        let tmp = 0;
        const len = this.length;
        for (let i = 0; i < len; ++i)
            tmp += this[i];
        return tmp;
    },
});

Array.prototype.mean || Object.defineProperty(Array.prototype, "mean", {
    enumerable: false,
    writable: true,
    value: function() {
        return this.sum() / this.length;
    },
});

Array.prototype.meanAbsoluteDeviation || Object.defineProperty(Array.prototype, "meanAbsoluteDeviation", {
    enumerable: false,
    writable: true,
    value: function() {
        const mean = this.mean();
        return (this.map(num=>Math.abs(num - mean)) || []).mean();
    },
});

Map.prototype.getOrSet || Object.defineProperty(Map.prototype, "getOrSet", {
    enumerable: false,
    writable: true,
    value: function(k, orV) {
        if (this.has(k))
            return this.get(k);
        this.set(k, orV);
        return orV;
    },
});
//#endregion

//#region Renderer
globalThis.Renderer = function() {
    this.wrapperTag = "div";
    this.baseUrl = "";
    this.baseMediaUrls = {};

    if (globalThis.DEPLOYED_IMG_ROOT) {
        this.baseMediaUrls["img"] = globalThis.DEPLOYED_IMG_ROOT;
    }

    this._lazyImages = false;
    this._subVariant = false;
    this._firstSection = true;
    this._isAddHandlers = true;
    this._headerIndex = 1;
    this._tagExportDict = null;
    this._roll20Ids = null;
    this._trackTitles = {
        enabled: false,
        titles: {}
    };
    this._enumerateTitlesRel = {
        enabled: false,
        titles: {}
    };
    this._isHeaderIndexIncludeTableCaptions = false;
    this._isHeaderIndexIncludeImageTitles = false;
    this._plugins = {};
    this._fnPostProcess = null;
    this._extraSourceClasses = null;
    this._depthTracker = null;
    this._depthTrackerAdditionalProps = [];
    this._depthTrackerAdditionalPropsInherited = [];
    this._lastDepthTrackerInheritedProps = {};
    this._isInternalLinksDisabled = false;
    this._isPartPageExpandCollapseDisabled = false;
    this._fnsGetStyleClasses = {};

    this.setLazyImages = function(bool) {
        if (typeof IntersectionObserver === "undefined")
            this._lazyImages = false;
        else
            this._lazyImages = !!bool;
        return this;
    }
    ;

    this.setWrapperTag = function(tag) {
        this.wrapperTag = tag;
        return this;
    }
    ;

    this.setBaseUrl = function(url) {
        this.baseUrl = url;
        return this;
    }
    ;

    this.setBaseMediaUrl = function(mediaDir, url) {
        this.baseMediaUrls[mediaDir] = url;
        return this;
    }
    ;

    this.setFirstSection = function(bool) {
        this._firstSection = bool;
        return this;
    }
    ;

    this.setAddHandlers = function(bool) {
        this._isAddHandlers = bool;
        return this;
    }
    ;

    this.setFnPostProcess = function(fn) {
        this._fnPostProcess = fn;
        return this;
    }
    ;

    this.setExtraSourceClasses = function(arr) {
        this._extraSourceClasses = arr;
        return this;
    }
    ;

    this.resetHeaderIndex = function() {
        this._headerIndex = 1;
        this._trackTitles.titles = {};
        this._enumerateTitlesRel.titles = {};
        return this;
    }
    ;

    this.getHeaderIndex = function() {
        return this._headerIndex;
    }
    ;

    this.setHeaderIndexTableCaptions = function(bool) {
        this._isHeaderIndexIncludeTableCaptions = bool;
        return this;
    }
    ;
    this.setHeaderIndexImageTitles = function(bool) {
        this._isHeaderIndexIncludeImageTitles = bool;
        return this;
    }
    ;

    this.doExportTags = function(toObj) {
        this._tagExportDict = toObj;
        return this;
    }
    ;

    this.resetExportTags = function() {
        this._tagExportDict = null;
        return this;
    }
    ;

    this.setRoll20Ids = function(roll20Ids) {
        this._roll20Ids = roll20Ids;
        return this;
    }
    ;

    this.resetRoll20Ids = function() {
        this._roll20Ids = null;
        return this;
    }
    ;

    this.setInternalLinksDisabled = function(val) {
        this._isInternalLinksDisabled = !!val;
        return this;
    }
    ;
    this.isInternalLinksDisabled = function() {
        return !!this._isInternalLinksDisabled;
    }
    ;

    this.setPartPageExpandCollapseDisabled = function(val) {
        this._isPartPageExpandCollapseDisabled = !!val;
        return this;
    }
    ;

    this.setFnGetStyleClasses = function(identifier, fn) {
        if (fn == null) {
            delete this._fnsGetStyleClasses[identifier];
            return this;
        }

        this._fnsGetStyleClasses[identifier] = fn;
        return this;
    }
    ;

    this.setEnumerateTitlesRel = function(bool) {
        this._enumerateTitlesRel.enabled = bool;
        return this;
    }
    ;

    this._getEnumeratedTitleRel = function(name) {
        if (this._enumerateTitlesRel.enabled && name) {
            const clean = name.toLowerCase();
            this._enumerateTitlesRel.titles[clean] = this._enumerateTitlesRel.titles[clean] || 0;
            return `data-title-relative-index="${this._enumerateTitlesRel.titles[clean]++}"`;
        } else
            return "";
    }
    ;

    this.setTrackTitles = function(bool) {
        this._trackTitles.enabled = bool;
        return this;
    }
    ;

    this.getTrackedTitles = function() {
        return MiscUtil.copyFast(this._trackTitles.titles);
    }
    ;

    this.getTrackedTitlesInverted = function({isStripTags=false}={}) {
        const trackedTitlesInverse = {};
        Object.entries(this._trackTitles.titles || {}).forEach(([titleIx,titleName])=>{
            if (isStripTags)
                titleName = Renderer.stripTags(titleName);
            titleName = titleName.toLowerCase().trim();
            (trackedTitlesInverse[titleName] = trackedTitlesInverse[titleName] || []).push(titleIx);
        }
        );
        return trackedTitlesInverse;
    }
    ;

    this._handleTrackTitles = function(name, {isTable=false, isImage=false}={}) {
        if (!this._trackTitles.enabled)
            return;
        if (isTable && !this._isHeaderIndexIncludeTableCaptions)
            return;
        if (isImage && !this._isHeaderIndexIncludeImageTitles)
            return;
        this._trackTitles.titles[this._headerIndex] = name;
    }
    ;

    this._handleTrackDepth = function(entry, depth) {
        if (!entry.name || !this._depthTracker)
            return;

        this._lastDepthTrackerInheritedProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        if (entry.source)
            this._lastDepthTrackerInheritedProps.source = entry.source;
        if (this._depthTrackerAdditionalPropsInherited?.length) {
            this._depthTrackerAdditionalPropsInherited.forEach(prop=>this._lastDepthTrackerInheritedProps[prop] = entry[prop] || this._lastDepthTrackerInheritedProps[prop]);
        }

        const additionalData = this._depthTrackerAdditionalProps.length ? this._depthTrackerAdditionalProps.mergeMap(it=>({
            [it]: entry[it]
        })) : {};

        this._depthTracker.push({
            ...this._lastDepthTrackerInheritedProps,
            ...additionalData,
            depth,
            name: entry.name,
            type: entry.type,
            ixHeader: this._headerIndex,
            source: this._lastDepthTrackerInheritedProps.source,
            data: entry.data,
            page: entry.page,
            alias: entry.alias,
            entry,
        });
    }
    ;

    this.addPlugin = function(pluginType, fnPlugin) {
        MiscUtil.getOrSet(this._plugins, pluginType, []).push(fnPlugin);
    }
    ;

    this.removePlugin = function(pluginType, fnPlugin) {
        if (!fnPlugin)
            return;
        const ix = (MiscUtil.get(this._plugins, pluginType) || []).indexOf(fnPlugin);
        if (~ix)
            this._plugins[pluginType].splice(ix, 1);
    }
    ;

    this.removePlugins = function(pluginType) {
        MiscUtil.delete(this._plugins, pluginType);
    }
    ;

    this._getPlugins = function(pluginType) {
        return this._plugins[pluginType] || [];
    }
    ;

    this.withPlugin = function({pluginTypes, fnPlugin, fn}) {
        for (const pt of pluginTypes)
            this.addPlugin(pt, fnPlugin);
        try {
            return fn(this);
        } finally {
            for (const pt of pluginTypes)
                this.removePlugin(pt, fnPlugin);
        }
    }
    ;

    this.pWithPlugin = async function({pluginTypes, fnPlugin, pFn}) {
        for (const pt of pluginTypes)
            this.addPlugin(pt, fnPlugin);
        try {
            const out = await pFn(this);
            return out;
        } finally {
            for (const pt of pluginTypes)
                this.removePlugin(pt, fnPlugin);
        }
    }
    ;

    this.setDepthTracker = function(arr, {additionalProps, additionalPropsInherited}={}) {
        this._depthTracker = arr;
        this._depthTrackerAdditionalProps = additionalProps || [];
        this._depthTrackerAdditionalPropsInherited = additionalPropsInherited || [];
        return this;
    }
    ;

    this.getLineBreak = function() {
        return "<br>";
    }
    ;

    this.recursiveRender = function(entry, textStack, meta, options) {
        if (entry instanceof Array) {
            entry.forEach(nxt=>this.recursiveRender(nxt, textStack, meta, options));
            setTimeout(()=>{
                throw new Error(`Array passed to renderer! The renderer only guarantees support for primitives and basic objects.`);
            }
            );
            return this;
        }

        if (textStack.length === 0)
            textStack[0] = "";
        else
            textStack.reverse();

        meta = meta || {};
        meta._typeStack = [];
        meta.depth = meta.depth == null ? 0 : meta.depth;

        this._recursiveRender(entry, textStack, meta, options);
        if (this._fnPostProcess)
            textStack[0] = this._fnPostProcess(textStack[0]);
        textStack.reverse();

        return this;
    }
    ;

    this._recursiveRender = function(entry, textStack, meta, options) {
        if (entry == null)
            return;
        if (!textStack)
            throw new Error("Missing stack!");
        if (!meta)
            throw new Error("Missing metadata!");
        if (entry.type === "section")
            meta.depth = -1;

        options = options || {};

        meta._didRenderPrefix = false;
        meta._didRenderSuffix = false;

        if (typeof entry === "object") {
            const type = entry.type == null || entry.type === "section" ? "entries" : entry.type;

            if (type === "wrapper")
                return this._recursiveRender(entry.wrapped, textStack, meta, options);

            meta._typeStack.push(type);

            switch (type) {
            case "entries":
                this._renderEntries(entry, textStack, meta, options);
                break;
            case "options":
                this._renderOptions(entry, textStack, meta, options);
                break;
            case "list":
                this._renderList(entry, textStack, meta, options);
                break;
            case "table":
                this._renderTable(entry, textStack, meta, options);
                break;
            case "tableGroup":
                this._renderTableGroup(entry, textStack, meta, options);
                break;
            case "inset":
                this._renderInset(entry, textStack, meta, options);
                break;
            case "insetReadaloud":
                this._renderInsetReadaloud(entry, textStack, meta, options);
                break;
            case "variant":
                this._renderVariant(entry, textStack, meta, options);
                break;
            case "variantInner":
                this._renderVariantInner(entry, textStack, meta, options);
                break;
            case "variantSub":
                this._renderVariantSub(entry, textStack, meta, options);
                break;
            case "spellcasting":
                this._renderSpellcasting(entry, textStack, meta, options);
                break;
            case "quote":
                this._renderQuote(entry, textStack, meta, options);
                break;
            case "optfeature":
                this._renderOptfeature(entry, textStack, meta, options);
                break;
            case "patron":
                this._renderPatron(entry, textStack, meta, options);
                break;

            case "abilityDc":
                this._renderAbilityDc(entry, textStack, meta, options);
                break;
            case "abilityAttackMod":
                this._renderAbilityAttackMod(entry, textStack, meta, options);
                break;
            case "abilityGeneric":
                this._renderAbilityGeneric(entry, textStack, meta, options);
                break;

            case "inline":
                this._renderInline(entry, textStack, meta, options);
                break;
            case "inlineBlock":
                this._renderInlineBlock(entry, textStack, meta, options);
                break;
            case "bonus":
                this._renderBonus(entry, textStack, meta, options);
                break;
            case "bonusSpeed":
                this._renderBonusSpeed(entry, textStack, meta, options);
                break;
            case "dice":
                this._renderDice(entry, textStack, meta, options);
                break;
            case "link":
                this._renderLink(entry, textStack, meta, options);
                break;
            case "actions":
                this._renderActions(entry, textStack, meta, options);
                break;
            case "attack":
                this._renderAttack(entry, textStack, meta, options);
                break;
            case "ingredient":
                this._renderIngredient(entry, textStack, meta, options);
                break;

            case "item":
                this._renderItem(entry, textStack, meta, options);
                break;
            case "itemSub":
                this._renderItemSub(entry, textStack, meta, options);
                break;
            case "itemSpell":
                this._renderItemSpell(entry, textStack, meta, options);
                break;

            case "statblockInline":
                this._renderStatblockInline(entry, textStack, meta, options);
                break;
            case "statblock":
                this._renderStatblock(entry, textStack, meta, options);
                break;

            case "image":
                this._renderImage(entry, textStack, meta, options);
                break;
            case "gallery":
                this._renderGallery(entry, textStack, meta, options);
                break;

            case "flowchart":
                this._renderFlowchart(entry, textStack, meta, options);
                break;
            case "flowBlock":
                this._renderFlowBlock(entry, textStack, meta, options);
                break;

            case "homebrew":
                this._renderHomebrew(entry, textStack, meta, options);
                break;

            case "code":
                this._renderCode(entry, textStack, meta, options);
                break;
            case "hr":
                this._renderHr(entry, textStack, meta, options);
                break;
            }

            meta._typeStack.pop();
        } else if (typeof entry === "string") {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderString(entry, textStack, meta, options);
            this._renderSuffix(entry, textStack, meta, options);
        } else {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderPrimitive(entry, textStack, meta, options);
            this._renderSuffix(entry, textStack, meta, options);
        }
    }
    ;

    this._RE_TEXT_CENTER = /\btext-center\b/;

    this._getMutatedStyleString = function(str) {
        if (!str)
            return str;
        return str.replace(this._RE_TEXT_CENTER, "ve-text-center");
    }
    ;

    this._adjustDepth = function(meta, dDepth) {
        const cachedDepth = meta.depth;
        meta.depth += dDepth;
        meta.depth = Math.min(Math.max(-1, meta.depth), 2);
        return cachedDepth;
    }
    ;

    this._renderPrefix = function(entry, textStack, meta, options) {
        if (meta._didRenderPrefix)
            return;
        if (options.prefix != null) {
            textStack[0] += options.prefix;
            meta._didRenderPrefix = true;
        }
    }
    ;

    this._renderSuffix = function(entry, textStack, meta, options) {
        if (meta._didRenderSuffix)
            return;
        if (options.suffix != null) {
            textStack[0] += options.suffix;
            meta._didRenderSuffix = true;
        }
    }
    ;

    this._renderImage = function(entry, textStack, meta, options) {
        if (entry.title)
            this._handleTrackTitles(entry.title, {
                isImage: true
            });

        textStack[0] += `<div class="float-clear"></div>`;

        if (entry.imageType === "map" || entry.imageType === "mapPlayer")
            textStack[0] += `<div class="rd__wrp-map">`;
        textStack[0] += `<div class="${meta._typeStack.includes("gallery") ? "rd__wrp-gallery-image" : ""}">`;

        const href = this._renderImage_getUrl(entry);
        const svg = this._lazyImages && entry.width != null && entry.height != null ? `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="${entry.width}" height="${entry.height}"><rect width="100%" height="100%" fill="#ccc3"></rect></svg>`)}` : null;
        const ptTitleCreditTooltip = this._renderImage_getTitleCreditTooltipText(entry);
        const ptTitle = ptTitleCreditTooltip ? `title="${ptTitleCreditTooltip}"` : "";
        const pluginDataIsNoLink = this._getPlugins("image_isNoLink").map(plugin=>plugin(entry, textStack, meta, options)).some(Boolean);

        textStack[0] += `<div class="${this._renderImage_getWrapperClasses(entry, meta)}" ${entry.title && this._isHeaderIndexIncludeImageTitles ? `data-title-index="${this._headerIndex++}"` : ""}>
			${pluginDataIsNoLink ? "" : `<a href="${href}" target="_blank" rel="noopener noreferrer" ${ptTitle}>`}
				<img class="${this._renderImage_getImageClasses(entry, meta)}" src="${svg || href}" ${pluginDataIsNoLink ? ptTitle : ""} ${entry.altText || entry.title ? `alt="${Renderer.stripTags((entry.altText || entry.title)).qq()}"` : ""} ${svg ? `data-src="${href}"` : `loading="lazy"`} ${this._renderImage_getStylePart(entry)}>
			${pluginDataIsNoLink ? "" : `</a>`}
		</div>`;

        if (!this._renderImage_isComicStyling(entry) && (entry.title || entry.credit || entry.mapRegions)) {
            const ptAdventureBookMeta = entry.mapRegions && meta.adventureBookPage && meta.adventureBookSource && meta.adventureBookHash ? `data-rd-adventure-book-map-page="${meta.adventureBookPage.qq()}" data-rd-adventure-book-map-source="${meta.adventureBookSource.qq()}" data-rd-adventure-book-map-hash="${meta.adventureBookHash.qq()}"` : "";

            textStack[0] += `<div class="rd__image-title">`;

            if (entry.title && !entry.mapRegions)
                textStack[0] += `<div class="rd__image-title-inner">${this.render(entry.title)}</div>`;

            if (entry.mapRegions && !IS_VTT) {
                textStack[0] += `<button class="btn btn-xs btn-default rd__image-btn-viewer" onclick="RenderMap.pShowViewer(event, this)" data-rd-packed-map="${this._renderImage_getMapRegionData(entry)}" ${ptAdventureBookMeta} title="Open Dynamic Viewer (SHIFT to Open in New Window)"><span class="glyphicon glyphicon-picture"></span> ${Renderer.stripTags(entry.title) || "Dynamic Viewer"}</button>`;
            }

            if (entry.credit)
                textStack[0] += `<div class="rd__image-credit ve-muted"><span class="glyphicon glyphicon-pencil" title="Art Credit"></span> ${this.render(entry.credit)}</div>`;

            textStack[0] += `</div>`;
        }

        if (entry._galleryTitlePad)
            textStack[0] += `<div class="rd__image-title">&nbsp;</div>`;
        if (entry._galleryCreditPad)
            textStack[0] += `<div class="rd__image-credit">&nbsp;</div>`;

        textStack[0] += `</div>`;
        if (entry.imageType === "map" || entry.imageType === "mapPlayer")
            textStack[0] += `</div>`;
    }
    ;

    this._renderImage_getTitleCreditTooltipText = function(entry) {
        if (!entry.title && !entry.credit)
            return null;
        return Renderer.stripTags([entry.title, entry.credit ? `Art credit: ${entry.credit}` : null].filter(Boolean).join(". "), ).qq();
    }
    ;

    this._renderImage_getStylePart = function(entry) {
        const styles = [entry.maxWidth ? `max-width: min(100%, ${entry.maxWidth}${entry.maxWidthUnits || "px"})` : "", entry.maxHeight ? `max-height: min(60vh, ${entry.maxHeight}${entry.maxHeightUnits || "px"})` : "", ].filter(Boolean).join("; ");
        return styles ? `style="${styles}"` : "";
    }
    ;

    this._renderImage_getMapRegionData = function(entry) {
        return JSON.stringify(this.getMapRegionData(entry)).escapeQuotes();
    }
    ;

    this.getMapRegionData = function(entry) {
        return {
            regions: entry.mapRegions,
            width: entry.width,
            height: entry.height,
            href: this._renderImage_getUrl(entry),
            hrefThumbnail: this._renderImage_getUrlThumbnail(entry),
            page: entry.page,
            source: entry.source,
            hash: entry.hash,
        };
    }
    ;

    this._renderImage_isComicStyling = function(entry) {
        if (!entry.style)
            return false;
        return ["comic-speaker-left", "comic-speaker-right"].includes(entry.style);
    }
    ;

    this._renderImage_getWrapperClasses = function(entry) {
        const out = ["rd__wrp-image", "relative"];
        if (entry.style) {
            switch (entry.style) {
            case "comic-speaker-left":
                out.push("rd__comic-img-speaker", "rd__comic-img-speaker--left");
                break;
            case "comic-speaker-right":
                out.push("rd__comic-img-speaker", "rd__comic-img-speaker--right");
                break;
            }
        }
        return out.join(" ");
    }
    ;

    this._renderImage_getImageClasses = function(entry) {
        const out = ["rd__image"];
        if (entry.style) {
            switch (entry.style) {
            case "deity-symbol":
                out.push("rd__img-small");
                break;
            }
        }
        return out.join(" ");
    }
    ;

    this._renderImage_getUrl = function(entry) {
        let url = Renderer.utils.getMediaUrl(entry, "href", "img");
        for (const plugin of this._getPlugins(`image_urlPostProcess`)) {
            url = plugin(entry, url) || url;
        }
        return url;
    }
    ;

    this._renderImage_getUrlThumbnail = function(entry) {
        let url = Renderer.utils.getMediaUrl(entry, "hrefThumbnail", "img");
        for (const plugin of this._getPlugins(`image_urlThumbnailPostProcess`)) {
            url = plugin(entry, url) || url;
        }
        return url;
    }
    ;

    this._renderList_getListCssClasses = function(entry, textStack, meta, options) {
        const out = [`rd__list`];
        if (entry.style || entry.columns) {
            if (entry.style)
                out.push(...entry.style.split(" ").map(it=>`rd__${it}`));
            if (entry.columns)
                out.push(`columns-${entry.columns}`);
        }
        return out.join(" ");
    }
    ;

    this._renderTableGroup = function(entry, textStack, meta, options) {
        const len = entry.tables.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.tables[i], textStack, meta);
    }
    ;

    this._renderTable = function(entry, textStack, meta, options) {
        if (entry.intro) {
            const len = entry.intro.length;
            for (let i = 0; i < len; ++i) {
                this._recursiveRender(entry.intro[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
            }
        }

        textStack[0] += `<table class="w-100 rd__table ${this._getMutatedStyleString(entry.style || "")} ${entry.isStriped === false ? "" : "stripe-odd-table"}">`;

        const headerRowMetas = Renderer.table.getHeaderRowMetas(entry);

        const autoRollMode = Renderer.table.getAutoConvertedRollMode(entry, {headerRowMetas});

        const toRenderLabel = autoRollMode ? RollerUtil.getFullRollCol(headerRowMetas.last()[0]) : null;
        const isInfiniteResults = autoRollMode === RollerUtil.ROLL_COL_VARIABLE;

        if (entry.caption != null) {
            this._handleTrackTitles(entry.caption, {
                isTable: true
            });
            textStack[0] += `<caption ${this._isHeaderIndexIncludeTableCaptions ? `data-title-index="${this._headerIndex++}"` : ""}>${entry.caption}</caption>`;
        }

        const rollCols = [];
        let bodyStack = [""];
        bodyStack[0] += "<tbody>";
        const lenRows = entry.rows.length;
        for (let ixRow = 0; ixRow < lenRows; ++ixRow) {
            bodyStack[0] += "<tr>";
            const r = entry.rows[ixRow];
            let roRender = r.type === "row" ? r.row : r;

            const len = roRender.length;
            for (let ixCell = 0; ixCell < len; ++ixCell) {
                rollCols[ixCell] = rollCols[ixCell] || false;

                if (autoRollMode && ixCell === 0) {
                    roRender = Renderer.getRollableRow(roRender, {
                        isForceInfiniteResults: isInfiniteResults,
                        isFirstRow: ixRow === 0,
                        isLastRow: ixRow === lenRows - 1,
                    }, );
                    rollCols[ixCell] = true;
                }

                let toRenderCell;
                if (roRender[ixCell].type === "cell") {
                    if (roRender[ixCell].roll) {
                        rollCols[ixCell] = true;
                        if (roRender[ixCell].entry) {
                            toRenderCell = roRender[ixCell].entry;
                        } else if (roRender[ixCell].roll.exact != null) {
                            toRenderCell = roRender[ixCell].roll.pad ? StrUtil.padNumber(roRender[ixCell].roll.exact, 2, "0") : roRender[ixCell].roll.exact;
                        } else {

                            const dispMin = roRender[ixCell].roll.displayMin != null ? roRender[ixCell].roll.displayMin : roRender[ixCell].roll.min;
                            const dispMax = roRender[ixCell].roll.displayMax != null ? roRender[ixCell].roll.displayMax : roRender[ixCell].roll.max;

                            if (dispMax === Renderer.dice.POS_INFINITE) {
                                toRenderCell = roRender[ixCell].roll.pad ? `${StrUtil.padNumber(dispMin, 2, "0")}+` : `${dispMin}+`;
                            } else {
                                toRenderCell = roRender[ixCell].roll.pad ? `${StrUtil.padNumber(dispMin, 2, "0")}-${StrUtil.padNumber(dispMax, 2, "0")}` : `${dispMin}-${dispMax}`;
                            }
                        }
                    } else if (roRender[ixCell].entry) {
                        toRenderCell = roRender[ixCell].entry;
                    }
                } else {
                    toRenderCell = roRender[ixCell];
                }
                bodyStack[0] += `<td ${this._renderTable_makeTableTdClassText(entry, ixCell)} ${this._renderTable_getCellDataStr(roRender[ixCell])} ${roRender[ixCell].type === "cell" && roRender[ixCell].width ? `colspan="${roRender[ixCell].width}"` : ""}>`;
                if (r.style === "row-indent-first" && ixCell === 0)
                    bodyStack[0] += `<div class="rd__tab-indent"></div>`;
                const cacheDepth = this._adjustDepth(meta, 1);
                this._recursiveRender(toRenderCell, bodyStack, meta);
                meta.depth = cacheDepth;
                bodyStack[0] += "</td>";
            }
            bodyStack[0] += "</tr>";
        }
        bodyStack[0] += "</tbody>";

        if (headerRowMetas) {
            textStack[0] += "<thead>";

            for (let ixRow = 0, lenRows = headerRowMetas.length; ixRow < lenRows; ++ixRow) {
                textStack[0] += "<tr>";

                const headerRowMeta = headerRowMetas[ixRow];
                for (let ixCell = 0, lenCells = headerRowMeta.length; ixCell < lenCells; ++ixCell) {
                    const lbl = headerRowMeta[ixCell];
                    textStack[0] += `<th ${this._renderTable_getTableThClassText(entry, ixCell)} data-rd-isroller="${rollCols[ixCell]}" ${entry.isNameGenerator ? `data-rd-namegeneratorrolls="${headerRowMeta.length - 1}"` : ""}>`;
                    this._recursiveRender(autoRollMode && ixCell === 0 ? RollerUtil.getFullRollCol(lbl) : lbl, textStack, meta);
                    textStack[0] += `</th>`;
                }

                textStack[0] += "</tr>";
            }

            textStack[0] += "</thead>";
        }

        textStack[0] += bodyStack[0];

        if (entry.footnotes != null) {
            textStack[0] += "<tfoot>";
            const len = entry.footnotes.length;
            for (let i = 0; i < len; ++i) {
                textStack[0] += `<tr><td colspan="99">`;
                const cacheDepth = this._adjustDepth(meta, 1);
                this._recursiveRender(entry.footnotes[i], textStack, meta);
                meta.depth = cacheDepth;
                textStack[0] += "</td></tr>";
            }
            textStack[0] += "</tfoot>";
        }
        textStack[0] += "</table>";

        if (entry.outro) {
            const len = entry.outro.length;
            for (let i = 0; i < len; ++i) {
                this._recursiveRender(entry.outro[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
            }
        }
    }
    ;

    this._renderTable_getCellDataStr = function(ent) {
        function convertZeros(num) {
            if (num === 0)
                return 100;
            return num;
        }

        if (ent.roll) {
            return `data-roll-min="${convertZeros(ent.roll.exact != null ? ent.roll.exact : ent.roll.min)}" data-roll-max="${convertZeros(ent.roll.exact != null ? ent.roll.exact : ent.roll.max)}"`;
        }

        return "";
    }
    ;

    this._renderTable_getTableThClassText = function(entry, i) {
        return entry.colStyles == null || i >= entry.colStyles.length ? "" : `class="${this._getMutatedStyleString(entry.colStyles[i])}"`;
    }
    ;

    this._renderTable_makeTableTdClassText = function(entry, i) {
        if (entry.rowStyles != null)
            return i >= entry.rowStyles.length ? "" : `class="${this._getMutatedStyleString(entry.rowStyles[i])}"`;
        else
            return this._renderTable_getTableThClassText(entry, i);
    }
    ;

    this._renderEntries = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, true);
    }
    ;

    this._getPagePart = function(entry, isInset) {
        if (!Renderer.utils.isDisplayPage(entry.page))
            return "";
        return ` <span class="rd__title-link ${isInset ? `rd__title-link--inset` : ""}">${entry.source ? `<span class="help-subtle" title="${Parser.sourceJsonToFull(entry.source)}">${Parser.sourceJsonToAbv(entry.source)}</span> ` : ""}p${entry.page}</span>`;
    }
    ;

    this._renderEntriesSubtypes = function(entry, textStack, meta, options, incDepth) {
        const type = entry.type || "entries";
        const isInlineTitle = meta.depth >= 2;
        const isAddPeriod = isInlineTitle && entry.name && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
        const pagePart = !this._isPartPageExpandCollapseDisabled && !isInlineTitle ? this._getPagePart(entry) : "";
        const partExpandCollapse = !this._isPartPageExpandCollapseDisabled && !isInlineTitle ? `<span class="rd__h-toggle ml-2 clickable no-select" data-rd-h-toggle-button="true" title="Toggle Visibility (CTRL to Toggle All)">[\u2013]</span>` : "";
        const partPageExpandCollapse = !this._isPartPageExpandCollapseDisabled && (pagePart || partExpandCollapse) ? `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>` : "";
        const nextDepth = incDepth && meta.depth < 2 ? meta.depth + 1 : meta.depth;
        const styleString = this._renderEntriesSubtypes_getStyleString(entry, meta, isInlineTitle);
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);

        const headerTag = isInlineTitle ? "span" : `h${Math.min(Math.max(meta.depth + 2, 1), 6)}`;
        const headerClass = `rd__h--${meta.depth + 1}`;
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, meta.depth);

        const pluginDataNamePrefix = this._getPlugins(`${type}_namePrefix`).map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);

        const headerSpan = entry.name ? `<${headerTag} class="rd__h ${headerClass}" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}> <span class="entry-title-inner${!pagePart && entry.source ? ` help-subtle` : ""}"${!pagePart && entry.source ? ` title="Source: ${Parser.sourceJsonToFull(entry.source)}${entry.page ? `, p${entry.page}` : ""}"` : ""}>${pluginDataNamePrefix.join("")}${this.render({
            type: "inline",
            entries: [entry.name]
        })}${isAddPeriod ? "." : ""}</span>${partPageExpandCollapse}</${headerTag}> ` : "";

        if (meta.depth === -1) {
            if (!this._firstSection)
                textStack[0] += `<hr class="rd__hr rd__hr--section">`;
            this._firstSection = false;
        }

        if (entry.entries || entry.name) {
            textStack[0] += `<${this.wrapperTag} ${dataString} ${styleString}>${headerSpan}`;
            this._renderEntriesSubtypes_renderPreReqText(entry, textStack, meta);
            if (entry.entries) {
                const cacheDepth = meta.depth;
                const len = entry.entries.length;
                for (let i = 0; i < len; ++i) {
                    meta.depth = nextDepth;
                    this._recursiveRender(entry.entries[i], textStack, meta, {
                        prefix: "<p>",
                        suffix: "</p>"
                    });
                    if (i === 0 && cacheDepth >= 2)
                        textStack[0] += `<div class="rd__spc-inline-post"></div>`;
                }
                meta.depth = cacheDepth;
            }
            textStack[0] += `</${this.wrapperTag}>`;
        }

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderEntriesSubtypes_getDataString = function(entry) {
        let dataString = "";
        if (entry.source)
            dataString += `data-source="${entry.source}"`;
        if (entry.data) {
            for (const k in entry.data) {
                if (!k.startsWith("rd-"))
                    continue;
                dataString += ` data-${k}="${`${entry.data[k]}`.escapeQuotes()}"`;
            }
        }
        return dataString;
    }
    ;

    this._renderEntriesSubtypes_renderPreReqText = function(entry, textStack, meta) {
        if (entry.prerequisite) {
            textStack[0] += `<span class="rd__prerequisite">Prerequisite: `;
            this._recursiveRender({
                type: "inline",
                entries: [entry.prerequisite]
            }, textStack, meta);
            textStack[0] += `</span>`;
        }
    }
    ;

    this._renderEntriesSubtypes_getStyleString = function(entry, meta, isInlineTitle) {
        const styleClasses = ["rd__b"];
        styleClasses.push(this._getStyleClass(entry.type || "entries", entry));
        if (isInlineTitle) {
            if (this._subVariant)
                styleClasses.push(Renderer.HEAD_2_SUB_VARIANT);
            else
                styleClasses.push(Renderer.HEAD_2);
        } else
            styleClasses.push(meta.depth === -1 ? Renderer.HEAD_NEG_1 : meta.depth === 0 ? Renderer.HEAD_0 : Renderer.HEAD_1);
        return styleClasses.length > 0 ? `class="${styleClasses.join(" ")}"` : "";
    }
    ;

    this._renderOptions = function(entry, textStack, meta, options) {
        if (!entry.entries)
            return;
        entry.entries = entry.entries.sort((a,b)=>a.name && b.name ? SortUtil.ascSort(a.name, b.name) : a.name ? -1 : b.name ? 1 : 0);

        if (entry.style && entry.style === "list-hang-notitle") {
            const fauxEntry = {
                type: "list",
                style: "list-hang-notitle",
                items: entry.entries.map(ent=>{
                    if (typeof ent === "string")
                        return ent;
                    if (ent.type === "item")
                        return ent;

                    const out = {
                        ...ent,
                        type: "item"
                    };
                    if (ent.name)
                        out.name = Renderer._INLINE_HEADER_TERMINATORS.has(ent.name[ent.name.length - 1]) ? out.name : `${out.name}.`;
                    return out;
                }
                ),
            };
            this._renderList(fauxEntry, textStack, meta, options);
        } else
            this._renderEntriesSubtypes(entry, textStack, meta, options, false);
    }
    ;

    this._renderList = function(entry, textStack, meta, options) {
        if (entry.items) {
            const tag = entry.start ? "ol" : "ul";
            const cssClasses = this._renderList_getListCssClasses(entry, textStack, meta, options);
            textStack[0] += `<${tag} ${cssClasses ? `class="${cssClasses}"` : ""} ${entry.start ? `start="${entry.start}"` : ""}>`;
            if (entry.name)
                textStack[0] += `<li class="rd__list-name">${entry.name}</li>`;
            const isListHang = entry.style && entry.style.split(" ").includes("list-hang");
            const len = entry.items.length;
            for (let i = 0; i < len; ++i) {
                const item = entry.items[i];
                if (item.type !== "list") {
                    const className = `${this._getStyleClass(entry.type, item)}${item.type === "itemSpell" ? " rd__li-spell" : ""}`;
                    textStack[0] += `<li class="rd__li ${className}">`;
                }
                if (isListHang && typeof item === "string")
                    textStack[0] += "<div>";
                this._recursiveRender(item, textStack, meta);
                if (isListHang && typeof item === "string")
                    textStack[0] += "</div>";
                if (item.type !== "list")
                    textStack[0] += "</li>";
            }
            textStack[0] += `</${tag}>`;
        }
    }
    ;

    this._getPtExpandCollapseSpecial = function() {
        return `<span class="rd__h-toggle ml-2 clickable no-select" data-rd-h-special-toggle-button="true" title="Toggle Visibility (CTRL to Toggle All)">[\u2013]</span>`;
    }
    ;

    this._renderInset = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset ${this._getMutatedStyleString(entry.style || "")}" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4>${partPageExpandCollapse}</span>`;
        } else {
            textStack[0] += `<span class="rd__h rd__h--2-inset rd__h--2-inset-no-name">${partPageExpandCollapse}</span>`;
        }

        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i) {
                const cacheDepth = meta.depth;
                meta.depth = 2;
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
                meta.depth = cacheDepth;
            }
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderInsetReadaloud = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset rd__b-inset--readaloud ${this._getMutatedStyleString(entry.style || "")}" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4>${this._getPagePart(entry, true)}</span>`;
        } else {
            textStack[0] += `<span class="rd__h rd__h--2-inset rd__h--2-inset-no-name">${partPageExpandCollapse}</span>`;
        }

        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariant = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset" ${dataString}>`;
        textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">Variant: ${entry.name}</h4>${partPageExpandCollapse}</span>`;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        if (entry.source)
            textStack[0] += Renderer.utils.getSourceAndPageTrHtml({
                source: entry.source,
                page: entry.page
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariantInner = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        textStack[0] += `<${this.wrapperTag} class="rd__b-inset-inner" ${dataString}>`;
        textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4></span>`;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        if (entry.source)
            textStack[0] += Renderer.utils.getSourceAndPageTrHtml({
                source: entry.source,
                page: entry.page
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariantSub = function(entry, textStack, meta, options) {
        this._subVariant = true;
        const fauxEntry = entry;
        fauxEntry.type = "entries";
        const cacheDepth = meta.depth;
        meta.depth = 3;
        this._recursiveRender(fauxEntry, textStack, meta, {
            prefix: "<p>",
            suffix: "</p>"
        });
        meta.depth = cacheDepth;
        this._subVariant = false;
    }
    ;

    this._renderSpellcasting_getEntries = function(entry) {
        const hidden = new Set(entry.hidden || []);
        const toRender = [{
            type: "entries",
            name: entry.name,
            entries: entry.headerEntries ? MiscUtil.copyFast(entry.headerEntries) : []
        }];

        if (entry.constant || entry.will || entry.recharge || entry.charges || entry.rest || entry.daily || entry.weekly || entry.yearly || entry.ritual) {
            const tempList = {
                type: "list",
                style: "list-hang-notitle",
                items: [],
                data: {
                    isSpellList: true
                }
            };
            if (entry.constant && !hidden.has("constant"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `Constant:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.constant).join(", ")
                });
            if (entry.will && !hidden.has("will"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `At will:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.will).join(", ")
                });

            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "recharge",
                fnGetDurationText: num=>`{@recharge ${num}|m}`,
                isSkipPrefix: true
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "charges",
                fnGetDurationText: num=>` charge${num === 1 ? "" : "s"}`
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "rest",
                durationText: "/rest"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "daily",
                durationText: "/day"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "weekly",
                durationText: "/week"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "yearly",
                durationText: "/year"
            });

            if (entry.ritual && !hidden.has("ritual"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `Rituals:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.ritual).join(", ")
                });
            tempList.items = tempList.items.filter(it=>it.entry !== "");
            if (tempList.items.length)
                toRender[0].entries.push(tempList);
        }

        if (entry.spells && !hidden.has("spells")) {
            const tempList = {
                type: "list",
                style: "list-hang-notitle",
                items: [],
                data: {
                    isSpellList: true
                }
            };

            const lvls = Object.keys(entry.spells).map(lvl=>Number(lvl)).sort(SortUtil.ascSort);

            for (const lvl of lvls) {
                const spells = entry.spells[lvl];
                if (spells) {
                    let levelCantrip = `${Parser.spLevelToFull(lvl)}${(lvl === 0 ? "s" : " level")}`;
                    let slotsAtWill = ` (at will)`;
                    const slots = spells.slots;
                    if (slots >= 0)
                        slotsAtWill = slots > 0 ? ` (${slots} slot${slots > 1 ? "s" : ""})` : ``;
                    if (spells.lower && spells.lower !== lvl) {
                        levelCantrip = `${Parser.spLevelToFull(spells.lower)}-${levelCantrip}`;
                        if (slots >= 0)
                            slotsAtWill = slots > 0 ? ` (${slots} ${Parser.spLevelToFull(lvl)}-level slot${slots > 1 ? "s" : ""})` : ``;
                    }
                    tempList.items.push({
                        type: "itemSpell",
                        name: `${levelCantrip}${slotsAtWill}:`,
                        entry: this._renderSpellcasting_getRenderableList(spells.spells).join(", ") || "\u2014"
                    });
                }
            }

            toRender[0].entries.push(tempList);
        }

        if (entry.footerEntries)
            toRender.push({
                type: "entries",
                entries: entry.footerEntries
            });
        return toRender;
    }
    ;

    this._renderSpellcasting_getEntries_procPerDuration = function({entry, hidden, tempList, prop, durationText, fnGetDurationText, isSkipPrefix}) {
        if (!entry[prop] || hidden.has(prop))
            return;

        for (let lvl = 9; lvl > 0; lvl--) {
            const perDur = entry[prop];
            if (perDur[lvl]) {
                tempList.items.push({
                    type: "itemSpell",
                    name: `${isSkipPrefix ? "" : lvl}${fnGetDurationText ? fnGetDurationText(lvl) : durationText}:`,
                    entry: this._renderSpellcasting_getRenderableList(perDur[lvl]).join(", "),
                });
            }

            const lvlEach = `${lvl}e`;
            if (perDur[lvlEach]) {
                const isHideEach = !perDur[lvl] && perDur[lvlEach].length === 1;
                tempList.items.push({
                    type: "itemSpell",
                    name: `${isSkipPrefix ? "" : lvl}${fnGetDurationText ? fnGetDurationText(lvl) : durationText}${isHideEach ? "" : ` each`}:`,
                    entry: this._renderSpellcasting_getRenderableList(perDur[lvlEach]).join(", "),
                });
            }
        }
    }
    ;

    this._renderSpellcasting_getRenderableList = function(spellList) {
        return spellList.filter(it=>!it.hidden).map(it=>it.entry || it);
    }
    ;

    this._renderSpellcasting = function(entry, textStack, meta, options) {
        const toRender = this._renderSpellcasting_getEntries(entry);
        if (!toRender?.[0].entries?.length)
            return;
        this._recursiveRender({
            type: "entries",
            entries: toRender
        }, textStack, meta);
    }
    ;

    this._renderQuote = function(entry, textStack, meta, options) {
        textStack[0] += `<div class="${this._renderList_getQuoteCssClasses(entry, textStack, meta, options)}">`;

        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            textStack[0] += `<p class="rd__quote-line ${i === len - 1 && entry.by ? `rd__quote-line--last` : ""}">${i === 0 && !entry.skipMarks ? "&ldquo;" : ""}`;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: entry.skipItalics ? "" : "<i>",
                suffix: entry.skipItalics ? "" : "</i>"
            });
            textStack[0] += `${i === len - 1 && !entry.skipMarks ? "&rdquo;" : ""}</p>`;
        }

        if (entry.by || entry.from) {
            textStack[0] += `<p>`;
            const tempStack = [""];
            const byArr = this._renderQuote_getBy(entry);
            if (byArr) {
                for (let i = 0, len = byArr.length; i < len; ++i) {
                    const by = byArr[i];
                    this._recursiveRender(by, tempStack, meta);
                    if (i < len - 1)
                        tempStack[0] += "<br>";
                }
            }
            textStack[0] += `<span class="rd__quote-by">\u2014 ${byArr ? tempStack.join("") : ""}${byArr && entry.from ? `, ` : ""}${entry.from ? `<i>${entry.from}</i>` : ""}</span>`;
            textStack[0] += `</p>`;
        }

        textStack[0] += `</div>`;
    }
    ;

    this._renderList_getQuoteCssClasses = function(entry, textStack, meta, options) {
        const out = [`rd__quote`];
        if (entry.style) {
            if (entry.style)
                out.push(...entry.style.split(" ").map(it=>`rd__${it}`));
        }
        return out.join(" ");
    }
    ;

    this._renderQuote_getBy = function(entry) {
        if (!entry.by?.length)
            return null;
        return entry.by instanceof Array ? entry.by : [entry.by];
    }
    ;

    this._renderOptfeature = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, true);
    }
    ;

    this._renderPatron = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, false);
    }
    ;

    this._renderAbilityDc = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center"><b>`;
        this._recursiveRender(entry.name, textStack, meta);
        textStack[0] += ` save DC</b> = 8 + your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderAbilityAttackMod = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center"><b>`;
        this._recursiveRender(entry.name, textStack, meta);
        textStack[0] += ` attack modifier</b> = your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderAbilityGeneric = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center">`;
        if (entry.name)
            this._recursiveRender(entry.name, textStack, meta, {
                prefix: "<b>",
                suffix: "</b> = "
            });
        textStack[0] += `${entry.text}${entry.attributes ? ` ${Parser.attrChooseToFull(entry.attributes)}` : ""}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderInline = function(entry, textStack, meta, options) {
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta);
        }
    }
    ;

    this._renderInlineBlock = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta);
        }
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderBonus = function(entry, textStack, meta, options) {
        textStack[0] += (entry.value < 0 ? "" : "+") + entry.value;
    }
    ;

    this._renderBonusSpeed = function(entry, textStack, meta, options) {
        textStack[0] += entry.value === 0 ? "\u2014" : `${entry.value < 0 ? "" : "+"}${entry.value} ft.`;
    }
    ;

    this._renderDice = function(entry, textStack, meta, options) {
        const pluginResults = this._getPlugins("dice").map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);

        //TEMPFIX
        if(!SETTINGS.DO_RENDER_DICE){textStack[0] += entry.displayText; return;}
        textStack[0] += Renderer.getEntryDice(entry, entry.name, {
            isAddHandlers: this._isAddHandlers, pluginResults
        });
    };

    this._renderActions = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 2);

        textStack[0] += `<${this.wrapperTag} class="${Renderer.HEAD_2}" ${dataString}><span class="rd__h rd__h--3" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><span class="entry-title-inner">${entry.name}.</span></span> `;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderAttack = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<i>${Parser.attackTypeToFull(entry.attackType)}:</i> `;
        const len = entry.attackEntries.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.attackEntries[i], textStack, meta);
        textStack[0] += ` <i>Hit:</i> `;
        const len2 = entry.hitEntries.length;
        for (let i = 0; i < len2; ++i)
            this._recursiveRender(entry.hitEntries[i], textStack, meta);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderIngredient = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        this._recursiveRender(entry.entry, textStack, meta);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItem = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<p class="rd__p-list-item"><span class="${this._getMutatedStyleString(entry.style) || "bold"} rd__list-item-name">${this.render(entry.name)}${this._renderItem_isAddPeriod(entry) ? "." : ""}</span> `;
        if (entry.entry)
            this._recursiveRender(entry.entry, textStack, meta);
        else if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: i > 0 ? `<span class="rd__p-cont-indent">` : "",
                    suffix: i > 0 ? "</span>" : ""
                });
        }
        textStack[0] += "</p>";
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItem_isAddPeriod = function(entry) {
        return entry.name && entry.nameDot !== false && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
    }
    ;

    this._renderItemSub = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        const isAddPeriod = entry.name && entry.nameDot !== false && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
        this._recursiveRender(entry.entry, textStack, meta, {
            prefix: `<p class="rd__p-list-item"><span class="italic rd__list-item-name">${entry.name}${isAddPeriod ? "." : ""}</span> `,
            suffix: "</p>"
        });
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItemSpell = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);

        const tempStack = [""];
        this._recursiveRender(entry.name || "", tempStack, meta);

        this._recursiveRender(entry.entry, textStack, meta, {
            prefix: `<p>${tempStack.join("")} `,
            suffix: "</p>"
        });
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._InlineStatblockStrategy = function({pFnPreProcess, }, ) {
        this.pFnPreProcess = pFnPreProcess;
    }
    ;

    this._INLINE_STATBLOCK_STRATEGIES = {
        "item": new this._InlineStatblockStrategy({
            pFnPreProcess: async(ent)=>{
                await Renderer.item.pPopulatePropertyAndTypeReference();
                Renderer.item.enhanceItem(ent);
                return ent;
            }
            ,
        }),
    };

    this._renderStatblockInline = function(entry, textStack, meta, options) {
        const fnGetRenderCompact = Renderer.hover.getFnRenderCompact(entry.dataType);

        const headerName = entry.displayName || entry.data?.name;
        const headerStyle = entry.style;

        if (!fnGetRenderCompact) {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderDataHeader(textStack, headerName, headerStyle);
            textStack[0] += `<tr>
				<td colspan="6">
					<i class="text-danger">Cannot render &quot;${entry.type}&quot;&mdash;unknown data type &quot;${entry.dataType}&quot;!</i>
				</td>
			</tr>`;
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);
            return;
        }

        const strategy = this._INLINE_STATBLOCK_STRATEGIES[entry.dataType];

        if (!strategy?.pFnPreProcess && !entry.data?._copy) {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderDataHeader(textStack, headerName, headerStyle, {
                isCollapsed: entry.collapsed
            });
            textStack[0] += fnGetRenderCompact(entry.data, {
                isEmbeddedEntity: true
            });
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);
            return;
        }

        this._renderPrefix(entry, textStack, meta, options);
        this._renderDataHeader(textStack, headerName, headerStyle, {
            isCollapsed: entry.collapsed
        });

        const id = CryptUtil.uid();
        Renderer._cache.inlineStatblock[id] = {
            pFn: async(ele)=>{
                const entLoaded = entry.data?._copy ? (await DataUtil.pDoMetaMergeSingle(entry.dataType, {
                    dependencies: {
                        [entry.dataType]: entry.dependencies
                    }
                }, entry.data, )) : entry.data;

                const ent = strategy?.pFnPreProcess ? await strategy.pFnPreProcess(entLoaded) : entLoaded;

                const tbl = ele.closest("table");
                const nxt = e_({
                    outer: Renderer.utils.getEmbeddedDataHeader(headerName, headerStyle, {
                        isCollapsed: entry.collapsed
                    }) + fnGetRenderCompact(ent, {
                        isEmbeddedEntity: true
                    }) + Renderer.utils.getEmbeddedDataFooter(),
                });
                tbl.parentNode.replaceChild(nxt, tbl, );
            }
            ,
        };

        textStack[0] += `<tr><td colspan="6"><style data-rd-cache-id="${id}" data-rd-cache="inlineStatblock" onload="Renderer._cache.pRunFromEle(this)"></style></td></tr>`;
        this._renderDataFooter(textStack);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderDataHeader = function(textStack, name, style, {isCollapsed=false}={}) {
        textStack[0] += Renderer.utils.getEmbeddedDataHeader(name, style, {
            isCollapsed
        });
    }
    ;

    this._renderDataFooter = function(textStack) {
        textStack[0] += Renderer.utils.getEmbeddedDataFooter();
    }
    ;

    this._renderStatblock = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);

        const page = entry.prop || Renderer.tag.getPage(entry.tag);
        const source = Parser.getTagSource(entry.tag, entry.source);
        const hash = entry.hash || (UrlUtil.URL_TO_HASH_BUILDER[page] ? UrlUtil.URL_TO_HASH_BUILDER[page]({
            ...entry,
            name: entry.name,
            source
        }) : null);

        const asTag = `{@${entry.tag} ${entry.name}|${source}${entry.displayName ? `|${entry.displayName}` : ""}}`;

        if (!page || !source || !hash) {
            this._renderDataHeader(textStack, entry.name, entry.style);
            textStack[0] += `<tr>
				<td colspan="6">
					<i class="text-danger">Cannot load ${entry.tag ? `&quot;${asTag}&quot;` : entry.displayName || entry.name}! An unknown tag/prop, source, or hash was provided.</i>
				</td>
			</tr>`;
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);

            return;
        }

        this._renderDataHeader(textStack, entry.displayName || entry.name, entry.style, {
            isCollapsed: entry.collapsed
        });
        textStack[0] += `<tr>
			<td colspan="6" data-rd-tag="${(entry.tag || "").qq()}" data-rd-page="${(page || "").qq()}" data-rd-source="${(source || "").qq()}" data-rd-hash="${(hash || "").qq()}" data-rd-name="${(entry.name || "").qq()}" data-rd-display-name="${(entry.displayName || "").qq()}" data-rd-style="${(entry.style || "").qq()}">
				<i>Loading ${entry.tag ? `${Renderer.get().render(asTag)}` : entry.displayName || entry.name}...</i>
				<style onload="Renderer.events.handleLoad_inlineStatblock(this)"></style>
			</td>
		</tr>`;
        this._renderDataFooter(textStack);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderGallery = function(entry, textStack, meta, options) {
        if (entry.name)
            textStack[0] += `<h5 class="rd__gallery-name">${entry.name}</h5>`;
        textStack[0] += `<div class="rd__wrp-gallery">`;
        const len = entry.images.length;
        const anyNamed = entry.images.some(it=>it.title);
        const isAnyCredited = entry.images.some(it=>it.credit);
        for (let i = 0; i < len; ++i) {
            const img = MiscUtil.copyFast(entry.images[i]);

            if (anyNamed && !img.title)
                img._galleryTitlePad = true;
            if (isAnyCredited && !img.credit)
                img._galleryCreditPad = true;

            delete img.imageType;
            this._recursiveRender(img, textStack, meta, options);
        }
        textStack[0] += `</div>`;
    }
    ;

    this._renderFlowchart = function(entry, textStack, meta, options) {
        textStack[0] += `<div class="rd__wrp-flowchart">`;
        const len = entry.blocks.length;
        for (let i = 0; i < len; ++i) {
            this._recursiveRender(entry.blocks[i], textStack, meta, options);
            if (i !== len - 1) {
                textStack[0] += `<div class="rd__s-v-flow"></div>`;
            }
        }
        textStack[0] += `</div>`;
    }
    ;

    this._renderFlowBlock = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-flow ve-text-center" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-flow-block" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${this.render({
                type: "inline",
                entries: [entry.name]
            })}</h4></span>`;
        }
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i) {
                const cacheDepth = meta.depth;
                meta.depth = 2;
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
                meta.depth = cacheDepth;
            }
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderHomebrew = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="homebrew-section"><div class="homebrew-float"><span class="homebrew-notice"></span>`;

        if (entry.oldEntries) {
            const hoverMeta = Renderer.hover.getInlineHover({
                type: "entries",
                name: "Homebrew",
                entries: entry.oldEntries
            });
            let markerText;
            if (entry.movedTo) {
                markerText = "(See moved content)";
            } else if (entry.entries) {
                markerText = "(See replaced content)";
            } else {
                markerText = "(See removed content)";
            }
            textStack[0] += `<span class="homebrew-old-content" href="#${window.location.hash}" ${hoverMeta.html}>${markerText}</span>`;
        }

        textStack[0] += `</div>`;

        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
        } else if (entry.movedTo) {
            textStack[0] += `<i>This content has been moved to ${entry.movedTo}.</i>`;
        } else {
            textStack[0] += "<i>This content has been deleted.</i>";
        }

        textStack[0] += `</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderCode = function(entry, textStack, meta, options) {
        const isWrapped = !!StorageUtil.syncGet("rendererCodeWrap");
        textStack[0] += `
			<div class="ve-flex-col h-100">
				<div class="ve-flex no-shrink pt-1">
					<button class="btn btn-default btn-xs mb-1 mr-2" onclick="Renderer.events.handleClick_copyCode(event, this)">Copy Code</button>
					<button class="btn btn-default btn-xs mb-1 ${isWrapped ? "active" : ""}" onclick="Renderer.events.handleClick_toggleCodeWrap(event, this)">Word Wrap</button>
				</div>
				<pre class="h-100 w-100 mb-1 ${isWrapped ? "rd__pre-wrap" : ""}">${entry.preformatted}</pre>
			</div>
		`;
    }
    ;

    this._renderHr = function(entry, textStack, meta, options) {
        textStack[0] += `<hr class="rd__hr">`;
    }
    ;

    this._getStyleClass = function(entryType, entry) {
        const outList = [];

        const pluginResults = this._getPlugins(`${entryType}_styleClass_fromSource`).map(plugin=>plugin(entryType, entry)).filter(Boolean);

        if (!pluginResults.some(it=>it.isSkip)) {
            if (SourceUtil.isNonstandardSource(entry.source) || (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(entry.source)))
                outList.push("spicy-sauce");
            if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(entry.source))
                outList.push("refreshing-brew");
        }

        if (this._extraSourceClasses)
            outList.push(...this._extraSourceClasses);
        for (const k in this._fnsGetStyleClasses) {
            const fromFn = this._fnsGetStyleClasses[k](entry);
            if (fromFn)
                outList.push(...fromFn);
        }
        if (entry.style)
            outList.push(this._getMutatedStyleString(entry.style));
        return outList.join(" ");
    }
    ;

    this._renderString = function(entry, textStack, meta, options) {
        const tagSplit = Renderer.splitByTags(entry);
        const len = tagSplit.length;
        for (let i = 0; i < len; ++i) {
            const s = tagSplit[i];
            if (!s)
                continue;
            if (s.startsWith("{@")) {
                const [tag,text] = Renderer.splitFirstSpace(s.slice(1, -1));
                this._renderString_renderTag(textStack, meta, options, tag, text);
            } else
                textStack[0] += s;
        }
    }
    ;

    this._renderString_renderTag = function(textStack, meta, options, tag, text) {
        for (const plugin of this._getPlugins("string_tag")) {
            const out = plugin(tag, text, textStack, meta, options);
            if (out)
                return void (textStack[0] += out);
        }

        for (const plugin of this._getPlugins(`string_${tag}`)) {
            const out = plugin(tag, text, textStack, meta, options);
            if (out)
                return void (textStack[0] += out);
        }

        switch (tag) {
        case "@b":
        case "@bold":
            textStack[0] += `<b>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</b>`;
            break;
        case "@i":
        case "@italic":
            textStack[0] += `<i>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</i>`;
            break;
        case "@s":
        case "@strike":
            textStack[0] += `<s>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</s>`;
            break;
        case "@u":
        case "@underline":
            textStack[0] += `<u>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</u>`;
            break;
        case "@sup":
            textStack[0] += `<sup>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</sup>`;
            break;
        case "@sub":
            textStack[0] += `<sub>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</sub>`;
            break;
        case "@kbd":
            textStack[0] += `<kbd>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</kbd>`;
            break;
        case "@code":
            textStack[0] += `<span class="code">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@style":
            {
                const [displayText,styles] = Renderer.splitTagByPipe(text);
                const classNames = (styles || "").split(";").map(it=>Renderer._STYLE_TAG_ID_TO_STYLE[it.trim()]).filter(Boolean).join(" ");
                textStack[0] += `<span class="${classNames}">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@font":
            {
                const [displayText,fontFamily] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span style="font-family: '${fontFamily}'">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@note":
            textStack[0] += `<i class="ve-muted">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</i>`;
            break;
        case "@tip":
            {
                const [displayText,titielText] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span title="${titielText.qq()}">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@atk":
            textStack[0] += `<i>${Renderer.attackTagToFull(text)}</i>`;
            break;
        case "@h":
            textStack[0] += `<i>Hit:</i> `;
            break;
        case "@m":
            textStack[0] += `<i>Miss:</i> `;
            break;
        case "@color":
            {
                const [toDisplay,color] = Renderer.splitTagByPipe(text);
                const ptColor = this._renderString_renderTag_getBrewColorPart(color);

                textStack[0] += `<span class="rd__color" style="color: ${ptColor}">`;
                this._recursiveRender(toDisplay, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@highlight":
            {
                const [toDisplay,color] = Renderer.splitTagByPipe(text);
                const ptColor = this._renderString_renderTag_getBrewColorPart(color);

                textStack[0] += ptColor ? `<span style="background-color: ${ptColor}">` : `<span class="rd__highlight">`;
                textStack[0] += toDisplay;
                textStack[0] += `</span>`;
                break;
            }
        case "@help":
            {
                const [toDisplay,title=""] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span class="help" title="${title.qq()}">`;
                this._recursiveRender(toDisplay, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }

        case "@unit":
            {
                const [amount,unitSingle,unitPlural] = Renderer.splitTagByPipe(text);
                textStack[0] += isNaN(amount) ? unitSingle : Number(amount) > 1 ? (unitPlural || unitSingle.toPlural()) : unitSingle;
                break;
            }

        case "@comic":
            textStack[0] += `<span class="rd__comic">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH1":
            textStack[0] += `<span class="rd__comic rd__comic--h1">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH2":
            textStack[0] += `<span class="rd__comic rd__comic--h2">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH3":
            textStack[0] += `<span class="rd__comic rd__comic--h3">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH4":
            textStack[0] += `<span class="rd__comic rd__comic--h4">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicNote":
            textStack[0] += `<span class="rd__comic rd__comic--note">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;

        case "@dc":
            {
                const [dcText,displayText] = Renderer.splitTagByPipe(text);
                textStack[0] += `DC <span class="rd__dc">${displayText || dcText}</span>`;
                break;
            }

        case "@dcYourSpellSave":
            {
                const [displayText] = Renderer.splitTagByPipe(text);
                textStack[0] += displayText || "your spell save DC";
                break;
            }

        case "@dice":
        case "@autodice":
        case "@damage":
        case "@hit":
        case "@d20":
        case "@chance":
        case "@coinflip":
        case "@recharge":
        case "@ability":
        case "@savingThrow":
        case "@skillCheck":
            {
                const fauxEntry = Renderer.utils.getTagEntry(tag, text);

                if (tag === "@recharge") {
                    const [,flagsRaw] = Renderer.splitTagByPipe(text);
                    const flags = flagsRaw ? flagsRaw.split("") : null;
                    textStack[0] += `${flags && flags.includes("m") ? "" : "("}Recharge `;
                    this._recursiveRender(fauxEntry, textStack, meta);
                    textStack[0] += `${flags && flags.includes("m") ? "" : ")"}`;
                } else {
                    this._recursiveRender(fauxEntry, textStack, meta);
                }

                break;
            }

        case "@hitYourSpellAttack":
            this._renderString_renderTag_hitYourSpellAttack(textStack, meta, options, tag, text);
            break;

        case "@scaledice":
        case "@scaledamage":
            {
                const fauxEntry = Renderer.parseScaleDice(tag, text);
                this._recursiveRender(fauxEntry, textStack, meta);
                break;
            }

        case "@filter":
            {
                const [displayText,page,...filters] = Renderer.splitTagByPipe(text);

                const filterSubhashMeta = Renderer.getFilterSubhashes(filters);

                const fauxEntry = {
                    type: "link",
                    text: displayText,
                    href: {
                        type: "internal",
                        path: `${page}.html`,
                        hash: HASH_BLANK,
                        hashPreEncoded: true,
                        subhashes: filterSubhashMeta.subhashes,
                    },
                };

                if (filterSubhashMeta.customHash)
                    fauxEntry.href.hash = filterSubhashMeta.customHash;

                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        case "@link":
            {
                const [displayText,url] = Renderer.splitTagByPipe(text);
                let outUrl = url == null ? displayText : url;
                if (!outUrl.startsWith("http"))
                    outUrl = `http://${outUrl}`;
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "external",
                        url: outUrl,
                    },
                    text: displayText,
                };
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        case "@5etools":
            {
                const [displayText,page,hash] = Renderer.splitTagByPipe(text);
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                    },
                    text: displayText,
                };
                if (hash) {
                    fauxEntry.hash = hash;
                    fauxEntry.hashPreEncoded = true;
                }
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }

        case "@footnote":
            {
                const [displayText,footnoteText,optTitle] = Renderer.splitTagByPipe(text);
                const hoverMeta = Renderer.hover.getInlineHover({
                    type: "entries",
                    name: optTitle ? optTitle.toTitleCase() : "Footnote",
                    entries: [footnoteText, optTitle ? `{@note ${optTitle}}` : ""].filter(Boolean),
                });
                textStack[0] += `<span class="help" ${hoverMeta.html}>`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;

                break;
            }
        case "@homebrew":
            {
                const [newText,oldText] = Renderer.splitTagByPipe(text);
                const tooltipEntries = [];
                if (newText && oldText) {
                    tooltipEntries.push("{@b This is a homebrew addition, replacing the following:}");
                } else if (newText) {
                    tooltipEntries.push("{@b This is a homebrew addition.}");
                } else if (oldText) {
                    tooltipEntries.push("{@b The following text has been removed with this homebrew:}");
                }
                if (oldText) {
                    tooltipEntries.push(oldText);
                }
                const hoverMeta = Renderer.hover.getInlineHover({
                    type: "entries",
                    name: "Homebrew Modifications",
                    entries: tooltipEntries,
                });
                textStack[0] += `<span class="homebrew-inline" ${hoverMeta.html}>`;
                this._recursiveRender(newText || "[...]", textStack, meta);
                textStack[0] += `</span>`;

                break;
            }
        case "@area":
            {
                const {areaId, displayText} = Renderer.tag.TAG_LOOKUP.area.getMeta(tag, text);

                if (typeof BookUtil === "undefined") {
                    textStack[0] += displayText;
                } else {
                    const area = BookUtil.curRender.headerMap[areaId] || {
                        entry: {
                            name: ""
                        }
                    };
                    const hoverMeta = Renderer.hover.getInlineHover(area.entry, {
                        isLargeBookContent: true,
                        depth: area.depth
                    });
                    textStack[0] += `<a href="#${BookUtil.curRender.curBookId},${area.chapter},${UrlUtil.encodeForHash(area.entry.name)},0" ${hoverMeta.html}>${displayText}</a>`;
                }

                break;
            }

        case "@loader":
            {
                const {name, path, mode} = this._renderString_getLoaderTagMeta(text);

                const brewUtilName = mode === "homebrew" ? "BrewUtil2" : mode === "prerelease" ? "PrereleaseUtil" : null;
                const brewUtil = globalThis[brewUtilName];

                if (!brewUtil) {
                    textStack[0] += `<span class="text-danger" title="Unknown loader mode &quot;${mode.qq()}&quot;!">${name}<span class="glyphicon glyphicon-alert rd__loadbrew-icon rd__loadbrew-icon"></span></span>`;

                    break;
                }

                textStack[0] += `<span onclick="${brewUtilName}.pAddBrewFromLoaderTag(this)" data-rd-loader-path="${path.escapeQuotes()}" data-rd-loader-name="${name.escapeQuotes()}" class="rd__wrp-loadbrew--ready" title="Click to install ${brewUtil.DISPLAY_NAME}">${name}<span class="glyphicon glyphicon-download-alt rd__loadbrew-icon rd__loadbrew-icon"></span></span>`;
                break;
            }

        case "@book":
        case "@adventure":
            {
                const page = tag === "@book" ? "book.html" : "adventure.html";
                const [displayText,book,chapter,section,rawNumber] = Renderer.splitTagByPipe(text);
                const number = rawNumber || 0;
                const hash = `${book}${chapter ? `${HASH_PART_SEP}${chapter}${section ? `${HASH_PART_SEP}${UrlUtil.encodeForHash(section)}${number != null ? `${HASH_PART_SEP}${UrlUtil.encodeForHash(number)}` : ""}` : ""}` : ""}`;
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                        hash,
                        hashPreEncoded: true,
                    },
                    text: displayText,
                };
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }

        default:
            {
                const {name, source, displayText, others, page, hash, hashPreEncoded, pageHover, hashHover, hashPreEncodedHover, preloadId, linkText, subhashes, subhashesHover, isFauxPage} = Renderer.utils.getTagMeta(tag, text);

                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                        hash,
                        hover: {
                            page,
                            isFauxPage,
                            source,
                        },
                    },
                    text: (displayText || name),
                };

                if (hashPreEncoded != null)
                    fauxEntry.href.hashPreEncoded = hashPreEncoded;
                if (pageHover != null)
                    fauxEntry.href.hover.page = pageHover;
                if (hashHover != null)
                    fauxEntry.href.hover.hash = hashHover;
                if (hashPreEncodedHover != null)
                    fauxEntry.href.hover.hashPreEncoded = hashPreEncodedHover;
                if (preloadId != null)
                    fauxEntry.href.hover.preloadId = preloadId;
                if (linkText)
                    fauxEntry.text = linkText;
                if (subhashes)
                    fauxEntry.href.subhashes = subhashes;
                if (subhashesHover)
                    fauxEntry.href.hover.subhashes = subhashesHover;

                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        }
    }
    ;

    this._renderString_renderTag_getBrewColorPart = function(color) {
        if (!color)
            return "";
        const scrubbedColor = BrewUtilShared.getValidColor(color, {
            isExtended: true
        });
        return scrubbedColor.startsWith("--") ? `var(${scrubbedColor})` : `#${scrubbedColor}`;
    }
    ;

    this._renderString_renderTag_hitYourSpellAttack = function(textStack, meta, options, tag, text) {
        const [displayText] = Renderer.splitTagByPipe(text);

        const fauxEntry = {
            type: "dice",
            rollable: true,
            subType: "d20",
            displayText: displayText || "your spell attack modifier",
            toRoll: `1d20 + #$prompt_number:title=Enter your Spell Attack Modifier$#`,
        };
        return this._recursiveRender(fauxEntry, textStack, meta);
    }
    ;

    this._renderString_getLoaderTagMeta = function(text, {isDefaultUrl=false}={}) {
        const [name,file,mode="homebrew"] = Renderer.splitTagByPipe(text);

        if (!isDefaultUrl)
            return {
                name,
                path: file,
                mode
            };

        const path = /^.*?:\/\//.test(file) ? file : `${VeCt.URL_ROOT_BREW}${file}`;
        return {
            name,
            path,
            mode
        };
    }
    ;

    this._renderPrimitive = function(entry, textStack, meta, options) {
        textStack[0] += entry;
    }
    ;

    this._renderLink = function(entry, textStack, meta, options) {
        let href = this._renderLink_getHref(entry);

        if (entry.href.hover && this._roll20Ids) {
            const procHash = UrlUtil.encodeForHash(entry.href.hash);
            const id = this._roll20Ids[procHash];
            if (id) {
                href = `http://journal.roll20.net/${id.type}/${id.roll20Id}`;
            }
        }

        const pluginData = this._getPlugins("link").map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);
        const isDisableEvents = pluginData.some(it=>it.isDisableEvents);
        const additionalAttributes = pluginData.map(it=>it.attributes).filter(Boolean);

        if (this._isInternalLinksDisabled && entry.href.type === "internal") {
            textStack[0] += `<span class="bold" ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</span>`;
        } else if (entry.href.hover?.isFauxPage) {
            textStack[0] += `<span class="help help--hover" ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</span>`;
        } else {
            textStack[0] += `<a href="${href.qq()}" ${entry.href.type === "internal" ? "" : `target="_blank" rel="noopener noreferrer"`} ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</a>`;
        }
    }
    ;

    this._renderLink_getHref = function(entry) {
        let href;
        if (entry.href.type === "internal") {
            href = `${this.baseUrl}${entry.href.path}#`;
            if (entry.href.hash != null) {
                href += entry.href.hashPreEncoded ? entry.href.hash : UrlUtil.encodeForHash(entry.href.hash);
            }
            if (entry.href.subhashes != null) {
                href += Renderer.utils.getLinkSubhashString(entry.href.subhashes);
            }
        } else if (entry.href.type === "external") {
            href = entry.href.url;
        }
        return href;
    }
    ;

    this._renderLink_getHoverString = function(entry) {
        if (!entry.href.hover || !this._isAddHandlers)
            return "";

        let procHash = entry.href.hover.hash ? entry.href.hover.hashPreEncoded ? entry.href.hover.hash : UrlUtil.encodeForHash(entry.href.hover.hash) : entry.href.hashPreEncoded ? entry.href.hash : UrlUtil.encodeForHash(entry.href.hash);

        if (this._tagExportDict) {
            this._tagExportDict[procHash] = {
                page: entry.href.hover.page,
                source: entry.href.hover.source,
                hash: procHash,
            };
        }

        if (entry.href.hover.subhashes) {
            procHash += Renderer.utils.getLinkSubhashString(entry.href.hover.subhashes);
        }

        const pluginData = this._getPlugins("link_attributesHover").map(plugin=>plugin(entry, procHash)).filter(Boolean);
        const replacementAttributes = pluginData.map(it=>it.attributesHoverReplace).filter(Boolean);
        if (replacementAttributes.length)
            return replacementAttributes.join(" ");

        return `onmouseover="Renderer.hover.pHandleLinkMouseOver(event, this)" onmouseleave="Renderer.hover.handleLinkMouseLeave(event, this)" onmousemove="Renderer.hover.handleLinkMouseMove(event, this)" data-vet-page="${entry.href.hover.page.qq()}" data-vet-source="${entry.href.hover.source.qq()}" data-vet-hash="${procHash.qq()}" ${entry.href.hover.preloadId != null ? `data-vet-preload-id="${`${entry.href.hover.preloadId}`.qq()}"` : ""} ${entry.href.hover.isFauxPage ? `data-vet-is-faux-page="true"` : ""} ${Renderer.hover.getPreventTouchString()}`;
    }
    ;

    this.render = function(entry, depth=0) {
        const tempStack = [];
        this.recursiveRender(entry, tempStack, {
            depth
        });
        return tempStack.join("");
    }
    ;
};

Renderer.generic = class {
    static getCompactRenderedString(ent, opts) {
        opts = opts || {};
        const prerequisite = Renderer.utils.prerequisite.getHtml(ent.prerequisite);

        return `
		${opts.dataProp && opts.page ? Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: opts.dataProp,
            page: opts.page
        }) : ""}
		${opts.isSkipNameRow ? "" : Renderer.utils.getNameTr(ent, {
            page: opts.page
        })}
		<tr class="text"><td colspan="6">
		${prerequisite ? `<p>${prerequisite}</p>` : ""}
		${Renderer.get().setFirstSection(true).render({
            entries: ent.entries
        })}
		</td></tr>
		${opts.isSkipPageRow ? "" : Renderer.utils.getPageTr(ent)}`;
    }

    static FEATURE__SKILLS_ALL = Object.keys(Parser.SKILL_TO_ATB_ABV).sort(SortUtil.ascSortLower);

    static FEATURE__TOOLS_ARTISANS = ["alchemist's supplies", "brewer's supplies", "calligrapher's supplies", "carpenter's tools", "cartographer's tools", "cobbler's tools", "cook's utensils", "glassblower's tools", "jeweler's tools", "leatherworker's tools", "mason's tools", "painter's supplies", "potter's tools", "smith's tools", "tinker's tools", "weaver's tools", "woodcarver's tools", ];
    static FEATURE__TOOLS_MUSICAL_INSTRUMENTS = ["bagpipes", "drum", "dulcimer", "flute", "horn", "lute", "lyre", "pan flute", "shawm", "viol", ];
    static FEATURE__TOOLS_ALL = ["artisan's tools",
    ...this.FEATURE__TOOLS_ARTISANS, ...this.FEATURE__TOOLS_MUSICAL_INSTRUMENTS,
    "disguise kit", "forgery kit", "gaming set", "herbalism kit", "musical instrument", "navigator's tools", "thieves' tools", "poisoner's kit", "vehicles (land)", "vehicles (water)", "vehicles (air)", "vehicles (space)", ];

    static FEATURE__LANGUAGES_ALL = Parser.LANGUAGES_ALL.map(it=>it.toLowerCase());
    static FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ = {
        from: [...Parser.LANGUAGES_STANDARD.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesStandard",
        })), ...Parser.LANGUAGES_EXOTIC.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesExotic",
        })), ...Parser.LANGUAGES_SECRET.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesSecret",
        })), ],
        groups: {
            languagesStandard: {
                name: "Standard Languages",
            },
            languagesExotic: {
                name: "Exotic Languages",
                hint: "With your DM's permission, you can choose an exotic language.",
            },
            languagesSecret: {
                name: "Secret Languages",
                hint: "With your DM's permission, you can choose a secret language.",
            },
        },
    };

    static FEATURE__SAVING_THROWS_ALL = [...Parser.ABIL_ABVS];

    static _SKILL_TOOL_LANGUAGE_KEYS__SKILL_ANY = new Set(["anySkill"]);
    static _SKILL_TOOL_LANGUAGE_KEYS__TOOL_ANY = new Set(["anyTool", "anyArtisansTool"]);
    static _SKILL_TOOL_LANGUAGE_KEYS__LANGAUGE_ANY = new Set(["anyLanguage", "anyStandardLanguage", "anyExoticLanguage"]);

    static getSkillSummary({skillProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: skillProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__SKILLS_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__SKILL_ANY,
            isShort,
            hoverTag: "skill",
        });
    }

    static getToolSummary({toolProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: toolProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__TOOLS_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__TOOL_ANY,
            isShort,
        });
    }

    static getLanguageSummary({languageProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: languageProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__LANGUAGES_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__LANGAUGE_ANY,
            isShort,
        });
    }

    static _summariseProfs({profGroupArr, skillToolLanguageProfs, setValid, setValidAny, isShort, hoverTag}) {
        if (!profGroupArr?.length && !skillToolLanguageProfs?.length)
            return {
                summary: "",
                collection: []
            };

        const collectionSet = new Set();

        const handleProfGroup = (profGroup,{isValidate=true}={})=>{
            let sep = ", ";

            const toJoin = Object.entries(profGroup).sort(([kA],[kB])=>this._summariseProfs_sortKeys(kA, kB)).filter(([k,v])=>v && (!isValidate || setValid.has(k) || setValidAny.has(k))).map(([k,v],i)=>{
                const vMapped = this.getMappedAnyProficiency({
                    keyAny: k,
                    countRaw: v
                }) ?? v;

                if (k === "choose") {
                    sep = "; ";

                    const chooseProfs = vMapped.from.filter(s=>!isValidate || setValid.has(s)).map(s=>{
                        collectionSet.add(s);
                        return this._summariseProfs_getEntry({
                            str: s,
                            isShort,
                            hoverTag
                        });
                    }
                    );
                    return `${isShort ? `${i === 0 ? "C" : "c"}hoose ` : ""}${v.count || 1} ${isShort ? `of` : `from`} ${chooseProfs.joinConjunct(", ", " or ")}`;
                }

                collectionSet.add(k);
                return this._summariseProfs_getEntry({
                    str: k,
                    isShort,
                    hoverTag
                });
            }
            );

            return toJoin.join(sep);
        }
        ;

        const summary = [...(profGroupArr || []).map(profGroup=>handleProfGroup(profGroup, {
            isValidate: false
        })), ...(skillToolLanguageProfs || []).map(profGroup=>handleProfGroup(profGroup)), ].filter(Boolean).join(` <i>or</i> `);

        return {
            summary,
            collection: [...collectionSet].sort(SortUtil.ascSortLower)
        };
    }

    static _summariseProfs_sortKeys(a, b, {setValidAny=null}={}) {
        if (a === b)
            return 0;
        if (a === "choose")
            return 2;
        if (b === "choose")
            return -2;
        if (setValidAny) {
            if (setValidAny.has(a))
                return 1;
            if (setValidAny.has(b))
                return -1;
        }
        return SortUtil.ascSort(a, b);
    }

    static _summariseProfs_getEntry({str, isShort, hoverTag}) {
        return isShort ? str.toTitleCase() : hoverTag ? `{@${hoverTag} ${str.toTitleCase()}}` : str.toTitleCase();
    }

    static getMappedAnyProficiency({keyAny, countRaw}) {
        const mappedCount = !isNaN(countRaw) ? Number(countRaw) : 1;
        if (mappedCount <= 0)
            return null;

        switch (keyAny) {
        case "anySkill":
            return {
                name: mappedCount === 1 ? `Any Skill` : `Any ${mappedCount} Skills`,
                from: this.FEATURE__SKILLS_ALL.map(it=>({
                    name: it,
                    prop: "skillProficiencies"
                })),
                count: mappedCount,
            };
        case "anyTool":
            return {
                name: mappedCount === 1 ? `Any Tool` : `Any ${mappedCount} Tools`,
                from: this.FEATURE__TOOLS_ALL.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyArtisansTool":
            return {
                name: mappedCount === 1 ? `Any Artisan's Tool` : `Any ${mappedCount} Artisan's Tools`,
                from: this.FEATURE__TOOLS_ARTISANS.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyMusicalInstrument":
            return {
                name: mappedCount === 1 ? `Any Musical Instrument` : `Any ${mappedCount} Musical Instruments`,
                from: this.FEATURE__TOOLS_MUSICAL_INSTRUMENTS.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyLanguage":
            return {
                name: mappedCount === 1 ? `Any Language` : `Any ${mappedCount} Languages`,
                from: this.FEATURE__LANGUAGES_ALL.map(it=>({
                    name: it,
                    prop: "languageProficiencies"
                })),
                count: mappedCount,
            };
        case "anyStandardLanguage":
            return {
                name: mappedCount === 1 ? `Any Standard Language` : `Any ${mappedCount} Standard Languages`,
                ...MiscUtil.copyFast(this.FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ),
                count: mappedCount,
            };
        case "anyExoticLanguage":
            return {
                name: mappedCount === 1 ? `Any Exotic Language` : `Any ${mappedCount} Exotic Languages`,
                ...MiscUtil.copyFast(this.FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ),
                count: mappedCount,
            };
        case "anySavingThrow":
            return {
                name: mappedCount === 1 ? `Any Saving Throw` : `Any ${mappedCount} Saving Throws`,
                from: this.FEATURE__SAVING_THROWS_ALL.map(it=>({
                    name: it,
                    prop: "savingThrowProficiencies"
                })),
                count: mappedCount,
            };

        case "anyWeapon":
            throw new Error(`Property handling for "anyWeapon" is unimplemented!`);
        case "anyArmor":
            throw new Error(`Property handling for "anyArmor" is unimplemented!`);

        default:
            return null;
        }
    }
};
Renderer.hover = {
    LinkMeta: function() {
        this.isHovered = false;
        this.isLoading = false;
        this.isPermanent = false;
        this.windowMeta = null;
    },

    _BAR_HEIGHT: 16,

    _linkCache: {},
    _eleCache: new Map(),
    _entryCache: {},
    _isInit: false,
    _dmScreen: null,
    _lastId: 0,
    _contextMenu: null,
    _contextMenuLastClicked: null,

    bindDmScreen(screen) {
        this._dmScreen = screen;
    },

    _getNextId() {
        return ++Renderer.hover._lastId;
    },

    _doInit() {
        if (!Renderer.hover._isInit) {
            Renderer.hover._isInit = true;

            $(document.body).on("click", ()=>Renderer.hover.cleanTempWindows());

            Renderer.hover._contextMenu = ContextUtil.getMenu([new ContextUtil.Action("Maximize All",()=>{
                const $permWindows = $(`.hoverborder[data-perm="true"]`);
                $permWindows.attr("data-display-title", "false");
            }
            ,), new ContextUtil.Action("Minimize All",()=>{
                const $permWindows = $(`.hoverborder[data-perm="true"]`);
                $permWindows.attr("data-display-title", "true");
            }
            ,), null, new ContextUtil.Action("Close Others",()=>{
                const hoverId = Renderer.hover._contextMenuLastClicked?.hoverId;
                Renderer.hover._doCloseAllWindows({
                    hoverIdBlocklist: new Set([hoverId])
                });
            }
            ,), new ContextUtil.Action("Close All",()=>Renderer.hover._doCloseAllWindows(),), ]);
        }
    },

    cleanTempWindows() {
        for (const [key,meta] of Renderer.hover._eleCache.entries()) {
            if (!meta.isPermanent && meta.windowMeta && typeof key === "number") {
                meta.windowMeta.doClose();
                Renderer.hover._eleCache.delete(key);
                return;
            }

            if (!meta.isPermanent && meta.windowMeta && !document.body.contains(key)) {
                meta.windowMeta.doClose();
                return;
            }

            if (!meta.isPermanent && meta.isHovered && meta.windowMeta) {
                const bounds = key.getBoundingClientRect();
                if (EventUtil._mouseX < bounds.x || EventUtil._mouseY < bounds.y || EventUtil._mouseX > bounds.x + bounds.width || EventUtil._mouseY > bounds.y + bounds.height) {
                    meta.windowMeta.doClose();
                }
            }
        }
    },

    _doCloseAllWindows({hoverIdBlocklist=null}={}) {
        Object.entries(Renderer.hover._WINDOW_METAS).filter(([hoverId,meta])=>hoverIdBlocklist == null || !hoverIdBlocklist.has(Number(hoverId))).forEach(([,meta])=>meta.doClose());
    },

    _getSetMeta(ele) {
        if (!Renderer.hover._eleCache.has(ele))
            Renderer.hover._eleCache.set(ele, new Renderer.hover.LinkMeta());
        return Renderer.hover._eleCache.get(ele);
    },

    _handleGenericMouseOverStart({evt, ele}) {
        if (Renderer.hover.isSmallScreen(evt) && !evt.shiftKey)
            return;

        Renderer.hover.cleanTempWindows();

        const meta = Renderer.hover._getSetMeta(ele);
        if (meta.isHovered || meta.isLoading)
            return;
        ele.style.cursor = "progress";

        meta.isHovered = true;
        meta.isLoading = true;
        meta.isPermanent = evt.shiftKey;

        return meta;
    },

    _doPredefinedShowStart({entryId}) {
        Renderer.hover.cleanTempWindows();

        const meta = Renderer.hover._getSetMeta(entryId);

        meta.isPermanent = true;

        return meta;
    },

    async pHandleLinkMouseOver(evt, ele, opts) {
        Renderer.hover._doInit();

        let page, source, hash, preloadId, customHashId, isFauxPage;
        if (opts) {
            page = opts.page;
            source = opts.source;
            hash = opts.hash;
            preloadId = opts.preloadId;
            customHashId = opts.customHashId;
            isFauxPage = !!opts.isFauxPage;
        } else {
            page = ele.dataset.vetPage;
            source = ele.dataset.vetSource;
            hash = ele.dataset.vetHash;
            preloadId = ele.dataset.vetPreloadId;
            isFauxPage = ele.dataset.vetIsFauxPage;
        }

        let meta = Renderer.hover._handleGenericMouseOverStart({
            evt,
            ele
        });
        if (meta == null)
            return;

        if ((EventUtil.isCtrlMetaKey(evt)) && Renderer.hover._pageToFluffFn(page))
            meta.isFluff = true;

        let toRender;
        if (preloadId != null) {
            switch (page) {
            case UrlUtil.PG_BESTIARY:
                {
                    const {_scaledCr: scaledCr, _scaledSpellSummonLevel: scaledSpellSummonLevel, _scaledClassSummonLevel: scaledClassSummonLevel} = Renderer.monster.getUnpackedCustomHashId(preloadId);

                    const baseMon = await DataLoader.pCacheAndGet(page, source, hash);
                    if (scaledCr != null) {
                        toRender = await ScaleCreature.scale(baseMon, scaledCr);
                    } else if (scaledSpellSummonLevel != null) {
                        toRender = await ScaleSpellSummonedCreature.scale(baseMon, scaledSpellSummonLevel);
                    } else if (scaledClassSummonLevel != null) {
                        toRender = await ScaleClassSummonedCreature.scale(baseMon, scaledClassSummonLevel);
                    }
                    break;
                }
            }
        } else if (customHashId) {
            toRender = await DataLoader.pCacheAndGet(page, source, hash);
            toRender = await Renderer.hover.pApplyCustomHashId(page, toRender, customHashId);
        } else {
            if (meta.isFluff)
                toRender = await Renderer.hover.pGetHoverableFluff(page, source, hash);
            else
                toRender = await DataLoader.pCacheAndGet(page, source, hash);
        }

        meta.isLoading = false;

        if (opts?.isDelay) {
            meta.isDelayed = true;
            ele.style.cursor = "help";
            await MiscUtil.pDelay(1100);
            meta.isDelayed = false;
        }

        ele.style.cursor = "";

        if (!meta || (!meta.isHovered && !meta.isPermanent))
            return;

        const tmpEvt = meta._tmpEvt;
        delete meta._tmpEvt;

        const win = (evt.view || {}).window;

        const $content = meta.isFluff ? Renderer.hover.$getHoverContent_fluff(page, toRender) : Renderer.hover.$getHoverContent_stats(page, toRender);

        const compactReferenceData = {
            page,
            source,
            hash,
        };

        if (meta.windowMeta && !meta.isPermanent) {
            meta.windowMeta.doClose();
            meta.windowMeta = null;
        }

        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(tmpEvt || evt, {
            isPreventFlicker: !meta.isPermanent
        }), {
            title: toRender ? toRender.name : "",
            isPermanent: meta.isPermanent,
            pageUrl: isFauxPage ? null : `${Renderer.get().baseUrl}${page}#${hash}`,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = meta.isFluff = false,
            isBookContent: page === UrlUtil.PG_RECIPES,
            compactReferenceData,
            sourceData: toRender,
        }, );

        if (!meta.isFluff && !win?._IS_POPOUT) {
            const fnBind = Renderer.hover.getFnBindListenersCompact(page);
            if (fnBind)
                fnBind(toRender, $content);
        }
    },

    handleInlineMouseOver(evt, ele, entry, opts) {
        Renderer.hover._doInit();

        entry = entry || JSON.parse(ele.dataset.vetEntry);

        let meta = Renderer.hover._handleGenericMouseOverStart({
            evt,
            ele
        });
        if (meta == null)
            return;

        meta.isLoading = false;

        ele.style.cursor = "";

        if (!meta || (!meta.isHovered && !meta.isPermanent))
            return;

        const tmpEvt = meta._tmpEvt;
        delete meta._tmpEvt;

        const win = (evt.view || {}).window;

        const $content = Renderer.hover.$getHoverContent_generic(entry, opts);

        if (meta.windowMeta && !meta.isPermanent) {
            meta.windowMeta.doClose();
            meta.windowMeta = null;
        }

        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(tmpEvt || evt, {
            isPreventFlicker: !meta.isPermanent
        }), {
            title: entry?.name || "",
            isPermanent: meta.isPermanent,
            pageUrl: null,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = false,
            isBookContent: true,
            sourceData: entry,
        }, );
    },

    async pGetHoverableFluff(page, source, hash, opts) {
        let toRender = await DataLoader.pCacheAndGet(`${page}Fluff`, source, hash, opts);

        if (!toRender) {
            const entity = await DataLoader.pCacheAndGet(page, source, hash, opts);

            const pFnGetFluff = Renderer.hover._pageToFluffFn(page);
            if (!pFnGetFluff && opts?.isSilent)
                return null;

            toRender = await pFnGetFluff(entity);
        }

        if (!toRender)
            return toRender;

        if (toRender && (!toRender.name || !toRender.source)) {
            const toRenderParent = await DataLoader.pCacheAndGet(page, source, hash, opts);
            toRender = MiscUtil.copyFast(toRender);
            toRender.name = toRenderParent.name;
            toRender.source = toRenderParent.source;
        }

        return toRender;
    },

    handleLinkMouseLeave(evt, ele) {
        const meta = Renderer.hover._eleCache.get(ele);
        ele.style.cursor = "";

        if (!meta || meta.isPermanent)
            return;

        if (evt.shiftKey) {
            meta.isPermanent = true;
            meta.windowMeta.setIsPermanent(true);
            return;
        }

        meta.isHovered = false;
        if (meta.windowMeta) {
            meta.windowMeta.doClose();
            meta.windowMeta = null;
        }
    },

    handleLinkMouseMove(evt, ele) {
        const meta = Renderer.hover._eleCache.get(ele);
        if (!meta || meta.isPermanent)
            return;

        if (meta.isDelayed) {
            meta._tmpEvt = evt;
            return;
        }

        if (!meta.windowMeta)
            return;

        meta.windowMeta.setPosition(Renderer.hover.getWindowPositionFromEvent(evt, {
            isPreventFlicker: !evt.shiftKey && !meta.isPermanent
        }));

        if (evt.shiftKey && !meta.isPermanent) {
            meta.isPermanent = true;
            meta.windowMeta.setIsPermanent(true);
        }
    },

    handlePredefinedMouseOver(evt, ele, entryId, opts) {
        opts = opts || {};

        const meta = Renderer.hover._handleGenericMouseOverStart({
            evt,
            ele
        });
        if (meta == null)
            return;

        Renderer.hover.cleanTempWindows();

        const toRender = Renderer.hover._entryCache[entryId];

        meta.isLoading = false;
        if (!meta.isHovered && !meta.isPermanent)
            return;

        const $content = Renderer.hover.$getHoverContent_generic(toRender, opts);
        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(evt, {
            isPreventFlicker: !meta.isPermanent
        }), {
            title: toRender.data && toRender.data.hoverTitle != null ? toRender.data.hoverTitle : toRender.name,
            isPermanent: meta.isPermanent,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = false,
            sourceData: toRender,
        }, );

        ele.style.cursor = "";
    },

    doPredefinedShow(entryId, opts) {
        opts = opts || {};

        const meta = Renderer.hover._doPredefinedShowStart({
            entryId
        });
        if (meta == null)
            return;

        Renderer.hover.cleanTempWindows();

        const toRender = Renderer.hover._entryCache[entryId];

        const $content = Renderer.hover.$getHoverContent_generic(toRender, opts);
        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionExact((window.innerWidth / 2) - (Renderer.hover._DEFAULT_WIDTH_PX / 2), 100), {
            title: toRender.data && toRender.data.hoverTitle != null ? toRender.data.hoverTitle : toRender.name,
            isPermanent: meta.isPermanent,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = false,
            sourceData: toRender,
        }, );
    },

    handlePredefinedMouseLeave(evt, ele) {
        return Renderer.hover.handleLinkMouseLeave(evt, ele);
    },

    handlePredefinedMouseMove(evt, ele) {
        return Renderer.hover.handleLinkMouseMove(evt, ele);
    },

    _WINDOW_POSITION_PROPS_FROM_EVENT: ["isFromBottom", "isFromRight", "clientX", "window", "isPreventFlicker", "bcr", ],

    getWindowPositionFromEvent(evt, {isPreventFlicker=false}={}) {
        const ele = evt.target;
        const win = evt?.view?.window || window;

        const bcr = ele.getBoundingClientRect().toJSON();

        const isFromBottom = bcr.top > win.innerHeight / 2;
        const isFromRight = bcr.left > win.innerWidth / 2;

        return {
            mode: "autoFromElement",
            isFromBottom,
            isFromRight,
            clientX: EventUtil.getClientX(evt),
            window: win,
            isPreventFlicker,
            bcr,
        };
    },

    getWindowPositionExact(x, y, evt=null) {
        return {
            window: evt?.view?.window || window,
            mode: "exact",
            x,
            y,
        };
    },

    getWindowPositionExactVisibleBottom(x, y, evt=null) {
        return {
            ...Renderer.hover.getWindowPositionExact(x, y, evt),
            mode: "exactVisibleBottom",
        };
    },

    _WINDOW_METAS: {},
    MIN_Z_INDEX: 200,
    _MAX_Z_INDEX: 300,
    _DEFAULT_WIDTH_PX: 600,
    _BODY_SCROLLER_WIDTH_PX: 15,

    _getZIndex() {
        const zIndices = Object.values(Renderer.hover._WINDOW_METAS).map(it=>it.zIndex);
        if (!zIndices.length)
            return Renderer.hover.MIN_Z_INDEX;
        return Math.max(...zIndices);
    },

    _getNextZIndex(hoverId) {
        const cur = Renderer.hover._getZIndex();
        if (hoverId != null && Renderer.hover._WINDOW_METAS[hoverId].zIndex === cur)
            return cur;
        const out = cur + 1;

        if (out > Renderer.hover._MAX_Z_INDEX) {
            const sortedWindowMetas = Object.entries(Renderer.hover._WINDOW_METAS).sort(([kA,vA],[kB,vB])=>SortUtil.ascSort(vA.zIndex, vB.zIndex));

            if (sortedWindowMetas.length >= (Renderer.hover._MAX_Z_INDEX - Renderer.hover.MIN_Z_INDEX)) {
                sortedWindowMetas.forEach(([k,v])=>{
                    v.setZIndex(Renderer.hover.MIN_Z_INDEX);
                }
                );
            } else {
                sortedWindowMetas.forEach(([k,v],i)=>{
                    v.setZIndex(Renderer.hover.MIN_Z_INDEX + i);
                }
                );
            }

            return Renderer.hover._getNextZIndex(hoverId);
        } else
            return out;
    },

    _isIntersectRect(r1, r2) {
        return r1.left <= r2.right && r2.left <= r1.right && r1.top <= r2.bottom && r2.top <= r1.bottom;
    },

    getShowWindow($content, position, opts) {
        opts = opts || {};

        Renderer.hover._doInit();

        const initialWidth = opts.width == null ? Renderer.hover._DEFAULT_WIDTH_PX : opts.width;
        const initialZIndex = Renderer.hover._getNextZIndex();

        const $body = $(position.window.document.body);
        const $hov = $(`<div class="hwin"></div>`).css({
            "right": -initialWidth,
            "width": initialWidth,
            "zIndex": initialZIndex,
        });
        const $wrpContent = $(`<div class="hwin__wrp-table"></div>`);
        if (opts.height != null)
            $wrpContent.css("height", opts.height);
        const $hovTitle = $(`<span class="window-title min-w-0 overflow-ellipsis" title="${`${opts.title || ""}`.qq()}">${opts.title || ""}</span>`);

        const hoverWindow = {};
        const hoverId = Renderer.hover._getNextId();
        Renderer.hover._WINDOW_METAS[hoverId] = hoverWindow;
        const mouseUpId = `mouseup.${hoverId} touchend.${hoverId}`;
        const mouseMoveId = `mousemove.${hoverId} touchmove.${hoverId}`;
        const resizeId = `resize.${hoverId}`;
        const drag = {};

        const $brdrTopRightResize = $(`<div class="hoverborder__resize-ne"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 1
        }));

        const $brdrRightResize = $(`<div class="hoverborder__resize-e"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 2
        }));

        const $brdrBottomRightResize = $(`<div class="hoverborder__resize-se"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 3
        }));

        const $brdrBtm = $(`<div class="hoverborder hoverborder--btm ${opts.isBookContent ? "hoverborder-book" : ""}"><div class="hoverborder__resize-s"></div></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 4
        }));

        const $brdrBtmLeftResize = $(`<div class="hoverborder__resize-sw"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 5
        }));

        const $brdrLeftResize = $(`<div class="hoverborder__resize-w"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 6
        }));

        const $brdrTopLeftResize = $(`<div class="hoverborder__resize-nw"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 7
        }));

        const $brdrTopResize = $(`<div class="hoverborder__resize-n"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 8
        }));

        const $brdrTop = $(`<div class="hoverborder hoverborder--top ${opts.isBookContent ? "hoverborder-book" : ""}" ${opts.isPermanent ? `data-perm="true"` : ""}></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 9
        })).on("contextmenu", (evt)=>{
            Renderer.hover._contextMenuLastClicked = {
                hoverId,
            };
            ContextUtil.pOpenMenu(evt, Renderer.hover._contextMenu);
        }
        );

        $(position.window.document).on(mouseUpId, (evt)=>{
            if (drag.type) {
                if (drag.type < 9) {
                    $wrpContent.css("max-height", "");
                    $hov.css("max-width", "");
                }
                Renderer.hover._getShowWindow_adjustPosition({
                    $hov,
                    $wrpContent,
                    position
                });

                if (drag.type === 9) {
                    if (EventUtil.isUsingTouch() && evt.target.classList.contains("hwin__top-border-icon")) {
                        evt.preventDefault();
                        drag.type = 0;
                        $(evt.target).click();
                        return;
                    }

                    if (this._dmScreen && opts.compactReferenceData) {
                        const panel = this._dmScreen.getPanelPx(EventUtil.getClientX(evt), EventUtil.getClientY(evt));
                        if (!panel)
                            return;
                        this._dmScreen.setHoveringPanel(panel);
                        const target = panel.getAddButtonPos();

                        if (Renderer.hover._getShowWindow_isOverHoverTarget({
                            evt,
                            target
                        })) {
                            panel.doPopulate_Stats(opts.compactReferenceData.page, opts.compactReferenceData.source, opts.compactReferenceData.hash);
                            Renderer.hover._getShowWindow_doClose({
                                $hov,
                                position,
                                mouseUpId,
                                mouseMoveId,
                                resizeId,
                                hoverId,
                                opts,
                                hoverWindow
                            });
                        }
                        this._dmScreen.resetHoveringButton();
                    }
                }
                drag.type = 0;
            }
        }
        ).on(mouseMoveId, (evt)=>{
            const args = {
                $wrpContent,
                $hov,
                drag,
                evt
            };
            switch (drag.type) {
            case 1:
                Renderer.hover._getShowWindow_handleNorthDrag(args);
                Renderer.hover._getShowWindow_handleEastDrag(args);
                break;
            case 2:
                Renderer.hover._getShowWindow_handleEastDrag(args);
                break;
            case 3:
                Renderer.hover._getShowWindow_handleSouthDrag(args);
                Renderer.hover._getShowWindow_handleEastDrag(args);
                break;
            case 4:
                Renderer.hover._getShowWindow_handleSouthDrag(args);
                break;
            case 5:
                Renderer.hover._getShowWindow_handleSouthDrag(args);
                Renderer.hover._getShowWindow_handleWestDrag(args);
                break;
            case 6:
                Renderer.hover._getShowWindow_handleWestDrag(args);
                break;
            case 7:
                Renderer.hover._getShowWindow_handleNorthDrag(args);
                Renderer.hover._getShowWindow_handleWestDrag(args);
                break;
            case 8:
                Renderer.hover._getShowWindow_handleNorthDrag(args);
                break;
            case 9:
                {
                    const diffX = drag.startX - EventUtil.getClientX(evt);
                    const diffY = drag.startY - EventUtil.getClientY(evt);
                    $hov.css("left", drag.baseLeft - diffX).css("top", drag.baseTop - diffY);
                    drag.startX = EventUtil.getClientX(evt);
                    drag.startY = EventUtil.getClientY(evt);
                    drag.baseTop = parseFloat($hov.css("top"));
                    drag.baseLeft = parseFloat($hov.css("left"));

                    if (this._dmScreen) {
                        const panel = this._dmScreen.getPanelPx(EventUtil.getClientX(evt), EventUtil.getClientY(evt));
                        if (!panel)
                            return;
                        this._dmScreen.setHoveringPanel(panel);
                        const target = panel.getAddButtonPos();

                        if (Renderer.hover._getShowWindow_isOverHoverTarget({
                            evt,
                            target
                        }))
                            this._dmScreen.setHoveringButton(panel);
                        else
                            this._dmScreen.resetHoveringButton();
                    }
                    break;
                }
            }
        }
        );
        $(position.window).on(resizeId, ()=>Renderer.hover._getShowWindow_adjustPosition({
            $hov,
            $wrpContent,
            position
        }));

        $brdrTop.attr("data-display-title", false);
        $brdrTop.on("dblclick", ()=>Renderer.hover._getShowWindow_doToggleMinimizedMaximized({
            $brdrTop,
            $hov
        }));
        $brdrTop.append($hovTitle);
        const $brdTopRhs = $(`<div class="ve-flex ml-auto no-shrink"></div>`).appendTo($brdrTop);

        if (opts.pageUrl && !position.window._IS_POPOUT && !Renderer.get().isInternalLinksDisabled()) {
            const $btnGotoPage = $(`<a class="hwin__top-border-icon glyphicon glyphicon-modal-window" title="Go to Page" href="${opts.pageUrl}"></a>`).appendTo($brdTopRhs);
        }

        if (!position.window._IS_POPOUT && !opts.isPopout) {
            const $btnPopout = $(`<span class="hwin__top-border-icon glyphicon glyphicon-new-window hvr__popout" title="Open as Popup Window"></span>`).on("click", evt=>{
                evt.stopPropagation();
                return Renderer.hover._getShowWindow_pDoPopout({
                    $hov,
                    position,
                    mouseUpId,
                    mouseMoveId,
                    resizeId,
                    hoverId,
                    opts,
                    hoverWindow,
                    $content
                }, {
                    evt
                });
            }
            ).appendTo($brdTopRhs);
        }

        if (opts.sourceData) {
            const btnPopout = e_({
                tag: "span",
                clazz: `hwin__top-border-icon hwin__top-border-icon--text`,
                title: "Show Source Data",
                text: "{}",
                click: evt=>{
                    evt.stopPropagation();
                    evt.preventDefault();

                    const $content = Renderer.hover.$getHoverContent_statsCode(opts.sourceData);
                    Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(evt), {
                        title: [opts.sourceData._displayName || opts.sourceData.name, "Source Data"].filter(Boolean).join(" \u2014 "),
                        isPermanent: true,
                        isBookContent: true,
                    }, );
                }
                ,
            });
            $brdTopRhs.append(btnPopout);
        }

        const $btnClose = $(`<span class="hwin__top-border-icon glyphicon glyphicon-remove" title="Close (CTRL to Close All)"></span>`).on("click", (evt)=>{
            evt.stopPropagation();

            if (EventUtil.isCtrlMetaKey(evt)) {
                Renderer.hover._doCloseAllWindows();
                return;
            }

            Renderer.hover._getShowWindow_doClose({
                $hov,
                position,
                mouseUpId,
                mouseMoveId,
                resizeId,
                hoverId,
                opts,
                hoverWindow
            });
        }
        ).appendTo($brdTopRhs);

        $wrpContent.append($content);

        $hov.append($brdrTopResize).append($brdrTopRightResize).append($brdrRightResize).append($brdrBottomRightResize).append($brdrBtmLeftResize).append($brdrLeftResize).append($brdrTopLeftResize)
        .append($brdrTop).append($wrpContent).append($brdrBtm);

        $body.append($hov);

        Renderer.hover._getShowWindow_setPosition({
            $hov,
            $wrpContent,
            position
        }, position);

        hoverWindow.$windowTitle = $hovTitle;
        hoverWindow.zIndex = initialZIndex;
        hoverWindow.setZIndex = Renderer.hover._getNextZIndex.bind(this, {
            $hov,
            hoverWindow
        });

        hoverWindow.setPosition = Renderer.hover._getShowWindow_setPosition.bind(this, {
            $hov,
            $wrpContent,
            position
        });
        hoverWindow.setIsPermanent = Renderer.hover._getShowWindow_setIsPermanent.bind(this, {
            opts,
            $brdrTop
        });
        hoverWindow.doClose = Renderer.hover._getShowWindow_doClose.bind(this, {
            $hov,
            position,
            mouseUpId,
            mouseMoveId,
            resizeId,
            hoverId,
            opts,
            hoverWindow
        });
        hoverWindow.doMaximize = Renderer.hover._getShowWindow_doMaximize.bind(this, {
            $brdrTop,
            $hov
        });
        hoverWindow.doZIndexToFront = Renderer.hover._getShowWindow_doZIndexToFront.bind(this, {
            $hov,
            hoverWindow,
            hoverId
        });

        if (opts.isPopout)
            Renderer.hover._getShowWindow_pDoPopout({
                $hov,
                position,
                mouseUpId,
                mouseMoveId,
                resizeId,
                hoverId,
                opts,
                hoverWindow,
                $content
            });

        return hoverWindow;
    },

    _getShowWindow_doClose({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow}) {
        $hov.remove();
        $(position.window.document).off(mouseUpId);
        $(position.window.document).off(mouseMoveId);
        $(position.window).off(resizeId);

        delete Renderer.hover._WINDOW_METAS[hoverId];

        if (opts.cbClose)
            opts.cbClose(hoverWindow);
    },

    _getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type}) {
        if (evt.which === 0 || evt.which === 1)
            evt.preventDefault();
        hoverWindow.zIndex = Renderer.hover._getNextZIndex(hoverId);
        $hov.css({
            "z-index": hoverWindow.zIndex,
            "animation": "initial",
        });
        drag.type = type;
        drag.startX = EventUtil.getClientX(evt);
        drag.startY = EventUtil.getClientY(evt);
        drag.baseTop = parseFloat($hov.css("top"));
        drag.baseLeft = parseFloat($hov.css("left"));
        drag.baseHeight = $wrpContent.height();
        drag.baseWidth = parseFloat($hov.css("width"));
        if (type < 9) {
            $wrpContent.css({
                "height": drag.baseHeight,
                "max-height": "initial",
            });
            $hov.css("max-width", "initial");
        }
    },

    _getShowWindow_isOverHoverTarget({evt, target}) {
        return EventUtil.getClientX(evt) >= target.left && EventUtil.getClientX(evt) <= target.left + target.width && EventUtil.getClientY(evt) >= target.top && EventUtil.getClientY(evt) <= target.top + target.height;
    },

    _getShowWindow_handleNorthDrag({$wrpContent, $hov, drag, evt}) {
        const diffY = Math.max(drag.startY - EventUtil.getClientY(evt), 80 - drag.baseHeight);
        $wrpContent.css("height", drag.baseHeight + diffY);
        $hov.css("top", drag.baseTop - diffY);
        drag.startY = EventUtil.getClientY(evt);
        drag.baseHeight = $wrpContent.height();
        drag.baseTop = parseFloat($hov.css("top"));
    },

    _getShowWindow_handleEastDrag({$wrpContent, $hov, drag, evt}) {
        const diffX = drag.startX - EventUtil.getClientX(evt);
        $hov.css("width", drag.baseWidth - diffX);
        drag.startX = EventUtil.getClientX(evt);
        drag.baseWidth = parseFloat($hov.css("width"));
    },

    _getShowWindow_handleSouthDrag({$wrpContent, $hov, drag, evt}) {
        const diffY = drag.startY - EventUtil.getClientY(evt);
        $wrpContent.css("height", drag.baseHeight - diffY);
        drag.startY = EventUtil.getClientY(evt);
        drag.baseHeight = $wrpContent.height();
    },

    _getShowWindow_handleWestDrag({$wrpContent, $hov, drag, evt}) {
        const diffX = Math.max(drag.startX - EventUtil.getClientX(evt), 150 - drag.baseWidth);
        $hov.css("width", drag.baseWidth + diffX).css("left", drag.baseLeft - diffX);
        drag.startX = EventUtil.getClientX(evt);
        drag.baseWidth = parseFloat($hov.css("width"));
        drag.baseLeft = parseFloat($hov.css("left"));
    },

    _getShowWindow_doToggleMinimizedMaximized({$brdrTop, $hov}) {
        const curState = $brdrTop.attr("data-display-title");
        const isNextMinified = curState === "false";
        $brdrTop.attr("data-display-title", isNextMinified);
        $brdrTop.attr("data-perm", true);
        $hov.toggleClass("hwin--minified", isNextMinified);
    },

    _getShowWindow_doMaximize({$brdrTop, $hov}) {
        $brdrTop.attr("data-display-title", false);
        $hov.toggleClass("hwin--minified", false);
    },

    async _getShowWindow_pDoPopout({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow, $content}, {evt}={}) {
        const dimensions = opts.fnGetPopoutSize ? opts.fnGetPopoutSize() : {
            width: 600,
            height: $content.height()
        };
        const win = window.open("", opts.title || "", `width=${dimensions.width},height=${dimensions.height}location=0,menubar=0,status=0,titlebar=0,toolbar=0`, );

        if (!win._IS_POPOUT) {
            win._IS_POPOUT = true;
            win.document.write(`
				<!DOCTYPE html>
				<html lang="en" class="ve-popwindow ${typeof styleSwitcher !== "undefined" ? styleSwitcher.getDayNightClassNames() : ""}"><head>
					<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
					<title>${opts.title}</title>
					${$(`link[rel="stylesheet"][href]`).map((i,e)=>e.outerHTML).get().join("\n")}
					<!-- Favicons -->
					<link rel="icon" type="image/svg+xml" href="favicon.svg">
					<link rel="icon" type="image/png" sizes="256x256" href="favicon-256x256.png">
					<link rel="icon" type="image/png" sizes="144x144" href="favicon-144x144.png">
					<link rel="icon" type="image/png" sizes="128x128" href="favicon-128x128.png">
					<link rel="icon" type="image/png" sizes="64x64" href="favicon-64x64.png">
					<link rel="icon" type="image/png" sizes="48x48" href="favicon-48x48.png">
					<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
					<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">

					<!-- Chrome Web App Icons -->
					<link rel="manifest" href="manifest.webmanifest">
					<meta name="application-name" content="5etools">
					<meta name="theme-color" content="#006bc4">

					<!-- Windows Start Menu tiles -->
					<meta name="msapplication-config" content="browserconfig.xml"/>
					<meta name="msapplication-TileColor" content="#006bc4">

					<!-- Apple Touch Icons -->
					<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
					<link rel="apple-touch-icon" sizes="360x360" href="apple-touch-icon-360x360.png">
					<link rel="apple-touch-icon" sizes="167x167" href="apple-touch-icon-167x167.png">
					<link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
					<link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120x120.png">
					<meta name="apple-mobile-web-app-title" content="5etools">

					<!-- macOS Safari Pinned Tab and Touch Bar -->
					<link rel="mask-icon" href="safari-pinned-tab.svg" color="#006bc4">

					<style>
						html, body { width: 100%; height: 100%; }
						body { overflow-y: scroll; }
						.hwin--popout { max-width: 100%; max-height: 100%; box-shadow: initial; width: 100%; overflow-y: auto; }
					</style>
				</head><body class="rd__body-popout">
				<div class="hwin hoverbox--popout hwin--popout"></div>
				<script type="text/javascript" src="js/parser.js"></script>
				<script type="text/javascript" src="js/utils.js"></script>
				<script type="text/javascript" src="lib/jquery.js"></script>
				</body></html>
			`);

            win.Renderer = Renderer;

            let ticks = 50;
            while (!win.document.body && ticks-- > 0)
                await MiscUtil.pDelay(5);

            win.$wrpHoverContent = $(win.document).find(`.hoverbox--popout`);
        }

        let $cpyContent;
        if (opts.$pFnGetPopoutContent) {
            $cpyContent = await opts.$pFnGetPopoutContent();
        } else {
            $cpyContent = $content.clone(true, true);
        }

        $cpyContent.appendTo(win.$wrpHoverContent.empty());

        Renderer.hover._getShowWindow_doClose({
            $hov,
            position,
            mouseUpId,
            mouseMoveId,
            resizeId,
            hoverId,
            opts,
            hoverWindow
        });
    },

    _getShowWindow_setPosition({$hov, $wrpContent, position}, positionNxt) {
        switch (positionNxt.mode) {
        case "autoFromElement":
            {
                const bcr = $hov[0].getBoundingClientRect();

                if (positionNxt.isFromBottom)
                    $hov.css("top", positionNxt.bcr.top - (bcr.height + 10));
                else
                    $hov.css("top", positionNxt.bcr.top + positionNxt.bcr.height + 10);

                if (positionNxt.isFromRight)
                    $hov.css("left", (positionNxt.clientX || positionNxt.bcr.left) - (bcr.width + 10));
                else
                    $hov.css("left", (positionNxt.clientX || (positionNxt.bcr.left + positionNxt.bcr.width)) + 10);

                if (position !== positionNxt) {
                    Renderer.hover._WINDOW_POSITION_PROPS_FROM_EVENT.forEach(prop=>{
                        position[prop] = positionNxt[prop];
                    }
                    );
                }

                break;
            }
        case "exact":
            {
                $hov.css({
                    "left": positionNxt.x,
                    "top": positionNxt.y,
                });
                break;
            }
        case "exactVisibleBottom":
            {
                $hov.css({
                    "left": positionNxt.x,
                    "top": positionNxt.y,
                    "animation": "initial",
                });

                let yPos = positionNxt.y;

                const {bottom: posBottom, height: winHeight} = $hov[0].getBoundingClientRect();
                const height = position.window.innerHeight;
                if (posBottom > height) {
                    yPos = position.window.innerHeight - winHeight;
                    $hov.css({
                        "top": yPos,
                        "animation": "",
                    });
                }

                break;
            }
        default:
            throw new Error(`Positiong mode unimplemented: "${positionNxt.mode}"`);
        }

        Renderer.hover._getShowWindow_adjustPosition({
            $hov,
            $wrpContent,
            position
        });
    },

    _getShowWindow_adjustPosition({$hov, $wrpContent, position}) {
        const eleHov = $hov[0];
        const wrpContent = $wrpContent[0];

        const bcr = eleHov.getBoundingClientRect().toJSON();
        const screenHeight = position.window.innerHeight;
        const screenWidth = position.window.innerWidth;

        if (bcr.top < 0) {
            bcr.top = 0;
            bcr.bottom = bcr.top + bcr.height;
            eleHov.style.top = `${bcr.top}px`;
        } else if (bcr.top >= screenHeight - Renderer.hover._BAR_HEIGHT) {
            bcr.top = screenHeight - Renderer.hover._BAR_HEIGHT;
            bcr.bottom = bcr.top + bcr.height;
            eleHov.style.top = `${bcr.top}px`;
        }

        if (bcr.left < 0) {
            bcr.left = 0;
            bcr.right = bcr.left + bcr.width;
            eleHov.style.left = `${bcr.left}px`;
        } else if (bcr.left + bcr.width + Renderer.hover._BODY_SCROLLER_WIDTH_PX > screenWidth) {
            bcr.left = Math.max(screenWidth - bcr.width - Renderer.hover._BODY_SCROLLER_WIDTH_PX, 0);
            bcr.right = bcr.left + bcr.width;
            eleHov.style.left = `${bcr.left}px`;
        }

        if (position.isPreventFlicker && Renderer.hover._isIntersectRect(bcr, position.bcr)) {
            if (position.isFromBottom) {
                bcr.height = position.bcr.top - 5;
                wrpContent.style.height = `${bcr.height}px`;
            } else {
                bcr.height = screenHeight - position.bcr.bottom - 5;
                wrpContent.style.height = `${bcr.height}px`;
            }
        }
    },

    _getShowWindow_setIsPermanent({opts, $brdrTop}, isPermanent) {
        opts.isPermanent = isPermanent;
        $brdrTop.attr("data-perm", isPermanent);
    },

    _getShowWindow_setZIndex({$hov, hoverWindow}, zIndex) {
        $hov.css("z-index", zIndex);
        hoverWindow.zIndex = zIndex;
    },

    _getShowWindow_doZIndexToFront({$hov, hoverWindow, hoverId}) {
        const nxtZIndex = Renderer.hover._getNextZIndex(hoverId);
        Renderer.hover._getNextZIndex({
            $hov,
            hoverWindow
        }, nxtZIndex);
    },

    getMakePredefinedHover(entry, opts) {
        opts = opts || {};

        const id = opts.id ?? Renderer.hover._getNextId();
        Renderer.hover._entryCache[id] = entry;
        return {
            id,
            html: `onmouseover="Renderer.hover.handlePredefinedMouseOver(event, this, ${id}, ${JSON.stringify(opts).escapeQuotes()})" onmousemove="Renderer.hover.handlePredefinedMouseMove(event, this)" onmouseleave="Renderer.hover.handlePredefinedMouseLeave(event, this)" ${Renderer.hover.getPreventTouchString()}`,
            mouseOver: (evt,ele)=>Renderer.hover.handlePredefinedMouseOver(evt, ele, id, opts),
            mouseMove: (evt,ele)=>Renderer.hover.handlePredefinedMouseMove(evt, ele),
            mouseLeave: (evt,ele)=>Renderer.hover.handlePredefinedMouseLeave(evt, ele),
            touchStart: (evt,ele)=>Renderer.hover.handleTouchStart(evt, ele),
            show: ()=>Renderer.hover.doPredefinedShow(id, opts),
        };
    },

    updatePredefinedHover(id, entry) {
        Renderer.hover._entryCache[id] = entry;
    },

    getInlineHover(entry, opts) {
        return {
            html: `onmouseover="Renderer.hover.handleInlineMouseOver(event, this)" onmouseleave="Renderer.hover.handleLinkMouseLeave(event, this)" onmousemove="Renderer.hover.handleLinkMouseMove(event, this)" data-vet-entry="${JSON.stringify(entry).qq()}" ${opts ? `data-vet-opts="${JSON.stringify(opts).qq()}"` : ""} ${Renderer.hover.getPreventTouchString()}`,
        };
    },

    getPreventTouchString() {
        return `ontouchstart="Renderer.hover.handleTouchStart(event, this)"`;
    },

    handleTouchStart(evt, ele) {
        if (!Renderer.hover.isSmallScreen(evt)) {
            $(ele).data("href", $(ele).data("href") || $(ele).attr("href"));
            $(ele).attr("href", "javascript:void(0)");
            setTimeout(()=>{
                const data = $(ele).data("href");
                if (data) {
                    $(ele).attr("href", data);
                    $(ele).data("href", null);
                }
            }
            , 100);
        }
    },

    getEntityLink(ent, {displayText=null, prop=null, isLowerCase=false, isTitleCase=false, }={}, ) {
        if (isLowerCase && isTitleCase)
            throw new Error(`"isLowerCase" and "isTitleCase" are mutually exclusive!`);

        const name = isLowerCase ? ent.name.toLowerCase() : isTitleCase ? ent.name.toTitleCase() : ent.name;

        let parts = [name, ent.source, displayText || "", ];

        switch (prop || ent.__prop) {
        case "monster":
            {
                if (ent._isScaledCr) {
                    parts.push(`${VeCt.HASH_SCALED}=${Parser.numberToCr(ent._scaledCr)}`);
                }

                if (ent._isScaledSpellSummon) {
                    parts.push(`${VeCt.HASH_SCALED_SPELL_SUMMON}=${ent._scaledSpellSummonLevel}`);
                }

                if (ent._isScaledClassSummon) {
                    parts.push(`${VeCt.HASH_SCALED_CLASS_SUMMON}=${ent._scaledClassSummonLevel}`);
                }

                break;
            }

        case "deity":
            {
                parts.splice(1, 0, ent.pantheon);
                break;
            }
        }

        while (parts.length && !parts.last()?.length)
            parts.pop();

        return Renderer.get().render(`{@${Parser.getPropTag(prop || ent.__prop)} ${parts.join("|")}}`);
    },

    getRefMetaFromTag(str) {
        str = str.slice(2, -1);
        const [tag,...refParts] = str.split(" ");
        const ref = refParts.join(" ");
        const type = `ref${tag.uppercaseFirst()}`;
        return {
            type,
            [tag]: ref
        };
    },

    async pApplyCustomHashId(page, ent, customHashId) {
        switch (page) {
        case UrlUtil.PG_BESTIARY:
            {
                const out = await Renderer.monster.pGetModifiedCreature(ent, customHashId);
                Renderer.monster.updateParsed(out);
                return out;
            }

        case UrlUtil.PG_RECIPES:
            return Renderer.recipe.pGetModifiedRecipe(ent, customHashId);

        default:
            return ent;
        }
    },

    getGenericCompactRenderedString(entry, depth=0) {
        return `
			<tr class="text homebrew-hover"><td colspan="6">
			${Renderer.get().setFirstSection(true).render(entry, depth)}
			</td></tr>
		`;
    },

    getFnRenderCompact(page, {isStatic=false}={}) {
        switch (page) {
        case "generic":
        case "hover":
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_QUICKREF:
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_CLASSES:
            return Renderer.class.getCompactRenderedString;
        case UrlUtil.PG_SPELLS:
            return Renderer.spell.getCompactRenderedString;
        case UrlUtil.PG_ITEMS:
            return Renderer.item.getCompactRenderedString;
        case UrlUtil.PG_BESTIARY:
            return it=>Renderer.monster.getCompactRenderedString(it, {
                isShowScalers: !isStatic,
                isScaledCr: it._originalCr != null,
                isScaledSpellSummon: it._isScaledSpellSummon,
                isScaledClassSummon: it._isScaledClassSummon
            });
        case UrlUtil.PG_CONDITIONS_DISEASES:
            return Renderer.condition.getCompactRenderedString;
        case UrlUtil.PG_BACKGROUNDS:
            return Renderer.background.getCompactRenderedString;
        case UrlUtil.PG_FEATS:
            return Renderer.feat.getCompactRenderedString;
        case UrlUtil.PG_OPT_FEATURES:
            return Renderer.optionalfeature.getCompactRenderedString;
        case UrlUtil.PG_PSIONICS:
            return Renderer.psionic.getCompactRenderedString;
        case UrlUtil.PG_REWARDS:
            return Renderer.reward.getCompactRenderedString;
        case UrlUtil.PG_RACES:
            return it=>Renderer.race.getCompactRenderedString(it, {
                isStatic
            });
        case UrlUtil.PG_DEITIES:
            return Renderer.deity.getCompactRenderedString;
        case UrlUtil.PG_OBJECTS:
            return Renderer.object.getCompactRenderedString;
        case UrlUtil.PG_TRAPS_HAZARDS:
            return Renderer.traphazard.getCompactRenderedString;
        case UrlUtil.PG_VARIANTRULES:
            return Renderer.variantrule.getCompactRenderedString;
        case UrlUtil.PG_CULTS_BOONS:
            return Renderer.cultboon.getCompactRenderedString;
        case UrlUtil.PG_TABLES:
            return Renderer.table.getCompactRenderedString;
        case UrlUtil.PG_VEHICLES:
            return Renderer.vehicle.getCompactRenderedString;
        case UrlUtil.PG_ACTIONS:
            return Renderer.action.getCompactRenderedString;
        case UrlUtil.PG_LANGUAGES:
            return Renderer.language.getCompactRenderedString;
        case UrlUtil.PG_CHAR_CREATION_OPTIONS:
            return Renderer.charoption.getCompactRenderedString;
        case UrlUtil.PG_RECIPES:
            return Renderer.recipe.getCompactRenderedString;
        case UrlUtil.PG_CLASS_SUBCLASS_FEATURES:
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_CREATURE_FEATURES:
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_DECKS:
            return Renderer.deck.getCompactRenderedString;
        case "classfeature":
        case "classFeature":
            return Renderer.hover.getGenericCompactRenderedString;
        case "subclassfeature":
        case "subclassFeature":
            return Renderer.hover.getGenericCompactRenderedString;
        case "citation":
            return Renderer.hover.getGenericCompactRenderedString;
        default:
            if (Renderer[page]?.getCompactRenderedString){return Renderer[page].getCompactRenderedString;}
            return null;
        }
    },

    getFnBindListenersCompact(page) {
        switch (page) {
        case UrlUtil.PG_BESTIARY:
            return Renderer.monster.bindListenersCompact;
        case UrlUtil.PG_RACES:
            return Renderer.race.bindListenersCompact;
        default:
            return null;
        }
    },

    _pageToFluffFn(page) {
        switch (page) {
        case UrlUtil.PG_BESTIARY:
            return Renderer.monster.pGetFluff;
        case UrlUtil.PG_ITEMS:
            return Renderer.item.pGetFluff;
        case UrlUtil.PG_CONDITIONS_DISEASES:
            return Renderer.condition.pGetFluff;
        case UrlUtil.PG_SPELLS:
            return Renderer.spell.pGetFluff;
        case UrlUtil.PG_RACES:
            return Renderer.race.pGetFluff;
        case UrlUtil.PG_BACKGROUNDS:
            return Renderer.background.pGetFluff;
        case UrlUtil.PG_FEATS:
            return Renderer.feat.pGetFluff;
        case UrlUtil.PG_LANGUAGES:
            return Renderer.language.pGetFluff;
        case UrlUtil.PG_VEHICLES:
            return Renderer.vehicle.pGetFluff;
        case UrlUtil.PG_CHAR_CREATION_OPTIONS:
            return Renderer.charoption.pGetFluff;
        case UrlUtil.PG_RECIPES:
            return Renderer.recipe.pGetFluff;
        default:
            return null;
        }
    },

    isSmallScreen(evt) {
        if (typeof window === "undefined")
            return false;

        evt = evt || {};
        const win = (evt.view || {}).window || window;
        return win.innerWidth <= 768;
    },

    $getHoverContent_stats(page, toRender, opts, renderFnOpts) {
        opts = opts || {};
        if (page === UrlUtil.PG_RECIPES){opts = {...MiscUtil.copyFast(opts), isBookContent: true};}

        const fnRender = opts.fnRender || Renderer.hover.getFnRenderCompact(page, {isStatic: opts.isStatic});
        const $out = $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}">${fnRender(toRender, renderFnOpts)}</table>`;

        if (!opts.isStatic) {
            const fnBind = Renderer.hover.getFnBindListenersCompact(page);
            if (fnBind){fnBind(toRender, $out[0]);}
        }

        return $out;
    },

    $getHoverContent_fluff(page, toRender, opts, renderFnOpts) {
        opts = opts || {};
        if (page === UrlUtil.PG_RECIPES)
            opts = {
                ...MiscUtil.copyFast(opts),
                isBookContent: true
            };

        if (!toRender) {
            return $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}"><tr class="text"><td colspan="6" class="p-2 ve-text-center">${Renderer.utils.HTML_NO_INFO}</td></tr></table>`;
        }

        toRender = MiscUtil.copyFast(toRender);

        if (toRender.images && toRender.images.length) {
            const cachedImages = MiscUtil.copyFast(toRender.images);
            delete toRender.images;

            toRender.entries = toRender.entries || [];
            const hasText = toRender.entries.length > 0;
            if (hasText)
                toRender.entries.unshift({
                    type: "hr"
                });
            cachedImages[0].maxHeight = 33;
            cachedImages[0].maxHeightUnits = "vh";
            toRender.entries.unshift(cachedImages[0]);

            if (cachedImages.length > 1) {
                if (hasText)
                    toRender.entries.push({
                        type: "hr"
                    });
                toRender.entries.push(...cachedImages.slice(1));
            }
        }

        return $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}">${Renderer.generic.getCompactRenderedString(toRender, renderFnOpts)}</table>`;
    },

    $getHoverContent_statsCode(toRender, {isSkipClean=false, title=null}={}) {
        const cleanCopy = isSkipClean ? toRender : DataUtil.cleanJson(MiscUtil.copyFast(toRender));
        return Renderer.hover.$getHoverContent_miscCode(title || [cleanCopy.name, "Source Data"].filter(Boolean).join(" \u2014 "), JSON.stringify(cleanCopy, null, "\t"), );
    },

    $getHoverContent_miscCode(name, code) {
        const toRenderCode = {
            type: "code",
            name,
            preformatted: code,
        };
        return $$`<table class="w-100 stats stats--book">${Renderer.get().render(toRenderCode)}</table>`;
    },

    $getHoverContent_generic(toRender, opts) {
        opts = opts || {};

        return $$`<table class="w-100 stats ${opts.isBookContent || opts.isLargeBookContent ? "stats--book" : ""} ${opts.isLargeBookContent?
             "stats--book-large" : ""}">${Renderer.hover.getGenericCompactRenderedString(toRender, opts.depth || 0)}</table>`;
    },

    doPopoutCurPage(evt, entity) {
        const page = UrlUtil.getCurrentPage();
        const $content = Renderer.hover.$getHoverContent_stats(page, entity);
        Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(evt), {
            pageUrl: `#${UrlUtil.autoEncodeHash(entity)}`,
            title: entity._displayName || entity.name,
            isPermanent: true,
            isBookContent: page === UrlUtil.PG_RECIPES,
            sourceData: entity,
        }, );
    },
};
Renderer.get = ()=>{
    if (!Renderer.defaultRenderer){Renderer.defaultRenderer = new Renderer();}
    return Renderer.defaultRenderer;
};

Renderer.applyProperties = function(entry, object) {
    const propSplit = Renderer.splitByPropertyInjectors(entry);
    const len = propSplit.length;
    if (len === 1)
        return entry;

    let textStack = "";

    for (let i = 0; i < len; ++i) {
        const s = propSplit[i];
        if (!s)
            continue;

        if (!s.startsWith("{=")) {
            textStack += s;
            continue;
        }

        if (s.startsWith("{=")) {
            const [path,modifiers] = s.slice(2, -1).split("/");
            let fromProp = object[path];

            if (!modifiers) {
                textStack += fromProp;
                continue;
            }

            if (fromProp == null)
                throw new Error(`Could not apply property in "${s}"; "${path}" value was null!`);

            modifiers.split("").sort((a,b)=>Renderer.applyProperties._OP_ORDER.indexOf(a) - Renderer.applyProperties._OP_ORDER.indexOf(b));

            for (const modifier of modifiers) {
                switch (modifier) {
                case "a":
                    fromProp = Renderer.applyProperties._LEADING_AN.has(fromProp[0].toLowerCase()) ? "an" : "a";
                    break;

                case "l":
                    fromProp = fromProp.toLowerCase();
                    break;
                case "t":
                    fromProp = fromProp.toTitleCase();
                    break;
                case "u":
                    fromProp = fromProp.toUpperCase();
                    break;
                case "v":
                    fromProp = Parser.numberToVulgar(fromProp);
                    break;
                case "x":
                    fromProp = Parser.numberToText(fromProp);
                    break;
                case "r":
                    fromProp = Math.round(fromProp);
                    break;
                case "f":
                    fromProp = Math.floor(fromProp);
                    break;
                case "c":
                    fromProp = Math.ceil(fromProp);
                    break;
                default:
                    throw new Error(`Unhandled property modifier "${modifier}"`);
                }
            }

            textStack += fromProp;
        }
    }

    return textStack;
};
Renderer.applyProperties._LEADING_AN = new Set(["a", "e", "i", "o", "u"]);
Renderer.applyProperties._OP_ORDER = ["r", "f", "c", "v", "x", "l", "t", "u", "a", ];

Renderer.applyAllProperties = function(entries, object=null) {
    let lastObj = null;
    const handlers = {
        object: (obj)=>{
            lastObj = obj;
            return obj;
        }
        ,
        string: (str)=>Renderer.applyProperties(str, object || lastObj),
    };
    return MiscUtil.getWalker().walk(entries, handlers);
};

Renderer.splitFirstSpace = function(string) {
    const firstIndex = string.indexOf(" ");
    return firstIndex === -1 ? [string, ""] : [string.substr(0, firstIndex), string.substr(firstIndex + 1)];
};
Renderer._splitByTagsBase = function(leadingCharacter) {
    return function(string) {
        let tagDepth = 0;
        let char, char2;
        const out = [];
        let curStr = "";
        let isLastOpen = false;

        const len = string.length;
        for (let i = 0; i < len; ++i) {
            char = string[i];
            char2 = string[i + 1];

            switch (char) {
            case "{":
                isLastOpen = true;
                if (char2 === leadingCharacter) {
                    if (tagDepth++ > 0) {
                        curStr += "{";
                    } else {
                        out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));
                        curStr = `{${leadingCharacter}`;
                        ++i;
                    }
                } else
                    curStr += "{";
                break;

            case "}":
                isLastOpen = false;
                curStr += "}";
                if (tagDepth !== 0 && --tagDepth === 0) {
                    out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));
                    curStr = "";
                }
                break;

            case leadingCharacter:
                {
                    if (!isLastOpen)
                        curStr += "<VE_LEAD>";
                    else
                        curStr += leadingCharacter;
                    break;
                }

            default:
                isLastOpen = false;
                curStr += char;
                break;
            }
        }

        if (curStr)
            out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));

        return out;
    }
    ;
};

Renderer.splitByTags = Renderer._splitByTagsBase("@");
Renderer.splitByPropertyInjectors = Renderer._splitByTagsBase("=");

Renderer._splitByPipeBase = function(leadingCharacter) {
    return function(string) {
        let tagDepth = 0;
        let char, char2;
        const out = [];
        let curStr = "";

        const len = string.length;
        for (let i = 0; i < len; ++i) {
            char = string[i];
            char2 = string[i + 1];

            switch (char) {
            case "{":
                if (char2 === leadingCharacter)
                    tagDepth++;
                curStr += "{";

                break;

            case "}":
                if (tagDepth)
                    tagDepth--;
                curStr += "}";

                break;

            case "|":
                {
                    if (tagDepth)
                        curStr += "|";
                    else {
                        out.push(curStr);
                        curStr = "";
                    }
                    break;
                }

            default:
                {
                    curStr += char;
                    break;
                }
            }
        }

        if (curStr)
            out.push(curStr);
        return out;
    }
    ;
};

Renderer.splitTagByPipe = Renderer._splitByPipeBase("@");
Renderer.utils = {
    getBorderTr: (optText=null)=>{
        return `<tr><th class="border" colspan="6">${optText || ""}</th></tr>`;
    }
    ,

    getDividerTr: ()=>{
        return `<tr><td class="divider" colspan="6"><div></div></td></tr>`;
    }
    ,

    getSourceSubText(it) {
        return it.sourceSub ? ` \u2014 ${it.sourceSub}` : "";
    },

    getNameTr: (it,opts)=>{
        opts = opts || {};

        let dataPart = "";
        let pageLinkPart;
        if (opts.page) {
            const hash = UrlUtil.URL_TO_HASH_BUILDER[opts.page](it);
            dataPart = `data-page="${opts.page}" data-source="${it.source.escapeQuotes()}" data-hash="${hash.escapeQuotes()}" ${opts.extensionData != null ? `data-extension='${JSON.stringify(opts.extensionData).escapeQuotes()}` : ""}'`;
            pageLinkPart = SourceUtil.getAdventureBookSourceHref(it.source, it.page);

            if (opts.isEmbeddedEntity) { ExtensionUtil.addEmbeddedToCache(opts.page, it.source, hash, it); }
        }

        const tagPartSourceStart = `<${pageLinkPart ? `a href="${Renderer.get().baseUrl}${pageLinkPart}"` : "span"}`;
        const tagPartSourceEnd = `</${pageLinkPart ? "a" : "span"}>`;

        const ptBrewSourceLink = Renderer.utils._getNameTr_getPtPrereleaseBrewSourceLink({
            ent: it,
            brewUtil: PrereleaseUtil
        }) || Renderer.utils._getNameTr_getPtPrereleaseBrewSourceLink({
            ent: it,
            brewUtil: BrewUtil2
        });

        const $ele = $$`<tr>
			<th class="rnd-name ${opts.extraThClasses ? opts.extraThClasses.join(" ") : ""}" colspan="6" ${dataPart}>
				<div class="name-inner">
					<div class="ve-flex-v-center">
						<h1 class="stats-name copyable m-0" onmousedown="event.preventDefault()" onclick="Renderer.utils._pHandleNameClick(this)">${opts.prefix || ""}${it._displayName || it.name}${opts.suffix || ""}</h1>
						${opts.controlRhs || ""}
					</div>
					<div class="stats-source ve-flex-v-baseline">
						${tagPartSourceStart} class="help-subtle stats-source-abbreviation ${it.source ? `${Parser.sourceJsonToColor(it.source)}" title="${Parser.sourceJsonToFull(it.source)}
                        ${Renderer.utils.getSourceSubText(it)}` : ""}" ${Parser.sourceJsonToStyle(it.source)}>${it.source ? Parser.sourceJsonToAbv(it.source) : ""}${tagPartSourceEnd}

						${Renderer.utils.isDisplayPage(it.page) ? ` ${tagPartSourceStart} class="rd__stats-name-page ml-1" title="Page ${it.page}">p${it.page}${tagPartSourceEnd}` : ""}

						${ptBrewSourceLink}
					</div>
				</div>
			</th>
		</tr>`;

        if (opts.asJquery){return $ele;}
        else {return $ele[0].outerHTML;}
    },

    _getNameTr_getPtPrereleaseBrewSourceLink({ent, brewUtil}) {
        if (!brewUtil.hasSourceJson(ent.source) || !brewUtil.sourceJsonToSource(ent.source)?.url)
            return "";

        return `<a href="${brewUtil.sourceJsonToSource(ent.source).url}" title="View ${brewUtil.DISPLAY_NAME.toTitleCase()} Source" class="ve-self-flex-center ml-2 ve-muted rd__stats-name-brew-link" target="_blank" rel="noopener noreferrer"><span class="	glyphicon glyphicon-share"></span></a>`;
    },

    getBtnSendToFoundryHtml({isMb=true}={}) {
        return `<button title="Send to Foundry (SHIFT for Temporary Import)" class="btn btn-xs btn-default btn-stats-name mx-2 ${isMb ? "mb-2" : ""} ve-self-flex-end" onclick="ExtensionUtil.pDoSendStats(event, this)" draggable="true" ondragstart="ExtensionUtil.doDragStart(event, this)"><span class="glyphicon glyphicon-send"></span></button>`;
    },

    isDisplayPage(page) {
        return page != null && ((!isNaN(page) && page > 0) || isNaN(page));
    },

    getExcludedTr({entity, dataProp, page, isExcluded}) {
        const excludedHtml = Renderer.utils.getExcludedHtml({
            entity,
            dataProp,
            page,
            isExcluded
        });
        if (!excludedHtml)
            return "";
        return `<tr><td colspan="6" class="pt-3">${excludedHtml}</td></tr>`;
    },

    getExcludedHtml({entity, dataProp, page, isExcluded}) {
        if (isExcluded != null && !isExcluded)
            return "";
        if (isExcluded == null) {
            if (!ExcludeUtil.isInitialised)
                return "";
            if (page && !UrlUtil.URL_TO_HASH_BUILDER[page])
                return "";
            const hash = page ? UrlUtil.URL_TO_HASH_BUILDER[page](entity) : UrlUtil.autoEncodeHash(entity);
            isExcluded = isExcluded || dataProp === "item" ? Renderer.item.isExcluded(entity, {
                hash
            }) : ExcludeUtil.isExcluded(hash, dataProp, entity.source);
        }
        return isExcluded ? `<div class="ve-text-center text-danger"><b><i>Warning: This content has been <a href="blocklist.html">blocklisted</a>.</i></b></div>` : "";
    },

    getSourceAndPageTrHtml(it, {tag, fnUnpackUid}={}) {
        const html = Renderer.utils.getSourceAndPageHtml(it, {
            tag,
            fnUnpackUid
        });
        return html ? `<b>Source:</b> ${html}` : "";
    },

    _getAltSourceHtmlOrText(it, prop, introText, isText) {
        if (!it[prop] || !it[prop].length)
            return "";

        return `${introText} ${it[prop].map(as=>{
            if (as.entry)
                return (isText ? Renderer.stripTags : Renderer.get().render)(as.entry);
            return `${isText ? "" : `<i class="help-subtle" title="${Parser.sourceJsonToFull(as.source).qq()}">`}${Parser.sourceJsonToAbv(as.source)}${isText ? "" : `</i>`}${Renderer.utils.isDisplayPage(as.page) ? `, page ${as.page}` : ""}`;
        }
        ).join("; ")}`;
    },

    _getReprintedAsHtmlOrText(ent, {isText, tag, fnUnpackUid}={}) {
        if (!ent.reprintedAs)
            return "";
        if (!tag || !fnUnpackUid)
            return "";

        const ptReprinted = ent.reprintedAs.map(it=>{
            const uid = it.uid ?? it;
            const tag_ = it.tag ?? tag;

            const {name, source, displayText} = fnUnpackUid(uid);

            if (isText) {
                return `${Renderer.stripTags(displayText || name)} in ${Parser.sourceJsonToAbv(source)}`;
            }

            const asTag = `{@${tag_} ${name}|${source}${displayText ? `|${displayText}` : ""}}`;

            return `${Renderer.get().render(asTag)} in <i class="help-subtle" title="${Parser.sourceJsonToFull(source).qq()}">${Parser.sourceJsonToAbv(source)}</i>`;
        }
        ).join("; ");

        return `Reprinted as ${ptReprinted}`;
    },

    getSourceAndPageHtml(it, {tag, fnUnpackUid}={}) {
        return this._getSourceAndPageHtmlOrText(it, {
            tag,
            fnUnpackUid
        });
    },
    getSourceAndPageText(it, {tag, fnUnpackUid}={}) {
        return this._getSourceAndPageHtmlOrText(it, {
            isText: true,
            tag,
            fnUnpackUid
        });
    },

    _getSourceAndPageHtmlOrText(it, {isText, tag, fnUnpackUid}={}) {
        const sourceSub = Renderer.utils.getSourceSubText(it);
        const baseText = `${isText ? `` : `<i title="${Parser.sourceJsonToFull(it.source)}${sourceSub}">`}${Parser.sourceJsonToAbv(it.source)}${sourceSub}${isText ? "" : `</i>`}${Renderer.utils.isDisplayPage(it.page) ? `, page ${it.page}` : ""}`;
        const reprintedAsText = Renderer.utils._getReprintedAsHtmlOrText(it, {
            isText,
            tag,
            fnUnpackUid
        });
        const addSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "additionalSources", "Additional information from", isText);
        const otherSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "otherSources", "Also found in", isText);
        const externalSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "externalSources", "External sources:", isText);

        const srdText = it.srd ? `${isText ? "" : `the <span title="Systems Reference Document">`}SRD${isText ? "" : `</span>`}${typeof it.srd === "string" ? ` (as &quot;${it.srd}&quot;)` : ""}` : "";
        const basicRulesText = it.basicRules ? `the Basic Rules${typeof it.basicRules === "string" ? ` (as &quot;${it.basicRules}&quot;)` : ""}` : "";
        const srdAndBasicRulesText = (srdText || basicRulesText) ? `Available in ${[srdText, basicRulesText].filter(it=>it).join(" and ")}` : "";

        return `${[baseText, addSourceText, reprintedAsText, otherSourceText, srdAndBasicRulesText, externalSourceText].filter(it=>it).join(". ")}${baseText && (addSourceText || otherSourceText || srdAndBasicRulesText || externalSourceText) ? "." : ""}`;
    },

    async _pHandleNameClick(ele) {
        await MiscUtil.pCopyTextToClipboard($(ele).text());
        JqueryUtil.showCopiedEffect($(ele));
    },

    getPageTr(it, {tag, fnUnpackUid}={}) {
        return `<tr><td colspan=6>${Renderer.utils.getSourceAndPageTrHtml(it, {
            tag,
            fnUnpackUid
        })}</td></tr>`;
    },

    getAbilityRollerEntry(statblock, ability) {
        if (statblock[ability] == null)
            return "\u2014";
        return `{@ability ${ability} ${statblock[ability]}}`;
    },

    getAbilityRoller(statblock, ability) {
        return Renderer.get().render(Renderer.utils.getAbilityRollerEntry(statblock, ability));
    },

    getEmbeddedDataHeader(name, style, {isCollapsed=false}={}) {
        return `<table class="rd__b-special rd__b-data ${style ? `rd__b-data--${style}` : ""}">
		<thead><tr><th class="rd__data-embed-header" colspan="6" data-rd-data-embed-header="true"><span class="rd__data-embed-name ${isCollapsed ? "" : `ve-hidden`}">${name}</span><span class="rd__data-embed-toggle">[${isCollapsed ? "+" : "\u2013"}]</span></th></tr></thead><tbody class="${isCollapsed ? `ve-hidden` : ""}" data-rd-embedded-data-render-target="true">`;
    },

    getEmbeddedDataFooter() {
        return `</tbody></table>`;
    },

    TabButton: function({label, fnChange, fnPopulate, isVisible}) {
        this.label = label;
        this.fnChange = fnChange;
        this.fnPopulate = fnPopulate;
        this.isVisible = isVisible;
    },

    _tabs: {},
    _curTab: null,
    _tabsPreferredLabel: null,
    bindTabButtons({tabButtons, tabLabelReference, $wrpTabs, $pgContent}) {
        Renderer.utils._tabs = {};
        Renderer.utils._curTab = null;

        $wrpTabs.find(`.stat-tab-gen`).remove();

        tabButtons.forEach((tb,i)=>{
            tb.ix = i;

            tb.$t = $(`<button class="ui-tab__btn-tab-head btn btn-default stat-tab-gen">${tb.label}</button>`).click(()=>tb.fnActivateTab({
                isUserInput: true
            }));

            tb.fnActivateTab = ({isUserInput=false}={})=>{
                const curTab = Renderer.utils._curTab;
                const tabs = Renderer.utils._tabs;

                if (!curTab || curTab.label !== tb.label) {
                    if (curTab)
                        curTab.$t.removeClass(`ui-tab__btn-tab-head--active`);
                    Renderer.utils._curTab = tb;
                    tb.$t.addClass(`ui-tab__btn-tab-head--active`);
                    if (curTab)
                        tabs[curTab.label].$content = $pgContent.children().detach();

                    tabs[tb.label] = tb;
                    if (!tabs[tb.label].$content && tb.fnPopulate)
                        tb.fnPopulate();
                    else
                        $pgContent.append(tabs[tb.label].$content);
                    if (tb.fnChange)
                        tb.fnChange();
                }

                if (isUserInput)
                    Renderer.utils._tabsPreferredLabel = tb.label;
            }
            ;
        }
        );

        if (tabButtons.length !== 1)
            tabButtons.slice().reverse().forEach(tb=>$wrpTabs.prepend(tb.$t));

        if (!Renderer.utils._tabsPreferredLabel)
            return tabButtons[0].fnActivateTab();

        const tabButton = tabButtons.find(tb=>tb.label === Renderer.utils._tabsPreferredLabel);
        if (tabButton)
            return tabButton.fnActivateTab();

        const ixDesired = tabLabelReference.indexOf(Renderer.utils._tabsPreferredLabel);
        if (!~ixDesired)
            return tabButtons[0].fnActivateTab();
        const ixsAvailableMetas = tabButtons.map(tb=>{
            const ixMapped = tabLabelReference.indexOf(tb.label);
            if (!~ixMapped)
                return null;
            return {
                ixMapped,
                label: tb.label,
            };
        }
        ).filter(Boolean);
        if (!ixsAvailableMetas.length)
            return tabButtons[0].fnActivateTab();
        const ixMetaHigher = ixsAvailableMetas.find(({ixMapped})=>ixMapped > ixDesired);
        if (ixMetaHigher != null)
            return (tabButtons.find(it=>it.label === ixMetaHigher.label) || tabButtons[0]).fnActivateTab();

        const ixMetaMax = ixsAvailableMetas.last();
        (tabButtons.find(it=>it.label === ixMetaMax.label) || tabButtons[0]).fnActivateTab();
    },

    _pronounceButtonsBound: false,
    bindPronounceButtons() {
        if (Renderer.utils._pronounceButtonsBound)
            return;
        Renderer.utils._pronounceButtonsBound = true;
        $(`body`).on("click", ".btn-name-pronounce", function() {
            const audio = $(this).find(`.name-pronounce`)[0];
            audio.currentTime = 0;
            audio.play();
        });
    },

    async pHasFluffText(entity, prop) {
        return entity.hasFluff || ((await Renderer.utils.pGetPredefinedFluff(entity, prop))?.entries?.length || 0) > 0;
    },

    async pHasFluffImages(entity, prop) {
        return entity.hasFluffImages || (((await Renderer.utils.pGetPredefinedFluff(entity, prop))?.images?.length || 0) > 0);
    },

    async pGetPredefinedFluff(entry, prop) {
        if (!entry.fluff)
            return null;

        const mappedProp = `_${prop}`;
        const mappedPropAppend = `_append${prop.uppercaseFirst()}`;
        const fluff = {};

        const assignPropsIfExist = (fromObj,...props)=>{
            props.forEach(prop=>{
                if (fromObj[prop])
                    fluff[prop] = fromObj[prop];
            }
            );
        }
        ;

        assignPropsIfExist(entry.fluff, "name", "type", "entries", "images");

        if (entry.fluff[mappedProp]) {
            const fromList = [...((await PrereleaseUtil.pGetBrewProcessed())[prop] || []), ...((await BrewUtil2.pGetBrewProcessed())[prop] || []), ].find(it=>it.name === entry.fluff[mappedProp].name && it.source === entry.fluff[mappedProp].source, );
            if (fromList) {
                assignPropsIfExist(fromList, "name", "type", "entries", "images");
            }
        }

        if (entry.fluff[mappedPropAppend]) {
            const fromList = [...((await PrereleaseUtil.pGetBrewProcessed())[prop] || []), ...((await BrewUtil2.pGetBrewProcessed())[prop] || []), ].find(it=>it.name === entry.fluff[mappedPropAppend].name && it.source === entry.fluff[mappedPropAppend].source, );
            if (fromList) {
                if (fromList.entries) {
                    fluff.entries = MiscUtil.copyFast(fluff.entries || []);
                    fluff.entries.push(...MiscUtil.copyFast(fromList.entries));
                }
                if (fromList.images) {
                    fluff.images = MiscUtil.copyFast(fluff.images || []);
                    fluff.images.push(...MiscUtil.copyFast(fromList.images));
                }
            }
        }

        return fluff;
    },

    async pGetFluff({entity, pFnPostProcess, fnGetFluffData, fluffUrl, fluffBaseUrl, fluffProp}={}) {
        let predefinedFluff = await Renderer.utils.pGetPredefinedFluff(entity, fluffProp);
        if (predefinedFluff) {
            if (pFnPostProcess)
                predefinedFluff = await pFnPostProcess(predefinedFluff);
            return predefinedFluff;
        }
        if (!fnGetFluffData && !fluffBaseUrl && !fluffUrl)
            return null;

        const fluffIndex = fluffBaseUrl ? await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffBaseUrl}fluff-index.json`) : null;
        if (fluffIndex && !fluffIndex[entity.source])
            return null;

        const data = fnGetFluffData ? await fnGetFluffData() : fluffIndex && fluffIndex[entity.source] ? await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffBaseUrl}${fluffIndex[entity.source]}`) : await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffUrl}`);
        if (!data)
            return null;

        let fluff = (data[fluffProp] || []).find(it=>it.name === entity.name && it.source === entity.source);
        if (!fluff && entity._versionBase_name && entity._versionBase_source)
            fluff = (data[fluffProp] || []).find(it=>it.name === entity._versionBase_name && it.source === entity._versionBase_source);
        if (!fluff)
            return null;

        if (pFnPostProcess)
            fluff = await pFnPostProcess(fluff);
        return fluff;
    },

    _TITLE_SKIP_TYPES: new Set(["entries", "section"]),
    async pBuildFluffTab({isImageTab, $content, entity, $headerControls, pFnGetFluff}={}) {
        $content.append(Renderer.utils.getBorderTr());
        $content.append(Renderer.utils.getNameTr(entity, {
            controlRhs: $headerControls,
            asJquery: true
        }));
        const $td = $(`<td colspan="6" class="text"></td>`);
        $$`<tr class="text">${$td}</tr>`.appendTo($content);
        $content.append(Renderer.utils.getBorderTr());

        const fluff = MiscUtil.copyFast((await pFnGetFluff(entity)) || {});
        fluff.entries = fluff.entries || [Renderer.utils.HTML_NO_INFO];
        fluff.images = fluff.images || [Renderer.utils.HTML_NO_IMAGES];

        $td.fastSetHtml(Renderer.utils.getFluffTabContent({
            entity,
            fluff,
            isImageTab
        }));
    },

    getFluffTabContent({entity, fluff, isImageTab=false}) {
        Renderer.get().setFirstSection(true);
        return (fluff[isImageTab ? "images" : "entries"] || []).map((ent,i)=>{
            if (isImageTab)
                return Renderer.get().render(ent);

            if (i === 0 && ent.name && entity.name && (Renderer.utils._TITLE_SKIP_TYPES).has(ent.type)) {
                const entryLowName = ent.name.toLowerCase().trim();
                const entityLowName = entity.name.toLowerCase().trim();

                if (entryLowName.includes(entityLowName) || entityLowName.includes(entryLowName)) {
                    const cpy = MiscUtil.copyFast(ent);
                    delete cpy.name;
                    return Renderer.get().render(cpy);
                } else
                    return Renderer.get().render(ent);
            } else {
                if (typeof ent === "string")
                    return `<p>${Renderer.get().render(ent)}</p>`;
                else
                    return Renderer.get().render(ent);
            }
        }
        ).join("");
    },

    HTML_NO_INFO: "<i>No information available.</i>",
    HTML_NO_IMAGES: "<i>No images available.</i>",

    prerequisite: class {
        static _WEIGHTS = ["level", "pact", "patron", "spell", "race", "alignment", "ability", "proficiency", "spellcasting", "spellcasting2020", "spellcastingFeature", "spellcastingPrepared", "psionics", "feature", "feat", "background", "item", "itemType", "itemProperty", "campaign", "group", "other", "otherSummary", undefined, ].mergeMap((k,i)=>({
            [k]: i
        }));

        static _getShortClassName(className) {
            const ixFirstVowel = /[aeiou]/.exec(className).index;
            const start = className.slice(0, ixFirstVowel + 1);
            let end = className.slice(ixFirstVowel + 1);
            end = end.replace(/[aeiou]/g, "");
            return `${start}${end}`.toTitleCase();
        }

        static getHtml(prerequisites, {isListMode=false, blocklistKeys=new Set(), isTextOnly=false, isSkipPrefix=false}={}) {
            if (!prerequisites?.length)
                return isListMode ? "\u2014" : "";

            const prereqsShared = prerequisites.length === 1 ? {} : Object.entries(prerequisites.slice(1).reduce((a,b)=>CollectionUtil.objectIntersect(a, b), prerequisites[0]), ).filter(([k,v])=>prerequisites.every(pre=>CollectionUtil.deepEquals(pre[k], v))).mergeMap(([k,v])=>({
                [k]: v
            }));

            const shared = Object.keys(prereqsShared).length ? this.getHtml([prereqsShared], {
                isListMode,
                blocklistKeys,
                isTextOnly,
                isSkipPrefix: true
            }) : null;

            let cntPrerequisites = 0;
            let hasNote = false;
            const listOfChoices = prerequisites.map(pr=>{
                const ptNote = !isListMode && pr.note ? Renderer.get().render(pr.note) : null;
                if (ptNote) {
                    hasNote = true;
                }

                const prereqsToJoin = Object.entries(pr).filter(([k])=>!prereqsShared[k]).sort(([kA],[kB])=>this._WEIGHTS[kA] - this._WEIGHTS[kB]).map(([k,v])=>{
                    if (k === "note" || blocklistKeys.has(k))
                        return false;

                    cntPrerequisites += 1;

                    switch (k) {
                    case "level":
                        return this._getHtml_level({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "pact":
                        return this._getHtml_pact({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "patron":
                        return this._getHtml_patron({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spell":
                        return this._getHtml_spell({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "feat":
                        return this._getHtml_feat({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "feature":
                        return this._getHtml_feature({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "item":
                        return this._getHtml_item({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "itemType":
                        return this._getHtml_itemType({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "itemProperty":
                        return this._getHtml_itemProperty({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "otherSummary":
                        return this._getHtml_otherSummary({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "other":
                        return this._getHtml_other({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "race":
                        return this._getHtml_race({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "background":
                        return this._getHtml_background({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "ability":
                        return this._getHtml_ability({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "proficiency":
                        return this._getHtml_proficiency({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcasting":
                        return this._getHtml_spellcasting({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcasting2020":
                        return this._getHtml_spellcasting2020({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcastingFeature":
                        return this._getHtml_spellcastingFeature({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcastingPrepared":
                        return this._getHtml_spellcastingPrepared({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "psionics":
                        return this._getHtml_psionics({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "alignment":
                        return this._getHtml_alignment({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "campaign":
                        return this._getHtml_campaign({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "group":
                        return this._getHtml_group({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    default:
                        throw new Error(`Unhandled key: ${k}`);
                    }
                }
                ).filter(Boolean);

                const ptPrereqs = prereqsToJoin.join(prereqsToJoin.some(it=>/ or /.test(it)) ? "; " : ", ");

                return [ptPrereqs, ptNote].filter(Boolean).join(". ");
            }
            ).filter(Boolean);

            if (!listOfChoices.length && !shared)
                return isListMode ? "\u2014" : "";
            if (isListMode)
                return [shared, listOfChoices.join("/")].filter(Boolean).join(" + ");

            const sharedSuffix = MiscUtil.findCommonSuffix(listOfChoices, {
                isRespectWordBoundaries: true
            });
            const listOfChoicesTrimmed = sharedSuffix ? listOfChoices.map(it=>it.slice(0, -sharedSuffix.length)) : listOfChoices;

            const joinedChoices = (hasNote ? listOfChoicesTrimmed.join(" Or, ") : listOfChoicesTrimmed.joinConjunct(listOfChoicesTrimmed.some(it=>/ or /.test(it)) ? "; " : ", ", " or ")) + sharedSuffix;
            return `${isSkipPrefix ? "" : `Prerequisite${cntPrerequisites === 1 ? "" : "s"}: `}${[shared, joinedChoices].filter(Boolean).join(", plus ")}`;
        }

        static _getHtml_level({v, isListMode}) {
            if (typeof v === "number") {
                if (isListMode)
                    return `Lvl ${v}`;
                else
                    return `${Parser.getOrdinalForm(v)} level`;
            } else if (!v.class && !v.subclass) {
                if (isListMode)
                    return `Lvl ${v.level}`;
                else
                    return `${Parser.getOrdinalForm(v.level)} level`;
            }

            const isLevelVisible = v.level !== 1;
            const isSubclassVisible = v.subclass && v.subclass.visible;
            const isClassVisible = v.class && (v.class.visible || isSubclassVisible);
            if (isListMode) {
                const shortNameRaw = isClassVisible ? this._getShortClassName(v.class.name) : null;
                return `${isClassVisible ? `${shortNameRaw.slice(0, 4)}${isSubclassVisible ? "*" : "."}` : ""}${isLevelVisible ? ` Lvl ${v.level}` : ""}`;
            } else {
                let classPart = "";
                if (isClassVisible && isSubclassVisible)
                    classPart = ` ${v.class.name} (${v.subclass.name})`;
                else if (isClassVisible)
                    classPart = ` ${v.class.name}`;
                else if (isSubclassVisible)
                    classPart = ` &lt;remember to insert class name here&gt; (${v.subclass.name})`;
                return `${isLevelVisible ? `${Parser.getOrdinalForm(v.level)} level` : ""}${isClassVisible ? ` ${classPart}` : ""}`;
            }
        }

        static _getHtml_pact({v, isListMode}) {
            return Parser.prereqPactToFull(v);
        }

        static _getHtml_patron({v, isListMode}) {
            return isListMode ? `${Parser.prereqPatronToShort(v)} patron` : `${v} patron`;
        }

        static _getHtml_spell({v, isListMode, isTextOnly}) {
            return isListMode ? v.map(sp=>{
                if (typeof sp === "string")
                    return sp.split("#")[0].split("|")[0].toTitleCase();
                return sp.entrySummary || sp.entry;
            }
            ).join("/") : v.map(sp=>{
                if (typeof sp === "string")
                    return Parser.prereqSpellToFull(sp, {
                        isTextOnly
                    });
                return isTextOnly ? Renderer.stripTags(sp.entry) : Renderer.get().render(`{@filter ${sp.entry}|spells|${sp.choose}}`);
            }
            ).joinConjunct(", ", " or ");
        }

        static _getHtml_feat({v, isListMode, isTextOnly}) {
            return isListMode ? v.map(x=>x.split("|")[0].toTitleCase()).join("/") : v.map(it=>(isTextOnly ? Renderer.stripTags.bind(Renderer) : Renderer.get().render.bind(Renderer.get()))(`{@feat ${it}} feat`)).joinConjunct(", ", " or ");
        }

        static _getHtml_feature({v, isListMode, isTextOnly}) {
            return isListMode ? v.map(x=>Renderer.stripTags(x).toTitleCase()).join("/") : v.map(it=>isTextOnly ? Renderer.stripTags(it) : Renderer.get().render(it)).joinConjunct(", ", " or ");
        }

        static _getHtml_item({v, isListMode}) {
            return isListMode ? v.map(x=>x.toTitleCase()).join("/") : v.joinConjunct(", ", " or ");
        }

        static _getHtml_itemType({v, isListMode}) {
            return isListMode ? v.map(it=>Renderer.item.getType(it)).map(it=>it?.abbreviation).join("+") : v.map(it=>Renderer.item.getType(it)).map(it=>it?.name?.toTitleCase()).joinConjunct(", ", " and ");
        }

        static _getHtml_itemProperty({v, isListMode}) {
            if (v == null)
                return isListMode ? "No Prop." : "No Other Properties";

            return isListMode ? v.map(it=>Renderer.item.getProperty(it)).map(it=>it?.abbreviation).join("+") : (`${v.map(it=>Renderer.item.getProperty(it)).map(it=>it?.name?.toTitleCase()).joinConjunct(", ", " and ")} Property`);
        }

        static _getHtml_otherSummary({v, isListMode, isTextOnly}) {
            return isListMode ? (v.entrySummary || Renderer.stripTags(v.entry)) : (isTextOnly ? Renderer.stripTags(v.entry) : Renderer.get().render(v.entry));
        }

        static _getHtml_other({v, isListMode, isTextOnly}) {
            return isListMode ? "Special" : (isTextOnly ? Renderer.stripTags(v) : Renderer.get().render(v));
        }

        static _getHtml_race({v, isListMode, isTextOnly}) {
            const parts = v.map((it,i)=>{
                if (isListMode) {
                    return `${it.name.toTitleCase()}${it.subrace != null ? ` (${it.subrace})` : ""}`;
                } else {
                    const raceName = it.displayEntry ? (isTextOnly ? Renderer.stripTags(it.displayEntry) : Renderer.get().render(it.displayEntry)) : i === 0 ? it.name.toTitleCase() : it.name;
                    return `${raceName}${it.subrace != null ? ` (${it.subrace})` : ""}`;
                }
            }
            );
            return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
        }

        static _getHtml_background({v, isListMode, isTextOnly}) {
            const parts = v.map((it,i)=>{
                if (isListMode) {
                    return `${it.name.toTitleCase()}`;
                } else {
                    return it.displayEntry ? (isTextOnly ? Renderer.stripTags(it.displayEntry) : Renderer.get().render(it.displayEntry)) : i === 0 ? it.name.toTitleCase() : it.name;
                }
            }
            );
            return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
        }

        static _getHtml_ability({v, isListMode, isTextOnly}) {

            let hadMultipleInner = false;
            let hadMultiMultipleInner = false;
            let allValuesEqual = null;

            outer: for (const abMeta of v) {
                for (const req of Object.values(abMeta)) {
                    if (allValuesEqual == null)
                        allValuesEqual = req;
                    else {
                        if (req !== allValuesEqual) {
                            allValuesEqual = null;
                            break outer;
                        }
                    }
                }
            }

            const abilityOptions = v.map(abMeta=>{
                if (allValuesEqual) {
                    const abList = Object.keys(abMeta);
                    hadMultipleInner = hadMultipleInner || abList.length > 1;
                    return isListMode ? abList.map(ab=>ab.uppercaseFirst()).join(", ") : abList.map(ab=>Parser.attAbvToFull(ab)).joinConjunct(", ", " and ");
                } else {
                    const groups = {};

                    Object.entries(abMeta).forEach(([ab,req])=>{
                        (groups[req] = groups[req] || []).push(ab);
                    }
                    );

                    let isMulti = false;
                    const byScore = Object.entries(groups).sort(([reqA],[reqB])=>SortUtil.ascSort(Number(reqB), Number(reqA))).map(([req,abs])=>{
                        hadMultipleInner = hadMultipleInner || abs.length > 1;
                        if (abs.length > 1)
                            hadMultiMultipleInner = isMulti = true;

                        abs = abs.sort(SortUtil.ascSortAtts);
                        return isListMode ? `${abs.map(ab=>ab.uppercaseFirst()).join(", ")} ${req}+` : `${abs.map(ab=>Parser.attAbvToFull(ab)).joinConjunct(", ", " and ")} ${req} or higher`;
                    }
                    );

                    return isListMode ? `${isMulti || byScore.length > 1 ? "(" : ""}${byScore.join(" & ")}${isMulti || byScore.length > 1 ? ")" : ""}` : isMulti ? byScore.joinConjunct("; ", " and ") : byScore.joinConjunct(", ", " and ");
                }
            }
            );

            if (isListMode) {
                return `${abilityOptions.join("/")}${allValuesEqual != null ? ` ${allValuesEqual}+` : ""}`;
            } else {
                const isComplex = hadMultiMultipleInner || hadMultipleInner || allValuesEqual == null;
                const joined = abilityOptions.joinConjunct(hadMultiMultipleInner ? " - " : hadMultipleInner ? "; " : ", ", isComplex ? (isTextOnly ? ` /or/ ` : ` <i>or</i> `) : " or ", );
                return `${joined}${allValuesEqual != null ? ` ${allValuesEqual} or higher` : ""}`;
            }
        }

        static _getHtml_proficiency({v, isListMode}) {
            const parts = v.map(obj=>{
                return Object.entries(obj).map(([profType,prof])=>{
                    switch (profType) {
                    case "armor":
                        {
                            return isListMode ? `Prof ${Parser.armorFullToAbv(prof)} armor` : `Proficiency with ${prof} armor`;
                        }
                    case "weapon":
                        {
                            return isListMode ? `Prof ${Parser.weaponFullToAbv(prof)} weapon` : `Proficiency with a ${prof} weapon`;
                        }
                    case "weaponGroup":
                        {
                            return isListMode ? `Prof ${Parser.weaponFullToAbv(prof)} weapons` : `${prof.toTitleCase()} Proficiency`;
                        }
                    default:
                        throw new Error(`Unhandled proficiency type: "${profType}"`);
                    }
                }
                );
            }
            );
            return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
        }

        static _getHtml_spellcasting({v, isListMode}) {
            return isListMode ? "Spellcasting" : "The ability to cast at least one spell";
        }

        static _getHtml_spellcasting2020({v, isListMode}) {
            return isListMode ? "Spellcasting" : "Spellcasting or Pact Magic feature";
        }

        static _getHtml_spellcastingFeature({v, isListMode}) {
            return isListMode ? "Spellcasting" : "Spellcasting Feature";
        }

        static _getHtml_spellcastingPrepared({v, isListMode}) {
            return isListMode ? "Spellcasting" : "Spellcasting feature from a class that prepares spells";
        }

        static _getHtml_psionics({v, isListMode, isTextOnly}) {
            return isListMode ? "Psionics" : (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))("Psionic Talent feature or Wild Talent feat");
        }

        static _getHtml_alignment({v, isListMode}) {
            return isListMode ? Parser.alignmentListToFull(v).replace(/\bany\b/gi, "").trim().replace(/\balignment\b/gi, "align").trim().toTitleCase() : Parser.alignmentListToFull(v);
        }

        static _getHtml_campaign({v, isListMode}) {
            return isListMode ? v.join("/") : `${v.joinConjunct(", ", " or ")} Campaign`;
        }

        static _getHtml_group({v, isListMode}) {
            return isListMode ? v.map(it=>it.toTitleCase()).join("/") : `${v.map(it=>it.toTitleCase()).joinConjunct(", ", " or ")} Group`;
        }
    }, 

    getRepeatableEntry(ent) {
        if (!ent.repeatable)
            return null;
        return `{@b Repeatable:} ${ent.repeatableNote || (ent.repeatable ? "Yes" : "No")}`;
    },

    getRepeatableHtml(ent, {isListMode=false}={}) {
        const entryRepeatable = Renderer.utils.getRepeatableEntry(ent);
        if (entryRepeatable == null)
            return isListMode ? "\u2014" : "";
        return Renderer.get().render(entryRepeatable);
    },

    getRenderedSize(size) {
        return [...(size ? [size].flat() : [])].sort(SortUtil.ascSortSize).map(sz=>Parser.sizeAbvToFull(sz)).joinConjunct(", ", " or ");
    },

    getMediaUrl(entry, prop, mediaDir) {
        if (!entry[prop])
            return "";

        let href = "";
        if (entry[prop].type === "internal") {
            const baseUrl = Renderer.get().baseMediaUrls[mediaDir] || Renderer.get().baseUrl;
            const mediaPart = `${mediaDir}/${entry[prop].path}`;
            href = baseUrl !== "" ? `${baseUrl}${mediaPart}` : UrlUtil.link(mediaPart);
        } else if (entry[prop].type === "external") {
            href = entry[prop].url;
        }
        return href;
    },

    getTagEntry(tag, text) {
        switch (tag) {
        case "@dice":
        case "@autodice":
        case "@damage":
        case "@hit":
        case "@d20":
        case "@chance":
        case "@recharge":
            {
                const fauxEntry = {
                    type: "dice",
                    rollable: true,
                };
                const [rollText,displayText,name,...others] = Renderer.splitTagByPipe(text);
                if (displayText)
                    fauxEntry.displayText = displayText;

                if ((!fauxEntry.displayText && (rollText || "").includes("summonSpellLevel")) || (fauxEntry.displayText && fauxEntry.displayText.includes("summonSpellLevel")))
                    fauxEntry.displayText = (fauxEntry.displayText || rollText || "").replace(/summonSpellLevel/g, "the spell's level");

                if ((!fauxEntry.displayText && (rollText || "").includes("summonClassLevel")) || (fauxEntry.displayText && fauxEntry.displayText.includes("summonClassLevel")))
                    fauxEntry.displayText = (fauxEntry.displayText || rollText || "").replace(/summonClassLevel/g, "your class level");

                if (name)
                    fauxEntry.name = name;

                switch (tag) {
                case "@dice":
                case "@autodice":
                case "@damage":
                    {
                        fauxEntry.toRoll = rollText;

                        if (!fauxEntry.displayText && (rollText || "").includes(";"))
                            fauxEntry.displayText = rollText.replace(/;/g, "/");
                        if ((!fauxEntry.displayText && (rollText || "").includes("#$")) || (fauxEntry.displayText && fauxEntry.displayText.includes("#$")))
                            fauxEntry.displayText = (fauxEntry.displayText || rollText).replace(/#\$prompt_number[^$]*\$#/g, "(n)");
                        fauxEntry.displayText = fauxEntry.displayText || fauxEntry.toRoll;

                        if (tag === "@damage")
                            fauxEntry.subType = "damage";
                        if (tag === "@autodice")
                            fauxEntry.autoRoll = true;

                        return fauxEntry;
                    }
                case "@d20":
                case "@hit":
                    {
                        let mod;
                        if (!isNaN(rollText)) {
                            const n = Number(rollText);
                            mod = `${n >= 0 ? "+" : ""}${n}`;
                        } else
                            mod = /^\s+[-+]/.test(rollText) ? rollText : `+${rollText}`;
                        fauxEntry.displayText = fauxEntry.displayText || mod;
                        fauxEntry.toRoll = `1d20${mod}`;
                        fauxEntry.subType = "d20";
                        fauxEntry.d20mod = mod;
                        if (tag === "@hit")
                            fauxEntry.context = {
                                type: "hit"
                            };
                        return fauxEntry;
                    }
                case "@chance":
                    {
                        const [textSuccess,textFailure] = others;
                        fauxEntry.toRoll = `1d100`;
                        fauxEntry.successThresh = Number(rollText);
                        fauxEntry.chanceSuccessText = textSuccess;
                        fauxEntry.chanceFailureText = textFailure;
                        return fauxEntry;
                    }
                case "@recharge":
                    {
                        const flags = displayText ? displayText.split("") : null;
                        fauxEntry.toRoll = "1d6";
                        const asNum = Number(rollText || 6);
                        fauxEntry.successThresh = 7 - asNum;
                        fauxEntry.successMax = 6;
                        fauxEntry.displayText = `${asNum}${asNum < 6 ? `\u20136` : ""}`;
                        fauxEntry.chanceSuccessText = "Recharged!";
                        fauxEntry.chanceFailureText = "Did not recharge";
                        fauxEntry.isColorSuccessFail = true;
                        return fauxEntry;
                    }
                }

                return fauxEntry;
            }

        case "@ability":
        case "@savingThrow":
            {
                const fauxEntry = {
                    type: "dice",
                    rollable: true,
                    subType: "d20",
                    context: {
                        type: tag === "@ability" ? "abilityCheck" : "savingThrow"
                    },
                };

                const [abilAndScoreOrScore,displayText,name,...others] = Renderer.splitTagByPipe(text);

                let[abil,...rawScoreOrModParts] = abilAndScoreOrScore.split(" ").map(it=>it.trim()).filter(Boolean);
                abil = abil.toLowerCase();

                fauxEntry.context.ability = abil;

                if (name)
                    fauxEntry.name = name;
                else {
                    if (tag === "@ability")
                        fauxEntry.name = Parser.attAbvToFull(abil);
                    else if (tag === "@savingThrow")
                        fauxEntry.name = `${Parser.attAbvToFull(abil)} save`;
                }

                const rawScoreOrMod = rawScoreOrModParts.join(" ");
                if (isNaN(rawScoreOrMod) && tag === "@savingThrow") {
                    if (displayText)
                        fauxEntry.displayText = displayText;
                    else
                        fauxEntry.displayText = rawScoreOrMod;

                    fauxEntry.toRoll = `1d20${rawScoreOrMod}`;
                    fauxEntry.d20mod = rawScoreOrMod;
                } else {
                    const scoreOrMod = Number(rawScoreOrMod) || 0;
                    const mod = (tag === "@ability" ? Parser.getAbilityModifier : UiUtil.intToBonus)(scoreOrMod);

                    if (displayText)
                        fauxEntry.displayText = displayText;
                    else {
                        if (tag === "@ability")
                            fauxEntry.displayText = `${scoreOrMod} (${mod})`;
                        else
                            fauxEntry.displayText = mod;
                    }

                    fauxEntry.toRoll = `1d20${mod}`;
                    fauxEntry.d20mod = mod;
                }

                return fauxEntry;
            }

        case "@skillCheck":
            {
                const fauxEntry = {
                    type: "dice",
                    rollable: true,
                    subType: "d20",
                    context: {
                        type: "skillCheck"
                    },
                };

                const [skillAndMod,displayText,name,...others] = Renderer.splitTagByPipe(text);

                const parts = skillAndMod.split(" ").map(it=>it.trim()).filter(Boolean);
                const namePart = parts.shift();
                const bonusPart = parts.join(" ");
                const skill = namePart.replace(/_/g, " ");

                let mod = bonusPart;
                if (!isNaN(bonusPart))
                    mod = UiUtil.intToBonus(Number(bonusPart) || 0);
                else if (bonusPart.startsWith("#$"))
                    mod = `+${bonusPart}`;

                fauxEntry.context.skill = skill;
                fauxEntry.displayText = displayText || mod;

                if (name)
                    fauxEntry.name = name;
                else
                    fauxEntry.name = skill.toTitleCase();

                fauxEntry.toRoll = `1d20${mod}`;
                fauxEntry.d20mod = mod;

                return fauxEntry;
            }

        case "@coinflip":
            {
                const [displayText,name,textSuccess,textFailure] = Renderer.splitTagByPipe(text);

                const fauxEntry = {
                    type: "dice",
                    toRoll: "1d2",
                    successThresh: 1,
                    successMax: 2,
                    displayText: displayText || "flip a coin",
                    chanceSuccessText: textSuccess || `Heads`,
                    chanceFailureText: textFailure || `Tails`,
                    isColorSuccessFail: !textSuccess && !textFailure,
                    rollable: true,
                };

                return fauxEntry;
            }

        default:
            throw new Error(`Unhandled tag "${tag}"`);
        }
    },

    getTagMeta(tag, text) {
        switch (tag) {
        case "@deity":
            {
                let[name,pantheon,source,displayText,...others] = Renderer.splitTagByPipe(text);
                pantheon = pantheon || "forgotten realms";
                source = source || Parser.getTagSource(tag, source);
                const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES]({
                    name,
                    pantheon,
                    source
                });

                return {
                    name,
                    displayText,
                    others,

                    page: UrlUtil.PG_DEITIES,
                    source,
                    hash,

                    hashPreEncoded: true,
                };
            }

        case "@card":
            {
                const unpacked = DataUtil.deck.unpackUidCard(text);
                const {name, set, source, displayText} = unpacked;
                const hash = UrlUtil.URL_TO_HASH_BUILDER["card"]({
                    name,
                    set,
                    source
                });

                return {
                    name,
                    displayText,

                    isFauxPage: true,
                    page: "card",
                    source,
                    hash,
                    hashPreEncoded: true,
                };
            }

        case "@classFeature":
            {
                const unpacked = DataUtil.class.unpackUidClassFeature(text);

                const classPageHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
                    name: unpacked.className,
                    source: unpacked.classSource
                })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                    feature: {
                        ixLevel: unpacked.level - 1,
                        ixFeature: 0
                    }
                })}`;

                return {
                    name: unpacked.name,
                    displayText: unpacked.displayText,

                    page: UrlUtil.PG_CLASSES,
                    source: unpacked.source,
                    hash: classPageHash,
                    hashPreEncoded: true,

                    pageHover: "classfeature",
                    hashHover: UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked),
                    hashPreEncodedHover: true,
                };
            }

        case "@subclassFeature":
            {
                const unpacked = DataUtil.class.unpackUidSubclassFeature(text);

                const classPageHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
                    name: unpacked.className,
                    source: unpacked.classSource
                })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                    feature: {
                        ixLevel: unpacked.level - 1,
                        ixFeature: 0
                    }
                })}`;

                return {
                    name: unpacked.name,
                    displayText: unpacked.displayText,

                    page: UrlUtil.PG_CLASSES,
                    source: unpacked.source,
                    hash: classPageHash,
                    hashPreEncoded: true,

                    pageHover: "subclassfeature",
                    hashHover: UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked),
                    hashPreEncodedHover: true,
                };
            }

        case "@quickref":
            {
                const unpacked = DataUtil.quickreference.unpackUid(text);

                const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_QUICKREF](unpacked);

                return {
                    name: unpacked.name,
                    displayText: unpacked.displayText,

                    page: UrlUtil.PG_QUICKREF,
                    source: unpacked.source,
                    hash,
                    hashPreEncoded: true,
                };
            }

        default:
            return Renderer.utils._getTagMeta_generic(tag, text);
        }
    },

    _getTagMeta_generic(tag, text) {
        const {name, source, displayText, others} = DataUtil.generic.unpackUid(text, tag);
        const hash = UrlUtil.encodeForHash([name, source]);

        const out = {
            name,
            displayText,
            others,

            page: null,
            source,
            hash,

            preloadId: null,
            subhashes: null,
            linkText: null,

            hashPreEncoded: true,
        };

        switch (tag) {
        case "@spell":
            out.page = UrlUtil.PG_SPELLS;
            break;
        case "@item":
            out.page = UrlUtil.PG_ITEMS;
            break;
        case "@condition":
        case "@disease":
        case "@status":
            out.page = UrlUtil.PG_CONDITIONS_DISEASES;
            break;
        case "@background":
            out.page = UrlUtil.PG_BACKGROUNDS;
            break;
        case "@race":
            out.page = UrlUtil.PG_RACES;
            break;
        case "@optfeature":
            out.page = UrlUtil.PG_OPT_FEATURES;
            break;
        case "@reward":
            out.page = UrlUtil.PG_REWARDS;
            break;
        case "@feat":
            out.page = UrlUtil.PG_FEATS;
            break;
        case "@psionic":
            out.page = UrlUtil.PG_PSIONICS;
            break;
        case "@object":
            out.page = UrlUtil.PG_OBJECTS;
            break;
        case "@boon":
        case "@cult":
            out.page = UrlUtil.PG_CULTS_BOONS;
            break;
        case "@trap":
        case "@hazard":
            out.page = UrlUtil.PG_TRAPS_HAZARDS;
            break;
        case "@variantrule":
            out.page = UrlUtil.PG_VARIANTRULES;
            break;
        case "@table":
            out.page = UrlUtil.PG_TABLES;
            break;
        case "@vehicle":
        case "@vehupgrade":
            out.page = UrlUtil.PG_VEHICLES;
            break;
        case "@action":
            out.page = UrlUtil.PG_ACTIONS;
            break;
        case "@language":
            out.page = UrlUtil.PG_LANGUAGES;
            break;
        case "@charoption":
            out.page = UrlUtil.PG_CHAR_CREATION_OPTIONS;
            break;
        case "@recipe":
            out.page = UrlUtil.PG_RECIPES;
            break;
        case "@deck":
            out.page = UrlUtil.PG_DECKS;
            break;

        case "@legroup":
            {
                out.page = "legendaryGroup";
                out.isFauxPage = true;
                break;
            }

        case "@creature":
            {
                out.page = UrlUtil.PG_BESTIARY;

                if (others.length) {
                    const [type,value] = others[0].split("=").map(it=>it.trim().toLowerCase()).filter(Boolean);
                    if (type && value) {
                        switch (type) {
                        case VeCt.HASH_SCALED:
                            {
                                const targetCrNum = Parser.crToNumber(value);
                                out.preloadId = Renderer.monster.getCustomHashId({
                                    name,
                                    source,
                                    _isScaledCr: true,
                                    _scaledCr: targetCrNum
                                });
                                out.subhashes = [{
                                    key: VeCt.HASH_SCALED,
                                    value: targetCrNum
                                }, ];
                                out.linkText = displayText || `${name} (CR ${value})`;
                                break;
                            }

                        case VeCt.HASH_SCALED_SPELL_SUMMON:
                            {
                                const scaledSpellNum = Number(value);
                                out.preloadId = Renderer.monster.getCustomHashId({
                                    name,
                                    source,
                                    _isScaledSpellSummon: true,
                                    _scaledSpellSummonLevel: scaledSpellNum
                                });
                                out.subhashes = [{
                                    key: VeCt.HASH_SCALED_SPELL_SUMMON,
                                    value: scaledSpellNum
                                }, ];
                                out.linkText = displayText || `${name} (Spell Level ${value})`;
                                break;
                            }

                        case VeCt.HASH_SCALED_CLASS_SUMMON:
                            {
                                const scaledClassNum = Number(value);
                                out.preloadId = Renderer.monster.getCustomHashId({
                                    name,
                                    source,
                                    _isScaledClassSummon: true,
                                    _scaledClassSummonLevel: scaledClassNum
                                });
                                out.subhashes = [{
                                    key: VeCt.HASH_SCALED_CLASS_SUMMON,
                                    value: scaledClassNum
                                }, ];
                                out.linkText = displayText || `${name} (Class Level ${value})`;
                                break;
                            }
                        }
                    }
                }

                break;
            }

        case "@class":
            {
                out.page = UrlUtil.PG_CLASSES;

                if (others.length) {
                    const [subclassShortName,subclassSource,featurePart] = others;

                    if (subclassSource)
                        out.source = subclassSource;

                    const classStateOpts = {
                        subclass: {
                            shortName: subclassShortName.trim(),
                            source: subclassSource ? subclassSource.trim() : Parser.SRC_PHB,
                        },
                    };

                    const hoverSubhashObj = UrlUtil.unpackSubHash(UrlUtil.getClassesPageStatePart(classStateOpts));
                    out.subhashesHover = [{
                        key: "state",
                        value: hoverSubhashObj.state,
                        preEncoded: true
                    }];

                    if (featurePart) {
                        const featureParts = featurePart.trim().split("-");
                        classStateOpts.feature = {
                            ixLevel: featureParts[0] || "0",
                            ixFeature: featureParts[1] || "0",
                        };
                    }

                    const subhashObj = UrlUtil.unpackSubHash(UrlUtil.getClassesPageStatePart(classStateOpts));

                    out.subhashes = [{
                        key: "state",
                        value: subhashObj.state.join(HASH_SUB_LIST_SEP),
                        preEncoded: true
                    }, {
                        key: "fltsource",
                        value: "clear"
                    }, {
                        key: "flstmiscellaneous",
                        value: "clear"
                    }, ];
                }

                break;
            }

        case "@skill":
            {
                out.isFauxPage = true;
                out.page = "skill";
                break;
            }
        case "@sense":
            {
                out.isFauxPage = true;
                out.page = "sense";
                break;
            }
        case "@itemMastery":
            {
                out.isFauxPage = true;
                out.page = "itemMastery";
                break;
            }
        case "@cite":
            {
                out.isFauxPage = true;
                out.page = "citation";
                break;
            }

        default:
            throw new Error(`Unhandled tag "${tag}"`);
        }

        return out;
    },

    applyTemplate(ent, templateString, {fnPreApply, mapCustom}={}) {
        return templateString.replace(/{{([^}]+)}}/g, (fullMatch,strArgs)=>{
            if (fnPreApply)
                fnPreApply(fullMatch, strArgs);

            if (strArgs === "item.dmg1") {
                return Renderer.item._getTaggedDamage(ent.dmg1);
            } else if (strArgs === "item.dmg2") {
                return Renderer.item._getTaggedDamage(ent.dmg2);
            }

            if (mapCustom && mapCustom[strArgs])
                return mapCustom[strArgs];

            const args = strArgs.split(" ").map(arg=>arg.trim()).filter(Boolean);

            if (args.length === 1) {
                return Renderer.utils._applyTemplate_getValue(ent, args[0]);
            } else if (args.length === 2) {
                const val = Renderer.utils._applyTemplate_getValue(ent, args[1]);
                switch (args[0]) {
                case "getFullImmRes":
                    return Parser.getFullImmRes(val);
                default:
                    throw new Error(`Unknown template function "${args[0]}"`);
                }
            } else
                throw new Error(`Unhandled number of arguments ${args.length}`);
        }
        );
    },

    _applyTemplate_getValue(ent, prop) {
        const spl = prop.split(".");
        switch (spl[0]) {
        case "item":
            {
                const path = spl.slice(1);
                if (!path.length)
                    return `{@i missing key path}`;
                return MiscUtil.get(ent, ...path);
            }
        default:
            return `{@i unknown template root: "${spl[0]}"}`;
        }
    },

    getFlatEntries(entry) {
        const out = [];
        const depthStack = [];

        const recurse = ({obj})=>{
            let isPopDepth = false;

            Renderer.ENTRIES_WITH_ENUMERATED_TITLES.forEach(meta=>{
                if (obj.type !== meta.type)
                    return;

                const kName = "name";
                if (obj[kName] == null)
                    return;

                isPopDepth = true;

                const curDepth = depthStack.length ? depthStack.last() : 0;
                const nxtDepth = meta.depth ? meta.depth : meta.depthIncrement ? curDepth + meta.depthIncrement : curDepth;

                depthStack.push(Math.min(nxtDepth, 2, ), );

                const cpyObj = MiscUtil.copyFast(obj);

                out.push({
                    depth: curDepth,
                    entry: cpyObj,
                    key: meta.key,
                    ix: out.length,
                    name: cpyObj.name,
                });

                cpyObj[meta.key] = cpyObj[meta.key].map(child=>{
                    if (!child.type)
                        return child;
                    const childMeta = Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[child.type];
                    if (!childMeta)
                        return child;

                    const kNameChild = "name";
                    if (child[kName] == null)
                        return child;

                    const ixNextRef = out.length;

                    recurse({
                        obj: child
                    });

                    return {
                        IX_FLAT_REF: ixNextRef
                    };
                }
                );
            }
            );

            if (isPopDepth)
                depthStack.pop();
        }
        ;

        recurse({
            obj: entry
        });

        return out;
    },

    getLinkSubhashString(subhashes) {
        let out = "";
        const len = subhashes.length;
        for (let i = 0; i < len; ++i) {
            const subHash = subhashes[i];
            if (subHash.preEncoded)
                out += `${HASH_PART_SEP}${subHash.key}${HASH_SUB_KV_SEP}`;
            else
                out += `${HASH_PART_SEP}${UrlUtil.encodeForHash(subHash.key)}${HASH_SUB_KV_SEP}`;
            if (subHash.value != null) {
                if (subHash.preEncoded)
                    out += subHash.value;
                else
                    out += UrlUtil.encodeForHash(subHash.value);
            } else {
                out += subHash.values.map(v=>UrlUtil.encodeForHash(v)).join(HASH_SUB_LIST_SEP);
            }
        }
        return out;
    },

    initFullEntries_(ent, {propEntries="entries", propFullEntries="_fullEntries"}={}) {
        ent[propFullEntries] = ent[propFullEntries] || (ent[propEntries] ? MiscUtil.copyFast(ent[propEntries]) : []);
    },

    lazy: {
        _getIntersectionConfig() {
            return {
                rootMargin: "150px 0px",
                threshold: 0.01,
            };
        },

        _OBSERVERS: {},
        getCreateObserver({observerId, fnOnObserve}) {
            if (!Renderer.utils.lazy._OBSERVERS[observerId]) {
                const observer = Renderer.utils.lazy._OBSERVERS[observerId] = new IntersectionObserver(Renderer.utils.lazy.getFnOnIntersect({
                    observerId,
                    fnOnObserve,
                }),Renderer.utils.lazy._getIntersectionConfig(),);

                observer._TRACKED = new Set();

                observer.track = it=>{
                    observer._TRACKED.add(it);
                    return observer.observe(it);
                }
                ;

                observer.untrack = it=>{
                    observer._TRACKED.delete(it);
                    return observer.unobserve(it);
                }
                ;

                observer._printListener = evt=>{
                    if (!observer._TRACKED.size)
                        return;

                    [...observer._TRACKED].forEach(it=>{
                        observer.untrack(it);
                        fnOnObserve({
                            observer,
                            entry: {
                                target: it,
                            },
                        });
                    }
                    );

                    alert(`All content must be loaded prior to printing. Please cancel the print and wait a few moments for loading to complete!`);
                }
                ;
                window.addEventListener("beforeprint", observer._printListener);
            }
            return Renderer.utils.lazy._OBSERVERS[observerId];
        },

        destroyObserver({observerId}) {
            const observer = Renderer.utils.lazy._OBSERVERS[observerId];
            if (!observer)
                return;

            observer.disconnect();
            window.removeEventListener("beforeprint", observer._printListener);
        },

        getFnOnIntersect({observerId, fnOnObserve}) {
            return obsEntries=>{
                const observer = Renderer.utils.lazy._OBSERVERS[observerId];

                obsEntries.forEach(entry=>{
                    if (entry.intersectionRatio <= 0)
                        return;

                    observer.untrack(entry.target);
                    fnOnObserve({
                        observer,
                        entry,
                    });
                }
                );
            }
            ;
        },
    },
};

Renderer.tag = class {
    static _TagBase = class {
        tagName;
        defaultSource = null;
        page = null;

        get tag() {
            return `@${this.tagName}`;
        }

        getStripped(tag, text) {
            text = text.replace(/<\$([^$]+)\$>/gi, "");
            return this._getStripped(tag, text);
        }

        _getStripped(tag, text) {
            throw new Error("Unimplemented!");
        }

        getMeta(tag, text) {
            return this._getMeta(tag, text);
        }
        _getMeta(tag, text) {
            throw new Error("Unimplemented!");
        }
    }
    ;

    static _TagBaseAt = class extends this._TagBase {
        get tag() {
            return `@${this.tagName}`;
        }
    }
    ;

    static _TagBaseHash = class extends this._TagBase {
        get tag() {
            return `#${this.tagName}`;
        }
    }
    ;

    static _TagTextStyle = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            return text;
        }
    }
    ;

    static TagBoldShort = class extends this._TagTextStyle {
        tagName = "b";
    }
    ;

    static TagBoldLong = class extends this._TagTextStyle {
        tagName = "bold";
    }
    ;

    static TagItalicShort = class extends this._TagTextStyle {
        tagName = "i";
    }
    ;

    static TagItalicLong = class extends this._TagTextStyle {
        tagName = "italic";
    }
    ;

    static TagStrikethroughShort = class extends this._TagTextStyle {
        tagName = "s";
    }
    ;

    static TagStrikethroughLong = class extends this._TagTextStyle {
        tagName = "strike";
    }
    ;

    static TagUnderlineShort = class extends this._TagTextStyle {
        tagName = "u";
    }
    ;

    static TagUnderlineLong = class extends this._TagTextStyle {
        tagName = "underline";
    }
    ;

    static TagSup = class extends this._TagTextStyle {
        tagName = "sup";
    }
    ;

    static TagSub = class extends this._TagTextStyle {
        tagName = "sub";
    }
    ;

    static TagKbd = class extends this._TagTextStyle {
        tagName = "kbd";
    }
    ;

    static TagCode = class extends this._TagTextStyle {
        tagName = "code";
    }
    ;

    static TagStyle = class extends this._TagTextStyle {
        tagName = "style";
    }
    ;

    static TagFont = class extends this._TagTextStyle {
        tagName = "font";
    }
    ;

    static TagComic = class extends this._TagTextStyle {
        tagName = "comic";
    }
    ;

    static TagComicH1 = class extends this._TagTextStyle {
        tagName = "comicH1";
    }
    ;

    static TagComicH2 = class extends this._TagTextStyle {
        tagName = "comicH2";
    }
    ;

    static TagComicH3 = class extends this._TagTextStyle {
        tagName = "comicH3";
    }
    ;

    static TagComicH4 = class extends this._TagTextStyle {
        tagName = "comicH4";
    }
    ;

    static TagComicNote = class extends this._TagTextStyle {
        tagName = "comicNote";
    }
    ;

    static TagNote = class extends this._TagTextStyle {
        tagName = "note";
    }
    ;

    static TagTip = class extends this._TagTextStyle {
        tagName = "tip";
    }
    ;

    static TagUnit = class extends this._TagBaseAt {
        tagName = "unit";

        _getStripped(tag, text) {
            const [amount,unitSingle,unitPlural] = Renderer.splitTagByPipe(text);
            return isNaN(amount) ? unitSingle : Number(amount) > 1 ? (unitPlural || unitSingle.toPlural()) : unitSingle;
        }
    }
    ;

    static TagHit = class extends this._TagBaseAt {
        tagName = "h";

        _getStripped(tag, text) {
            return "Hit: ";
        }
    }
    ;

    static TagMiss = class extends this._TagBaseAt {
        tagName = "m";

        _getStripped(tag, text) {
            return "Miss: ";
        }
    }
    ;

    static TagAtk = class extends this._TagBaseAt {
        tagName = "atk";

        _getStripped(tag, text) {
            return Renderer.attackTagToFull(text);
        }
    }
    ;

    static TagHitYourSpellAttack = class extends this._TagBaseAt {
        tagName = "hitYourSpellAttack";

        _getStripped(tag, text) {
            const [displayText] = Renderer.splitTagByPipe(text);
            return displayText || "your spell attack modifier";
        }
    }
    ;

    static TagDc = class extends this._TagBaseAt {
        tagName = "dc";

        _getStripped(tag, text) {
            const [dcText,displayText] = Renderer.splitTagByPipe(text);
            return `DC ${displayText || dcText}`;
        }
    }
    ;

    static TagDcYourSpellSave = class extends this._TagBaseAt {
        tagName = "dcYourSpellSave";

        _getStripped(tag, text) {
            const [displayText] = Renderer.splitTagByPipe(text);
            return displayText || "your spell save DC";
        }
    }
    ;

    static _TagDiceFlavor = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const [rollText,displayText] = Renderer.splitTagByPipe(text);
            switch (tag) {
            case "@damage":
            case "@dice":
            case "@autodice":
                {
                    return displayText || rollText.replace(/;/g, "/");
                }
            case "@d20":
            case "@hit":
                {
                    return displayText || (()=>{
                        const n = Number(rollText);
                        if (!isNaN(n))
                            return `${n >= 0 ? "+" : ""}${n}`;
                        return rollText;
                    }
                    )();
                }
            case "@recharge":
                {
                    const asNum = Number(rollText || 6);
                    if (isNaN(asNum)) {
                        throw new Error(`Could not parse "${rollText}" as a number!`);
                    }
                    return `(Recharge ${asNum}${asNum < 6 ? `\u20136` : ""})`;
                }
            case "@chance":
                {
                    return displayText || `${rollText} percent`;
                }
            case "@ability":
                {
                    const [,rawScore] = rollText.split(" ").map(it=>it.trim().toLowerCase()).filter(Boolean);
                    const score = Number(rawScore) || 0;
                    return displayText || `${score} (${Parser.getAbilityModifier(score)})`;
                }
            case "@savingThrow":
            case "@skillCheck":
                {
                    return displayText || rollText;
                }
            }
            throw new Error(`Unhandled tag: ${tag}`);
        }
    }
    ;

    static TaChance = class extends this._TagDiceFlavor {
        tagName = "chance";
    }
    ;

    static TaD20 = class extends this._TagDiceFlavor {
        tagName = "d20";
    }
    ;

    static TaDamage = class extends this._TagDiceFlavor {
        tagName = "damage";
    }
    ;

    static TaDice = class extends this._TagDiceFlavor {
        tagName = "dice";
    }
    ;

    static TaAutodice = class extends this._TagDiceFlavor {
        tagName = "autodice";
    }
    ;

    static TaHit = class extends this._TagDiceFlavor {
        tagName = "hit";
    }
    ;

    static TaRecharge = class extends this._TagDiceFlavor {
        tagName = "recharge";
    }
    ;

    static TaAbility = class extends this._TagDiceFlavor {
        tagName = "ability";
    }
    ;

    static TaSavingThrow = class extends this._TagDiceFlavor {
        tagName = "savingThrow";
    }
    ;

    static TaSkillCheck = class extends this._TagDiceFlavor {
        tagName = "skillCheck";
    }
    ;

    static _TagDiceFlavorScaling = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const [,,addPerProgress,,displayText] = Renderer.splitTagByPipe(text);
            return displayText || addPerProgress;
        }
    }
    ;

    static TagScaledice = class extends this._TagDiceFlavorScaling {
        tagName = "scaledice";
    }
    ;

    static TagScaledamage = class extends this._TagDiceFlavorScaling {
        tagName = "scaledamage";
    }
    ;

    static TagCoinflip = class extends this._TagBaseAt {
        tagName = "coinflip";

        _getStripped(tag, text) {
            const [displayText] = Renderer.splitTagByPipe(text);
            return displayText || "flip a coin";
        }
    }
    ;

    static _TagPipedNoDisplayText = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts[0];
        }
    }
    ;

    static Tag5etools = class extends this._TagPipedNoDisplayText {
        tagName = "5etools";
    }
    ;

    static TagAdventure = class extends this._TagPipedNoDisplayText {
        tagName = "adventure";
    }
    ;

    static TagBook = class extends this._TagPipedNoDisplayText {
        tagName = "book";
    }
    ;

    static TagFilter = class extends this._TagPipedNoDisplayText {
        tagName = "filter";
    }
    ;

    static TagFootnote = class extends this._TagPipedNoDisplayText {
        tagName = "footnote";
    }
    ;

    static TagLink = class extends this._TagPipedNoDisplayText {
        tagName = "link";
    }
    ;

    static TagLoader = class extends this._TagPipedNoDisplayText {
        tagName = "loader";
    }
    ;

    static TagColor = class extends this._TagPipedNoDisplayText {
        tagName = "color";
    }
    ;

    static TagHighlight = class extends this._TagPipedNoDisplayText {
        tagName = "highlight";
    }
    ;

    static TagHelp = class extends this._TagPipedNoDisplayText {
        tagName = "help";
    }
    ;

    static _TagPipedDisplayTextThird = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 3 ? parts[2] : parts[0];
        }
    }
    ;

    static TagAction = class extends this._TagPipedDisplayTextThird {
        tagName = "action";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_ACTIONS;
    }
    ;

    static TagBackground = class extends this._TagPipedDisplayTextThird {
        tagName = "background";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_BACKGROUNDS;
    }
    ;

    static TagBoon = class extends this._TagPipedDisplayTextThird {
        tagName = "boon";
        defaultSource = Parser.SRC_MTF;
        page = UrlUtil.PG_CULTS_BOONS;
    }
    ;

    static TagCharoption = class extends this._TagPipedDisplayTextThird {
        tagName = "charoption";
        defaultSource = Parser.SRC_MOT;
        page = UrlUtil.PG_CHAR_CREATION_OPTIONS;
    }
    ;

    static TagClass = class extends this._TagPipedDisplayTextThird {
        tagName = "class";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CLASSES;
    }
    ;

    static TagCondition = class extends this._TagPipedDisplayTextThird {
        tagName = "condition";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CONDITIONS_DISEASES;
    }
    ;

    static TagCreature = class extends this._TagPipedDisplayTextThird {
        tagName = "creature";
        defaultSource = Parser.SRC_MM;
        page = UrlUtil.PG_BESTIARY;
    }
    ;

    static TagCult = class extends this._TagPipedDisplayTextThird {
        tagName = "cult";
        defaultSource = Parser.SRC_MTF;
        page = UrlUtil.PG_CULTS_BOONS;
    }
    ;

    static TagDeck = class extends this._TagPipedDisplayTextThird {
        tagName = "deck";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_DECKS;
    }
    ;

    static TagDisease = class extends this._TagPipedDisplayTextThird {
        tagName = "disease";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_CONDITIONS_DISEASES;
    }
    ;

    static TagFeat = class extends this._TagPipedDisplayTextThird {
        tagName = "feat";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_FEATS;
    }
    ;

    static TagHazard = class extends this._TagPipedDisplayTextThird {
        tagName = "hazard";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_TRAPS_HAZARDS;
    }
    ;

    static TagItem = class extends this._TagPipedDisplayTextThird {
        tagName = "item";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_ITEMS;
    }
    ;

    static TagItemMastery = class extends this._TagPipedDisplayTextThird {
        tagName = "itemMastery";
        defaultSource = VeCt.STR_GENERIC;
        page = "itemMastery";
    }
    ;

    static TagLanguage = class extends this._TagPipedDisplayTextThird {
        tagName = "language";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_LANGUAGES;
    }
    ;

    static TagLegroup = class extends this._TagPipedDisplayTextThird {
        tagName = "legroup";
        defaultSource = Parser.SRC_MM;
        page = "legendaryGroup";
    }
    ;

    static TagObject = class extends this._TagPipedDisplayTextThird {
        tagName = "object";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_OBJECTS;
    }
    ;

    static TagOptfeature = class extends this._TagPipedDisplayTextThird {
        tagName = "optfeature";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_OPT_FEATURES;
    }
    ;

    static TagPsionic = class extends this._TagPipedDisplayTextThird {
        tagName = "psionic";
        defaultSource = Parser.SRC_UATMC;
        page = UrlUtil.PG_PSIONICS;
    }
    ;

    static TagRace = class extends this._TagPipedDisplayTextThird {
        tagName = "race";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_RACES;
    }
    ;

    static TagRecipe = class extends this._TagPipedDisplayTextThird {
        tagName = "recipe";
        defaultSource = Parser.SRC_HF;
        page = UrlUtil.PG_RECIPES;
    }
    ;

    static TagReward = class extends this._TagPipedDisplayTextThird {
        tagName = "reward";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_REWARDS;
    }
    ;

    static TagVehicle = class extends this._TagPipedDisplayTextThird {
        tagName = "vehicle";
        defaultSource = Parser.SRC_GoS;
        page = UrlUtil.PG_VEHICLES;
    }
    ;

    static TagVehupgrade = class extends this._TagPipedDisplayTextThird {
        tagName = "vehupgrade";
        defaultSource = Parser.SRC_GoS;
        page = UrlUtil.PG_VEHICLES;
    }
    ;

    static TagSense = class extends this._TagPipedDisplayTextThird {
        tagName = "sense";
        defaultSource = Parser.SRC_PHB;
        page = "sense";
    }
    ;

    static TagSkill = class extends this._TagPipedDisplayTextThird {
        tagName = "skill";
        defaultSource = Parser.SRC_PHB;
        page = "skill";
    }
    ;

    static TagSpell = class extends this._TagPipedDisplayTextThird {
        tagName = "spell";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_SPELLS;
    }
    ;

    static TagStatus = class extends this._TagPipedDisplayTextThird {
        tagName = "status";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CONDITIONS_DISEASES;
    }
    ;

    static TagTable = class extends this._TagPipedDisplayTextThird {
        tagName = "table";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_TABLES;
    }
    ;

    static TagTrap = class extends this._TagPipedDisplayTextThird {
        tagName = "trap";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_TRAPS_HAZARDS;
    }
    ;

    static TagVariantrule = class extends this._TagPipedDisplayTextThird {
        tagName = "variantrule";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_VARIANTRULES;
    }
    ;

    static TagCite = class extends this._TagPipedDisplayTextThird {
        tagName = "cite";
        defaultSource = Parser.SRC_PHB;
        page = "citation";
    }
    ;

    static _TagPipedDisplayTextFourth = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 4 ? parts[3] : parts[0];
        }
    }
    ;

    static TagCard = class extends this._TagPipedDisplayTextFourth {
        tagName = "card";
        defaultSource = Parser.SRC_DMG;
        page = "card";
    }
    ;

    static TagDeity = class extends this._TagPipedDisplayTextFourth {
        tagName = "deity";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_DEITIES;
    }
    ;

    static _TagPipedDisplayTextSixth = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 6 ? parts[5] : parts[0];
        }
    }
    ;

    static TagClassFeature = class extends this._TagPipedDisplayTextSixth {
        tagName = "classFeature";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CLASSES;
    }
    ;

    static _TagPipedDisplayTextEight = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 8 ? parts[7] : parts[0];
        }
    }
    ;

    static TagSubclassFeature = class extends this._TagPipedDisplayTextEight {
        tagName = "subclassFeature";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CLASSES;
    }
    ;

    static TagQuickref = class extends this._TagBaseAt {
        tagName = "quickref";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_QUICKREF;

        _getStripped(tag, text) {
            const {name, displayText} = DataUtil.quickreference.unpackUid(text);
            return displayText || name;
        }
    }
    ;

    static TagArea = class extends this._TagBaseAt {
        tagName = "area";

        _getStripped(tag, text) {
            const [compactText,,flags] = Renderer.splitTagByPipe(text);

            return flags && flags.includes("x") ? compactText : `${flags && flags.includes("u") ? "A" : "a"}rea ${compactText}`;
        }

        _getMeta(tag, text) {
            const [compactText,areaId,flags] = Renderer.splitTagByPipe(text);

            const displayText = flags && flags.includes("x") ? compactText : `${flags && flags.includes("u") ? "A" : "a"}rea ${compactText}`;

            return {
                areaId,
                displayText,
            };
        }
    }
    ;

    static TagHomebrew = class extends this._TagBaseAt {
        tagName = "homebrew";

        _getStripped(tag, text) {
            const [newText,oldText] = Renderer.splitTagByPipe(text);
            if (newText && oldText) {
                return `${newText} [this is a homebrew addition, replacing the following: "${oldText}"]`;
            } else if (newText) {
                return `${newText} [this is a homebrew addition]`;
            } else if (oldText) {
                return `[the following text has been removed due to homebrew: ${oldText}]`;
            } else
                throw new Error(`Homebrew tag had neither old nor new text!`);
        }
    }
    ;

    static TagItemEntry = class extends this._TagBaseHash {
        tagName = "itemEntry";
        defaultSource = Parser.SRC_DMG;
    }
    ;

    static TAGS = [new this.TagBoldShort(), new this.TagBoldLong(), new this.TagItalicShort(), new this.TagItalicLong(), new this.TagStrikethroughShort(), new this.TagStrikethroughLong(), new this.TagUnderlineShort(), new this.TagUnderlineLong(), new this.TagSup(), new this.TagSub(), new this.TagKbd(), new this.TagCode(), new this.TagStyle(), new this.TagFont(),
    new this.TagComic(), new this.TagComicH1(), new this.TagComicH2(), new this.TagComicH3(), new this.TagComicH4(), new this.TagComicNote(),
    new this.TagNote(), new this.TagTip(),
    new this.TagUnit(),
    new this.TagHit(), new this.TagMiss(),
    new this.TagAtk(),
    new this.TagHitYourSpellAttack(),
    new this.TagDc(),
    new this.TagDcYourSpellSave(),
    new this.TaChance(), new this.TaD20(), new this.TaDamage(), new this.TaDice(), new this.TaAutodice(), new this.TaHit(), new this.TaRecharge(), new this.TaAbility(), new this.TaSavingThrow(), new this.TaSkillCheck(),
    new this.TagScaledice(), new this.TagScaledamage(),
    new this.TagCoinflip(),
    new this.Tag5etools(), new this.TagAdventure(), new this.TagBook(), new this.TagFilter(), new this.TagFootnote(), new this.TagLink(), new this.TagLoader(), new this.TagColor(), new this.TagHighlight(), new this.TagHelp(),
    new this.TagQuickref(),
    new this.TagArea(),
    new this.TagAction(), new this.TagBackground(), new this.TagBoon(), new this.TagCharoption(), new this.TagClass(), new this.TagCondition(), new this.TagCreature(), new this.TagCult(), new this.TagDeck(), new this.TagDisease(), new this.TagFeat(), new this.TagHazard(), new this.TagItem(), new this.TagItemMastery(), new this.TagLanguage(), new this.TagLegroup(), new this.TagObject(), new this.TagOptfeature(), new this.TagPsionic(), new this.TagRace(), new this.TagRecipe(), new this.TagReward(), new this.TagVehicle(), new this.TagVehupgrade(), new this.TagSense(), new this.TagSkill(), new this.TagSpell(), new this.TagStatus(), new this.TagTable(), new this.TagTrap(), new this.TagVariantrule(), new this.TagCite(),
    new this.TagCard(), new this.TagDeity(),
    new this.TagClassFeature({
        tagName: "classFeature"
    }),
    new this.TagSubclassFeature({
        tagName: "subclassFeature"
    }),
    new this.TagHomebrew(),
    new this.TagItemEntry(), ];

    static TAG_LOOKUP = {};

    static _init() {
        this.TAGS.forEach(tag=>{
            this.TAG_LOOKUP[tag.tag] = tag;
            this.TAG_LOOKUP[tag.tagName] = tag;
        }
        );

        return null;
    }

    static _ = this._init();

    static getPage(tag) {
        const tagInfo = this.TAG_LOOKUP[tag];
        return tagInfo?.page;
    }
};
Renderer.race = class {
    static getRaceRenderableEntriesMeta(race) {
        return {
            entryMain: race._isBaseRace ? {
                type: "entries",
                entries: race._baseRaceEntries
            } : {
                type: "entries",
                entries: race.entries
            },
        };
    }

    static getCompactRenderedString(race, {isStatic=false}={}) {
        const renderer = Renderer.get();
        const renderStack = [];

        renderStack.push(`
			${Renderer.utils.getExcludedTr({
            entity: race,
            dataProp: "race",
            page: UrlUtil.PG_RACES
        })}
			${Renderer.utils.getNameTr(race, {
            page: UrlUtil.PG_RACES
        })}
			<tr><td colspan="6">
				<table class="w-100 summary stripe-even-table">
					<tr>
						<th class="col-4 ve-text-center">Ability Scores</th>
						<th class="col-4 ve-text-center">Size</th>
						<th class="col-4 ve-text-center">Speed</th>
					</tr>
					<tr>
						<td class="ve-text-center">${Renderer.getAbilityData(race.ability).asText}</td>
						<td class="ve-text-center">${(race.size || [Parser.SZ_VARIES]).map(sz=>Parser.sizeAbvToFull(sz)).join("/")}</td>
						<td class="ve-text-center">${Parser.getSpeedString(race)}</td>
					</tr>
				</table>
			</td></tr>
			<tr class="text"><td colspan="6">
		`);

        renderer.recursiveRender(Renderer.race.getRaceRenderableEntriesMeta(race).entryMain, renderStack, {depth: 1});

        renderStack.push("</td></tr>");

        const ptHeightWeight = Renderer.race.getHeightAndWeightPart(race, {isStatic});

        if (ptHeightWeight)
            renderStack.push(`<tr class="text"><td colspan="6"><hr class="rd__hr">${ptHeightWeight}</td></tr>`);

        return renderStack.join("");
    }

    static getRenderedSize(race) {
        return (race.size || [Parser.SZ_VARIES]).map(sz=>Parser.sizeAbvToFull(sz)).join("/");
    }

    static getHeightAndWeightPart(race, {isStatic=false}={}) {
        if (!race.heightAndWeight)
            return null;
        if (race._isBaseRace)
            return null;
        return Renderer.get().render({
            entries: Renderer.race.getHeightAndWeightEntries(race, {
                isStatic
            })
        });
    }

    static getHeightAndWeightEntries(race, {isStatic=false}={}) {
        const colLabels = ["Base Height", "Base Weight", "Height Modifier", "Weight Modifier"];
        const colStyles = ["col-2-3 ve-text-center", "col-2-3 ve-text-center", "col-2-3 ve-text-center", "col-2 ve-text-center"];

        const cellHeightMod = !isStatic ? `+<span data-race-heightmod="true">${race.heightAndWeight.heightMod}</span>` : `+${race.heightAndWeight.heightMod}`;
        const cellWeightMod = !isStatic ? `× <span data-race-weightmod="true">${race.heightAndWeight.weightMod || "1"}</span> lb.` : `× ${race.heightAndWeight.weightMod || "1"} lb.`;

        const row = [Renderer.race.getRenderedHeight(race.heightAndWeight.baseHeight), `${race.heightAndWeight.baseWeight} lb.`, cellHeightMod, cellWeightMod, ];

        if (!isStatic) {
            colLabels.push("");
            colStyles.push("col-3-1 ve-text-center");
            row.push(`<div class="ve-flex-vh-center">
				<div class="ve-hidden race__disp-result-height-weight ve-flex-v-baseline">
					<div class="mr-1">=</div>
					<div class="race__disp-result-height"></div>
					<div class="mr-2">; </div>
					<div class="race__disp-result-weight mr-1"></div>
					<div class="small">lb.</div>
				</div>
				<button class="btn btn-default btn-xs my-1 race__btn-roll-height-weight">Roll</button>
			</div>`);
        }

        return ["You may roll for your character's height and weight on the Random Height and Weight table. The roll in the Height Modifier column adds a number (in inches) to the character's base height. To get a weight, multiply the number you rolled for height by the roll in the Weight Modifier column and add the result (in pounds) to the base weight.", {
            type: "table",
            caption: "Random Height and Weight",
            colLabels,
            colStyles,
            rows: [row],
        }, ];
    }

    static getRenderedHeight(height) {
        const heightFeet = Number(Math.floor(height / 12).toFixed(3));
        const heightInches = Number((height % 12).toFixed(3));
        return `${heightFeet ? `${heightFeet}'` : ""}${heightInches ? `${heightInches}"` : ""}`;
    }

    static mergeSubraces(races, opts) {
        opts = opts || {};

        const out = [];
        races.forEach(r=>{
            if (r.size && typeof r.size === "string")
                r.size = [r.size];

            if (r.lineage && r.lineage !== true) {
                r = MiscUtil.copyFast(r);

                if (r.lineage === "VRGR") {
                    r.ability = r.ability || [{
                        choose: {
                            weighted: {
                                from: [...Parser.ABIL_ABVS],
                                weights: [2, 1],
                            },
                        },
                    }, {
                        choose: {
                            weighted: {
                                from: [...Parser.ABIL_ABVS],
                                weights: [1, 1, 1],
                            },
                        },
                    }, ];
                } else if (r.lineage === "UA1") {
                    r.ability = r.ability || [{
                        choose: {
                            weighted: {
                                from: [...Parser.ABIL_ABVS],
                                weights: [2, 1],
                            },
                        },
                    }, ];
                }

                r.entries = r.entries || [];
                r.entries.push({
                    type: "entries",
                    name: "Languages",
                    entries: ["You can speak, read, and write Common and one other language that you and your DM agree is appropriate for your character."],
                });

                r.languageProficiencies = r.languageProficiencies || [{
                    "common": true,
                    "anyStandard": 1
                }];
            }

            if (r.subraces && !r.subraces.length)
                delete r.subraces;

            if (r.subraces) {
                r.subraces.forEach(sr=>{
                    sr.source = sr.source || r.source;
                    sr._isSubRace = true;
                }
                );

                r.subraces.sort((a,b)=>SortUtil.ascSortLower(a.name || "_", b.name || "_") || SortUtil.ascSortLower(Parser.sourceJsonToAbv(a.source), Parser.sourceJsonToAbv(b.source)));
            }

            if (opts.isAddBaseRaces && r.subraces) {
                const baseRace = MiscUtil.copyFast(r);

                baseRace._isBaseRace = true;

                const isAnyNoName = r.subraces.some(it=>!it.name);
                if (isAnyNoName) {
                    baseRace._rawName = baseRace.name;
                    baseRace.name = `${baseRace.name} (Base)`;
                }

                const nameCounts = {};
                r.subraces.filter(sr=>sr.name).forEach(sr=>nameCounts[sr.name.toLowerCase()] = (nameCounts[sr.name.toLowerCase()] || 0) + 1);
                nameCounts._ = r.subraces.filter(sr=>!sr.name).length;

                const lst = {
                    type: "list",
                    items: r.subraces.map(sr=>{
                        const count = nameCounts[(sr.name || "_").toLowerCase()];
                        const idName = Renderer.race.getSubraceName(r.name, sr.name);
                        return `{@race ${idName}|${sr.source}${count > 1 ? `|${idName} (<span title="${Parser.sourceJsonToFull(sr.source).escapeQuotes()}">${Parser.sourceJsonToAbv(sr.source)}</span>)` : ""}}`;
                    }
                    ),
                };

                Renderer.race._mutBaseRaceEntries(baseRace, lst);
                baseRace._subraces = r.subraces.map(sr=>({
                    name: Renderer.race.getSubraceName(r.name, sr.name),
                    source: sr.source
                }));

                delete baseRace.subraces;

                out.push(baseRace);
            }

            out.push(...Renderer.race._mergeSubraces(r));
        }
        );

        return out;
    }

    static _mutMakeBaseRace(baseRace) {
        if (baseRace._isBaseRace)
            return;

        baseRace._isBaseRace = true;

        Renderer.race._mutBaseRaceEntries(baseRace, {
            type: "list",
            items: []
        });
    }

    static _mutBaseRaceEntries(baseRace, lst) {
        baseRace._baseRaceEntries = [{
            type: "section",
            entries: ["This race has multiple subraces, as listed below:", lst, ],
        }, {
            type: "section",
            entries: [{
                type: "entries",
                entries: [{
                    type: "entries",
                    name: "Traits",
                    entries: [...MiscUtil.copyFast(baseRace.entries), ],
                }, ],
            }, ],
        }, ];
    }

    static getSubraceName(raceName, subraceName) {
        if (!subraceName)
            return raceName;

        const mBrackets = /^(.*?)(\(.*?\))$/i.exec(raceName || "");
        if (!mBrackets)
            return `${raceName} (${subraceName})`;

        const bracketPart = mBrackets[2].substring(1, mBrackets[2].length - 1);
        return `${mBrackets[1]}(${[bracketPart, subraceName].join("; ")})`;
    }

    static _mergeSubraces(race) {
        if (!race.subraces)
            return [race];
        return MiscUtil.copyFast(race.subraces).map(s=>Renderer.race._getMergedSubrace(race, s));
    }

    static _getMergedSubrace(race, cpySr) {
        const cpy = MiscUtil.copyFast(race);
        cpy._baseName = cpy.name;
        cpy._baseSource = cpy.source;
        cpy._baseSrd = cpy.srd;
        cpy._baseBasicRules = cpy.basicRules;
        delete cpy.subraces;
        delete cpy.srd;
        delete cpy.basicRules;
        delete cpy._versions;
        delete cpy.hasFluff;
        delete cpy.hasFluffImages;
        delete cpySr.__prop;

        if (cpySr.name) {
            cpy._subraceName = cpySr.name;

            if (cpySr.alias) {
                cpy.alias = cpySr.alias.map(it=>Renderer.race.getSubraceName(cpy.name, it));
                delete cpySr.alias;
            }

            cpy.name = Renderer.race.getSubraceName(cpy.name, cpySr.name);
            delete cpySr.name;
        }
        if (cpySr.ability) {
            if ((cpySr.overwrite && cpySr.overwrite.ability) || !cpy.ability)
                cpy.ability = cpySr.ability.map(()=>({}));

            if (cpy.ability.length !== cpySr.ability.length)
                throw new Error(`Race and subrace ability array lengths did not match!`);
            cpySr.ability.forEach((obj,i)=>Object.assign(cpy.ability[i], obj));
            delete cpySr.ability;
        }
        if (cpySr.entries) {
            cpySr.entries.forEach(ent=>{
                if (!ent.data?.overwrite)
                    return cpy.entries.push(ent);

                const toOverwrite = cpy.entries.findIndex(it=>it.name?.toLowerCase()?.trim() === ent.data.overwrite.toLowerCase().trim());
                if (~toOverwrite)
                    cpy.entries[toOverwrite] = ent;
                else
                    cpy.entries.push(ent);
            }
            );
            delete cpySr.entries;
        }

        if (cpySr.traitTags) {
            if (cpySr.overwrite && cpySr.overwrite.traitTags)
                cpy.traitTags = cpySr.traitTags;
            else
                cpy.traitTags = (cpy.traitTags || []).concat(cpySr.traitTags);
            delete cpySr.traitTags;
        }

        if (cpySr.languageProficiencies) {
            if (cpySr.overwrite && cpySr.overwrite.languageProficiencies)
                cpy.languageProficiencies = cpySr.languageProficiencies;
            else
                cpy.languageProficiencies = cpy.languageProficiencies = (cpy.languageProficiencies || []).concat(cpySr.languageProficiencies);
            delete cpySr.languageProficiencies;
        }

        if (cpySr.skillProficiencies) {
            if (!cpy.skillProficiencies || (cpySr.overwrite && cpySr.overwrite["skillProficiencies"]))
                cpy.skillProficiencies = cpySr.skillProficiencies;
            else {
                if (!cpySr.skillProficiencies.length || !cpy.skillProficiencies.length)
                    throw new Error(`No items!`);
                if (cpySr.skillProficiencies.length > 1 || cpy.skillProficiencies.length > 1)
                    throw new Error(`Subrace merging does not handle choices!`);
                if (cpySr.skillProficiencies.choose) {
                    if (cpy.skillProficiencies.choose)
                        throw new Error(`Subrace choose merging is not supported!!`);
                    cpy.skillProficiencies.choose = cpySr.skillProficiencies.choose;
                    delete cpySr.skillProficiencies.choose;
                }
                Object.assign(cpy.skillProficiencies[0], cpySr.skillProficiencies[0]);
            }

            delete cpySr.skillProficiencies;
        }

        Object.assign(cpy, cpySr);

        Object.entries(cpy).forEach(([k,v])=>{
            if (v != null)
                return;
            delete cpy[k];
        }
        );

        return cpy;
    }

    static adoptSubraces(allRaces, subraces) {
        const nxtData = [];

        subraces.forEach(sr=>{
            if (!sr.raceName || !sr.raceSource)
                throw new Error(`Subrace was missing parent "raceName" and/or "raceSource"!`);

            const _baseRace = allRaces.find(r=>r.name === sr.raceName && r.source === sr.raceSource);
            if (!_baseRace)
                throw new Error(`Could not find parent race for subrace "${sr.name}" (${sr.source})!`);

            if ((_baseRace._seenSubraces || []).some(it=>it.name === sr.name && it.source === sr.source))
                return;
            (_baseRace._seenSubraces = _baseRace._seenSubraces || []).push({
                name: sr.name,
                source: sr.source
            });

            if (!_baseRace._isBaseRace && (PrereleaseUtil.hasSourceJson(_baseRace.source) || BrewUtil2.hasSourceJson(_baseRace.source))) {
                Renderer.race._mutMakeBaseRace(_baseRace);
            }

            if (_baseRace._isBaseRace) {
                const subraceListEntry = ((_baseRace._baseRaceEntries[0] || {}).entries || []).find(it=>it.type === "list");
                subraceListEntry.items.push(`{@race ${_baseRace._rawName || _baseRace.name} (${sr.name})|${sr.source || _baseRace.source}}`);
            }

            let baseRace = nxtData.find(r=>r.name === sr.raceName && r.source === sr.raceSource);
            if (!baseRace) {
                baseRace = MiscUtil.copyFast(_baseRace);
                if (baseRace._rawName) {
                    baseRace.name = baseRace._rawName;
                    delete baseRace._rawName;
                }
                delete baseRace._isBaseRace;
                delete baseRace._baseRaceEntries;

                nxtData.push(baseRace);
            }

            baseRace.subraces = baseRace.subraces || [];
            baseRace.subraces.push(sr);
        }
        );

        return nxtData;
    }

    static bindListenersHeightAndWeight(race, ele) {
        if (!race.heightAndWeight)
            return;
        if (race._isBaseRace)
            return;

        const $render = $(ele);

        const $dispResult = $render.find(`.race__disp-result-height-weight`);
        const $dispHeight = $render.find(`.race__disp-result-height`);
        const $dispWeight = $render.find(`.race__disp-result-weight`);

        const lock = new VeLock();
        let hasRolled = false;
        let resultHeight;
        let resultWeightMod;

        const $btnRollHeight = $render.find(`[data-race-heightmod="true"]`).html(race.heightAndWeight.heightMod).addClass("roller").mousedown(evt=>evt.preventDefault()).click(async()=>{
            try {
                await lock.pLock();

                if (!hasRolled)
                    return pDoFullRoll(true);
                await pRollHeight();
                updateDisplay();
            } finally {
                lock.unlock();
            }
        }
        );

        const isWeightRoller = race.heightAndWeight.weightMod && isNaN(race.heightAndWeight.weightMod);
        const $btnRollWeight = $render.find(`[data-race-weightmod="true"]`).html(isWeightRoller ? `(<span class="roller">${race.heightAndWeight.weightMod}</span>)` : race.heightAndWeight.weightMod || "1").click(async()=>{
            try {
                await lock.pLock();

                if (!hasRolled)
                    return pDoFullRoll(true);
                await pRollWeight();
                updateDisplay();
            } finally {
                lock.unlock();
            }
        }
        );
        if (isWeightRoller)
            $btnRollWeight.mousedown(evt=>evt.preventDefault());

        const $btnRoll = $render.find(`button.race__btn-roll-height-weight`).click(async()=>pDoFullRoll());

        const pRollHeight = async()=>{
            const mResultHeight = await Renderer.dice.pRoll2(race.heightAndWeight.heightMod, {
                isUser: false,
                label: "Height Modifier",
                name: race.name,
            });
            if (mResultHeight == null)
                return;
            resultHeight = mResultHeight;
        }
        ;

        const pRollWeight = async()=>{
            const weightModRaw = race.heightAndWeight.weightMod || "1";
            const mResultWeightMod = isNaN(weightModRaw) ? await Renderer.dice.pRoll2(weightModRaw, {
                isUser: false,
                label: "Weight Modifier",
                name: race.name,
            }) : Number(weightModRaw);
            if (mResultWeightMod == null)
                return;
            resultWeightMod = mResultWeightMod;
        }
        ;

        const updateDisplay = ()=>{
            const renderedHeight = Renderer.race.getRenderedHeight(race.heightAndWeight.baseHeight + resultHeight);
            const totalWeight = race.heightAndWeight.baseWeight + (resultWeightMod * resultHeight);
            $dispHeight.text(renderedHeight);
            $dispWeight.text(Number(totalWeight.toFixed(3)));
        }
        ;

        const pDoFullRoll = async isPreLocked=>{
            try {
                if (!isPreLocked)
                    await lock.pLock();

                $btnRoll.parent().removeClass(`ve-flex-vh-center`).addClass(`split-v-center`);
                await pRollHeight();
                await pRollWeight();
                $dispResult.removeClass(`ve-hidden`);
                updateDisplay();

                hasRolled = true;
            } finally {
                if (!isPreLocked)
                    lock.unlock();
            }
        }
        ;
    }

    static bindListenersCompact(race, ele) {
        Renderer.race.bindListenersHeightAndWeight(race, ele);
    }

    static pGetFluff(race) {
        return Renderer.utils.pGetFluff({
            entity: race,
            fnGetFluffData: DataUtil.raceFluff.loadJSON.bind(DataUtil.raceFluff),
            fluffProp: "raceFluff",
        });
    }
};

Renderer.getEntryDice = function(entry, name, opts={}) {
    const toDisplay = Renderer.getEntryDiceDisplayText(entry);

    if (entry.rollable === true)
        {
            console.log(Renderer.getRollableEntryDice);
            return Renderer.getRollableEntryDice(entry, name, toDisplay, opts);}
    else
        {return toDisplay;}
};

Renderer.getRollableEntryDice = function(entry, name, toDisplay, {isAddHandlers=true, pluginResults=null, }={}, ) {
    const toPack = MiscUtil.copyFast(entry);
    if (typeof toPack.toRoll !== "string") {
        toPack.toRoll = Renderer.legacyDiceToString(toPack.toRoll);
    }

    const handlerPart = isAddHandlers ? `onmousedown="event.preventDefault()" data-packed-dice='${JSON.stringify(toPack).qq()}'` : "";

    const rollableTitlePart = isAddHandlers ? Renderer.getEntryDiceTitle(toPack.subType) : null;
    const titlePart = isAddHandlers ? `title="${[name, rollableTitlePart].filter(Boolean).join(". ").qq()}" ${name ? `data-roll-name="${name}"` : ""}` : name ? `title="${name.qq()}" data-roll-name="${name.qq()}"` : "";

    const additionalDataPart = (pluginResults || []).filter(it=>it.additionalData).map(it=>{
        return Object.entries(it.additionalData).map(([dataKey,val])=>`${dataKey}='${typeof val === "object" ? JSON.stringify(val).qq() : `${val}`.qq()}'`).join(" ");
    }
    ).join(" ");

    toDisplay = (pluginResults || []).filter(it=>it.toDisplay)[0]?.toDisplay ?? toDisplay;

    const ptRoll = Renderer.getRollableEntryDice._getPtRoll(toPack);

    return `<span class="roller render-roller" ${titlePart} ${handlerPart} ${additionalDataPart}>${toDisplay}</span>${ptRoll}`;
};

Renderer.getRollableEntryDice._getPtRoll = (toPack)=>{
    if (!toPack.autoRoll)
        return "";

    const r = Renderer.dice.parseRandomise2(toPack.toRoll);
    return ` (<span data-rd-is-autodice-result="true">${r}</span>)`;
};

Renderer.getEntryDiceTitle = function(subType) {
    return `Click to roll. ${subType === "damage" ? "SHIFT to roll a critical hit, CTRL to half damage (rounding down)." : subType === "d20" ? "SHIFT to roll with advantage, CTRL to roll with disadvantage." : "SHIFT/CTRL to roll twice."}`;
};

Renderer.legacyDiceToString = function(array) {
    let stack = "";
    array.forEach(r=>{
        stack += `${r.neg ? "-" : stack === "" ? "" : "+"}${r.number || 1}d${r.faces}${r.mod ? r.mod > 0 ? `+${r.mod}` : r.mod : ""}`;
    }
    );
    return stack;
};

Renderer.getEntryDiceDisplayText = function(entry) {
    if (entry.displayText)
        return entry.displayText;
    return Renderer._getEntryDiceDisplayText_getDiceAsStr(entry);
};

Renderer._getEntryDiceDisplayText_getDiceAsStr = function(entry) {
    if (entry.successThresh != null)
        return `${entry.successThresh} percent`;
    if (typeof entry.toRoll === "string")
        return entry.toRoll;
    return Renderer.legacyDiceToString(entry.toRoll);
};

Renderer.parseScaleDice = function(tag, text) {
    const [baseRoll,progression,addPerProgress,renderMode,displayText] = Renderer.splitTagByPipe(text);
    const progressionParse = MiscUtil.parseNumberRange(progression, 1, 9);
    const baseLevel = Math.min(...progressionParse);
    const options = {};
    const isMultableDice = /^(\d+)d(\d+)$/i.exec(addPerProgress);

    const getSpacing = ()=>{
        let diff = null;
        const sorted = [...progressionParse].sort(SortUtil.ascSort);
        for (let i = 1; i < sorted.length; ++i) {
            const prev = sorted[i - 1];
            const curr = sorted[i];
            if (diff == null)
                diff = curr - prev;
            else if (curr - prev !== diff)
                return null;
        }
        return diff;
    }
    ;

    const spacing = getSpacing();
    progressionParse.forEach(k=>{
        const offset = k - baseLevel;
        if (isMultableDice && spacing != null) {
            options[k] = offset ? `${Number(isMultableDice[1]) * (offset / spacing)}d${isMultableDice[2]}` : "";
        } else {
            options[k] = offset ? [...new Array(Math.floor(offset / spacing))].map(_=>addPerProgress).join("+") : "";
        }
    }
    );

    const out = {
        type: "dice",
        rollable: true,
        toRoll: baseRoll,
        displayText: displayText || addPerProgress,
        prompt: {
            entry: renderMode === "psi" ? "Spend Psi Points..." : "Cast at...",
            mode: renderMode,
            options,
        },
    };
    if (tag === "@scaledamage")
        out.subType = "damage";

    return out;
};

Renderer.getAbilityData = function(abArr, {isOnlyShort, isCurrentLineage}={}) {
    if (isOnlyShort && isCurrentLineage)
        return new Renderer._AbilityData({
            asTextShort: "Lineage (choose)"
        });

    const outerStack = (abArr || [null]).map(it=>Renderer.getAbilityData._doRenderOuter(it));
    if (outerStack.length <= 1)
        return outerStack[0];
    return new Renderer._AbilityData({
        asText: `Choose one of: ${outerStack.map((it,i)=>`(${Parser.ALPHABET[i].toLowerCase()}) ${it.asText}`).join(" ")}`,
        asTextShort: `${outerStack.map((it,i)=>`(${Parser.ALPHABET[i].toLowerCase()}) ${it.asTextShort}`).join(" ")}`,
        asCollection: [...new Set(outerStack.map(it=>it.asCollection).flat())],
        areNegative: [...new Set(outerStack.map(it=>it.areNegative).flat())],
    });
};

Renderer.getAbilityData._doRenderOuter = function(abObj) {
    const mainAbs = [];
    const asCollection = [];
    const areNegative = [];
    const toConvertToText = [];
    const toConvertToShortText = [];

    if (abObj != null) {
        handleAllAbilities(abObj);
        handleAbilitiesChoose();
        return new Renderer._AbilityData({
            asText: toConvertToText.join("; "),
            asTextShort: toConvertToShortText.join("; "),
            asCollection: asCollection,
            areNegative: areNegative,
        });
    }

    return new Renderer._AbilityData();

    function handleAllAbilities(abObj, targetList) {
        MiscUtil.copyFast(Parser.ABIL_ABVS).sort((a,b)=>SortUtil.ascSort(abObj[b] || 0, abObj[a] || 0)).forEach(shortLabel=>handleAbility(abObj, shortLabel, targetList));
    }

    function handleAbility(abObj, shortLabel, optToConvertToTextStorage) {
        if (abObj[shortLabel] != null) {
            const isNegMod = abObj[shortLabel] < 0;
            const toAdd = `${shortLabel.uppercaseFirst()} ${(isNegMod ? "" : "+")}${abObj[shortLabel]}`;

            if (optToConvertToTextStorage) {
                optToConvertToTextStorage.push(toAdd);
            }
            else {
                toConvertToText.push(toAdd);
                toConvertToShortText.push(toAdd);
            }

            mainAbs.push(shortLabel.uppercaseFirst());
            asCollection.push(shortLabel);
            if (isNegMod)
                areNegative.push(shortLabel);
        }
    }

    function handleAbilitiesChoose() {
        if (abObj.choose != null) {
            const ch = abObj.choose;
            let outStack = "";
            if (ch.weighted) {
                const w = ch.weighted;
                const froms = w.from.map(it=>it.uppercaseFirst());
                const isAny = froms.length === 6;
                const isAllEqual = w.weights.unique().length === 1;
                let cntProcessed = 0;

                const weightsIncrease = w.weights.filter(it=>it >= 0).sort(SortUtil.ascSort).reverse();
                const weightsReduce = w.weights.filter(it=>it < 0).map(it=>-it).sort(SortUtil.ascSort);

                const areIncreaseShort = [];
                const areIncrease = isAny && isAllEqual && w.weights.length > 1 && w.weights[0] >= 0 ? (()=>{
                    weightsIncrease.forEach(it=>areIncreaseShort.push(`+${it}`));
                    return [`${cntProcessed ? "choose " : ""}${Parser.numberToText(w.weights.length)} different +${weightsIncrease[0]}`];
                }
                )() : weightsIncrease.map(it=>{
                    areIncreaseShort.push(`+${it}`);
                    if (isAny)
                        return `${cntProcessed ? "choose " : ""}any ${cntProcessed++ ? `other ` : ""}+${it}`;
                    return `one ${cntProcessed++ ? `other ` : ""}ability to increase by ${it}`;
                }
                );

                const areReduceShort = [];
                const areReduce = isAny && isAllEqual && w.weights.length > 1 && w.weights[0] < 0 ? (()=>{
                    weightsReduce.forEach(it=>areReduceShort.push(`-${it}`));
                    return [`${cntProcessed ? "choose " : ""}${Parser.numberToText(w.weights.length)} different -${weightsReduce[0]}`];
                }
                )() : weightsReduce.map(it=>{
                    areReduceShort.push(`-${it}`);
                    if (isAny)
                        return `${cntProcessed ? "choose " : ""}any ${cntProcessed++ ? `other ` : ""}-${it}`;
                    return `one ${cntProcessed++ ? `other ` : ""}ability to decrease by ${it}`;
                }
                );

                const startText = isAny ? `Choose ` : `From ${froms.joinConjunct(", ", " and ")} choose `;

                const ptAreaIncrease = isAny ? areIncrease.concat(areReduce).join("; ") : areIncrease.concat(areReduce).joinConjunct(", ", isAny ? "; " : " and ");
                toConvertToText.push(`${startText}${ptAreaIncrease}`);
                toConvertToShortText.push(`${isAny ? "Any combination " : ""}${areIncreaseShort.concat(areReduceShort).join("/")}${isAny ? "" : ` from ${froms.join("/")}`}`);
            } else {
                const allAbilities = ch.from.length === 6;
                const allAbilitiesWithParent = isAllAbilitiesWithParent(ch);
                let amount = ch.amount === undefined ? 1 : ch.amount;
                amount = (amount < 0 ? "" : "+") + amount;
                if (allAbilities) {
                    outStack += "any ";
                } else if (allAbilitiesWithParent) {
                    outStack += "any other ";
                }
                if (ch.count != null && ch.count > 1) {
                    outStack += `${Parser.numberToText(ch.count)} `;
                }
                if (allAbilities || allAbilitiesWithParent) {
                    outStack += `${ch.count > 1 ? "unique " : ""}${amount}`;
                } else {
                    for (let j = 0; j < ch.from.length; ++j) {
                        let suffix = "";
                        if (ch.from.length > 1) {
                            if (j === ch.from.length - 2) {
                                suffix = " or ";
                            } else if (j < ch.from.length - 2) {
                                suffix = ", ";
                            }
                        }
                        let thsAmount = ` ${amount}`;
                        if (ch.from.length > 1) {
                            if (j !== ch.from.length - 1) {
                                thsAmount = "";
                            }
                        }
                        outStack += ch.from[j].uppercaseFirst() + thsAmount + suffix;
                    }
                }
            }

            if (outStack.trim()) {
                toConvertToText.push(`Choose ${outStack}`);
                toConvertToShortText.push(outStack.uppercaseFirst());
            }
        }
    }

    function isAllAbilitiesWithParent(chooseAbs) {
        const tempAbilities = [];
        for (let i = 0; i < mainAbs.length; ++i) {
            tempAbilities.push(mainAbs[i].toLowerCase());
        }
        for (let i = 0; i < chooseAbs.from.length; ++i) {
            const ab = chooseAbs.from[i].toLowerCase();
            if (!tempAbilities.includes(ab))
                tempAbilities.push(ab);
            if (!asCollection.includes(ab.toLowerCase))
                asCollection.push(ab.toLowerCase());
        }
        return tempAbilities.length === 6;
    }
};

Renderer._AbilityData = function({asText, asTextShort, asCollection, areNegative}={}) {
    this.asText = asText || "";
    this.asTextShort = asTextShort || "";
    this.asCollection = asCollection || [];
    this.areNegative = areNegative || [];
};

Renderer.getFilterSubhashes = function(filters, namespace=null) {
    let customHash = null;

    const subhashes = filters.map(f=>{
        const [fName,fVals,fMeta,fOpts] = f.split("=").map(s=>s.trim());
        const isBoxData = fName.startsWith("fb");
        const key = isBoxData ? `${fName}${namespace ? `.${namespace}` : ""}` : `flst${namespace ? `.${namespace}` : ""}${UrlUtil.encodeForHash(fName)}`;

        let value;
        if (isBoxData) {
            return {
                key,
                value: fVals,
                preEncoded: true,
            };
        } else if (fName === "search") {
            return {
                key: VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX,
                value: UrlUtil.encodeForHash(fVals),
                preEncoded: true,
            };
        } else if (fName === "hash") {
            customHash = fVals;
            return null;
        } else if (fVals.startsWith("[") && fVals.endsWith("]")) {
            const [min,max] = fVals.substring(1, fVals.length - 1).split(";").map(it=>it.trim());
            if (max == null) {
                value = [`min=${min}`, `max=${min}`, ].join(HASH_SUB_LIST_SEP);
            } else {
                value = [min ? `min=${min}` : "", max ? `max=${max}` : "", ].filter(Boolean).join(HASH_SUB_LIST_SEP);
            }
        } else if (fVals.startsWith("::") && fVals.endsWith("::")) {
            value = fVals.substring(2, fVals.length - 2).split(";").map(it=>it.trim()).map(it=>{
                if (it.startsWith("!"))
                    return `${UrlUtil.encodeForHash(it.slice(1))}=${UrlUtil.mini.compress(false)}`;
                return `${UrlUtil.encodeForHash(it)}=${UrlUtil.mini.compress(true)}`;
            }
            ).join(HASH_SUB_LIST_SEP);
        } else {
            value = fVals.split(";").map(s=>s.trim()).filter(Boolean).map(s=>{
                if (s.startsWith("!"))
                    return `${UrlUtil.encodeForHash(s.slice(1))}=2`;
                return `${UrlUtil.encodeForHash(s)}=1`;
            }
            ).join(HASH_SUB_LIST_SEP);
        }

        const out = [{
            key,
            value,
            preEncoded: true,
        }];

        if (fMeta) {
            out.push({
                key: `flmt${UrlUtil.encodeForHash(fName)}`,
                value: fMeta,
                preEncoded: true,
            });
        }

        if (fOpts) {
            out.push({
                key: `flop${UrlUtil.encodeForHash(fName)}`,
                value: fOpts,
                preEncoded: true,
            });
        }

        return out;
    }
    ).flat().filter(Boolean);

    return {
        customHash,
        subhashes,
    };
};

Renderer.ENTRIES_WITH_ENUMERATED_TITLES = [{
    type: "section",
    key: "entries",
    depth: -1
}, {
    type: "entries",
    key: "entries",
    depthIncrement: 1
}, {
    type: "options",
    key: "entries"
}, {
    type: "inset",
    key: "entries",
    depth: 2
}, {
    type: "insetReadaloud",
    key: "entries",
    depth: 2
}, {
    type: "variant",
    key: "entries",
    depth: 2
}, {
    type: "variantInner",
    key: "entries",
    depth: 2
}, {
    type: "actions",
    key: "entries",
    depth: 2
}, {
    type: "flowBlock",
    key: "entries",
    depth: 2
}, {
    type: "optfeature",
    key: "entries",
    depthIncrement: 1
}, {
    type: "patron",
    key: "entries"
}, ];
Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP = Renderer.ENTRIES_WITH_ENUMERATED_TITLES.mergeMap(it=>({[it.type]: it}));
Renderer._INLINE_HEADER_TERMINATORS = new Set([".", ",", "!", "?", ";", ":", `"`]);

Renderer.table = class {
    static getCompactRenderedString(it) {
        it.type = it.type || "table";
        const cpy = MiscUtil.copyFast(it);
        delete cpy.name;
        return `
			${Renderer.utils.getExcludedTr({
            entity: it,
            dataProp: "table",
            page: UrlUtil.PG_TABLES
        })}
			${Renderer.utils.getNameTr(it, {
            page: UrlUtil.PG_TABLES
        })}
			<tr><td colspan="6">
			${Renderer.get().setFirstSection(true).render(it)}
			</td></tr>
		`;
    }

    static getConvertedEncounterOrNamesTable({group, tableRaw, fnGetNameCaption, colLabel1}) {
        const getPadded = (number)=>{
            if (tableRaw.diceExpression === "d100")
                return String(number).padStart(2, "0");
            return String(number);
        }
        ;

        const nameCaption = fnGetNameCaption(group, tableRaw);
        return {
            name: nameCaption,
            type: "table",
            source: group?.source,
            page: group?.page,
            caption: nameCaption,
            colLabels: [`{@dice ${tableRaw.diceExpression}}`, colLabel1, tableRaw.rollAttitude ? `Attitude` : null, ].filter(Boolean),
            colStyles: ["col-2 text-center", tableRaw.rollAttitude ? "col-8" : "col-10", tableRaw.rollAttitude ? `col-2 text-center` : null, ].filter(Boolean),
            rows: tableRaw.table.map(it=>[`${getPadded(it.min)}${it.max != null && it.max !== it.min ? `-${getPadded(it.max)}` : ""}`, it.result, tableRaw.rollAttitude ? it.resultAttitude || "\u2014" : null, ].filter(Boolean)),
            footnotes: tableRaw.footnotes,
        };
    }

    static getConvertedEncounterTableName(group, tableRaw) {
        return `${group.name}${tableRaw.caption ? ` ${tableRaw.caption}` : ""}${/\bencounters?\b/i.test(group.name) ? "" : " Encounters"}${tableRaw.minlvl && tableRaw.maxlvl ? ` (Levels ${tableRaw.minlvl}\u2014${tableRaw.maxlvl})` : ""}`;
    }

    static getConvertedNameTableName(group, tableRaw) {
        return `${group.name} Names \u2013 ${tableRaw.option}`;
    }

    static getHeaderRowMetas(ent) {
        if (!ent.colLabels?.length && !ent.colLabelGroups?.length)
            return null;

        if (ent.colLabels?.length)
            return [ent.colLabels];

        const maxHeight = Math.max(...ent.colLabelGroups.map(clg=>clg.colLabels?.length || 0));

        const padded = ent.colLabelGroups.map(clg=>{
            const out = [...(clg.colLabels || [])];
            while (out.length < maxHeight)
                out.unshift("");
            return out;
        }
        );

        return [...new Array(maxHeight)].map((_,i)=>padded.map(lbls=>lbls[i]));
    }

    static _RE_TABLE_ROW_DASHED_NUMBERS = /^\d+([-\u2012\u2013]\d+)?/;
    static getAutoConvertedRollMode(table, {headerRowMetas}={}) {
        if (headerRowMetas === undefined){headerRowMetas = Renderer.table.getHeaderRowMetas(table);}

        if (!headerRowMetas || headerRowMetas[headerRowMetas.length-1].length < 2){return RollerUtil.ROLL_COL_NONE;}

        const rollColMode = RollerUtil.getColRollType(headerRowMetas[headerRowMetas.length-1][0]);
        if (!rollColMode){return RollerUtil.ROLL_COL_NONE;}

        if (!Renderer.table.isEveryRowRollable(table.rows)){return RollerUtil.ROLL_COL_NONE;}

        return rollColMode;
    }

    static isEveryRowRollable(rows) {
        return rows.every(row=>{
            if (!row)
                return false;
            const [cell] = row;
            return Renderer.table.isRollableCell(cell);
        }
        );
    }

    static isRollableCell(cell) {
        if (cell == null)
            return false;
        if (cell?.roll)
            return true;

        if (typeof cell === "number")
            return Number.isInteger(cell);

        return typeof cell === "string" && Renderer.table._RE_TABLE_ROW_DASHED_NUMBERS.test(cell);
    }
};

Renderer.stripTags = function(str) {
    if (!str)
        return str;
    let nxtStr = Renderer._stripTagLayer(str);
    while (nxtStr.length !== str.length) {
        str = nxtStr;
        nxtStr = Renderer._stripTagLayer(str);
    }
    return nxtStr;
};

Renderer._stripTagLayer = function(str) {
    if (str.includes("{@")) {
        const tagSplit = Renderer.splitByTags(str);
        return tagSplit.filter(it=>it).map(it=>{
            if (it.startsWith("{@")) {
                let[tag,text] = Renderer.splitFirstSpace(it.slice(1, -1));
                const tagInfo = Renderer.tag.TAG_LOOKUP[tag];
                if (!tagInfo)
                    throw new Error(`Unhandled tag: "${tag}"`);
                return tagInfo.getStripped(tag, text);
            } else
                return it;
        }
        ).join("");
    }
    return str;
};

Renderer.class = class {
    static getCompactRenderedString(cls) {
        if (cls.__prop === "subclass")
            return Renderer.subclass.getCompactRenderedString(cls);

        const clsEntry = {
            type: "section",
            name: cls.name,
            source: cls.source,
            page: cls.page,
            entries: MiscUtil.copyFast((cls.classFeatures || []).flat()),
        };

        return Renderer.hover.getGenericCompactRenderedString(clsEntry);
    }

    static getHitDiceEntry(clsHd) {
        return clsHd ? {
            toRoll: `${clsHd.number}d${clsHd.faces}`,
            rollable: true
        } : null;
    }
    static getHitPointsAtFirstLevel(clsHd) {
        return clsHd ? `${clsHd.number * clsHd.faces} + your Constitution modifier` : null;
    }
    static getHitPointsAtHigherLevels(className, clsHd, hdEntry) {
        return className && clsHd && hdEntry ? `${SETTINGS.DO_RENDER_DICE? Renderer.getEntryDice(hdEntry, "Hit die"): hdEntry.toRoll} (or 
            ${((clsHd.number * clsHd.faces) / 2 + 1)}) + your Constitution modifier per ${className} level after 1st` : null;
    }

    static getRenderedArmorProfs(armorProfs) {
        return armorProfs.map(a=>Renderer.get().render(a.full ? a.full : a === "light" || a === "medium" || a === "heavy" ? `{@filter ${a} armor|items|type=${a} armor}` : a)).join(", ");
    }
    static getRenderedWeaponProfs(weaponProfs) {
        return weaponProfs.map(w=>Renderer.get().render(w === "simple" || w === "martial" ? `{@filter ${w} weapons|items|type=${w} weapon}` : w.optional ? `<span class="help help--hover" title="Optional Proficiency">${w.proficiency}</span>` : w)).join(", ");
    }
    static getRenderedToolProfs(toolProfs) {
        return toolProfs.map(it=>Renderer.get().render(it)).join(", ");
    }
    static getRenderedSkillProfs(skills) {
        return `${Parser.skillProficienciesToFull(skills).uppercaseFirst()}.`;
    }

    static getWalkerFilterDereferencedFeatures() {
        return MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
            isAllowDeleteObjects: true,
            isDepthFirst: true,
        });
    }

    static mutFilterDereferencedClassFeatures({walker, cpyCls, pageFilter, filterValues, isUseSubclassSources=false, }, ) {
        walker = walker || Renderer.class.getWalkerFilterDereferencedFeatures();

        cpyCls.classFeatures = cpyCls.classFeatures.map((lvlFeatures,ixLvl)=>{
            return walker.walk(lvlFeatures, {
                object: (obj)=>{
                    if (!obj.source)
                        return obj;
                    const fText = obj.isClassFeatureVariant ? {
                        isClassFeatureVariant: true
                    } : null;

                    const isDisplay = [obj.source, ...(obj.otherSources || []).map(it=>it.source)].some(src=>pageFilter.filterBox.toDisplayByFilters(filterValues, ...[{
                        filter: pageFilter.sourceFilter,
                        value: isUseSubclassSources && src === cpyCls.source ? pageFilter.getActiveSource(filterValues) : src,
                    }, pageFilter.levelFilter ? {
                        filter: pageFilter.levelFilter,
                        value: ixLvl + 1,
                    } : null, {
                        filter: pageFilter.optionsFilter,
                        value: fText,
                    }, ].filter(Boolean), ));

                    return isDisplay ? obj : null;
                }
                ,
                array: (arr)=>{
                    return arr.filter(it=>it != null);
                }
                ,
            }, );
        }
        );
    }

    static mutFilterDereferencedSubclassFeatures({walker, cpySc, pageFilter, filterValues, }, ) {
        walker = walker || Renderer.class.getWalkerFilterDereferencedFeatures();

        cpySc.subclassFeatures = cpySc.subclassFeatures.map(lvlFeatures=>{
            const level = CollectionUtil.bfs(lvlFeatures, {
                prop: "level"
            });

            return walker.walk(lvlFeatures, {
                object: (obj)=>{
                    if (obj.entries && !obj.entries.length)
                        return null;
                    if (!obj.source)
                        return obj;
                    const fText = obj.isClassFeatureVariant ? {
                        isClassFeatureVariant: true
                    } : null;

                    const isDisplay = [obj.source, ...(obj.otherSources || []).map(it=>it.source)].some(src=>pageFilter.filterBox.toDisplayByFilters(filterValues, ...[{
                        filter: pageFilter.sourceFilter,
                        value: src,
                    }, pageFilter.levelFilter ? {
                        filter: pageFilter.levelFilter,
                        value: level,
                    } : null, {
                        filter: pageFilter.optionsFilter,
                        value: fText,
                    }, ].filter(Boolean), ));

                    return isDisplay ? obj : null;
                }
                ,
                array: (arr)=>{
                    return arr.filter(it=>it != null);
                }
                ,
            }, );
        }
        );
    }
};

Renderer.subclass = class {
    static getCompactRenderedString(sc) {
        const scEntry = {
            type: "section",
            name: sc.name,
            source: sc.source,
            page: sc.page,
            entries: MiscUtil.copyFast((sc.subclassFeatures || []).flat()),
        };

        return Renderer.hover.getGenericCompactRenderedString(scEntry);
    }
};

Renderer.background = class {
    static getCompactRenderedString(bg) {
        return Renderer.generic.getCompactRenderedString(bg, {
            dataProp: "background",
            page: UrlUtil.PG_BACKGROUNDS,
        }, );
    }

    static pGetFluff(bg) {
        return Renderer.utils.pGetFluff({
            entity: bg,
            fnGetFluffData: DataUtil.backgroundFluff.loadJSON.bind(DataUtil.backgroundFluff),
            fluffProp: "backgroundFluff",
        });
    }
}
;

Renderer.backgroundFeature = class {
    static getCompactRenderedString(ent) {
        return Renderer.generic.getCompactRenderedString(ent);
    }
};

Renderer.item = class {
    static _sortProperties(a, b) {
        return SortUtil.ascSort(Renderer.item.getProperty(a, {
            isIgnoreMissing: true
        })?.name || "", Renderer.item.getProperty(b, {
            isIgnoreMissing: true
        })?.name || "");
    }

    static _getPropertiesText(item, {renderer=null}={}) {
        renderer = renderer || Renderer.get();

        if (!item.property) {
            const parts = [];
            if (item.dmg2)
                parts.push(`alt. ${Renderer.item._renderDamage(item.dmg2, {
                    renderer
                })}`);
            if (item.range)
                parts.push(`range ${item.range} ft.`);
            return `${item.dmg1 && parts.length ? " - " : ""}${parts.join(", ")}`;
        }

        let renderedDmg2 = false;

        const renderedProperties = item.property.sort(Renderer.item._sortProperties).map(p=>{
            const pFull = Renderer.item.getProperty(p);

            if (pFull.template) {
                const toRender = Renderer.utils.applyTemplate(item, pFull.template, {
                    fnPreApply: (fullMatch,variablePath)=>{
                        if (variablePath === "item.dmg2")
                            renderedDmg2 = true;
                    }
                    ,
                    mapCustom: {
                        "prop_name": pFull.name
                    },
                }, );

                return renderer.render(toRender);
            } else
                return pFull.name;
        }
        );

        if (!renderedDmg2 && item.dmg2)
            renderedProperties.unshift(`alt. ${Renderer.item._renderDamage(item.dmg2, {
                renderer
            })}`);

        return `${item.dmg1 && renderedProperties.length ? " - " : ""}${renderedProperties.join(", ")}`;
    }

    static _getTaggedDamage(dmg, {renderer=null}={}) {
        if (!dmg)
            return "";

        renderer = renderer || Renderer.get();

        Renderer.stripTags(dmg.trim());

        return renderer.render(`{@damage ${dmg}}`);
    }

    static _renderDamage(dmg, {renderer=null}={}) {
        renderer = renderer || Renderer.get();
        return renderer.render(Renderer.item._getTaggedDamage(dmg, {
            renderer
        }));
    }

    static getDamageAndPropertiesText(item, {renderer=null}={}) {
        renderer = renderer || Renderer.get();

        const damagePartsPre = [];
        const damageParts = [];

        if (item.mastery)
            damagePartsPre.push(`Mastery: ${item.mastery.map(it=>renderer.render(`{@itemMastery ${it}}`)).join(", ")}`);

        if (item.ac != null) {
            const prefix = item.type === "S" ? "+" : "";
            const suffix = (item.type === "LA" || item.bardingType === "LA") || ((item.type === "MA" || item.bardingType === "MA") && item.dexterityMax === null) ? " + Dex" : (item.type === "MA" || item.bardingType === "MA") ? ` + Dex (max ${item.dexterityMax ?? 2})` : "";
            damageParts.push(`AC ${prefix}${item.ac}${suffix}`);
        }
        if (item.acSpecial != null)
            damageParts.push(item.ac != null ? item.acSpecial : `AC ${item.acSpecial}`);

        if (item.dmg1)
            damageParts.push(Renderer.item._renderDamage(item.dmg1, {
                renderer
            }));

        if (item.speed != null)
            damageParts.push(`Speed: ${item.speed}`);
        if (item.carryingCapacity)
            damageParts.push(`Carrying Capacity: ${item.carryingCapacity} lb.`);

        if (item.vehSpeed || item.capCargo || item.capPassenger || item.crew || item.crewMin || item.crewMax || item.vehAc || item.vehHp || item.vehDmgThresh || item.travelCost || item.shippingCost) {
            const vehPartUpper = item.vehSpeed ? `Speed: ${Parser.numberToVulgar(item.vehSpeed)} mph` : null;

            const vehPartMiddle = item.capCargo || item.capPassenger ? `Carrying Capacity: ${[item.capCargo ? `${Parser.numberToFractional(item.capCargo)} ton${item.capCargo === 0 || item.capCargo > 1 ? "s" : ""} cargo` : null, item.capPassenger ? `${item.capPassenger} passenger${item.capPassenger === 1 ? "" : "s"}` : null].filter(Boolean).join(", ")}` : null;

            const {travelCostFull, shippingCostFull} = Parser.itemVehicleCostsToFull(item);

            const vehPartLower = [item.crew ? `Crew ${item.crew}` : null, item.crewMin && item.crewMax ? `Crew ${item.crewMin}-${item.crewMax}` : null, item.vehAc ? `AC ${item.vehAc}` : null, item.vehHp ? `HP ${item.vehHp}${item.vehDmgThresh ? `, Damage Threshold ${item.vehDmgThresh}` : ""}` : null, ].filter(Boolean).join(", ");

            damageParts.push([vehPartUpper, vehPartMiddle,
            travelCostFull ? `Personal Travel Cost: ${travelCostFull} per mile per passenger` : null, shippingCostFull ? `Shipping Cost: ${shippingCostFull} per 100 pounds per mile` : null,
            vehPartLower, ].filter(Boolean).join(renderer.getLineBreak()));
        }

        const damage = [damagePartsPre.join(", "), damageParts.join(", "), ].filter(Boolean).join(renderer.getLineBreak());
        const damageType = item.dmgType ? Parser.dmgTypeToFull(item.dmgType) : "";
        const propertiesTxt = Renderer.item._getPropertiesText(item, {
            renderer
        });

        return [damage, damageType, propertiesTxt];
    }

    static getTypeRarityAndAttunementText(item) {
        const typeRarity = [item._typeHtml === "other" ? "" : item._typeHtml, (item.rarity && Renderer.item.doRenderRarity(item.rarity) ? item.rarity : ""), ].filter(Boolean).join(", ");

        return [item.reqAttune ? `${typeRarity} ${item._attunement}` : typeRarity, item._subTypeHtml || "", item.tier ? `${item.tier} tier` : "", ];
    }

    static getAttunementAndAttunementCatText(item, prop="reqAttune") {
        let attunement = null;
        let attunementCat = VeCt.STR_NO_ATTUNEMENT;
        if (item[prop] != null && item[prop] !== false) {
            if (item[prop] === true) {
                attunementCat = "Requires Attunement";
                attunement = "(requires attunement)";
            } else if (item[prop] === "optional") {
                attunementCat = "Attunement Optional";
                attunement = "(attunement optional)";
            } else if (item[prop].toLowerCase().startsWith("by")) {
                attunementCat = "Requires Attunement By...";
                attunement = `(requires attunement ${Renderer.get().render(item[prop])})`;
            } else {
                attunementCat = "Requires Attunement";
                attunement = `(requires attunement ${Renderer.get().render(item[prop])})`;
            }
        }
        return [attunement, attunementCat];
    }

    static getHtmlAndTextTypes(item) {
        const typeHtml = [];
        const typeListText = [];
        const subTypeHtml = [];

        let showingBase = false;
        if (item.wondrous) {
            typeHtml.push(`wondrous item${item.tattoo ? ` (tattoo)` : ""}`);
            typeListText.push("wondrous item");
        }
        if (item.tattoo) {
            typeListText.push("tattoo");
        }
        if (item.staff) {
            typeHtml.push("staff");
            typeListText.push("staff");
        }
        if (item.ammo) {
            typeHtml.push(`ammunition`);
            typeListText.push("ammunition");
        }
        if (item.firearm) {
            subTypeHtml.push("firearm");
            typeListText.push("firearm");
        }
        if (item.age) {
            subTypeHtml.push(item.age);
            typeListText.push(item.age);
        }
        if (item.weaponCategory) {
            typeHtml.push(`weapon${item.baseItem ? ` (${Renderer.get().render(`{@item ${item.baseItem}}`)})` : ""}`);
            subTypeHtml.push(`${item.weaponCategory} weapon`);
            typeListText.push(`${item.weaponCategory} weapon`);
            showingBase = true;
        }
        if (item.staff && (item.type !== "M" && item.typeAlt !== "M")) {
            subTypeHtml.push("melee weapon");
            typeListText.push("melee weapon");
        }
        if (item.type)
            Renderer.item._getHtmlAndTextTypes_type({
                type: item.type,
                typeHtml,
                typeListText,
                subTypeHtml,
                showingBase,
                item
            });
        if (item.typeAlt)
            Renderer.item._getHtmlAndTextTypes_type({
                type: item.typeAlt,
                typeHtml,
                typeListText,
                subTypeHtml,
                showingBase,
                item
            });
        if (item.poison) {
            typeHtml.push(`poison${item.poisonTypes ? ` (${item.poisonTypes.joinConjunct(", ", " or ")})` : ""}`);
            typeListText.push("poison");
        }
        return [typeListText, typeHtml.join(", "), subTypeHtml.join(", ")];
    }

    static _getHtmlAndTextTypes_type({type, typeHtml, typeListText, subTypeHtml, showingBase, item}) {
        const fullType = Renderer.item.getItemTypeName(type);

        const isSub = (typeListText.some(it=>it.includes("weapon")) && fullType.includes("weapon")) || (typeListText.some(it=>it.includes("armor")) && fullType.includes("armor"));

        if (!showingBase && !!item.baseItem)
            (isSub ? subTypeHtml : typeHtml).push(`${fullType} (${Renderer.get().render(`{@item ${item.baseItem}}`)})`);
        else if (type === "S")
            (isSub ? subTypeHtml : typeHtml).push(Renderer.get().render(`armor ({@item shield|phb})`));
        else
            (isSub ? subTypeHtml : typeHtml).push(fullType);

        typeListText.push(fullType);
    }

    static _GET_RENDERED_ENTRIES_WALKER = null;

    static getRenderedEntries(item, {isCompact=false, wrappedTypeAllowlist=null}={}) {
        const renderer = Renderer.get();

        Renderer.item._GET_RENDERED_ENTRIES_WALKER = Renderer.item._GET_RENDERED_ENTRIES_WALKER || MiscUtil.getWalker({
            keyBlocklist: new Set([...MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST, "data", ]),
        });

        const handlersName = {
            string: (str)=>Renderer.item._getRenderedEntries_handlerConvertNamesToItalics.bind(Renderer.item, item, item.name)(str),
        };

        const handlersVariantName = item._variantName == null ? null : {
            string: (str)=>Renderer.item._getRenderedEntries_handlerConvertNamesToItalics.bind(Renderer.item, item, item._variantName)(str),
        };

        const renderStack = [];
        if (item._fullEntries || item.entries?.length) {
            const entry = MiscUtil.copyFast({
                type: "entries",
                entries: item._fullEntries || item.entries
            });
            let procEntry = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(entry, handlersName);
            if (handlersVariantName)
                procEntry = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(entry, handlersVariantName);
            if (wrappedTypeAllowlist)
                procEntry.entries = procEntry.entries.filter(it=>!it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG] || wrappedTypeAllowlist.has(it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]));
            renderer.recursiveRender(procEntry, renderStack, {
                depth: 1
            });
        }

        if (item._fullAdditionalEntries || item.additionalEntries) {
            const additionEntries = MiscUtil.copyFast({
                type: "entries",
                entries: item._fullAdditionalEntries || item.additionalEntries
            });
            let procAdditionEntries = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(additionEntries, handlersName);
            if (handlersVariantName)
                procAdditionEntries = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(additionEntries, handlersVariantName);
            if (wrappedTypeAllowlist)
                procAdditionEntries.entries = procAdditionEntries.entries.filter(it=>!it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG] || wrappedTypeAllowlist.has(it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]));
            renderer.recursiveRender(procAdditionEntries, renderStack, {
                depth: 1
            });
        }

        if (!isCompact && item.lootTables) {
            renderStack.push(`<div><span class="bold">Found On: </span>${item.lootTables.sort(SortUtil.ascSortLower).map(tbl=>renderer.render(`{@table ${tbl}}`)).join(", ")}</div>`);
        }

        return renderStack.join("").trim();
    }

    static _getRenderedEntries_handlerConvertNamesToItalics(item, baseName, str) {
        if (item._fIsMundane)
            return str;

        const stack = [];
        let depth = 0;

        const tgtLen = baseName.length;
        const tgtName = item.sentient ? baseName : baseName.toLowerCase();

        const tgtNamePlural = tgtName.toPlural();
        const tgtLenPlural = tgtNamePlural.length;

        const tgtNameNoBraces = tgtName.replace(/ \(.*$/, "");
        const tgtLenNoBraces = tgtNameNoBraces.length;

        const len = str.length;
        for (let i = 0; i < len; ++i) {
            const c = str[i];

            switch (c) {
            case "{":
                {
                    if (str[i + 1] === "@")
                        depth++;
                    stack.push(c);
                    break;
                }
            case "}":
                {
                    if (depth)
                        depth--;
                    stack.push(c);
                    break;
                }
            default:
                stack.push(c);
                break;
            }

            if (depth)
                continue;

            if (stack.slice(-tgtLen).join("")[item.sentient ? "toString" : "toLowerCase"]() === tgtName) {
                stack.splice(stack.length - tgtLen, tgtLen, `{@i ${stack.slice(-tgtLen).join("")}}`);
            } else if (stack.slice(-tgtLenPlural).join("")[item.sentient ? "toString" : "toLowerCase"]() === tgtNamePlural) {
                stack.splice(stack.length - tgtLenPlural, tgtLenPlural, `{@i ${stack.slice(-tgtLenPlural).join("")}}`);
            } else if (stack.slice(-tgtLenNoBraces).join("")[item.sentient ? "toString" : "toLowerCase"]() === tgtNameNoBraces) {
                stack.splice(stack.length - tgtLenNoBraces, tgtLenNoBraces, `{@i ${stack.slice(-tgtLenNoBraces).join("")}}`);
            }
        }

        return stack.join("");
    }

    static getCompactRenderedString(item, opts) {
        opts = opts || {};

        const [damage,damageType,propertiesTxt] = Renderer.item.getDamageAndPropertiesText(item);
        const [typeRarityText,subTypeText,tierText] = Renderer.item.getTypeRarityAndAttunementText(item);

        return `
		${Renderer.utils.getExcludedTr({
            entity: item,
            dataProp: "item",
            page: UrlUtil.PG_ITEMS
        })}
		${Renderer.utils.getNameTr(item, {
            page: UrlUtil.PG_ITEMS,
            isEmbeddedEntity: opts.isEmbeddedEntity
        })}
		<tr><td class="rd-item__type-rarity-attunement" colspan="6">${Renderer.item.getTypeRarityAndAttunementHtml(typeRarityText, subTypeText, tierText)}</td></tr>
		<tr>
			<td colspan="2">${[Parser.itemValueToFullMultiCurrency(item), Parser.itemWeightToFull(item)].filter(Boolean).join(", ").uppercaseFirst()}</td>
			<td class="text-right" colspan="4">${damage} ${damageType} ${propertiesTxt}</td>
		</tr>
		${Renderer.item.hasEntries(item) ? `${Renderer.utils.getDividerTr()}<tr class="text"><td colspan="6" class="text">${Renderer.item.getRenderedEntries(item, {
            isCompact: true
        })}</td></tr>` : ""}`;
    }

    static hasEntries(item) {
        return item._fullAdditionalEntries?.length || item._fullEntries?.length || item.entries?.length;
    }

    static getTypeRarityAndAttunementHtml(typeRarityText, subTypeText, tierText) {
        return `<div class="ve-flex-col">
			${typeRarityText || tierText ? `<div class="split ${subTypeText ? "mb-1" : ""}">
				<div class="italic">${(typeRarityText || "").uppercaseFirst()}</div>
				<div class="no-wrap ${tierText ? `ml-2` : ""}">${(tierText || "").uppercaseFirst()}</div>
			</div>` : ""}
			${subTypeText ? `<div class="italic">${subTypeText.uppercaseFirst()}</div>` : ""}
		</div>`;
    }

    static _hiddenRarity = new Set(["none", "unknown", "unknown (magic)", "varies"]);
    static doRenderRarity(rarity) {
        return !Renderer.item._hiddenRarity.has(rarity);
    }

    static _propertyMap = {};
    static _addProperty(prt) {
        if (Renderer.item._propertyMap[prt.abbreviation])
            return;
        const cpy = MiscUtil.copyFast(prt);
        Renderer.item._propertyMap[prt.abbreviation] = prt.name ? cpy : {
            ...cpy,
            name: (prt.entries || prt.entriesTemplate)[0].name.toLowerCase(),
        };
    }

    static getProperty(abbv, {isIgnoreMissing=false}={}) {
        if (!isIgnoreMissing && !Renderer.item._propertyMap[abbv])
            throw new Error(`Item property ${abbv} not found. You probably meant to load the property reference first.`);
        return Renderer.item._propertyMap[abbv];
    }

    static _typeMap = {};
    static _addType(typ) {
        if (Renderer.item._typeMap[typ.abbreviation]?.entries || Renderer.item._typeMap[typ.abbreviation]?.entriesTemplate)
            return;
        const cpy = MiscUtil.copyFast(typ);

        Object.entries(Renderer.item._typeMap[typ.abbreviation] || {}).forEach(([k,v])=>{
            if (cpy[k])
                return;
            cpy[k] = v;
        }
        );

        cpy.name = cpy.name || (cpy.entries || cpy.entriesTemplate)[0].name.toLowerCase();

        Renderer.item._typeMap[typ.abbreviation] = cpy;
    }

    static getType(abbv) {
        if (!Renderer.item._typeMap[abbv])
            throw new Error(`Item type ${abbv} not found. You probably meant to load the type reference first.`);
        return Renderer.item._typeMap[abbv];
    }

    static entryMap = {};
    static _addEntry(ent) {
        if (Renderer.item.entryMap[ent.source]?.[ent.name])
            return;
        MiscUtil.set(Renderer.item.entryMap, ent.source, ent.name, ent);
    }

    static _additionalEntriesMap = {};
    static _addAdditionalEntries(ent) {
        if (Renderer.item._additionalEntriesMap[ent.appliesTo])
            return;
        Renderer.item._additionalEntriesMap[ent.appliesTo] = MiscUtil.copyFast(ent.entries);
    }

    static _masteryMap = {};
    static _addMastery(ent) {
        const lookupSource = ent.source.toLowerCase();
        const lookupName = ent.name.toLowerCase();
        if (Renderer.item._masteryMap[lookupSource]?.[lookupName])
            return;
        MiscUtil.set(Renderer.item._masteryMap, lookupSource, lookupName, ent);
    }

    static _getMastery(uid) {
        const {name, source} = DataUtil.proxy.unpackUid("itemMastery", uid, "itemMastery", {
            isLower: true
        });
        const out = MiscUtil.get(Renderer.item._masteryMap, source, name);
        if (!out)
            throw new Error(`Item mastry ${uid} not found. You probably meant to load the mastery reference first.`);
        return out;
    }

    static async _pAddPrereleaseBrewPropertiesAndTypes() {
        if (typeof PrereleaseUtil !== "undefined")
            Renderer.item.addPrereleaseBrewPropertiesAndTypesFrom({
                data: await PrereleaseUtil.pGetBrewProcessed()
            });
        if (typeof BrewUtil2 !== "undefined")
            Renderer.item.addPrereleaseBrewPropertiesAndTypesFrom({
                data: await BrewUtil2.pGetBrewProcessed()
            });
    }

    static addPrereleaseBrewPropertiesAndTypesFrom({data}) {
        (data.itemProperty || []).forEach(it=>Renderer.item._addProperty(it));
        (data.itemType || []).forEach(it=>Renderer.item._addType(it));
        (data.itemEntry || []).forEach(it=>Renderer.item._addEntry(it));
        (data.itemTypeAdditionalEntries || []).forEach(it=>Renderer.item._addAdditionalEntries(it));
        (data.itemMastery || []).forEach(it=>Renderer.item._addMastery(it));
    }

    static _addBasePropertiesAndTypes(baseItemData) {
        Object.entries(Parser.ITEM_TYPE_JSON_TO_ABV).forEach(([abv,name])=>Renderer.item._addType({
            abbreviation: abv,
            name
        }));

        (baseItemData.itemProperty || []).forEach(it=>Renderer.item._addProperty(it));
        (baseItemData.itemType || []).forEach(it=>Renderer.item._addType(it));
        (baseItemData.itemEntry || []).forEach(it=>Renderer.item._addEntry(it));
        (baseItemData.itemTypeAdditionalEntries || []).forEach(it=>Renderer.item._addAdditionalEntries(it));
        (baseItemData.itemMastery || []).forEach(it=>Renderer.item._addMastery(it));

        baseItemData.baseitem.forEach(it=>it._isBaseItem = true);
    }

    static async _pGetSiteUnresolvedRefItems_pLoadItems() {
        const itemData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items.json`);
        const items = itemData.item;
        itemData.itemGroup.forEach(it=>it._isItemGroup = true);
        return [...items, ...itemData.itemGroup];
    }

    static async pGetSiteUnresolvedRefItems() {
        const itemList = await Renderer.item._pGetSiteUnresolvedRefItems_pLoadItems();
        const baseItemsJson = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items-base.json`);
        const baseItems = await Renderer.item._pGetAndProcBaseItems(baseItemsJson);
        const {genericVariants, linkedLootTables} = await Renderer.item._pGetCacheSiteGenericVariants();
        const specificVariants = Renderer.item._createSpecificVariants(baseItems, genericVariants, {
            linkedLootTables
        });
        const allItems = [...itemList, ...baseItems, ...genericVariants, ...specificVariants];
        Renderer.item._enhanceItems(allItems);

        return {
            item: allItems,
            itemEntry: baseItemsJson.itemEntry,
        };
    }

    static _pGettingSiteGenericVariants = null;
    static async _pGetCacheSiteGenericVariants() {
        Renderer.item._pGettingSiteGenericVariants = Renderer.item._pGettingSiteGenericVariants || (async()=>{
            const [genericVariants,linkedLootTables] = Renderer.item._getAndProcGenericVariants(await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/magicvariants.json`));
            return {
                genericVariants,
                linkedLootTables
            };
        }
        )();
        return Renderer.item._pGettingSiteGenericVariants;
    }

    static async pBuildList() {
        return DataLoader.pCacheAndGetAllSite(UrlUtil.PG_ITEMS);
    }

    static async _pGetAndProcBaseItems(baseItemData) {
        Renderer.item._addBasePropertiesAndTypes(baseItemData);
        await Renderer.item._pAddPrereleaseBrewPropertiesAndTypes();
        return baseItemData.baseitem;
    }

    static _getAndProcGenericVariants(variantData) {
        variantData.magicvariant.forEach(Renderer.item._genericVariants_addInheritedPropertiesToSelf);
        return [variantData.magicvariant, variantData.linkedLootTables];
    }

    static _initFullEntries(item) {
        Renderer.utils.initFullEntries_(item);
    }

    static _initFullAdditionalEntries(item) {
        Renderer.utils.initFullEntries_(item, {
            propEntries: "additionalEntries",
            propFullEntries: "_fullAdditionalEntries"
        });
    }

    static _createSpecificVariants(baseItems, genericVariants, opts) {
        opts = opts || {};

        const genericAndSpecificVariants = [];
        baseItems.forEach((curBaseItem)=>{
            curBaseItem._category = "Basic";
            if (curBaseItem.entries == null)
                curBaseItem.entries = [];

            if (curBaseItem.packContents)
                return;
            genericVariants.forEach((curGenericVariant)=>{
                if (!Renderer.item._createSpecificVariants_hasRequiredProperty(curBaseItem, curGenericVariant))
                    return;
                if (Renderer.item._createSpecificVariants_hasExcludedProperty(curBaseItem, curGenericVariant))
                    return;

                genericAndSpecificVariants.push(Renderer.item._createSpecificVariants_createSpecificVariant(curBaseItem, curGenericVariant, opts));
            }
            );
        }
        );
        return genericAndSpecificVariants;
    }

    static _createSpecificVariants_hasRequiredProperty(baseItem, genericVariant) {
        return genericVariant.requires.some(req=>Renderer.item._createSpecificVariants_isRequiresExcludesMatch(baseItem, req, "every"));
    }

    static _createSpecificVariants_hasExcludedProperty(baseItem, genericVariant) {
        const curExcludes = genericVariant.excludes || {};
        return Renderer.item._createSpecificVariants_isRequiresExcludesMatch(baseItem, genericVariant.excludes, "some");
    }

    static _createSpecificVariants_isRequiresExcludesMatch(candidate, requirements, method) {
        if (candidate == null || requirements == null)
            return false;

        return Object.entries(requirements)[method](([reqKey,reqVal])=>{
            if (reqVal instanceof Array) {
                return candidate[reqKey]instanceof Array ? candidate[reqKey].some(it=>reqVal.includes(it)) : reqVal.includes(candidate[reqKey]);
            }

            if (reqVal != null && typeof reqVal === "object") {
                return Renderer.item._createSpecificVariants_isRequiresExcludesMatch(candidate[reqKey], reqVal, method);
            }

            return candidate[reqKey]instanceof Array ? candidate[reqKey].some(it=>reqVal === it) : reqVal === candidate[reqKey];
        }
        );
    }

    static _createSpecificVariants_createSpecificVariant(baseItem, genericVariant, opts) {
        const inherits = genericVariant.inherits;
        const specificVariant = MiscUtil.copyFast(baseItem);

        specificVariant.__prop = "item";

        delete specificVariant._isBaseItem;

        specificVariant._isEnhanced = false;
        delete specificVariant._fullEntries;

        specificVariant._baseName = baseItem.name;
        specificVariant._baseSrd = baseItem.srd;
        specificVariant._baseBasicRules = baseItem.basicRules;
        if (baseItem.source !== inherits.source)
            specificVariant._baseSource = baseItem.source;

        specificVariant._variantName = genericVariant.name;

        delete specificVariant.value;

        delete specificVariant.srd;
        delete specificVariant.basicRules;
        delete specificVariant.page;

        delete specificVariant.hasFluff;
        delete specificVariant.hasFluffImages;

        specificVariant._category = "Specific Variant";
        Object.entries(inherits).forEach(([inheritedProperty,val])=>{
            switch (inheritedProperty) {
            case "namePrefix":
                specificVariant.name = `${val}${specificVariant.name}`;
                break;
            case "nameSuffix":
                specificVariant.name = `${specificVariant.name}${val}`;
                break;
            case "entries":
                {
                    Renderer.item._initFullEntries(specificVariant);

                    const appliedPropertyEntries = Renderer.applyAllProperties(val, Renderer.item._getInjectableProps(baseItem, inherits));
                    appliedPropertyEntries.forEach((ent,i)=>specificVariant._fullEntries.splice(i, 0, ent));
                    break;
                }
            case "vulnerable":
            case "resist":
            case "immune":
                {
                    break;
                }
            case "conditionImmune":
                {
                    specificVariant[inheritedProperty] = [...specificVariant[inheritedProperty] || [], ...val].unique();
                    break;
                }
            case "nameRemove":
                {
                    specificVariant.name = specificVariant.name.replace(new RegExp(val.escapeRegexp(),"g"), "");

                    break;
                }
            case "weightExpression":
            case "valueExpression":
                {
                    const exp = Renderer.item._createSpecificVariants_evaluateExpression(baseItem, specificVariant, inherits, inheritedProperty);

                    const result = Renderer.dice.parseRandomise2(exp);
                    if (result != null) {
                        switch (inheritedProperty) {
                        case "weightExpression":
                            specificVariant.weight = result;
                            break;
                        case "valueExpression":
                            specificVariant.value = result;
                            break;
                        }
                    }

                    break;
                }
            case "barding":
                {
                    specificVariant.bardingType = baseItem.type;
                    break;
                }
            case "propertyAdd":
                {
                    specificVariant.property = [...(specificVariant.property || []), ...val.filter(it=>!specificVariant.property || !specificVariant.property.includes(it)), ];
                    break;
                }
            case "propertyRemove":
                {
                    if (specificVariant.property) {
                        specificVariant.property = specificVariant.property.filter(it=>!val.includes(it));
                        if (!specificVariant.property.length)
                            delete specificVariant.property;
                    }
                    break;
                }
            default:
                specificVariant[inheritedProperty] = val;
            }
        }
        );

        Renderer.item._createSpecificVariants_mergeVulnerableResistImmune({
            specificVariant,
            inherits
        });

        genericVariant.variants = genericVariant.variants || [];
        if (!genericVariant.variants.some(it=>it.base?.name === baseItem.name && it.base?.source === baseItem.source))
            genericVariant.variants.push({
                base: baseItem,
                specificVariant
            });

        specificVariant.genericVariant = {
            name: genericVariant.name,
            source: genericVariant.source,
        };

        if (opts.linkedLootTables && opts.linkedLootTables[specificVariant.source] && opts.linkedLootTables[specificVariant.source][specificVariant.name]) {
            (specificVariant.lootTables = specificVariant.lootTables || []).push(...opts.linkedLootTables[specificVariant.source][specificVariant.name]);
        }

        if (baseItem.source !== Parser.SRC_PHB && baseItem.source !== Parser.SRC_DMG) {
            Renderer.item._initFullEntries(specificVariant);
            specificVariant._fullEntries.unshift({
                type: "wrapper",
                wrapped: `{@note The {@item ${baseItem.name}|${baseItem.source}|base item} can be found in ${Parser.sourceJsonToFull(baseItem.source)}${baseItem.page ? `, page ${baseItem.page}` : ""}.}`,
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "note",
                },
            });
        }

        return specificVariant;
    }

    static _createSpecificVariants_evaluateExpression(baseItem, specificVariant, inherits, inheritedProperty) {
        return inherits[inheritedProperty].replace(/\[\[([^\]]+)]]/g, (...m)=>{
            const propPath = m[1].split(".");
            return propPath[0] === "item" ? MiscUtil.get(specificVariant, ...propPath.slice(1)) : propPath[0] === "baseItem" ? MiscUtil.get(baseItem, ...propPath.slice(1)) : MiscUtil.get(specificVariant, ...propPath);
        }
        );
    }

    static _PROPS_VULN_RES_IMMUNE = ["vulnerable", "resist", "immune", ];
    static _createSpecificVariants_mergeVulnerableResistImmune({specificVariant, inherits}) {
        const fromBase = {};
        Renderer.item._PROPS_VULN_RES_IMMUNE.filter(prop=>specificVariant[prop]).forEach(prop=>fromBase[prop] = [...specificVariant[prop]]);

        Renderer.item._PROPS_VULN_RES_IMMUNE.forEach(prop=>{
            const val = inherits[prop];

            if (val === undefined)
                return;

            if (val == null)
                return delete fromBase[prop];

            const valSet = new Set();
            val.forEach(it=>{
                if (typeof it === "string")
                    valSet.add(it);
                if (!it?.[prop]?.length)
                    return;
                it?.[prop].forEach(itSub=>{
                    if (typeof itSub === "string")
                        valSet.add(itSub);
                }
                );
            }
            );

            Renderer.item._PROPS_VULN_RES_IMMUNE.filter(it=>it !== prop).forEach(propOther=>{
                if (!fromBase[propOther])
                    return;

                fromBase[propOther] = fromBase[propOther].filter(it=>{
                    if (typeof it === "string")
                        return !valSet.has(it);

                    if (it?.[propOther]?.length) {
                        it[propOther] = it[propOther].filter(itSub=>{
                            if (typeof itSub === "string")
                                return !valSet.has(itSub);
                            return true;
                        }
                        );
                    }

                    return true;
                }
                );

                if (!fromBase[propOther].length)
                    delete fromBase[propOther];
            }
            );
        }
        );

        Renderer.item._PROPS_VULN_RES_IMMUNE.forEach(prop=>{
            if (fromBase[prop] || inherits[prop])
                specificVariant[prop] = [...(fromBase[prop] || []), ...(inherits[prop] || [])].unique();
            else
                delete specificVariant[prop];
        }
        );
    }

    static _enhanceItems(allItems) {
        allItems.forEach((item)=>Renderer.item.enhanceItem(item));
        return allItems;
    }

    static async pGetGenericAndSpecificVariants(genericVariants, opts) {
        opts = opts || {};

        let baseItems;
        if (opts.baseItems) {
            baseItems = opts.baseItems;
        } else {
            const baseItemData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items-base.json`);
            Renderer.item._addBasePropertiesAndTypes(baseItemData);
            baseItems = [...baseItemData.baseitem, ...(opts.additionalBaseItems || [])];
        }

        await Renderer.item._pAddPrereleaseBrewPropertiesAndTypes();
        genericVariants.forEach(Renderer.item._genericVariants_addInheritedPropertiesToSelf);
        const specificVariants = Renderer.item._createSpecificVariants(baseItems, genericVariants);
        const outSpecificVariants = Renderer.item._enhanceItems(specificVariants);

        if (opts.isSpecificVariantsOnly)
            return outSpecificVariants;

        const outGenericVariants = Renderer.item._enhanceItems(genericVariants);
        return [...outGenericVariants, ...outSpecificVariants];
    }

    static _getInjectableProps(baseItem, inherits) {
        return {
            baseName: baseItem.name,
            dmgType: baseItem.dmgType ? Parser.dmgTypeToFull(baseItem.dmgType) : null,
            bonusAc: inherits.bonusAc,
            bonusWeapon: inherits.bonusWeapon,
            bonusWeaponAttack: inherits.bonusWeaponAttack,
            bonusWeaponDamage: inherits.bonusWeaponDamage,
            bonusWeaponCritDamage: inherits.bonusWeaponCritDamage,
            bonusSpellAttack: inherits.bonusSpellAttack,
            bonusSpellSaveDc: inherits.bonusSpellSaveDc,
            bonusSavingThrow: inherits.bonusSavingThrow,
        };
    }

    static _INHERITED_PROPS_BLOCKLIST = new Set(["entries", "rarity",
    "namePrefix", "nameSuffix", ]);
    static _genericVariants_addInheritedPropertiesToSelf(genericVariant) {
        if (genericVariant._isInherited)
            return;
        genericVariant._isInherited = true;

        for (const prop in genericVariant.inherits) {
            if (Renderer.item._INHERITED_PROPS_BLOCKLIST.has(prop))
                continue;

            const val = genericVariant.inherits[prop];

            if (val == null)
                delete genericVariant[prop];
            else if (genericVariant[prop]) {
                if (genericVariant[prop]instanceof Array && val instanceof Array)
                    genericVariant[prop] = MiscUtil.copyFast(genericVariant[prop]).concat(val);
                else
                    genericVariant[prop] = val;
            } else
                genericVariant[prop] = genericVariant.inherits[prop];
        }

        if (!genericVariant.entries && genericVariant.inherits.entries) {
            genericVariant.entries = MiscUtil.copyFast(Renderer.applyAllProperties(genericVariant.inherits.entries, genericVariant.inherits));
        }

        if (genericVariant.inherits.rarity == null)
            delete genericVariant.rarity;
        else if (genericVariant.inherits.rarity === "varies") {} else
            genericVariant.rarity = genericVariant.inherits.rarity;

        if (genericVariant.requires.armor)
            genericVariant.armor = genericVariant.requires.armor;
    }

    static getItemTypeName(t) {
        return Renderer.item.getType(t).name?.toLowerCase() || t;
    }

    static enhanceItem(item) {
        if (item._isEnhanced)
            return;
        item._isEnhanced = true;
        if (item.noDisplay)
            return;
        if (item.type === "GV")
            item._category = "Generic Variant";
        if (item._category == null)
            item._category = "Other";
        if (item.entries == null)
            item.entries = [];
        if (item.type && (Renderer.item.getType(item.type)?.entries || Renderer.item.getType(item.type)?.entriesTemplate)) {
            Renderer.item._initFullEntries(item);

            const propetyEntries = Renderer.item._enhanceItem_getItemPropertyTypeEntries({
                item,
                ent: Renderer.item.getType(item.type)
            });
            propetyEntries.forEach(e=>item._fullEntries.push({
                type: "wrapper",
                wrapped: e,
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                }
            }));
        }
        if (item.property) {
            item.property.forEach(p=>{
                const entProperty = Renderer.item.getProperty(p);
                if (!entProperty.entries && !entProperty.entriesTemplate)
                    return;

                Renderer.item._initFullEntries(item);

                const propetyEntries = Renderer.item._enhanceItem_getItemPropertyTypeEntries({
                    item,
                    ent: entProperty
                });
                propetyEntries.forEach(e=>item._fullEntries.push({
                    type: "wrapper",
                    wrapped: e,
                    data: {
                        [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "property"
                    }
                }));
            }
            );
        }
        if (item.type === "LA" || item.type === "MA" || item.type === "HA") {
            if (item.stealth) {
                Renderer.item._initFullEntries(item);
                item._fullEntries.push({
                    type: "wrapper",
                    wrapped: "The wearer has disadvantage on Dexterity ({@skill Stealth}) checks.",
                    data: {
                        [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                    }
                });
            }
            if (item.type === "HA" && item.strength) {
                Renderer.item._initFullEntries(item);
                item._fullEntries.push({
                    type: "wrapper",
                    wrapped: `If the wearer has a Strength score lower than ${item.strength}, their speed is reduced by 10 feet.`,
                    data: {
                        [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                    }
                });
            }
        }
        if (item.type === "SCF") {
            if (item._isItemGroup) {
                if (item.scfType === "arcane" && item.source !== Parser.SRC_ERLW) {
                    Renderer.item._initFullEntries(item);
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "An arcane focus is a special item\u2014an orb, a crystal, a rod, a specially constructed staff, a wand-like length of wood, or some similar item\u2014designed to channel the power of arcane spells. A sorcerer, warlock, or wizard can use such an item as a spellcasting focus.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
                if (item.scfType === "druid") {
                    Renderer.item._initFullEntries(item);
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "A druidic focus might be a sprig of mistletoe or holly, a wand or scepter made of yew or another special wood, a staff drawn whole out of a living tree, or a totem object incorporating feathers, fur, bones, and teeth from sacred animals. A druid can use such an object as a spellcasting focus.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
                if (item.scfType === "holy") {
                    Renderer.item._initFullEntries(item);
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "A holy symbol is a representation of a god or pantheon. It might be an amulet depicting a symbol representing a deity, the same symbol carefully engraved or inlaid as an emblem on a shield, or a tiny box holding a fragment of a sacred relic. A cleric or paladin can use a holy symbol as a spellcasting focus. To use the symbol in this way, the caster must hold it in hand, wear it visibly, or bear it on a shield.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
            } else {
                if (item.scfType === "arcane") {
                    Renderer.item._initFullEntries(item);
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "An arcane focus is a special item designed to channel the power of arcane spells. A sorcerer, warlock, or wizard can use such an item as a spellcasting focus.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
                if (item.scfType === "druid") {
                    Renderer.item._initFullEntries(item);
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "A druid can use this object as a spellcasting focus.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
                if (item.scfType === "holy") {
                    Renderer.item._initFullEntries(item);

                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "A holy symbol is a representation of a god or pantheon.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "A cleric or paladin can use a holy symbol as a spellcasting focus. To use the symbol in this way, the caster must hold it in hand, wear it visibly, or bear it on a shield.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
            }
        }

        (item.mastery || []).forEach(uid=>{
            const mastery = Renderer.item._getMastery(uid);

            if (!mastery)
                throw new Error(`Item mastery ${uid} not found. You probably meant to load the property/type reference first; see \`Renderer.item.pPopulatePropertyAndTypeReference()\`.`);
            if (!mastery.entries && !mastery.entriesTemplate)
                return;

            Renderer.item._initFullEntries(item);

            item._fullEntries.push({
                type: "wrapper",
                wrapped: {
                    type: "entries",
                    name: `Mastery: ${mastery.name}`,
                    source: mastery.source,
                    page: mastery.page,
                    entries: Renderer.item._enhanceItem_getItemPropertyTypeEntries({
                        item,
                        ent: mastery
                    }),
                },
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "mastery",
                },
            });
        }
        );

        if (item.type === "T" || item.type === "AT" || item.type === "INS" || item.type === "GS") {
            Renderer.item._initFullAdditionalEntries(item);
            item._fullAdditionalEntries.push({
                type: "wrapper",
                wrapped: {
                    type: "hr"
                },
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                }
            });
            item._fullAdditionalEntries.push({
                type: "wrapper",
                wrapped: `{@note See the {@variantrule Tool Proficiencies|XGE} entry for more information.}`,
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                }
            });
        }

        if (item.type === "INS" || item.type === "GS")
            item.additionalSources = item.additionalSources || [];
        if (item.type === "INS") {
            if (!item.additionalSources.find(it=>it.source === "XGE" && it.page === 83))
                item.additionalSources.push({
                    "source": "XGE",
                    "page": 83
                });
        } else if (item.type === "GS") {
            if (!item.additionalSources.find(it=>it.source === "XGE" && it.page === 81))
                item.additionalSources.push({
                    "source": "XGE",
                    "page": 81
                });
        }

        if (item.type && Renderer.item._additionalEntriesMap[item.type]) {
            Renderer.item._initFullAdditionalEntries(item);
            const additional = Renderer.item._additionalEntriesMap[item.type];
            item._fullAdditionalEntries.push({
                type: "wrapper",
                wrapped: {
                    type: "entries",
                    entries: additional
                },
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                }
            });
        }

        const [typeListText,typeHtml,subTypeHtml] = Renderer.item.getHtmlAndTextTypes(item);
        item._typeListText = typeListText;
        item._typeHtml = typeHtml;
        item._subTypeHtml = subTypeHtml;

        const [attune,attuneCat] = Renderer.item.getAttunementAndAttunementCatText(item);
        item._attunement = attune;
        item._attunementCategory = attuneCat;

        if (item.reqAttuneAlt) {
            const [attuneAlt,attuneCatAlt] = Renderer.item.getAttunementAndAttunementCatText(item, "reqAttuneAlt");
            item._attunementCategory = [attuneCat, attuneCatAlt];
        }

        if (item._isItemGroup) {
            Renderer.item._initFullEntries(item);
            item._fullEntries.push({
                type: "wrapper",
                wrapped: "Multiple variations of this item exist, as listed below:",
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "magicvariant"
                }
            });
            item._fullEntries.push({
                type: "wrapper",
                wrapped: {
                    type: "list",
                    items: item.items.map(it=>typeof it === "string" ? `{@item ${it}}` : `{@item ${it.name}|${it.source}}`),
                },
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "magicvariant"
                },
            });
        }

        if (item.variants && item.variants.length) {
            item.variants.sort((a,b)=>SortUtil.ascSortLower(a.base.name, b.base.name) || SortUtil.ascSortLower(a.base.source, b.base.source));

            Renderer.item._initFullEntries(item);
            item._fullEntries.push({
                type: "wrapper",
                wrapped: {
                    type: "entries",
                    name: "Base items",
                    entries: ["This item variant can be applied to the following base items:", {
                        type: "list",
                        items: item.variants.map(({base, specificVariant})=>{
                            return `{@item ${base.name}|${base.source}} ({@item ${specificVariant.name}|${specificVariant.source}})`;
                        }
                        ),
                    }, ],
                },
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "magicvariant"
                },
            });
        }
    }

    static _enhanceItem_getItemPropertyTypeEntries({item, ent}) {
        if (!ent.entriesTemplate)
            return MiscUtil.copyFast(ent.entries);
        return MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
        }).walk(MiscUtil.copyFast(ent.entriesTemplate), {
            string: (str)=>{
                return Renderer.utils.applyTemplate(item, str, );
            }
            ,
        }, );
    }

    static unenhanceItem(item) {
        if (!item._isEnhanced)
            return;
        delete item._isEnhanced;
        delete item._fullEntries;
    }

    static async pGetSiteUnresolvedRefItemsFromPrereleaseBrew({brewUtil, brew=null}) {
        if (brewUtil == null && brew == null)
            return [];

        brew = brew || await brewUtil.pGetBrewProcessed();

        (brew.itemProperty || []).forEach(p=>Renderer.item._addProperty(p));
        (brew.itemType || []).forEach(t=>Renderer.item._addType(t));
        (brew.itemEntry || []).forEach(it=>Renderer.item._addEntry(it));
        (brew.itemTypeAdditionalEntries || []).forEach(it=>Renderer.item._addAdditionalEntries(it));

        let items = [...(brew.baseitem || []), ...(brew.item || [])];

        if (brew.itemGroup) {
            const itemGroups = MiscUtil.copyFast(brew.itemGroup);
            itemGroups.forEach(it=>it._isItemGroup = true);
            items = [...items, ...itemGroups];
        }

        Renderer.item._enhanceItems(items);

        let isReEnhanceVariants = false;

        if (brew.baseitem && brew.baseitem.length) {
            isReEnhanceVariants = true;

            const {genericVariants} = await Renderer.item._pGetCacheSiteGenericVariants();

            const variants = await Renderer.item.pGetGenericAndSpecificVariants(genericVariants, {
                baseItems: brew.baseitem || [],
                isSpecificVariantsOnly: true
            }, );
            items = [...items, ...variants];
        }

        if (brew.magicvariant && brew.magicvariant.length) {
            isReEnhanceVariants = true;

            const variants = await Renderer.item.pGetGenericAndSpecificVariants(brew.magicvariant, {
                additionalBaseItems: brew.baseitem || []
            }, );
            items = [...items, ...variants];
        }

        if (isReEnhanceVariants) {
            const {genericVariants} = await Renderer.item._pGetCacheSiteGenericVariants();
            genericVariants.forEach(item=>{
                Renderer.item.unenhanceItem(item);
                Renderer.item.enhanceItem(item);
            }
            );
        }

        return items;
    }

    static async pGetItemsFromPrerelease() {
        return DataLoader.pCacheAndGetAllPrerelease(UrlUtil.PG_ITEMS);
    }

    static async pGetItemsFromBrew() {
        return DataLoader.pCacheAndGetAllBrew(UrlUtil.PG_ITEMS);
    }

    static _pPopulatePropertyAndTypeReference = null;
    static pPopulatePropertyAndTypeReference() {
        return Renderer.item._pPopulatePropertyAndTypeReference || (async()=>{
            const data = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items-base.json`);

            Object.entries(Parser.ITEM_TYPE_JSON_TO_ABV).forEach(([abv,name])=>Renderer.item._addType({
                abbreviation: abv,
                name
            }));
            data.itemProperty.forEach(p=>Renderer.item._addProperty(p));
            data.itemType.forEach(t=>Renderer.item._addType(t));
            data.itemEntry.forEach(it=>Renderer.item._addEntry(it));
            data.itemTypeAdditionalEntries.forEach(e=>Renderer.item._addAdditionalEntries(e));

            await Renderer.item._pAddPrereleaseBrewPropertiesAndTypes();
        }
        )();
    }

    static async getAllIndexableItems(rawVariants, rawBaseItems) {
        const basicItems = await Renderer.item._pGetAndProcBaseItems(rawBaseItems);
        const [genericVariants,linkedLootTables] = await Renderer.item._getAndProcGenericVariants(rawVariants);
        const specificVariants = Renderer.item._createSpecificVariants(basicItems, genericVariants, {
            linkedLootTables
        });

        [...genericVariants, ...specificVariants].forEach(item=>{
            if (item.variants)
                delete item.variants;
        }
        );

        return specificVariants;
    }

    static isMundane(item) {
        return item.rarity === "none" || item.rarity === "unknown" || item._category === "Basic";
    }

    static isExcluded(item, {hash=null}={}) {
        const name = item.name;
        const source = item.source || item.inherits?.source;

        hash = hash || UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
            name,
            source
        });

        if (ExcludeUtil.isExcluded(hash, "item", source))
            return true;

        if (item._isBaseItem)
            return ExcludeUtil.isExcluded(hash, "baseitem", source);
        if (item._isItemGroup)
            return ExcludeUtil.isExcluded(hash, "itemGroup", source);
        if (item._variantName) {
            if (ExcludeUtil.isExcluded(hash, "_specificVariant", source))
                return true;

            const baseHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
                name: item._baseName,
                source: item._baseSource || source
            });
            if (ExcludeUtil.isExcluded(baseHash, "baseitem", item._baseSource || source))
                return true;

            const variantHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
                name: item._variantName,
                source: source
            });
            return ExcludeUtil.isExcluded(variantHash, "magicvariant", source);
        }
        if (item.type === "GV")
            return ExcludeUtil.isExcluded(hash, "magicvariant", source);

        return false;
    }

    static pGetFluff(item) {
        return Renderer.utils.pGetFluff({
            entity: item,
            fnGetFluffData: DataUtil.itemFluff.loadJSON.bind(DataUtil.itemFluff),
            fluffProp: "itemFluff",
        });
    }
};

Renderer.spell = class {
    static getCompactRenderedString(spell, opts) {
        opts = opts || {};

        const renderer = Renderer.get();
        const renderStack = [];

        renderStack.push(`
			${Renderer.utils.getExcludedTr({
            entity: spell,
            dataProp: "spell",
            page: UrlUtil.PG_SPELLS
        })}
			${Renderer.utils.getNameTr(spell, {
            page: UrlUtil.PG_SPELLS,
            isEmbeddedEntity: opts.isEmbeddedEntity
        })}
			<tr><td colspan="6">
				<table class="w-100 summary stripe-even-table">
					<tr>
						<th colspan="1">Level</th>
						<th colspan="1">School</th>
						<th colspan="2">Casting Time</th>
						<th colspan="2">Range</th>
					</tr>
					<tr>
						<td colspan="1">${Parser.spLevelToFull(spell.level)}${Parser.spMetaToFull(spell.meta)}</td>
						<td colspan="1">${Parser.spSchoolAndSubschoolsAbvsToFull(spell.school, spell.subschools)}</td>
						<td colspan="2">${Parser.spTimeListToFull(spell.time)}</td>
						<td colspan="2">${Parser.spRangeToFull(spell.range)}</td>
					</tr>
					<tr>
						<th colspan="4">Components</th>
						<th colspan="2">Duration</th>
					</tr>
					<tr>
						<td colspan="4">${Parser.spComponentsToFull(spell.components, spell.level)}</td>
						<td colspan="2">${Parser.spDurationToFull(spell.duration)}</td>
					</tr>
				</table>
			</td></tr>
		`);

        renderStack.push(`<tr class="text"><td colspan="6" class="text">`);
        const entryList = {
            type: "entries",
            entries: spell.entries
        };
        renderer.recursiveRender(entryList, renderStack, {
            depth: 1
        });
        if (spell.entriesHigherLevel) {
            const higherLevelsEntryList = {
                type: "entries",
                entries: spell.entriesHigherLevel
            };
            renderer.recursiveRender(higherLevelsEntryList, renderStack, {
                depth: 2
            });
        }
        const fromClassList = Renderer.spell.getCombinedClasses(spell, "fromClassList");
        if (fromClassList.length) {
            const [current] = Parser.spClassesToCurrentAndLegacy(fromClassList);
            renderStack.push(`<div><span class="bold">Classes: </span>${Parser.spMainClassesToFull(current)}</div>`);
        }
        renderStack.push(`</td></tr>`);

        return renderStack.join("");
    }

    static _SpellSourceManager = class {
        _cache = null;

        populate({brew, isForce=false}) {
            if (this._cache && !isForce)
                return;

            this._cache = {
                classes: {},

                groups: {},

                races: {},
                backgrounds: {},
                feats: {},
                optionalfeatures: {},
            };

            (brew.class || []).forEach(c=>{
                c.source = c.source || Parser.SRC_PHB;

                (c.classSpells || []).forEach(itm=>{
                    this._populate_fromClass_classSubclass({
                        itm,
                        className: c.name,
                        classSource: c.source,
                    });

                    this._populate_fromClass_group({
                        itm,
                        className: c.name,
                        classSource: c.source,
                    });
                }
                );
            }
            );

            (brew.subclass || []).forEach(sc=>{
                sc.classSource = sc.classSource || Parser.SRC_PHB;
                sc.shortName = sc.shortName || sc.name;
                sc.source = sc.source || sc.classSource;

                (sc.subclassSpells || []).forEach(itm=>{
                    this._populate_fromClass_classSubclass({
                        itm,
                        className: sc.className,
                        classSource: sc.classSource,
                        subclassShortName: sc.shortName,
                        subclassName: sc.name,
                        subclassSource: sc.source,
                    });

                    this._populate_fromClass_group({
                        itm,
                        className: sc.className,
                        classSource: sc.classSource,
                        subclassShortName: sc.shortName,
                        subclassName: sc.name,
                        subclassSource: sc.source,
                    });
                }
                );

                Object.entries(sc.subSubclassSpells || {}).forEach(([subSubclassName,arr])=>{
                    arr.forEach(itm=>{
                        this._populate_fromClass_classSubclass({
                            itm,
                            className: sc.className,
                            classSource: sc.classSource,
                            subclassShortName: sc.shortName,
                            subclassName: sc.name,
                            subclassSource: sc.source,
                            subSubclassName,
                        });

                        this._populate_fromClass_group({
                            itm,
                            className: sc.className,
                            classSource: sc.classSource,
                            subclassShortName: sc.shortName,
                            subclassName: sc.name,
                            subclassSource: sc.source,
                            subSubclassName,
                        });
                    }
                    );
                }
                );
            }
            );

            (brew.spellList || []).forEach(spellList=>this._populate_fromGroup_group({
                spellList
            }));
        }

        _populate_fromClass_classSubclass({itm, className, classSource, subclassShortName, subclassName, subclassSource, subSubclassName, }, ) {
            if (itm.groupName)
                return;

            if (itm.className) {
                return this._populate_fromClass_doAdd({
                    tgt: MiscUtil.getOrSet(this._cache.classes, "class", (itm.classSource || Parser.SRC_PHB).toLowerCase(), itm.className.toLowerCase(), {}, ),
                    className,
                    classSource,
                    subclassShortName,
                    subclassName,
                    subclassSource,
                    subSubclassName,
                });
            }

            let[name,source] = `${itm}`.toLowerCase().split("|");
            source = source || Parser.SRC_PHB.toLowerCase();

            this._populate_fromClass_doAdd({
                tgt: MiscUtil.getOrSet(this._cache.classes, "spell", source, name, {
                    fromClassList: [],
                    fromSubclass: []
                }, ),
                className,
                classSource,
                subclassShortName,
                subclassName,
                subclassSource,
                subSubclassName,
            });
        }

        _populate_fromClass_doAdd({tgt, className, classSource, subclassShortName, subclassName, subclassSource, subSubclassName, schools, }, ) {
            if (subclassShortName) {
                const toAdd = {
                    class: {
                        name: className,
                        source: classSource
                    },
                    subclass: {
                        name: subclassName || subclassShortName,
                        shortName: subclassShortName,
                        source: subclassSource
                    },
                };
                if (subSubclassName)
                    toAdd.subclass.subSubclass = subSubclassName;
                if (schools)
                    toAdd.schools = schools;

                tgt.fromSubclass = tgt.fromSubclass || [];
                tgt.fromSubclass.push(toAdd);
                return;
            }

            const toAdd = {
                name: className,
                source: classSource
            };
            if (schools)
                toAdd.schools = schools;

            tgt.fromClassList = tgt.fromClassList || [];
            tgt.fromClassList.push(toAdd);
        }

        _populate_fromClass_group({itm, className, classSource, subclassShortName, subclassName, subclassSource, subSubclassName, }, ) {
            if (!itm.groupName)
                return;

            return this._populate_fromClass_doAdd({
                tgt: MiscUtil.getOrSet(this._cache.classes, "group", (itm.groupSource || Parser.SRC_PHB).toLowerCase(), itm.groupName.toLowerCase(), {}, ),
                className,
                classSource,
                subclassShortName,
                subclassName,
                subclassSource,
                subSubclassName,
                schools: itm.spellSchools,
            });
        }

        _populate_fromGroup_group({spellList, }, ) {
            const spellListSourceLower = (spellList.source || "").toLowerCase();
            const spellListNameLower = (spellList.name || "").toLowerCase();

            spellList.spells.forEach(spell=>{
                if (typeof spell === "string") {
                    const {name, source} = DataUtil.proxy.unpackUid("spell", spell, "spell", {
                        isLower: true
                    });
                    return MiscUtil.set(this._cache.groups, "spell", source, name, spellListSourceLower, spellListNameLower, {
                        name: spellList.name,
                        source: spellList.source
                    });
                }

                throw new Error(`Grouping spells based on other spell lists is not yet supported!`);
            }
            );
        }

        mutateSpell({spell: sp, lowName, lowSource}) {
            lowName = lowName || sp.name.toLowerCase();
            lowSource = lowSource || sp.source.toLowerCase();

            this._mutateSpell_brewGeneric({
                sp,
                lowName,
                lowSource,
                propSpell: "races",
                prop: "race"
            });
            this._mutateSpell_brewGeneric({
                sp,
                lowName,
                lowSource,
                propSpell: "backgrounds",
                prop: "background"
            });
            this._mutateSpell_brewGeneric({
                sp,
                lowName,
                lowSource,
                propSpell: "feats",
                prop: "feat"
            });
            this._mutateSpell_brewGeneric({
                sp,
                lowName,
                lowSource,
                propSpell: "optionalfeatures",
                prop: "optionalfeature"
            });
            this._mutateSpell_brewGroup({
                sp,
                lowName,
                lowSource
            });
            this._mutateSpell_brewClassesSubclasses({
                sp,
                lowName,
                lowSource
            });
        }

        _mutateSpell_brewClassesSubclasses({sp, lowName, lowSource}) {
            if (!this._cache?.classes)
                return;

            if (this._cache.classes.spell?.[lowSource]?.[lowName]?.fromClassList?.length) {
                sp._tmpClasses.fromClassList = sp._tmpClasses.fromClassList || [];
                sp._tmpClasses.fromClassList.push(...this._cache.classes.spell[lowSource][lowName].fromClassList);
            }

            if (this._cache.classes.spell?.[lowSource]?.[lowName]?.fromSubclass?.length) {
                sp._tmpClasses.fromSubclass = sp._tmpClasses.fromSubclass || [];
                sp._tmpClasses.fromSubclass.push(...this._cache.classes.spell[lowSource][lowName].fromSubclass);
            }

            if (this._cache.classes.class && sp.classes?.fromClassList) {
                (sp._tmpClasses = sp._tmpClasses || {}).fromClassList = sp._tmpClasses.fromClassList || [];

                outer: for (const srcLower in this._cache.classes.class) {
                    const searchForClasses = this._cache.classes.class[srcLower];

                    for (const clsLowName in searchForClasses) {
                        const spellHasClass = sp.classes?.fromClassList?.some(cls=>(cls.source || "").toLowerCase() === srcLower && cls.name.toLowerCase() === clsLowName);
                        if (!spellHasClass)
                            continue;

                        const fromDetails = searchForClasses[clsLowName];

                        if (fromDetails.fromClassList) {
                            sp._tmpClasses.fromClassList.push(...this._mutateSpell_getListFilteredBySchool({
                                sp,
                                arr: fromDetails.fromClassList
                            }));
                        }

                        if (fromDetails.fromSubclass) {
                            sp._tmpClasses.fromSubclass = sp._tmpClasses.fromSubclass || [];
                            sp._tmpClasses.fromSubclass.push(...this._mutateSpell_getListFilteredBySchool({
                                sp,
                                arr: fromDetails.fromSubclass
                            }));
                        }

                        break outer;
                    }
                }
            }

            if (this._cache.classes.group && (sp.groups?.length || sp._tmpGroups?.length)) {
                const groups = Renderer.spell.getCombinedGeneric(sp, {
                    propSpell: "groups"
                });

                (sp._tmpClasses = sp._tmpClasses || {}).fromClassList = sp._tmpClasses.fromClassList || [];

                outer: for (const srcLower in this._cache.classes.group) {
                    const searchForGroups = this._cache.classes.group[srcLower];

                    for (const groupLowName in searchForGroups) {
                        const spellHasGroup = groups?.some(grp=>(grp.source || "").toLowerCase() === srcLower && grp.name.toLowerCase() === groupLowName);
                        if (!spellHasGroup)
                            continue;

                        const fromDetails = searchForGroups[groupLowName];

                        if (fromDetails.fromClassList) {
                            sp._tmpClasses.fromClassList.push(...this._mutateSpell_getListFilteredBySchool({
                                sp,
                                arr: fromDetails.fromClassList
                            }));
                        }

                        if (fromDetails.fromSubclass) {
                            sp._tmpClasses.fromSubclass = sp._tmpClasses.fromSubclass || [];
                            sp._tmpClasses.fromSubclass.push(...this._mutateSpell_getListFilteredBySchool({
                                sp,
                                arr: fromDetails.fromSubclass
                            }));
                        }

                        break outer;
                    }
                }
            }
        }

        _mutateSpell_getListFilteredBySchool({arr, sp}) {
            return arr.filter(it=>{
                if (!it.schools)
                    return true;
                return it.schools.includes(sp.school);
            }
            ).map(it=>{
                if (!it.schools)
                    return it;
                const out = MiscUtil.copyFast(it);
                delete it.schools;
                return it;
            }
            );
        }

        _mutateSpell_brewGeneric({sp, lowName, lowSource, propSpell, prop}) {
            if (!this._cache?.[propSpell])
                return;

            const propTmp = `_tmp${propSpell.uppercaseFirst()}`;

            if (this._cache[propSpell]?.spell?.[lowSource]?.[lowName]?.length) {
                (sp[propTmp] = sp[propTmp] || []).push(...this._cache[propSpell].spell[lowSource][lowName]);
            }

            if (this._cache?.[propSpell]?.[prop] && sp[propSpell]) {
                sp[propTmp] = sp[propTmp] || [];

                outer: for (const srcLower in this._cache[propSpell][prop]) {
                    const searchForExisting = this._cache[propSpell][prop][srcLower];

                    for (const lowName in searchForExisting) {
                        const spellHasEnt = sp[propSpell].some(it=>(it.source || "").toLowerCase() === srcLower && it.name.toLowerCase() === lowName);
                        if (!spellHasEnt)
                            continue;

                        const fromDetails = searchForExisting[lowName];

                        sp[propTmp].push(...fromDetails);

                        break outer;
                    }
                }
            }
        }

        _mutateSpell_brewGroup({sp, lowName, lowSource}) {
            if (!this._cache?.groups)
                return;

            if (this._cache.groups.spell?.[lowSource]?.[lowName]) {
                Object.values(this._cache.groups.spell[lowSource][lowName]).forEach(bySource=>{
                    Object.values(bySource).forEach(byName=>{
                        sp._tmpGroups.push(byName);
                    }
                    );
                }
                );
            }

        }
    }
    ;

    static populatePrereleaseLookup(brew, {isForce=false}={}) {
        Renderer.spell._spellSourceManagerPrerelease.populate({
            brew,
            isForce
        });
    }

    static populateBrewLookup(brew, {isForce=false}={}) {
        Renderer.spell._spellSourceManagerBrew.populate({
            brew,
            isForce
        });
    }

    static prePopulateHover(data) {
        (data.spell || []).forEach(sp=>Renderer.spell.initBrewSources(sp));
    }

    static prePopulateHoverPrerelease(data) {
        Renderer.spell.populatePrereleaseLookup(data);
    }

    static prePopulateHoverBrew(data) {
        Renderer.spell.populateBrewLookup(data);
    }

    static _BREW_SOURCES_TMP_PROPS = ["_tmpSourcesInit", "_tmpClasses", "_tmpRaces", "_tmpBackgrounds", "_tmpFeats", "_tmpOptionalfeatures", "_tmpGroups", ];
    static uninitBrewSources(sp) {
        Renderer.spell._BREW_SOURCES_TMP_PROPS.forEach(prop=>delete sp[prop]);
    }

    static initBrewSources(sp) {
        if (sp._tmpSourcesInit)
            return;
        sp._tmpSourcesInit = true;

        sp._tmpClasses = {};
        sp._tmpRaces = [];
        sp._tmpBackgrounds = [];
        sp._tmpFeats = [];
        sp._tmpOptionalfeatures = [];
        sp._tmpGroups = [];

        const lowName = sp.name.toLowerCase();
        const lowSource = sp.source.toLowerCase();

        for (const manager of [Renderer.spell._spellSourceManagerPrerelease, Renderer.spell._spellSourceManagerBrew]) {
            manager.mutateSpell({
                spell: sp,
                lowName,
                lowSource
            });
        }
    }

    static getCombinedClasses(sp, prop) {
        if((sp.classes == null || sp.classes.length < 1)){ console.error("Spell " + sp.name + " does not have any classes defined. Is data/spells/sources.json used? (it contains class information for all spells)", sp);}
        return [...((sp.classes || {})[prop] || []), ...((sp._tmpClasses || {})[prop] || []), ].filter(it=>{

            if (!ExcludeUtil.isInitialised){
                return true;
            }

            switch (prop) {
            case "fromClassList":
            case "fromClassListVariant":
                {
                    console.log("GET COMBINED CLASSES");
                    const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](it);
                    console.log("GETCOMBINEDCLASSES", it, hash);
                    if (ExcludeUtil.isExcluded(hash, "class", it.source, {isNoCount: true})){return false;}

                    if (prop !== "fromClassListVariant"){return true;}
                    if (it.definedInSource) {return !ExcludeUtil.isExcluded("*", "classFeature", it.definedInSource, {isNoCount: true});}

                    return true;
                }
            case "fromSubclass":
            case "fromSubclassVariant":
                {
                    const hash = UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
                        name: it.subclass.name,
                        shortName: it.subclass.shortName,
                        source: it.subclass.source,
                        className: it.class.name,
                        classSource: it.class.source,
                    });

                    if (prop !== "fromSubclassVariant")
                        return !ExcludeUtil.isExcluded(hash, "subclass", it.subclass.source, {
                            isNoCount: true
                        });
                    if (it.class.definedInSource)
                        return !Renderer.spell.isExcludedSubclassVariantSource({
                            classDefinedInSource: it.class.definedInSource
                        });

                    return true;
                }
            default:
                throw new Error(`Unhandled prop "${prop}"`);
            }
        }
        );
    }

    static isExcludedSubclassVariantSource({classDefinedInSource, subclassDefinedInSource}) {
        return (classDefinedInSource != null && ExcludeUtil.isExcluded("*", "classFeature", classDefinedInSource, {
            isNoCount: true
        })) || (subclassDefinedInSource != null && ExcludeUtil.isExcluded("*", "subclassFeature", subclassDefinedInSource, {
            isNoCount: true
        }));
    }

    static getCombinedGeneric(sp, {propSpell, prop}) {
        const propSpellTmp = `_tmp${propSpell.uppercaseFirst()}`;
        return [...(sp[propSpell] || []), ...(sp[propSpellTmp] || []), ].filter(it=>{
            if (!ExcludeUtil.isInitialised || !prop)
                return true;
            const hash = UrlUtil.URL_TO_HASH_BUILDER[prop](it);
            return !ExcludeUtil.isExcluded(hash, prop, it.source, {
                isNoCount: true
            });
        }
        ).sort(SortUtil.ascSortGenericEntity.bind(SortUtil));
    }

    static pGetFluff(sp) {
        return Renderer.utils.pGetFluff({
            entity: sp,
            fluffBaseUrl: `data/spells/`,
            fluffProp: "spellFluff",
        });
    }
}
;

Renderer.spell._spellSourceManagerPrerelease = new Renderer.spell._SpellSourceManager();
Renderer.spell._spellSourceManagerBrew = new Renderer.spell._SpellSourceManager();

Renderer.variantrule = class {
    static getCompactRenderedString(rule) {
        const cpy = MiscUtil.copyFast(rule);
        delete cpy.name;
        return `
			${Renderer.utils.getExcludedTr({
            entity: rule,
            dataProp: "variantrule",
            page: UrlUtil.PG_VARIANTRULES
        })}
			${Renderer.utils.getNameTr(rule, {
            page: UrlUtil.PG_VARIANTRULES
        })}
			<tr><td colspan="6">
			${Renderer.get().setFirstSection(true).render(cpy)}
			</td></tr>
		`;
    }
};

Renderer.dice = {
    SYSTEM_USER: {
        name: "Avandra",
    },
    POS_INFINITE: 100000000000000000000,
    _SYMBOL_PARSE_FAILED: Symbol("parseFailed"),

    _$wrpRoll: null,
    _$minRoll: null,
    _$iptRoll: null,
    _$outRoll: null,
    _$head: null,
    _hist: [],
    _histIndex: null,
    _$lastRolledBy: null,
    _storage: null,

    _isManualMode: false,

    DICE: [4, 6, 8, 10, 12, 20, 100],
    getNextDice(faces) {
        const idx = Renderer.dice.DICE.indexOf(faces);
        if (~idx)
            return Renderer.dice.DICE[idx + 1];
        else
            return null;
    },

    getPreviousDice(faces) {
        const idx = Renderer.dice.DICE.indexOf(faces);
        if (~idx)
            return Renderer.dice.DICE[idx - 1];
        else
            return null;
    },

    _panel: null,
    bindDmScreenPanel(panel, title) {
        if (Renderer.dice._panel) {
            Renderer.dice.unbindDmScreenPanel();
        }
        Renderer.dice._showBox();
        Renderer.dice._panel = panel;
        panel.doPopulate_Rollbox(title);
    },

    unbindDmScreenPanel() {
        if (Renderer.dice._panel) {
            $(`body`).append(Renderer.dice._$wrpRoll);
            Renderer.dice._panel.close$TabContent();
            Renderer.dice._panel = null;
            Renderer.dice._hideBox();
            Renderer.dice._$wrpRoll.removeClass("rollbox-panel");
        }
    },

    get$Roller() {
        return Renderer.dice._$wrpRoll;
    },

    parseRandomise2(str) {
        if (!str || !str.trim())
            return null;
        const wrpTree = Renderer.dice.lang.getTree3(str);
        if (wrpTree)
            return wrpTree.tree.evl({});
        else
            return null;
    },

    parseAverage(str) {
        if (!str || !str.trim())
            return null;
        const wrpTree = Renderer.dice.lang.getTree3(str);
        if (wrpTree)
            return wrpTree.tree.avg({});
        else
            return null;
    },

    _showBox() {
        Renderer.dice._$minRoll.hideVe();
        Renderer.dice._$wrpRoll.showVe();
        Renderer.dice._$iptRoll.prop("placeholder", `${Renderer.dice._getRandomPlaceholder()} or "/help"`);
    },

    _hideBox() {
        Renderer.dice._$minRoll.showVe();
        Renderer.dice._$wrpRoll.hideVe();
    },

    _getRandomPlaceholder() {
        const count = RollerUtil.randomise(10);
        const faces = Renderer.dice.DICE[RollerUtil.randomise(Renderer.dice.DICE.length - 1)];
        const mod = (RollerUtil.randomise(3) - 2) * RollerUtil.randomise(10);
        const drop = (count > 1) && RollerUtil.randomise(5) === 5;
        const dropDir = drop ? RollerUtil.randomise(2) === 2 ? "h" : "l" : "";
        const dropAmount = drop ? RollerUtil.randomise(count - 1) : null;
        return `${count}d${faces}${drop ? `d${dropDir}${dropAmount}` : ""}${mod < 0 ? mod : mod > 0 ? `+${mod}` : ""}`;
    },

    async _pInit() {
        const $wrpRoll = $(`<div class="rollbox ve-flex-col min-h-0"></div>`).hideVe();
        const $minRoll = $(`<button class="rollbox-min"><span class="glyphicon glyphicon-chevron-up"></span></button>`).on("click", ()=>{
            Renderer.dice._showBox();
            Renderer.dice._$iptRoll.focus();
        }
        );
        const $head = $(`<div class="head-roll"><span class="hdr-roll">Dice Roller</span><span class="p-2 glyphicon glyphicon-remove"></span></div>`).on("click", ()=>{
            if (!Renderer.dice._panel)
                Renderer.dice._hideBox();
        }
        );
        const $outRoll = $(`<div class="out-roll">`);
        const $iptRoll = $(`<input class="ipt-roll form-control" autocomplete="off" spellcheck="false">`).on("keypress", async evt=>{
            evt.stopPropagation();
            if (evt.key !== "Enter")
                return;

            const strDice = $iptRoll.val();
            const result = await Renderer.dice.pRoll2(strDice, {
                isUser: true,
                name: "Anon",
            }, );
            $iptRoll.val("");

            if (result === Renderer.dice._SYMBOL_PARSE_FAILED) {
                Renderer.dice._showInvalid();
                $iptRoll.addClass("form-control--error");
            }
        }
        ).on("keydown", (evt)=>{
            $iptRoll.removeClass("form-control--error");

            if (evt.key === "ArrowUp") {
                evt.preventDefault();
                Renderer.dice._prevHistory();
                return;
            }

            if (evt.key === "ArrowDown") {
                evt.preventDefault();
                Renderer.dice._nextHistory();
            }
        }
        );
        $wrpRoll.append($head).append($outRoll).append($iptRoll);

        Renderer.dice._$wrpRoll = $wrpRoll;
        Renderer.dice._$minRoll = $minRoll;
        Renderer.dice._$head = $head;
        Renderer.dice._$outRoll = $outRoll;
        Renderer.dice._$iptRoll = $iptRoll;

        $(`body`).append($minRoll).append($wrpRoll);

        $wrpRoll.on("click", ".out-roll-item-code", (evt)=>Renderer.dice._$iptRoll.val($(evt.target).text()).focus());

        Renderer.dice.storage = await StorageUtil.pGet(VeCt.STORAGE_ROLLER_MACRO) || {};
    },

    _prevHistory() {
        Renderer.dice._histIndex--;
        Renderer.dice._prevNextHistory_load();
    },
    _nextHistory() {
        Renderer.dice._histIndex++;
        Renderer.dice._prevNextHistory_load();
    },

    _prevNextHistory_load() {
        Renderer.dice._cleanHistoryIndex();
        const nxtVal = Renderer.dice._hist[Renderer.dice._histIndex];
        Renderer.dice._$iptRoll.val(nxtVal);
        if (nxtVal)
            Renderer.dice._$iptRoll[0].selectionStart = Renderer.dice._$iptRoll[0].selectionEnd = nxtVal.length;
    },

    _cleanHistoryIndex: ()=>{
        if (!Renderer.dice._hist.length) {
            Renderer.dice._histIndex = null;
        } else {
            Renderer.dice._histIndex = Math.min(Renderer.dice._hist.length, Math.max(Renderer.dice._histIndex, 0));
        }
    }
    ,

    _addHistory: (str)=>{
        Renderer.dice._hist.push(str);
        Renderer.dice._histIndex = Renderer.dice._hist.length;
    }
    ,

    _scrollBottom: ()=>{
        Renderer.dice._$outRoll.scrollTop(1e10);
    }
    ,

    async pRollerClickUseData(evt, ele) {
        evt.stopPropagation();
        evt.preventDefault();

        const $ele = $(ele);
        const rollData = $ele.data("packed-dice");
        let name = $ele.data("roll-name");
        let shiftKey = evt.shiftKey;
        let ctrlKey = EventUtil.isCtrlMetaKey(evt);

        const options = rollData.toRoll.split(";").map(it=>it.trim()).filter(Boolean);

        let chosenRollData;
        if (options.length > 1) {
            const cpyRollData = MiscUtil.copyFast(rollData);
            const menu = ContextUtil.getMenu([new ContextUtil.Action("Choose Roll",null,{
                isDisabled: true
            },), null, ...options.map(it=>new ContextUtil.Action(`Roll ${it}`,evt=>{
                shiftKey = shiftKey || evt.shiftKey;
                ctrlKey = ctrlKey || (EventUtil.isCtrlMetaKey(evt));
                cpyRollData.toRoll = it;
                return cpyRollData;
            }
            ,)), ]);

            chosenRollData = await ContextUtil.pOpenMenu(evt, menu);
        } else
            chosenRollData = rollData;

        if (!chosenRollData)
            return;

        const rePrompt = /#\$prompt_number:?([^$]*)\$#/g;
        const results = [];
        let m;
        while ((m = rePrompt.exec(chosenRollData.toRoll))) {
            const optionsRaw = m[1];
            const opts = {};
            if (optionsRaw) {
                const spl = optionsRaw.split(",");
                spl.map(it=>it.trim()).forEach(part=>{
                    const [k,v] = part.split("=").map(it=>it.trim());
                    switch (k) {
                    case "min":
                    case "max":
                        opts[k] = Number(v);
                        break;
                    default:
                        opts[k] = v;
                        break;
                    }
                }
                );
            }

            if (opts.min == null)
                opts.min = 0;
            if (opts.max == null)
                opts.max = Renderer.dice.POS_INFINITE;
            if (opts.default == null)
                opts.default = 0;

            const input = await InputUiUtil.pGetUserNumber(opts);
            if (input == null)
                return;
            results.push(input);
        }

        const rollDataCpy = MiscUtil.copyFast(chosenRollData);
        rePrompt.lastIndex = 0;
        rollDataCpy.toRoll = rollDataCpy.toRoll.replace(rePrompt, ()=>results.shift());

        let rollDataCpyToRoll;
        if (rollData.prompt) {
            const sortedKeys = Object.keys(rollDataCpy.prompt.options).sort(SortUtil.ascSortLower);
            const menu = ContextUtil.getMenu([new ContextUtil.Action(rollDataCpy.prompt.entry,null,{
                isDisabled: true
            }), null, ...sortedKeys.map(it=>{
                const title = rollDataCpy.prompt.mode === "psi" ? `${it} point${it === "1" ? "" : "s"}` : `${Parser.spLevelToFull(it)} level`;

                return new ContextUtil.Action(title,evt=>{
                    shiftKey = shiftKey || evt.shiftKey;
                    ctrlKey = ctrlKey || (EventUtil.isCtrlMetaKey(evt));

                    const fromScaling = rollDataCpy.prompt.options[it];
                    if (!fromScaling) {
                        name = "";
                        return rollDataCpy;
                    } else {
                        name = rollDataCpy.prompt.mode === "psi" ? `${it} psi activation` : `${Parser.spLevelToFull(it)}-level cast`;
                        rollDataCpy.toRoll += `+${fromScaling}`;
                        return rollDataCpy;
                    }
                }
                ,);
            }
            ), ]);

            rollDataCpyToRoll = await ContextUtil.pOpenMenu(evt, menu);
        } else
            rollDataCpyToRoll = rollDataCpy;

        if (!rollDataCpyToRoll)
            return;
        await Renderer.dice.pRollerClick({
            shiftKey,
            ctrlKey
        }, ele, JSON.stringify(rollDataCpyToRoll), name);
    },

    __rerollNextInlineResult(ele) {
        const $ele = $(ele);
        const $result = $ele.next(`.result`);
        const r = Renderer.dice.__rollPackedData($ele);
        $result.text(r);
    },

    __rollPackedData($ele) {
        const wrpTree = Renderer.dice.lang.getTree3($ele.data("packed-dice").toRoll);
        return wrpTree.tree.evl({});
    },

    $getEleUnknownTableRoll(total) {
        return $(Renderer.dice._pRollerClick_getMsgBug(total));
    },

    _pRollerClick_getMsgBug(total) {
        return `<span class="message">No result found matching roll ${total}?! <span class="help-subtle" title="Bug!">🐛</span></span>`;
    },

    async pRollerClick(evtMock, ele, packed, name) {
        const $ele = $(ele);
        const entry = JSON.parse(packed);
        const additionalData = {
            ...ele.dataset
        };

        const rolledBy = {
            name: Renderer.dice._pRollerClick_attemptToGetNameOfRoller({
                $ele
            }),
            label: name != null ? name : Renderer.dice._pRollerClick_attemptToGetNameOfRoll({
                entry,
                $ele
            }),
        };

        const modRollMeta = Renderer.dice.getEventModifiedRollMeta(evtMock, entry);
        const $parent = $ele.closest("th, p, table");

        const rollResult = await this._pRollerClick_pGetResult({
            $parent,
            $ele,
            entry,
            modRollMeta,
            rolledBy,
            additionalData,
        });

        if (!entry.autoRoll)
            return;

        const $tgt = $ele.next(`[data-rd-is-autodice-result="true"]`);
        const curTxt = $tgt.text();
        $tgt.text(rollResult);
        JqueryUtil.showCopiedEffect($tgt, curTxt, true);
    },

    async _pRollerClick_pGetResult({$parent, $ele, entry, modRollMeta, rolledBy, additionalData}) {
        const sharedRollOpts = {
            rollCount: modRollMeta.rollCount,
            additionalData,
            isHidden: !!entry.autoRoll,
        };

        if ($parent.is("th") && $parent.attr("data-rd-isroller") === "true") {
            if ($parent.attr("data-rd-namegeneratorrolls")) {
                return Renderer.dice._pRollerClick_pRollGeneratorTable({
                    $parent,
                    $ele,
                    rolledBy,
                    modRollMeta,
                    rollOpts: sharedRollOpts,
                });
            }

            return Renderer.dice.pRollEntry(modRollMeta.entry, rolledBy, {
                ...sharedRollOpts,
                fnGetMessage: Renderer.dice._pRollerClick_fnGetMessageTable.bind(Renderer.dice, $ele),
            }, );
        }

        return Renderer.dice.pRollEntry(modRollMeta.entry, rolledBy, {
            ...sharedRollOpts,
        }, );
    },

    _pRollerClick_fnGetMessageTable($ele, total) {
        const elesTd = Renderer.dice._pRollerClick_$getTdsFromTotal($ele, total);
        if (elesTd) {
            const tableRow = elesTd.map(ele=>ele.innerHTML.trim()).filter(it=>it).join(" | ");
            const $row = $(`<span class="message">${tableRow}</span>`);
            Renderer.dice._pRollerClick_rollInlineRollers($ele);
            return $row.html();
        }
        return Renderer.dice._pRollerClick_getMsgBug(total);
    },

    _pRollerClick_attemptToGetNameOfRoll({entry, $ele}) {
        if (entry.name)
            return entry.name;

        let titleMaybe = $ele.closest(`table:not(.stats)`).children(`caption`).text();
        if (titleMaybe)
            return titleMaybe.trim();

        titleMaybe = $ele.parent().children(`.rd__list-item-name`).text();
        if (titleMaybe)
            return titleMaybe.trim().replace(/[.,:]$/, "");

        titleMaybe = $ele.closest(`div`).children(`.rd__h`).first().find(`.entry-title-inner`).text();
        if (titleMaybe) {
            titleMaybe = titleMaybe.trim().replace(/[.,:]$/, "");
            return titleMaybe;
        }

        titleMaybe = $ele.closest(`table.stats`).children(`tbody`).first().children(`tr`).first().find(`.rnd-name .stats-name`).text();
        if (titleMaybe)
            return titleMaybe.trim();

        if (UrlUtil.getCurrentPage() === UrlUtil.PG_CHARACTERS) {
            titleMaybe = ($ele.closest(`.chr-entity__row`).find(".chr-entity__ipt-name").val() || "").trim();
            if (titleMaybe)
                return titleMaybe;
        }

        return titleMaybe;
    },

    _pRollerClick_attemptToGetNameOfRoller({$ele}) {
        const $hov = $ele.closest(`.hwin`);
        if ($hov.length)
            return $hov.find(`.stats-name`).first().text();
        const $roll = $ele.closest(`.out-roll-wrp`);
        if ($roll.length)
            return $roll.data("name");
        const $dispPanelTitle = $ele.closest(`.dm-screen-panel`).children(`.panel-control-title`);
        if ($dispPanelTitle.length)
            return $dispPanelTitle.text().trim();
        let name = document.title.replace("- 5etools", "").trim();
        return name === "DM Screen" ? "Dungeon Master" : name;
    },

    _pRollerClick_$getTdsFromTotal($ele, total) {
        const $table = $ele.closest(`table`);
        const $tdRoll = $table.find(`td`).filter((i,e)=>{
            const $e = $(e);
            if (!$e.closest(`table`).is($table))
                return false;
            return total >= Number($e.data("roll-min")) && total <= Number($e.data("roll-max"));
        }
        );
        if ($tdRoll.length && $tdRoll.nextAll().length) {
            return $tdRoll.nextAll().get();
        }
        return null;
    },

    _pRollerClick_rollInlineRollers($ele) {
        $ele.find(`.render-roller`).each((i,e)=>{
            const $e = $(e);
            const r = Renderer.dice.__rollPackedData($e);
            $e.attr("onclick", `Renderer.dice.__rerollNextInlineResult(this)`);
            $e.after(` (<span class="result">${r}</span>)`);
        }
        );
    },

    _pRollerClick_fnGetMessageGeneratorTable($ele, ix, total) {
        const elesTd = Renderer.dice._pRollerClick_$getTdsFromTotal($ele, total);
        if (elesTd) {
            const $row = $(`<span class="message">${elesTd[ix].innerHTML.trim()}</span>`);
            Renderer.dice._pRollerClick_rollInlineRollers($ele);
            return $row.html();
        }
        return Renderer.dice._pRollerClick_getMsgBug(total);
    },

    async _pRollerClick_pRollGeneratorTable({$parent, $ele, rolledBy, modRollMeta, rollOpts}) {
        Renderer.dice.addElement({
            rolledBy,
            html: `<i>${rolledBy.label}:</i>`,
            isMessage: true
        });

        let total = 0;

        const out = [];
        const numRolls = Number($parent.attr("data-rd-namegeneratorrolls"));
        const $ths = $ele.closest(`table`).find(`th`);
        for (let i = 0; i < numRolls; ++i) {
            const cpyRolledBy = MiscUtil.copyFast(rolledBy);
            cpyRolledBy.label = $($ths.get(i + 1)).text().trim();

            const result = await Renderer.dice.pRollEntry(modRollMeta.entry, cpyRolledBy, {
                ...rollOpts,
                fnGetMessage: Renderer.dice._pRollerClick_fnGetMessageGeneratorTable.bind(Renderer.dice, $ele, i),
            }, );
            total += result;
            const elesTd = Renderer.dice._pRollerClick_$getTdsFromTotal($ele, result);

            if (!elesTd) {
                out.push(`(no result)`);
                continue;
            }

            out.push(elesTd[i].innerHTML.trim());
        }

        Renderer.dice.addElement({
            rolledBy,
            html: `= ${out.join(" ")}`,
            isMessage: true
        });

        return total;
    },

    getEventModifiedRollMeta(evt, entry) {
        const out = {
            rollCount: 1,
            entry
        };

        if (evt.shiftKey) {
            if (entry.subType === "damage") {
                const dice = [];
                entry.toRoll.replace(/\s+/g, "").replace(/\d*?d\d+/gi, m0=>dice.push(m0));
                entry.toRoll = `${entry.toRoll}${dice.length ? `+${dice.join("+")}` : ""}`;
            } else if (entry.subType === "d20") {
                if (entry.d20mod != null)
                    entry.toRoll = `2d20dl1${entry.d20mod}`;
                else
                    entry.toRoll = entry.toRoll.replace(/^\s*1?\s*d\s*20/, "2d20dl1");
            } else
                out.rollCount = 2;
        }

        if (EventUtil.isCtrlMetaKey(evt)) {
            if (entry.subType === "damage") {
                entry.toRoll = `floor((${entry.toRoll}) / 2)`;
            } else if (entry.subType === "d20") {
                if (entry.d20mod != null)
                    entry.toRoll = `2d20dh1${entry.d20mod}`;
                else
                    entry.toRoll = entry.toRoll.replace(/^\s*1?\s*d\s*20/, "2d20dh1");
            } else
                out.rollCount = 2;
        }

        return out;
    },

    async pRoll2(str, rolledBy, opts) {
        opts = opts || {};
        str = str.trim().replace(/\/r(?:oll)? /gi, "").trim();
        if (!str)
            return;
        if (rolledBy.isUser)
            Renderer.dice._addHistory(str);

        if (str.startsWith("/"))
            return Renderer.dice._pHandleCommand(str, rolledBy);
        if (str.startsWith("#"))
            return Renderer.dice._pHandleSavedRoll(str, rolledBy, opts);

        const [head,...tail] = str.split(":");
        if (tail.length) {
            str = tail.join(":");
            rolledBy.label = head;
        }
        const wrpTree = Renderer.dice.lang.getTree3(str);
        if (!wrpTree)
            return Renderer.dice._SYMBOL_PARSE_FAILED;
        return Renderer.dice._pHandleRoll2(wrpTree, rolledBy, opts);
    },

    async pRollEntry(entry, rolledBy, opts) {
        opts = opts || {};

        const rollCount = Math.round(opts.rollCount || 1);
        delete opts.rollCount;
        if (rollCount <= 0)
            throw new Error(`Invalid roll count: ${rollCount} (must be a positive integer)`);

        const wrpTree = Renderer.dice.lang.getTree3(entry.toRoll);
        wrpTree.tree.successThresh = entry.successThresh;
        wrpTree.tree.successMax = entry.successMax;
        wrpTree.tree.chanceSuccessText = entry.chanceSuccessText;
        wrpTree.tree.chanceFailureText = entry.chanceFailureText;
        wrpTree.tree.isColorSuccessFail = entry.isColorSuccessFail;

        const results = [];
        if (rollCount > 1 && !opts.isHidden)
            Renderer.dice._showMessage(`Rolling twice...`, rolledBy);
        for (let i = 0; i < rollCount; ++i) {
            const result = await Renderer.dice._pHandleRoll2(wrpTree, rolledBy, opts);
            if (result == null)
                return null;
            results.push(result);
        }
        return Math.max(...results);
    },

    async _pHandleRoll2(wrpTree, rolledBy, opts) {
        opts = {
            ...opts
        };

        if (wrpTree.meta && wrpTree.meta.hasPb) {
            const userPb = await InputUiUtil.pGetUserNumber({
                min: 0,
                int: true,
                title: "Enter Proficiency Bonus",
                default: 2,
                storageKey_default: "dice.playerProficiencyBonus",
                isGlobal_default: true,
            });
            if (userPb == null)
                return null;
            opts.pb = userPb;
        }

        if (wrpTree.meta && wrpTree.meta.hasSummonSpellLevel) {
            const predefinedSpellLevel = opts.additionalData?.summonedBySpellLevel != null && !isNaN(opts.additionalData?.summonedBySpellLevel) ? Number(opts.additionalData.summonedBySpellLevel) : null;

            const userSummonSpellLevel = await InputUiUtil.pGetUserNumber({
                min: predefinedSpellLevel ?? 0,
                int: true,
                title: "Enter Spell Level",
                default: predefinedSpellLevel ?? 1,
            });
            if (userSummonSpellLevel == null)
                return null;
            opts.summonSpellLevel = userSummonSpellLevel;
        }

        if (wrpTree.meta && wrpTree.meta.hasSummonClassLevel) {
            const predefinedClassLevel = opts.additionalData?.summonedByClassLevel != null && !isNaN(opts.additionalData?.summonedByClassLevel) ? Number(opts.additionalData.summonedByClassLevel) : null;

            const userSummonClassLevel = await InputUiUtil.pGetUserNumber({
                min: predefinedClassLevel ?? 0,
                int: true,
                title: "Enter Class Level",
                default: predefinedClassLevel ?? 1,
            });
            if (userSummonClassLevel == null)
                return null;
            opts.summonClassLevel = userSummonClassLevel;
        }

        if (Renderer.dice._isManualMode)
            return Renderer.dice._pHandleRoll2_manual(wrpTree.tree, rolledBy, opts);
        else
            return Renderer.dice._pHandleRoll2_automatic(wrpTree.tree, rolledBy, opts);
    },

    _pHandleRoll2_automatic(tree, rolledBy, opts) {
        opts = opts || {};

        if (!opts.isHidden)
            Renderer.dice._showBox();
        Renderer.dice._checkHandleName(rolledBy.name);
        const $out = Renderer.dice._$lastRolledBy;

        if (tree) {
            const meta = {};
            if (opts.pb)
                meta.pb = opts.pb;
            if (opts.summonSpellLevel)
                meta.summonSpellLevel = opts.summonSpellLevel;
            if (opts.summonClassLevel)
                meta.summonClassLevel = opts.summonClassLevel;

            const result = tree.evl(meta);
            const fullHtml = (meta.html || []).join("");
            const allMax = meta.allMax && meta.allMax.length && !(meta.allMax.filter(it=>!it).length);
            const allMin = meta.allMin && meta.allMin.length && !(meta.allMin.filter(it=>!it).length);

            const lbl = rolledBy.label && (!rolledBy.name || rolledBy.label.trim().toLowerCase() !== rolledBy.name.trim().toLowerCase()) ? rolledBy.label : null;

            const ptTarget = opts.target != null ? result >= opts.target ? ` <b>&geq;${opts.target}</b>` : ` <span class="ve-muted">&lt;${opts.target}</span>` : "";

            const isThreshSuccess = tree.successThresh != null && result > (tree.successMax || 100) - tree.successThresh;
            const isColorSuccess = tree.isColorSuccessFail || !tree.chanceSuccessText;
            const isColorFail = tree.isColorSuccessFail || !tree.chanceFailureText;
            const totalPart = tree.successThresh != null ? `<span class="roll ${isThreshSuccess && isColorSuccess ? "roll-max" : !isThreshSuccess && isColorFail ? "roll-min" : ""}">${isThreshSuccess ? (tree.chanceSuccessText || "Success!") : (tree.chanceFailureText || "Failure")}</span>` : `<span class="roll ${allMax ? "roll-max" : allMin ? "roll-min" : ""}">${result}</span>`;

            const title = `${rolledBy.name ? `${rolledBy.name} \u2014 ` : ""}${lbl ? `${lbl}: ` : ""}${tree}`;

            const message = opts.fnGetMessage ? opts.fnGetMessage(result) : null;
            ExtensionUtil.doSendRoll({
                dice: tree.toString(),
                result,
                rolledBy: rolledBy.name,
                label: [lbl, message].filter(Boolean).join(" \u2013 "),
            });

            if (!opts.isHidden) {
                $out.append(`
					<div class="out-roll-item" title="${title}">
						<div>
							${lbl ? `<span class="roll-label">${lbl}: </span>` : ""}
							${totalPart}
							${ptTarget}
							<span class="all-rolls ve-muted">${fullHtml}</span>
							${message ? `<span class="message">${message}</span>` : ""}
						</div>
						<div class="out-roll-item-button-wrp">
							<button title="Copy to input" class="btn btn-default btn-xs btn-copy-roll" onclick="Renderer.dice._$iptRoll.val('${tree.toString().replace(/\s+/g, "")}'); Renderer.dice._$iptRoll.focus()"><span class="glyphicon glyphicon-pencil"></span></button>
						</div>
					</div>`);

                Renderer.dice._scrollBottom();
            }

            return result;
        } else {
            if (!opts.isHidden) {
                $out.append(`<div class="out-roll-item">Invalid input! Try &quot;/help&quot;</div>`);
                Renderer.dice._scrollBottom();
            }
            return null;
        }
    },

    _pHandleRoll2_manual(tree, rolledBy, opts) {
        opts = opts || {};

        if (!tree)
            return JqueryUtil.doToast({
                type: "danger",
                content: `Invalid roll input!`
            });

        const title = (rolledBy.label || "").toTitleCase() || "Roll Dice";
        const $dispDice = $(`<div class="p-2 bold ve-flex-vh-center rll__prompt-header">${tree.toString()}</div>`);
        if (opts.isResultUsed) {
            return InputUiUtil.pGetUserNumber({
                title,
                $elePre: $dispDice,
            });
        } else {
            const {$modalInner} = UiUtil.getShowModal({
                title,
                isMinHeight0: true,
            });
            $dispDice.appendTo($modalInner);
            return null;
        }
    },

    _showMessage(message, rolledBy) {
        Renderer.dice._showBox();
        Renderer.dice._checkHandleName(rolledBy.name);
        const $out = Renderer.dice._$lastRolledBy;
        $out.append(`<div class="out-roll-item out-roll-item--message">${message}</div>`);
        Renderer.dice._scrollBottom();
    },

    _showInvalid() {
        Renderer.dice._showMessage("Invalid input! Try &quot;/help&quot;", Renderer.dice.SYSTEM_USER);
    },

    _validCommands: new Set(["/c", "/cls", "/clear", "/iterroll"]),
    async _pHandleCommand(com, rolledBy) {
        Renderer.dice._showMessage(`<span class="out-roll-item-code">${com}</span>`, rolledBy);
        const comParsed = Renderer.dice._getParsedCommand(com);
        const [comOp] = comParsed;

        if (comOp === "/help" || comOp === "/h") {
            Renderer.dice._showMessage(`<ul class="rll__list">
					<li>Keep highest; <span class="out-roll-item-code">4d6kh3</span></li>
					<li>Drop lowest; <span class="out-roll-item-code">4d6dl1</span></li>
					<li>Drop highest; <span class="out-roll-item-code">3d4dh1</span></li>
					<li>Keep lowest; <span class="out-roll-item-code">3d4kl1</span></li>

					<li>Reroll equal; <span class="out-roll-item-code">2d4r1</span></li>
					<li>Reroll less; <span class="out-roll-item-code">2d4r&lt;2</span></li>
					<li>Reroll less or equal; <span class="out-roll-item-code">2d4r&lt;=2</span></li>
					<li>Reroll greater; <span class="out-roll-item-code">2d4r&gt;2</span></li>
					<li>Reroll greater equal; <span class="out-roll-item-code">2d4r&gt;=3</span></li>

					<li>Explode equal; <span class="out-roll-item-code">2d4x4</span></li>
					<li>Explode less; <span class="out-roll-item-code">2d4x&lt;2</span></li>
					<li>Explode less or equal; <span class="out-roll-item-code">2d4x&lt;=2</span></li>
					<li>Explode greater; <span class="out-roll-item-code">2d4x&gt;2</span></li>
					<li>Explode greater equal; <span class="out-roll-item-code">2d4x&gt;=3</span></li>

					<li>Count Successes equal; <span class="out-roll-item-code">2d4cs=4</span></li>
					<li>Count Successes less; <span class="out-roll-item-code">2d4cs&lt;2</span></li>
					<li>Count Successes less or equal; <span class="out-roll-item-code">2d4cs&lt;=2</span></li>
					<li>Count Successes greater; <span class="out-roll-item-code">2d4cs&gt;2</span></li>
					<li>Count Successes greater equal; <span class="out-roll-item-code">2d4cs&gt;=3</span></li>

					<li>Margin of Success; <span class="out-roll-item-code">2d4ms=4</span></li>

					<li>Dice pools; <span class="out-roll-item-code">{2d8, 1d6}</span></li>
					<li>Dice pools with modifiers; <span class="out-roll-item-code">{1d20+7, 10}kh1</span></li>

					<li>Rounding; <span class="out-roll-item-code">floor(1.5)</span>, <span class="out-roll-item-code">ceil(1.5)</span>, <span class="out-roll-item-code">round(1.5)</span></li>

					<li>Average; <span class="out-roll-item-code">avg(8d6)</span></li>
					<li>Maximize dice; <span class="out-roll-item-code">dmax(8d6)</span></li>
					<li>Minimize dice; <span class="out-roll-item-code">dmin(8d6)</span></li>

					<li>Other functions; <span class="out-roll-item-code">sign(1d6-3)</span>, <span class="out-roll-item-code">abs(1d6-3)</span>, ...etc.</li>
				</ul>
				Up and down arrow keys cycle input history.<br>
				Anything before a colon is treated as a label (<span class="out-roll-item-code">Fireball: 8d6</span>)<br>
Use <span class="out-roll-item-code">/macro list</span> to list saved macros.<br>
				Use <span class="out-roll-item-code">/macro add myName 1d2+3</span> to add (or update) a macro. Macro names should not contain spaces or hashes.<br>
				Use <span class="out-roll-item-code">/macro remove myName</span> to remove a macro.<br>
				Use <span class="out-roll-item-code">#myName</span> to roll a macro.<br>
				Use <span class="out-roll-item-code">/iterroll roll count [target]</span> to roll multiple times, optionally against a target.
				Use <span class="out-roll-item-code">/clear</span> to clear the roller.`, Renderer.dice.SYSTEM_USER, );
            return;
        }

        if (comOp === "/macro") {
            const [,mode,...others] = comParsed;

            if (!["list", "add", "remove", "clear"].includes(mode))
                Renderer.dice._showInvalid();
            else {
                switch (mode) {
                case "list":
                    if (!others.length) {
                        Object.keys(Renderer.dice.storage).forEach(name=>{
                            Renderer.dice._showMessage(`<span class="out-roll-item-code">#${name}</span> \u2014 ${Renderer.dice.storage[name]}`, Renderer.dice.SYSTEM_USER);
                        }
                        );
                    } else {
                        Renderer.dice._showInvalid();
                    }
                    break;
                case "add":
                    {
                        if (others.length === 2) {
                            const [name,macro] = others;
                            if (name.includes(" ") || name.includes("#"))
                                Renderer.dice._showInvalid();
                            else {
                                Renderer.dice.storage[name] = macro;
                                await Renderer.dice._pSaveMacros();
                                Renderer.dice._showMessage(`Saved macro <span class="out-roll-item-code">#${name}</span>`, Renderer.dice.SYSTEM_USER);
                            }
                        } else {
                            Renderer.dice._showInvalid();
                        }
                        break;
                    }
                case "remove":
                    if (others.length === 1) {
                        if (Renderer.dice.storage[others[0]]) {
                            delete Renderer.dice.storage[others[0]];
                            await Renderer.dice._pSaveMacros();
                            Renderer.dice._showMessage(`Removed macro <span class="out-roll-item-code">#${others[0]}</span>`, Renderer.dice.SYSTEM_USER);
                        } else {
                            Renderer.dice._showMessage(`Macro <span class="out-roll-item-code">#${others[0]}</span> not found`, Renderer.dice.SYSTEM_USER);
                        }
                    } else {
                        Renderer.dice._showInvalid();
                    }
                    break;
                }
            }
            return;
        }

        if (Renderer.dice._validCommands.has(comOp)) {
            switch (comOp) {
            case "/c":
            case "/cls":
            case "/clear":
                Renderer.dice._$outRoll.empty();
                Renderer.dice._$lastRolledBy.empty();
                Renderer.dice._$lastRolledBy = null;
                return;

            case "/iterroll":
                {
                    let[,exp,count,target] = comParsed;

                    if (!exp)
                        return Renderer.dice._showInvalid();
                    const wrpTree = Renderer.dice.lang.getTree3(exp);
                    if (!wrpTree)
                        return Renderer.dice._showInvalid();

                    count = count && !isNaN(count) ? Number(count) : 1;
                    target = target && !isNaN(target) ? Number(target) : undefined;

                    for (let i = 0; i < count; ++i) {
                        await Renderer.dice.pRoll2(exp, {
                            name: "Anon",
                        }, {
                            target,
                        }, );
                    }
                }
            }
            return;
        }

        Renderer.dice._showInvalid();
    },

    async _pSaveMacros() {
        await StorageUtil.pSet(VeCt.STORAGE_ROLLER_MACRO, Renderer.dice.storage);
    },

    _getParsedCommand(str) {
        return str.split(/\s+/);
    },

    _pHandleSavedRoll(id, rolledBy, opts) {
        id = id.replace(/^#/, "");
        const macro = Renderer.dice.storage[id];
        if (macro) {
            rolledBy.label = id;
            const wrpTree = Renderer.dice.lang.getTree3(macro);
            return Renderer.dice._pHandleRoll2(wrpTree, rolledBy, opts);
        } else
            Renderer.dice._showMessage(`Macro <span class="out-roll-item-code">#${id}</span> not found`, Renderer.dice.SYSTEM_USER);
    },

    addRoll({rolledBy, html, $ele}) {
        if (html && $ele)
            throw new Error(`Must specify one of html or $ele!`);

        if (html != null && !html.trim())
            return;

        Renderer.dice._showBox();
        Renderer.dice._checkHandleName(rolledBy.name);

        if (html) {
            Renderer.dice._$lastRolledBy.append(`<div class="out-roll-item" title="${(rolledBy.name || "").qq()}">${html}</div>`);
        } else {
            $$`<div class="out-roll-item" title="${(rolledBy.name || "").qq()}">${$ele}</div>`.appendTo(Renderer.dice._$lastRolledBy);
        }

        Renderer.dice._scrollBottom();
    },

    addElement({rolledBy, html, $ele}) {
        if (html && $ele)
            throw new Error(`Must specify one of html or $ele!`);

        if (html != null && !html.trim())
            return;

        Renderer.dice._showBox();
        Renderer.dice._checkHandleName(rolledBy.name);

        if (html) {
            Renderer.dice._$lastRolledBy.append(`<div class="out-roll-item out-roll-item--message" title="${(rolledBy.name || "").qq()}">${html}</div>`);
        } else {
            $$`<div class="out-roll-item out-roll-item--message" title="${(rolledBy.name || "").qq()}">${$ele}</div>`.appendTo(Renderer.dice._$lastRolledBy);
        }

        Renderer.dice._scrollBottom();
    },

    _checkHandleName(name) {
        if (!Renderer.dice._$lastRolledBy || Renderer.dice._$lastRolledBy.data("name") !== name) {
            Renderer.dice._$outRoll.prepend(`<div class="ve-muted out-roll-id">${name}</div>`);
            Renderer.dice._$lastRolledBy = $(`<div class="out-roll-wrp"></div>`).data("name", name);
            Renderer.dice._$outRoll.prepend(Renderer.dice._$lastRolledBy);
        }
    },
};

Renderer.dice.util = {
    getReducedMeta(meta) {
        return {
            pb: meta.pb
        };
    },
};

Renderer.dice.lang = {
    validate3(str) {
        str = str.trim();

        let lexed;
        try {
            lexed = Renderer.dice.lang._lex3(str).lexed;
        } catch (e) {
            return e.message;
        }

        try {
            Renderer.dice.lang._parse3(lexed);
        } catch (e) {
            return e.message;
        }

        return null;
    },

    getTree3(str, isSilent=true) {
        str = str.trim();
        if (isSilent) {
            try {
                const {lexed, lexedMeta} = Renderer.dice.lang._lex3(str);
                return {
                    tree: Renderer.dice.lang._parse3(lexed),
                    meta: lexedMeta
                };
            } catch (e) {
                return null;
            }
        } else {
            const {lexed, lexedMeta} = Renderer.dice.lang._lex3(str);
            return {
                tree: Renderer.dice.lang._parse3(lexed),
                meta: lexedMeta
            };
        }
    },

    _M_NUMBER_CHAR: /[0-9.]/,
    _M_SYMBOL_CHAR: /[-+/*^=><florceidhkxunavgsmpbtqw,]/,

    _M_NUMBER: /^[\d.,]+$/,
    _lex3(str) {
        const self = {
            tokenStack: [],
            parenCount: 0,
            braceCount: 0,
            mode: null,
            token: "",
            hasPb: false,
            hasSummonSpellLevel: false,
            hasSummonClassLevel: false,
        };

        str = str.trim().replace(/\bPBd(?=\d)/g, "(PB)d").toLowerCase().replace(/\s*?\bplus\b\s*?/g, " + ").replace(/\s*?\bminus\b\s*?/g, " - ").replace(/\s*?\btimes\b\s*?/g, " * ").replace(/\s*?\bover\b\s*?/g, " / ").replace(/\s*?\bdivided by\b\s*?/g, " / ").replace(/\s+/g, "").replace(/[\u2012\u2013\u2014]/g, "-").replace(/[×]/g, "*").replace(/\*\*/g, "^").replace(/÷/g, "/").replace(/--/g, "+").replace(/\+-|-\+/g, "-");

        if (!str)
            return {
                lexed: [],
                lexedMeta: {}
            };

        this._lex3_lex(self, str);

        return {
            lexed: self.tokenStack,
            lexedMeta: {
                hasPb: self.hasPb,
                hasSummonSpellLevel: self.hasSummonSpellLevel,
                hasSummonClassLevel: self.hasSummonClassLevel
            }
        };
    },

    _lex3_lex(self, l) {
        const len = l.length;

        for (let i = 0; i < len; ++i) {
            const c = l[i];

            switch (c) {
            case "(":
                self.parenCount++;
                this._lex3_outputToken(self);
                self.token = "(";
                this._lex3_outputToken(self);
                break;
            case ")":
                self.parenCount--;
                if (self.parenCount < 0)
                    throw new Error(`Syntax error: closing <code>)</code> without opening <code>(</code>`);
                this._lex3_outputToken(self);
                self.token = ")";
                this._lex3_outputToken(self);
                break;
            case "{":
                self.braceCount++;
                this._lex3_outputToken(self);
                self.token = "{";
                this._lex3_outputToken(self);
                break;
            case "}":
                self.braceCount--;
                if (self.parenCount < 0)
                    throw new Error(`Syntax error: closing <code>}</code> without opening <code>(</code>`);
                this._lex3_outputToken(self);
                self.token = "}";
                this._lex3_outputToken(self);
                break;
            case "+":
            case "-":
            case "*":
            case "/":
            case "^":
            case ",":
                this._lex3_outputToken(self);
                self.token += c;
                this._lex3_outputToken(self);
                break;
            default:
                {
                    if (Renderer.dice.lang._M_NUMBER_CHAR.test(c)) {
                        if (self.mode === "symbol")
                            this._lex3_outputToken(self);
                        self.token += c;
                        self.mode = "text";
                    } else if (Renderer.dice.lang._M_SYMBOL_CHAR.test(c)) {
                        if (self.mode === "text")
                            this._lex3_outputToken(self);
                        self.token += c;
                        self.mode = "symbol";
                    } else
                        throw new Error(`Syntax error: unexpected character <code>${c}</code>`);
                    break;
                }
            }
        }

        this._lex3_outputToken(self);
    },

    _lex3_outputToken(self) {
        if (!self.token)
            return;

        switch (self.token) {
        case "(":
            self.tokenStack.push(Renderer.dice.tk.PAREN_OPEN);
            break;
        case ")":
            self.tokenStack.push(Renderer.dice.tk.PAREN_CLOSE);
            break;
        case "{":
            self.tokenStack.push(Renderer.dice.tk.BRACE_OPEN);
            break;
        case "}":
            self.tokenStack.push(Renderer.dice.tk.BRACE_CLOSE);
            break;
        case ",":
            self.tokenStack.push(Renderer.dice.tk.COMMA);
            break;
        case "+":
            self.tokenStack.push(Renderer.dice.tk.ADD);
            break;
        case "-":
            self.tokenStack.push(Renderer.dice.tk.SUB);
            break;
        case "*":
            self.tokenStack.push(Renderer.dice.tk.MULT);
            break;
        case "/":
            self.tokenStack.push(Renderer.dice.tk.DIV);
            break;
        case "^":
            self.tokenStack.push(Renderer.dice.tk.POW);
            break;
        case "pb":
            self.tokenStack.push(Renderer.dice.tk.PB);
            self.hasPb = true;
            break;
        case "summonspelllevel":
            self.tokenStack.push(Renderer.dice.tk.SUMMON_SPELL_LEVEL);
            self.hasSummonSpellLevel = true;
            break;
        case "summonclasslevel":
            self.tokenStack.push(Renderer.dice.tk.SUMMON_CLASS_LEVEL);
            self.hasSummonClassLevel = true;
            break;
        case "floor":
            self.tokenStack.push(Renderer.dice.tk.FLOOR);
            break;
        case "ceil":
            self.tokenStack.push(Renderer.dice.tk.CEIL);
            break;
        case "round":
            self.tokenStack.push(Renderer.dice.tk.ROUND);
            break;
        case "avg":
            self.tokenStack.push(Renderer.dice.tk.AVERAGE);
            break;
        case "dmax":
            self.tokenStack.push(Renderer.dice.tk.DMAX);
            break;
        case "dmin":
            self.tokenStack.push(Renderer.dice.tk.DMIN);
            break;
        case "sign":
            self.tokenStack.push(Renderer.dice.tk.SIGN);
            break;
        case "abs":
            self.tokenStack.push(Renderer.dice.tk.ABS);
            break;
        case "cbrt":
            self.tokenStack.push(Renderer.dice.tk.CBRT);
            break;
        case "sqrt":
            self.tokenStack.push(Renderer.dice.tk.SQRT);
            break;
        case "exp":
            self.tokenStack.push(Renderer.dice.tk.EXP);
            break;
        case "log":
            self.tokenStack.push(Renderer.dice.tk.LOG);
            break;
        case "random":
            self.tokenStack.push(Renderer.dice.tk.RANDOM);
            break;
        case "trunc":
            self.tokenStack.push(Renderer.dice.tk.TRUNC);
            break;
        case "pow":
            self.tokenStack.push(Renderer.dice.tk.POW);
            break;
        case "max":
            self.tokenStack.push(Renderer.dice.tk.MAX);
            break;
        case "min":
            self.tokenStack.push(Renderer.dice.tk.MIN);
            break;
        case "d":
            self.tokenStack.push(Renderer.dice.tk.DICE);
            break;
        case "dh":
            self.tokenStack.push(Renderer.dice.tk.DROP_HIGHEST);
            break;
        case "kh":
            self.tokenStack.push(Renderer.dice.tk.KEEP_HIGHEST);
            break;
        case "dl":
            self.tokenStack.push(Renderer.dice.tk.DROP_LOWEST);
            break;
        case "kl":
            self.tokenStack.push(Renderer.dice.tk.KEEP_LOWEST);
            break;
        case "r":
            self.tokenStack.push(Renderer.dice.tk.REROLL_EXACT);
            break;
        case "r>":
            self.tokenStack.push(Renderer.dice.tk.REROLL_GT);
            break;
        case "r>=":
            self.tokenStack.push(Renderer.dice.tk.REROLL_GTEQ);
            break;
        case "r<":
            self.tokenStack.push(Renderer.dice.tk.REROLL_LT);
            break;
        case "r<=":
            self.tokenStack.push(Renderer.dice.tk.REROLL_LTEQ);
            break;
        case "x":
            self.tokenStack.push(Renderer.dice.tk.EXPLODE_EXACT);
            break;
        case "x>":
            self.tokenStack.push(Renderer.dice.tk.EXPLODE_GT);
            break;
        case "x>=":
            self.tokenStack.push(Renderer.dice.tk.EXPLODE_GTEQ);
            break;
        case "x<":
            self.tokenStack.push(Renderer.dice.tk.EXPLODE_LT);
            break;
        case "x<=":
            self.tokenStack.push(Renderer.dice.tk.EXPLODE_LTEQ);
            break;
        case "cs=":
            self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_EXACT);
            break;
        case "cs>":
            self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_GT);
            break;
        case "cs>=":
            self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_GTEQ);
            break;
        case "cs<":
            self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_LT);
            break;
        case "cs<=":
            self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_LTEQ);
            break;
        case "ms=":
            self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_EXACT);
            break;
        case "ms>":
            self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_GT);
            break;
        case "ms>=":
            self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_GTEQ);
            break;
        case "ms<":
            self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_LT);
            break;
        case "ms<=":
            self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_LTEQ);
            break;
        default:
            {
                if (Renderer.dice.lang._M_NUMBER.test(self.token)) {
                    if (self.token.split(Parser._decimalSeparator).length > 2)
                        throw new Error(`Syntax error: too many decimal separators <code>${self.token}</code>`);
                    self.tokenStack.push(Renderer.dice.tk.NUMBER(self.token));
                } else
                    throw new Error(`Syntax error: unexpected token <code>${self.token}</code>`);
            }
        }

        self.token = "";
    },

    _parse3(lexed) {
        const self = {
            ixSym: -1,
            syms: lexed,
            sym: null,
            lastAccepted: null,
            isIgnoreCommas: true,
        };

        this._parse3_nextSym(self);
        return this._parse3_expression(self);
    },

    _parse3_nextSym(self) {
        const cur = self.syms[self.ixSym];
        self.ixSym++;
        self.sym = self.syms[self.ixSym];
        return cur;
    },

    _parse3_match(self, symbol) {
        if (self.sym == null)
            return false;
        if (symbol.type)
            symbol = symbol.type;
        return self.sym.type === symbol;
    },

    _parse3_accept(self, symbol) {
        if (this._parse3_match(self, symbol)) {
            const out = self.sym;
            this._parse3_nextSym(self);
            self.lastAccepted = out;
            return out;
        }
        return false;
    },

    _parse3_expect(self, symbol) {
        const accepted = this._parse3_accept(self, symbol);
        if (accepted)
            return accepted;
        if (self.sym)
            throw new Error(`Unexpected input: Expected <code>${symbol}</code> but found <code>${self.sym}</code>`);
        else
            throw new Error(`Unexpected end of input: Expected <code>${symbol}</code>`);
    },

    _parse3_factor(self, {isSilent=false}={}) {
        if (this._parse3_accept(self, Renderer.dice.tk.TYP_NUMBER)) {
            if (self.isIgnoreCommas) {
                const syms = [self.lastAccepted];
                while (this._parse3_accept(self, Renderer.dice.tk.COMMA)) {
                    const sym = this._parse3_expect(self, Renderer.dice.tk.TYP_NUMBER);
                    syms.push(sym);
                }
                const sym = Renderer.dice.tk.NUMBER(syms.map(it=>it.value).join(""));
                return new Renderer.dice.parsed.Factor(sym);
            }

            return new Renderer.dice.parsed.Factor(self.lastAccepted);
        } else if (this._parse3_accept(self, Renderer.dice.tk.PB)) {
            return new Renderer.dice.parsed.Factor(Renderer.dice.tk.PB);
        } else if (this._parse3_accept(self, Renderer.dice.tk.SUMMON_SPELL_LEVEL)) {
            return new Renderer.dice.parsed.Factor(Renderer.dice.tk.SUMMON_SPELL_LEVEL);
        } else if (this._parse3_accept(self, Renderer.dice.tk.SUMMON_CLASS_LEVEL)) {
            return new Renderer.dice.parsed.Factor(Renderer.dice.tk.SUMMON_CLASS_LEVEL);
        } else if (this._parse3_match(self, Renderer.dice.tk.FLOOR) || this._parse3_match(self, Renderer.dice.tk.CEIL) || this._parse3_match(self, Renderer.dice.tk.ROUND) || this._parse3_match(self, Renderer.dice.tk.AVERAGE) || this._parse3_match(self, Renderer.dice.tk.DMAX) || this._parse3_match(self, Renderer.dice.tk.DMIN) || this._parse3_match(self, Renderer.dice.tk.SIGN) || this._parse3_match(self, Renderer.dice.tk.ABS) || this._parse3_match(self, Renderer.dice.tk.CBRT) || this._parse3_match(self, Renderer.dice.tk.SQRT) || this._parse3_match(self, Renderer.dice.tk.EXP) || this._parse3_match(self, Renderer.dice.tk.LOG) || this._parse3_match(self, Renderer.dice.tk.RANDOM) || this._parse3_match(self, Renderer.dice.tk.TRUNC)) {
            const children = [];

            children.push(this._parse3_nextSym(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_OPEN);
            children.push(this._parse3_expression(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);

            return new Renderer.dice.parsed.Function(children);
        } else if (this._parse3_match(self, Renderer.dice.tk.POW)) {
            self.isIgnoreCommas = false;

            const children = [];

            children.push(this._parse3_nextSym(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_OPEN);
            children.push(this._parse3_expression(self));
            this._parse3_expect(self, Renderer.dice.tk.COMMA);
            children.push(this._parse3_expression(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);

            self.isIgnoreCommas = true;

            return new Renderer.dice.parsed.Function(children);
        } else if (this._parse3_match(self, Renderer.dice.tk.MAX) || this._parse3_match(self, Renderer.dice.tk.MIN)) {
            self.isIgnoreCommas = false;

            const children = [];

            children.push(this._parse3_nextSym(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_OPEN);
            children.push(this._parse3_expression(self));
            while (this._parse3_accept(self, Renderer.dice.tk.COMMA))
                children.push(this._parse3_expression(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);

            self.isIgnoreCommas = true;

            return new Renderer.dice.parsed.Function(children);
        } else if (this._parse3_accept(self, Renderer.dice.tk.PAREN_OPEN)) {
            const exp = this._parse3_expression(self);
            this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);
            return new Renderer.dice.parsed.Factor(exp,{
                hasParens: true
            });
        } else if (this._parse3_accept(self, Renderer.dice.tk.BRACE_OPEN)) {
            self.isIgnoreCommas = false;

            const children = [];

            children.push(this._parse3_expression(self));
            while (this._parse3_accept(self, Renderer.dice.tk.COMMA))
                children.push(this._parse3_expression(self));

            this._parse3_expect(self, Renderer.dice.tk.BRACE_CLOSE);

            self.isIgnoreCommas = true;

            const modPart = [];
            this._parse3__dice_modifiers(self, modPart);

            return new Renderer.dice.parsed.Pool(children,modPart[0]);
        } else {
            if (isSilent)
                return null;

            if (self.sym)
                throw new Error(`Unexpected input: <code>${self.sym}</code>`);
            else
                throw new Error(`Unexpected end of input`);
        }
    },

    _parse3_dice(self) {
        const children = [];

        if (this._parse3_match(self, Renderer.dice.tk.DICE))
            children.push(new Renderer.dice.parsed.Factor(Renderer.dice.tk.NUMBER(1)));
        else
            children.push(this._parse3_factor(self));

        while (this._parse3_match(self, Renderer.dice.tk.DICE)) {
            this._parse3_nextSym(self);
            children.push(this._parse3_factor(self));
            this._parse3__dice_modifiers(self, children);
        }
        return new Renderer.dice.parsed.Dice(children);
    },

    _parse3__dice_modifiers(self, children) {
        const modsMeta = new Renderer.dice.lang.DiceModMeta();

        while (this._parse3_match(self, Renderer.dice.tk.DROP_HIGHEST) || this._parse3_match(self, Renderer.dice.tk.KEEP_HIGHEST) || this._parse3_match(self, Renderer.dice.tk.DROP_LOWEST) || this._parse3_match(self, Renderer.dice.tk.KEEP_LOWEST) || this._parse3_match(self, Renderer.dice.tk.REROLL_EXACT) || this._parse3_match(self, Renderer.dice.tk.REROLL_GT) || this._parse3_match(self, Renderer.dice.tk.REROLL_GTEQ) || this._parse3_match(self, Renderer.dice.tk.REROLL_LT) || this._parse3_match(self, Renderer.dice.tk.REROLL_LTEQ) || this._parse3_match(self, Renderer.dice.tk.EXPLODE_EXACT) || this._parse3_match(self, Renderer.dice.tk.EXPLODE_GT) || this._parse3_match(self, Renderer.dice.tk.EXPLODE_GTEQ) || this._parse3_match(self, Renderer.dice.tk.EXPLODE_LT) || this._parse3_match(self, Renderer.dice.tk.EXPLODE_LTEQ) || this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_EXACT) || this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_GT) || this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_GTEQ) || this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_LT) || this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_LTEQ) || this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_EXACT) || this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_GT) || this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_GTEQ) || this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_LT) || this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_LTEQ)) {
            const nxtSym = this._parse3_nextSym(self);
            const nxtFactor = this._parse3__dice_modifiers_nxtFactor(self, nxtSym);

            if (nxtSym.isSuccessMode)
                modsMeta.isSuccessMode = true;
            modsMeta.mods.push({
                modSym: nxtSym,
                numSym: nxtFactor
            });
        }

        if (modsMeta.mods.length)
            children.push(modsMeta);
    },

    _parse3__dice_modifiers_nxtFactor(self, nxtSym) {
        if (nxtSym.diceModifierImplicit == null)
            return this._parse3_factor(self, {
                isSilent: true
            });

        const fallback = new Renderer.dice.parsed.Factor(Renderer.dice.tk.NUMBER(nxtSym.diceModifierImplicit));
        if (self.sym == null)
            return fallback;

        const out = this._parse3_factor(self, {
            isSilent: true
        });
        if (out)
            return out;

        return fallback;
    },

    _parse3_exponent(self) {
        const children = [];
        children.push(this._parse3_dice(self));
        while (this._parse3_match(self, Renderer.dice.tk.POW)) {
            this._parse3_nextSym(self);
            children.push(this._parse3_dice(self));
        }
        return new Renderer.dice.parsed.Exponent(children);
    },

    _parse3_term(self) {
        const children = [];
        children.push(this._parse3_exponent(self));
        while (this._parse3_match(self, Renderer.dice.tk.MULT) || this._parse3_match(self, Renderer.dice.tk.DIV)) {
            children.push(this._parse3_nextSym(self));
            children.push(this._parse3_exponent(self));
        }
        return new Renderer.dice.parsed.Term(children);
    },

    _parse3_expression(self) {
        const children = [];
        if (this._parse3_match(self, Renderer.dice.tk.ADD) || this._parse3_match(self, Renderer.dice.tk.SUB))
            children.push(this._parse3_nextSym(self));
        children.push(this._parse3_term(self));
        while (this._parse3_match(self, Renderer.dice.tk.ADD) || this._parse3_match(self, Renderer.dice.tk.SUB)) {
            children.push(this._parse3_nextSym(self));
            children.push(this._parse3_term(self));
        }
        return new Renderer.dice.parsed.Expression(children);
    },

    DiceModMeta: class {
        constructor() {
            this.isDiceModifierGroup = true;
            this.isSuccessMode = false;
            this.mods = [];
        }
    }
    ,
};

Renderer.dice.tk = {
    Token: class {
        constructor(type, value, asString, opts) {
            opts = opts || {};
            this.type = type;
            this.value = value;
            this._asString = asString;
            if (opts.isDiceModifier)
                this.isDiceModifier = true;
            if (opts.diceModifierImplicit)
                this.diceModifierImplicit = true;
            if (opts.isSuccessMode)
                this.isSuccessMode = true;
        }

        eq(other) {
            return other && other.type === this.type;
        }

        toString() {
            if (this._asString)
                return this._asString;
            return this.toDebugString();
        }

        toDebugString() {
            return `${this.type}${this.value ? ` :: ${this.value}` : ""}`;
        }
    }
    ,

    _new(type, asString, opts) {
        return new Renderer.dice.tk.Token(type,null,asString,opts);
    },

    TYP_NUMBER: "NUMBER",
    TYP_DICE: "DICE",
    TYP_SYMBOL: "SYMBOL",
    NUMBER(val) {
        return new Renderer.dice.tk.Token(Renderer.dice.tk.TYP_NUMBER,val);
    },
};
Renderer.dice.tk.PAREN_OPEN = Renderer.dice.tk._new("PAREN_OPEN", "(");
Renderer.dice.tk.PAREN_CLOSE = Renderer.dice.tk._new("PAREN_CLOSE", ")");
Renderer.dice.tk.BRACE_OPEN = Renderer.dice.tk._new("BRACE_OPEN", "{");
Renderer.dice.tk.BRACE_CLOSE = Renderer.dice.tk._new("BRACE_CLOSE", "}");
Renderer.dice.tk.COMMA = Renderer.dice.tk._new("COMMA", ",");
Renderer.dice.tk.ADD = Renderer.dice.tk._new("ADD", "+");
Renderer.dice.tk.SUB = Renderer.dice.tk._new("SUB", "-");
Renderer.dice.tk.MULT = Renderer.dice.tk._new("MULT", "*");
Renderer.dice.tk.DIV = Renderer.dice.tk._new("DIV", "/");
Renderer.dice.tk.POW = Renderer.dice.tk._new("POW", "^");
Renderer.dice.tk.PB = Renderer.dice.tk._new("PB", "pb");
Renderer.dice.tk.SUMMON_SPELL_LEVEL = Renderer.dice.tk._new("SUMMON_SPELL_LEVEL", "summonspelllevel");
Renderer.dice.tk.SUMMON_CLASS_LEVEL = Renderer.dice.tk._new("SUMMON_CLASS_LEVEL", "summonclasslevel");
Renderer.dice.tk.FLOOR = Renderer.dice.tk._new("FLOOR", "floor");
Renderer.dice.tk.CEIL = Renderer.dice.tk._new("CEIL", "ceil");
Renderer.dice.tk.ROUND = Renderer.dice.tk._new("ROUND", "round");
Renderer.dice.tk.AVERAGE = Renderer.dice.tk._new("AVERAGE", "avg");
Renderer.dice.tk.DMAX = Renderer.dice.tk._new("DMAX", "avg");
Renderer.dice.tk.DMIN = Renderer.dice.tk._new("DMIN", "avg");
Renderer.dice.tk.SIGN = Renderer.dice.tk._new("SIGN", "sign");
Renderer.dice.tk.ABS = Renderer.dice.tk._new("ABS", "abs");
Renderer.dice.tk.CBRT = Renderer.dice.tk._new("CBRT", "cbrt");
Renderer.dice.tk.SQRT = Renderer.dice.tk._new("SQRT", "sqrt");
Renderer.dice.tk.EXP = Renderer.dice.tk._new("EXP", "exp");
Renderer.dice.tk.LOG = Renderer.dice.tk._new("LOG", "log");
Renderer.dice.tk.RANDOM = Renderer.dice.tk._new("RANDOM", "random");
Renderer.dice.tk.TRUNC = Renderer.dice.tk._new("TRUNC", "trunc");
Renderer.dice.tk.POW = Renderer.dice.tk._new("POW", "pow");
Renderer.dice.tk.MAX = Renderer.dice.tk._new("MAX", "max");
Renderer.dice.tk.MIN = Renderer.dice.tk._new("MIN", "min");
Renderer.dice.tk.DICE = Renderer.dice.tk._new("DICE", "d");
Renderer.dice.tk.DROP_HIGHEST = Renderer.dice.tk._new("DH", "dh", {
    isDiceModifier: true,
    diceModifierImplicit: 1
});
Renderer.dice.tk.KEEP_HIGHEST = Renderer.dice.tk._new("KH", "kh", {
    isDiceModifier: true,
    diceModifierImplicit: 1
});
Renderer.dice.tk.DROP_LOWEST = Renderer.dice.tk._new("DL", "dl", {
    isDiceModifier: true,
    diceModifierImplicit: 1
});
Renderer.dice.tk.KEEP_LOWEST = Renderer.dice.tk._new("KL", "kl", {
    isDiceModifier: true,
    diceModifierImplicit: 1
});
Renderer.dice.tk.REROLL_EXACT = Renderer.dice.tk._new("REROLL", "r", {
    isDiceModifier: true
});
Renderer.dice.tk.REROLL_GT = Renderer.dice.tk._new("REROLL_GT", "r>", {
    isDiceModifier: true
});
Renderer.dice.tk.REROLL_GTEQ = Renderer.dice.tk._new("REROLL_GTEQ", "r>=", {
    isDiceModifier: true
});
Renderer.dice.tk.REROLL_LT = Renderer.dice.tk._new("REROLL_LT", "r<", {
    isDiceModifier: true
});
Renderer.dice.tk.REROLL_LTEQ = Renderer.dice.tk._new("REROLL_LTEQ", "r<=", {
    isDiceModifier: true
});
Renderer.dice.tk.EXPLODE_EXACT = Renderer.dice.tk._new("EXPLODE", "x", {
    isDiceModifier: true
});
Renderer.dice.tk.EXPLODE_GT = Renderer.dice.tk._new("EXPLODE_GT", "x>", {
    isDiceModifier: true
});
Renderer.dice.tk.EXPLODE_GTEQ = Renderer.dice.tk._new("EXPLODE_GTEQ", "x>=", {
    isDiceModifier: true
});
Renderer.dice.tk.EXPLODE_LT = Renderer.dice.tk._new("EXPLODE_LT", "x<", {
    isDiceModifier: true
});
Renderer.dice.tk.EXPLODE_LTEQ = Renderer.dice.tk._new("EXPLODE_LTEQ", "x<=", {
    isDiceModifier: true
});
Renderer.dice.tk.COUNT_SUCCESS_EXACT = Renderer.dice.tk._new("COUNT_SUCCESS_EXACT", "cs=", {
    isDiceModifier: true,
    isSuccessMode: true
});
Renderer.dice.tk.COUNT_SUCCESS_GT = Renderer.dice.tk._new("COUNT_SUCCESS_GT", "cs>", {
    isDiceModifier: true,
    isSuccessMode: true
});
Renderer.dice.tk.COUNT_SUCCESS_GTEQ = Renderer.dice.tk._new("COUNT_SUCCESS_GTEQ", "cs>=", {
    isDiceModifier: true,
    isSuccessMode: true
});
Renderer.dice.tk.COUNT_SUCCESS_LT = Renderer.dice.tk._new("COUNT_SUCCESS_LT", "cs<", {
    isDiceModifier: true,
    isSuccessMode: true
});
Renderer.dice.tk.COUNT_SUCCESS_LTEQ = Renderer.dice.tk._new("COUNT_SUCCESS_LTEQ", "cs<=", {
    isDiceModifier: true,
    isSuccessMode: true
});
Renderer.dice.tk.MARGIN_SUCCESS_EXACT = Renderer.dice.tk._new("MARGIN_SUCCESS_EXACT", "ms=", {
    isDiceModifier: true
});
Renderer.dice.tk.MARGIN_SUCCESS_GT = Renderer.dice.tk._new("MARGIN_SUCCESS_GT", "ms>", {
    isDiceModifier: true
});
Renderer.dice.tk.MARGIN_SUCCESS_GTEQ = Renderer.dice.tk._new("MARGIN_SUCCESS_GTEQ", "ms>=", {
    isDiceModifier: true
});
Renderer.dice.tk.MARGIN_SUCCESS_LT = Renderer.dice.tk._new("MARGIN_SUCCESS_LT", "ms<", {
    isDiceModifier: true
});
Renderer.dice.tk.MARGIN_SUCCESS_LTEQ = Renderer.dice.tk._new("MARGIN_SUCCESS_LTEQ", "ms<=", {
    isDiceModifier: true
});

Renderer.dice.AbstractSymbol = class {
    constructor() {
        this.type = Renderer.dice.tk.TYP_SYMBOL;
    }
    eq(symbol) {
        return symbol && this.type === symbol.type;
    }
    evl(meta) {
        this.meta = meta;
        return this._evl(meta);
    }
    avg(meta) {
        this.meta = meta;
        return this._avg(meta);
    }
    min(meta) {
        this.meta = meta;
        return this._min(meta);
    }
    max(meta) {
        this.meta = meta;
        return this._max(meta);
    }
    _evl() {
        throw new Error("Unimplemented!");
    }
    _avg() {
        throw new Error("Unimplemented!");
    }
    _min() {
        throw new Error("Unimplemented!");
    }
    _max() {
        throw new Error("Unimplemented!");
    }
    toString() {
        throw new Error("Unimplemented!");
    }
    addToMeta(meta, {text, html=null, md=null}={}) {
        if (!meta)
            return;
        html = html || text;
        md = md || text;
        (meta.html = meta.html || []).push(html);
        (meta.text = meta.text || []).push(text);
        (meta.md = meta.md || []).push(md);
    }
}
;

Renderer.dice.parsed = {
    _PARTITION_EQ: (r,compareTo)=>r === compareTo,
    _PARTITION_GT: (r,compareTo)=>r > compareTo,
    _PARTITION_GTEQ: (r,compareTo)=>r >= compareTo,
    _PARTITION_LT: (r,compareTo)=>r < compareTo,
    _PARTITION_LTEQ: (r,compareTo)=>r <= compareTo,

    _handleModifiers(fnName, meta, vals, nodeMod, opts) {
        opts = opts || {};

        const displayVals = vals.slice();
        const {mods} = nodeMod;

        for (const mod of mods) {
            vals.sort(SortUtil.ascSortProp.bind(null, "val")).reverse();
            const valsAlive = vals.filter(it=>!it.isDropped);

            const modNum = mod.numSym[fnName]();

            switch (mod.modSym.type) {
            case Renderer.dice.tk.DROP_HIGHEST.type:
            case Renderer.dice.tk.KEEP_HIGHEST.type:
            case Renderer.dice.tk.DROP_LOWEST.type:
            case Renderer.dice.tk.KEEP_LOWEST.type:
                {
                    const isHighest = mod.modSym.type.endsWith("H");

                    const splitPoint = isHighest ? modNum : valsAlive.length - modNum;

                    const highSlice = valsAlive.slice(0, splitPoint);
                    const lowSlice = valsAlive.slice(splitPoint, valsAlive.length);

                    switch (mod.modSym.type) {
                    case Renderer.dice.tk.DROP_HIGHEST.type:
                    case Renderer.dice.tk.KEEP_LOWEST.type:
                        highSlice.forEach(val=>val.isDropped = true);
                        break;
                    case Renderer.dice.tk.KEEP_HIGHEST.type:
                    case Renderer.dice.tk.DROP_LOWEST.type:
                        lowSlice.forEach(val=>val.isDropped = true);
                        break;
                    default:
                        throw new Error(`Unimplemented!`);
                    }
                    break;
                }

            case Renderer.dice.tk.REROLL_EXACT.type:
            case Renderer.dice.tk.REROLL_GT.type:
            case Renderer.dice.tk.REROLL_GTEQ.type:
            case Renderer.dice.tk.REROLL_LT.type:
            case Renderer.dice.tk.REROLL_LTEQ.type:
                {
                    let fnPartition;
                    switch (mod.modSym.type) {
                    case Renderer.dice.tk.REROLL_EXACT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_EQ;
                        break;
                    case Renderer.dice.tk.REROLL_GT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GT;
                        break;
                    case Renderer.dice.tk.REROLL_GTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GTEQ;
                        break;
                    case Renderer.dice.tk.REROLL_LT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LT;
                        break;
                    case Renderer.dice.tk.REROLL_LTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LTEQ;
                        break;
                    default:
                        throw new Error(`Unimplemented!`);
                    }

                    const toReroll = valsAlive.filter(val=>fnPartition(val.val, modNum));
                    toReroll.forEach(val=>val.isDropped = true);

                    const nuVals = opts.fnGetRerolls(toReroll);

                    vals.push(...nuVals);
                    displayVals.push(...nuVals);
                    break;
                }

            case Renderer.dice.tk.EXPLODE_EXACT.type:
            case Renderer.dice.tk.EXPLODE_GT.type:
            case Renderer.dice.tk.EXPLODE_GTEQ.type:
            case Renderer.dice.tk.EXPLODE_LT.type:
            case Renderer.dice.tk.EXPLODE_LTEQ.type:
                {
                    let fnPartition;
                    switch (mod.modSym.type) {
                    case Renderer.dice.tk.EXPLODE_EXACT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_EQ;
                        break;
                    case Renderer.dice.tk.EXPLODE_GT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GT;
                        break;
                    case Renderer.dice.tk.EXPLODE_GTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GTEQ;
                        break;
                    case Renderer.dice.tk.EXPLODE_LT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LT;
                        break;
                    case Renderer.dice.tk.EXPLODE_LTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LTEQ;
                        break;
                    default:
                        throw new Error(`Unimplemented!`);
                    }

                    let tries = 999;
                    let lastLen;
                    let toExplodeNext = valsAlive;
                    do {
                        lastLen = vals.length;

                        const [toExplode] = toExplodeNext.partition(roll=>!roll.isExploded && fnPartition(roll.val, modNum));
                        toExplode.forEach(roll=>roll.isExploded = true);

                        const nuVals = opts.fnGetExplosions(toExplode);

                        toExplodeNext = nuVals;

                        vals.push(...nuVals);
                        displayVals.push(...nuVals);
                    } while (tries-- > 0 && vals.length !== lastLen);

                    if (!~tries)
                        JqueryUtil.doToast({
                            type: "warning",
                            content: `Stopped exploding after 999 additional rolls.`
                        });

                    break;
                }

            case Renderer.dice.tk.COUNT_SUCCESS_EXACT.type:
            case Renderer.dice.tk.COUNT_SUCCESS_GT.type:
            case Renderer.dice.tk.COUNT_SUCCESS_GTEQ.type:
            case Renderer.dice.tk.COUNT_SUCCESS_LT.type:
            case Renderer.dice.tk.COUNT_SUCCESS_LTEQ.type:
                {
                    let fnPartition;
                    switch (mod.modSym.type) {
                    case Renderer.dice.tk.COUNT_SUCCESS_EXACT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_EQ;
                        break;
                    case Renderer.dice.tk.COUNT_SUCCESS_GT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GT;
                        break;
                    case Renderer.dice.tk.COUNT_SUCCESS_GTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GTEQ;
                        break;
                    case Renderer.dice.tk.COUNT_SUCCESS_LT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LT;
                        break;
                    case Renderer.dice.tk.COUNT_SUCCESS_LTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LTEQ;
                        break;
                    default:
                        throw new Error(`Unimplemented!`);
                    }

                    const successes = valsAlive.filter(val=>fnPartition(val.val, modNum));
                    successes.forEach(val=>val.isSuccess = true);

                    break;
                }

            case Renderer.dice.tk.MARGIN_SUCCESS_EXACT.type:
            case Renderer.dice.tk.MARGIN_SUCCESS_GT.type:
            case Renderer.dice.tk.MARGIN_SUCCESS_GTEQ.type:
            case Renderer.dice.tk.MARGIN_SUCCESS_LT.type:
            case Renderer.dice.tk.MARGIN_SUCCESS_LTEQ.type:
                {
                    const total = valsAlive.map(it=>it.val).reduce((valA,valB)=>valA + valB, 0);

                    const subDisplayDice = displayVals.map(r=>`[${Renderer.dice.parsed._rollToNumPart_html(r, opts.faces)}]`).join("+");

                    let delta;
                    let subDisplay;
                    switch (mod.modSym.type) {
                    case Renderer.dice.tk.MARGIN_SUCCESS_EXACT.type:
                    case Renderer.dice.tk.MARGIN_SUCCESS_GT.type:
                    case Renderer.dice.tk.MARGIN_SUCCESS_GTEQ.type:
                        {
                            delta = total - modNum;

                            subDisplay = `(${subDisplayDice})-${modNum}`;

                            break;
                        }
                    case Renderer.dice.tk.MARGIN_SUCCESS_LT.type:
                    case Renderer.dice.tk.MARGIN_SUCCESS_LTEQ.type:
                        {
                            delta = modNum - total;

                            subDisplay = `${modNum}-(${subDisplayDice})`;

                            break;
                        }
                    default:
                        throw new Error(`Unimplemented!`);
                    }

                    while (vals.length) {
                        vals.pop();
                        displayVals.pop();
                    }

                    vals.push({
                        val: delta
                    });
                    displayVals.push({
                        val: delta,
                        htmlDisplay: subDisplay
                    });

                    break;
                }

            default:
                throw new Error(`Unimplemented!`);
            }
        }

        return displayVals;
    },

    _rollToNumPart_html(r, faces) {
        if (faces == null)
            return r.val;
        return r.val === faces ? `<span class="rll__max--muted">${r.val}</span>` : r.val === 1 ? `<span class="rll__min--muted">${r.val}</span>` : r.val;
    },

    Function: class extends Renderer.dice.AbstractSymbol {
        constructor(nodes) {
            super();
            this._nodes = nodes;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            const [symFunc] = this._nodes;
            switch (symFunc.type) {
            case Renderer.dice.tk.FLOOR.type:
            case Renderer.dice.tk.CEIL.type:
            case Renderer.dice.tk.ROUND.type:
            case Renderer.dice.tk.SIGN.type:
            case Renderer.dice.tk.CBRT.type:
            case Renderer.dice.tk.SQRT.type:
            case Renderer.dice.tk.EXP.type:
            case Renderer.dice.tk.LOG.type:
            case Renderer.dice.tk.RANDOM.type:
            case Renderer.dice.tk.TRUNC.type:
            case Renderer.dice.tk.POW.type:
            case Renderer.dice.tk.MAX.type:
            case Renderer.dice.tk.MIN.type:
                {
                    const [,...symExps] = this._nodes;
                    this.addToMeta(meta, {
                        text: `${symFunc.toString()}(`
                    });
                    const args = [];
                    symExps.forEach((symExp,i)=>{
                        if (i !== 0)
                            this.addToMeta(meta, {
                                text: `, `
                            });
                        args.push(symExp[fnName](meta));
                    }
                    );
                    const out = Math[symFunc.toString()](...args);
                    this.addToMeta(meta, {
                        text: ")"
                    });
                    return out;
                }
            case Renderer.dice.tk.AVERAGE.type:
                {
                    const [,symExp] = this._nodes;
                    return symExp.avg(meta);
                }
            case Renderer.dice.tk.DMAX.type:
                {
                    const [,symExp] = this._nodes;
                    return symExp.max(meta);
                }
            case Renderer.dice.tk.DMIN.type:
                {
                    const [,symExp] = this._nodes;
                    return symExp.min(meta);
                }
            default:
                throw new Error(`Unimplemented!`);
            }
        }

        toString() {
            let out;
            const [symFunc,symExp] = this._nodes;
            switch (symFunc.type) {
            case Renderer.dice.tk.FLOOR.type:
            case Renderer.dice.tk.CEIL.type:
            case Renderer.dice.tk.ROUND.type:
            case Renderer.dice.tk.AVERAGE.type:
            case Renderer.dice.tk.DMAX.type:
            case Renderer.dice.tk.DMIN.type:
            case Renderer.dice.tk.SIGN.type:
            case Renderer.dice.tk.ABS.type:
            case Renderer.dice.tk.CBRT.type:
            case Renderer.dice.tk.SQRT.type:
            case Renderer.dice.tk.EXP.type:
            case Renderer.dice.tk.LOG.type:
            case Renderer.dice.tk.RANDOM.type:
            case Renderer.dice.tk.TRUNC.type:
            case Renderer.dice.tk.POW.type:
            case Renderer.dice.tk.MAX.type:
            case Renderer.dice.tk.MIN.type:
                out = symFunc.toString();
                break;
            default:
                throw new Error(`Unimplemented!`);
            }
            out += `(${symExp.toString()})`;
            return out;
        }
    }
    ,

    Pool: class extends Renderer.dice.AbstractSymbol {
        constructor(nodesPool, nodeMod) {
            super();
            this._nodesPool = nodesPool;
            this._nodeMod = nodeMod;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            const vals = this._nodesPool.map(it=>{
                const subMeta = {};
                return {
                    node: it,
                    val: it[fnName](subMeta),
                    meta: subMeta
                };
            }
            );

            if (this._nodeMod && vals.length) {
                const isSuccessMode = this._nodeMod.isSuccessMode;

                const modOpts = {
                    fnGetRerolls: toReroll=>toReroll.map(val=>{
                        const subMeta = {};
                        return {
                            node: val.node,
                            val: val.node[fnName](subMeta),
                            meta: subMeta
                        };
                    }
                    ),
                    fnGetExplosions: toExplode=>toExplode.map(val=>{
                        const subMeta = {};
                        return {
                            node: val.node,
                            val: val.node[fnName](subMeta),
                            meta: subMeta
                        };
                    }
                    ),
                };

                const displayVals = Renderer.dice.parsed._handleModifiers(fnName, meta, vals, this._nodeMod, modOpts);

                const asHtml = displayVals.map(v=>{
                    const html = v.meta.html.join("");
                    if (v.isDropped)
                        return `<span class="rll__dropped">(${html})</span>`;
                    else if (v.isExploded)
                        return `<span class="rll__exploded">(</span>${html}<span class="rll__exploded">)</span>`;
                    else if (v.isSuccess)
                        return `<span class="rll__success">(${html})</span>`;
                    else
                        return `(${html})`;
                }
                ).join("+");

                const asText = displayVals.map(v=>`(${v.meta.text.join("")})`).join("+");
                const asMd = displayVals.map(v=>`(${v.meta.md.join("")})`).join("+");

                this.addToMeta(meta, {
                    html: asHtml,
                    text: asText,
                    md: asMd
                });

                if (isSuccessMode) {
                    return vals.filter(it=>!it.isDropped && it.isSuccess).length;
                } else {
                    return vals.filter(it=>!it.isDropped).map(it=>it.val).sum();
                }
            } else {
                this.addToMeta(meta, ["html", "text", "md"].mergeMap(prop=>({
                    [prop]: `${vals.map(it=>`(${it.meta[prop].join("")})`).join("+")}`,
                })), );
                return vals.map(it=>it.val).sum();
            }
        }

        toString() {
            return `{${this._nodesPool.map(it=>it.toString()).join(", ")}}${this._nodeMod ? this._nodeMod.toString() : ""}`;
        }
    }
    ,

    Factor: class extends Renderer.dice.AbstractSymbol {
        constructor(node, opts) {
            super();
            opts = opts || {};
            this._node = node;
            this._hasParens = !!opts.hasParens;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            switch (this._node.type) {
            case Renderer.dice.tk.TYP_NUMBER:
                {
                    this.addToMeta(meta, {
                        text: this.toString()
                    });
                    return Number(this._node.value);
                }
            case Renderer.dice.tk.TYP_SYMBOL:
                {
                    if (this._hasParens)
                        this.addToMeta(meta, {
                            text: "("
                        });
                    const out = this._node[fnName](meta);
                    if (this._hasParens)
                        this.addToMeta(meta, {
                            text: ")"
                        });
                    return out;
                }
            case Renderer.dice.tk.PB.type:
                {
                    this.addToMeta(meta, {
                        text: this.toString(meta)
                    });
                    return meta.pb == null ? 0 : meta.pb;
                }
            case Renderer.dice.tk.SUMMON_SPELL_LEVEL.type:
                {
                    this.addToMeta(meta, {
                        text: this.toString(meta)
                    });
                    return meta.summonSpellLevel == null ? 0 : meta.summonSpellLevel;
                }
            case Renderer.dice.tk.SUMMON_CLASS_LEVEL.type:
                {
                    this.addToMeta(meta, {
                        text: this.toString(meta)
                    });
                    return meta.summonClassLevel == null ? 0 : meta.summonClassLevel;
                }
            default:
                throw new Error(`Unimplemented!`);
            }
        }

        toString(indent) {
            let out;
            switch (this._node.type) {
            case Renderer.dice.tk.TYP_NUMBER:
                out = this._node.value;
                break;
            case Renderer.dice.tk.TYP_SYMBOL:
                out = this._node.toString();
                break;
            case Renderer.dice.tk.PB.type:
                out = this.meta ? (this.meta.pb || 0) : "PB";
                break;
            case Renderer.dice.tk.SUMMON_SPELL_LEVEL.type:
                out = this.meta ? (this.meta.summonSpellLevel || 0) : "the spell's level";
                break;
            case Renderer.dice.tk.SUMMON_CLASS_LEVEL.type:
                out = this.meta ? (this.meta.summonClassLevel || 0) : "your class level";
                break;
            default:
                throw new Error(`Unimplemented!`);
            }
            return this._hasParens ? `(${out})` : out;
        }
    }
    ,

    Dice: class extends Renderer.dice.AbstractSymbol {
        static _facesToValue(faces, fnName) {
            switch (fnName) {
            case "evl":
                return RollerUtil.randomise(faces);
            case "avg":
                return (faces + 1) / 2;
            case "min":
                return 1;
            case "max":
                return faces;
            }
        }

        constructor(nodes) {
            super();
            this._nodes = nodes;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            if (this._nodes.length === 1)
                return this._nodes[0][fnName](meta);

            const view = this._nodes.slice();
            const numSym = view.shift();
            let tmp = numSym[fnName](Renderer.dice.util.getReducedMeta(meta));

            while (view.length) {
                if (Math.round(tmp) !== tmp)
                    throw new Error(`Number of dice to roll (${tmp}) was not an integer!`);

                const facesSym = view.shift();
                const faces = facesSym[fnName]();
                if (Math.round(faces) !== faces)
                    throw new Error(`Dice face count (${faces}) was not an integer!`);

                const isLast = view.length === 0 || (view.length === 1 && view.last().isDiceModifierGroup);
                tmp = this._invoke_handlePart(fnName, meta, view, tmp, faces, isLast);
            }

            return tmp;
        }

        _invoke_handlePart(fnName, meta, view, num, faces, isLast) {
            const rolls = [...new Array(num)].map(()=>({
                val: Renderer.dice.parsed.Dice._facesToValue(faces, fnName)
            }));
            let displayRolls;
            let isSuccessMode = false;

            if (view.length && view[0].isDiceModifierGroup) {
                const nodeMod = view[0];

                if (fnName === "evl" || fnName === "min" || fnName === "max") {
                    isSuccessMode = nodeMod.isSuccessMode;

                    const modOpts = {
                        faces,
                        fnGetRerolls: toReroll=>[...new Array(toReroll.length)].map(()=>({
                            val: Renderer.dice.parsed.Dice._facesToValue(faces, fnName)
                        })),
                        fnGetExplosions: toExplode=>[...new Array(toExplode.length)].map(()=>({
                            val: Renderer.dice.parsed.Dice._facesToValue(faces, fnName)
                        })),
                    };

                    displayRolls = Renderer.dice.parsed._handleModifiers(fnName, meta, rolls, nodeMod, modOpts);
                }

                view.shift();
            } else
                displayRolls = rolls;

            if (isLast) {
                const asHtml = displayRolls.map(r=>{
                    if (r.htmlDisplay)
                        return r.htmlDisplay;

                    const numPart = Renderer.dice.parsed._rollToNumPart_html(r, faces);

                    if (r.isDropped)
                        return `<span class="rll__dropped">[${numPart}]</span>`;
                    else if (r.isExploded)
                        return `<span class="rll__exploded">[</span>${numPart}<span class="rll__exploded">]</span>`;
                    else if (r.isSuccess)
                        return `<span class="rll__success">[${numPart}]</span>`;
                    else
                        return `[${numPart}]`;
                }
                ).join("+");

                const asText = displayRolls.map(r=>`[${r.val}]`).join("+");

                const asMd = displayRolls.map(r=>{
                    if (r.isDropped)
                        return `~~[${r.val}]~~`;
                    else if (r.isExploded)
                        return `_[${r.val}]_`;
                    else if (r.isSuccess)
                        return `**[${r.val}]**`;
                    else
                        return `[${r.val}]`;
                }
                ).join("+");

                this.addToMeta(meta, {
                    html: asHtml,
                    text: asText,
                    md: asMd,
                }, );
            }

            if (fnName === "evl") {
                const maxRolls = rolls.filter(it=>it.val === faces && !it.isDropped);
                const minRolls = rolls.filter(it=>it.val === 1 && !it.isDropped);
                meta.allMax = meta.allMax || [];
                meta.allMin = meta.allMin || [];
                meta.allMax.push(maxRolls.length && maxRolls.length === rolls.length);
                meta.allMin.push(minRolls.length && minRolls.length === rolls.length);
            }

            if (isSuccessMode) {
                return rolls.filter(it=>!it.isDropped && it.isSuccess).length;
            } else {
                return rolls.filter(it=>!it.isDropped).map(it=>it.val).sum();
            }
        }

        toString() {
            if (this._nodes.length === 1)
                return this._nodes[0].toString();
            const [numSym,facesSym] = this._nodes;
            let out = `${numSym.toString()}d${facesSym.toString()}`;

            for (let i = 2; i < this._nodes.length; ++i) {
                const n = this._nodes[i];
                if (n.isDiceModifierGroup)
                    out += n.mods.map(it=>`${it.modSym.toString()}${it.numSym.toString()}`).join("");
                else
                    out += `d${n.toString()}`;
            }

            return out;
        }
    }
    ,

    Exponent: class extends Renderer.dice.AbstractSymbol {
        constructor(nodes) {
            super();
            this._nodes = nodes;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            const view = this._nodes.slice();
            let val = view.pop()[fnName](meta);
            while (view.length) {
                this.addToMeta(meta, {
                    text: "^"
                });
                val = view.pop()[fnName](meta) ** val;
            }
            return val;
        }

        toString() {
            const view = this._nodes.slice();
            let out = view.pop().toString();
            while (view.length)
                out = `${view.pop().toString()}^${out}`;
            return out;
        }
    }
    ,

    Term: class extends Renderer.dice.AbstractSymbol {
        constructor(nodes) {
            super();
            this._nodes = nodes;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            let out = this._nodes[0][fnName](meta);

            for (let i = 1; i < this._nodes.length; i += 2) {
                if (this._nodes[i].eq(Renderer.dice.tk.MULT)) {
                    this.addToMeta(meta, {
                        text: " × "
                    });
                    out *= this._nodes[i + 1][fnName](meta);
                } else if (this._nodes[i].eq(Renderer.dice.tk.DIV)) {
                    this.addToMeta(meta, {
                        text: " ÷ "
                    });
                    out /= this._nodes[i + 1][fnName](meta);
                } else
                    throw new Error(`Unimplemented!`);
            }

            return out;
        }

        toString() {
            let out = this._nodes[0].toString();
            for (let i = 1; i < this._nodes.length; i += 2) {
                if (this._nodes[i].eq(Renderer.dice.tk.MULT))
                    out += ` * ${this._nodes[i + 1].toString()}`;
                else if (this._nodes[i].eq(Renderer.dice.tk.DIV))
                    out += ` / ${this._nodes[i + 1].toString()}`;
                else
                    throw new Error(`Unimplemented!`);
            }
            return out;
        }
    }
    ,

    Expression: class extends Renderer.dice.AbstractSymbol {
        constructor(nodes) {
            super();
            this._nodes = nodes;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            const view = this._nodes.slice();

            let isNeg = false;
            if (view[0].eq(Renderer.dice.tk.ADD) || view[0].eq(Renderer.dice.tk.SUB)) {
                isNeg = view.shift().eq(Renderer.dice.tk.SUB);
                if (isNeg)
                    this.addToMeta(meta, {
                        text: "-"
                    });
            }

            let out = view[0][fnName](meta);
            if (isNeg)
                out = -out;

            for (let i = 1; i < view.length; i += 2) {
                if (view[i].eq(Renderer.dice.tk.ADD)) {
                    this.addToMeta(meta, {
                        text: " + "
                    });
                    out += view[i + 1][fnName](meta);
                } else if (view[i].eq(Renderer.dice.tk.SUB)) {
                    this.addToMeta(meta, {
                        text: " - "
                    });
                    out -= view[i + 1][fnName](meta);
                } else
                    throw new Error(`Unimplemented!`);
            }

            return out;
        }

        toString(indent=0) {
            let out = "";
            const view = this._nodes.slice();

            let isNeg = false;
            if (view[0].eq(Renderer.dice.tk.ADD) || view[0].eq(Renderer.dice.tk.SUB)) {
                isNeg = view.shift().eq(Renderer.dice.tk.SUB);
                if (isNeg)
                    out += "-";
            }

            out += view[0].toString(indent);
            for (let i = 1; i < view.length; i += 2) {
                if (view[i].eq(Renderer.dice.tk.ADD))
                    out += ` + ${view[i + 1].toString(indent)}`;
                else if (view[i].eq(Renderer.dice.tk.SUB))
                    out += ` - ${view[i + 1].toString(indent)}`;
                else
                    throw new Error(`Unimplemented!`);
            }
            return out;
        }
    }
    ,
};

if (!IS_VTT && typeof window !== "undefined") {
    window.addEventListener("load", Renderer.dice._pInit);
}

Renderer.getRollableRow = function(row, opts) {
    opts = opts || {};

    if (row[0]?.type === "cell" && (row[0]?.roll?.exact != null || (row[0]?.roll?.min != null && row[0]?.roll?.max != null)))
        return row;

    row = MiscUtil.copyFast(row);
    try {
        const cleanRow = String(row[0]).trim();

        const mLowHigh = /^(\d+) or (lower|higher)$/i.exec(cleanRow);
        if (mLowHigh) {
            row[0] = {
                type: "cell",
                entry: cleanRow
            };
            if (mLowHigh[2].toLowerCase() === "lower") {
                row[0].roll = {
                    min: -Renderer.dice.POS_INFINITE,
                    max: Number(mLowHigh[1]),
                };
            } else {
                row[0].roll = {
                    min: Number(mLowHigh[1]),
                    max: Renderer.dice.POS_INFINITE,
                };
            }

            return row;
        }

        const m = /^(\d+)([-\u2012\u2013](\d+))?$/.exec(cleanRow);
        if (m) {
            if (m[1] && !m[2]) {
                row[0] = {
                    type: "cell",
                    roll: {
                        exact: Number(m[1]),
                    },
                };
                if (m[1][0] === "0")
                    row[0].roll.pad = true;
                Renderer.getRollableRow._handleInfiniteOpts(row, opts);
            } else {
                row[0] = {
                    type: "cell",
                    roll: {
                        min: Number(m[1]),
                        max: Number(m[3]),
                    },
                };
                if (m[1][0] === "0" || m[3][0] === "0")
                    row[0].roll.pad = true;
                Renderer.getRollableRow._handleInfiniteOpts(row, opts);
            }
        } else {
            const m = /^(\d+)\+$/.exec(row[0]);
            row[0] = {
                type: "cell",
                roll: {
                    min: Number(m[1]),
                    max: Renderer.dice.POS_INFINITE,
                },
            };
        }
    } catch (e) {
        if (opts.cbErr)
            opts.cbErr(row[0], e);
    }
    return row;
}
;
Renderer.getRollableRow._handleInfiniteOpts = function(row, opts) {
    if (!opts.isForceInfiniteResults)
        return;

    const isExact = row[0].roll.exact != null;

    if (opts.isFirstRow) {
        if (!isExact)
            row[0].roll.displayMin = row[0].roll.min;
        row[0].roll.min = -Renderer.dice.POS_INFINITE;
    }

    if (opts.isLastRow) {
        if (!isExact)
            row[0].roll.displayMax = row[0].roll.max;
        row[0].roll.max = Renderer.dice.POS_INFINITE;
    }
}
;

//#endregion

class MixedProxyBase //extends Cls
{
    constructor(...args) {
        //super(...args);
        this.__hooks = {};
        this.__hooksAll = {};
        this.__hooksTmp = null;
        this.__hooksAllTmp = null;
    }

    _getProxy(hookProp, toProxy) {
        return new Proxy(toProxy,{
            set: (object,prop,value)=>{
                return this._doProxySet(hookProp, object, prop, value);
            }
            ,
            deleteProperty: (object,prop)=>{
                if (!(prop in object))
                    return true;
                const prevValue = object[prop];
                Reflect.deleteProperty(object, prop);
                this._doFireHooksAll(hookProp, prop, undefined, prevValue);
                if (this.__hooks[hookProp] && this.__hooks[hookProp][prop])
                    this.__hooks[hookProp][prop].forEach(hook=>hook(prop, undefined, prevValue));
                return true;
            }
            ,
        });
    }

    _doProxySet(hookProp, object, prop, value) {
        if (object[prop] === value){return true;}
        const prevValue = object[prop];
        Reflect.set(object, prop, value);
        this._doFireHooksAll(hookProp, prop, value, prevValue);
        this._doFireHooks(hookProp, prop, value, prevValue);
        return true;
    }

    async _pDoProxySet(hookProp, object, prop, value) {
        if (object[prop] === value)
            return true;
        const prevValue = object[prop];
        Reflect.set(object, prop, value);
        if (this.__hooksAll[hookProp])
            for (const hook of this.__hooksAll[hookProp])
                await hook(prop, value, prevValue);
        if (this.__hooks[hookProp] && this.__hooks[hookProp][prop])
            for (const hook of this.__hooks[hookProp][prop])
                await hook(prop, value, prevValue);
        return true;
    }

    _doFireHooks(hookProp, prop, value, prevValue) {
        if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]){
            console.log("Fire hook", hookProp, prop, value, prevValue);
            this.__hooks[hookProp][prop].forEach(hook=>hook(prop, value, prevValue));
        }
    }

    _doFireHooksAll(hookProp, prop, value, prevValue) {
        if (this.__hooksAll[hookProp])
            this.__hooksAll[hookProp].forEach(hook=>hook(prop, undefined, prevValue));
    }

    _doFireAllHooks(hookProp) {
        if (this.__hooks[hookProp])
            Object.entries(this.__hooks[hookProp]).forEach(([prop,hk])=>hk(prop));
    }

    _addHook(hookProp, prop, hook) {
        ProxyBase._addHook_to(this.__hooks, hookProp, prop, hook);
        if (this.__hooksTmp)
            ProxyBase._addHook_to(this.__hooksTmp, hookProp, prop, hook);
        return hook;
    }

    static _addHook_to(obj, hookProp, prop, hook) {
        ((obj[hookProp] = obj[hookProp] || {})[prop] = (obj[hookProp][prop] || [])).push(hook);
    }

    _addHookAll(hookProp, hook) {
        ProxyBase._addHookAll_to(this.__hooksAll, hookProp, hook);
        if (this.__hooksAllTmp)
            ProxyBase._addHookAll_to(this.__hooksAllTmp, hookProp, hook);
        return hook;
    }

    static _addHookAll_to(obj, hookProp, hook) {
        (obj[hookProp] = obj[hookProp] || []).push(hook);
    }

    _removeHook(hookProp, prop, hook) {
        ProxyBase._removeHook_from(this.__hooks, hookProp, prop, hook);
        if (this.__hooksTmp)
            ProxyBase._removeHook_from(this.__hooksTmp, hookProp, prop, hook);
    }

    static _removeHook_from(obj, hookProp, prop, hook) {
        if (obj[hookProp] && obj[hookProp][prop]) {
            const ix = obj[hookProp][prop].findIndex(hk=>hk === hook);
            if (~ix)
                obj[hookProp][prop].splice(ix, 1);
        }
    }

    _removeHooks(hookProp, prop) {
        if (this.__hooks[hookProp])
            delete this.__hooks[hookProp][prop];
        if (this.__hooksTmp && this.__hooksTmp[hookProp])
            delete this.__hooksTmp[hookProp][prop];
    }

    _removeHookAll(hookProp, hook) {
        ProxyBase._removeHookAll_from(this.__hooksAll, hookProp, hook);
        if (this.__hooksAllTmp)
            ProxyBase._removeHook_from(this.__hooksAllTmp, hookProp, hook);
    }

    static _removeHookAll_from(obj, hookProp, hook) {
        if (obj[hookProp]) {
            const ix = obj[hookProp].findIndex(hk=>hk === hook);
            if (~ix)
                obj[hookProp].splice(ix, 1);
        }
    }

    _resetHooks(hookProp) {
        if (hookProp !== undefined)
            delete this.__hooks[hookProp];
        else
            Object.keys(this.__hooks).forEach(prop=>delete this.__hooks[prop]);
    }

    _resetHooksAll(hookProp) {
        if (hookProp !== undefined)
            delete this.__hooksAll[hookProp];
        else
            Object.keys(this.__hooksAll).forEach(prop=>delete this.__hooksAll[prop]);
    }

    _saveHookCopiesTo(obj) {
        this.__hooksTmp = obj;
    }
    _saveHookAllCopiesTo(obj) {
        this.__hooksAllTmp = obj;
    }

    _proxyAssign(hookProp, proxyProp, underProp, toObj, isOverwrite) {
        const oldKeys = Object.keys(this[proxyProp]);
        const nuKeys = new Set(Object.keys(toObj));
        const dirtyKeyValues = {};

        if (isOverwrite) {
            oldKeys.forEach(k=>{
                if (!nuKeys.has(k) && this[underProp] !== undefined) {
                    const prevValue = this[proxyProp][k];
                    delete this[underProp][k];
                    dirtyKeyValues[k] = prevValue;
                }
            }
            );
        }

        nuKeys.forEach(k=>{
            if (!CollectionUtil.deepEquals(this[underProp][k], toObj[k])) {
                const prevValue = this[proxyProp][k];
                this[underProp][k] = toObj[k];
                dirtyKeyValues[k] = prevValue;
            }
        }
        );

        Object.entries(dirtyKeyValues).forEach(([k,prevValue])=>{
            this._doFireHooksAll(hookProp, k, this[underProp][k], prevValue);
            if (this.__hooks[hookProp] && this.__hooks[hookProp][k])
                this.__hooks[hookProp][k].forEach(hk=>hk(k, this[underProp][k], prevValue));
        }
        );
    }

    _proxyAssignSimple(hookProp, toObj, isOverwrite) {
        return this._proxyAssign(hookProp, `_${hookProp}`, `__${hookProp}`, toObj, isOverwrite);
    }
}
class BaseComponent //extends Cls
extends MixedProxyBase
{
    _state;
    constructor(...args) {
        super(...args);

        this.__locks = {};
        this.__rendered = {};

        this.__state = {...this._getDefaultState()};
        this._state = this._getProxy("state", this.__state);
    }

    _addHookBase(prop, hook) {
        return this._addHook("state", prop, hook);
    }

    _removeHookBase(prop, hook) {
        return this._removeHook("state", prop, hook);
    }

    _removeHooksBase(prop) {
        return this._removeHooks("state", prop);
    }

    _addHookAllBase(hook) {
        return this._addHookAll("state", hook);
    }

    _removeHookAllBase(hook) {
        return this._removeHookAll("state", hook);
    }

    _setState(toState) {
        this._proxyAssign("state", "_state", "__state", toState, true);
    }

    _setStateValue(prop, value, {isForceTriggerHooks=true}={}) {
        if (this._state[prop] === value && !isForceTriggerHooks)
            return value;
        if (this._state[prop] !== value)
            return this._state[prop] = value;

        this._doFireHooksAll("state", prop, value, value);
        this._doFireHooks("state", prop, value, value);
        return value;
    }

    _getState() {
        return MiscUtil.copyFast(this.__state);
    }

    getPod() {
        this.__pod = this.__pod || {
            get: (prop)=>this._state[prop],
            set: (prop,val)=>this._state[prop] = val,
            delete: (prop)=>delete this._state[prop],
            addHook: (prop,hook)=>this._addHookBase(prop, hook),
            addHookAll: (hook)=>this._addHookAllBase(hook),
            removeHook: (prop,hook)=>this._removeHookBase(prop, hook),
            removeHookAll: (hook)=>this._removeHookAllBase(hook),
            triggerCollectionUpdate: (prop)=>this._triggerCollectionUpdate(prop),
            setState: (state)=>this._setState(state),
            getState: ()=>this._getState(),
            assign: (toObj,isOverwrite)=>this._proxyAssign("state", "_state", "__state", toObj, isOverwrite),
            pLock: lockName=>this._pLock(lockName),
            unlock: lockName=>this._unlock(lockName),
            component: this,
        };
        return this.__pod;
    }

    _getDefaultState() {
        return {};
    }

    getBaseSaveableState() {
        return {
            state: MiscUtil.copyFast(this.__state),
        };
    }

    setBaseSaveableStateFrom(toLoad, isOverwrite=false) {
        toLoad?.state && this._proxyAssignSimple("state", toLoad.state, isOverwrite);
    }

    _getRenderedCollection(opts) {
        opts = opts || {};
        const renderedLookupProp = opts.namespace ? `${opts.namespace}.${opts.prop}` : opts.prop;
        return (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
    }

    _renderCollection(opts) {
        opts = opts || {};

        const rendered = this._getRenderedCollection(opts);
        const entities = this._state[opts.prop] || [];
        return this._renderCollection_doRender(rendered, entities, opts);
    }

    _renderCollection_doRender(rendered, entities, opts) {
        opts = opts || {};

        const toDelete = new Set(Object.keys(rendered));

        for (let i = 0; i < entities.length; ++i) {
            const it = entities[i];

            if (it.id == null)
                throw new Error(`Collection item did not have an ID!`);
            const meta = rendered[it.id];

            toDelete.delete(it.id);
            if (meta) {
                if (opts.isDiffMode) {
                    const nxtHash = this._getCollectionEntityHash(it);
                    if (nxtHash !== meta.__hash)
                        meta.__hash = nxtHash;
                    else
                        continue;
                }

                meta.data = it;
                opts.fnUpdateExisting(meta, it, i);
            } else {
                const meta = opts.fnGetNew(it, i);

                if (meta == null)
                    continue;

                meta.data = it;
                if (!meta.$wrpRow && !meta.fnRemoveEles)
                    throw new Error(`A "$wrpRow" or a "fnRemoveEles" property is required for deletes!`);

                if (opts.isDiffMode)
                    meta.__hash = this._getCollectionEntityHash(it);

                rendered[it.id] = meta;
            }
        }

        const doRemoveElements = meta=>{
            if (meta.$wrpRow)
                meta.$wrpRow.remove();
            if (meta.fnRemoveEles)
                meta.fnRemoveEles();
        }
        ;

        toDelete.forEach(id=>{
            const meta = rendered[id];
            doRemoveElements(meta);
            delete rendered[id];
            if (opts.fnDeleteExisting)
                opts.fnDeleteExisting(meta);
        }
        );

        if (opts.fnReorderExisting) {
            entities.forEach((it,i)=>{
                const meta = rendered[it.id];
                opts.fnReorderExisting(meta, it, i);
            }
            );
        }
    }

    async _pRenderCollection(opts) {
        opts = opts || {};

        const rendered = this._getRenderedCollection(opts);
        const entities = this._state[opts.prop] || [];
        return this._pRenderCollection_doRender(rendered, entities, opts);
    }

    async _pRenderCollection_doRender(rendered, entities, opts) {
        opts = opts || {};

        const toDelete = new Set(Object.keys(rendered));

        for (let i = 0; i < entities.length; ++i) {
            const it = entities[i];

            if (!it.id)
                throw new Error(`Collection item did not have an ID!`);
            const meta = rendered[it.id];

            toDelete.delete(it.id);
            if (meta) {
                if (opts.isDiffMode) {
                    const nxtHash = this._getCollectionEntityHash(it);
                    if (nxtHash !== meta.__hash)
                        meta.__hash = nxtHash;
                    else
                        continue;
                }

                const nxtMeta = await opts.pFnUpdateExisting(meta, it);
                if (opts.isMultiRender)
                    rendered[it.id] = nxtMeta;
            } else {
                const meta = await opts.pFnGetNew(it);

                if (meta == null)
                    continue;

                if (!opts.isMultiRender && !meta.$wrpRow && !meta.fnRemoveEles)
                    throw new Error(`A "$wrpRow" or a "fnRemoveEles" property is required for deletes!`);
                if (opts.isMultiRender && meta.some(it=>!it.$wrpRow && !it.fnRemoveEles))
                    throw new Error(`A "$wrpRow" or a "fnRemoveEles" property is required for deletes!`);

                if (opts.isDiffMode)
                    meta.__hash = this._getCollectionEntityHash(it);

                rendered[it.id] = meta;
            }
        }

        const doRemoveElements = meta=>{
            if (meta.$wrpRow)
                meta.$wrpRow.remove();
            if (meta.fnRemoveEles)
                meta.fnRemoveEles();
        }
        ;

        for (const id of toDelete) {
            const meta = rendered[id];
            if (opts.isMultiRender)
                meta.forEach(it=>doRemoveElements(it));
            else
                doRemoveElements(meta);
            if (opts.additionalCaches)
                opts.additionalCaches.forEach(it=>delete it[id]);
            delete rendered[id];
            if (opts.pFnDeleteExisting)
                await opts.pFnDeleteExisting(meta);
        }

        if (opts.pFnReorderExisting) {
            await entities.pSerialAwaitMap(async(it,i)=>{
                const meta = rendered[it.id];
                await opts.pFnReorderExisting(meta, it, i);
            }
            );
        }
    }

    _detachCollection(prop, namespace=null) {
        const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
        const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
        Object.values(rendered).forEach(it=>it.$wrpRow.detach());
    }

    _resetCollectionRenders(prop, namespace=null) {
        const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
        const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
        Object.values(rendered).forEach(it=>it.$wrpRow.remove());
        delete this.__rendered[renderedLookupProp];
    }

    _getCollectionEntityHash(ent) {
        return CryptUtil.md5(JSON.stringify(ent));
    }

    render() {
        throw new Error("Unimplemented!");
    }

    getSaveableState() {
        return {
            ...this.getBaseSaveableState()
        };
    }
    setStateFrom(toLoad, isOverwrite=false) {
        this.setBaseSaveableStateFrom(toLoad, isOverwrite);
    }

    async _pLock(lockName) {
        while (this.__locks[lockName])
            await this.__locks[lockName].lock;
        let unlock = null;
        const lock = new Promise(resolve=>unlock = resolve);
        this.__locks[lockName] = {
            lock,
            unlock,
        };
    }

    async _pGate(lockName) {
        while (this.__locks[lockName])
            await this.__locks[lockName].lock;
    }

    _unlock(lockName) {
        const lockMeta = this.__locks[lockName];
        if (lockMeta) {
            delete this.__locks[lockName];
            lockMeta.unlock();
        }
    }

    async _pDoProxySetBase(prop, value) {
        return this._pDoProxySet("state", this.__state, prop, value);
    }

    _triggerCollectionUpdate(prop) {
        if (!this._state[prop])
            return;
        this._state[prop] = [...this._state[prop]];
    }

    static _toCollection(array) {
        if (array)
            return array.map(it=>({
                id: CryptUtil.uid(),
                entity: it
            }));
    }

    static _fromCollection(array) {
        if (array)
            return array.map(it=>it.entity);
    }

    static fromObject(obj, ...noModCollections) {
        const comp = new this();
        Object.entries(MiscUtil.copyFast(obj)).forEach(([k,v])=>{
            if (v == null)
                comp.__state[k] = v;
            else if (noModCollections.includes(k) || noModCollections.includes("*"))
                comp.__state[k] = v;
            else if (typeof v === "object" && v instanceof Array)
                comp.__state[k] = BaseComponent$1._toCollection(v);
            else
                comp.__state[k] = v;
        }
        );
        return comp;
    }

    static fromObjectNoMod(obj) {
        return this.fromObject(obj, "*");
    }

    toObject(...noModCollections) {
        const cpy = MiscUtil.copyFast(this.__state);
        Object.entries(cpy).forEach(([k,v])=>{
            if (v == null)
                return;

            if (noModCollections.includes(k) || noModCollections.includes("*"))
                cpy[k] = v;
            else if (v instanceof Array && v.every(it=>it && it.id))
                cpy[k] = BaseComponent$1._fromCollection(v);
        }
        );
        return cpy;
    }

    toObjectNoMod() {
        return this.toObject("*");
    }
}
globalThis.BaseComponent$1 = BaseComponent;
class ProxyBase extends MixedProxyBase{

}
//#region Base Components
class ActorCharactermancerBaseComponent extends BaseComponent {
    get state() {return this._state; }
    addHookBase(prop, hook) {
      this._addHookBase(prop, hook);
    }
    proxyAssignSimple(hookProp, toObj, isOverwrite) {
      return this._proxyAssignSimple(hookProp, toObj, isOverwrite);
    }
    /**Simply creates a property out of an index, to use for asking _state for information */
    static class_getProps(ix) {
    return {
        'propPrefixClass': 'class_' + ix + '_',
        'propIxClass': "class_" + ix + "_ixClass",
        'propPrefixSubclass': "class_" + ix + "_subclass_",
        'propIxSubclass': "class_" + ix + "_subclass_ixSubclass",
        'propCntAsi': "class_" + ix + "_cntAsi",
        'propCurLevel': "class_" + ix + "_curLevel",
        'propTargetLevel': "class_" + ix + "_targetLevel"
      };
    }
    _shared_renderEntity_stgOtherProficiencies({
        $stg: element,
        ent: entity,
        propComp: propComp,
        propProficiencies: propProf,
        title: title,
        CompClass: CompClass,
        propPathActorExistingProficiencies: propPathActorExistingProficiencies,
        fnGetExistingFvtt: fnGetExistingFvtt,
        fnGetMappedProficiencies: fnGetMappedProficiencies
        }) {
        element.empty();
        this._parent.featureSourceTracker_.unregister(this[propComp]);
        if (entity && entity[propProf]) {
            element.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">" + title + "</div>");
            const existingFvtt = fnGetExistingFvtt ? fnGetExistingFvtt(this._actor) : {
                [propProf]: MiscUtil.get(this._actor, '_source', ...propPathActorExistingProficiencies)
            };
            this[propComp] = new CompClass({
                'featureSourceTracker': this._parent.featureSourceTracker_,
                'existing': CompClass.getExisting(existingFvtt),
                'existingFvtt': existingFvtt,
                'available': fnGetMappedProficiencies ? fnGetMappedProficiencies(entity[propProf], propProf) : entity[propProf]
            });
            this[propComp].render(element);
        }
        else { element.hideVe(); this[propComp] = null; }
    }
    _shared_renderEntity_stgDiDrDvCi({
      $stg: _0x53e426,
      ent: _0x137c88,
      propComp: _0x528966,
      CompClass: _0x49593b,
      title: _0xf6f71d,
      propRaceData: _0xcf0cc,
      propTraits: _0x141da8
    }) {
      _0x53e426.empty();
      if (_0x137c88 && _0x137c88[_0xcf0cc]) {
        _0x53e426.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">" + _0xf6f71d + "</div>");
        const _0x44ab2c = {
          [_0xcf0cc]: MiscUtil.get(this._actor, "_source", "system", "traits", _0x141da8)
        };
        this[_0x528966] = new _0x49593b({
          'existing': _0x49593b.getExisting(_0x44ab2c),
          'existingFvtt': _0x44ab2c,
          'available': _0x137c88[_0xcf0cc]
        });
        this[_0x528966].render(_0x53e426);
      } else {
        _0x53e426.hideVe();
        this[_0x528966] = null;
      }
    }
}

let RenderableCollectionBase$1 = class RenderableCollectionBase {
    constructor(comp, prop, opts) {
        opts = opts || {};
        this._comp = comp;
        this._prop = prop;
        this._namespace = opts.namespace;
        this._isDiffMode = opts.isDiffMode;
    }

    getNewRender(entity, i) {
        throw new Error(`Unimplemented!`);
    }

    doUpdateExistingRender(renderedMeta, entity, i) {
        throw new Error(`Unimplemented!`);
    }

    doDeleteExistingRender(renderedMeta) {}

    doReorderExistingComponent(renderedMeta, entity, i) {}

    _getCollectionItem(id) {
        return this._comp._state[this._prop].find(it=>it.id === id);
    }

    render(opts) {
        opts = opts || {};
        this._comp._renderCollection({
            prop: this._prop,
            fnUpdateExisting: (rendered,ent,i)=>this.doUpdateExistingRender(rendered, ent, i),
            fnGetNew: (entity,i)=>this.getNewRender(entity, i),
            fnDeleteExisting: (rendered)=>this.doDeleteExistingRender(rendered),
            fnReorderExisting: (rendered,ent,i)=>this.doReorderExistingComponent(rendered, ent, i),
            namespace: this._namespace,
            isDiffMode: opts.isDiffMode != null ? opts.isDiffMode : this._isDiffMode,
        });
    }
};

globalThis.RenderableCollectionBase = RenderableCollectionBase$1;

class _RenderableCollectionGenericRowsSyncAsyncUtils {
    constructor({comp, prop, $wrpRows, namespace}) {
        this._comp = comp;
        this._prop = prop;
        this._$wrpRows = $wrpRows;
        this._namespace = namespace;
    }

    _getCollectionItem(id) {
        return this._comp._state[this._prop].find(it=>it.id === id);
    }

    getNewRenderComp(entity, i) {
        const comp = BaseComponent.fromObject(entity.entity, "*");
        comp._addHookAll("state", ()=>{
            this._getCollectionItem(entity.id).entity = comp.toObject("*");
            this._comp._triggerCollectionUpdate(this._prop);
        }
        );
        return comp;
    }

    doUpdateExistingRender(renderedMeta, entity, i) {
        renderedMeta.comp._proxyAssignSimple("state", entity.entity, true);
        if (!renderedMeta.$wrpRow.parent().is(this._$wrpRows))
            renderedMeta.$wrpRow.appendTo(this._$wrpRows);
    }

    static _doSwapJqueryElements($eles, ixA, ixB) {
        if (ixA > ixB)
            [ixA,ixB] = [ixB, ixA];

        const eleA = $eles.get(ixA);
        const eleB = $eles.get(ixB);

        const eleActive = document.activeElement;

        $(eleA).insertAfter(eleB);
        $(eleB).insertBefore($eles.get(ixA + 1));

        if (eleActive)
            eleActive.focus();
    }

    doReorderExistingComponent(renderedMeta, entity, i) {
        const ix = this._comp._state[this._prop].map(it=>it.id).indexOf(entity.id);
        const $rows = this._$wrpRows.find(`> *`);
        const curIx = $rows.index(renderedMeta.$wrpRow);

        const isMove = !this._$wrpRows.length || curIx !== ix;
        if (!isMove)
            return;

        this.constructor._doSwapJqueryElements($rows, curIx, ix);
    }

    $getBtnDelete({entity, title="Delete"}) {
        return $(`<button class="btn btn-xxs btn-danger" title="${title.qq()}"><span class="glyphicon glyphicon-trash"></span></button>`).click(()=>this.doDelete({
            entity
        }));
    }

    doDelete({entity}) {
        this._comp._state[this._prop] = this._comp._state[this._prop].filter(it=>it?.id !== entity.id);
    }

    doDeleteMultiple({entities}) {
        const ids = new Set(entities.map(it=>it.id));
        this._comp._state[this._prop] = this._comp._state[this._prop].filter(it=>!ids.has(it?.id));
    }

    $getPadDrag({$wrpRow}) {
        return DragReorderUiUtil$1.$getDragPadOpts(()=>$wrpRow, {
            swapRowPositions: (ixA,ixB)=>{
                [this._comp._state[this._prop][ixA],this._comp._state[this._prop][ixB]] = [this._comp._state[this._prop][ixB], this._comp._state[this._prop][ixA]];
                this._comp._triggerCollectionUpdate(this._prop);
            }
            ,
            $getChildren: ()=>{
                const rendered = this._comp._getRenderedCollection({
                    prop: this._prop,
                    namespace: this._namespace
                });
                return this._comp._state[this._prop].map(it=>rendered[it.id].$wrpRow);
            }
            ,
            $parent: this._$wrpRows,
        }, );
    }
}

let RenderableCollectionGenericRows$1 = class RenderableCollectionGenericRows extends RenderableCollectionBase$1 {
    constructor(comp, prop, $wrpRows, opts) {
        super(comp, prop, opts);
        this._$wrpRows = $wrpRows;

        this._utils = new _RenderableCollectionGenericRowsSyncAsyncUtils({
            comp,
            prop,
            $wrpRows,
            namespace: opts?.namespace,
        });
    }

    doUpdateExistingRender(renderedMeta, entity, i) {
        return this._utils.doUpdateExistingRender(renderedMeta, entity, i);
    }

    doReorderExistingComponent(renderedMeta, entity, i) {
        return this._utils.doReorderExistingComponent(renderedMeta, entity, i);
    }

    getNewRender(entity, i) {
        const comp = this._utils.getNewRenderComp(entity, i);

        const $wrpRow = this._$getWrpRow().appendTo(this._$wrpRows);

        const renderAdditional = this._populateRow({
            comp,
            $wrpRow,
            entity
        });

        return {
            ...(renderAdditional || {}),
            id: entity.id,
            comp,
            $wrpRow,
        };
    }

    _$getWrpRow() {
        return $(`<div class="ve-flex-v-center w-100"></div>`);
    }

    _populateRow({comp, $wrpRow, entity}) {
        throw new Error(`Unimplemented!`);
    }
};

globalThis.RenderableCollectionGenericRows = RenderableCollectionGenericRows$1;

//#region UtilActors
class UtilActors {
    static init() {
        UtilActors.VALID_DAMAGE_TYPES = Object.keys(MiscUtil.get(CONFIG, "DND5E", "damageTypes") || {});
        UtilActors.VALID_CONDITIONS = Object.keys(MiscUtil.get(CONFIG, "DND5E", "conditionTypes") || {});
    }

    static async pGetActorSpellItemOpts({actor, isAllowAutoDetectPreparationMode=false}={}) {
        const opts = {
            isActorItem: true,
            isActorItemNpc: actor?.type === "npc",
            isPrepared: !!Config.get("importSpell", "prepareActorSpells"),
            preparationMode: Config.get("importSpell", "actorSpellPreparationMode"),
        };

        if (!actor || this.isImporterTempActor(actor))
            return opts;

        const spellcastingAbility = MiscUtil.get(actor, "system", "attributes", "spellcasting");
        if (spellcastingAbility)
            opts.ability = spellcastingAbility.value;

        if (actor && isAllowAutoDetectPreparationMode) {
            const autoPreparationMode = await this._pGetActorSpellItemOpts_getAutoPreparationMode({
                actor
            });
            if (autoPreparationMode != null)
                opts.preparationMode = autoPreparationMode;
        }

        return opts;
    }

    static isImporterTempActor(actor) {
        return !!MiscUtil.get(actor, "flags", SharedConsts.MODULE_ID, "isImporterTempActor");
    }

    static async _pGetActorSpellItemOpts_getAutoPreparationMode({actor}) {
        if (!Config.get("importSpell", "isAutoDetectActorSpellPreparationMode"))
            return null;

        const classItems = actor.items.filter(it=>it.type === "class" && it.system?.spellcasting?.progression !== "none");
        if (!classItems.length || classItems.length > 1)
            return null;

        const sheetItem = classItems[0];

        const spellProgression = sheetItem.system.spellcasting.progression;
        switch (spellProgression) {
        case "full":
        case "half":
        case "third":
        case "artificer":
            {
                const classSubclassMeta = await UtilDataConverter.pGetClassItemClassAndSubclass({
                    sheetItem,
                    subclassSheetItems: actor.items.filter(it=>it.type === "subclass")
                });
                if (classSubclassMeta.matchingClasses.length !== 1)
                    return null;
                return (classSubclassMeta.matchingClasses[0].preparedSpells || classSubclassMeta.matchingClasses[0].preparedSpellsProgression) ? "prepared" : "always";
            }
        case "pact":
            return "pact";
        default:
            return null;
        }
    }

    static getSpellItemItemOpts() {
        const opts = {};

        opts.isPrepared = !!Config.get("importSpell", "prepareSpellItems");
        opts.preparationMode = Config.get("importSpell", "spellItemPreparationMode");

        return opts;
    }

    static getMappedTool(str) {
        str = str.toLowerCase().trim();
        if (this.VALID_TOOL_PROFICIENCIES[str])
            return this.VALID_TOOL_PROFICIENCIES[str];
        str = str.split("|")[0];
        return this.VALID_TOOL_PROFICIENCIES[str];
    }

    static getUnmappedTool(str) {
        if (!str)
            return null;
        return Parser._parse_bToA(this.VALID_TOOL_PROFICIENCIES, str, null);
    }

    static getMappedLanguage(str) {
        str = str.toLowerCase().trim();
        return this.VALID_LANGUAGES[str];
    }

    static getMappedCasterType(str) {
        if (!str)
            return str;
        return this._VET_CASTER_TYPE_TO_FVTT[str];
    }

    static getMappedArmorProficiency(str) {
        if (!str)
            return null;
        return Parser._parse_aToB(this.VALID_ARMOR_PROFICIENCIES, str, null);
    }

    static getUnmappedArmorProficiency(str) {
        if (!str)
            return null;
        return Parser._parse_bToA(this.VALID_ARMOR_PROFICIENCIES, str, null);
    }

    static getMappedWeaponProficiency(str) {
        if (!str)
            return null;
        return Parser._parse_aToB(this.VALID_WEAPON_PROFICIENCIES, str, null);
    }

    static getUnmappedWeaponProficiency(str) {
        if (!str)
            return null;
        return Parser._parse_bToA(this.VALID_WEAPON_PROFICIENCIES, str, null);
    }

    static getItemUIdFromWeaponProficiency(str) {
        if (!str)
            return null;
        str = str.trim();
        const tagItemUid = this._getItemUidFromTag(str);
        if (tagItemUid)
            return tagItemUid;
        return Parser._parse_aToB(this._WEAPON_PROFICIENCIES_TO_ITEM_UIDS, str, null);
    }

    static getItemUIdFromToolProficiency(str) {
        if (!str)
            return null;
        str = str.trim();
        const tagItemUid = this._getItemUidFromTag(str);
        if (tagItemUid)
            return tagItemUid;
        return Parser._parse_aToB(this._TOOL_PROFICIENCIES_TO_ITEM_UIDS, str, null);
    }

    static _getItemUidFromTag(str) {
        const mItem = /^{@item ([^}]+)}$/.exec(str);
        if (!mItem)
            return null;
        const {name, source} = DataUtil.generic.unpackUid(mItem[1], "item", {
            isLower: true
        });
        return `${name}|${source}`;
    }

    static getActorBarAttributes(actor) {
        if (!actor)
            return [];

        const attributeSource = actor?.system instanceof foundry.abstract.DataModel ? actor?.type : actor?.system;
        const attributes = MiscUtil.copyFast(TokenDocument.implementation.getTrackedAttributes(attributeSource), );

        return TokenDocument.implementation.getTrackedAttributeChoices(attributes);
    }

    static getTotalClassLevels(actor) {
        return actor.items.filter(it=>it.type === "class").map(it=>it.system.levels || 0).reduce((a,b)=>a + b, 0);
    }

    static isLevelUp(actor) {
        let xpCur = Number(actor?.system?.details?.xp?.value);
        if (isNaN(xpCur))
            xpCur = 0;

        const lvlTarget = actor.items.filter(it=>it.type === "class").map(it=>it.system.levels || 0).sum();
        let xpMax = game.system.config.CHARACTER_EXP_LEVELS[lvlTarget];
        if (isNaN(xpMax))
            xpMax = Number.MAX_SAFE_INTEGER;

        return xpCur >= xpMax;
    }

    static ICON_SPELL_POINTS_ = "icons/magic/light/explosion-star-glow-silhouette.webp";
    static _SPELL_POINTS_SLOT_COUNT = 99;
    static async pGetCreateActorSpellPointsSlotsEffect({actor, isTemporary, isRender}) {
        if (this.hasActorSpellPointSlotEffect({
            actor
        }))
            return;

        await UtilDocuments.pCreateEmbeddedDocuments(actor, this.getActorSpellPointsSlotsEffectData({
            actor
        }), {
            ClsEmbed: ActiveEffect,
            isTemporary,
            isRender
        }, );

        await UtilDocuments.pUpdateDocument(actor, this.getActorSpellPointsSlotsUpdateSys());
    }

    static hasActorSpellPointSlotEffect({actor}) {
        return (actor?.effects || []).some(it=>it.flags[SharedConsts.MODULE_ID]?.["isSpellPointsSlotUnlocker"]);
    }

    static getActorSpellPointsSlotsEffectData({actor=null, sheetItem=null}={}) {
        return UtilActiveEffects.getExpandedEffects([{
            name: `Spell Points Spell Slot Unlock`,
            changes: [...new Array(9)].map((_,i)=>({
                "key": `system.spells.spell${i + 1}.override`,
                "mode": "OVERRIDE",
                "value": this._SPELL_POINTS_SLOT_COUNT,
            })),
            flags: {
                [SharedConsts.MODULE_ID]: {
                    isSpellPointsSlotUnlocker: true,
                    dedupeId: "spellPointsSlotUnlocker",
                },
            },
        }, ], {
            img: this.ICON_SPELL_POINTS_,
            actor,
            sheetItem,
        }, );
    }

    static getActorSpellPointsSlotsUpdateSys() {
        return {
            system: {
                spells: [...new Array(9)].mergeMap((_,i)=>({
                    [`spell${i + 1}`]: {
                        value: 99,
                    },
                })),
            },
        };
    }

    static getActorSpellPointsItem({actor}) {
        return SpellPointsItemBuilder.getItem({
            actor
        });
    }

    static async pGetCreateActorSpellPointsItem({actor, totalSpellcastingLevels=null}) {
        return SpellPointsItemBuilder.pGetCreateItem({
            actor,
            totalLevels: totalSpellcastingLevels
        });
    }

    static getActorPsiPointsItem({actor}) {
        return PsiPointsItemBuilder.getItem({
            actor
        });
    }

    static async pGetCreateActorPsiPointsItem({actor, totalMysticLevels=null}) {
        return PsiPointsItemBuilder.pGetCreateItem({
            actor,
            totalLevels: totalMysticLevels
        });
    }

    static getActorSpellcastingInfo({actor, sheetItems, isForceSpellcastingMulticlass=false, }={}, ) {
        if (actor && sheetItems)
            throw new Error(`Only one of "actor" or "sheetItems" may be specified!`);

        const spellcastingClassItems = (actor?.items || sheetItems).filter(it=>it.type === "class").filter(it=>it.system?.spellcasting);

        if (!spellcastingClassItems.length) {
            return {
                totalSpellcastingLevels: 0,
                casterClassCount: 0,
                maxPactCasterLevel: 0,
                isSpellcastingMulticlass: isForceSpellcastingMulticlass,
            };
        }

        let totalSpellcastingLevels = 0;
        let maxPactCasterLevel = 0;

        const isSpellcastingMulticlass = isForceSpellcastingMulticlass || spellcastingClassItems.length > 1;

        const getSpellcastingLevel = (lvl,type)=>{
            switch (type) {
            case "half":
                return Math.ceil(lvl / 2);
            case "third":
                return Math.ceil(lvl / 3);
            case "artificer":
                return lvl === 1 ? 1 : getSpellcastingLevel(lvl, "half");
            default:
                throw new Error(`Unhandled spellcaster type "${type}"`);
            }
        }
        ;

        const getSpellcastingLevelMulticlass = (lvl,type)=>{
            switch (type) {
            case "half":
                return Math.floor(lvl / 2);
            case "third":
                return Math.floor(lvl / 3);
            case "artificer":
                return Math.ceil(lvl / 2);
            default:
                throw new Error(`Unhandled spellcaster type "${type}"`);
            }
        }
        ;

        const fnGetSpellcastingLevelHalfThird = isSpellcastingMulticlass ? getSpellcastingLevelMulticlass : getSpellcastingLevel;

        spellcastingClassItems.forEach(it=>{
            const lvl = it.system.levels || 0;

            switch (it.system.spellcasting.progression) {
            case "full":
                totalSpellcastingLevels += lvl;
                break;
            case "half":
                totalSpellcastingLevels += fnGetSpellcastingLevelHalfThird(lvl, it.system.spellcasting.progression);
                break;
            case "third":
                totalSpellcastingLevels += fnGetSpellcastingLevelHalfThird(lvl, it.system.spellcasting.progression);
                break;
            case "pact":
                Math.max(maxPactCasterLevel, lvl);
                break;
            case "artificer":
                totalSpellcastingLevels += fnGetSpellcastingLevelHalfThird(lvl, it.system.spellcasting.progression);
                break;
            }
        }
        );

        return {
            totalSpellcastingLevels,
            casterClassCount: spellcastingClassItems.length,
            maxPactCasterLevel,
            isSpellcastingMulticlass
        };
    }

    static async pLinkTempUuids({actor}) {
        const SENTINEL = `__${SharedConsts.MODULE_ID_FAKE}_REPLACE_TARGET__`;

        const reUuid = new RegExp(`(?<prefix>@UUID\\[[^\\]]+\\.)temp-${SharedConsts.MODULE_ID_FAKE}-(?<packed>[^.\\]]+)(?<suffix>](?:\\{[^}]+})?)`,"g");
        const reSentinelLi = new RegExp(`<li[^>]*>\\s*${SENTINEL}\\s*<\\/li>`,"g");
        const reSentinelP = new RegExp(`<p[^>]*>\\s*${SENTINEL}\\s*<\\/p>`,"g");
        const reSentinel = new RegExp(SENTINEL,"g");

        const updates = actor.items.map(item=>{
            const desc = item.system.description.value || "";
            const nxtDesc = desc.replace(reUuid, (...m)=>{
                const packed = m.last().packed;
                try {
                    const {page, source, hash} = JSON.parse(decodeURIComponent(atob(packed)));
                    if (!page || !source || !hash)
                        return SENTINEL;

                    const matchedItem = actor.items.find(it=>it.flags?.[SharedConsts.MODULE_ID]?.page === page && it.flags?.[SharedConsts.MODULE_ID]?.source === source && it.flags?.[SharedConsts.MODULE_ID]?.hash === hash);

                    if (!matchedItem)
                        return SENTINEL;

                    return `${m.last().prefix}${matchedItem.id}${m.last().suffix}`;
                } catch (e) {
                    console.error(...LGT, `Failed to unpack temp page/source/hash`, e);
                    return "";
                }
            }
            ).replace(reSentinelLi, "").replace(reSentinelP, "").replace(reSentinel, "");

            if (desc === nxtDesc)
                return null;

            return {
                _id: item.id,
                system: {
                    description: {
                        value: nxtDesc,
                    },
                },
            };
        }
        ).filter(Boolean);

        if (!updates.length)
            return;

        await UtilDocuments.pUpdateEmbeddedDocuments(actor, updates, {
            ClsEmbed: Item
        });
    }

    static isSetMaxHp({actor}) {
        if (!UtilVersions.getSystemVersion().isVersionTwoOnePlus)
            return true;
        return actor._source.system.attributes.hp.max != null;
    }

    static getProficiencyBonusNumber({actor}) {
        const prof = actor.getRollData().prof;
        if (typeof prof === "number")
            return prof;
        return prof.flat;
    }
}
UtilActors.SKILL_ABV_TO_FULL = {
    acr: "acrobatics",
    ani: "animal handling",
    arc: "arcana",
    ath: "athletics",
    dec: "deception",
    his: "history",
    ins: "insight",
    itm: "intimidation",
    inv: "investigation",
    med: "medicine",
    nat: "nature",
    prc: "perception",
    prf: "performance",
    per: "persuasion",
    rel: "religion",
    slt: "sleight of hand",
    ste: "stealth",
    sur: "survival",
};
UtilActors.TOOL_ABV_TO_FULL = {
    art: "artisan's tools",
    alchemist: "alchemist's supplies",
    brewer: "brewer's supplies",
    calligrapher: "calligrapher's supplies",
    carpenter: "carpenter's tools",
    cartographer: "cartographer's tools",
    cobbler: "cobbler's tools",
    cook: "cook's utensils",
    glassblower: "glassblower's tools",
    jeweler: "jeweler's tools",
    leatherworker: "leatherworker's tools",
    mason: "mason's tools",
    painter: "painter's supplies",
    potter: "potter's tools",
    smith: "smith's tools",
    tinker: "tinker's tools",
    weaver: "weaver's tools",
    woodcarver: "woodcarver's tools",

    disg: "disguise kit",
    forg: "forgery kit",

    game: "gaming set",
    chess: "dragonchess set",
    dice: "dice set",
    card: "three-dragon ante set",

    herb: "herbalism kit",

    music: "musical instrument",
    bagpipes: "bagpipes",
    drum: "drum",
    dulcimer: "dulcimer",
    flute: "flute",
    horn: "horn",
    lute: "lute",
    lyre: "lyre",
    panflute: "pan flute",
    shawm: "shawm",
    viol: "viol",

    navg: "navigator's tools",

    pois: "poisoner's kit",

    thief: "thieves' tools",

    vehicle: "vehicles",
    air: "vehicles (air)",
    land: "vehicles (land)",
    space: "vehicles (space)",
    water: "vehicles (water)",
};
UtilActors.PROF_TO_ICON_CLASS = {
    "1": "fa-check",
    "2": "fa-check-double",
    "0.5": "fa-adjust",
};
UtilActors.PROF_TO_TEXT = {
    "1": "Proficient",
    "2": "Proficient with Expertise",
    "0.5": "Half-Proficient",
    "0": "",
};
UtilActors.VET_SIZE_TO_ABV = {
    [Parser.SZ_TINY]: "tiny",
    [Parser.SZ_SMALL]: "sm",
    [Parser.SZ_MEDIUM]: "med",
    [Parser.SZ_LARGE]: "lg",
    [Parser.SZ_HUGE]: "huge",
    [Parser.SZ_GARGANTUAN]: "grg",
};
UtilActors.VET_SPELL_SCHOOL_TO_ABV = {
    A: "abj",
    C: "con",
    D: "div",
    E: "enc",
    V: "evo",
    I: "ill",
    N: "nec",
    T: "trs",
};

UtilActors.PACT_CASTER_MAX_SPELL_LEVEL = 5;

UtilActors.VALID_DAMAGE_TYPES = null;
UtilActors.VALID_CONDITIONS = null;

UtilActors.TOOL_PROFICIENCIES_TO_UID = {
    "alchemist's supplies": "alchemist's supplies|phb",
    "brewer's supplies": "brewer's supplies|phb",
    "calligrapher's supplies": "calligrapher's supplies|phb",
    "carpenter's tools": "carpenter's tools|phb",
    "cartographer's tools": "cartographer's tools|phb",
    "cobbler's tools": "cobbler's tools|phb",
    "cook's utensils": "cook's utensils|phb",
    "glassblower's tools": "glassblower's tools|phb",
    "jeweler's tools": "jeweler's tools|phb",
    "leatherworker's tools": "leatherworker's tools|phb",
    "mason's tools": "mason's tools|phb",
    "painter's supplies": "painter's supplies|phb",
    "potter's tools": "potter's tools|phb",
    "smith's tools": "smith's tools|phb",
    "tinker's tools": "tinker's tools|phb",
    "weaver's tools": "weaver's tools|phb",
    "woodcarver's tools": "woodcarver's tools|phb",
    "disguise kit": "disguise kit|phb",
    "forgery kit": "forgery kit|phb",
    "gaming set": "gaming set|phb",
    "herbalism kit": "herbalism kit|phb",
    "musical instrument": "musical instrument|phb",
    "navigator's tools": "navigator's tools|phb",
    "thieves' tools": "thieves' tools|phb",
    "poisoner's kit": "poisoner's kit|phb",
};
UtilActors.VALID_TOOL_PROFICIENCIES = {
    "artisan's tools": "art",
    "alchemist's supplies": "alchemist",
    "brewer's supplies": "brewer",
    "calligrapher's supplies": "calligrapher",
    "carpenter's tools": "carpenter",
    "cartographer's tools": "cartographer",
    "cobbler's tools": "cobbler",
    "cook's utensils": "cook",
    "glassblower's tools": "glassblower",
    "jeweler's tools": "jeweler",
    "leatherworker's tools": "leatherworker",
    "mason's tools": "mason",
    "painter's supplies": "painter",
    "potter's tools": "potter",
    "smith's tools": "smith",
    "tinker's tools": "tinker",
    "weaver's tools": "weaver",
    "woodcarver's tools": "woodcarver",

    "disguise kit": "disg",

    "forgery kit": "forg",

    "gaming set": "game",
    "dice set": "dice",
    "dragonchess set": "chess",
    "playing card set": "card",
    "three-dragon ante set": "card",

    "herbalism kit": "herb",

    "musical instrument": "music",
    "bagpipes": "bagpipes",
    "drum": "drum",
    "dulcimer": "dulcimer",
    "flute": "flute",
    "lute": "lute",
    "lyre": "lyre",
    "horn": "horn",
    "pan flute": "panflute",
    "shawm": "shawm",
    "viol": "viol",

    "navigator's tools": "navg",

    "poisoner's kit": "pois",

    "thieves' tools": "thief",

    "vehicle (land or water)": "vehicle",
    "vehicle (air)": "air",
    "vehicle (land)": "land",
    "vehicle (water)": "water",
    "vehicle (space)": "space",
};
UtilActors.VALID_LANGUAGES = {
    "common": "common",
    "aarakocra": "aarakocra",
    "abyssal": "abyssal",
    "aquan": "aquan",
    "auran": "auran",
    "celestial": "celestial",
    "deep speech": "deep",
    "draconic": "draconic",
    "druidic": "druidic",
    "dwarvish": "dwarvish",
    "elvish": "elvish",
    "giant": "giant",
    "gith": "gith",
    "gnomish": "gnomish",
    "goblin": "goblin",
    "gnoll": "gnoll",
    "halfling": "halfling",
    "ignan": "ignan",
    "infernal": "infernal",
    "orc": "orc",
    "primordial": "primordial",
    "sylvan": "sylvan",
    "terran": "terran",
    "thieves' cant": "cant",
    "undercommon": "undercommon",
};
UtilActors.LANGUAGES_PRIMORDIAL = ["aquan", "auran", "ignan", "terran", ];
UtilActors._VET_CASTER_TYPE_TO_FVTT = {
    "full": "full",
    "1/2": "half",
    "1/3": "third",
    "pact": "pact",
    "artificer": "artificer",
};
UtilActors.ARMOR_PROFICIENCIES = ["light", "medium", "heavy", "shield|phb", ];
UtilActors.VALID_ARMOR_PROFICIENCIES = {
    "light": "lgt",
    "medium": "med",
    "heavy": "hvy",
    "shield|phb": "shl",
};
UtilActors.WEAPON_PROFICIENCIES = ["battleaxe|phb", "club|phb", "dagger|phb", "flail|phb", "glaive|phb", "greataxe|phb", "greatclub|phb", "greatsword|phb", "halberd|phb", "handaxe|phb", "javelin|phb", "lance|phb", "light hammer|phb", "longsword|phb", "mace|phb", "maul|phb", "morningstar|phb", "pike|phb", "quarterstaff|phb", "rapier|phb", "scimitar|phb", "shortsword|phb", "sickle|phb", "spear|phb", "staff|phb", "trident|phb", "war pick|phb", "warhammer|phb", "whip|phb", "blowgun|phb", "dart|phb", "hand crossbow|phb", "heavy crossbow|phb", "light crossbow|phb", "longbow|phb", "net|phb", "shortbow|phb", "sling|phb", ];
UtilActors.VALID_WEAPON_PROFICIENCIES = {
    "simple": "sim",
    "martial": "mar",

    "club|phb": "club",
    "dagger|phb": "dagger",
    "dart|phb": "dart",
    "greatclub|phb": "greatclub",
    "handaxe|phb": "handaxe",
    "javelin|phb": "javelin",
    "light crossbow|phb": "lightcrossbow",
    "light hammer|phb": "lighthammer",
    "mace|phb": "mace",
    "quarterstaff|phb": "quarterstaff",
    "shortbow|phb": "shortbow",
    "sickle|phb": "sickle",
    "sling|phb": "sling",
    "spear|phb": "spear",

    "battleaxe|phb": "battleaxe",
    "blowgun|phb": "blowgun",
    "flail|phb": "flail",
    "glaive|phb": "glaive",
    "greataxe|phb": "greataxe",
    "greatsword|phb": "greatsword",
    "halberd|phb": "halberd",
    "hand crossbow|phb": "handcrossbow",
    "heavy crossbow|phb": "heavycrossbow",
    "lance|phb": "lance",
    "longbow|phb": "longbow",
    "longsword|phb": "longsword",
    "maul|phb": "maul",
    "morningstar|phb": "morningstar",
    "net|phb": "net",
    "pike|phb": "pike",
    "rapier|phb": "rapier",
    "scimitar|phb": "scimitar",
    "shortsword|phb": "shortsword",
    "trident|phb": "trident",
    "war pick|phb": "warpick",
    "warhammer|phb": "warhammer",
    "whip|phb": "whip",
};
UtilActors._WEAPON_PROFICIENCIES_TO_ITEM_UIDS = {
    "battleaxes": "battleaxe|phb",
    "clubs": "club|phb",
    "daggers": "dagger|phb",
    "flails": "flail|phb",
    "glaives": "glaive|phb",
    "greataxes": "greataxe|phb",
    "greatclubs": "greatclub|phb",
    "greatswords": "greatsword|phb",
    "halberds": "halberd|phb",
    "handaxes": "handaxe|phb",
    "javelins": "javelin|phb",
    "lances": "lance|phb",
    "light hammers": "light hammer|phb",
    "longswords": "longsword|phb",
    "maces": "mace|phb",
    "mauls": "maul|phb",
    "morningstars": "morningstar|phb",
    "pikes": "pike|phb",
    "quarterstaffs": "quarterstaff|phb",
    "rapiers": "rapier|phb",
    "scimitars": "scimitar|phb",
    "shortswords": "shortsword|phb",
    "sickles": "sickle|phb",
    "spears": "spear|phb",
    "staffs": "staff|phb",
    "tridents": "trident|phb",
    "war picks": "war pick|phb",
    "warhammers": "warhammer|phb",
    "whips": "whip|phb",

    "blowguns": "blowgun|phb",
    "darts": "dart|phb",
    "hand crossbows": "hand crossbow|phb",
    "heavy crossbows": "heavy crossbow|phb",
    "light crossbows": "light crossbow|phb",
    "longbows": "longbow|phb",
    "nets": "net|phb",
    "shortbows": "shortbow|phb",
    "slings": "sling|phb",

    "battleaxe": "battleaxe|phb",
    "club": "club|phb",
    "dagger": "dagger|phb",
    "flail": "flail|phb",
    "glaive": "glaive|phb",
    "greataxe": "greataxe|phb",
    "greatclub": "greatclub|phb",
    "greatsword": "greatsword|phb",
    "halberd": "halberd|phb",
    "handaxe": "handaxe|phb",
    "javelin": "javelin|phb",
    "lance": "lance|phb",
    "light hammer": "light hammer|phb",
    "longsword": "longsword|phb",
    "mace": "mace|phb",
    "maul": "maul|phb",
    "morningstar": "morningstar|phb",
    "pike": "pike|phb",
    "quarterstaff": "quarterstaff|phb",
    "rapier": "rapier|phb",
    "scimitar": "scimitar|phb",
    "shortsword": "shortsword|phb",
    "sickle": "sickle|phb",
    "spear": "spear|phb",
    "staff": "staff|phb",
    "trident": "trident|phb",
    "war pick": "war pick|phb",
    "warhammer": "warhammer|phb",
    "whip": "whip|phb",

    "blowgun": "blowgun|phb",
    "dart": "dart|phb",
    "hand crossbow": "hand crossbow|phb",
    "heavy crossbow": "heavy crossbow|phb",
    "light crossbow": "light crossbow|phb",
    "longbow": "longbow|phb",
    "net": "net|phb",
    "shortbow": "shortbow|phb",
    "sling": "sling|phb",
};
UtilActors._TOOL_PROFICIENCIES_TO_ITEM_UIDS = {
    "alchemist's supplies": "alchemist's supplies|phb",
    "artisan's tools": "artisan's tools|phb",
    "bagpipes": "bagpipes|phb",
    "brewer's supplies": "brewer's supplies|phb",
    "calligrapher's supplies": "calligrapher's supplies|phb",
    "carpenter's tools": "carpenter's tools|phb",
    "cartographer's tools": "cartographer's tools|phb",
    "cobbler's tools": "cobbler's tools|phb",
    "cook's utensils": "cook's utensils|phb",
    "disguise kit": "disguise kit|phb",
    "drum": "drum|phb",
    "dulcimer": "dulcimer|phb",
    "flute": "flute|phb",
    "forgery kit": "forgery kit|phb",
    "glassblower's tools": "glassblower's tools|phb",
    "herbalism kit": "herbalism kit|phb",
    "horn": "horn|phb",
    "jeweler's tools": "jeweler's tools|phb",
    "leatherworker's tools": "leatherworker's tools|phb",
    "lute": "lute|phb",
    "lyre": "lyre|phb",
    "mason's tools": "mason's tools|phb",
    "musical instrument": "musical instrument|phb",
    "navigator's tools": "navigator's tools|phb",
    "painter's supplies": "painter's supplies|phb",
    "pan flute": "pan flute|phb",
    "poisoner's kit": "poisoner's kit|phb",
    "potter's tools": "potter's tools|phb",
    "shawm": "shawm|phb",
    "smith's tools": "smith's tools|phb",
    "thieves' tools": "thieves' tools|phb",
    "tinker's tools": "tinker's tools|phb",
    "viol": "viol|phb",
    "weaver's tools": "weaver's tools|phb",
    "woodcarver's tools": "woodcarver's tools|phb",
};

UtilActors.BG_SKILL_PROFS_CUSTOMIZE = [{
    choose: {
        from: Object.keys(Parser.SKILL_TO_ATB_ABV),
        count: 2,
    },
}, ];

UtilActors.LANG_TOOL_PROFS_CUSTOMIZE = [{
    anyStandardLanguage: 2,
}, {
    anyStandardLanguage: 1,
    anyTool: 1,
}, {
    anyTool: 2,
}, ];
//#endregion

//#region UtilEntityBackground
class UtilEntityBase {
    static _PropNamespacer = null;

    static getCompendiumDeepKeys() {
        return null;
    }

    static getCompendiumAliases(ent, {isStrict=false}={}) {
        return [];
    }

    static getEntityAliases(ent, {isStrict=false}={}) {
        return [];
    }

    static getNamespacedProp(prop) {
        if (!this._PropNamespacer)
            throw new Error("Unimplemented!");
        return this._PropNamespacer.getNamespacedProp(prop);
    }

    static getUnNamespacedProp(propNamespaced) {
        if (!this._PropNamespacer)
            throw new Error("Unimplemented!");
        return this._PropNamespacer.getUnNamespacedProp(propNamespaced);
    }
}

class UtilEntityBackground extends UtilEntityBase {
    static getCompendiumAliases(ent, {isStrict=false}={}) {
        return this.getEntityAliases(ent).map(it=>it.name);
    }

    static getEntityAliases(ent, {isStrict=false}={}) {
        if (!ent.name)
            return [];
        return [];
    }

    static isCustomBackground(ent) {
        return ent?.name === "Custom Background" && ent?.source === Parser.SRC_PHB;
    }
}
//#endregion

class Charactermancer_FeatureSourceTracker extends BaseComponent {
    constructor() {
        super();
        this._registered = new Map();
    }

    register(comp) {
        this._registered.set(comp, {
            state: null,
            hookMetas: []
        });
    }

    _validateProp(propPulse) {
        if (!Charactermancer_FeatureSourceTracker._VALID_HOOK_PROPS.has(propPulse))
            throw new Error(`Unhandled pulse prop "${propPulse}"`);
    }

    addHook(comp, propPulse, hk) {
        this._validateProp(propPulse);

        if (!this._registered.has(comp))
            this.register(comp);

        this._registered.get(comp).hookMetas.push({
            propPulse,
            hook: hk
        });
        this._addHookBase(propPulse, hk);
    }

    removeHook(comp, propPulse, hk) {
        this._validateProp(propPulse);

        if (!this._registered.has(comp))
            return;

        const compMeta = this._registered.get(comp);
        const ixHook = compMeta.hookMetas.findIndex(it=>it.hook === hk);
        if (~ixHook)
            compMeta.hookMetas.splice(ixHook, 1);
        this._removeHookBase(propPulse, hk);
    }

    setState(comp, state) {
        if (!this._registered.has(comp)){this.register(comp);}
        const compMeta = this._registered.get(comp);

        const prevState = compMeta.state ? MiscUtil.copy(compMeta.state) : compMeta.state;
        compMeta.state = state;

        const allKeys = new Set([...Object.keys(prevState || {}), ...Object.keys(state || {}), ]);

        allKeys.forEach(k=>{
            const oldVal = prevState?.[k];
            const nuVal = state?.[k];

            if (CollectionUtil.deepEquals(oldVal, nuVal)){return;}

            this._doPulseForProp(k);
        });
    }

    /**
     * @param {string} key
     * @param {any} {ignore=null}={}
     * @returns {any}
     */
    getStatesForKey(key, {ignore=null}={}) {
        let out = [];
        for (const [comp, compMeta] of this._registered.entries()) {
            if (ignore === comp){ continue;}
            if (compMeta?.state?.[key]){out.push(compMeta.state[key]);}
        }
        return out;
    }

    unregister(comp) {
        if (!comp)
            return;

        const registered = this._registered.get(comp);
        if (!registered)
            return;

        this._registered.delete(comp);

        registered.hookMetas.forEach(({propPulse, hook})=>{
            this._removeHookBase(propPulse, hook);
        }
        );

        if (registered.state) {
            Object.keys(registered.state).forEach(k=>{
                this._doPulseForProp(k);
            }
            );
        }
    }

    _doPulseForProp(k) {
        switch (k) {
        case "skillProficiencies":
            return this._state.pulseSkillProficiencies = !this._state.pulseSkillProficiencies;
        case "languageProficiencies":
            return this._state.pulseLanguageProficiencies = !this._state.pulseLanguageProficiencies;
        case "toolProficiencies":
            return this._state.pulseToolProficiencies = !this._state.pulseToolProficiencies;
        case "armorProficiencies":
            return this._state.pulseArmorProficiencies = !this._state.pulseArmorProficiencies;
        case "weaponProficiencies":
            return this._state.pulseWeaponProficiencies = !this._state.pulseWeaponProficiencies;
        case "features":
            return this._state.pulseFeatures = !this._state.pulseFeatures;
        case "savingThrowProficiencies":
            return this._state.pulseSavingThrowProficiencies = !this._state.pulseSavingThrowProficiencies;
        case "immune":
            return this._state.pulseImmune = !this._state.pulseImmune;
        case "resist":
            return this._state.pulseResist = !this._state.pulseResist;
        case "vulnerable":
            return this._state.pulseVulnerable = !this._state.pulseVulnerable;
        case "conditionImmune":
            return this._state.pulseConditionImmune = !this._state.pulseConditionImmune;
        case "expertise":
            return this._state.pulseExpertise = !this._state.pulseExpertise;
        default:
            throw new Error(`Unhandled tracked state key ${k}`);
        }
    }

    _getDefaultState() {
        return [...Charactermancer_FeatureSourceTracker._VALID_HOOK_PROPS].mergeMap(it=>({
            [it]: false
        }));
    }
}
Charactermancer_FeatureSourceTracker._VALID_HOOK_PROPS = new Set(["pulseSkillProficiencies", "pulseLanguageProficiencies", "pulseToolProficiencies", "pulseArmorProficiencies", "pulseWeaponProficiencies", "pulseFeatures", "pulseSavingThrowProficiencies", "pulseImmune", "pulseResist", "pulseVulnerable", "pulseConditionImmune", "pulseExpertise", ]);

//#endregion

//#region Charactermancer Class
class ActorCharactermancerClass extends ActorCharactermancerBaseComponent {
    _data;
    _tabClass;
    _actor;

    constructor(parentInfo) {
      parentInfo = parentInfo || {};
      super();
      this._actor = parentInfo.actor;
      this._data = parentInfo.data; //data is an object containing information about all classes, subclasses, feats, etc
      this._parent = parentInfo.parent;
      this._tabClass = parentInfo.tabClass;
      //TEMPFIX
      this._modalFilterClasses = new ModalFilterClasses({//ModalFilterClassesFvtt({
        'namespace': "ActorCharactermancer.classes", 'allData': this._data.class
      });
      this._metaHksClassStgSubclass = [];
      this._compsClassStartingProficiencies = [];
      this._compsClassHpIncreaseMode = [];
      this._compsClassHpInfo = [];
      this._compsClassLevelSelect = [];
      this._compsClassFeatureOptionsSelect = [];
      this._compsClassSkillProficiencies = [];
      this._compsClassToolProficiencies = [];
      this._metaHksClassStgSkills = [];
      this._metaHksClassStgTools = [];
      this._metaHksClassStgStartingProficiencies = [];
      this._$wrpsClassTable = [];
      this._existingClassMetas = [];

    }
    //FINDME ActorCharactermancerClass.render
    render() {
        let wrptab = this._tabClass?.$wrpTab;
        if (!wrptab) { return; }
        let classChoiceElement = $(`<div class="ve-flex-col w-100 h-100 px-1 pt-1 overflow-y-auto ve-grow veapp__bg-foundry"></div>`);
        let sidebarElement = $(`<div class="ve-flex-col w-100 h-100 px-1 overflow-y-auto ve-grow veapp__bg-foundry"></div>`);
        for (let i = 0; i < this._state.class_ixMax + 1; ++i) {
          this._class_renderClass(classChoiceElement, sidebarElement, i);
        }
        this._addHookBase("class_ixPrimaryClass", () => this._state.class_pulseChange = !this._state.class_pulseChange);
  
        //ADD CLASS BUTTON
        const addClassBtn = $(`<button class="btn btn-5et btn-sm">Add Another Class</button>`)
        .click(() => {
          this._class_renderClass(classChoiceElement, sidebarElement, ++this._state.class_ixMax);
        });
  
  
        let o = $$`<div class="ve-flex w-100 h-100">
        <div class="ve-flex-col w-100">
            ${classChoiceElement}
            <div class="mt-2">${addClassBtn}</div>
        </div>
        <div class="vr-1"></div>
        ${sidebarElement}
        </div>`.appendTo(wrptab);
    }
    _class_renderClass(parentDiv_left, parentDiv_right, ix) {
        //Main properties for asking our _state for information on this class
        const {
            propPrefixClass: propPrefixClass,
            propIxClass: propIxClass,
            propPrefixSubclass: propPrefixSubclass,
            propIxSubclass: propIxSubclass,
            propCntAsi: propCntAsi,
            propCurLevel: propCurLevel,
            propTargetLevel: propTargetLevel
        } = ActorCharactermancerBaseComponent.class_getProps(ix);
        const filter_evnt_valchange_class = FilterBox.EVNT_VALCHANGE + ".class_" + ix + "_classLevels";
        const filter_evnt_valchange_subclass = FilterBox.EVNT_VALCHANGE + ".class_" + ix + "_subclass";

        const {
            lockChangeClass: lockChangeClass,
            lockChangeSubclass: lockChangeSubclass,
            lockRenderFeatureOptionsSelects: lockRenderFeatureOptionsSelects
        } = this.constructor._class_getLocks(ix);

        this._addHookBase(propIxClass, () => this._state.class_pulseChange = !this._state.class_pulseChange);

        //Create a searchable select field for choosing a class
        const {
            $wrp: wrapper, //Wrapper DOM for the dropdown menu DOM object
            $iptDisplay: inputDisplay, //a function that returns the visible name of a class that you provide the index for
            $iptSearch: inputSearch,
            fnUpdateHidden: fnUpdateHidden
        } = ComponentUiUtil.$getSelSearchable(this, propIxClass, {
            'values': this._data.class.map((_0x2b7aa2, _0x2f3ba4) => _0x2f3ba4), //Think this is just the ix's of the classes
            'isAllowNull': true,
            'fnDisplay': clsIx => {
                //Using a simple index, ask _data for the class
            const cls = this.getClass_({'ix': clsIx });
            if (!cls) {
                console.warn(...LGT, "Could not find class with index " + clsIx + " (" + this._data.class.length + " classes were available)");
                return '(Unknown)';
            }
            //Then return what should be the displayed name
            return cls.name + " " + (cls.source !== Parser.SRC_PHB ? '[' + Parser.sourceJsonToAbv(cls.source) + ']' : '');
            },
            'fnGetAdditionalStyleClasses': classIx => {
                if (classIx == null) { return null; }
                const cls = this.getClass_({'ix': classIx});
                if (!cls) { return; }
                return cls._versionBase_isVersion ? ['italic'] : null;
            },
            'asMeta': true,
            'isDisabled': this._class_isClassSelectionDisabled({'ix': ix })
        });

        inputDisplay.addClass("bl-0");
        inputSearch.addClass("bl-0");

        const updateHiddenClasses = () => {
            const filterValues = this._modalFilterClasses.pageFilter.filterBox.getValues();
            const classes = this._data.class.map(cls => !this._modalFilterClasses.pageFilter.toDisplay(filterValues, cls));
            fnUpdateHidden(classes, false);
        };

        const applySubclassFilter = () => {
            const cls = this.getClass_({'propIxClass': propIxClass});
            if (!cls || !this._metaHksClassStgSubclass[ix]) { return; }
            const filteredValues = this._modalFilterClasses.pageFilter.filterBox.getValues();
            const displayableSubclasses = cls.subclasses.map(val => !this._modalFilterClasses.pageFilter.toDisplay(filteredValues, val));
            this._metaHksClassStgSubclass[ix].fnUpdateHidden(displayableSubclasses, false);
        };

        if(SETTINGS.FILTERS){
            this._modalFilterClasses.pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, () => updateHiddenClasses());
            updateHiddenClasses();
        }
        const filterBtn = $("<button class=\"btn btn-xs btn-5et h-100 btr-0 bbr-0 pr-2\" title=\"Filter for Class and Subclass\"><span class=\"glyphicon glyphicon-filter\"></span> Filter</button>")
        .click(async () => {
            const cls = this.getClass_({'propIxClass': propIxClass });
            const subcls = this.getSubclass_({'cls': cls, 'propIxSubclass': propIxSubclass});
            const classSelectDisabled = this._class_isClassSelectionDisabled({
            'ix': ix
            });
            const subclassSelectDisabled = this._class_isSubclassSelectionDisabled({
            'ix': ix
            });
            const userSelection = await this._modalFilterClasses.pGetUserSelection({
            'selectedClass': cls,
            'selectedSubclass': subcls,
            'isClassDisabled': classSelectDisabled,
            'isSubclassDisabled': subclassSelectDisabled
            });
            if (classSelectDisabled && subclassSelectDisabled) {
            return;
            }
            if (userSelection == null || !userSelection.class) {
            return;
            }
            const class_index = this._data.class.findIndex(_0x46996f => _0x46996f.name === userSelection.class.name && _0x46996f.source === userSelection['class'].source);
            if (!~class_index) {
            throw new Error("Could not find selected class: " + JSON.stringify(userSelection["class"]));
            }
            this._state[propIxClass] = class_index;
            await this._pGate(lockChangeClass);
            if (userSelection.subclass != null) {
            const cls = this.getClass_({
                'propIxClass': propIxClass
            });
            const subcls_index = cls.subclasses.findIndex(_0x482224 => _0x482224.name === userSelection.subclass.name && _0x482224.source === userSelection.subclass.source);
            if (!~subcls_index) {
                throw new Error("Could not find selected subclass: " + JSON.stringify(userSelection.subclass));
            }
            this._state[propIxSubclass] = subcls_index;
            } else {
            this._state[propIxSubclass] = null;
            }
        });

        //#region Render Class
        const renderClassComponents = async _0xd4d6f7 => {
            if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.off(filter_evnt_valchange_subclass);}
            //FIXME SET STATE!
            if (_0xd4d6f7) {
                const toObj = Object.keys(this.__state).filter(propName => propName.startsWith(propPrefixClass) && propName !== propIxClass).mergeMap(_0x77ce3e => ({
                    [_0x77ce3e]: null
                }));
                this._proxyAssignSimple("state", toObj);
            }
            //First time this function is called, we will probably not get anything out of getClass since we haven't set anything to _state yet
            const cls = this.getClass_({'propIxClass': propIxClass});
            const subcls = this.getSubclass_({
            'cls': cls,
            'propIxSubclass': propIxSubclass
            });

            this._class_renderClass_stgSelectSubclass({
            '$stgSelectSubclass': holder_selectSubclass,
            'cls': cls,
            'ix': ix,
            'propIxSubclass': propIxSubclass,
            'idFilterBoxChangeSubclass': filter_evnt_valchange_subclass,
            'doApplyFilterToSelSubclass': applySubclassFilter
            });
            this._class_renderClass_stgHpMode({
            '$stgHpMode': holder_hpMode,
            'ix': ix,
            'cls': cls
            });
            this._class_renderClass_stgHpInfo({
            '$stgHpInfo': holder_hpInfo,
            'ix': ix,
            'cls': cls
            }); 
            this._class_renderClass_stgStartingProficiencies({
            '$stgStartingProficiencies': holder_startingProf,
            'ix': ix,
            'cls': cls
            });

            //Now create the level select UI
            await this._class_renderClass_pStgLevelSelect({
            '$stgLevelSelect': holder_levelSelect,
            '$stgFeatureOptions': holder_featureOptions,
            'ix': ix,
            'cls': cls,
            'sc': subcls,
            'propIxSubclass': propIxSubclass,
            'propCurLevel': propCurLevel,
            'propTargetLevel': propTargetLevel,
            'propCntAsi': propCntAsi,
            'lockRenderFeatureOptionsSelects': lockRenderFeatureOptionsSelects,
            'idFilterBoxChangeClassLevels': filter_evnt_valchange_class
            });
            this._state.class_totalLevels = this.class_getTotalLevels();

            //Create the element that lets us choose skill proficiencies
            this._class_renderClass_stgSkills({ '$stgSkills': holder_skills, 'ix': ix, 'propIxClass': propIxClass });

            //Create the element that lets us choose tool proficiencies
            this._class_renderClass_stgTools({ '$stgTools': holder_tools, 'ix': ix, 'propIxClass': propIxClass })

            //Create the element that handles drawing info about our class
            await this._class_renderClass_pDispClass({
                'ix': ix,
                '$dispClass': holder_dispClass,
                'cls': cls,
                'sc': subcls
            });
            //Also clear the element that displays info about our subclass
            disp_subclass.empty();
        };

        const renderClassComponents_safe = async _0x7a25e5 => {
            try {
            await this._pLock(lockChangeClass);
            await renderClassComponents(_0x7a25e5);
            } finally {
            this._unlock(lockChangeClass);
            }
        };

        //Add a hook so that when propIxClass changes, we try to render the class components again
        this._addHookBase(propIxClass, renderClassComponents_safe);
        //#endregion

        //#region Render Subclass
        const renderSubclassComponents = async () => {
            if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.off(filter_evnt_valchange_subclass);}
            const toObj = Object.keys(this.__state).filter(prop => prop.startsWith(propPrefixSubclass) && prop !== propIxSubclass).mergeMap(_0x207fe4 => ({
            [_0x207fe4]: null
            }));
            this._proxyAssignSimple("state", toObj);
            const cls = this.getClass_({
            'propIxClass': propIxClass
            });
            const subcls = this.getSubclass_({
            'cls': cls,
            'propIxSubclass': propIxSubclass
            });
            /* const filteredFeatures = this._class_getFilteredFeatures(cls, subcls);
            if (this._compsClassLevelSelect[ix]) {
            this._compsClassLevelSelect[ix].setFeatures(filteredFeatures);
            }
            await this._class_pRenderFeatureOptionsSelects({
            'ix': ix,
            'propCntAsi': propCntAsi,
            'filteredFeatures': filteredFeatures,
            '$stgFeatureOptions': holder_featureOptions,
            'lockRenderFeatureOptionsSelects': _0x3217e0
            }); */
            if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.on(filter_evnt_valchange_subclass, () => applySubclassFilter());}
            /* applySubclassFilter();
            await this._class_renderClass_pDispSubclass({
            'ix': ix,
            '$dispSubclass': disp_subclass,
            'cls': cls,
            'sc': subcls
            }); */
        };
        const renderSubclass_safe = async () => {
            try {
            await this._pLock(lockChangeSubclass);
            await renderSubclassComponents();
            } finally {
            this._unlock(lockChangeSubclass);
            }
        };
        this._addHookBase(propIxSubclass, renderSubclass_safe);
        //#endregion

        //Create parent objects to hold subcomponents, hide the later ones
        const header = $("<div class=\"bold\">Select a Class</div>");
        const holder_selectSubclass = $(`<div class="ve-flex-col w-100"></div>`).hideVe();
        const holder_hpMode = $(`<div class="ve-flex-col"></div>`).hideVe();
        const holder_hpInfo = $(`<div class="ve-flex-col"></div>`).hideVe();
        const holder_startingProf = $(`<div class="ve-flex-col"></div>`).hideVe();
        const holder_levelSelect = $(`<div class="ve-flex-col"></div>`).hideVe();
        const holder_featureOptions = $(`<div class="ve-flex-col"></div>`).hideVe();
        const holder_skills = $(`<div class="ve-flex-col"></div>`).hideVe();
        const holder_tools = $(`<div class="ve-flex-col"></div>`).hideVe();

        let primaryBtn = null;
        if (!this._existingClassMetas.length) {
            primaryBtn = $("<button class=\"btn btn-5et btn-xs mr-2\"></button>").click(() => this._state.class_ixPrimaryClass = ix);
            const primaryBtnHover = () => {
            primaryBtn.text(this._state.class_ixPrimaryClass === ix ? "Primary Class" : "Make Primary").title(this._state.class_ixPrimaryClass === ix ? "This is your primary class, i.e. the one you chose at level 1 for the purposes of proficiencies/etc." : "Make this your primary class, i.e. the one you chose at level 1 for the purposes of proficiencies/etc.").prop("disabled", this._state.class_ixPrimaryClass === ix);
            };
            this._addHookBase("class_ixPrimaryClass", primaryBtnHover);
            primaryBtnHover();
        }

        const minimizerToggle = $("<div class=\"py-1 clickable ve-muted\">[‒]</div>").click(() => {
            const isMinimized = minimizerToggle.text() === '[+]';
            minimizerToggle.text(isMinimized ? "[‒]" : "[+]");
            if (isMinimized) {
            header.text("Select a Class");
            } else {
            const cls = this.getClass_({'propIxClass': propIxClass});
            const subcls = this.getSubclass_({
                'cls': cls,
                'propIxSubclass': propIxSubclass
            });
            if (cls) { header.text('' + cls.name + (subcls ? " (" + subcls.name + ')' : ''));}
            else { header.text("Select a Class"); }
            }
            classChoicePanels.toggleVe();
        });
        
        const holder_dispClass = $(`<div class="ve-flex-col w-100"></div>`);
        const disp_subclass = $(`<div class="ve-flex-col w-100"></div>`);

        const classChoicePanels = $$`<div class="ve-flex-col w-100 mt-2">
            <div class="ve-flex btn-group w-100">
                <div class="ve-flex no-shrink">
                    ${filterBtn}
                </div>
                <div class="ve-flex-col w-100">
                    ${wrapper}
                    ${holder_selectSubclass}
                </div>
            </div>
            ${holder_hpMode}
            ${holder_hpInfo}
            ${holder_startingProf}
            ${holder_skills}
            ${holder_tools}
            ${holder_levelSelect}
            ${holder_featureOptions}
        </div>`;

        const classChoicePanelsWrapper = $$`<div class="ve-flex-col">
            ${ix>0? `<hr class=\"hr-3 hr--heavy\">`:''}
            <div class="split-v-center">
                ${header}
                <div class="ve-flex-v-center">
                    ${primaryBtn}
                    ${minimizerToggle}
                </div>
            </div>

            ${classChoicePanels}
        </div>`;
        classChoicePanelsWrapper.appendTo(parentDiv_left);

        //Sidebar display (class text info)
        const sidebarContent = $$`<div>
            ${ix>0?'<hr\x20class=\x22hr-2\x20hr--heavy\x22>':''}

            ${holder_dispClass}
            ${disp_subclass}
        </div>`.appendTo(parentDiv_right);

        renderClassComponents_safe().then(() => renderSubclass_safe());
    }

    get modalFilterClasses() {
      return this._modalFilterClasses;
    }
    get compsClassStartingProficiencies() {
      return this._compsClassStartingProficiencies;
    }
    get compsClassHpIncreaseMode() {
      return this._compsClassHpIncreaseMode;
    }
    get compsClassLevelSelect() {
      return this._compsClassLevelSelect;
    }
    get compsClassFeatureOptionsSelect() {
      return this._compsClassFeatureOptionsSelect;
    }
    get compsClassSkillProficiencies() {
      return this._compsClassSkillProficiencies;
    }
    get compsClassToolProficiencies() {
      return this._compsClassToolProficiencies;
    }
    get existingClassMetas() {
      return this._existingClassMetas;
    }
    /**Load some information prior to first rendering. Just to do with loading from the modal and loading existing data from actor */
    async pLoad() {
      await this._modalFilterClasses.pPreloadHidden();
      if(!SETTINGS.USE_EXISTING){return;} //TEMPFIX
      await this._pLoad_pDoHandleExistingClassItems();
    }
    async _pLoad_pDoHandleExistingClassItems() {
      const _0x1c249f = this._actor.items.filter(_0x5de464 => _0x5de464.type === 'class');
      const _0x3dab8a = this._actor.items.filter(_0x248afa => _0x248afa.type === 'subclass');
      this._existingClassMetas = _0x1c249f.map(_0x122387 => {
        const _0x39760a = this._pLoad_getExistingClassIndex(_0x122387);
        const _0x56b925 = _0x3dab8a.find(_0x162fde => _0x162fde.system.classIdentifier === _0x122387.system.identifier);
        let _0xa0d172 = this._pLoad_getExistingSubclassIndex(_0x39760a, _0x56b925);
        const _0x5372b3 = this._actor.system?.details?.['originalClass'] ? this._actor.system?.details?.originalClass === _0x122387.id : !!_0x122387.flags?.[SharedConsts.MODULE_ID]?.['isPrimaryClass'];
        const _0x55c437 = ~_0x39760a ? null : "Could not find class \"" + _0x122387.name + "\" (\"" + UtilDocumentSource.getDocumentSourceDisplayString(_0x122387) + "\") in loaded data. " + Charactermancer_Util.STR_WARN_SOURCE_SELECTION;
        if (_0x55c437) {
          ui.notifications.warn(_0x55c437);
          console.warn(...LGT, _0x55c437, "Strict source matching is: " + Config.get("import", "isStrictMatching") + '.');
        }
        const _0x530b46 = _0x56b925 == null || ~_0xa0d172 ? null : "Could not find subclass \"" + _0x56b925.name + "\" in loaded data. " + Charactermancer_Util.STR_WARN_SOURCE_SELECTION;
        if (_0x530b46) {
          ui.notifications.warn(_0x530b46);
          console.warn(...LGT, _0x530b46, "Strict source matching is: " + Config.get("import", "isStrictMatching") + '.');
        }
        return new ActorCharactermancerClass.ExistingClassMeta({
          'item': _0x122387,
          'ixClass': _0x39760a,
          'isUnknownClass': !~_0x39760a,
          'ixSubclass': _0xa0d172,
          'isUnknownSubclass': _0xa0d172 == null && !~_0xa0d172,
          'level': Number(_0x122387.system.levels || 0x0),
          'isPrimary': _0x5372b3,
          'spellSlotLevelSelection': _0x122387?.flags?.[SharedConsts.MODULE_ID]?.['spellSlotLevelSelection']
        });
      });
      if (!this._existingClassMetas.length) {
        return;
      }
      this._state.class_ixMax = this._existingClassMetas.length - 0x1;
      for (let _0xfaa7c6 = 0x0; _0xfaa7c6 < this._existingClassMetas.length; ++_0xfaa7c6) {
        const _0x325547 = this._existingClassMetas[_0xfaa7c6];
        const {
          propIxClass: _0x57fec3,
          propIxSubclass: _0x4335dc
        } = ActorCharactermancerBaseComponent.class_getProps(_0xfaa7c6);
        await this._pDoProxySetBase(_0x57fec3, _0x325547.ixClass);
        await this._pDoProxySetBase(_0x4335dc, _0x325547.ixSubclass);
        if (_0x325547.isPrimary) {
          this._state.class_ixPrimaryClass = _0xfaa7c6;
        }
      }
      if (!this._existingClassMetas.some(_0x34ec7d => _0x34ec7d.isPrimary)) {
        this._state.class_ixPrimaryClass = 0x0;
      }
    }
    _pLoad_getExistingClassIndex(_0x31ccce) {
      const _0x9c6a99 = _0x31ccce.flags?.[SharedConsts.MODULE_ID];
      if (_0x9c6a99?.propDroppable === 'class' && _0x9c6a99?.source && _0x9c6a99?.hash) {
        const _0x4fb2d3 = this._data["class"].findIndex(_0xc280a8 => _0x9c6a99.source === _0xc280a8.source && _0x9c6a99.hash === UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](_0xc280a8));
        if (~_0x4fb2d3) {
          return _0x4fb2d3;
        }
      }
      const _0x22658f = (IntegrationBabele.getOriginalName(_0x31ccce) || '').toLowerCase().trim();
      const _0xf5d9aa = this._data['class'].findIndex(_0x5112df => {
        return _0x22658f === _0x5112df.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(_0x31ccce).source || '').toLowerCase() === Parser.sourceJsonToAbv(_0x5112df.source).toLowerCase());
      });
      if (~_0xf5d9aa) {
        return _0xf5d9aa;
      }
      const _0x4d5c9d = /^(.*?)\(.*\)$/.exec(_0x22658f);
      if (!_0x4d5c9d) {
        return -0x1;
      }
      return this._data["class"].findIndex(_0x12f0b7 => {
        return _0x4d5c9d[0x1].trim() === _0x12f0b7.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(_0x31ccce).source || '').toLowerCase() === Parser.sourceJsonToAbv(_0x12f0b7.source).toLowerCase());
      });
    }
    _pLoad_getExistingSubclassIndex(_0x161fa4, _0x3e14d4) {
      if (!_0x3e14d4 || !~_0x161fa4) {
        return null;
      }
      const _0x10558f = this._data['class'][_0x161fa4];
      const _0x50af12 = _0x3e14d4.flags?.[SharedConsts.MODULE_ID];
      if (_0x50af12?.["propDroppable"] === "subclass" && _0x50af12?.["source"] && _0x50af12?.["hash"]) {
        const _0x37d579 = _0x10558f.subclasses.findIndex(_0x5067b7 => _0x50af12.source === _0x5067b7.source && _0x50af12.hash === UrlUtil.URL_TO_HASH_BUILDER.subclass(_0x5067b7));
        if (~_0x37d579) {
          return _0x37d579;
        }
      }
      return _0x10558f.subclasses.findIndex(_0x54c0e7 => (IntegrationBabele.getOriginalName(_0x3e14d4) || '').toLowerCase().trim() === _0x54c0e7.name.toLowerCase().trim() && (!Config.get("import", 'isStrictMatching') || (UtilDocumentSource.getDocumentSource(_0x3e14d4).source || '').toLowerCase() === Parser.sourceJsonToAbv(_0x54c0e7.source).toLowerCase()));
    }
    getExistingClassTotalLevels_() {
        //TEMPFIX
        if(!SETTINGS.USE_EXISTING){return 0;}
        return this._existingClassMetas.filter(Boolean).map(_0x29ccbb => _0x29ccbb.level).sum();
    }
    _getExistingClassCount() {
      return this._existingClassMetas.filter(Boolean).length;
    }
    getClass_({ix: ix, propIxClass: propIxClass}) {
      if (ix == null && propIxClass == null) { throw new Error("At least one argument must be provided!"); }
      //If a propIxClass was provived, try to get the class from this._state
      if (propIxClass != null) {
        if (this._state[propIxClass] == null) { return null;  }
        if (!~this._state[propIxClass]) { return DataConverterClass.getClassStub(); }
        return this._data.class[this._state[propIxClass]];
      }
      //Otherwise, try to get it from this._data, if we have an ix
      if (ix != null && ~ix) { return this._data.class[ix];}
      return DataConverterClass.getClassStub();
    }
    getSubclass_({
      cls: _0x5c8967,
      propIxSubclass: _0x3ff653,
      ix: _0x325aa4
    }) {
      if (_0x325aa4 == null && _0x3ff653 == null) {
        throw new Error("At least one argument must be provided!");
      }
      if (!_0x5c8967) {
        return null;
      }
      if (_0x3ff653 != null) {
        if (this._state[_0x3ff653] == null) {
          return null;
        }
        if (!~this._state[_0x3ff653]) {
          return DataConverterClass.getSubclassStub({
            'cls': _0x5c8967
          });
        }
        if (!_0x5c8967.subclasses?.["length"]) {
          return DataConverterClass.getSubclassStub({
            'cls': _0x5c8967
          });
        }
        return _0x5c8967.subclasses[this._state[_0x3ff653]];
      }
      if (_0x325aa4 != null && ~_0x325aa4) {
        return _0x5c8967.subclasses[_0x325aa4];
      }
      return DataConverterClass.getSubclassStub({
        'cls': _0x5c8967
      });
    }
    _class_isClassSelectionDisabled({
      ix: _0x5bbf32
    }) {
      return !!this._existingClassMetas[_0x5bbf32];
    }
    _class_isSubclassSelectionDisabled({
      ix: _0x3ccf09
    }) {
      return this._existingClassMetas[_0x3ccf09] && (this._existingClassMetas[_0x3ccf09].ixSubclass != null || this._existingClassMetas[_0x3ccf09].isUnknownClass);
    }
    
    static _class_getLocks(ix) {
      return {
        'lockChangeClass': 'class_' + ix + '_pHkChangeClass',
        'lockChangeSubclass': "class_" + ix + '_pHkChangeSubclass',
        'lockRenderFeatureOptionsSelects': 'class_' + ix + "_renderFeatureOptionsSelects"
      };
    }
    
    
    _class_renderClass_stgSelectSubclass({
      $stgSelectSubclass: stgSelectSubclass,
      cls: cls,
      ix: ix,
      propIxSubclass: propIxSubclass,
      idFilterBoxChangeSubclass: idFilterBoxChangeSubclass,
      doApplyFilterToSelSubclass: doApplyFilterToSelSubclass
    }) {
      stgSelectSubclass.empty();
      if (this._metaHksClassStgSubclass[ix]) { this._metaHksClassStgSubclass[ix].unhook(); }
      if(cls == null){console.error("Class is null");}
      if (cls && cls.subclasses && cls.subclasses.length) {
        const uiSearchElement = ComponentUiUtil.$getSelSearchable(this, propIxSubclass, {
          'values': cls.subclasses.map((a, b) => b),
          'isAllowNull': true,
          'fnDisplay': ix => {
            const subcls = this.getSubclass_({'cls': cls, 'ix': ix });
            if (!subcls) {
              console.warn(...LGT, "Could not find subclass with index " + ix + " (" + cls.subclasses.length + " subclasses were available for class " + cls.name + ')');
              return '(Unknown)';
            }
            return subcls.name + " " + (subcls.source !== Parser.SRC_PHB ? '[' + Parser.sourceJsonToAbv(subcls.source) + ']' : '');
          },
          'fnGetAdditionalStyleClasses': ix => {
            if (ix == null) { return null; }
            const subcls = this.getSubclass_({'cls': cls, 'ix': ix });
            if (!subcls) { return; }
            return subcls._versionBase_isVersion ? ['italic'] : null;
          },
          'asMeta': true,
          'isDisabled': this._class_isSubclassSelectionDisabled({'ix': ix}),
          'displayNullAs': "Select a Subclass"
        });
        uiSearchElement.$iptDisplay.addClass('bl-0');
        uiSearchElement.$iptSearch.addClass("bl-0");
        this._metaHksClassStgSubclass[ix] = uiSearchElement;
        this._modalFilterClasses.pageFilter.filterBox.on(idFilterBoxChangeSubclass, () => doApplyFilterToSelSubclass());
        doApplyFilterToSelSubclass();
        const wrp = $$`<div class="ve-flex-col w-100 mt-1">${uiSearchElement.$wrp}</div>`;
        stgSelectSubclass.showVe().append(wrp);
      }
      else {
        console.error("No subclasses found");
        console.log(cls);
        stgSelectSubclass.hideVe();
        this._metaHksClassStgSubclass[ix] = null;
      }
    }
    //#region Health
    /**Create the display for the choice of HP gain mode for our class (average, roll, etc) */
    _class_renderClass_stgHpMode({
      $stgHpMode: parentElement,
      ix: ix,
      cls: cls
    }) {
      parentElement.empty();
      if (cls && Charactermancer_Class_HpIncreaseModeSelect.isHpAvailable(cls)) {
        parentElement.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Hit Points Increase Mode</div>");
        this._compsClassHpIncreaseMode[ix] = new Charactermancer_Class_HpIncreaseModeSelect();
        this._compsClassHpIncreaseMode[ix].render(parentElement);
      }
      else {
        parentElement.hideVe();
        this._compsClassHpIncreaseMode[ix] = null;
      }
    }
    /**Create the display for how our health will look as we level up */
    _class_renderClass_stgHpInfo({
      $stgHpInfo: parentElement,
      ix: ix,
      cls: cls
    }) {
      parentElement.empty();
      if (cls && Charactermancer_Class_HpIncreaseModeSelect.isHpAvailable(cls)) {
        parentElement.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Hit Points</div>");
        this._compsClassHpInfo[ix] = new Charactermancer_Class_HpInfo({
          'className': cls.name,
          'hitDice': cls.hd
        });
        this._compsClassHpInfo[ix].render(parentElement);
      }
      else {
        parentElement.hideVe();
        this._compsClassHpInfo[ix] = null;
      }
    }
    //#endregion

    //#region Level Select
    /**Render a LevelSelect element */
    async _class_renderClass_pStgLevelSelect({
        $stgLevelSelect: ele_levelSelect,
        $stgFeatureOptions: ele_featureOptions,
        ix: ix,
        cls: cls,
        sc: sc,
        propIxSubclass: propIxSubclass,
        propCurLevel: propCurLevel,
        propTargetLevel: propTargetLevel,
        propCntAsi: propCntAsi,
        lockRenderFeatureOptionsSelects: lockRenderFeatureOptionsSelects,
        idFilterBoxChangeClassLevels: idFilterBoxChangeClassLevels
    }) {
        ele_levelSelect.empty();
        if (cls) {
            ele_levelSelect.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Select Levels</div>");
            const filteredFeatures = this._class_getFilteredFeatures(cls, sc);

            //TEMPFIX
            const existingClassMeta = SETTINGS.USE_EXISTING? this._class_getExistingClassMeta(ix) : null;
            this._compsClassLevelSelect[ix] = new Charactermancer_Class_LevelSelect({
                'features': filteredFeatures,
                'isRadio': true,
                'isForceSelect': this.getExistingClassTotalLevels_() === 0 || !existingClassMeta,
                'maxPreviousLevel': existingClassMeta?.["level"],
                'isSubclass': true
            });
            this._compsClassLevelSelect[ix].render(ele_levelSelect);

            const e_onChangeLevelSelected = async () => {
                const subclass = this.getSubclass_({'cls': cls, 'propIxSubclass': propIxSubclass});
                const _features = this._class_getFilteredFeatures(cls, subclass);
                //_features should have loadeds, an each in loadeds should have entity
                //some of these entity should have an entryData, but this is only for specific choice class features
                

                //Debug
                for(let f of _features){
                    if(f.level == 3 && (f.name == "Expertise" || f.name == "Primal Knowledge") && !f.loadeds[0].entity.entryData){
                        console.error("Class feature " + f.name + " is missing their entrydata!");
                    }
                }

                //Re-render the Feature Options Selects
                await this._class_pRenderFeatureOptionsSelects({
                    'ix': ix,
                    'propCntAsi': propCntAsi,
                    'filteredFeatures': _features,
                    '$stgFeatureOptions': ele_featureOptions,
                    'lockRenderFeatureOptionsSelects': lockRenderFeatureOptionsSelects
                });
                this._state[propCurLevel] = this._compsClassLevelSelect[ix].getCurLevel();
                this._state[propTargetLevel] = this._compsClassLevelSelect[ix].getTargetLevel();
                this._state.class_totalLevels = this.class_getTotalLevels();
            };

            this._compsClassLevelSelect[ix].onchange(e_onChangeLevelSelected);
            await e_onChangeLevelSelected();

            if(SETTINGS.FILTERS){ //TEMPFIX
                this._modalFilterClasses.pageFilter.filterBox.on(idFilterBoxChangeClassLevels, () => {
                    if (!this._compsClassLevelSelect[ix]) {
                        return;
                    }
                    const subclass = this.getSubclass_({'cls': cls, 'propIxSubclass': propIxSubclass});
                    const filteredFeatures = this._class_getFilteredFeatures(cls, subclass);
                    if (this._compsClassLevelSelect[ix]) {
                        this._compsClassLevelSelect[ix].setFeatures(filteredFeatures);
                    }
                    this._class_pRenderFeatureOptionsSelects({
                        'ix': ix,
                        'propCntAsi': propCntAsi,
                        'filteredFeatures': filteredFeatures,
                        '$stgFeatureOptions': ele_featureOptions,
                        'lockRenderFeatureOptionsSelects': lockRenderFeatureOptionsSelects
                    });
                });
            }
        }
        else {
            ele_levelSelect.hideVe();
            this._compsClassLevelSelect[ix] = null;
            ele_featureOptions.empty().hideVe();
            this._class_unregisterFeatureSourceTrackingFeatureComps(ix);
            this._state[propCntAsi] = null;
            if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.off(idFilterBoxChangeClassLevels);}
        }
    }
    //#endregion

    //#region Skill and Tool proficiencies
    /**Create an element to display skill proficiency choices that our class gives us*/
    _class_renderClass_stgSkills({ $stgSkills: parentElement, ix: ix, propIxClass: propIxClass }) {
      this._class_renderClass_stgSkillsTools({
        '$stg': parentElement,
        'ix': ix,
        'propIxClass': propIxClass,
        'propMetaHks': "_metaHksClassStgSkills",
        'propCompsClass': '_compsClassSkillProficiencies',
        'propSystem': 'skills',
        'fnGetProfs': ({ cls: cls, isPrimaryClass: isPrimaryClass }) => {
          if (!cls) { return null; }
          return isPrimaryClass ? cls.startingProficiencies?.["skills"] : cls.multiclassing?.['proficienciesGained']?.["skills"];
        },
        'headerText': "Skill Proficiencies",
        'fnGetMapped': Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect)
      });
    }
     /**Create an element to display tool proficiency choices that our class gives us*/
    _class_renderClass_stgTools({ $stgTools: parentElement, ix: ix, propIxClass: propIxClass }) {
      this._class_renderClass_stgSkillsTools({
        '$stg': parentElement,
        'ix': ix,
        'propIxClass': propIxClass,
        'propMetaHks': "_metaHksClassStgTools",
        'propCompsClass': '_compsClassToolProficiencies',
        'propSystem': "tools",
        'fnGetProfs': ({ cls: cls, isPrimaryClass: isPrimaryClass  }) => {
          if (!cls) { return null; }
          return isPrimaryClass ? Charactermancer_Class_Util.getToolProficiencyData(cls.startingProficiencies) : Charactermancer_Class_Util.getToolProficiencyData(cls.multiclassing?.['proficienciesGained']);
        },
        'headerText': "Tool Proficiencies",
        'fnGetMapped': Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect)
      });
    }

    /**Create an element to display skill or tool proficiency choices that our class gives us.
     * Use _class_renderClass_stgSkills or _class_renderClass_stgTools if you specifically know which one you want to use  */
    _class_renderClass_stgSkillsTools({
        $stg: parentElement,
        ix: ix,
        propIxClass: propIxClass,
        propMetaHks: propMetaHks,
        propCompsClass: propCompsClass,
        propSystem: propSystem,
        fnGetProfs: fnGetProfs,
        headerText: headerText,
        fnGetMapped: fnGetMapped
        }) {
        
        //TEMPFIX
        if(SETTINGS.USE_EXISTING){const existingMeta = this._class_getExistingClassMeta(ix);
        if (existingMeta) { return; }}
        
        if (this[propMetaHks][ix]) { this[propMetaHks][ix].unhook(); }

        const doRenderSkillsTools = () => {
            parentElement.empty();
            const cls = this.getClass_({ 'propIxClass': propIxClass });
            const isPrimaryClass = this._state.class_ixPrimaryClass === ix;
            this._parent.featureSourceTracker_.unregister(this[propCompsClass][ix]);
            const proficiencies = fnGetProfs({ 'cls': cls, 'isPrimaryClass': isPrimaryClass });

            if (cls && proficiencies) {
                parentElement.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">" + headerText + "</div>");
                //TEMPFIX
                const existing = SETTINGS.USE_EXISTING? { 'skillProficiencies': MiscUtil.get(this._actor, "_source", "system", propSystem) } : null;
                this[propCompsClass][ix] = new Charactermancer_OtherProficiencySelect({
                    'featureSourceTracker': this._parent.featureSourceTracker_,
                    'existing': Charactermancer_OtherProficiencySelect.getExisting(existing),
                    'existingFvtt': existing,
                    'available': fnGetMapped(proficiencies)
                });
                this[propCompsClass][ix].render(parentElement);
            }
            else { parentElement.hideVe(); this[propCompsClass][ix] = null; }
        };

        this._addHookBase("class_ixPrimaryClass", doRenderSkillsTools);
        this[propMetaHks][ix] = {
            'unhook': () => this._removeHookBase("class_ixPrimaryClass", doRenderSkillsTools)
        };

        doRenderSkillsTools();
    }

    /**Create the element displaying starting proficiencies for our class */
    _class_renderClass_stgStartingProficiencies({
        $stgStartingProficiencies: element, ix: ix, cls: cls}) {

        const existingClassMeta = SETTINGS.USE_EXISTING? this._class_getExistingClassMeta(ix) : null;
        if (existingClassMeta) {return;}
        if (this._metaHksClassStgStartingProficiencies[ix]) {
            this._metaHksClassStgStartingProficiencies[ix].unhook();
        }
        element.empty();

        //Our parent should be an ActorCharactermancer
        this._parent.featureSourceTracker_.unregister(this._compsClassStartingProficiencies[ix]);

        if (cls && (cls.startingProficiencies || cls.multiclassing?.proficienciesGained)) {
            element.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Proficiencies</div>");
            this._compsClassStartingProficiencies[ix] = Charactermancer_Class_StartingProficiencies.get({
                'featureSourceTracker': this._parent.featureSourceTracker_,
                'primaryProficiencies': cls.startingProficiencies,
                'multiclassProficiencies': cls.multiclassing?.proficienciesGained,
                'savingThrowsProficiencies': cls.proficiency,
                'existingProficienciesFvttArmor': MiscUtil.get(this._actor, "_source", "system", "traits", "armorProf"),
                'existingProficienciesFvttWeapons': MiscUtil.get(this._actor, '_source', "system", "traits", "weaponProf"),
                'existingProficienciesFvttSavingThrows': Charactermancer_Class_StartingProficiencies.getExistingProficienciesFvttSavingThrows(this._actor)
            });
            this._compsClassStartingProficiencies[ix].render(element);
        }
        else {
            element.hideVe();
            this._compsClassStartingProficiencies[ix] = null;
        }

        const onPrimaryClassChanged = () => {
            if (this._compsClassStartingProficiencies[ix]) {
            this._compsClassStartingProficiencies[ix].mode =
            this._state.class_ixPrimaryClass === ix ? Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY
            : Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS;
            }
        };

        this._addHookBase("class_ixPrimaryClass", onPrimaryClassChanged);
        this._metaHksClassStgStartingProficiencies[ix] = {
            'unhook': () => this._removeHookBase("class_ixPrimaryClass", onPrimaryClassChanged)
        };

        onPrimaryClassChanged();
    }
    _class_getExistingClassMeta(classIx) {
      if (this._existingClassMetas[classIx]) {return this._existingClassMetas[classIx];}

      const {propIxClass: propIxClass } = ActorCharactermancerBaseComponent.class_getProps(classIx);

      const cls = this.getClass_({'propIxClass': propIxClass });

      const classItems = Charactermancer_Class_Util.getExistingClassItems(this._actor, cls);
      const firstItem = classItems.length ? classItems[0] : null;
      if (!firstItem) { return null; }
      return {'item': firstItem, 'level': Number(firstItem.system.levels || 0)};
    }
    //#endregion

    //#region Text Roller Display
    async _class_renderClass_pDispClass({ ix: ix, $dispClass: parentElement, cls: cls, sc: sc }) {
        if (this._$wrpsClassTable[ix]) {this._$wrpsClassTable[ix].detach(); }
        else {this._$wrpsClassTable[ix] = $("<div class=\"ve-flex-col w-100\"></div>");}
        parentElement.empty();

        if (cls) {
            //A problem is that the class.classFeatures array doesn't contain the text content that we want to display. It only has the name
            //So what we need to do is get that text information from somewhere

            //TEMPFIX 
            const classInfo = //cls;
            {classFeatures: HelperFunctions.getClassFeaturesFromClassInData(this._data, cls)};
            /*cls._isStub ? cls : await DataLoader.pCacheAndGet("class", cls.source,
            UrlUtil.URL_TO_HASH_BUILDER["class"](cls)); */ //The hash will look something like 'barbarian_phb' (depending on class name and source)
            let entries = MiscUtil.copy(classInfo.classFeatures || []).flat();
            if(SETTINGS.FILTERS){entries = Charactermancer_Class_Util.getFilteredEntries_bySource(entries,
                this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());}
            else {
                //if we dont use the filters (the intended method), the 'entries' array is hidden deep within loadeds
                //we can still use that entries array, but for simplicities sake we can just get the raw classfeatures again
                entries = ContentGetter.getFeaturesFromClass(cls);
            }
            
            const toRender = { 'type': "section", 'entries': entries};
            this._class_renderEntriesSection(parentElement, cls.name, toRender, { '$wrpTable': this._$wrpsClassTable[ix] });
            //Render the class table
            //TEMPFIX await this._class_renderClass_pClassTable({ 'ix': ix, 'cls': cls, 'sc': sc });
        }
    }
    async _class_renderClass_pDispSubclass({
      ix: _0xd8d788,
      $dispSubclass: _0x189ba0,
      cls: _0x3f21f6,
      sc: _0x5dd639
    }) {
      _0x189ba0.empty();
      if (_0x5dd639) {
        _0x189ba0.append("<hr class=\"hr-1\">");
        const _0x19c6a9 = _0x5dd639._isStub ? _0x5dd639 : await DataLoader.pCacheAndGet("subclass", _0x5dd639.source, UrlUtil.URL_TO_HASH_BUILDER.subclass(_0x5dd639));
        let _0x4cd88b = MiscUtil.copy(_0x19c6a9.subclassFeatures).flat();
        _0x4cd88b = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x4cd88b, this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
        const _0x92cb5c = {
          'type': "section",
          'entries': _0x4cd88b
        };
        if (_0x92cb5c.entries[0x0] && _0x92cb5c.entries[0x0].name) {
          delete _0x92cb5c.entries[0x0].name;
        }
        this._class_renderEntriesSection(_0x189ba0, _0x5dd639.name, _0x92cb5c);
      }
      await this._class_renderClass_pClassTable({
        'ix': _0xd8d788,
        'cls': _0x3f21f6,
        'sc': _0x5dd639
      });
    }
    async _class_renderClass_pClassTable({
      ix: _0x29a0a3,
      cls: _0xed637d,
      sc: _0x386619
    }) {
      const _0x57a945 = _0xed637d ? _0xed637d._isStub ? _0xed637d : await DataLoader.pCacheAndGet('class', _0xed637d.source, UrlUtil.URL_TO_HASH_BUILDER["class"](_0xed637d)) : null;
      const _0x4d6b47 = _0x386619 ? _0x386619._isStub ? _0x386619 : await DataLoader.pCacheAndGet("subclass", _0x386619.source, UrlUtil.URL_TO_HASH_BUILDER.subclass(_0x386619)) : null;
      const _0x2da178 = _0x57a945?.["classFeatures"] || _0x4d6b47?.["subclassFeatures"] ? this._modalFilterClasses.pageFilter.filterBox.getValues() : null;
      if (_0x57a945?.["classFeatures"]) {
        _0x57a945.classFeatures = _0x57a945.classFeatures.map(_0x2106c1 => {
          _0x2106c1 = MiscUtil.copy(_0x2106c1);
          _0x2106c1 = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x2106c1, this._modalFilterClasses.pageFilter, _0x2da178);
          return _0x2106c1;
        });
      }
      if (_0x4d6b47?.["subclassFeatures"]) {
        _0x4d6b47.subclassFeatures = _0x4d6b47.subclassFeatures.map(_0x3cb3f1 => {
          _0x3cb3f1 = MiscUtil.copy(_0x3cb3f1);
          _0x3cb3f1 = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x3cb3f1, this._modalFilterClasses.pageFilter, _0x2da178);
          return _0x3cb3f1;
        });
      }
      const _0x5e497c = DataConverterClass.getRenderedClassTableFromDereferenced(_0x57a945, _0x4d6b47);
      this._$wrpsClassTable[_0x29a0a3].html('').fastSetHtml(_0x5e497c);
    }
    _class_renderEntriesSection(parentElement, cls, toRender, { $wrpTable = null } = {}) {
        const minimizeButton = $("<div class=\"py-1 pl-2 clickable ve-muted\">[‒]</div>").click(() => {
            minimizeButton.text(minimizeButton.text() === '[+]' ? '[‒]' : "[+]");
            if ($wrpTable) { $wrpTable.toggleVe(); }
            displayedElement.toggleVe();
        });
        const displayedElement = Renderer.hover.$getHoverContent_generic(toRender);
        $$`<div class="ve-flex-col">
                <div class="split-v-center">
                    <div class="rd__h rd__h--0"><div class="entry-title-inner">${(cls || '').qq()}</div></div>
                    ${minimizeButton}
                </div>
                ${$wrpTable}
                ${displayedElement}
        </div>`.appendTo(parentElement);
    }
    //#endregion


    /**Get the features of our current class and subclass */
    _class_getFilteredFeatures(cls, sc) {
        if (!cls) {return [];}
        cls = MiscUtil.copy(cls);
        cls.subclasses = [sc].filter(Boolean);

        //TEMPFIX
        if(!SETTINGS.FILTERS) {
            return Charactermancer_Class_Util.getAllFeatures(cls);
        }
        return Charactermancer_Util.getFilteredFeatures(Charactermancer_Class_Util.getAllFeatures(cls),
        this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
    }

    //#region Feature Options Selects
    async _class_pRenderFeatureOptionsSelects(options) {
        const { lockRenderFeatureOptionsSelects: lockRenderFeatureOptionsSelects } = options;
        try {
            await this._pLock(lockRenderFeatureOptionsSelects);
            return this._class_pRenderFeatureOptionsSelects_(options);
        }
        finally { this._unlock(lockRenderFeatureOptionsSelects); }
    }

    async _class_pRenderFeatureOptionsSelects_({
        ix: ix,
        propCntAsi: propCntAsi,
        filteredFeatures: filteredFeatures,
        $stgFeatureOptions: stgFeatureOptions
        }) {
        const selElement = this._compsClassFeatureOptionsSelect[ix] || [];
        selElement.forEach(e => this._parent.featureSourceTracker_.unregister(e));
        stgFeatureOptions.empty();
        const existingFeatureChecker = this._existingClassMetas[ix] ? new Charactermancer_Class_Util.ExistingFeatureChecker(this._actor) : null;
        const importableFeatures = Charactermancer_Util.getImportableFeatures(filteredFeatures);
        const features = MiscUtil.copy(importableFeatures);
        if(SETTINGS.FILTERS){ //TEMPFIX
            Charactermancer_Util.doApplyFilterToFeatureEntries_bySource(features,
                this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
        }
        //by this point, 'features' should be an array of classFeatures with property 'loadeds'
        const groupedByOptionsSet = Charactermancer_Util.getFeaturesGroupedByOptionsSet(features);
        //groupedByOptionsSet should be an array of objects like this: {optionsSets: [...], topLevelFeature: {...}}
        const {lvlMin: lvlMin, lvlMax: lvlMax } = await this._class_pGetMinMaxLevel(ix);
        this._class_unregisterFeatureSourceTrackingFeatureComps(ix);

        let asiCount = 0;
        for (const grpA of groupedByOptionsSet) {
            const { topLevelFeature: topLevelFeature, optionsSets: optionsSets} = grpA;
            //Only render features of the right level
            if (topLevelFeature.level < lvlMin || topLevelFeature.level > lvlMax) { continue; }
            const featureName = topLevelFeature.name.toLowerCase();
            if (featureName === "ability score improvement") { asiCount++; continue; }
            for (const set of optionsSets) {
                const component = new Charactermancer_FeatureOptionsSelect({
                    'featureSourceTracker': this._parent.featureSourceTracker_,
                    //TEMPFIX //'existingFeatureChecker': existingFeatureChecker,
                    //TEMPFIX //'actor': this._actor,
                    'optionsSet': set,
                    'level': topLevelFeature.level,
                    //TEMPFIX //'modalFilterSpells': this._parent.compSpell.modalFilterSpells
                });
                this._compsClassFeatureOptionsSelect[ix].push(component);
                component.findAndCopyStateFrom(selElement);
            }
        }

        this._state[propCntAsi] = asiCount;
        await this._class_pRenderFeatureComps(ix, {'$stgFeatureOptions': stgFeatureOptions});
    }
    async _class_pRenderFeatureComps(ix, { $stgFeatureOptions: stgFeatureOptions }) {
        for (const component of this._compsClassFeatureOptionsSelect[ix]) {
            //component._optionsSet[0].entity.entryData exists
            if ((await component.pIsNoChoice()) && !(await component.pIsAvailable())) {continue;}
            
            if (!(await component.pIsNoChoice()) || (await component.pIsForceDisplay())) {
                stgFeatureOptions.showVe().append('' + (component.modalTitle ?
                     "<hr class=\"hr-2\"><div class=\"mb-2 bold w-100\">" + component.modalTitle + "</div>" : ''));
            }
            component.render(stgFeatureOptions);
        }
      }
    //#endregion

    ["_class_unregisterFeatureSourceTrackingFeatureComps"](_0x3f9ba9) {
      (this._compsClassFeatureOptionsSelect[_0x3f9ba9] || []).forEach(_0x2edadc => _0x2edadc.unregisterFeatureSourceTracking());
      this._compsClassFeatureOptionsSelect[_0x3f9ba9] = [];
    }
    async ["_class_pGetMinMaxLevel"](_0x356dbb) {
      let _0x3d959d = 0x0;
      let _0x1005e8 = 0x0;
      if (this._compsClassLevelSelect[_0x356dbb]) {
        const _0xbda027 = await this._compsClassLevelSelect[_0x356dbb].pGetFormData().data;
        _0x3d959d = Math.min(..._0xbda027) + 0x1;
        _0x1005e8 = Math.max(..._0xbda027) + 0x1;
      }
      return {
        'lvlMin': _0x3d959d,
        'lvlMax': _0x1005e8
      };
    }
    
    
    ['class_getPrimaryClass']() {
      if (!~this._state.class_ixPrimaryClass) {
        return null;
      }
      const {
        propIxClass: _0x42dfba
      } = ActorCharactermancerBaseComponent.class_getProps(this._state.class_ixPrimaryClass);
      return this._data["class"][this._state[_0x42dfba]];
    }
    ["class_getTotalLevels"]() {
      return this._compsClassLevelSelect.filter(Boolean).map(_0x169930 => _0x169930.getTargetLevel() || _0x169930.getCurLevel()).reduce((_0x130249, _0x125134) => _0x130249 + _0x125134, 0x0);
    }
    ["class_getMinMaxSpellLevel"]() {
      const _0x35ebcb = [];
      const _0x5ba174 = [];
      let _0x8a1dd5 = false;
      for (let _0xa4aa35 = 0x0; _0xa4aa35 < this._state.class_ixMax + 0x1; ++_0xa4aa35) {
        const {
          propIxClass: _0x27f359,
          propIxSubclass: _0x215bda,
          propCurLevel: _0x496498,
          propTargetLevel: _0x4c7a29
        } = ActorCharactermancerBaseComponent.class_getProps(_0xa4aa35);
        const _0x2bea38 = this.getClass_({
          'propIxClass': _0x27f359
        });
        if (!_0x2bea38) {
          continue;
        }
        const _0x6aec7a = this.getSubclass_({
          'cls': _0x2bea38,
          'propIxSubclass': _0x215bda
        });
        const _0x19e990 = this._state[_0x496498];
        const _0x275d07 = this._state[_0x4c7a29];
        const _0x547cd0 = DataConverter.getMaxCasterProgression(_0x2bea38.casterProgression, _0x6aec7a?.["casterProgression"]);
        const _0x52dd93 = Charactermancer_Spell_Util.getCasterProgressionMeta({
          'casterProgression': _0x547cd0,
          'curLevel': _0x19e990,
          'targetLevel': _0x275d07,
          'isBreakpointsOnly': true
        })?.["spellLevelLow"];
        if (_0x52dd93 != null) {
          _0x35ebcb.push(_0x52dd93);
        }
        const _0x38d005 = Charactermancer_Spell_Util.getCasterProgressionMeta({
          'casterProgression': _0x547cd0,
          'curLevel': _0x19e990,
          'targetLevel': _0x275d07,
          'isBreakpointsOnly': true
        })?.["spellLevelHigh"];
        if (_0x38d005 != null) {
          _0x5ba174.push(_0x38d005);
        }
        _0x8a1dd5 = _0x8a1dd5 || Charactermancer_Spell_Util.getMaxLearnedCantrips({
          'cls': _0x2bea38,
          'sc': _0x6aec7a,
          'targetLevel': _0x275d07
        }) != null;
      }
      return {
        'min': _0x35ebcb.length ? Math.min(..._0x35ebcb) : null,
        'max': _0x5ba174.length ? Math.max(..._0x5ba174) : null,
        'isAnyCantrips': _0x8a1dd5
      };
    }
    /**Defines the starting default values of our _state proxy  */
    _getDefaultState() {
      return {
        'class_ixPrimaryClass': 0,
        'class_ixMax': 0,
        'class_totalLevels': 0,
        'class_pulseChange': false
      };
    }
}
class Charactermancer_Class_HpIncreaseModeSelect extends BaseComponent {
    static async pGetUserInput() {
        if (this.isNoChoice()) {
            const comp = new this();
            return comp.pGetFormData();
        }

        return UtilApplications.pGetImportCompApplicationFormData({
            comp: new this(),
            width: 480,
            height: 150,
        });
    }

    static isHpAvailable(cls) {
        return cls.hd && cls.hd.number && !isNaN(cls.hd.number) && cls.hd.faces && !isNaN(cls.hd.faces);
    }

    static isNoChoice() {
        if (game.user.isGM)
            return false;

        if (Config.get("importClass", "hpIncreaseMode") === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM && Config.get("importClass", "hpIncreaseModeCustomRollFormula") == null)
            return false;

        return Config.get("importClass", "hpIncreaseMode") != null;
    }

    pGetFormData() {
        return {
            isFormComplete: true,
            data: {
                mode: this._state.mode,
                customFormula: this._state.customFormula,
            },
        };
    }

    get modalTitle() {
        return `Select Hit Points Increase Mode`;
    }

    render($wrp) {
        const $sel = ComponentUiUtil.$getSelEnum(this, "mode", {
            values: [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE, ],
            fnDisplay: mode=>ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[mode],
        }, );

        /* if (!game.user.isGM && Config.get("importClass", "hpIncreaseMode") != null)
            $sel.disable(); */

        const $iptCustom = ComponentUiUtil.$getIptStr(this, "customFormula").addClass("code");

        /* if (!game.user.isGM && Config.get("importClass", "hpIncreaseModeCustomRollFormula") != null)
            $iptCustom.disable(); */

        const $stgCustom = $$`<div class="mt-2 ve-flex-v-center">
			<div class="inline-block bold mr-1 no-wrap">Custom Formula:</div>
			${$iptCustom}
		</div>`;
        const hkMode = ()=>{
            $stgCustom.toggleVe(this._state.mode === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM);
        }
        ;
        this._addHookBase("mode", hkMode);
        hkMode();

        $$`<div class="ve-flex-col min-h-0">
			${$sel}
			${$stgCustom}
		</div>`.appendTo($wrp);
    }

    _getDefaultState() {
        return {
            mode: Config.get("importClass", "hpIncreaseMode") ?? ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE,
            customFormula: Config.get("importClass", "hpIncreaseModeCustomRollFormula") ?? "(2 * @hd.number)d(@hd.faces / 2)",
        };
    }
}
class Charactermancer_Class_HpInfo extends BaseComponent {
    constructor({className, hitDice}) {
        super();
        this._className = className;
        this._hitDice = hitDice;
    }

    render($wrp) {
        const hdEntry = Renderer.class.getHitDiceEntry(this._hitDice);

        const we = $$`<div class="ve-flex-col min-h-0 ve-small">
			<div class="block"><div class="inline-block bold mr-1">Hit Dice:</div>${SETTINGS.DO_RENDER_DICE? Vetools.withUnpatchedDiceRendering(()=>
                Renderer.getEntryDice(hdEntry, "Hit die")) : hdEntry.toRoll}</div>
			<div class="block"><div class="inline-block bold mr-1">Hit Points:</div>${Renderer.class.getHitPointsAtFirstLevel(this._hitDice)}</div>
			<div class="block"><div class="inline-block bold mr-1">Hit Points at Higher Levels:</div>
            ${Vetools.withUnpatchedDiceRendering(()=>Renderer.class.getHitPointsAtHigherLevels(this._className, this._hitDice, hdEntry))}</div>
		</div>`;
        we.appendTo($wrp);
    }
}
class Charactermancer_AdditionalSpellsUtil {
    static getFlatData(additionalSpells) {
        additionalSpells = MiscUtil.copy(additionalSpells);

        return additionalSpells.map(additionalSpellBlock=>{
            const outMeta = {};
            const outSpells = {};

            const keyPath = [];

            Object.entries(additionalSpellBlock).forEach(([additionType,additionMeta])=>{
                keyPath.push(additionType);

                switch (additionType) {
                case "name":
                case "ability":
                    outMeta[additionType] = additionMeta;
                    break;

                case "resourceName":
                    break;

                case "innate":
                case "known":
                case "prepared":
                case "expanded":
                    {
                        this._getFlatData_doProcessAdditionMeta({
                            additionType,
                            additionMeta,
                            outSpells,
                            keyPath,
                            resourceName: additionalSpellBlock.resourceName
                        });
                        break;
                    }

                default:
                    throw new Error(`Unhandled spell addition type "${additionType}"`);
                }

                keyPath.pop();
            }
            );

            return {
                meta: outMeta,
                spells: outSpells
            };
        }
        );
    }

    static _getFlatData_doProcessAdditionMeta(opts) {
        const {additionMeta, keyPath} = opts;

        Object.entries(additionMeta).forEach(([levelOrCasterLevel,levelMeta])=>{
            keyPath.push(levelOrCasterLevel);

            if (levelMeta instanceof Array) {
                levelMeta.forEach((spellItem,ix)=>this._getFlatData_doProcessSpellItem({
                    ...opts,
                    levelOrCasterLevel,
                    spellItem,
                    ix
                }));
            } else {
                Object.entries(levelMeta).forEach(([rechargeType,levelMetaInner])=>{
                    this._getFlatData_doProcessSpellRechargeBlock({
                        ...opts,
                        levelOrCasterLevel,
                        rechargeType,
                        levelMetaInner
                    });
                }
                );
            }

            keyPath.pop();
        }
        );
    }

    static _getFlatData_doProcessSpellItem(opts) {
        const {additionType, additionMeta, outSpells, keyPath, spellItem, ix, rechargeType, uses, usesPer, levelOrCasterLevel, consumeType, consumeAmount, consumeTarget, vetConsumes} = opts;

        keyPath.push(ix);

        const outSpell = {
            isExpanded: additionType === "expanded",
            isAlwaysPrepared: additionType === "prepared",
            isAlwaysKnown: additionType === "known",
            isPrepared: additionType === "prepared" || additionType === "innate" || additionType === "known",
            preparationMode: (additionType === "prepared" || additionType === "known") ? "always" : "innate",
            consumeType,
            consumeAmount,
            consumeTarget,
            vetConsumes,
        };

        if (levelOrCasterLevel !== "_") {
            const mCasterLevel = /^s(\d+)$/.exec(levelOrCasterLevel);
            if (mCasterLevel)
                outSpell.requiredCasterLevel = Number(mCasterLevel[1]);
            else if (!isNaN(levelOrCasterLevel))
                outSpell.requiredLevel = Number(levelOrCasterLevel);
        }

        if (rechargeType) {
            switch (rechargeType) {
            case "rest":
            case "daily":
                break;
            case "will":
            case "ritual":
            case "resource":
                {
                    outSpell.preparationMode = "atwill";
                    outSpell.isPrepared = rechargeType !== "ritual";
                    break;
                }

            case "_":
                break;

            default:
                throw new Error(`Unhandled recharge type "${rechargeType}"`);
            }
        }

        if (uses)
            outSpell.uses = uses;
        if (usesPer)
            outSpell.usesPer = usesPer;

        if (typeof spellItem === "string") {
            const key = keyPath.join("__");

            outSpells[key] = new Charactermancer_AdditionalSpellsUtil.FlatSpell({
                type: "spell",

                key,
                ...outSpell,
                uid: spellItem,
            });
        } else {
            if (spellItem.all != null) {
                const key = keyPath.join("__");

                outSpells[key] = new Charactermancer_AdditionalSpellsUtil.FlatSpell({
                    type: "all",

                    key,
                    ...outSpell,
                    filterExpression: spellItem.all,
                });
            } else if (spellItem.choose != null) {
                if (typeof spellItem.choose === "string") {
                    const count = spellItem.count || 1;

                    for (let i = 0; i < count; ++i) {
                        keyPath.push(i);

                        const key = keyPath.join("__");

                        outSpells[key] = new Charactermancer_AdditionalSpellsUtil.FlatSpell({
                            type: "choose",

                            key,
                            ...outSpell,
                            filterExpression: spellItem.choose,
                        });

                        keyPath.pop();
                    }
                } else if (spellItem.choose.from) {
                    const count = spellItem.choose.count || 1;

                    const groupId = CryptUtil.uid();
                    [...spellItem.choose.from].sort((a,b)=>SortUtil.ascSortLower(a, b)).forEach((uid,i)=>{
                        keyPath.push(i);

                        const key = keyPath.join("__");

                        outSpells[key] = new Charactermancer_AdditionalSpellsUtil.FlatSpell({
                            type: "chooseFrom",

                            key,
                            ...outSpell,
                            uid: uid,
                            chooseFromGroup: groupId,
                            chooseFromCount: count,
                        });

                        keyPath.pop();
                    }
                    );
                } else {
                    throw new Error(`Unhandled additional spell format: "${JSON.stringify(spellItem)}"`);
                }
            } else
                throw new Error(`Unhandled additional spell format: "${JSON.stringify(spellItem)}"`);
        }

        keyPath.pop();
    }

    static _getFlatData_doProcessSpellRechargeBlock(opts) {
        const {additionType, additionMeta, outSpells, keyPath, resourceName, levelOrCasterLevel, rechargeType, levelMetaInner} = opts;

        keyPath.push(rechargeType);

        switch (rechargeType) {
        case "rest":
        case "daily":
            {
                const usesPer = rechargeType === "rest" ? "sr" : "lr";

                Object.entries(levelMetaInner).forEach(([numTimesCast,spellList])=>{
                    keyPath.push(numTimesCast);

                    numTimesCast = numTimesCast.replace(/^(\d+)e$/, "$1");
                    const uses = Number(numTimesCast);

                    spellList.forEach((spellItem,ix)=>this._getFlatData_doProcessSpellItem({
                        ...opts,
                        spellItem,
                        ix,
                        uses,
                        usesPer
                    }));

                    keyPath.pop();
                }
                );

                break;
            }

        case "resource":
            {
                Object.entries(levelMetaInner).forEach(([consumeAmount,spellList])=>{
                    keyPath.push(consumeAmount);

                    spellList.forEach((spellItem,ix)=>this._getFlatData_doProcessSpellItem({
                        ...opts,
                        spellItem,
                        ix,
                        vetConsumes: {
                            name: resourceName,
                            amount: Number(consumeAmount)
                        }
                    }));

                    keyPath.pop();
                }
                );

                break;
            }

        case "will":
        case "ritual":
        case "_":
            {
                levelMetaInner.forEach((spellItem,ix)=>this._getFlatData_doProcessSpellItem({
                    ...opts,
                    spellItem,
                    ix
                }));
                break;
            }

        default:
            throw new Error(`Unhandled spell recharge type "${rechargeType}"`);
        }

        keyPath.pop();
    }
}
Charactermancer_AdditionalSpellsUtil.FlatSpell = class {
    #opts = null;
    constructor(opts) {
        this.#opts = opts;

        this.type = opts.type;
        this.key = opts.key;
        this.isExpanded = opts.isExpanded;
        this.isPrepared = opts.isPrepared;
        this.isAlwaysKnown = opts.isAlwaysKnown;
        this.isAlwaysPrepared = opts.isAlwaysPrepared;
        this.preparationMode = opts.preparationMode;
        this.requiredCasterLevel = opts.requiredCasterLevel;
        this.requiredLevel = opts.requiredLevel;

        this.uses = opts.uses;
        this.usesPer = opts.usesPer;

        this.consumeType = opts.consumeType;
        this.consumeAmount = opts.consumeAmount;
        this.consumeTarget = opts.consumeTarget;

        this.vetConsumes = opts.vetConsumes;

        this.isCantrip = false;

        this.uid = null;
        this.castAtLevel = null;
        if (opts.uid) {
            const {uid, isCantrip, castAtLevel} = Charactermancer_AdditionalSpellsUtil.FlatSpell._getExpandedUid(opts.uid);
            this.uid = uid;
            this.isCantrip = isCantrip;
            this.castAtLevel = castAtLevel;
        }

        this.filterExpression = opts.filterExpression;
        if (opts.filterExpression && opts.filterExpression.split("|").filter(Boolean).some(it=>/^level=0$/i.test(it.trim()))) {
            this.isCantrip = true;
        }

        this.chooseFromGroup = opts.chooseFromGroup;
        this.chooseFromCount = opts.chooseFromCount;

        if (this.isCantrip && !this.isExpanded)
            this.isAlwaysKnown = true;
    }

    static _getExpandedUid(uidRaw) {
        const [uidPart,castAtLevelPart] = uidRaw.split("#").map(it=>it.trim()).filter(Boolean);

        let[name,source] = Renderer.splitTagByPipe(uidPart.toLowerCase());
        source = source || Parser.SRC_PHB.toLowerCase();
        const uid = `${name}|${source}`;

        const isCantrip = castAtLevelPart && castAtLevelPart.toLowerCase() === "c";
        const castAtLevel = isCantrip ? null : (castAtLevelPart && !isNaN(castAtLevelPart)) ? Number(castAtLevelPart) : null;

        return {
            uid,
            isCantrip,
            castAtLevel
        };
    }

    getCopy(optsNxt=null) {
        return new this.constructor({
            ...this.#opts,
            ...optsNxt || {},
        });
    }

    toObject() {
        return MiscUtil.copy(this);
    }
};

class Charactermancer_AdditionalSpellsSelect extends BaseComponent {
    static async pGetUserInput(opts) {
        opts = opts || {};
        const {additionalSpells} = opts;

        if (!additionalSpells || !additionalSpells.length)
            return {
                isFormComplete: true,
                data: []
            };

        const comp = this.getComp(opts);

        if (comp.isNoChoice({
            curLevel: opts.curLevel,
            targetLevel: opts.targetLevel,
            isStandalone: opts.isStandalone
        }))
            return comp.pGetFormData();

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            width: 640,
            height: 220,
        });
    }

    static _MODAL_FILTER_SPELLS_DEFAULT = null;

    static async pGetInitModalFilterSpells() {
        if (!this._MODAL_FILTER_SPELLS_DEFAULT) {
            this._MODAL_FILTER_SPELLS_DEFAULT = new ModalFilterSpellsFvtt({
                namespace: "Charactermancer_AdditionalSpellsSelect.spells",
                isRadio: true
            });
            await this._MODAL_FILTER_SPELLS_DEFAULT.pPreloadHidden();
        }
        return this._MODAL_FILTER_SPELLS_DEFAULT;
    }

    static getComp(opts) {
        opts = opts || {};

        const comp = new this({
            ...opts
        });
        comp.curLevel = opts.curLevel;
        comp.targetLevel = opts.targetLevel;
        comp.spellLevelLow = opts.spellLevelLow;
        comp.spellLevelHigh = opts.spellLevelHigh;
        comp.isAnyCantrips = !!opts.isAnyCantrips;

        return comp;
    }

    static async pApplyFormDataToActor(actor, formData, opts) {
        opts = opts || {};

        if (!formData || !formData?.data?.length)
            return [];

        const ability = ((opts.abilityAbv === "inherit" ? opts.parentAbilityAbv : opts.abilityAbv) || (formData.abilityAbv === "inherit" ? opts.parentAbilityAbv : formData.abilityAbv)) ?? undefined;

        const {ImportListSpell} = await Promise.resolve().then(function() {
            return ImportListSpell$1;
        });
        const importListSpell = new ImportListSpell({
            actor
        });

        const out = [];

        for (const spellMeta of formData.data) {
            if (spellMeta.isExpanded)
                continue;

            let[name,source] = spellMeta.uid.split("|");
            if (!source)
                source = Parser.SRC_PHB;
            const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS]({
                name,
                source
            });

            const spell = await DataLoader.pCacheAndGet(UrlUtil.PG_SPELLS, source, hash);
            if (!spell) {
                const message = `Could not find spell "${hash}" when applying additional spells!`;
                ui.notifications.warn(message);
                console.warn(...LGT, message);
                continue;
            }

            const importSummary = await importListSpell.pImportEntry(spell, {
                taskRunner: opts.taskRunner,
                opts_pGetSpellItem: {
                    ability,
                    usesMax: spellMeta.uses,
                    usesValue: spellMeta.uses,
                    usesPer: spellMeta.usesPer,
                    consumeType: spellMeta.consumeType,
                    consumeAmount: spellMeta.consumeAmount,
                    consumeTarget: spellMeta.consumeTarget,
                    vetConsumes: spellMeta.vetConsumes,
                    isPrepared: spellMeta.isPrepared,
                    preparationMode: spellMeta.preparationMode,
                    castAtLevel: spellMeta.castAtLevel,

                    isIgnoreExisting: true,
                },
            }, );
            out.push(importSummary);
        }

        return out;
    }

    static isNoChoice(additionalSpells, {additionalSpellsFlat=null, curLevel=null, targetLevel=null, isStandalone=false}={}) {
        if (additionalSpells.length !== 1)
            return false;
        additionalSpellsFlat = additionalSpellsFlat || Charactermancer_AdditionalSpellsUtil.getFlatData(additionalSpells);

        const minLevel = curLevel ?? Number.MIN_SAFE_INTEGER;
        const maxLevel = targetLevel ?? Number.MAX_SAFE_INTEGER;

        const spellsInRange = additionalSpellsFlat.some(it=>Object.values(it.spells).some(it=>(!isStandalone || !it.isExpanded) && (it.requiredLevel == null || (it.requiredLevel >= minLevel && it.requiredLevel <= maxLevel))), );

        if (!spellsInRange)
            return true;

        return !additionalSpellsFlat.some(it=>it.meta.ability?.choose || Object.values(it.spells).some(it=>(it.type !== "all" && it.filterExpression != null) || it.chooseFromGroup != null));
    }

    constructor(opts) {
        opts = opts || {};
        super();

        this._additionalSpells = opts.additionalSpells;
        this._sourceHintText = opts.sourceHintText;
        this._modalFilterSpells = opts.modalFilterSpells;

        this._additionalSpellsFlat = Charactermancer_AdditionalSpellsUtil.getFlatData(opts.additionalSpells);
    }

    get modalTitle() {
        return `Choose Additional Spell Set${this._sourceHintText ? ` (${this._sourceHintText})` : ""}`;
    }

    set curLevel(val) {
        this._state.curLevel = val;
    }
    set targetLevel(val) {
        this._state.targetLevel = val;
    }
    set spellLevelLow(val) {
        this._state.spellLevelLow = val;
    }
    set spellLevelHigh(val) {
        this._state.spellLevelHigh = val;
    }
    set isAnyCantrips(val) {
        this._state.isAnyCantrips = !!val;
    }

    addHookAlwaysPreparedSpells(hk) {
        this._addHookBase("spellsAlwaysPrepared", hk);
    }
    addHookExpandedSpells(hk) {
        this._addHookBase("spellsExpanded", hk);
    }
    addHookAlwaysKnownSpells(hk) {
        this._addHookBase("spellsAlwaysKnown", hk);
    }

    get spellsAlwaysPrepared() {
        return this._state.spellsAlwaysPrepared;
    }
    get spellsExpanded() {
        return this._state.spellsExpanded;
    }
    get spellsAlwaysKnown() {
        return this._state.spellsAlwaysKnown;
    }

    _render_addLastAlwaysPreparedSpellsHook() {
        return this._render_addLastBoolSpellsHook({
            propState: "spellsAlwaysPrepared",
            propIsBool: "isAlwaysPrepared"
        });
    }
    _render_addLastExpandedSpellsHook() {
        return this._render_addLastBoolSpellsHook({
            propState: "spellsExpanded",
            propIsBool: "isExpanded"
        });
    }
    _render_addLastAlwaysKnownSpellsHook() {
        return this._render_addLastBoolSpellsHook({
            propState: "spellsAlwaysKnown",
            propIsBool: "isAlwaysKnown"
        });
    }

    _render_addLastBoolSpellsHook({propState, propIsBool}) {
        const hk = ()=>{
            const formData = this.getFormData();
            const nxt = formData.data.filter(it=>it[propIsBool]).map(it=>it.uid.toLowerCase());

            const setCurr = new Set(this._state[propState]);
            const setNxt = new Set(nxt);
            if (!CollectionUtil.setEq(setCurr, setNxt))
                this._state[propState] = nxt;
        }
        ;
        this._addHookBase("ixSet", hk);
        this._addHookBase("curLevel", hk);
        this._addHookBase("targetLevel", hk);
        this._addHookBase("spellLevelLow", hk);
        this._addHookBase("spellLevelHigh", hk);
        this._addHookBase("isAnyCantrips", hk);
        this._addHookBase("pulseChoose", hk);
        hk();
    }

    render($wrp) {
        this._render_addLastAlwaysPreparedSpellsHook();
        this._render_addLastExpandedSpellsHook();
        this._render_addLastAlwaysKnownSpellsHook();

        const $wrpOptionsButtons = $(`<div class="ve-flex-v-center ve-flex-wrap w-100 btn-group ${this._additionalSpellsFlat.length > 1 ? "mb-1" : ""}"></div>`);
        const $wrpOptions = $(`<div class="ve-flex-col w-100"></div>`);

        for (let i = 0; i < this._additionalSpellsFlat.length; ++i)
            this._render_renderOptions($wrpOptionsButtons, $wrpOptions, i);

        $$($wrp)`
			${$wrpOptionsButtons}
			${$wrpOptions}
		`;
    }

    _render_renderOptions($wrpOptionsButtons, $wrpOptions, ix) {
        const additionalSpellsFlatBlock = this._additionalSpellsFlat[ix];

        const $btnSelect = this._additionalSpellsFlat.length === 1 ? null : $(`<button class="btn btn-xs ve-flex-1" title="Select Spell Set">${additionalSpellsFlatBlock.meta.name ?? `Spell Set ${ix + 1}`}</button>`).click(()=>this._state.ixSet = ix);

        const isInnatePreparedList = this._isAnyInnatePrepared(ix);
        const isExpandedList = this._isAnyExpanded(ix);

        const sortedSpells = Object.values(additionalSpellsFlatBlock.spells).sort((a,b)=>SortUtil.ascSort(a.requiredLevel || 0, b.requiredLevel || 0) || SortUtil.ascSort(a.requiredCasterLevel || 0, b.requiredCasterLevel || 0));

        const $wrpInnatePreparedHeaders = isInnatePreparedList ? $(`<div class="ve-flex-v-center py-1">
			<div class="col-3 ve-text-center">Level</div>
			<div class="col-9">Spells</div>
		</div>`) : null;

        const $wrpExpandedHeaders = isExpandedList ? $(`<div class="ve-flex-v-center py-1">
			<div class="col-3 ve-text-center">Spell Level</div>
			<div class="col-9">Spells</div>
		</div>`) : null;

        const $rowsInnatePrepared = isInnatePreparedList ? this._render_$getRows(ix, sortedSpells, {
            isExpandedMatch: false
        }) : null;
        const $rowsExpanded = isExpandedList ? this._render_$getRows(ix, sortedSpells, {
            isExpandedMatch: true
        }) : null;

        const $wrpNoneAvailableInnatePrepared = isInnatePreparedList ? $(`<div class="ve-small ve-flex-v-center my-1 w-100 italic ve-muted">No spells at this level</div>`) : null;
        const $wrpNoneAvailableExpanded = isExpandedList ? $(`<div class="ve-small ve-flex-v-center my-1 w-100 italic ve-muted">No spells at this level</div>`) : null;

        const hkSpellsAvailable = ()=>{
            const isInnatePreparedAvailable = !!this._getFlatInnatePreparedSpellsInRange(ix).length;
            if ($wrpInnatePreparedHeaders)
                $wrpInnatePreparedHeaders.toggleVe(isInnatePreparedAvailable);
            if ($wrpNoneAvailableInnatePrepared)
                $wrpNoneAvailableInnatePrepared.toggleVe(!isInnatePreparedAvailable);

            const isExpandedAvailable = !!this._getFlatExpandedSpellsInRange(ix).length;
            if ($wrpExpandedHeaders)
                $wrpExpandedHeaders.toggleVe(isExpandedAvailable);
            if ($wrpNoneAvailableExpanded)
                $wrpNoneAvailableExpanded.toggleVe(!isExpandedAvailable);
        }
        ;
        this._addHookBase("spellLevelLow", hkSpellsAvailable);
        this._addHookBase("spellLevelHigh", hkSpellsAvailable);
        this._addHookBase("isAnyCantrips", hkSpellsAvailable);
        this._addHookBase("curLevel", hkSpellsAvailable);
        this._addHookBase("targetLevel", hkSpellsAvailable);
        this._addHookBase("ixSet", hkSpellsAvailable);
        hkSpellsAvailable();

        const $stgInnatePrepared = isInnatePreparedList ? $$`<div class="ve-flex-col">
			<div class="bold my-0">Innate/Prepared/Known Spells</div>
			${$wrpInnatePreparedHeaders}
			${$rowsInnatePrepared}
			${$wrpNoneAvailableInnatePrepared}
		</div>` : null;

        const $stgExpanded = isExpandedList ? $$`<div class="ve-flex-col">
			<div class="bold my-0">Expanded Spell List</div>
			${$wrpExpandedHeaders}
			${$rowsExpanded}
			${$wrpNoneAvailableExpanded}
		</div>` : null;

        const isChooseAbility = this._isChooseAbility(ix);

        const $wrpChooseAbility = isChooseAbility ? this._render_$getSelChooseAbility(ix) : null;

        const $stgAbility = isChooseAbility ? $$`<div class="split-v-center">
			<div class="bold my-0 no-shrink mr-2">Ability Score</div>
			${$wrpChooseAbility}
		</div>` : null;

        if ($btnSelect)
            $wrpOptionsButtons.append($btnSelect);

        const $stg = $$`<div class="ve-flex-col">
			${$stgInnatePrepared}
			${$stgExpanded}
			${$stgAbility}
		</div>`.appendTo($wrpOptions);

        if (this._additionalSpellsFlat.length !== 1) {
            const hkIsActive = ()=>{
                $btnSelect.toggleClass("active", this._state.ixSet === ix);
                $stg.toggleVe(this._state.ixSet === ix);
            }
            ;
            this._addHookBase("ixSet", hkIsActive);
            hkIsActive();

            const hkResetActive = (prop,value,prevValue)=>{
                const prevBlock = this._additionalSpellsFlat[prevValue];
                const nxtState = Object.values(prevBlock.spells).mergeMap(it=>({
                    [it.key]: null
                }));
                this._proxyAssignSimple("state", nxtState);
            }
            ;
            this._addHookBase("ixSet", hkResetActive);
        }
    }

    _getProps_chooseFrom({groupUid}) {
        return {
            propBase: `chooseFrom_${groupUid}`,
        };
    }

    _render_$getRows(ix, spells, {isExpandedMatch}) {
        if (!spells.length)
            return null;

        const byLevel = {};
        spells.forEach(flat=>{
            if (flat.isExpanded !== isExpandedMatch)
                return;

            const level = flat.requiredCasterLevel || flat.requiredLevel;
            (byLevel[level] = byLevel[level] || []).push(flat);
        }
        );

        const getFlatVars = flat=>({
            requiredLevel: flat.requiredLevel,
            requiredCasterLevel: flat.requiredCasterLevel,
            isRequiredCasterLevel: flat.requiredCasterLevel != null,
            isRequiredLevel: flat.requiredLevel != null,
            isExpanded: flat.isExpanded,
        });

        return Object.entries(byLevel).sort(([kA],[kB])=>SortUtil.ascSort(Number(kA), Number(kB))).map(([,flats])=>{
            const {requiredLevel, requiredCasterLevel, isRequiredCasterLevel, isRequiredLevel, isExpanded: isAnyExpanded, } = getFlatVars(flats[0]);

            const metasRenderedFlats = [];

            const chooseFromGroups = {};
            flats = flats.filter(flat=>{
                if (!flat.chooseFromGroup)
                    return true;

                chooseFromGroups[flat.chooseFromGroup] = chooseFromGroups[flat.chooseFromGroup] || {
                    from: [],
                    count: flat.chooseFromCount ?? 1,
                    ...getFlatVars(flat),
                };
                chooseFromGroups[flat.chooseFromGroup].from.push(flat);

                return false;
            }
            );

            const [flatsBasic,flatsFilter] = flats.segregate(it=>it.filterExpression == null);
            flatsBasic.sort((a,b)=>SortUtil.ascSortLower(a.uid, b.uid));
            flatsFilter.sort((a,b)=>SortUtil.ascSortLower(a.filterExpression, b.filterExpression));

            const $colSpells = $$`<div class="col-9 ve-flex-v-center ve-flex-wrap"></div>`;

            flatsBasic.forEach(flat=>{
                const $pt = $(`<div class="ve-flex-v-center"></div>`).fastSetHtml(Renderer.get().render(`{@spell ${flat.uid.toSpellCase()}}`)).appendTo($colSpells);
                const $sep = $(`<div class="mr-1">,</div>`).appendTo($colSpells);

                metasRenderedFlats.push({
                    flat,
                    $pt,
                    $sep,
                    ...getFlatVars(flat),
                });
            }
            );

            const [flatsFilterChoose,flatsFilterAll] = flatsFilter.segregate(it=>it.type !== "all");

            flatsFilterChoose.forEach(flat=>{
                const $dispSpell = $(`<div class="ve-flex-v-center"></div>`);
                const hkChosenSpell = ()=>{
                    $dispSpell.html(this._state[flat.key] != null && this._state.ixSet === ix ? `<div>${Renderer.get().render(`{@spell ${this._state[flat.key].toLowerCase()}}`)}</div>` : `<div class="italic ve-muted">(select a spell)</div>`, );
                }
                ;
                this._addHookBase(flat.key, hkChosenSpell);
                if (this._additionalSpellsFlat.length !== 1) {
                    this._addHookBase("ixSet", hkChosenSpell);
                }
                hkChosenSpell();

                const $btnFilter = $(`<button class="btn btn-default btn-xxs mx-1" title="Choose a Spell"><span class="fas fa-fw fa-search"></span></button>`).click(async()=>{
                    const selecteds = await this._modalFilterSpells.pGetUserSelection({
                        filterExpression: flat.filterExpression
                    });
                    if (selecteds == null || !selecteds.length)
                        return;

                    const selected = selecteds[0];

                    this._state[flat.key] = DataUtil.proxy.getUid("spell", {
                        name: selected.name,
                        source: selected.values.sourceJson
                    });
                    this._state.pulseChoose = !this._state.pulseChoose;
                }
                );

                if (this._additionalSpellsFlat.length !== 1) {
                    const hkDisableBtnFilter = ()=>$btnFilter.prop("disabled", this._state.ixSet !== ix);
                    this._addHookBase("ixSet", hkDisableBtnFilter);
                    hkDisableBtnFilter();
                }

                const $pt = $$`<div class="ve-flex-v-center">${$btnFilter}${$dispSpell}</div>`.appendTo($colSpells);
                const $sep = $(`<div class="mr-1">,</div>`).appendTo($colSpells);

                metasRenderedFlats.push({
                    flat,
                    $pt,
                    $sep,
                    ...getFlatVars(flat),
                });
            }
            );

            flatsFilterAll.forEach(flat=>{
                const ptFilter = this._modalFilterSpells.getRenderedFilterExpression({
                    filterExpression: flat.filterExpression
                });
                const $pt = $$`<div class="ve-flex-v-center"><i class="mr-2 ve-muted">Spells matching:</i> ${ptFilter ? `${ptFilter} ` : ""}</div>`.appendTo($colSpells);
                const $sep = $(`<div class="mr-1">,</div>`).appendTo($colSpells);

                metasRenderedFlats.push({
                    flat,
                    $pt,
                    $sep,
                    ...getFlatVars(flat),
                });
            }
            );

            Object.entries(chooseFromGroups).forEach(([groupUid,group])=>{
                const {propBase} = this._getProps_chooseFrom({
                    groupUid
                });

                const meta = ComponentUiUtil.getMetaWrpMultipleChoice(this, propBase, {
                    values: group.from.map(it=>it.uid),
                    fnDisplay: v=>Renderer.get().render(`{@spell ${v}}`),
                    count: group.count,
                }, );

                const hkPulse = ()=>this._state.pulseChoose = !this._state.pulseChoose;
                this._addHookBase(meta.propPulse, hkPulse);

                if (this._additionalSpellsFlat.length !== 1) {
                    const hkDisableUi = ()=>{
                        meta.rowMetas.forEach(({$cb})=>$cb.prop("disabled", this._state.ixSet !== ix));
                    }
                    ;
                    this._addHookBase("ixSet", hkDisableUi);
                    hkDisableUi();
                }

                const $ptsInline = meta.rowMetas.map(({$cb, displayValue})=>{
                    return $$`<div class="ve-flex-v-center mr-2 no-wrap">${displayValue}${$cb.addClass("ml-1")}</div>`;
                }
                );

                const $pt = $$`<div class="ve-flex-v-center ve-flex-wrap"><i class="mr-1 ve-muted no-wrap">Choose ${group.count === 1 ? "" : `${group.count} `}from:</i>${$ptsInline}</div>`.appendTo($colSpells);
                const $sep = $(`<div class="mr-1">,</div>`).appendTo($colSpells);

                metasRenderedFlats.push({
                    flat: null,
                    $pt,
                    $sep,
                    ...group,
                });
            }
            );

            const $row = $$`<div class="py-1 ve-flex-v-center stripe-even">
					<div class="col-3 ve-text-center">${Parser.getOrdinalForm(requiredCasterLevel || requiredLevel) || `<i class="ve-muted">Current</i>`}</div>
					${$colSpells}
				</div>`;

            const doShowInitialPts = ()=>{
                metasRenderedFlats.forEach(({$pt, $sep},i)=>{
                    $pt.showVe();
                    $sep.toggleVe(i !== metasRenderedFlats.length - 1);
                }
                );
            }
            ;

            const doShowExpandedPts = ()=>{
                let isExpandedVisible;
                let isAllVisible;
                if (isRequiredCasterLevel) {
                    isExpandedVisible = this._isRequiredCasterLevelInRangeUpper(requiredCasterLevel);
                    isAllVisible = this._isRequiredCasterLevelInRange(requiredCasterLevel);
                } else if (isRequiredLevel) {
                    isExpandedVisible = this._isRequiredLevelInRangeUpper(requiredCasterLevel);
                    isAllVisible = this._isRequiredLevelInRange(requiredCasterLevel);
                } else
                    throw new Error(`No need to use this method!`);

                if (isAllVisible || !isExpandedVisible)
                    return doShowInitialPts();

                metasRenderedFlats.forEach((meta,i)=>{
                    meta.$pt.toggleVe(meta.isExpanded);
                    meta.$sep.toggleVe(i !== metasRenderedFlats.length - 1);
                }
                );

                let isFoundFirst = false;
                for (let i = metasRenderedFlats.length - 1; i >= 0; --i) {
                    const meta = metasRenderedFlats[i];

                    meta.$sep.hideVe();
                    if (!meta.isExpanded)
                        continue;

                    if (isFoundFirst) {
                        meta.$sep.showVe();
                        break;
                    }

                    isFoundFirst = true;
                }
            }
            ;

            if (isRequiredCasterLevel) {
                const hkLevel = ()=>{
                    const isVisible = isAnyExpanded ? this._isRequiredCasterLevelInRangeUpper(requiredCasterLevel) : this._isRequiredCasterLevelInRange(requiredCasterLevel);
                    $row.toggleVe(isVisible);
                    if (!isVisible || !isAnyExpanded)
                        return doShowInitialPts();
                    doShowExpandedPts();
                }
                ;
                this._addHookBase("spellLevelLow", hkLevel);
                this._addHookBase("spellLevelHigh", hkLevel);
                this._addHookBase("isAnyCantrips", hkLevel);
                hkLevel();
            } else if (isRequiredLevel) {
                const hkLevel = ()=>{
                    const isVisible = isAnyExpanded ? this._isRequiredLevelInRangeUpper(requiredLevel) : this._isRequiredLevelInRange(requiredLevel);
                    $row.toggleVe(isVisible);
                    if (!isVisible && !isAnyExpanded)
                        return doShowInitialPts();
                    doShowExpandedPts();
                }
                ;
                this._addHookBase("curLevel", hkLevel);
                this._addHookBase("targetLevel", hkLevel);
                hkLevel();
            } else {
                $row.showVe();
                doShowInitialPts();
            }

            return $row;
        }
        );
    }

    _render_$getSelChooseAbility(ix) {
        return ComponentUiUtil.$getSelEnum(this, "ability", {
            values: this._additionalSpells[ix].ability.choose,
            fnDisplay: abv=>Parser.attAbvToFull(abv),
            isAllowNull: true,
        }, );
    }

    _isRequiredLevelInRange(requiredLevel) {
        return this._isRequiredLevelInRangeLower(requiredLevel) && this._isRequiredLevelInRangeUpper(requiredLevel);
    }

    _isRequiredLevelInRangeLower(requiredLevel) {
        return requiredLevel > (this._state.curLevel ?? Number.MAX_SAFE_INTEGER);
    }

    _isRequiredLevelInRangeUpper(requiredLevel) {
        return requiredLevel <= (this._state.targetLevel ?? Number.MIN_SAFE_INTEGER);
    }

    _isRequiredCasterLevelInRange(requiredCasterLevel) {
        if (requiredCasterLevel === 0)
            return this._state.isAnyCantrips;

        return this._isRequiredCasterLevelInRangeLower(requiredCasterLevel) && this._isRequiredCasterLevelInRangeUpper(requiredCasterLevel);
    }

    _isRequiredCasterLevelInRangeLower(requiredCasterLevel) {
        if (requiredCasterLevel === 0)
            return this._state.isAnyCantrips;

        return requiredCasterLevel >= (this._state.spellLevelLow ?? Number.MAX_SAFE_INTEGER);
    }

    _isRequiredCasterLevelInRangeUpper(requiredCasterLevel) {
        if (requiredCasterLevel === 0)
            return this._state.isAnyCantrips;

        return requiredCasterLevel <= (this._state.spellLevelHigh == null ? Number.MIN_SAFE_INTEGER : this._state.spellLevelHigh);
    }

    _getFlatSpellsInRange(ixSet=null, {isExpandedMatch=null}={}) {
        if (ixSet == null)
            ixSet = this._state.ixSet;

        return Object.values((this._additionalSpellsFlat[ixSet] || {
            spells: []
        }).spells).filter(flat=>{
            if (isExpandedMatch != null) {
                if (flat.isExpanded !== isExpandedMatch)
                    return false;
            }

            if (flat.isExpanded) {
                if (flat.requiredCasterLevel != null)
                    return this._isRequiredCasterLevelInRangeUpper(flat.requiredCasterLevel);
                else if (flat.requiredLevel != null)
                    return this._isRequiredLevelInRangeUpper(flat.requiredLevel);
                return true;
            }

            if (flat.requiredCasterLevel != null)
                return this._isRequiredCasterLevelInRange(flat.requiredCasterLevel);
            else if (flat.requiredLevel != null)
                return this._isRequiredLevelInRange(flat.requiredLevel);
            return true;
        }
        );
    }

    _getFlatInnatePreparedSpellsInRange(ixSet) {
        return this._getFlatSpellsInRange(ixSet, {
            isExpandedMatch: false
        });
    }
    _getFlatExpandedSpellsInRange(ixSet) {
        return this._getFlatSpellsInRange(ixSet, {
            isExpandedMatch: true
        });
    }

    _isAnyInnatePrepared(ixSet) {
        return this._isAnyInnatePreparedExpanded(ixSet, {
            isExpandedMatch: false
        });
    }
    _isAnyExpanded(ixSet) {
        return this._isAnyInnatePreparedExpanded(ixSet, {
            isExpandedMatch: true
        });
    }

    _isAnyInnatePreparedExpanded(ixSet, {isExpandedMatch}) {
        if (ixSet == null)
            ixSet = this._state.ixSet;

        return Object.values((this._additionalSpellsFlat[ixSet] || {
            spells: []
        }).spells).some(flat=>flat.isExpanded === isExpandedMatch);
    }

    _isChooseAbility(ixSet) {
        if (ixSet == null)
            ixSet = this._state.ixSet;
        return (this._additionalSpells[ixSet]?.ability?.choose?.length ?? 0) > 1;
    }

    isNoChoice({curLevel, targetLevel, isStandalone}={}) {
        return this.constructor.isNoChoice(this._additionalSpells, {
            additionalSpellsFlat: this._additionalSpellsFlat,
            curLevel,
            targetLevel,
            isStandalone
        });
    }

    getFormData() {
        let flatSpellsInRange = this._getFlatSpellsInRange().map(it=>it.getCopy());

        const chooseFromGroups = {};
        flatSpellsInRange.forEach(flat=>{
            if (!flat.chooseFromGroup)
                return;

            chooseFromGroups[flat.chooseFromGroup] = chooseFromGroups[flat.chooseFromGroup] || {
                from: [],
                selectedValues: [],
                isAcceptable: false,
                count: flat.chooseFromCount ?? 1,
            };
            chooseFromGroups[flat.chooseFromGroup].from.push(flat);
        }
        );

        Object.entries(chooseFromGroups).forEach(([groupUid,groupMeta])=>{
            const {propBase} = this._getProps_chooseFrom({
                groupUid
            });

            groupMeta.isAcceptable = this._state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable(propBase)];

            groupMeta.selectedValues = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedValues(this, propBase, {
                values: groupMeta.from.map(it=>it.uid)
            });
        }
        );

        let cntNotChosen = 0;
        flatSpellsInRange = flatSpellsInRange.filter(flat=>{
            if (flat.type === "all")
                return true;
            if (flat.filterExpression != null) {
                const choiceMade = this._state[flat.key];
                if (!choiceMade) {
                    cntNotChosen++;
                    return false;
                }

                flat.filterExpression = null;
                flat.uid = this._state[flat.key];
                return true;
            }

            if (flat.chooseFromGroup != null) {
                return chooseFromGroups[flat.chooseFromGroup].selectedValues.includes(flat.uid);
            }

            return true;
        }
        );

        flatSpellsInRange = flatSpellsInRange.flatMap(flat=>{
            if (flat.type !== "all")
                return flat;

            if (flat.filterExpression != null) {
                const filterExpression = flat.filterExpression;
                flat.filterExpression = null;
                return this._modalFilterSpells.getItemsMatchingFilterExpression({
                    filterExpression
                }).map((li,i)=>flat.getCopy({
                    type: "spell",
                    key: `${flat.key}__${i}`,
                    uid: DataUtil.proxy.getUid("spell", {
                        name: li.name,
                        source: li.values.sourceJson
                    }),
                }, ));
            }

            if (flat.chooseFromGroup != null) {
                if (chooseFromGroups[flat.chooseFromGroup].selectedValues.includes(flat.uid))
                    return flat;
            }

            return null;
        }
        ).filter(Boolean);

        let abilityAbv;
        if (this._isChooseAbility(this._state.ixSet)) {
            abilityAbv = this._state.ability;
            if (abilityAbv == null)
                cntNotChosen++;
        } else
            abilityAbv = (this._additionalSpellsFlat[this._state.ixSet] || {
                meta: {}
            }).meta.ability;

        return {
            isFormComplete: cntNotChosen === 0 && Object.values(chooseFromGroups).every(it=>it.isAcceptable),
            data: flatSpellsInRange.map(it=>it.toObject()),
            abilityAbv,
        };
    }

    pGetFormData() {
        return this.getFormData();
    }

    _getDefaultState() {
        return {
            ixSet: 0,

            curLevel: null,
            targetLevel: null,
            spellLevelLow: null,
            spellLevelHigh: null,
            isAnyCantrips: false,

            spellsAlwaysPrepared: [],
            spellsExpanded: [],
            spellsAlwaysKnown: [],

            ability: null,

            pulseChoose: false,
        };
    }
}
class Charactermancer_Class_LevelSelect extends BaseComponent {
    static async pGetUserInput(opts) {
        return UtilApplications.pGetImportCompApplicationFormData({
            comp: new this(opts),
            isUnskippable: true,
            fnGetInvalidMeta: (formData)=>{
                if (formData.data.length === 0)
                    return {
                        type: "error",
                        message: `Please select some levels first!`
                    };
            }
            ,
            isAutoResize: true,
            width: 640,
        });
    }

    constructor(opts) {
        super();

        this._isSubclass = !!opts.isSubclass;
        this._isRadio = !!opts.isRadio;
        this._isForceSelect = !!opts.isForceSelect;
        this._featureArr = this.constructor._getLevelGroupedFeatures(opts.features, this._isSubclass);
        this._maxPreviousLevel = opts.maxPreviousLevel || 0;

        this._list = null;
        this._listSelectClickHandler = null;

        this._fnsOnChange = [];
    }

    get modalTitle() {
        return `Select ${this._isSubclass ? "Subclass" : "Class"} Levels`;
    }

    onchange(fn) {
        this._fnsOnChange.push(fn);
    }

    _doRunFnsOnchange() {
        this._fnsOnChange.forEach(fn=>fn());
    }

    setFeatures(features) {
        this._featureArr = this.constructor._getLevelGroupedFeatures(features, this._isSubclass);
        this._list.items.forEach(it=>it.data.fnUpdateRowText());
    }

    render($wrp) {
        const $cbAll = this._isRadio ? null : $(`<input type="checkbox" name="cb-select-all">`);
        const $wrpList = $(`<div class="veapp__list mb-1"></div>`);

        this._list = new List({
            $wrpList: $wrpList,
            fnSort: null,
            isUseJquery: true,
        });

        this._listSelectClickHandler = new ListSelectClickHandler({
            list: this._list
        });

        for (let ix = 0; ix < this._featureArr.length; ++ix) {
            const $cb = this._render_$getCbRow(ix);

            const $dispFeatures = $(`<span class="col-9-5"></span>`);
            const fnUpdateRowText = ()=>$dispFeatures.text(this.constructor._getRowText(this._featureArr[ix]));
            fnUpdateRowText();

            const $li = $$`<label class="w-100 ve-flex veapp__list-row veapp__list-row-hoverable ${this._isRadio && this._isForceSelect && ix <= this._maxPreviousLevel ? `list-multi-selected` : ""} ${ix < this._maxPreviousLevel ? `ve-muted` : ""}">
				<span class="col-1 ve-flex-vh-center">${$cb}</span>
				<span class="col-1-5 ve-text-center">${ix + 1}</span>
				${$dispFeatures}
			</label>`.click((evt)=>{
                this._handleSelectClick(listItem, evt);
            }
            );

            const listItem = new ListItem(ix,$li,"",{},{
                cbSel: $cb[0],
                fnUpdateRowText,
            },);
            this._list.addItem(listItem);
        }

        if (!this._isRadio)
            this._listSelectClickHandler.bindSelectAllCheckbox($cbAll);

        this._list.init();

        $$`<div class="ve-flex-col min-h-0">
			<div class="ve-flex-v-stretch input-group mb-1 no-shrink">
				<label class="btn btn-5et col-1 px-1 ve-flex-vh-center">${$cbAll}</label>
				<button class="btn-5et col-1-5">Level</button>
				<button class="btn-5et col-9-5">Features</button>
			</div>

			${$wrpList}
		</div>`.appendTo($wrp);
    }

    _render_$getCbRow(ix) {
        if (!this._isRadio)
            return $(`<input type="checkbox" class="no-events">`);

        const $cb = $(`<input type="radio" class="no-events">`);
        if (ix === this._maxPreviousLevel && this._isForceSelect)
            $cb.prop("checked", true);
        else if (ix < this._maxPreviousLevel)
            $cb.prop("disabled", true);

        return $cb;
    }

    _handleSelectClick(listItem, evt) {
        if (!this._isRadio)
            return this._listSelectClickHandler.handleSelectClick(listItem, evt);

        const isCheckedOld = listItem.data.cbSel.checked;

        const isDisabled = this._handleSelectClickRadio(this._list, listItem, evt);
        if (isDisabled)
            return;

        const isCheckedNu = listItem.data.cbSel.checked;
        if (isCheckedOld !== isCheckedNu)
            this._doRunFnsOnchange();
    }

    _handleSelectClickRadio(list, item, evt) {
        evt.preventDefault();
        evt.stopPropagation();

        if (item.data.cbSel.disabled)
            return true;

        list.items.forEach(it=>{
            if (it === item) {
                if (it.data.cbSel.checked && !this._isForceSelect) {
                    it.data.cbSel.checked = false;
                    it.ele.removeClass("list-multi-selected");
                    return;
                }

                it.data.cbSel.checked = true;
                it.ele.addClass("list-multi-selected");
            } else {
                it.data.cbSel.checked = false;
                if (it.ix < item.ix)
                    it.ele.addClass("list-multi-selected");
                else
                    it.ele.removeClass("list-multi-selected");
            }
        }
        );
    }

    pGetFormData() {
        let out = this._list.items.filter(it=>it.data.cbSel.checked).map(it=>it.ix);

        if (this._isRadio && out.length) {
            const max = out[0] + 1;
            out = [];
            for (let i = this._maxPreviousLevel; i < max; ++i)
                out.push(i);
        }

        return {
            isFormComplete: !!out.length,
            data: out,
        };
    }

    getCurLevel() {
        if (this._maxPreviousLevel)
            return this._maxPreviousLevel;
        return 0;
    }

    getTargetLevel() {
        const ixs = this._list.items.filter(it=>it.data.cbSel.checked).map(it=>it.ix);
        if (!ixs.length)
            return null;
        return Math.max(...ixs) + 1;
    }

    static _getRowText(lvl) {
        return lvl.map(f=>f.tableDisplayName || f.name).join(", ") || "\u2014";
    }

    static _getLevelGroupedFeatures(allFeatures, isSubclass) {
        allFeatures = MiscUtil.copy(allFeatures);
        if (!isSubclass)
            allFeatures = allFeatures.filter(it=>it.classFeature);
        const allFeaturesByLevel = [];

        let level = 1;
        let stack = [];
        const output = ()=>{
            allFeaturesByLevel.push(stack);
            stack = [];
        }
        ;
        allFeatures.forEach(f=>{
            while (level < f.level) {
                output();
                level++;
            }
            stack.push(f);
            level = f.level;
        }
        );
        output();

        while (level < Consts.CHAR_MAX_LEVEL) {
            output();
            level++;
        }

        return allFeaturesByLevel;
    }
}
class Charactermancer_Class_ProficiencyImportModeSelect extends BaseComponent {
    static async pGetUserInput() {
        return UtilApplications.pGetImportCompApplicationFormData({
            comp: new this(),
            isUnskippable: true,
            isAutoResize: true,
        });
    }

    pGetFormData() {
        return {
            isFormComplete: true,
            data: this._state.mode,
        };
    }

    get modalTitle() {
        return `Select Class Proficiency Import Mode`;
    }

    render($wrp) {
        const $sel = ComponentUiUtil.$getSelEnum(this, "mode", {
            values: [Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS, Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY, Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE, ],
            fnDisplay: mode=>Charactermancer_Class_ProficiencyImportModeSelect.DISPLAY_MODES[mode],
        }, );

        $$`<div class="ve-flex-col min-h-0">
			${$sel}
		</div>`.appendTo($wrp);
    }

    _getDefaultState() {
        return {
            mode: Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS,
        };
    }
}
Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS = 0;
Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY = 1;
Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE = 2;
Charactermancer_Class_ProficiencyImportModeSelect.DISPLAY_MODES = {
    [Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS]: "Add multiclass proficiencies (this is my second+ class)",
    [Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY]: "Add base class proficiencies and equipment (this is my first class)",
    [Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE]: "Do not add proficiencies or equipment",
};

class Charactermancer_Class_StartingProficiencies extends BaseComponent {
    
    constructor({featureSourceTracker, primaryProficiencies, multiclassProficiencies, savingThrowsProficiencies, existingProficienciesVetArmor, existingProficienciesVetWeapons, existingProficienciesVetSavingThrows, existingProficienciesFvttArmor, existingProficienciesFvttWeapons, existingProficienciesFvttSavingThrows, existingProficienciesCustomArmor, existingProficienciesCustomWeapons, }={}, ) {
        super();
        this._featureSourceTracker = featureSourceTracker;
        this._primaryProficiencies = Charactermancer_Class_StartingProficiencies._getCleanVetProfs(primaryProficiencies);
        this._multiclassProficiencies = Charactermancer_Class_StartingProficiencies._getCleanVetProfs(multiclassProficiencies);
        this._savingThrowsProficiencies = savingThrowsProficiencies;

        this._existingProficienciesVetArmor = existingProficienciesVetArmor;
        this._existingProficienciesVetWeapons = existingProficienciesVetWeapons;
        this._existingProficienciesVetSavingThrows = existingProficienciesVetSavingThrows;

        this._existingProficienciesCustomArmor = existingProficienciesCustomArmor;
        this._existingProficienciesCustomWeapons = existingProficienciesCustomWeapons;
        this._existingProficienciesFvttArmor = existingProficienciesFvttArmor ? MiscUtil.copy(existingProficienciesFvttArmor) : null;
        this._existingProficienciesFvttWeapons = existingProficienciesFvttWeapons ? MiscUtil.copy(existingProficienciesFvttWeapons) : null;
        this._existingProficienciesFvttSavingThrows = existingProficienciesFvttSavingThrows ? MiscUtil.copy(existingProficienciesFvttSavingThrows) : null;
    }
    
    static get({featureSourceTracker, primaryProficiencies, multiclassProficiencies, savingThrowsProficiencies, mode, existingProficienciesFvttArmor, existingProficienciesFvttWeapons, existingProficienciesFvttSavingThrows, }={}, ) {
        const {existingProficienciesVetArmor, existingProficienciesCustomArmor,
        existingProficienciesVetWeapons, existingProficienciesCustomWeapons,
        existingProficienciesVetSavingThrows, } = this._getExistingProficienciesVet({
            existingProficienciesFvttArmor,
            existingProficienciesFvttWeapons,
            existingProficienciesFvttSavingThrows,
        });

        const comp = new this({
            featureSourceTracker,
            primaryProficiencies,
            multiclassProficiencies,
            savingThrowsProficiencies,
            existingProficienciesVetArmor,
            existingProficienciesVetWeapons,
            existingProficienciesVetSavingThrows,

            existingProficienciesCustomArmor,
            existingProficienciesCustomWeapons,

            existingProficienciesFvttArmor,
            existingProficienciesFvttWeapons,
            existingProficienciesFvttSavingThrows,
        });

        if (mode != null)
            comp.mode = mode;

        return comp;
    }

    static async pGetUserInput({featureSourceTracker, primaryProficiencies, multiclassProficiencies, savingThrowsProficiencies, mode, existingProficienciesFvttArmor, existingProficienciesFvttWeapons, existingProficienciesFvttSavingThrows, }={}, ) {
        return this.get({
            featureSourceTracker,
            primaryProficiencies,
            multiclassProficiencies,
            savingThrowsProficiencies,
            mode,
            existingProficienciesFvttArmor,
            existingProficienciesFvttWeapons,
            existingProficienciesFvttSavingThrows,
        }).pGetFormData();
    }

    static applyFormDataToActorUpdate(actUpdate, formData) {
        MiscUtil.getOrSet(actUpdate, "system", "traits", {});

        this._applyFormDataToActorUpdate_applyProfList({
            actUpdate,
            profList: formData?.data?.armor || [],
            profsExisting: formData?.existingDataFvtt?.existingProficienciesArmor || {},
            propTrait: "armorProf",
            fnGetMapped: UtilActors.getMappedArmorProficiency.bind(UtilActors),
        });

        this._applyFormDataToActorUpdate_applyProfList({
            actUpdate,
            profList: formData.data?.weapons || [],
            profsExisting: formData?.existingDataFvtt?.existingProficienciesWeapons || {},
            propTrait: "weaponProf",
            fnGetMapped: UtilActors.getMappedWeaponProficiency.bind(UtilActors),
            fnGetPreMapped: UtilActors.getItemUIdFromWeaponProficiency.bind(UtilActors),
        });

        const tgtAbils = MiscUtil.getOrSet(actUpdate, "system", "abilities", {});
        [...(formData.data?.savingThrows || []), ...(formData.existingDataFvtt?.savingThrows || [])].forEach(abv=>(tgtAbils[abv] = tgtAbils[abv] || {}).proficient = 1);
    }

    static _applyFormDataToActorUpdate_addIfNotExists(arr, itm) {
        if (!arr.some(it=>it.toLowerCase().trim() === itm.toLowerCase().trim()))
            arr.push(itm);
    }

    static _applyFormDataToActorUpdate_applyProfList({actUpdate, profList, profsExisting, propTrait, fnGetMapped, fnGetPreMapped, }, ) {
        if (!profList?.length)
            return;

        const tgt = MiscUtil.getOrSet(actUpdate, "system", "traits", propTrait, {});
        tgt.value = tgt.value || [];
        tgt.custom = tgt.custom || "";

        const customArr = tgt.custom.split(";").map(it=>it.trim()).filter(Boolean);

        (profsExisting.value || []).forEach(it=>this._applyFormDataToActorUpdate_addIfNotExists(tgt.value, it));

        (profsExisting.custom || "").split(";").map(it=>it.trim()).filter(Boolean).forEach(it=>this._applyFormDataToActorUpdate_addIfNotExists(customArr, it));

        profList.forEach(it=>{
            const clean = (fnGetPreMapped ? fnGetPreMapped(it) : null) ?? Renderer.stripTags(it).toLowerCase();
            const mapped = fnGetMapped(clean);
            if (mapped)
                return this._applyFormDataToActorUpdate_addIfNotExists(tgt.value, mapped);

            const [itemTag] = /{@item [^}]+}/i.exec(it) || [];
            if (itemTag) {
                const mappedAlt = fnGetMapped(Renderer.stripTags(itemTag));
                if (mappedAlt)
                    return this._applyFormDataToActorUpdate_addIfNotExists(tgt.value, mappedAlt);
            }

            this._applyFormDataToActorUpdate_addIfNotExists(customArr, Renderer.stripTags(it));
        }
        );

        tgt.custom = customArr.join("; ");
    }

    static getExistingProficienciesFvttSavingThrows(actor) {
        return Object.entries(MiscUtil.get(actor, "_source", "system", "abilities") || {}).filter(([,abMeta])=>abMeta.proficient).map(([ab])=>ab);
    }

    static _getExistingProficienciesVet({existingProficienciesFvttArmor, existingProficienciesFvttWeapons, existingProficienciesFvttSavingThrows}) {
        const vetValidWeapons = new Set();
        const customWeapons = new Set();
        const vetValidArmors = new Set();
        const customArmors = new Set();

        this._getExistingProficienciesVet_({
            existingFvtt: existingProficienciesFvttWeapons,
            fnGetUnmapped: UtilActors.getUnmappedWeaponProficiency.bind(UtilActors),
            fnCheckUnmappedAlt: UtilActors.getItemUIdFromWeaponProficiency.bind(UtilActors),
            vetValidSet: vetValidWeapons,
            customSet: customWeapons,
        });

        this._getExistingProficienciesVet_({
            existingFvtt: existingProficienciesFvttArmor,
            fnGetUnmapped: UtilActors.getUnmappedArmorProficiency.bind(UtilActors),
            vetValidSet: vetValidArmors,
            customSet: customArmors,
        });

        return {
            existingProficienciesVetWeapons: [...vetValidWeapons],
            existingProficienciesCustomWeapons: [...customWeapons],
            existingProficienciesVetArmor: [...vetValidArmors],
            existingProficienciesCustomArmor: [...customArmors],
            existingProficienciesVetSavingThrows: existingProficienciesFvttSavingThrows,
        };
    }

    static _getExistingProficienciesVet_({existingFvtt, vetValidSet, customSet, fnGetUnmapped, fnCheckUnmappedAlt, }) {
        (existingFvtt?.value || []).forEach(it=>{
            const unmapped = fnGetUnmapped(it);
            if (unmapped)
                vetValidSet.add(unmapped);
            else {
                if (fnCheckUnmappedAlt) {
                    const unmappedVet = fnCheckUnmappedAlt(it);
                    if (unmappedVet)
                        vetValidSet.add(it);
                    else
                        customSet.add(it);
                } else {
                    customSet.add(it);
                }
            }
        }
        );

        (existingFvtt?.custom || "").trim().split(";").map(it=>it.trim()).filter(Boolean).forEach(it=>{
            const low = it.toLowerCase();
            const unmapped = fnGetUnmapped(low);
            if (unmapped)
                vetValidSet.add(unmapped);
            else {
                if (fnCheckUnmappedAlt) {
                    const unmappedVet = fnCheckUnmappedAlt(low);
                    if (unmappedVet)
                        vetValidSet.add(low);
                    else
                        customSet.add(it);
                } else {
                    customSet.add(it);
                }
            }
        }
        );
    }

    static _getCleanVetProfs(vetProfs) {
        if (!vetProfs)
            return {};

        const out = {};

        if (vetProfs.armor)
            out.armor = this._getCleanVetProfs_getMappedItemTags(vetProfs.armor.map(it=>it.proficiency || it));
        if (vetProfs.weapons)
            out.weapons = this._getCleanVetProfs_getMappedItemTags(vetProfs.weapons.map(it=>(it.proficiency || it).toLowerCase().trim()));

        return out;
    }

    static _getCleanVetProfs_getMappedItemTags(arr) {
        return arr.map(it=>it.replace(/^{@item ([^}]+)}$/g, (...m)=>{
            const [name,source] = Renderer.splitTagByPipe(m[1]);
            return `${name}|${source || Parser.SRC_DMG}`.toLowerCase();
        }
        ));
    }

    

    set mode(mode) {
        this._state.mode = mode;
    }

    _getFormData() {
        const isPrimary = this._state.mode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY;
        const profs = isPrimary ? this._primaryProficiencies : this._multiclassProficiencies;

        if (!profs)
            return {
                isFormComplete: true,
                data: {},
                existingData: {}
            };

        return {
            isFormComplete: true,
            data: {
                armor: profs.armor || [],
                weapons: profs.weapons || [],
                savingThrows: isPrimary ? (this._savingThrowsProficiencies || []) : [],
            },
            existingDataFvtt: {
                existingProficienciesArmor: this._existingProficienciesFvttArmor,
                existingProficienciesWeapons: this._existingProficienciesFvttWeapons,
                existingProficienciesSavingThrows: this._existingProficienciesFvttSavingThrows,
            },
        };
    }

    pGetFormData() {
        return this._getFormData();
    }

    render($wrp) {
        const $wrpDisplay = $(`<div class="ve-flex-col min-h-0 ve-small"></div>`).appendTo($wrp);

        const fnsCleanup = [];

        const hkMode = ()=>{
            fnsCleanup.forEach(fn=>fn());
            fnsCleanup.splice(0, fnsCleanup.length);

            $wrpDisplay.empty();
            const isPrimary = this._state.mode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY;

            const profs = isPrimary ? this._primaryProficiencies : this._multiclassProficiencies;
            if (profs) {
                this._render_profType({
                    profList: profs.armor,
                    title: "Armor",
                    $wrpDisplay,
                    propTracker: "armorProficiencies",
                    propTrackerPulse: "pulseArmorProficiencies",
                    fnsCleanup,
                    existing: this._existingProficienciesVetArmor,
                    existingProficienciesCustom: this._existingProficienciesCustomArmor,
                    fnDisplay: str=>["light", "medium", "heavy"].includes(str) ? `${str} armor` : str.includes("|") ? `{@item ${str}}` : str,
                });

                this._render_profType({
                    profList: profs.weapons,
                    title: "Weapons",
                    $wrpDisplay,
                    propTracker: "weaponProficiencies",
                    propTrackerPulse: "pulseWeaponProficiencies",
                    fnsCleanup,
                    existing: this._existingProficienciesVetWeapons,
                    existingProficienciesCustom: this._existingProficienciesCustomWeapons,
                    fnDisplay: str=>["simple", "martial"].includes(str) ? `${str} weapons` : str.includes("|") ? `{@item ${str}}` : str,
                });
            }

            if (isPrimary && this._savingThrowsProficiencies) {
                this._render_profType({
                    profList: this._savingThrowsProficiencies,
                    title: "Saving Throws",
                    $wrpDisplay,
                    propTracker: "savingThrowProficiencies",
                    propTrackerPulse: "pulseSavingThrowProficiencies",
                    fnsCleanup,
                    existing: this._existingProficienciesVetSavingThrows,
                    fnDisplay: str=>Parser.attAbvToFull(str),
                });
            }

            if (this._featureSourceTracker) {this._featureSourceTracker.setState(this, this._getStateTrackerData());}
        };
        this._addHookBase("mode", hkMode);
        hkMode();
    }

    _getStateTrackerData() {
        const formData = this._getFormData();

        const getNoTags = (arr)=>arr.map(it=>this.constructor._getUid(it)).filter(Boolean);

        return {
            armorProficiencies: getNoTags(formData.data?.armor || []).mergeMap(it=>({
                [it]: true
            })),
            weaponProficiencies: getNoTags(formData.data?.weapons || []).mergeMap(it=>({
                [it]: true
            })),
        };
    }

    static _getUid(str) {
        if (!str.startsWith("{@item"))
            return str;

        let[name,source] = Renderer.splitTagByPipe((Renderer.splitFirstSpace(str.slice(1, -1))[1] || "").toLowerCase());
        source = source || Parser.SRC_DMG.toLowerCase();
        if (!name)
            return null;

        return `${name}|${source}`;
    }

    _render_profType({profList, title, $wrpDisplay, propTracker, propTrackerPulse, fnsCleanup, existing, existingProficienciesCustom, fnDisplay}) {
        if (!profList?.length)
            return;

        const profListUids = profList.map(prof=>this.constructor._getUid(prof));

        const $ptsExisting = {};

        const $wrps = profList.map((it,i)=>{
            const $ptExisting = $(`<div class="ve-small veapp__msg-warning inline-block"></div>`);
            const uid = profListUids[i];
            $ptsExisting[uid] = $ptExisting;
            const isNotLast = i < profList.length - 1;
            return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${Renderer.get().render(fnDisplay ? fnDisplay(it) : it)}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
        }
        );

        $$`<div class="block">
			<div class="mr-1 bold inline-block">${title}:</div>${$wrps}
		</div>`.appendTo($wrpDisplay);

        const pHkUpdatePtsExisting = async()=>{
            try {
                await this._pLock("updateExisting");
                await pHkUpdatePtsExisting_();
            } finally {
                this._unlock("updateExisting");
            }
        }
        ;

        const pHkUpdatePtsExisting_ = async()=>{
            const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(propTracker, {
                ignore: this
            }) : null;

            for (const v of profListUids) {
                if (!$ptsExisting[v])
                    return;

                const parentGroup = await UtilDataConverter.pGetItemWeaponType(v);

                let isExisting = (existing || []).includes(v) || (parentGroup && (existing || []).includes(parentGroup)) || (existingProficienciesCustom || []).includes(v) || (parentGroup && (existingProficienciesCustom || []).includes(parentGroup));

                isExisting = isExisting || (otherStates || []).some(otherState=>!!otherState[v] || (parentGroup && !!otherState[parentGroup]));

                $ptsExisting[v].title(isExisting ? "Proficient from Another Source" : "").toggleClass("ml-1", isExisting).html(isExisting ? `(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[1]}"></i>)` : "");
            }
        }
        ;
        if (this._featureSourceTracker) {
            this._featureSourceTracker.addHook(this, propTrackerPulse, pHkUpdatePtsExisting);
            fnsCleanup.push(()=>this._featureSourceTracker.removeHook(this, propTrackerPulse, pHkUpdatePtsExisting));
        }
        pHkUpdatePtsExisting();
    }

    _getDefaultState() {
        return {
            mode: Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY,
        };
    }
}
//#endregion

//#region Charactermancer Ability
/**The panel that handles adjusting ability scores */
class ActorCharactermancerAbility extends ActorCharactermancerBaseComponent {
    static _STORAGE_KEY__PB_CUSTOM = "actor_charactermancer_ability";
    constructor(parentInfo) {
      parentInfo = parentInfo || {};
      super();
      this._actor = parentInfo.actor;
      this._data = parentInfo.data;
      this._parent = parentInfo.parent;
      this._tabAbilities = parentInfo.tabAbilities;
      this._compStatgen = null;
    }
    render() {
        const parentDiv = this._tabAbilities?.$wrpTab;
        if (!parentDiv) {return;}

        //This element will handle the heavy lifting, both UI wise and logic wise
        this._compStatgen = new StatGenUiCharactermancer({
            'isCharacterMode': true,
            'isFvttMode': true,
            'races': this._data.race,
            'backgrounds': this._data.background,
            'feats': this._data.feat,
            'modalFilterRaces': this._parent.compRace.modalFilterRaces,
            'modalFilterBackgrounds': this._parent.compBackground.modalFilterBackgrounds,
            /*'modalFilterFeats': this._parent.compFeat.modalFilterFeats, */
            /* 'existingScores': this._getExistingScores() */
        });

        /* const clientThenWorld = GameStorage.getClientThenWorld(this.constructor._STORAGE_KEY__PB_CUSTOM);
        if (clientThenWorld != null) {this._compStatgen.setStateFrom(clientThenWorld);} */

        const _0x8ec07a = MiscUtil.throttle(this._doSavePbRules.bind(this), 0x64); 
        this._compStatgen.addHookPointBuyCustom(_0x8ec07a);

        //Render the ui for changing ability scores
        this._compStatgen.render(parentDiv);
        const e_recountASI = () => {
            let asiCount = 0;
            for (let ix = 0; ix < this._parent.compClass.state.class_ixMax + 1; ++ix) {
                const {
                    propIxClass: propIxClass,
                    propCntAsi: propCntAsi
                } = ActorCharactermancerBaseComponent.class_getProps(ix);
                const cls = this._parent.compClass.getClass_({ 'propIxClass': propIxClass });
                if (!cls) { continue; }
                asiCount += Number(this._parent.compClass.state[propCntAsi]) || 0;
            }
            this._compStatgen.common_cntAsi = asiCount;
        };

        this._parent.compClass.addHookBase("class_pulseChange", e_recountASI);
        this._parent.compClass.addHookBase('class_totalLevels', e_recountASI);
        e_recountASI();

        /* const _0x4ae28f = () => this._parent.compFeat.setAdditionalFeatStateFromStatgen_();
        this._compStatgen.addHookPulseAsi(_0x4ae28f);
        this._parent.compFeat.setAdditionalFeatStateFromStatgen_(); */

        //If we change our race or background, call these events to change it elsewhere too
        const onRaceChangedHere = () => this._parent.compRace.state.race_ixRace = this._compStatgen.ixRace;
        this._compStatgen.addHookIxRace(onRaceChangedHere);
        const onBackgroundChangedHere = () => this._parent.compBackground.state.background_ixBackground = this._compStatgen.ixBackground;
        this._compStatgen.addHookIxBackground(onBackgroundChangedHere);

        //If state changes their race or background, call these events to change it here too
        const onRaceChangedThere = () => this._compStatgen.ixRace = this._parent.compRace.state.race_ixRace;
        this._parent.compRace.addHookBase("race_ixRace", onRaceChangedThere);
        const onBackgroundChangedThere = () => this._compStatgen.ixBackground = this._parent.compBackground.state.background_ixBackground;
        this._parent.compBackground.addHookBase("background_ixBackground", onBackgroundChangedThere);

        //Set our race and background to be what state says it is
        this._compStatgen.ixRace = this._parent.compRace.state.race_ixRace;
        this._compStatgen.ixBackground = this._parent.compBackground.state.background_ixBackground;
    }

    get compStatgen() { return this._compStatgen; }
    addHookAbilityScores(..._0x42aa73) {
      return this._compStatgen.addHookAbilityScores(..._0x42aa73);
    }
    getMode(..._0x30474b) {
      return this._compStatgen.getMode(..._0x30474b);
    }
    getTotals(..._0x5d866f) {
      return this._compStatgen.getTotals(..._0x5d866f);
    }
    
    _doSavePbRules() {
      const pointBuySavedState = this._compStatgen.getSaveableStatePointBuyCustom();
      GameStorage.pSetWorldThenClient(this.constructor._STORAGE_KEY__PB_CUSTOM, pointBuySavedState).then(null);
    }
    _getExistingScores() {
      if (!Charactermancer_Util.getCurrentLevel(this._actor)) {
        return null;
      }
      return Charactermancer_Util.getBaseAbilityScores(this._actor);
    }
    _getDefaultState() {
      return {};
    }
}

class StatGenUi extends BaseComponent {
    static _PROPS_POINT_BUY_CUSTOM = ["pb_rules", "pb_budget", "pb_isCustom", ];

    constructor(opts) {
        super();
        opts = opts || {};

        TabUiUtilSide.decorate(this, {
            isInitMeta: true
        });

        this._races = opts.races; //Set races
        this._backgrounds = opts.backgrounds;
        this._feats = opts.feats;
        this._tabMetasAdditional = opts.tabMetasAdditional;
        this._isCharacterMode = opts.isCharacterMode;
        this._isFvttMode = opts.isFvttMode;

        this._MODES = this._isFvttMode ? StatGenUi.MODES_FVTT : StatGenUi.MODES;
        if (this._isFvttMode) {
            let cnt = 0;
            this._IX_TAB_NONE = cnt++;
            this._IX_TAB_ROLLED = cnt++;
            this._IX_TAB_ARRAY = cnt++;
            this._IX_TAB_PB = cnt++;
            this._IX_TAB_MANUAL = cnt;
        }
        else {
            this._IX_TAB_NONE = -1;
            let cnt = 0;
            this._IX_TAB_ROLLED = cnt++;
            this._IX_TAB_ARRAY = cnt++;
            this._IX_TAB_PB = cnt++;
            this._IX_TAB_MANUAL = cnt;
        }

        this._modalFilterRaces = opts.modalFilterRaces || new ModalFilterRaces({
            namespace: "statgen.races",
            isRadio: true,
            allData: this._races
        });
        this._modalFilterBackgrounds = opts.modalFilterBackgrounds || new ModalFilterBackgrounds({
            namespace: "statgen.backgrounds",
            isRadio: true,
            allData: this._backgrounds
        });
        /*this._modalFilterFeats = opts.modalFilterFeats || new ModalFilterFeats({
            namespace: "statgen.feats",
            isRadio: true,
            allData: this._feats
        }); */

        this._isLevelUp = !!opts.existingScores;
        this._existingScores = opts.existingScores;

        this._$rollIptFormula = null;

        this._compAsi = new StatGenUi.CompAsi({ parent: this });
    }

    get MODES() {
        return this._MODES;
    }

    render($parent) {
        $parent.empty().addClass("statgen");

        //If we are leveling up, some UI changes
        const iptTabMetas = this._isLevelUp ? [new TabUiUtil.TabMeta({
            name: "Existing",
            icon: this._isFvttMode ? `fas fa-fw fa-user` : `far fa-fw fa-user`,
            hasBorder: true
        }), ...this._tabMetasAdditional || [], ] : [this._isFvttMode ? new TabUiUtil.TabMeta({
            name: "Select...",
            icon: this._isFvttMode ? `fas fa-fw fa-square` : `far fa-fw fa-square`,
            hasBorder: true,
            isNoPadding: this._isFvttMode
        }) : null, new TabUiUtil.TabMeta({
            name: "Roll",
            icon: this._isFvttMode ? `fas fa-fw fa-dice` : `far fa-fw fa-dice`,
            hasBorder: true,
            isNoPadding: this._isFvttMode
        }), new TabUiUtil.TabMeta({
            name: "Standard Array",
            icon: this._isFvttMode ? `fas fa-fw fa-signal` : `far fa-fw fa-signal-alt`,
            hasBorder: true,
            isNoPadding: this._isFvttMode
        }), new TabUiUtil.TabMeta({
            name: "Point Buy",
            icon: this._isFvttMode ? `fas fa-fw fa-chart-bar` : `far fa-fw fa-chart-bar`,
            hasBorder: true,
            isNoPadding: this._isFvttMode
        }), new TabUiUtil.TabMeta({
            name: "Manual",
            icon: this._isFvttMode ? `fas fa-fw fa-tools` : `far fa-fw fa-tools`,
            hasBorder: true,
            isNoPadding: this._isFvttMode
        }), ...this._tabMetasAdditional || [], ].filter(Boolean);

        const tabMetas = this._renderTabs(iptTabMetas, {$parent: this._isFvttMode ? null : $parent});
        if (this._isFvttMode) {
            if (!this._isLevelUp) {
                const {propActive: propActiveTab, propProxy: propProxyTabs} = this._getTabProps();
                const $selMode = ComponentUiUtil.$getSelEnum(this, propActiveTab, {
                    values: iptTabMetas.map((_,ix)=>ix),
                    fnDisplay: ix=>iptTabMetas[ix].name,
                    propProxy: propProxyTabs,
                }, ).addClass("max-w-200p");
                $$`<div class="ve-flex-v-center statgen-shared__wrp-header">
					<div class="mr-2"><b>Mode</b></div>
					${$selMode}
				</div>
				<hr class="hr-2">`.appendTo($parent);
            }

            tabMetas.forEach(it=>it.$wrpTab.appendTo($parent));
        }

        const $wrpAll = $(`<div class="ve-flex-col w-100 h-100"></div>`);
        this._render_all($wrpAll);

        const hkTab = ()=> { tabMetas[this.ixActiveTab || 0].$wrpTab.append($wrpAll); };

        this._addHookActiveTab(hkTab);
        hkTab();

        this._addHookBase("common_cntAsi", ()=>this._state.common_pulseAsi = !this._state.common_pulseAsi);
        this._addHookBase("common_cntFeatsCustom", ()=>this._state.common_pulseAsi = !this._state.common_pulseAsi);
    }

    _render_all($wrpTab) {
        if (this._isLevelUp){return this._render_isLevelUp($wrpTab);}
        this._render_isLevelOne($wrpTab);
    }

    _render_isLevelOne($wrpTab) {
        let $stgNone;
        let $stgMain;
        const $elesRolled = [];
        const $elesArray = [];
        const $elesPb = [];
        const $elesManual = [];

        const $stgRolledHeader = this._render_$getStgRolledHeader();
        const hkStgRolled = ()=>$stgRolledHeader.toggleVe(this.ixActiveTab === this._IX_TAB_ROLLED);
        this._addHookActiveTab(hkStgRolled);
        hkStgRolled();

        const $stgPbHeader = this._render_$getStgPbHeader();
        const $stgPbCustom = this._render_$getStgPbCustom();
        const $vrPbCustom = $(`<div class="vr-5 mobile-ish__hidden"></div>`);
        const $hrPbCustom = $(`<hr class="hr-5 mobile-ish__visible">`);
        const hkStgPb = ()=>{
            $stgPbHeader.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
            $stgPbCustom.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
            $vrPbCustom.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
            $hrPbCustom.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
        };
        this._addHookActiveTab(hkStgPb);
        hkStgPb();

        const $stgArrayHeader = this._render_$getStgArrayHeader();
        const hkStgArray = ()=>$stgArrayHeader.toggleVe(this.ixActiveTab === this._IX_TAB_ARRAY);
        this._addHookActiveTab(hkStgArray);
        hkStgArray();

        const $stgManualHeader = this._render_$getStgManualHeader();
        const hkStgManual = ()=>$stgManualHeader.toggleVe(this.ixActiveTab === this._IX_TAB_MANUAL);
        this._addHookActiveTab(hkStgManual);
        hkStgManual();

        const hkElesMode = ()=>{
            $stgNone.toggleVe(this.ixActiveTab === this._IX_TAB_NONE);
            $stgMain.toggleVe(this.ixActiveTab !== this._IX_TAB_NONE);

            $elesRolled.forEach($ele=>$ele.toggleVe(this.ixActiveTab === this._IX_TAB_ROLLED));
            $elesArray.forEach($ele=>$ele.toggleVe(this.ixActiveTab === this._IX_TAB_ARRAY));
            $elesPb.forEach($ele=>$ele.toggleVe(this.ixActiveTab === this._IX_TAB_PB));
            $elesManual.forEach($ele=>$ele.toggleVe(this.ixActiveTab === this._IX_TAB_MANUAL));
        };
        this._addHookActiveTab(hkElesMode);

        const $btnResetRolledOrArrayOrManual = $(`<button class="btn btn-default btn-xxs relative statgen-shared__btn-reset" title="Reset"><span class="glyphicon glyphicon-refresh"></span></button>`).click(()=>this._doReset());
        const hkRolledOrArray = ()=>$btnResetRolledOrArrayOrManual.toggleVe(this.ixActiveTab === this._IX_TAB_ROLLED || this.ixActiveTab === this._IX_TAB_ARRAY || this.ixActiveTab === this._IX_TAB_MANUAL);
        this._addHookActiveTab(hkRolledOrArray);
        hkRolledOrArray();

        const $wrpsBase = Parser.ABIL_ABVS.map(ab=>{
            const {propAbilSelectedRollIx} = this.constructor._rolled_getProps(ab);

            const $selRolled = $(`<select class="form-control input-xs form-control--minimal statgen-shared__ipt statgen-shared__ipt--sel"></select>`).change(()=>{
                const ix = Number($selRolled.val());

                const nxtState = {
                    ...Parser.ABIL_ABVS.map(ab=>this.constructor._rolled_getProps(ab).propAbilSelectedRollIx).filter(prop=>ix != null && this._state[prop] === ix).mergeMap(prop=>({
                        [prop]: null
                    })),
                    [propAbilSelectedRollIx]: ~ix ? ix : null,
                };
                this._proxyAssignSimple("state", nxtState);
            }
            );
            $(`<option/>`, { value: -1, text: "\u2014" }).appendTo($selRolled);

            let $optionsRolled = [];
            const hkRolls = ()=>{
                $optionsRolled.forEach($opt=>$opt.remove());

                this._state.rolled_rolls.forEach((it,i)=>{
                    const cntPrevRolls = this._state.rolled_rolls.slice(0, i).filter(r=>r.total === it.total).length;
                    const $opt = $(`<option/>`, {
                        value: i,
                        text: `${it.total}${cntPrevRolls ? Parser.numberToSubscript(cntPrevRolls) : ""}`
                    }).appendTo($selRolled);
                    $optionsRolled.push($opt);
                }
                );

                let nxtSelIx = this._state[propAbilSelectedRollIx];
                if (nxtSelIx >= this._state.rolled_rolls.length)
                    nxtSelIx = null;
                $selRolled.val(`${nxtSelIx == null ? -1 : nxtSelIx}`);
                if ((nxtSelIx) !== this._state[propAbilSelectedRollIx])
                    this._state[propAbilSelectedRollIx] = nxtSelIx;
            };

            this._addHookBase("rolled_rolls", hkRolls);
            hkRolls();

            const hookIxRolled = ()=>{
                const ix = this._state[propAbilSelectedRollIx] == null ? -1 : this._state[propAbilSelectedRollIx];
                $selRolled.val(`${ix}`);
            };

            this._addHookBase(propAbilSelectedRollIx, hookIxRolled);
            hookIxRolled();

            $elesRolled.push($selRolled);

            const {propAbilSelectedScoreIx} = this.constructor._array_getProps(ab);

            const $selArray = $(`<select class="form-control input-xs form-control--minimal statgen-shared__ipt statgen-shared__ipt--sel"></select>`).change(()=>{
                const ix = Number($selArray.val());

                const nxtState = {
                    ...Parser.ABIL_ABVS.map(ab=>this.constructor._array_getProps(ab).propAbilSelectedScoreIx).filter(prop=>ix != null && this._state[prop] === ix).mergeMap(prop=>({
                        [prop]: null
                    })),
                    [propAbilSelectedScoreIx]: ~ix ? ix : null,
                };
                this._proxyAssignSimple("state", nxtState);
            }
            );

            $(`<option/>`, {
                value: -1,
                text: "\u2014"
            }).appendTo($selArray);

            StatGenUi._STANDARD_ARRAY.forEach((it,i)=>$(`<option/>`, {
                value: i,
                text: it
            }).appendTo($selArray));

            const hookIxArray = ()=>{
                const ix = this._state[propAbilSelectedScoreIx] == null ? -1 : this._state[propAbilSelectedScoreIx];
                $selArray.val(`${ix}`);
            };

            this._addHookBase(propAbilSelectedScoreIx, hookIxArray);
            hookIxArray();

            $elesArray.push($selArray);

            const propPb = `pb_${ab}`;
            const $iptPb = ComponentUiUtil.$getIptInt(this, propPb, 0, {
                fallbackOnNaN: 0,
                min: 0,
                html: `<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number">`,
            }, );

            const hkPb = ()=>{
                const {min: minScore, max: maxScore} = this._pb_getMinMaxScores();
                this._state[propPb] = Math.min(maxScore, Math.max(minScore, this._state[propPb]));
            };
            
            this._addHookBase(propPb, hkPb);
            hkPb();

            $elesPb.push($iptPb);

            const {propAbilValue} = this.constructor._manual_getProps(ab);
            const $iptManual = ComponentUiUtil.$getIptInt(this, propAbilValue, 0, {
                fallbackOnNaN: 0,
                html: `<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number">`,
            }, );

            $elesManual.push($iptManual);

            return $$`<label class="my-1 statgen-pb__cell">
				${$selRolled}
				${$selArray}
				${$iptPb}
				${$iptManual}
			</label>`;
        }
        );

        const $wrpsUser = this._render_$getWrpsUser();

        const metasTotalAndMod = this._render_getMetasTotalAndMod();
        const {$wrpOuter: $wrpRaceOuter, $stgSel: $stgRaceSel, $dispPreview: $dispPreviewRace, $hrPreview: $hrPreviewRaceTashas, $dispTashas, } = this._renderLevelOneRace.render();
        const {$wrpOuter: $wrpBackgroundOuter, $stgSel: $stgBackgroundSel, $dispPreview: $dispPreviewBackground, $hrPreview: $hrPreviewBackground, } = this._renderLevelOneBackground.render();


        //const $wrpAsi = this._render_$getWrpAsi();

        //TEMPFIX
        /* const $wrpRaceOuter = $(`<div></div>`);  const $wrpBackgroundOuter = $(`<div></div>`);  const $stgRaceSel = $(`<div></div>`);  const $stgBackgroundSel = $(`<div></div>`);
        const $dispPreviewBackground = $(`<div></div>`); const $dispPreviewRace = $(`<div></div>`);
        const $hrPreviewRaceTashas = $(`<div></div>`); const $hrPreviewBackground = $(`<div></div>`); const $dispTashas = $(`<div></div>`); */
        const $wrpAsi = $(`<div></div>`);

        $stgNone = $$`<div class="ve-flex-col w-100 h-100">
			<div class="ve-flex-v-center"><i>Please select a mode.</i></div>
		</div>`;

        $stgMain = $$`<div class="ve-flex-col w-100 h-100">
			${$stgRolledHeader}
			${$stgArrayHeader}
			${$stgManualHeader}

			<div class="ve-flex mobile-ish__ve-flex-col w-100 px-3">
				<div class="ve-flex-col">
					${$stgPbHeader}

					<div class="ve-flex">
						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-h-right">${$btnResetRolledOrArrayOrManual}</div>

							${Parser.ABIL_ABVS.map(it=>`<div class="my-1 bold statgen-pb__cell ve-flex-v-center ve-flex-h-right" title="${Parser.attAbvToFull(it)}">${it.toUpperCase()}</div>`)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 bold statgen-pb__header ve-flex-vh-center">Base</div>
							${$wrpsBase}
						</div>

						${$wrpRaceOuter}

						${$wrpBackgroundOuter}

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-vh-center help text-muted" title="Input any additional/custom bonuses here">User</div>
							${$wrpsUser}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-vh-center">Total</div>
							${metasTotalAndMod.map(it=>it.$wrpIptTotal)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-vh-center" title="Modifier">Mod.</div>
							${metasTotalAndMod.map(it=>it.$wrpIptMod)}
						</div>
					</div>

					${$stgRaceSel}
					${$stgBackgroundSel}
				</div>

				${$vrPbCustom}
				${$hrPbCustom}

				${$stgPbCustom}
			</div>

			<hr class="hr-3">

			${$dispPreviewRace}
			${$hrPreviewRaceTashas}
			${$dispTashas}

			${$dispPreviewBackground}
			${$hrPreviewBackground}

			${$wrpAsi}
		</div>`;

        hkElesMode();

        $wrpTab.append($stgMain).append($stgNone);
    }

    _render_$getStgRolledHeader() {
        this._$rollIptFormula = ComponentUiUtil.$getIptStr(this, "rolled_formula").addClass("ve-text-center max-w-100p").keydown(evt=>{
            if (evt.key === "Enter")
                setTimeout(()=>$btnRoll.click());
        }
        ).change(()=>this._$rollIptFormula.removeClass("form-control--error"));

        const $iptRollCount = this._isCharacterMode ? null : ComponentUiUtil.$getIptInt(this, "rolled_rollCount", 1, {
            min: 1,
            fallbackOnNaN: 1,
            html: `<input type="text" class="form-control input-xs form-control--minimal ve-text-center max-w-100p">`
        }).keydown(evt=>{
            if (evt.key === "Enter")
                setTimeout(()=>$btnRoll.click());
        }
        ).change(()=>this._$rollIptFormula.removeClass("form-control--error"));

        const $btnRoll = $(`<button class="btn btn-primary bold">Roll</button>`).click(()=>{
            this._state.rolled_rolls = this._roll_getRolledStats();
        }
        );

        const $btnRandom = $(`<button class="btn btn-xs btn-default mt-2">Randomly Assign</button>`).hideVe().click(()=>{
            const abs = [...Parser.ABIL_ABVS].shuffle();
            abs.forEach((ab,i)=>{
                const {propAbilSelectedRollIx} = this.constructor._rolled_getProps(ab);
                this._state[propAbilSelectedRollIx] = i;
            }
            );
        }
        );

        const $wrpRolled = $(`<div class="ve-flex-v-center mr-auto statgen-rolled__wrp-results py-1"></div>`);
        const $wrpRolledOuter = $$`<div class="ve-flex-v-center"><div class="mr-2">=</div>${$wrpRolled}</div>`;

        const hkRolled = ()=>{
            $wrpRolledOuter.toggleVe(this._state.rolled_rolls.length);
            $btnRandom.toggleVe(this._state.rolled_rolls.length);

            $wrpRolled.html(this._state.rolled_rolls.map((it,i)=>{
                const cntPrevRolls = this._state.rolled_rolls.slice(0, i).filter(r=>r.total === it.total).length;
                return `<div class="px-3 py-1 help-subtle ve-flex-vh-center" title="${it.text}"><div class="ve-muted">[</div><div class="ve-flex-vh-center statgen-rolled__disp-result">${it.total}${cntPrevRolls ? Parser.numberToSubscript(cntPrevRolls) : ""}</div><div class="ve-muted">]</div></div>`;
            }
            ));
        }
        ;
        this._addHookBase("rolled_rolls", hkRolled);
        hkRolled();

        return $$`<div class="ve-flex-col mb-3 mr-auto">
			<div class="ve-flex mb-2">
				<div class="ve-flex-col ve-flex-h-center mr-3">
					<label class="ve-flex-v-center"><div class="mr-2 no-shrink w-100p">Formula:</div>${this._$rollIptFormula}</label>

					${this._isCharacterMode ? null : $$`<label class="ve-flex-v-center mt-2"><div class="mr-2 no-shrink w-100p">Number of rolls:</div>${$iptRollCount}</label>`}
				</div>
				${$btnRoll}
			</div>

			${$wrpRolledOuter}

			<div class="ve-flex-v-center">${$btnRandom}</div>
		</div>`;
    }

    _render_$getStgArrayHeader() {
        const $btnRandom = $(`<button class="btn btn-xs btn-default">Randomly Assign</button>`).click(()=>{
            const abs = [...Parser.ABIL_ABVS].shuffle();
            abs.forEach((ab,i)=>{
                const {propAbilSelectedScoreIx} = this.constructor._array_getProps(ab);
                this._state[propAbilSelectedScoreIx] = i;
            }
            );
        }
        );

        return $$`<div class="ve-flex-col mb-3 mr-auto">
			<div class="mb-2">Assign these numbers to your abilities as desired:</div>
			<div class="bold mb-2">${StatGenUi._STANDARD_ARRAY.join(", ")}</div>
			<div class="ve-flex">${$btnRandom}</div>
		</div>`;
    }

    _render_$getStgManualHeader() {
        return $$`<div class="ve-flex-col mb-3 mr-auto">
			<div>Enter your desired ability scores in the &quot;Base&quot; column below.</div>
		</div>`;
    }

    get ixActiveTab() {
        return this._getIxActiveTab();
    }
    set ixActiveTab(ix) {
        this._setIxActiveTab({
            ixActiveTab: ix
        });
    }

    addHookPointBuyCustom(hook) {
        this.constructor._PROPS_POINT_BUY_CUSTOM.forEach(prop=>this._addHookBase(prop, hook));
    }

    addHookAbilityScores(hook) {
        Parser.ABIL_ABVS.forEach(ab=>this._addHookBase(`common_export_${ab}`, hook));
    }
    addHookPulseAsi(hook) {
        this._addHookBase("common_pulseAsi", hook);
    }
    getFormDataAsi() {
        return this._compAsi.getFormData();
    }

    getMode(ix, namespace) {
        const {propMode} = this.getPropsAsi(ix, namespace);
        return this._state[propMode];
    }

    setIxFeat(ix, namespace, ixFeat) {
        const {propMode, propIxFeat} = this.getPropsAsi(ix, namespace);

        if (ixFeat == null && (this._state[propMode] === "asi" || this._state[propMode] == null)) {
            this._state[propIxFeat] = null; return;
        }

        this._state[propMode] = "feat";
        this._state[propIxFeat] = ixFeat;
    }

    setIxFeatSet(namespace, ixSet) {
        const {propIxSel} = this.getPropsAdditionalFeats_(namespace);
        this._state[propIxSel] = ixSet;
    }

    setIxFeatSetIxFeats(namespace, metaFeats) {
        const nxtState = {};
        metaFeats.forEach(({ix, ixFeat})=>{
            const {propIxFeat} = this.getPropsAdditionalFeatsFeatSet_(namespace, "fromFilter", ix);
            nxtState[propIxFeat] = ixFeat;
        }
        );
        this._proxyAssignSimple("state", nxtState);
    }

    set common_cntAsi(val) {
        this._state.common_cntAsi = val;
    }

    addHookIxRace(hook) {
        this._addHookBase("common_ixRace", hook);
    }
    get ixRace() {
        return this._state.common_ixRace;
    }
    set ixRace(ixRace) {
        this._state.common_ixRace = ixRace;
    }

    addHookIxBackground(hook) {
        this._addHookBase("common_ixBackground", hook);
    }
    get ixBackground() {
        return this._state.common_ixBackground;
    }
    set ixBackground(ixBackground) {
        this._state.common_ixBackground = ixBackground;
    }

    addCustomFeat() {
        this._state.common_cntFeatsCustom = Math.min(StatGenUi._MAX_CUSTOM_FEATS, (this._state.common_cntFeatsCustom || 0) + 1);
    }
    setCntCustomFeats(val) {
        this._state.common_cntFeatsCustom = Math.min(StatGenUi._MAX_CUSTOM_FEATS, val || 0);
    }

    get isCharacterMode() {
        return this._isCharacterMode;
    }
    get state() {
        return this._state;
    }
    get modalFilterFeats() {
        return this._modalFilterFeats;
    }
    get feats() {
        return this._feats;
    }
    addHookBase(prop, hook) {
        return this._addHookBase(prop, hook);
    }
    removeHookBase(prop, hook) {
        return this._removeHookBase(prop, hook);
    }
    proxyAssignSimple(hookProp, toObj, isOverwrite) {
        return this._proxyAssignSimple(hookProp, toObj, isOverwrite);
    }
    get race() {
        return this._races[this._state.common_ixRace];
    }
    get background() {
        return this._backgrounds[this._state.common_ixBackground];
    }
    get isLevelUp() {
        return this._isLevelUp;
    }

    getTotals() {
        if (this._isLevelUp) {
            return {
                mode: "levelUp",
                totals: {
                    levelUp: this._getTotals_levelUp(),
                },
            };
        }

        return {
            mode: this._MODES[this.ixActiveTab || 0],
            totals: {
                rolled: this._getTotals_rolled(),
                array: this._getTotals_array(),
                pointbuy: this._getTotals_pb(),
                manual: this._getTotals_manual(),
            },
        };
    }

    _getTotals_rolled() {
        return Parser.ABIL_ABVS.mergeMap(ab=>({
            [ab]: this._rolled_getTotalScore(ab)
        }));
    }
    _getTotals_array() {
        return Parser.ABIL_ABVS.mergeMap(ab=>({
            [ab]: this._array_getTotalScore(ab)
        }));
    }
    _getTotals_pb() {
        return Parser.ABIL_ABVS.mergeMap(ab=>({
            [ab]: this._pb_getTotalScore(ab)
        }));
    }
    _getTotals_manual() {
        return Parser.ABIL_ABVS.mergeMap(ab=>({
            [ab]: this._manual_getTotalScore(ab)
        }));
    }
    _getTotals_levelUp() {
        return Parser.ABIL_ABVS.mergeMap(ab=>({
            [ab]: this._levelUp_getTotalScore(ab)
        }));
    }

    addHook(hookProp, prop, hook) {
        return this._addHook(hookProp, prop, hook);
    }
    addHookAll(hookProp, hook) {
        this._addHookAll(hookProp, hook);
        this._compAsi._addHookAll(hookProp, hook);
    }

    addHookActiveTag(hook) {
        this._addHookActiveTab(hook);
    }

    async pInit() {
        await this._modalFilterRaces.pPreloadHidden();
        await this._modalFilterBackgrounds.pPreloadHidden();
        await this._modalFilterFeats.pPreloadHidden();
    }

    getPropsAsi(ix, namespace) {
        return {
            prefix: `common_asi_${namespace}_${ix}_`,
            propMode: `common_asi_${namespace}_${ix}_mode`,
            propIxAsiPointOne: `common_asi_${namespace}_${ix}_asiPointOne`,
            propIxAsiPointTwo: `common_asi_${namespace}_${ix}_asiPointTwo`,
            propIxFeat: `common_asi_${namespace}_${ix}_ixFeat`,
            propIxFeatAbility: `common_asi_${namespace}_${ix}_ixFeatAbility`,
            propFeatAbilityChooseFrom: `common_asi_${namespace}_${ix}_featAbilityChooseFrom`,
        };
    }

    getPropsAdditionalFeats_(namespace) {
        return {
            propPrefix: `common_additionalFeats_${namespace}_`,
            propIxSel: `common_additionalFeats_${namespace}_ixSel`,
        };
    }

    getPropsAdditionalFeatsFeatSet_(namespace, type, ix) {
        return {
            propIxFeat: `common_additionalFeats_${namespace}_${type}_${ix}_ixFeat`,
            propIxFeatAbility: `common_additionalFeats_${namespace}_${type}_${ix}_ixFeatAbility`,
            propFeatAbilityChooseFrom: `common_additionalFeats_${namespace}_${type}_${ix}_featAbilityChooseFrom`,
        };
    }

    _roll_getRolledStats() {
        const wrpTree = Renderer.dice.lang.getTree3(this._state.rolled_formula);
        if (!wrpTree)
            return this._$rollIptFormula.addClass("form-control--error");

        const rolls = [];
        for (let i = 0; i < this._state.rolled_rollCount; i++) {
            const meta = {};
            meta.total = wrpTree.tree.evl(meta);
            rolls.push(meta);
        }
        rolls.sort((a,b)=>SortUtil.ascSort(b.total, a.total));

        return rolls.map(r=>({
            total: r.total,
            text: (r.text || []).join("")
        }));
    }

    _doReset() {
        if (this._isLevelUp)
            return;
        const nxtState = this._getDefaultStateCommonResettable();

        switch (this.ixActiveTab) {
        case this._IX_TAB_NONE:
            Object.assign(nxtState, this._getDefaultStateNoneResettable());
            break;
        case this._IX_TAB_ROLLED:
            Object.assign(nxtState, this._getDefaultStateRolledResettable());
            break;
        case this._IX_TAB_ARRAY:
            Object.assign(nxtState, this._getDefaultStateArrayResettable());
            break;
        case this._IX_TAB_PB:
            Object.assign(nxtState, this._getDefaultStatePointBuyResettable());
            break;
        case this._IX_TAB_MANUAL:
            Object.assign(nxtState, this._getDefaultStateManualResettable());
            break;
        }

        this._proxyAssignSimple("state", nxtState);
    }

    doResetAll() {
        this._proxyAssignSimple("state", this._getDefaultState(), true);
    }

    _render_$getStgPbHeader() {
        const $iptBudget = ComponentUiUtil.$getIptInt(this, "pb_budget", 0, {
            html: `<input type="text" class="form-control statgen-pb__ipt-budget ve-text-center statgen-shared__ipt">`,
            min: 0,
            fallbackOnNaN: 0,
        }, );
        const hkIsCustom = ()=>{
            $iptBudget.attr("readonly", !this._state.pb_isCustom);
        }
        ;
        this._addHookBase("pb_isCustom", hkIsCustom);
        hkIsCustom();

        const $iptRemaining = ComponentUiUtil.$getIptInt(this, "pb_points", 0, {
            html: `<input type="text" class="form-control statgen-pb__ipt-budget ve-text-center statgen-shared__ipt">`,
            min: 0,
            fallbackOnNaN: 0,
        }, ).attr("readonly", true);

        const hkPoints = ()=>{
            this._state.pb_points = this._pb_getPointsRemaining(this._state);
            $iptRemaining.toggleClass(`statgen-pb__ipt-budget--error`, this._state.pb_points < 0);
        }
        ;
        this._addHookAll("state", hkPoints);
        hkPoints();

        const $btnReset = $(`<button class="btn btn-default">Reset</button>`).click(()=>this._doReset());

        const $btnRandom = $(`<button class="btn btn-default">Random</button>`).click(()=>{
            this._doReset();

            let canIncrease = Parser.ABIL_ABVS.map(it=>`pb_${it}`);
            const cpyBaseState = canIncrease.mergeMap(it=>({
                [it]: this._state[it]
            }));
            const cntRemaining = this._pb_getPointsRemaining(cpyBaseState);
            if (cntRemaining <= 0)
                return;

            for (let step = 0; step < 10000; ++step) {
                if (!canIncrease.length)
                    break;

                const prop = RollerUtil.rollOnArray(canIncrease);
                if (!this._state.pb_rules.some(rule=>rule.entity.score === cpyBaseState[prop] + 1)) {
                    canIncrease = canIncrease.filter(it=>it !== prop);
                    continue;
                }

                const draftCpyBaseState = MiscUtil.copy(cpyBaseState);
                draftCpyBaseState[prop]++;

                const cntRemaining = this._pb_getPointsRemaining(draftCpyBaseState);

                if (cntRemaining > 0) {
                    Object.assign(cpyBaseState, draftCpyBaseState);
                } else if (cntRemaining === 0) {
                    this._proxyAssignSimple("state", draftCpyBaseState);
                    break;
                } else {
                    canIncrease = canIncrease.filter(it=>it !== prop);
                }
            }
        }
        );

        return $$`<div class="ve-flex mobile__ve-flex-col mb-2">
			<div class="ve-flex-v-center">
				<div class="statgen-pb__cell mr-4 mobile__hidden"></div>

				<label class="ve-flex-col mr-2">
					<div class="mb-1 ve-text-center">Budget</div>
					${$iptBudget}
				</label>

				<label class="ve-flex-col mr-2">
					<div class="mb-1 ve-text-center">Remain</div>
					${$iptRemaining}
				</label>
			</div>

			<div class="ve-flex-v-center mobile__mt-2">
				<div class="ve-flex-col mr-2">
					<div class="mb-1 ve-text-center mobile__hidden">&nbsp;</div>
					${$btnReset}
				</div>

				<div class="ve-flex-col">
					<div class="mb-1 ve-text-center mobile__hidden">&nbsp;</div>
					${$btnRandom}
				</div>
			</div>
		</div>`;
    }

    _render_$getStgPbCustom() {
        const $btnAddLower = $(`<button class="btn btn-default btn-xs">Add Lower Score</button>`).click(()=>{
            const prevLowest = this._state.pb_rules[0];
            const score = prevLowest.entity.score - 1;
            const cost = prevLowest.entity.cost;
            this._state.pb_rules = [this._getDefaultState_pb_rule(score, cost), ...this._state.pb_rules];
        }
        );

        const $btnAddHigher = $(`<button class="btn btn-default btn-xs">Add Higher Score</button>`).click(()=>{
            const prevHighest = this._state.pb_rules.last();
            const score = prevHighest.entity.score + 1;
            const cost = prevHighest.entity.cost;
            this._state.pb_rules = [...this._state.pb_rules, this._getDefaultState_pb_rule(score, cost)];
        }
        );

        const $btnResetRules = $(`<button class="btn btn-danger btn-xs mr-2">Reset</button>`).click(()=>{
            this._state.pb_rules = this._getDefaultStatePointBuyCosts().pb_rules;
        }
        );

        const menuCustom = ContextUtil.getMenu([new ContextUtil.Action("Export as Code",async()=>{
            await MiscUtil.pCopyTextToClipboard(this._serialize_pb_rules());
            JqueryUtil.showCopiedEffect($btnContext);
        }
        ,), new ContextUtil.Action("Import from Code",async()=>{
            const raw = await InputUiUtil.pGetUserString({
                title: "Enter Code",
                isCode: true
            });
            if (raw == null)
                return;
            const parsed = this._deserialize_pb_rules(raw);
            if (parsed == null)
                return;

            const {pb_rules, pb_budget} = parsed;
            this._proxyAssignSimple("state", {
                pb_rules,
                pb_budget,
                pb_isCustom: true,
            }, );
            JqueryUtil.doToast("Imported!");
        }
        ,), ]);

        const $btnContext = $(`<button class="btn btn-default btn-xs" title="Menu"><span class="glyphicon glyphicon-option-vertical"></span></button>`).click(evt=>ContextUtil.pOpenMenu(evt, menuCustom));

        const $stgCustomCostControls = $$`<div class="ve-flex-col mb-auto ml-2 mobile__ml-0 mobile__mt-3">
			<div class="btn-group-vertical ve-flex-col mb-2">${$btnAddLower}${$btnAddHigher}</div>
			<div class="ve-flex-v-center">
				${$btnResetRules}
				${$btnContext}
			</div>
		</div>`;

        const $stgCostRows = $$`<div class="ve-flex-col"></div>`;

        const renderableCollectionRules = new StatGenUi.RenderableCollectionPbRules(this,$stgCostRows,);
        const hkRules = ()=>{
            renderableCollectionRules.render();

            const {min: minScore, max: maxScore} = this._pb_getMinMaxScores();
            Parser.ABIL_ABVS.forEach(it=>{
                const prop = `pb_${it}`;
                this._state[prop] = Math.min(maxScore, Math.max(minScore, this._state[prop]));
            }
            );
        };
        this._addHookBase("pb_rules", hkRules);
        hkRules();

        let lastIsCustom = this._state.pb_isCustom;
        const hkIsCustomReset = ()=>{
            $stgCustomCostControls.toggleVe(this._state.pb_isCustom);

            if (lastIsCustom === this._state.pb_isCustom)
                return;
            lastIsCustom = this._state.pb_isCustom;

            if (!this._state.pb_isCustom)
                this._state.pb_rules = this._getDefaultStatePointBuyCosts().pb_rules;
        }
        ;
        this._addHookBase("pb_isCustom", hkIsCustomReset);
        hkIsCustomReset();

        return $$`<div class="ve-flex-col">
			<h4>Ability Score Point Cost</h4>

			<div class="ve-flex-col">
				<div class="ve-flex mobile__ve-flex-col">
					<div class="ve-flex-col mr-3mobile__mr-0">
						<div class="ve-flex-v-center mb-1">
							<div class="statgen-pb__col-cost ve-flex-vh-center bold">Score</div>
							<div class="statgen-pb__col-cost ve-flex-vh-center bold">Modifier</div>
							<div class="statgen-pb__col-cost ve-flex-vh-center bold">Point Cost</div>
							<div class="statgen-pb__col-cost-delete"></div>
						</div>

						${$stgCostRows}
					</div>

					${$stgCustomCostControls}
				</div>
			</div>

			<hr class="hr-4 mb-2">

			<label class="ve-flex-v-center">
				<div class="mr-2">Custom Rules</div>
				${ComponentUiUtil.$getCbBool(this, "pb_isCustom")}
			</label>
		</div>`;
    }

    _serialize_pb_rules() {
        const out = [this._state.pb_budget, ...MiscUtil.copyFast(this._state.pb_rules).map(it=>[it.entity.score, it.entity.cost]), ];
        return JSON.stringify(out);
    }

    static _DESERIALIZE_MSG_INVALID = "Code was not valid!";

    _deserialize_pb_rules(raw) {
        let json;
        try {
            json = JSON.parse(raw);
        } catch (e) {
            JqueryUtil.doToast({
                type: "danger",
                content: `Failed to decode JSON! ${e.message}`
            });
            return null;
        }

        if (!(json instanceof Array))
            return void JqueryUtil.doToast({
                type: "danger",
                content: this.constructor._DESERIALIZE_MSG_INVALID
            });

        const [budget,...rules] = json;

        if (isNaN(budget))
            return void JqueryUtil.doToast({
                type: "danger",
                content: this.constructor._DESERIALIZE_MSG_INVALID
            });

        if (!rules.every(it=>it instanceof Array && it[0] != null && !isNaN(it[0]) && it[1] != null && !isNaN(it[1])))
            return void JqueryUtil.doToast({
                type: "danger",
                content: this.constructor._DESERIALIZE_MSG_INVALID
            });

        return {
            pb_budget: budget,
            pb_rules: rules.map(it=>this._getDefaultState_pb_rule(it[0], it[1])),
        };
    }

    

    static _RenderLevelOneEntity = class {
        _title;
        _titleShort;
        _propIxEntity;
        _propIxAbilityScoreSet;
        _propData;
        _propModalFilter;
        _propIsPreview;
        _propEntity;
        _page;
        _propChoiceMetasFrom;
        _propChoiceWeighted;

        constructor({parent}) {
            this._parent = parent;

            this._pbHookMetas = [];
        }

        render() {
            const $wrp = $(`<div class="ve-flex"></div>`);
            const $wrpOuter = $$`<div class="ve-flex-col">
				<div class="my-1 statgen-pb__header statgen-pb__header--group mr-3 ve-text-center italic ve-small help-subtle" title="Ability Score Changes from ${this._title}">${this._titleShort}</div>

				${$wrp}
			</div>`;

            this._parent._addHookBase(this._propIxEntity, ()=>this._parent.__state[this._propIxAbilityScoreSet] = 0);

            const hkIxEntity = (prop)=>{
                this._pb_unhookRender();
                const isInitialLoad = prop == null;
                if (!isInitialLoad)
                    this._parent._state[this._propChoiceMetasFrom] = [];
                if (!isInitialLoad)
                    this._parent._state[this._propChoiceWeighted] = [];
                const isAnyFromEntity = this._render_pointBuy($wrp);
                $wrpOuter.toggleVe(isAnyFromEntity);
            };

            this._parent._addHookBase(this._propIxEntity, hkIxEntity);
            this._bindAdditionalHooks_hkIxEntity(hkIxEntity);
            this._parent._addHookBase(this._propIxAbilityScoreSet, hkIxEntity);
            hkIxEntity();

            //Try to get races here
            const {$wrp: $selEntity, fnUpdateHidden: fnUpdateSelEntityHidden} = ComponentUiUtil.$getSelSearchable(this._parent, this._propIxEntity, {
                values: this._parent[this._propData].map((_,i)=>i),
                isAllowNull: true,
                fnDisplay: ix=>{
                    const r = this._parent[this._propData][ix];
                    if (!r){return "(Unknown)";}
                    return `${r.name} ${r.source !== Parser.SRC_PHB ? `[${Parser.sourceJsonToAbv(r.source)}]` : ""}`;
                }
                ,
                asMeta: true,
            }, );

            const doApplyFilterToSelEntity = ()=>{
                const f = this._parent[this._propModalFilter].pageFilter.filterBox.getValues();
                const isHiddenPerEntity = this._parent[this._propData].map(it=>!this._parent[this._propModalFilter].pageFilter.toDisplay(f, it));
                fnUpdateSelEntityHidden(isHiddenPerEntity, false);
            };

            //TEMPFIX
            if(SETTINGS.FILTERS){this._parent[this._propModalFilter].pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, ()=>doApplyFilterToSelEntity());
            doApplyFilterToSelEntity();}

            const $btnFilterForEntity = $(`<button class="btn btn-xs btn-default br-0 pr-2" title="Filter for ${this._title}"><span class="glyphicon glyphicon-filter"></span> Filter</button>`).click(async()=>{
                const selected = await this._parent[this._propModalFilter].pGetUserSelection();
                if (selected == null || !selected.length)
                    return;

                const selectedEntity = selected[0];
                const ixEntity = this._parent[this._propData].findIndex(it=>it.name === selectedEntity.name && it.source === selectedEntity.values.sourceJson);
                if (!~ixEntity)
                    throw new Error(`Could not find selected ${this._title.toLowerCase()}: ${JSON.stringify(selectedEntity)}`);
                this._parent._state[this._propIxEntity] = ixEntity;
            }
            );

            const $btnPreview = ComponentUiUtil.$getBtnBool(this._parent, this._propIsPreview, {
                html: `<button class="btn btn-xs btn-default" title="Toggle ${this._title} Preview"><span class="glyphicon glyphicon-eye-open"></span></button>`,
            }, );
            const hkBtnPreviewEntity = ()=>$btnPreview.toggleVe(this._parent._state[this._propIxEntity] != null && ~this._parent._state[this._propIxEntity]);
            this._parent._addHookBase(this._propIxEntity, hkBtnPreviewEntity);
            hkBtnPreviewEntity();

            const {$sel: $selAbilitySet, setValues: setValuesSelAbilitySet} = ComponentUiUtil.$getSelEnum(this._parent, this._propIxAbilityScoreSet, {
                values: [],
                asMeta: true,
                fnDisplay: ixAbSet=>{
                    const lst = this._pb_getAbilityList();
                    if (!lst?.[ixAbSet])
                        return "(Unknown)";
                    return Renderer.getAbilityData([lst[ixAbSet]]).asText;
                }
                ,
            }, );

            const $stgAbilityScoreSet = $$`<div class="ve-flex-v-center mb-2">
				<div class="mr-2">Ability Score Increase</div>
				<div>${$selAbilitySet}</div>
			</div>`;

            const hkSetValuesSelAbilitySet = ()=>{
                const entity = this._parent[this._propEntity];
                $stgAbilityScoreSet.toggleVe(!!entity && entity.ability?.length > 1);
                setValuesSelAbilitySet([...new Array(entity?.ability?.length || 0)].map((_,ix)=>ix), {
                    isForce: true
                }, );
            };

            this._parent._addHookBase(this._propIxEntity, hkSetValuesSelAbilitySet);
            this._bindAdditionalHooks_hkSetValuesSelAbilitySet(hkSetValuesSelAbilitySet);
            hkSetValuesSelAbilitySet();

            const $dispPreview = $(`<div class="ve-flex-col mb-2"></div>`);
            const hkPreviewEntity = ()=>{
                if (!this._parent._state[this._propIsPreview])
                    return $dispPreview.hideVe();

                const entity = this._parent._state[this._propIxEntity] != null ? this._parent[this._propData][this._parent._state[this._propIxEntity]] : null;
                if (!entity)
                    return $dispPreview.hideVe();

                $dispPreview.empty().showVe().append(Renderer.hover.$getHoverContent_stats(this._page, entity));
            };
            this._parent._addHookBase(this._propIxEntity, hkPreviewEntity);
            this._parent._addHookBase(this._propIsPreview, hkPreviewEntity);
            hkPreviewEntity();

            const {$hrPreview} = this._getHrPreviewMeta();

            const $stgSel = $$`<div class="ve-flex-col mt-3">
				<div class="mb-1">Select a ${this._title}</div>
				<div class="ve-flex-v-center mb-2">
					<div class="ve-flex-v-center btn-group w-100 mr-2">${$btnFilterForEntity}${$selEntity}</div>
					<div>${$btnPreview}</div>
				</div>
				${$stgAbilityScoreSet}
			</div>`;

            return {
                $wrpOuter,

                $stgSel,

                $dispPreview,
                $hrPreview,
            };
        }

        _pb_unhookRender() {
            this._pbHookMetas.forEach(it=>it.unhook());
            this._pbHookMetas = [];
        }

        _render_pointBuy($wrp) {
            $wrp.empty();

            const fromEntity = this._pb_getAbility();
            if (fromEntity == null)
                return false;

            let $ptBase = null;
            if (Parser.ABIL_ABVS.some(it=>fromEntity[it])) {
                const $wrpsEntity = Parser.ABIL_ABVS.map(ab=>{
                    return $$`<div class="my-1 statgen-pb__cell">
						<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number" readonly value="${fromEntity[ab] || 0}">
					</div>`;
                }
                );

                $ptBase = $$`<div class="ve-flex-col mr-3">
					<div class="my-1 statgen-pb__header ve-flex-vh-center">Static</div>
					${$wrpsEntity}
				</div>`;
            }

            let $ptChooseFrom = null;
            if (fromEntity.choose && fromEntity.choose.from) {
                const amount = fromEntity.choose.amount || 1;
                const count = fromEntity.choose.count || 1;

                const $wrpsChoose = Parser.ABIL_ABVS.map(ab=>{
                    if (!fromEntity.choose.from.includes(ab))
                        return `<div class="my-1 statgen-pb__cell"></div>`;

                    const $cb = $(`<input type="checkbox">`).change(()=>{
                        const existing = this._parent._state[this._propChoiceMetasFrom].find(it=>it.ability === ab);
                        if (existing) {
                            this._parent._state[this._propChoiceMetasFrom] = this._parent._state[this._propChoiceMetasFrom].filter(it=>it !== existing);
                            return;
                        }

                        if (this._parent._state[this._propChoiceMetasFrom].length >= count) {
                            while (this._parent._state[this._propChoiceMetasFrom].length >= count)
                                this._parent._state[this._propChoiceMetasFrom].shift();
                            this._parent._state[this._propChoiceMetasFrom] = [...this._parent._state[this._propChoiceMetasFrom]];
                        }

                        this._parent._state[this._propChoiceMetasFrom] = [...this._parent._state[this._propChoiceMetasFrom], {
                            ability: ab,
                            amount
                        }, ];
                    }
                    );

                    const hk = ()=>$cb.prop("checked", this._parent._state[this._propChoiceMetasFrom].some(it=>it.ability === ab));
                    this._parent._addHookBase(this._propChoiceMetasFrom, hk);
                    this._pbHookMetas.push({
                        unhook: ()=>this._parent._removeHookBase(this._propChoiceMetasFrom, hk)
                    });
                    hk();

                    return $$`<label class="my-1 statgen-pb__cell ve-flex-vh-center">${$cb}</label>`;
                }
                );

                $ptChooseFrom = $$`<div class="ve-flex-col mr-3">
					<div class="my-1 statgen-pb__header statgen-pb__header--choose-from ve-flex-vh-center">
						<div class="${count !== 1 ? `mr-1` : ""}">${UiUtil.intToBonus(amount, {
                    isPretty: true
                })}</div>${count !== 1 ? `<div class="ve-small ve-muted">(x${count})</div>` : ""}
					</div>
					${$wrpsChoose}
				</div>`;
            }

            let $ptsChooseWeighted = null;
            if (fromEntity.choose && fromEntity.choose.weighted && fromEntity.choose.weighted.weights) {
                $ptsChooseWeighted = fromEntity.choose.weighted.weights.map((weight,ixWeight)=>{
                    const $wrpsChoose = Parser.ABIL_ABVS.map(ab=>{
                        if (!fromEntity.choose.weighted.from.includes(ab))
                            return `<div class="my-1 statgen-pb__cell"></div>`;

                        const $cb = $(`<input type="checkbox">`).change(()=>{
                            const existing = this._parent._state[this._propChoiceWeighted].find(it=>it.ability === ab && it.ix === ixWeight);
                            if (existing) {
                                this._parent._state[this._propChoiceWeighted] = this._parent._state[this._propChoiceWeighted].filter(it=>it !== existing);
                                return;
                            }

                            const withSameAbil = this._parent._state[this._propChoiceWeighted].filter(it=>it.ability === ab || it.ix === ixWeight);
                            if (withSameAbil.length) {
                                this._parent._state[this._propChoiceWeighted] = this._parent._state[this._propChoiceWeighted].filter(it=>it.ability !== ab && it.ix !== ixWeight);
                            }

                            this._parent._state[this._propChoiceWeighted] = [...this._parent._state[this._propChoiceWeighted], {
                                ability: ab,
                                amount: weight,
                                ix: ixWeight
                            }, ];
                        }
                        );

                        const hk = ()=>{
                            $cb.prop("checked", this._parent._state[this._propChoiceWeighted].some(it=>it.ability === ab && it.ix === ixWeight));
                        }
                        ;
                        this._parent._addHookBase(this._propChoiceWeighted, hk);
                        this._pbHookMetas.push({
                            unhook: ()=>this._parent._removeHookBase(this._propChoiceWeighted, hk)
                        });
                        hk();

                        return $$`<label class="my-1 statgen-pb__cell ve-flex-vh-center">${$cb}</label>`;
                    }
                    );

                    return $$`<div class="ve-flex-col mr-3">
						<div class="my-1 statgen-pb__header statgen-pb__header--choose-from ve-flex-vh-center">${UiUtil.intToBonus(weight, {
                        isPretty: true
                    })}</div>
						${$wrpsChoose}
					</div>`;
                }
                );
            }

            $$($wrp)`
				${$ptBase}
				${$ptChooseFrom}
				${$ptsChooseWeighted}
			`;

            return $ptBase || $ptChooseFrom || $ptsChooseWeighted;
        }

        _pb_getAbilityList() {
            throw new Error("Unimplemented!");
        }

        _pb_getAbility() {
            throw new Error("Unimplemented!");
        }

        _bindAdditionalHooks_hkIxEntity(hkIxEntity) {}
        _bindAdditionalHooks_hkSetValuesSelAbilitySet(hkSetValuesSelAbilitySet) {}

        _getHrPreviewMeta() {
            const $hrPreview = $(`<hr class="hr-3">`);
            const hkPreview = this._getHkPreview({
                $hrPreview
            });
            this._parent._addHookBase(this._propIsPreview, hkPreview);
            hkPreview();

            return {
                $hrPreview,
                hkPreview,
            };
        }

        _getHkPreview({$hrPreview}) {
            return ()=>$hrPreview.toggleVe(this._parent._state[this._propIsPreview]);
        }
    };

    static _RenderLevelOneRace = class extends this._RenderLevelOneEntity {
        _title = "Race";
        _titleShort = "Race";
        _propIxEntity = "common_ixRace";
        _propIxAbilityScoreSet = "common_ixAbilityScoreSetRace";
        _propData = "_races";
        _propModalFilter = "_modalFilterRaces";
        _propIsPreview = "common_isPreviewRace";
        _propEntity = "race";
        _page = UrlUtil.PG_RACES;
        _propChoiceMetasFrom = "common_raceChoiceMetasFrom";
        _propChoiceWeighted = "common_raceChoiceMetasWeighted";

        render() {
            const out = super.render();

            const {$btnToggleTashasPin, $dispTashas} = this._$getPtsTashas();

            out.$stgSel.append($$`<label class="ve-flex-v-center mb-1">
				<div class="mr-2">Allow Origin Customization</div>
				${ComponentUiUtil.$getCbBool(this._parent, "common_isTashas")}
			</label>`);

            out.$stgSel.append($$`<div class="ve-flex">
				<div class="ve-small ve-muted italic mr-1">${Renderer.get().render(`An {@variantrule Customizing Your Origin|TCE|optional rule}`)}</div>
				${$btnToggleTashasPin}
				<div class="ve-small ve-muted italic ml-1">${Renderer.get().render(`from Tasha's Cauldron of Everything, page 8.`)}</div>
			</div>`);

            out.$dispTashas = $dispTashas;

            return out;
        }

        _pb_getAbilityList() { return this._parent._pb_getRaceAbilityList(); }

        _pb_getAbility() {
            return this._parent._pb_getRaceAbility();
        }

        _bindAdditionalHooks_hkIxEntity(hkIxEntity) {
            this._parent._addHookBase("common_isTashas", hkIxEntity);
        }

        _bindAdditionalHooks_hkSetValuesSelAbilitySet(hkSetValuesSelAbilitySet) {
            this._parent._addHookBase("common_isTashas", hkSetValuesSelAbilitySet);
        }

        _getHrPreviewMeta() {
            const out = super._getHrPreviewMeta();
            const {hkPreview} = out;
            this._parent._addHookBase("common_isShowTashasRules", hkPreview);
            return out;
        }

        _getHkPreview({$hrPreview}) {
            return ()=>$hrPreview.toggleVe(this._parent._state[this._propIsPreview] && this._parent._state.common_isShowTashasRules);
        }

        _$getPtsTashas() {
            const $btnToggleTashasPin = ComponentUiUtil.$getBtnBool(this._parent, "common_isShowTashasRules", {
                html: `<button class="btn btn-xxs btn-default ve-small p-0 statgen-shared__btn-toggle-tashas-rules ve-flex-vh-center" title="Toggle &quot;Customizing Your Origin&quot; Section">
                <span class="glyphicon glyphicon-eye-open"></span></button>`,
            }, );

            const $dispTashas = $(`<div class="ve-flex-col"><div class="italic ve-muted">Loading...</div></div>`);


            DataLoader.pCacheAndGet(UrlUtil.PG_VARIANTRULES, Parser.SRC_TCE, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES]({
                name: "Customizing Your Origin",
                source: Parser.SRC_TCE
            })).then(rule=>{
                $$($dispTashas.empty())`${Renderer.hover.$getHoverContent_stats(UrlUtil.PG_VARIANTRULES, rule)}<hr class="hr-3">`;
            });

            const hkIsShowTashas = ()=>{ $dispTashas.toggleVe(this._parent._state.common_isShowTashasRules); };
            this._parent._addHookBase("common_isShowTashasRules", hkIsShowTashas);
            hkIsShowTashas();

            return { $btnToggleTashasPin, $dispTashas, };
        }
    };

    _renderLevelOneRace = new this.constructor._RenderLevelOneRace({ parent: this });

    static _RenderLevelOneBackground = class extends this._RenderLevelOneEntity {
        _title = "Background";
        _titleShort = "Backg.";
        _propIxEntity = "common_ixBackground";
        _propIxAbilityScoreSet = "common_ixAbilityScoreSetBackground";
        _propData = "_backgrounds";
        _propModalFilter = "_modalFilterBackgrounds";
        _propIsPreview = "common_isPreviewBackground";
        _propEntity = "background";
        _page = UrlUtil.PG_BACKGROUNDS;
        _propChoiceMetasFrom = "common_backgroundChoiceMetasFrom";
        _propChoiceWeighted = "common_backgroundChoiceMetasWeighted";

        _pb_getAbilityList() {
            return this._parent._pb_getBackgroundAbilityList();
        }

        _pb_getAbility() {
            return this._parent._pb_getBackgroundAbility();
        }
    };

    _renderLevelOneBackground = new this.constructor._RenderLevelOneBackground({
        parent: this
    });

    _render_isLevelUp($wrpTab) {
        const $wrpsExisting = Parser.ABIL_ABVS.map(ab=>{
            const $iptExisting = $(`<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number" readonly>`).val(this._existingScores[ab]);

            return $$`<label class="my-1 statgen-pb__cell">
				${$iptExisting}
			</label>`;
        }
        );

        const $wrpsUser = this._render_$getWrpsUser();

        const metasTotalAndMod = this._render_getMetasTotalAndMod();

        const $wrpAsi = this._render_$getWrpAsi();

        $$($wrpTab)`
			<div class="ve-flex mobile-ish__ve-flex-col w-100 px-3">
				<div class="ve-flex-col">
					<div class="ve-flex">
						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>

							${Parser.ABIL_ABVS.map(it=>`<div class="my-1 bold statgen-pb__cell ve-flex-v-center ve-flex-h-right" title="${Parser.attAbvToFull(it)}">${it.toUpperCase()}</div>`)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 bold statgen-pb__header ve-flex-vh-center" title="Current">Curr.</div>
							${$wrpsExisting}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header ve-flex-vh-center help text-muted" title="Input any additional/custom bonuses here">User</div>
							${$wrpsUser}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header ve-flex-vh-center">Total</div>
							${metasTotalAndMod.map(it=>it.$wrpIptTotal)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header ve-flex-vh-center" title="Modifier">Mod.</div>
							${metasTotalAndMod.map(it=>it.$wrpIptMod)}
						</div>
					</div>
				</div>
			</div>

			<hr class="hr-3">

			${$wrpAsi}
		`;
    }

    _render_$getWrpsUser() {
        return Parser.ABIL_ABVS.map(ab=>{
            const {propUserBonus} = this.constructor._common_getProps(ab);
            const $ipt = ComponentUiUtil.$getIptInt(this, propUserBonus, 0, {
                fallbackOnNaN: 0,
                html: `<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number">`,
            }, );
            return $$`<label class="my-1 statgen-pb__cell">${$ipt}</label>`;
        }
        );
    }

    _render_getMetasTotalAndMod() {
        return Parser.ABIL_ABVS.map(ab=>{
            const $iptTotal = $(`<input class="form-control form-control--minimal statgen-shared__ipt ve-text-center" type="text" readonly>`);
            const $iptMod = $(`<input class="form-control form-control--minimal statgen-shared__ipt ve-text-center" type="text" readonly>`);

            const $wrpIptTotal = $$`<label class="my-1 statgen-pb__cell">${$iptTotal}</label>`;
            const $wrpIptMod = $$`<label class="my-1 statgen-pb__cell">${$iptMod}</label>`;

            const exportedStateProp = `common_export_${ab}`;

            const getTotalScore = ()=>{
                if (this._isLevelUp)
                    return this._levelUp_getTotalScore(ab);
                switch (this.ixActiveTab) {
                case this._IX_TAB_ROLLED:
                    return this._rolled_getTotalScore(ab);
                case this._IX_TAB_ARRAY:
                    return this._array_getTotalScore(ab);
                case this._IX_TAB_PB:
                    return this._pb_getTotalScore(ab);
                case this._IX_TAB_MANUAL:
                    return this._manual_getTotalScore(ab);
                default:
                    return 0;
                }
            }
            ;

            const hk = ()=>{
                const totalScore = getTotalScore();

                const isOverLimit = totalScore > 20;
                $iptTotal.val(totalScore).toggleClass("form-control--error", isOverLimit).title(isOverLimit ? `In general, you can't increase an ability score above 20.` : "");
                $iptMod.val(Parser.getAbilityModifier(totalScore));

                this._state[exportedStateProp] = totalScore;
            };

            this._addHookAll("state", hk);
            this._addHookActiveTab(hk);
            hk();

            return { $wrpIptTotal, $wrpIptMod, };
        });
    }

    _render_$getWrpAsi() {
        const $wrpAsi = $(`<div class="ve-flex-col w-100"></div>`);
        this._compAsi.render($wrpAsi);
        return $wrpAsi;
    }

    static _common_getProps(ab) {
        return {
            propUserBonus: `${StatGenUi._PROP_PREFIX_COMMON}${ab}_user`,
        };
    }

    static _rolled_getProps(ab) {
        return {
            propAbilSelectedRollIx: `${StatGenUi._PROP_PREFIX_ROLLED}${ab}_abilSelectedRollIx`,
        };
    }

    static _array_getProps(ab) {
        return {
            propAbilSelectedScoreIx: `${StatGenUi._PROP_PREFIX_ARRAY}${ab}_abilSelectedScoreIx`,
        };
    }

    static _manual_getProps(ab) {
        return {
            propAbilValue: `${StatGenUi._PROP_PREFIX_MANUAL}${ab}_abilValue`,
        };
    }

    _pb_getRaceAbilityList() {
        const race = this.race;
        if (!race?.ability?.length){return null;}

        return race.ability.map(fromRace=>{
            if (this._state.common_isTashas) {
                const weights = [];

                if (fromRace.choose && fromRace.choose.weighted && fromRace.choose.weighted.weights) {
                    weights.push(...fromRace.choose.weighted.weights);
                }

                Parser.ABIL_ABVS.forEach(it=>{
                    if (fromRace[it])
                        weights.push(fromRace[it]);
                }
                );

                if (fromRace.choose && fromRace.choose.from) {
                    const count = fromRace.choose.count || 1;
                    const amount = fromRace.choose.amount || 1;
                    for (let i = 0; i < count; ++i)
                        weights.push(amount);
                }

                weights.sort((a,b)=>SortUtil.ascSort(b, a));

                fromRace = {
                    choose: {
                        weighted: {
                            from: [...Parser.ABIL_ABVS],
                            weights,
                        },
                    },
                };
            }

            return fromRace;
        });
    }

    _pb_getBackgroundAbilityList() {
        const background = this.background;
        if (!background?.ability?.length)
            return null;
        return background.ability;
    }

    _pb_getRaceAbility() {
        return this._pb_getRaceAbilityList()?.[this._state.common_ixAbilityScoreSetRace || 0];
    }

    _pb_getBackgroundAbility() {
        return this._pb_getBackgroundAbilityList()?.[this._state.common_ixAbilityScoreSetBackground || 0];
    }

    _pb_getPointsRemaining(baseState) {
        const spent = Parser.ABIL_ABVS.map(it=>{
            const prop = `pb_${it}`;
            const score = baseState[prop];
            const rule = this._state.pb_rules.find(it=>it.entity.score === score);
            if (!rule)
                return 0;
            return rule.entity.cost;
        }
        ).reduce((a,b)=>a + b, 0);

        return this._state.pb_budget - spent;
    }

    _rolled_getTotalScore(ab) {
        const {propAbilSelectedRollIx} = this.constructor._rolled_getProps(ab);
        const {propUserBonus} = this.constructor._common_getProps(ab);
        return (this._state.rolled_rolls[this._state[propAbilSelectedRollIx]] || {
            total: 0
        }).total + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
    }

    _array_getTotalScore(ab) {
        const {propAbilSelectedScoreIx} = this.constructor._array_getProps(ab);
        const {propUserBonus} = this.constructor._common_getProps(ab);
        return (StatGenUi._STANDARD_ARRAY[this._state[propAbilSelectedScoreIx]] || 0) + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
    }

    _pb_getTotalScore(ab) {
        const prop = `pb_${ab}`;
        const {propUserBonus} = this.constructor._common_getProps(ab);
        return this._state[prop] + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
    }

    _manual_getTotalScore(ab) {
        const {propAbilValue} = this.constructor._manual_getProps(ab);
        const {propUserBonus} = this.constructor._common_getProps(ab);
        return (this._state[propAbilValue] || 0) + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
    }

    _levelUp_getTotalScore(ab) {
        const {propUserBonus} = this.constructor._common_getProps(ab);
        return (this._existingScores[ab] || 0) + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
    }

    _getTotalScore_getBonuses(ab) {
        let total = 0;

        if (!this._isLevelUp) {
            const handleEntityAbility = ({fromEntity, propChoiceMetasFrom, propChoiceWeighted})=>{
                if (fromEntity) {
                    if (fromEntity[ab])
                        total += fromEntity[ab];

                    if (fromEntity.choose && fromEntity.choose.from) {
                        total += this._state[propChoiceMetasFrom].filter(it=>it.ability === ab).map(it=>it.amount).reduce((a,b)=>a + b, 0);
                    }

                    if (fromEntity.choose && fromEntity.choose.weighted && fromEntity.choose.weighted.weights) {
                        total += this._state[propChoiceWeighted].filter(it=>it.ability === ab).map(it=>it.amount).reduce((a,b)=>a + b, 0);
                    }
                }
            }
            ;

            handleEntityAbility({
                fromEntity: this._pb_getRaceAbility(),
                propChoiceMetasFrom: "common_raceChoiceMetasFrom",
                propChoiceWeighted: "common_raceChoiceMetasWeighted",
            });

            handleEntityAbility({
                fromEntity: this._pb_getBackgroundAbility(),
                propChoiceMetasFrom: "common_backgroundChoiceMetasFrom",
                propChoiceWeighted: "common_backgroundChoiceMetasWeighted",
            });
        }

        const formDataAsi = this._compAsi.getFormData();
        if (formDataAsi)
            total += formDataAsi.data[ab] || 0;

        return total;
    }

    getSaveableState() {
        const out = super.getSaveableState();

        const handleEntity = ({propIxEntity, page, propData, propHash})=>{
            if (out[propIxEntity] != null && !~this._state[propIxEntity]) {
                out[propHash] = UrlUtil.URL_TO_HASH_BUILDER[page](this[propData][out[propIxEntity]]);
                delete out[propIxEntity];
            }
        }
        ;

        handleEntity({
            propIxEntity: "common_ixRace",
            page: UrlUtil.PG_RACES,
            propData: "_races",
            propHash: "_pb_raceHash",
        });

        handleEntity({
            propIxEntity: "common_ixBackground",
            page: UrlUtil.PG_BACKGROUNDS,
            propData: "_backgrounds",
            propHash: "_pb_backgroundHash",
        });

        return out;
    }

    getSaveableStatePointBuyCustom() {
        const base = this.getSaveableState();
        return {
            state: this.constructor._PROPS_POINT_BUY_CUSTOM.mergeMap(k=>({
                [k]: base.state[k]
            })),
        };
    }

    setStateFrom(saved, isOverwrite=false) {
        saved = MiscUtil.copy(saved);

        MiscUtil.getOrSet(saved, "state", {});

        const handleEntityHash = ({propHash, page, propData, propIxEntity})=>{
            if (!saved[propHash])
                return;

            const ixEntity = this[propData].findIndex(it=>{
                const hash = UrlUtil.URL_TO_HASH_BUILDER[page](it);
                return hash === saved[propHash];
            }
            );
            if (~ixEntity)
                saved[propIxEntity] = ixEntity;
        }
        ;

        handleEntityHash({
            propHash: "_pb_raceHash",
            page: UrlUtil.PG_RACES,
            propData: "_races",
            propIxEntity: "common_ixRace",
        });

        handleEntityHash({
            propHash: "_pb_backgroundHash",
            page: UrlUtil.PG_BACKGROUNDS,
            propData: "_backgrounds",
            propIxEntity: "common_ixBackground",
        });

        const validKeys = new Set(Object.keys(this._getDefaultState()));
        const validKeyPrefixes = [StatGenUi._PROP_PREFIX_COMMON, StatGenUi._PROP_PREFIX_ROLLED, StatGenUi._PROP_PREFIX_ARRAY, StatGenUi._PROP_PREFIX_MANUAL, ];

        Object.keys(saved.state).filter(k=>!validKeys.has(k) && !validKeyPrefixes.some(it=>k.startsWith(it))).forEach(k=>delete saved.state[k]);

        for (let i = saved.state.common_cntAsi || 0; i < 1000; ++i) {
            const {propMode, prefix} = this.getPropsAsi(i, "ability");
            if (saved.state[propMode])
                Object.keys(saved.state).filter(k=>k.startsWith(prefix)).forEach(k=>delete saved.state[k]);
        }

        for (let i = saved.state.common_cntFeatsCustom || 0; i < 1000; ++i) {
            const {propMode, prefix} = this.getPropsAsi(i, "custom");
            if (saved.state[propMode])
                Object.keys(saved.state).filter(k=>k.startsWith(prefix)).forEach(k=>delete saved.state[k]);
        }

        super.setStateFrom(saved, isOverwrite);
    }

    _pb_getMinMaxScores() {
        return {
            min: Math.min(...this._state.pb_rules.map(it=>it.entity.score)),
            max: Math.max(...this._state.pb_rules.map(it=>it.entity.score)),
        };
    }

    _getDefaultStateCommonResettable() {
        return {
            ...Parser.ABIL_ABVS.mergeMap(ab=>({
                [this.constructor._common_getProps(ab).propUserBonus]: 0
            })),

            common_raceChoiceMetasFrom: [],
            common_raceChoiceMetasWeighted: [],

            common_backgroundChoiceMetasFrom: [],
            common_backgroundChoiceMetasWeighted: [],
        };
    }

    _getDefaultStateNoneResettable() {
        return {};
    }

    _getDefaultStateRolledResettable() {
        return {
            ...Parser.ABIL_ABVS.mergeMap(ab=>({
                [this.constructor._rolled_getProps(ab).propAbilSelectedRollIx]: null
            })),
        };
    }

    _getDefaultStateArrayResettable() {
        return {
            ...Parser.ABIL_ABVS.mergeMap(ab=>({
                [this.constructor._array_getProps(ab).propAbilSelectedScoreIx]: null
            })),
        };
    }

    _getDefaultStatePointBuyResettable() {
        return {
            pb_str: 8,
            pb_dex: 8,
            pb_con: 8,
            pb_int: 8,
            pb_wis: 8,
            pb_cha: 8,
        };
    }

    _getDefaultStatePointBuyCosts() {
        return {
            pb_rules: [{
                score: 8,
                cost: 0
            }, {
                score: 9,
                cost: 1
            }, {
                score: 10,
                cost: 2
            }, {
                score: 11,
                cost: 3
            }, {
                score: 12,
                cost: 4
            }, {
                score: 13,
                cost: 5
            }, {
                score: 14,
                cost: 7
            }, {
                score: 15,
                cost: 9
            }, ].map(({score, cost})=>this._getDefaultState_pb_rule(score, cost)),
        };
    }

    _getDefaultState_pb_rule(score, cost) {
        return {
            id: CryptUtil.uid(),
            entity: {
                score,
                cost,
            },
        };
    }

    _getDefaultStateManualResettable() {
        return {
            ...Parser.ABIL_ABVS.mergeMap(ab=>({
                [this.constructor._manual_getProps(ab).propAbilValue]: null
            })),
        };
    }

    _getDefaultState() {
        return {
            common_isPreviewRace: false,
            common_isTashas: false,
            common_isShowTashasRules: false,
            common_ixRace: null,
            common_ixAbilityScoreSet: 0,

            common_isPreviewBackground: false,
            common_ixBackground: null,
            common_ixAbilityScoreSetBackground: 0,

            common_pulseAsi: false,
            common_cntAsi: 0,
            common_cntFeatsCustom: 0,

            common_export_str: null,
            common_export_dex: null,
            common_export_con: null,
            common_export_int: null,
            common_export_wis: null,
            common_export_cha: null,

            ...this._getDefaultStateCommonResettable(),

            rolled_formula: "4d6dl1",
            rolled_rollCount: 6,
            rolled_rolls: [],
            ...this._getDefaultStateRolledResettable(),

            ...this._getDefaultStateArrayResettable(),

            ...this._getDefaultStatePointBuyResettable(),
            ...this._getDefaultStatePointBuyCosts(),

            pb_points: 27,
            pb_budget: 27,

            pb_isCustom: false,

            ...this._getDefaultStateManualResettable(),
        };
    }
};

StatGenUi._STANDARD_ARRAY = [15, 14, 13, 12, 10, 8];
StatGenUi._PROP_PREFIX_COMMON = "common_";
StatGenUi._PROP_PREFIX_ROLLED = "rolled_";
StatGenUi._PROP_PREFIX_ARRAY = "array_";
StatGenUi._PROP_PREFIX_MANUAL = "manual_";
StatGenUi.MODE_NONE = "none";
StatGenUi.MODES = ["rolled", "array", "pointbuy", "manual", ];
StatGenUi.MODES_FVTT = [StatGenUi.MODE_NONE, ...StatGenUi.MODES, ];
StatGenUi._MAX_CUSTOM_FEATS = 20;
StatGenUi.CompAsi = class extends BaseComponent {
    constructor({parent}) {
        super();
        this._parent = parent;

        this._metasAsi = {
            ability: [],
            race: [],
            background: [],
            custom: []
        };

        this._doPulseThrottled = MiscUtil.throttle(this._doPulse_.bind(this), 50);
    }

    _doPulse_() {
        this._parent.state.common_pulseAsi = !this._parent.state.common_pulseAsi;
    }

    _render_renderAsiFeatSection(propCnt, namespace, $wrpRows) {
        const hk = ()=>{
            let ix = 0;

            for (; ix < this._parent.state[propCnt]; ++ix) {
                const ix_ = ix;
                const {propMode, propIxFeat, propIxAsiPointOne, propIxAsiPointTwo, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAsi(ix_, namespace);

                if (!this._metasAsi[namespace][ix_]) {
                    this._parent.state[propMode] = this._parent.state[propMode] || (namespace === "ability" ? "asi" : "feat");

                    const $btnAsi = namespace !== "ability" ? null : $(`<button class="btn btn-xs btn-default w-50p">ASI</button>`).click(()=>{
                        this._parent.state[propMode] = "asi";
                        this._doPulseThrottled();
                    }
                    );

                    const $btnFeat = namespace !== "ability" ? $(`<div class="w-100p ve-text-center">Feat</div>`) : $(`<button class="btn btn-xs btn-default w-50p">Feat</button>`).click(()=>{
                        this._parent.state[propMode] = "feat";
                        this._doPulseThrottled();
                    }
                    );

                    let $stgAsi;
                    if (namespace === "ability") {
                        const $colsAsi = Parser.ABIL_ABVS.map((it,ixAsi)=>{
                            const updateDisplay = ()=>$ipt.val(Number(this._parent.state[propIxAsiPointOne] === ixAsi) + Number(this._parent.state[propIxAsiPointTwo] === ixAsi));

                            const $ipt = $(`<input class="form-control form-control--minimal text-right input-xs statgen-shared__ipt" type="number" style="width: 42px;">`).disableSpellcheck().keydown(evt=>{
                                if (evt.key === "Escape")
                                    $ipt.blur();
                            }
                            ).change(()=>{
                                const raw = $ipt.val().trim();
                                const asNum = Number(raw);

                                const activeProps = [propIxAsiPointOne, propIxAsiPointTwo].filter(prop=>this._parent.state[prop] === ixAsi);

                                if (isNaN(asNum) || asNum <= 0) {
                                    this._parent.proxyAssignSimple("state", {
                                        ...activeProps.mergeMap(prop=>({
                                            [prop]: null
                                        })),
                                    }, );
                                    updateDisplay();
                                    return this._doPulseThrottled();
                                }

                                if (asNum >= 2) {
                                    this._parent.proxyAssignSimple("state", {
                                        [propIxAsiPointOne]: ixAsi,
                                        [propIxAsiPointTwo]: ixAsi,
                                    }, );
                                    updateDisplay();
                                    return this._doPulseThrottled();
                                }

                                if (activeProps.length === 2) {
                                    this._parent.state[propIxAsiPointTwo] = null;
                                    updateDisplay();
                                    return this._doPulseThrottled();
                                }

                                if (this._parent.state[propIxAsiPointOne] == null) {
                                    this._parent.state[propIxAsiPointOne] = ixAsi;
                                    updateDisplay();
                                    return this._doPulseThrottled();
                                }

                                this._parent.state[propIxAsiPointTwo] = ixAsi;
                                updateDisplay();
                                this._doPulseThrottled();
                            }
                            );

                            const hkSelected = ()=>updateDisplay();
                            this._parent.addHookBase(propIxAsiPointOne, hkSelected);
                            this._parent.addHookBase(propIxAsiPointTwo, hkSelected);
                            hkSelected();

                            return $$`<div class="ve-flex-col h-100 mr-2">
							<div class="statgen-asi__cell ve-text-center pb-1" title="${Parser.attAbvToFull(it)}">${it.toUpperCase()}</div>
							<div class="ve-flex-vh-center statgen-asi__cell relative">
								<div class="absolute no-events statgen-asi__disp-plus">+</div>
								${$ipt}
							</div>
						</div>`;
                        }
                        );

                        $stgAsi = $$`<div class="ve-flex-v-center">
							${$colsAsi}
						</div>`;
                    }

                    const {$stgFeat, $btnChooseFeat, hkIxFeat} = this._render_getMetaFeat({
                        propIxFeat,
                        propIxFeatAbility,
                        propFeatAbilityChooseFrom
                    });

                    const hkMode = ()=>{
                        if (namespace === "ability") {
                            $btnAsi.toggleClass("active", this._parent.state[propMode] === "asi");
                            $btnFeat.toggleClass("active", this._parent.state[propMode] === "feat");
                        }

                        $btnChooseFeat.toggleVe(this._parent.state[propMode] === "feat");

                        if (namespace === "ability")
                            $stgAsi.toggleVe(this._parent.state[propMode] === "asi");
                        $stgFeat.toggleVe(this._parent.state[propMode] === "feat");

                        hkIxFeat();
                    }
                    ;
                    this._parent.addHookBase(propMode, hkMode);
                    hkMode();

                    const $row = $$`<div class="ve-flex-v-end py-3 px-1">
						<div class="btn-group">${$btnAsi}${$btnFeat}</div>
						<div class="vr-4"></div>
						${$stgAsi}
						${$stgFeat}
					</div>`.appendTo($wrpRows);

                    this._metasAsi[namespace][ix_] = {
                        $row,
                    };
                }

                this._metasAsi[namespace][ix_].$row.showVe().addClass("statgen-asi__row");
            }

            if (this._metasAsi[namespace][ix - 1])
                this._metasAsi[namespace][ix - 1].$row.removeClass("statgen-asi__row");

            for (; ix < this._metasAsi[namespace].length; ++ix) {
                if (!this._metasAsi[namespace][ix])
                    continue;
                this._metasAsi[namespace][ix].$row.hideVe().removeClass("statgen-asi__row");
            }
        }
        ;
        this._parent.addHookBase(propCnt, hk);
        hk();
    }

    _render_renderAdditionalFeatSection({namespace, $wrpRows, propEntity}) {
        const fnsCleanupEnt = [];
        const fnsCleanupGroup = [];

        const {propIxSel, propPrefix} = this._parent.getPropsAdditionalFeats_(namespace);

        const resetGroupState = ()=>{
            const nxtState = Object.keys(this._parent.state).filter(k=>k.startsWith(propPrefix) && k !== propIxSel).mergeMap(k=>({
                [k]: null
            }));
            this._parent.proxyAssignSimple("state", nxtState);
        }
        ;

        const hkEnt = (isNotFirstRun)=>{
            fnsCleanupEnt.splice(0, fnsCleanupEnt.length).forEach(fn=>fn());
            fnsCleanupGroup.splice(0, fnsCleanupGroup.length).forEach(fn=>fn());
            $wrpRows.empty();

            if (isNotFirstRun)
                resetGroupState();

            const ent = this._parent[namespace];
            if ((ent?.feats?.length || 0) > 1) {
                const {$sel: $selGroup, unhook: unhookIxGroup} = UtilAdditionalFeats$1.getSelIxSetMeta({
                    comp: this._parent,
                    prop: propIxSel,
                    available: ent.feats
                });
                fnsCleanupEnt.push(unhookIxGroup);
                $$`<div class="ve-flex-col mb-2">
					<div class="ve-flex-v-center mb-2">
						<div class="mr-2">Feat Set:</div>
						${$selGroup.addClass("max-w-200p")}
					</div>
				</div>`.appendTo($wrpRows);
            } else {
                this._parent.state[propIxSel] = 0;
            }

            const $wrpRowsInner = $(`<div class="w-100 ve-flex-col min-h-0"></div>`).appendTo($wrpRows);

            const hkIxSel = (isNotFirstRun)=>{
                fnsCleanupGroup.splice(0, fnsCleanupGroup.length).forEach(fn=>fn());
                $wrpRowsInner.empty();

                if (isNotFirstRun)
                    resetGroupState();

                const featSet = ent?.feats?.[this._parent.state[propIxSel]];

                const uidsStatic = UtilAdditionalFeats$1.getUidsStatic(featSet);

                const $rows = [];

                uidsStatic.map((uid,ix)=>{
                    const {propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "static", ix);
                    const {name, source} = DataUtil.proxy.unpackUid("feat", uid, "feat", {
                        isLower: true
                    });
                    const feat = this._parent.feats.find(it=>it.name.toLowerCase() === name && it.source.toLowerCase() === source);
                    const {$stgFeat, hkIxFeat, cleanup} = this._render_getMetaFeat({
                        featStatic: feat,
                        propIxFeatAbility,
                        propFeatAbilityChooseFrom
                    });
                    fnsCleanupGroup.push(cleanup);
                    hkIxFeat();

                    const $row = $$`<div class="ve-flex-v-end py-3 px-1 statgen-asi__row">
						<div class="btn-group"><div class="w-100p ve-text-center">Feat</div></div>
						<div class="vr-4"></div>
						${$stgFeat}
					</div>`.appendTo($wrpRowsInner);
                    $rows.push($row);
                }
                );

                [...new Array(featSet?.any || 0)].map((_,ix)=>{
                    const {propIxFeat, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "fromFilter", ix);
                    const {$stgFeat, hkIxFeat, cleanup} = this._render_getMetaFeat({
                        propIxFeat,
                        propIxFeatAbility,
                        propFeatAbilityChooseFrom
                    });
                    fnsCleanupGroup.push(cleanup);
                    hkIxFeat();

                    const $row = $$`<div class="ve-flex-v-end py-3 px-1 statgen-asi__row">
						<div class="btn-group"><div class="w-100p ve-text-center">Feat</div></div>
						<div class="vr-4"></div>
						${$stgFeat}
					</div>`.appendTo($wrpRowsInner);
                    $rows.push($row);
                }
                );

                if ($rows.last())
                    $rows.last().removeClass("statgen-asi__row");

                this._doPulseThrottled();
            }
            ;
            this._parent.addHookBase(propIxSel, hkIxSel);
            fnsCleanupEnt.push(()=>this._parent.removeHookBase(propIxSel, hkIxSel));
            hkIxSel();
            this._doPulseThrottled();
        }
        ;
        this._parent.addHookBase(propEntity, hkEnt);
        hkEnt();
    }

    _render_getMetaFeat({featStatic=null, propIxFeat=null, propIxFeatAbility, propFeatAbilityChooseFrom}) {
        if (featStatic && propIxFeat)
            throw new Error(`Cannot combine static feat and feat property!`);
        if (featStatic == null && propIxFeat == null)
            throw new Error(`Either a static feat or a feat property must be specified!`);

        const $btnChooseFeat = featStatic ? null : $(`<button class="btn btn-xxs btn-default mr-2" title="Choose a Feat"><span class="glyphicon glyphicon-search"></span></button>`).click(async()=>{
            const selecteds = await this._parent.modalFilterFeats.pGetUserSelection();
            if (selecteds == null || !selecteds.length)
                return;

            const selected = selecteds[0];
            const ix = this._parent.feats.findIndex(it=>it.name === selected.name && it.source === selected.values.sourceJson);
            if (!~ix)
                throw new Error(`Could not find selected entity: ${JSON.stringify(selected)}`);
            this._parent.state[propIxFeat] = ix;

            this._doPulseThrottled();
        }
        );

        const $dispFeat = $(`<div class="ve-flex-v-center mr-2"></div>`);
        const $stgSelectAbilitySet = $$`<div class="ve-flex-v-center mr-2"></div>`;
        const $stgFeatNoChoice = $$`<div class="ve-flex-v-center mr-2"></div>`;
        const $stgFeatChooseAsiFrom = $$`<div class="ve-flex-v-end"></div>`;
        const $stgFeatChooseAsiWeighted = $$`<div class="ve-flex-v-center"></div>`;

        const $stgFeat = $$`<div class="ve-flex-v-center">
			${$btnChooseFeat}
			${$dispFeat}
			${$stgSelectAbilitySet}
			${$stgFeatNoChoice}
			${$stgFeatChooseAsiFrom}
			${$stgFeatChooseAsiWeighted}
		</div>`;

        const fnsCleanup = [];
        const fnsCleanupFeat = [];
        const fnsCleanupFeatAbility = [];

        const hkIxFeat = (isNotFirstRun)=>{
            fnsCleanupFeat.splice(0, fnsCleanupFeat.length).forEach(fn=>fn());
            fnsCleanupFeatAbility.splice(0, fnsCleanupFeatAbility.length).forEach(fn=>fn());

            if (isNotFirstRun) {
                const nxtState = Object.keys(this._parent.state).filter(it=>it.startsWith(propFeatAbilityChooseFrom)).mergeMap(it=>({
                    [it]: null
                }));
                this._parent.proxyAssignSimple("state", nxtState);
            }

            const feat = featStatic || this._parent.feats[this._parent.state[propIxFeat]];

            $stgFeat.removeClass("ve-flex-v-end").addClass("ve-flex-v-center");
            $dispFeat.toggleClass("italic ve-muted", !feat);
            $dispFeat.html(feat ? Renderer.get().render(`{@feat ${feat.name.toLowerCase()}|${feat.source}}`) : `(Choose a feat)`);

            this._parent.state[propIxFeatAbility] = 0;

            $stgSelectAbilitySet.hideVe();
            if (feat) {
                if (feat.ability && feat.ability.length > 1) {
                    const metaChooseAbilitySet = ComponentUiUtil.$getSelEnum(this._parent, propIxFeatAbility, {
                        values: feat.ability.map((_,i)=>i),
                        fnDisplay: ix=>Renderer.getAbilityData([feat.ability[ix]]).asText,
                        asMeta: true,
                    }, );

                    $stgSelectAbilitySet.showVe().append(metaChooseAbilitySet.$sel);
                    metaChooseAbilitySet.$sel.change(()=>this._doPulseThrottled());
                    fnsCleanupFeat.push(()=>metaChooseAbilitySet.unhook());
                }

                const hkAbilitySet = ()=>{
                    fnsCleanupFeatAbility.splice(0, fnsCleanupFeatAbility.length).forEach(fn=>fn());

                    if (!feat.ability) {
                        $stgFeatNoChoice.empty().hideVe();
                        $stgFeatChooseAsiFrom.empty().hideVe();
                        return;
                    }

                    const abilitySet = feat.ability[this._parent.state[propIxFeatAbility]];

                    const ptsNoChoose = Parser.ABIL_ABVS.filter(ab=>abilitySet[ab]).map(ab=>`${Parser.attAbvToFull(ab)} ${UiUtil.intToBonus(abilitySet[ab], {
                        isPretty: true
                    })}`);
                    $stgFeatNoChoice.empty().toggleVe(ptsNoChoose.length).html(`<div><span class="mr-2">\u2014</span>${ptsNoChoose.join(", ")}</div>`);

                    if (abilitySet.choose && abilitySet.choose.from) {
                        $stgFeat.removeClass("ve-flex-v-center").addClass("ve-flex-v-end");
                        $stgFeatChooseAsiFrom.showVe().empty();
                        $stgFeatChooseAsiWeighted.empty().hideVe();

                        const count = abilitySet.choose.count || 1;
                        const amount = abilitySet.choose.amount || 1;

                        const {rowMetas, cleanup: cleanupAsiPicker} = ComponentUiUtil.getMetaWrpMultipleChoice(this._parent, propFeatAbilityChooseFrom, {
                            values: abilitySet.choose.from,
                            fnDisplay: v=>`${Parser.attAbvToFull(v)} ${UiUtil.intToBonus(amount, {
                                isPretty: true
                            })}`,
                            count,
                        }, );
                        fnsCleanupFeatAbility.push(()=>cleanupAsiPicker());

                        $stgFeatChooseAsiFrom.append(`<div><span class="mr-2">\u2014</span>choose ${count > 1 ? `${count} ` : ""}${UiUtil.intToBonus(amount, {
                            isPretty: true
                        })}</div>`);

                        rowMetas.forEach(meta=>{
                            meta.$cb.change(()=>this._doPulseThrottled());

                            $$`<label class="ve-flex-col no-select">
								<div class="ve-flex-vh-center statgen-asi__cell-feat" title="${Parser.attAbvToFull(meta.value)}">${meta.value.toUpperCase()}</div>
								<div class="ve-flex-vh-center statgen-asi__cell-feat">${meta.$cb}</div>
							</label>`.appendTo($stgFeatChooseAsiFrom);
                        }
                        );
                    } else if (abilitySet.choose && abilitySet.choose.weighted) {
                        $stgFeatChooseAsiFrom.empty().hideVe();
                        $stgFeatChooseAsiWeighted.showVe().html(`<i class="ve-muted">The selected ability score format is currently unsupported. Please check back later!</i>`);
                    } else {
                        $stgFeatChooseAsiFrom.empty().hideVe();
                        $stgFeatChooseAsiWeighted.empty().hideVe();
                    }

                    this._doPulseThrottled();
                }
                ;
                this._parent.addHookBase(propIxFeatAbility, hkAbilitySet);
                fnsCleanupFeat.push(()=>this._parent.removeHookBase(propIxFeatAbility, hkAbilitySet));
                hkAbilitySet();
            } else {
                $stgFeatNoChoice.empty().hideVe();
                $stgFeatChooseAsiFrom.empty().hideVe();
                $stgFeatChooseAsiWeighted.empty().hideVe();
            }

            this._doPulseThrottled();
        }
        ;

        if (!featStatic) {
            this._parent.addHookBase(propIxFeat, hkIxFeat);
            fnsCleanup.push(()=>this._parent.removeHookBase(propIxFeat, hkIxFeat));
        }

        const cleanup = ()=>{
            fnsCleanup.splice(0, fnsCleanup.length).forEach(fn=>fn());
            fnsCleanupFeat.splice(0, fnsCleanupFeat.length).forEach(fn=>fn());
            fnsCleanupFeatAbility.splice(0, fnsCleanupFeatAbility.length).forEach(fn=>fn());
        }
        ;

        return {
            $btnChooseFeat,
            $stgFeat,
            hkIxFeat,
            cleanup
        };
    }

    render($wrpAsi) {
        const $wrpRowsAsi = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);
        const $wrpRowsRace = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);
        const $wrpRowsBackground = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);
        const $wrpRowsCustom = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);

        this._render_renderAsiFeatSection("common_cntAsi", "ability", $wrpRowsAsi);
        this._render_renderAsiFeatSection("common_cntFeatsCustom", "custom", $wrpRowsCustom);
        this._render_renderAdditionalFeatSection({
            propEntity: "common_ixRace",
            namespace: "race",
            $wrpRows: $wrpRowsRace
        });
        this._render_renderAdditionalFeatSection({
            propEntity: "common_ixBackground",
            namespace: "background",
            $wrpRows: $wrpRowsBackground
        });

        const $getStgEntity = ({title, $wrpRows, propEntity, propIxEntity})=>{
            const $stg = $$`<div class="ve-flex-col">
				<hr class="hr-3 hr--dotted">
				<h4 class="my-2 bold">${title} Feats</h4>
				${$wrpRows}
			</div>`;

            const hkIxEntity = ()=>{
                const entity = this._parent[propEntity];
                $stg.toggleVe(!this._parent.isLevelUp && !!entity?.feats);
            }
            ;
            this._parent.addHookBase(propIxEntity, hkIxEntity);
            hkIxEntity();

            return $stg;
        }
        ;

        const $stgRace = $getStgEntity({
            title: "Race",
            $wrpRows: $wrpRowsRace,
            propEntity: "race",
            propIxEntity: "common_ixRace"
        });

        const $stgBackground = $getStgEntity({
            title: "Background",
            $wrpRows: $wrpRowsBackground,
            propEntity: "background",
            propIxEntity: "common_ixBackground"
        });

        const $iptCountFeatsCustom = ComponentUiUtil.$getIptInt(this._parent, "common_cntFeatsCustom", 0, {
            min: 0,
            max: StatGenUi._MAX_CUSTOM_FEATS
        }).addClass("w-100p ve-text-center");

        $$($wrpAsi)`
			<h4 class="my-2 bold">Ability Score Increases</h4>
			${this._render_$getStageCntAsi()}
			${$wrpRowsAsi}

			${$stgRace}

			${$stgBackground}

			<hr class="hr-3 hr--dotted">
			<h4 class="my-2 bold">Additional Feats</h4>
			<label class="w-100 ve-flex-v-center mb-2">
				<div class="mr-2 no-shrink">Number of additional feats:</div>${$iptCountFeatsCustom}
			</label>
			${$wrpRowsCustom}
		`;
    }

    _render_$getStageCntAsi() {
        if (!this._parent.isCharacterMode) {
            const $iptCountAsi = ComponentUiUtil.$getIptInt(this._parent, "common_cntAsi", 0, {
                min: 0,
                max: 20
            }).addClass("w-100p ve-text-center");
            return $$`<label class="w-100 ve-flex-v-center mb-2"><div class="mr-2 no-shrink">Number of Ability Score Increases to apply:</div>${$iptCountAsi}</label>`;
        }

        const $out = $$`<div class="w-100 ve-flex-v-center mb-2 italic ve-muted">No ability score increases available.</div>`;
        const hkCntAsis = ()=>$out.toggleVe(this._parent.state.common_cntAsi === 0);
        this._parent.addHookBase("common_cntAsi", hkCntAsis);
        hkCntAsis();
        return $out;
    }

    _getFormData_getForNamespace_basic(outs, outIsFormCompletes, outFeats, propCnt, namespace) {
        for (let i = 0; i < this._parent.state[propCnt]; ++i) {
            const {propMode, propIxFeat, propIxAsiPointOne, propIxAsiPointTwo, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAsi(i, namespace);

            if (this._parent.state[propMode] === "asi") {
                const out = {};

                let ttlChosen = 0;

                Parser.ABIL_ABVS.forEach((ab,abI)=>{
                    const increase = [this._parent.state[propIxAsiPointOne] === abI, this._parent.state[propIxAsiPointTwo] === abI].filter(Boolean).length;
                    if (increase)
                        out[ab] = increase;
                    ttlChosen += increase;
                }
                );

                const isFormComplete = ttlChosen === 2;

                outFeats[namespace].push(null);
                outs.push(out);
                outIsFormCompletes.push(isFormComplete);
            } else if (this._parent.state[propMode] === "feat") {
                const {isFormComplete, out} = this._getFormData_doAddFeatMeta({
                    namespace,
                    outFeats,
                    propIxFeat,
                    propIxFeatAbility,
                    propFeatAbilityChooseFrom,
                    type: "choose",
                });
                outs.push(out);
                outIsFormCompletes.push(isFormComplete);
            }
        }
    }

    _getFormData_getForNamespace_additional(outs, outIsFormCompletes, outFeats, namespace) {
        const ent = this._parent[namespace];
        if (!ent?.feats?.length)
            return;

        const {propIxSel} = this._parent.getPropsAdditionalFeats_(namespace);

        const featSet = ent.feats[this._parent.state[propIxSel]];
        if (!featSet) {
            outIsFormCompletes.push(false);
            return;
        }

        const uidsStatic = UtilAdditionalFeats$1.getUidsStatic(featSet);

        uidsStatic.map((uid,ix)=>{
            const {propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "static", ix);
            const {name, source} = DataUtil.proxy.unpackUid("feat", uid, "feat", {
                isLower: true
            });
            const feat = this._parent.feats.find(it=>it.name.toLowerCase() === name && it.source.toLowerCase() === source);

            const {isFormComplete, out} = this._getFormData_doAddFeatMeta({
                namespace,
                outFeats,
                featStatic: feat,
                propIxFeatAbility,
                propFeatAbilityChooseFrom,
                type: "static",
            });

            outs.push(out);
            outIsFormCompletes.push(isFormComplete);
        }
        );

        [...new Array(featSet.any || 0)].map((_,ix)=>{
            const {propIxFeat, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "fromFilter", ix);

            const {isFormComplete, out} = this._getFormData_doAddFeatMeta({
                namespace,
                outFeats,
                propIxFeat,
                propIxFeatAbility,
                propFeatAbilityChooseFrom,
                type: "choose",
            });

            outs.push(out);
            outIsFormCompletes.push(isFormComplete);
        }
        );
    }

    _getFormData_doAddFeatMeta({namespace, outFeats, propIxFeat=null, featStatic=null, propIxFeatAbility, propFeatAbilityChooseFrom, type}) {
        if (featStatic && propIxFeat)
            throw new Error(`Cannot combine static feat and feat property!`);
        if (featStatic == null && propIxFeat == null)
            throw new Error(`Either a static feat or a feat property must be specified!`);

        const out = {};

        const feat = featStatic || this._parent.feats[this._parent.state[propIxFeat]];

        const featMeta = feat ? {
            ix: this._parent.state[propIxFeat],
            uid: `${feat.name}|${feat.source}`,
            type
        } : {
            ix: -1,
            uid: null,
            type
        };
        outFeats[namespace].push(featMeta);

        if (!~featMeta.ix)
            return {
                isFormComplete: false,
                out
            };
        if (!feat.ability)
            return {
                isFormComplete: true,
                out
            };

        const abilitySet = feat.ability[this._parent.state[propIxFeatAbility] || 0];

        Parser.ABIL_ABVS.forEach(ab=>{
            if (abilitySet[ab])
                out[ab] = abilitySet[ab];
        }
        );

        if (!abilitySet.choose)
            return {
                isFormComplete: true,
                out
            };

        let isFormComplete = true;

        featMeta.abilityChosen = {};

        if (abilitySet.choose.from) {
            if (isFormComplete)
                isFormComplete = !!this._parent.state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable(propFeatAbilityChooseFrom)];

            const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this._parent, propFeatAbilityChooseFrom);
            ixs.map(it=>abilitySet.choose.from[it]).forEach(ab=>{
                const amount = abilitySet.choose.amount || 1;
                out[ab] = (out[ab] || 0) + amount;
                featMeta.abilityChosen[ab] = amount;
            }
            );
        }

        return {
            isFormComplete,
            out
        };
    }

    getFormData() {
        const outs = [];
        const isFormCompletes = [];
        const feats = {
            ability: [],
            race: [],
            background: [],
            custom: []
        };

        this._getFormData_getForNamespace_basic(outs, isFormCompletes, feats, "common_cntAsi", "ability");
        this._getFormData_getForNamespace_basic(outs, isFormCompletes, feats, "common_cntFeatsCustom", "custom");
        this._getFormData_getForNamespace_additional(outs, isFormCompletes, feats, "race");
        this._getFormData_getForNamespace_additional(outs, isFormCompletes, feats, "background");

        const data = {};
        outs.filter(Boolean).forEach(abilBonuses=>Object.entries(abilBonuses).forEach(([ab,bonus])=>data[ab] = (data[ab] || 0) + bonus));

        return {
            isFormComplete: isFormCompletes.every(Boolean),
            dataPerAsi: outs,
            data,
            feats,
        };
    }
};
StatGenUi.RenderableCollectionPbRules = class extends RenderableCollectionGenericRows {
    constructor(statGenUi, $wrp) {
        super(statGenUi, "pb_rules", $wrp);
    }

    getNewRender(rule, i) {
        const parentComp = this._comp;

        const comp = this._utils.getNewRenderComp(rule, i);

        const $dispCost = $(`<div class="ve-flex-vh-center"></div>`);
        const hkCost = ()=>$dispCost.text(comp._state.cost);
        comp._addHookBase("cost", hkCost);
        hkCost();

        const $iptCost = ComponentUiUtil.$getIptInt(comp, "cost", 0, {
            html: `<input class="form-control input-xs form-control--minimal ve-text-center">`,
            fallbackOnNaN: 0
        });

        const hkIsCustom = ()=>{
            $dispCost.toggleVe(!parentComp.state.pb_isCustom);
            $iptCost.toggleVe(parentComp.state.pb_isCustom);
        };
        parentComp._addHookBase("pb_isCustom", hkIsCustom);
        hkIsCustom();

        const $btnDelete = $(`<button class="btn btn-xxs btn-danger" title="Delete"><span class="glyphicon glyphicon-trash"></span></button>`).click(()=>{
            if (parentComp.state.pb_rules.length === 1)
                return;
            parentComp.state.pb_rules = parentComp.state.pb_rules.filter(it=>it !== rule);
        }
        );

        const $wrpRow = $$`<div class="ve-flex py-1 stripe-even statgen-pb__row-cost">
			<div class="statgen-pb__col-cost ve-flex-vh-center">${comp._state.score}</div>
			<div class="statgen-pb__col-cost ve-flex-vh-center">${Parser.getAbilityModifier(comp._state.score)}</div>
			<div class="statgen-pb__col-cost ve-flex-vh-center px-3">
				${$dispCost}
				${$iptCost}
			</div>
			<div class="statgen-pb__col-cost-delete">${$btnDelete}</div>
		</div>`.appendTo(this._$wrpRows);

        const hkRules = ()=>{
            //$btnDelete.toggleVe((parentComp.state.pb_rules[0] === rule || parentComp.state.pb_rules.last() === rule) && parentComp.state.pb_isCustom);
        };
        parentComp._addHookBase("pb_rules", hkRules);
        parentComp._addHookBase("pb_isCustom", hkRules);
        hkRules();

        return {
            comp,
            $wrpRow,
            fnCleanup: ()=>{
                parentComp._removeHookBase("pb_isCustom", hkIsCustom);
                parentComp._removeHookBase("pb_isCustom", hkRules);
                parentComp._removeHookBase("pb_rules", hkRules);
            }
            ,
        };
    }

    doDeleteExistingRender(renderedMeta) {
        renderedMeta.fnCleanup();
    }
};

class StatGenUiCharactermancer extends StatGenUi {
    _roll_getRolledStats() {
      try {
        const roll = new Roll(this._state.rolled_formula);
        roll.evaluate({ 'async': false });
      }
      catch (err) { return this._$rollIptFormula.addClass("form-control--error"); }
      const result = [];
      for (let i = 0; i < this._state.rolled_rollCount; i++) {
        const roll = new Roll(this._state.rolled_formula);
        roll.evaluate({ 'async': false });
        result.push(roll);
        roll.toMessage({ 'sound': null }).then(null);
      }
      result.sort((r1, r2) => SortUtil.ascSort(r2.total, r1.total));
      return result.map(r => ({
        'total': r.total,
        'text': (r?.terms || []).map(term => (term?.results || []).map(result => '[' + (result.result || '‒') + ']').join('+'))
      }));
    }
}

//#endregion

//#region Charactermancer Race
class ActorCharactermancerRace extends ActorCharactermancerBaseComponent {
    constructor(parentInfo) {
      parentInfo = parentInfo || {};
      super();
      this._actor = parentInfo.actor;
      this._data = parentInfo.data;
      this._parent = parentInfo.parent;
      this._tabRace = parentInfo.tabRace;
      //TEMPFIX
      this._modalFilterRaces = new ModalFilterRaces({//ModalFilterRacesFvtt({
        'namespace': 'ActorCharactermancer.races',
        'isRadio': true,
        'allData': this._data.race
      });
      this._compRaceSize = null;
      this._compRaceSkillToolLanguageProficiencies = null;
      this._compRaceSkillProficiencies = null;
      this._compRaceLanguageProficiencies = null;
      this._compRaceToolProficiencies = null;
      this._compRaceExpertise = null;
      this._compRaceWeaponProficiencies = null;
      this._compRaceArmorProficiencies = null;
      this._compRaceDamageImmunity = null;
      this._compRaceDamageResistance = null;
      this._compRaceDamageVulnerability = null;
      this._compRaceConditionImmunity = null;
    }

    render() {
        const parentDiv = this._tabRace?.$wrpTab;
        if (!parentDiv) {return;}
        if(!this._data.race || this._data.race.length < 1){console.error("No races provided!");}
        
        //Create a searchable selector field that uses the modalfilter to only show filtered content
        const {$sel: ele_sel, $btnFilter: ele_btnFilter, $stgSelVersion: ele_selVersion }
        = Charactermancer_Util.getFilterSearchMeta({
            'comp': this,
            'prop': "race_ixRace",
            'propVersion': "race_ixRace_version",
            'data': this._data.race,
            'modalFilter': this._modalFilterRaces,
            'title': "Race"
        });

        //When race changes, reset the race version
        const onRaceChanged = () => this._setStateValue('race_ixRace_version', null);
        this._addHookBase('race_ixRace', onRaceChanged);

        const createExtraInfoElements = () => {
            //Take all child names of __state
            //Get only the child names that start with "race_" and arent 'race_ixRace' or 'race_ixRace_version'
            //From those, return them all as an array? not sure
            const racePropertyNames = Object.keys(this.__state).filter(prop => prop.startsWith('race_')
                && !['race_ixRace', 'race_ixRace_version'].includes(prop)).mergeMap(props => ({
                [props]: null
            }));

            this._proxyAssignSimple("state", racePropertyNames);
            const curRace = this.getRace_();
            if(this._data.race.length<1){console.error("data has no races?");}

            //#region Render proficiencies
            this._race_renderRace_stgSize({'$stgSize': ele_size, 'race': curRace });
            
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_skillToolLang,
                'ent': curRace,
                'propComp': '_compRaceSkillToolLanguageProficiencies',
                'propProficiencies': 'skillToolLanguageProficiencies',
                'CompClass': Charactermancer_OtherProficiencySelect,
                'fnGetExistingFvtt': Charactermancer_OtherProficiencySelect.getExistingFvttFromActor.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_skill,
                'ent': curRace,
                'propComp': "_compRaceSkillProficiencies",
                'propProficiencies': "skillProficiencies",
                'title': "Skill Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ["system", "skills"],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_lang,
                'ent': curRace,
                'propComp': '_compRaceLanguageProficiencies',
                'propProficiencies': "languageProficiencies",
                'title': "Language Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ['system', "traits", "languages"],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_tools,
                'ent': curRace,
                'propComp': "_compRaceToolProficiencies",
                'propProficiencies': "toolProficiencies",
                'title': "Tool Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ["system", "tools"],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_expertise,
                'ent': curRace,
                'propComp': '_compRaceExpertise',
                'propProficiencies': "expertise",
                'title': "Expertise",
                'CompClass': Charactermancer_ExpertiseSelect,
                'fnGetExistingFvtt': Charactermancer_ExpertiseSelect.getExistingFvttFromActor.bind(Charactermancer_ExpertiseSelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_wep,
                'ent': curRace,
                'propComp': "_compRaceWeaponProficiencies",
                'propProficiencies': 'weaponProficiencies',
                'title': "Weapon Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ["system", 'traits', 'weaponProf'],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_armor,
                'ent': curRace,
                'propComp': "_compRaceArmorProficiencies",
                'propProficiencies': "armorProficiencies",
                'title': "Armor Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ["system", "traits", "armorProf"],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': ele_damImm,
                'ent': curRace,
                'propComp': "_compRaceDamageImmunity",
                'CompClass': Charactermancer_DamageImmunitySelect,
                'title': "Damage Immunity",
                'propRaceData': "immune",
                'propTraits': 'di'
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': ele_damRes,
                'ent': curRace,
                'propComp': "_compRaceDamageResistance",
                'CompClass': Charactermancer_DamageResistanceSelect,
                'title': "Damage Resistance",
                'propRaceData': "resist",
                'propTraits': 'dr'
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': ele_damVul,
                'ent': curRace,
                'propComp': "_compRaceDamageVulnerability",
                'CompClass': Charactermancer_DamageVulnerabilitySelect,
                'title': "Damage Vulnerability",
                'propRaceData': 'vulnerable',
                'propTraits': 'dv'
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': ele_conImm,
                'ent': curRace,
                'propComp': '_compRaceConditionImmunity',
                'CompClass': Charactermancer_ConditionImmunitySelect,
                'title': "Condition Immunity",
                'propRaceData': "conditionImmune",
                'propTraits': 'ci'
            });
            //#endregion
            
            ele_textRoller.empty();

            if (curRace) {
                //PG_RACES = "Races.html"
                ele_textRoller.append(Renderer.hover.$getHoverContent_stats(UrlUtil.PG_RACES, MiscUtil.copy(curRace)));
                const race = this._data.race[this._state.race_ixRace];
                //TEMPFIX
                /* DataLoader.pCacheAndGet("raceFluff", race.source, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES](race)).then(o => {
                    if (!o) { return; }
                    if (o.name !== race.name || o.source !== race.source) { return; }
                    if (!o.images?.["length"]) { return; }
                    ele_textRoller.append("<hr class=\"hr-1\">");
                    ele_textRoller.append(Renderer.get().render(o.images[0]));
                }); */
            }
        };

        //When race version changes, redraw the elements
        this._addHookBase("race_ixRace_version", createExtraInfoElements);

        const ele_size = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_skillToolLang = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_skill = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_lang = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_tools = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_wep = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_armor = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_expertise = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_damImm = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_damRes = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_damVul = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_conImm = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_textRoller = $$`<div class="ve-flex-col w-100"></div>`;

        $$`
        <div class="ve-flex w-100 h-100">
        <div class="ve-flex-col w-100 h-100 px-1 pt-1 overflow-y-auto ve-grow veapp__bg-foundry">
            <div class="bold mb-2">Select a Race</div>
            <div class="ve-flex-v-center btn-group w-100">${ele_btnFilter}${ele_sel}</div>
            ${ele_selVersion}
            ${ele_skillToolLang}
            ${ele_size}
            ${ele_skill}
            ${ele_lang}
            ${ele_tools}
            ${ele_expertise}
            ${ele_wep}
            ${ele_armor}
            ${ele_damImm}
            ${ele_damRes}
            ${ele_damVul}
            ${ele_conImm}
            </div>
    
            <div class="vr-1"></div>
    
            <div class="ve-flex-col w-100 h-100 px-1 overflow-y-auto ve-grow veapp__bg-foundry">
                ${ele_textRoller}
            </div>
        </div>`.appendTo(parentDiv);

        createExtraInfoElements();
    }
    
    get modalFilterRaces() { return this._modalFilterRaces; }
    get ['compRaceSize']() {
      return this._compRaceSize;
    }
    get ["compRaceSkillToolLanguageProficiencies"]() {
      return this._compRaceSkillToolLanguageProficiencies;
    }
    get ["compRaceSkillProficiencies"]() {
      return this._compRaceSkillProficiencies;
    }
    get ["compRaceLanguageProficiencies"]() {
      return this._compRaceLanguageProficiencies;
    }
    get ["compRaceToolProficiencies"]() {
      return this._compRaceToolProficiencies;
    }
    get ["compRaceExpertise"]() {
      return this._compRaceExpertise;
    }
    get ['compRaceWeaponProficiencies']() {
      return this._compRaceWeaponProficiencies;
    }
    get ["compRaceArmorProficiencies"]() {
      return this._compRaceArmorProficiencies;
    }
    get ["compRaceDamageImmunity"]() {
      return this._compRaceDamageImmunity;
    }
    get ["compRaceDamageResistance"]() {
      return this._compRaceDamageResistance;
    }
    get ['compRaceDamageVulnerability']() {
      return this._compRaceDamageVulnerability;
    }
    get ["compRaceConditionImmunity"]() {
      return this._compRaceConditionImmunity;
    }
    async pLoad() {
      await this._modalFilterRaces.pPreloadHidden();
      if(!SETTINGS.USE_EXISTING){return;}
      this._pLoad_pDoHandleExistingRace();
    }
    _pLoad_pDoHandleExistingRace() {
      const _0x5554e3 = this._actor.system.details?.["race"];
      if (!_0x5554e3) {
        return;
      }
      const {
        ixRace: _0x554aa1,
        ixRaceVersion: _0x5a66c0,
        isRacePresent: _0x6e3758
      } = this._pLoad_getExistingRaceIndex(_0x5554e3);
      if (_0x6e3758 && _0x554aa1 == null) {
        const _0x5ac201 = "Could not find race \"" + _0x5554e3 + "\" in loaded data. " + Charactermancer_Util.STR_WARN_SOURCE_SELECTION;
        ui.notifications.warn(_0x5ac201);
        console.warn(...LGT, _0x5ac201, "Strict source matching is: " + Config.get('import', "isStrictMatching") + '.');
      }
      this._state.race_ixRace = _0x554aa1;
      this._state.race_ixRace_version = _0x5a66c0;
    }
    ["_pLoad_getExistingRaceIndex"](_0x41543f) {
      const _0x56fc39 = (IntegrationBabele.getOriginalName(_0x41543f) || '').trim().toLowerCase();
      const _0x2c50e0 = _0x41543f?.["flags"]?.[SharedConsts.MODULE_ID];
      const _0x4a05d9 = _0x2c50e0?.["propDroppable"] === "race" && _0x2c50e0?.["source"] && _0x2c50e0?.["hash"];
      let _0x50dc0a = null;
      let _0x21f4a5 = null;
      _0x343967: for (let _0x353561 = 0x0; _0x353561 < this._data.race.length; ++_0x353561) {
        const _0x626e38 = this._data.race[_0x353561];
        if (_0x4a05d9 && _0x2c50e0.source === _0x626e38.source && _0x2c50e0.hash === UrlUtil.URL_TO_HASH_BUILDER.race(_0x626e38) || this._pLoad_pDoHandleExistingRace_isMatch({
          'race': _0x626e38,
          'existingRaceClean': _0x56fc39
        })) {
          _0x50dc0a = _0x353561;
          break;
        }
        const _0x5adcb4 = DataUtil.generic.getVersions(_0x626e38);
        for (let _0x1a6bb8 = 0x0; _0x1a6bb8 < _0x5adcb4.length; ++_0x1a6bb8) {
          const _0x24cafe = _0x5adcb4[_0x1a6bb8];
          if (_0x4a05d9 && _0x2c50e0.source === _0x24cafe.source && _0x2c50e0.hash === UrlUtil.URL_TO_HASH_BUILDER.race(_0x24cafe) || this._pLoad_pDoHandleExistingRace_isMatch({
            'race': _0x24cafe,
            'existingRaceClean': _0x56fc39
          })) {
            _0x50dc0a = _0x353561;
            _0x21f4a5 = _0x1a6bb8;
            break _0x343967;
          }
        }
      }
      return {
        'ixRace': _0x50dc0a,
        'ixRaceVersion': _0x21f4a5,
        'isRacePresent': _0x56fc39 || _0x4a05d9
      };
    }
    ["_pLoad_pDoHandleExistingRace_isMatch"]({
      race: _0x5858ca,
      existingRaceClean: _0x10d38e
    }) {
      if (!_0x10d38e) {
        return false;
      }
      return _0x5858ca.name.toLowerCase().trim() === _0x10d38e || (PageFilterRaces.getInvertedName(_0x5858ca.name) || '').toLowerCase().trim() === _0x10d38e;
    }
    getRace_() {
        const curRace = this._data.race[this._state.race_ixRace];
        if (!curRace) { return null; }
        if (this._state.race_ixRace_version == null) { return curRace; }
        const raceVersions = DataUtil.generic.getVersions(curRace);
        return raceVersions[this._state.race_ixRace_version];
    }
    _race_renderRace_stgSize({$stgSize: parentDiv, race: race}) {
        parentDiv.empty();
        if (race && race.size) {
            parentDiv.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Size</div>");
            this._compRaceSize = new Charactermancer_Race_SizeSelect({'sizes': race.size});
            this._compRaceSize.render(parentDiv);
        }
        else { parentDiv.hideVe(); this._compRaceSize = null; }
    }
    _getDefaultState() { return {'race_ixRace': null, 'race_ixRace_version': null}; }
}

class Charactermancer_Race_Util {
    static async pPostLoadPrereleaseBrew(fileData) {
        const out = {
            race: []
        };

        if (fileData.race)
            out.race.push(...Renderer.race.mergeSubraces(fileData.race, {
                isAddBaseRaces: true
            }));

        if (fileData.subrace) {
            const baseListSite = MiscUtil.copy((await Vetools.pGetRaces({
                isAddBaseRaces: true
            })).race);
            baseListSite.forEach(it=>PageFilterRaces.mutateForFilters(it));

            const baseListBrew = MiscUtil.copy([...fileData.race || []]);
            baseListBrew.forEach(it=>PageFilterRaces.mutateForFilters(it));
            const baseList = [...baseListBrew, ...baseListSite];

            const nxtData = Renderer.race.adoptSubraces(baseList, fileData.subrace);
            const mergedNxtData = Renderer.race.mergeSubraces(nxtData);

            out.race.push(...mergedNxtData);
        }

        return out;
    }
}

class Charactermancer_Race_SizeSelect extends BaseComponent {
    static async pGetUserInput({sizes}) {
        if (!sizes || !sizes.length)
            return {
                isFormComplete: true,
                data: Parser.SZ_MEDIUM
            };
        const comp = new this({
            sizes
        });
        if (comp.isNoChoice())
            return comp.pGetFormData();
        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            isAutoResize: true
        });
    }

    constructor(opts) {
        opts = opts || {};
        super();

        this._sizes = opts.sizes || [Parser.SZ_MEDIUM];
    }

    get modalTitle() {
        return `Choose Size`;
    }

    render($wrp) {
        if (this._sizes.length === 1) {
            $wrp.append(`<div>${Parser.sizeAbvToFull(this._sizes[0])}</div>`);
            return;
        }

        ComponentUiUtil.$getSelEnum(this, "size", {
            values: this._sizes,
            isAllowNull: true,
            fnDisplay: Parser.sizeAbvToFull,
        }, ).appendTo($wrp);
    }

    isNoChoice() {
        return this._sizes.length <= 1;
    }

    pGetFormData() {
        return {
            isFormComplete: this._state.size != null,
            data: this._sizes.length === 1 ? this._sizes[0] : this._state.size,
        };
    }
}
//#endregion

//#region Charactermancer Background
class ActorCharactermancerBackground extends ActorCharactermancerBaseComponent {
    constructor(parentInfo) {
        parentInfo = parentInfo || {};
        super();
        this._actor = parentInfo.actor;
        this._data = parentInfo.data;
        this._parent = parentInfo.parent;
        this._tabBackground = parentInfo.tabBackground;
        this._modalFilterBackgrounds = new ModalFilterBackgroundsFvtt({
            'namespace': "ActorCharactermancer.backgrounds",
            'isRadio': true,
            'allData': this._data.background
        });
        this._metaCompBackgroundFeatures = null;
        this._compBackgroundSkillProficiencies = null;
        this._compBackgroundLanguageProficiencies = null;
        this._compBackgroundToolProficiencies = null;
        this._compBackgroundLanguageToolProficiencies = null;
        this._compBackgroundCharacteristics = null;
        this._compBackgroundExpertise = null;
        this._compBackgroundWeaponProficiencies = null;
        this._compBackgroundArmorProficiencies = null;
        this._compBackgroundDamageImmunity = null;
        this._compBackgroundDamageResistance = null;
        this._compBackgroundDamageVulnerability = null;
        this._compBackgroundConditionImmunity = null;
    }
    render() {
        const parentDiv = this._tabBackground?.["$wrpTab"];
        if (!parentDiv) { return; }
        const { $sel: ele_sel, $btnFilter: btnFilter }
        = Charactermancer_Util.getFilterSearchMeta({
          'comp': this,
          'prop': 'background_ixBackground',
          'data': this._data.background,
          'modalFilter': this._modalFilterBackgrounds,
          'title': "Background"
        });
        const wrpCustomize0 = this._background_renderBackground_$getWrpCbCustomize(ComponentUiUtil.$getCbBool(this, 'background_isCustomizeSkills'));
        const wrpCustomize1 = this._background_renderBackground_$getWrpCbCustomize(ComponentUiUtil.$getCbBool(this, "background_isCustomizeLanguagesTools"));
        const wrpCustomize2 = this._background_renderBackground_$getWrpCbCustomize(ComponentUiUtil.$getCbBool(this, "background_isCustomizeLanguagesTools"));
        const wrpCustomize3 = this._background_renderBackground_$getWrpCbCustomize(ComponentUiUtil.$getCbBool(this, "background_isCustomizeLanguagesTools"));
        const wrpCustomize4 = this._background_renderBackground_$getWrpCbCustomize(ComponentUiUtil.$getCbBool(this, "background_isCustomizeLanguagesTools"));
        const wrpCustomize5 = [wrpCustomize0, wrpCustomize1, wrpCustomize2, wrpCustomize3, wrpCustomize4];
        const renderShowCustomizingRules = () => this._background_hk_showCustomizingRules({'$stgRulesCustomize': holderRulesCustomize});

        this._addHookBase('background_isCustomizeSkills', renderShowCustomizingRules);
        this._addHookBase("background_isCustomizeLanguagesTools", renderShowCustomizingRules);

        const toggleLangCustomizeLabel = {
            1: $$`<label class="ve-flex-v-center ve-muted mb-1" title="Toggling this off will disable customization for the whole Language &amp; Tool proficiencies section.">${wrpCustomize4}</label>`
        };

        const renderBackground = _0x3c9e9c => {
            const background = this.getFeatureCustomizedBackground_({'isAllowStub': false});
            this._background_renderBackground_stgSkills({
                '$stgSkills': holderSkills,
                'background': background,
                '$wrpCbIsCustomizeSkills': wrpCustomize0
            });
            this._background_renderBackground_stgLanguages({
                '$stgLanguages': holderLanguages,
                'background': background,
                '$wrpCbIsCustomizeLanguagesTools': wrpCustomize1
            });
            this._background_renderBackground_stgTools({
                '$stgTools': holderTools,
                'background': background,
                '$wrpCbIsCustomizeLanguagesTools': wrpCustomize2
            });
            this._background_renderBackground_stgLanguagesTools({
                '$stgLanguagesTools': holderLanguageTools,
                'background': background,
                '$wrpCbIsCustomizeLanguagesTools': wrpCustomize3,
                '$elesPreFromGroups': toggleLangCustomizeLabel
            });
            this._background_renderBackground_stgCharacteristics({
                '$stgCharacteristics': holderCharacteristics, 'background': background});
            this._background_hk_showCustomizingRules({'$stgRulesCustomize': holderRulesCustomize});
            this._hk_shared_doRenderBackground({'$dispBackground': newCol});
            if (!_0x3c9e9c) {
                this._state.background_pulseBackground = !this._state.background_pulseBackground;
            }
        };
        this._addHookBase('background_pulseBackground', renderBackground);
  
        const refresh = () => {
            const _0x3b9a0d = Object.keys(this.__state).filter(prop =>
                prop.startsWith('background_') && prop !== 'background_ixBackground').mergeMap(p => ({[p]: null}));

            this._proxyAssignSimple("state", _0x3b9a0d);
            const curBackground = this._data.background[this._state.background_ixBackground];

            if (UtilEntityBackground.isCustomBackground(curBackground)) {
                this._proxyAssignSimple('state', {
                    'background_isCustomizeSkills': true,
                    'background_isCustomizeLanguagesTools': true
                });
                wrpCustomize5.forEach(ele => ele.hideVe());
            }
            else {wrpCustomize5.forEach(ele => ele.showVe());}

            this._background_renderBackground_stgFeatures({'$stgFeatures': holderFeatures, 'background': curBackground});
            renderBackground();

            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': holderExpertise,
                'ent': curBackground,
                'propComp': "_compBackgroundExpertise",
                'propProficiencies': 'expertise',
                'title': "Expertise",
                'CompClass': Charactermancer_ExpertiseSelect,
                'fnGetExistingFvtt': Charactermancer_ExpertiseSelect.getExistingFvttFromActor.bind(Charactermancer_ExpertiseSelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': holderWepProf,
                'ent': curBackground,
                'propComp': "_compBackgroundWeaponProficiencies",
                'propProficiencies': "weaponProficiencies",
                'title': "Weapon Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ["system", 'traits', 'weaponProf'],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': holderArmorProf,
                'ent': curBackground,
                'propComp': "_compBackgroundArmorProficiencies",
                'propProficiencies': "armorProficiencies",
                'title': "Armor Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ['system', 'traits', "armorProf"],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': holderDamImm,
                'ent': curBackground,
                'propComp': "_compBackgroundDamageImmunity",
                'CompClass': Charactermancer_DamageImmunitySelect,
                'title': "Damage Immunity",
                'propRaceData': "immune",
                'propTraits': 'di'
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': holderDamRes,
                'ent': curBackground,
                'propComp': "_compBackgroundDamageResistance",
                'CompClass': Charactermancer_DamageResistanceSelect,
                'title': "Damage Resistance",
                'propRaceData': "resist",
                'propTraits': 'dr'
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': holderDamVul,
                'ent': curBackground,
                'propComp': "_compBackgroundDamageVulnerability",
                'CompClass': Charactermancer_DamageVulnerabilitySelect,
                'title': "Damage Vulnerability",
                'propRaceData': "vulnerable",
                'propTraits': 'dv'
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': holderConImm,
                'ent': curBackground,
                'propComp': "_compBackgroundConditionImmunity",
                'CompClass': Charactermancer_ConditionImmunitySelect,
                'title': "Condition Immunity",
                'propRaceData': "conditionImmune",
                'propTraits': 'ci'
            });
        };

        this._addHookBase("background_ixBackground", refresh);

        const holderFeatures = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderSkills = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderLanguages = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderTools = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderLanguageTools = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderWepProf = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderArmorProf = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderExpertise = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderDamImm = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderDamRes = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderDamVul = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderConImm = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderRulesCustomize = $$`<div class="ve-flex-col"></div>`.hideVe();
        const holderCharacteristics = $$`<div class="ve-flex-col"></div>`.hideVe();

        const renderCustomizeSkills = () => {
            const background = this._data.background[this._state.background_ixBackground];
            this._background_renderBackground_stgSkills({
                '$stgSkills': holderSkills,
                'background': background,
                '$wrpCbIsCustomizeSkills': wrpCustomize0
            });
        };

        this._addHookBase("background_isCustomizeSkills", renderCustomizeSkills);

        const renderCustomizeLanguagesTools = () => {
            const background = this._data.background[this._state.background_ixBackground];
            this._background_renderBackground_stgLanguages({
                '$stgLanguages': holderLanguages,
                'background': background,
                '$wrpCbIsCustomizeLanguagesTools': wrpCustomize1
            });
            this._background_renderBackground_stgTools({
                '$stgTools': holderTools,
                'background': background,
                '$wrpCbIsCustomizeLanguagesTools': wrpCustomize2
            });
            this._background_renderBackground_stgLanguagesTools({
                '$stgLanguagesTools': holderLanguageTools,
                'background': background,
                '$wrpCbIsCustomizeLanguagesTools': wrpCustomize3,
                '$elesPreFromGroups': toggleLangCustomizeLabel
            });
        };

        this._addHookBase('background_isCustomizeLanguagesTools', renderCustomizeLanguagesTools);
        const newCol = $$`<div class="ve-flex-col w-100"></div>`;

        $$`<div class="ve-flex w-100 h-100">
        <div class="ve-flex-col w-100 h-100 px-1 pt-1 overflow-y-auto ve-grow veapp__bg-foundry">
            <div class="bold mb-2">Select a Background</div>
            <div class="ve-flex-v-center btn-group w-100">${btnFilter}${ele_sel}</div>
            ${holderFeatures}
            ${holderSkills}
            ${holderLanguages}
            ${holderTools}
            ${holderLanguageTools}
            ${holderWepProf}
            ${holderArmorProf}
            ${holderExpertise}
            ${holderDamImm}
            ${holderDamRes}
            ${holderDamVul}
            ${holderConImm}
            ${holderCharacteristics}
        </div>

        <div class="vr-1"></div>

        <div class="ve-flex-col w-100 h-100 px-1 overflow-y-auto ve-grow veapp__bg-foundry">
            ${holderRulesCustomize}
            ${newCol}
        </div>
        </div>`.appendTo(parentDiv);
    }

    get modalFilterBackgrounds() {
      return this._modalFilterBackgrounds;
    }
    get ["compBackgroundFeatures"]() {
      return this._metaCompBackgroundFeatures?.["comp"];
    }
    get ["compBackgroundSkillProficiencies"]() {
      return this._compBackgroundSkillProficiencies;
    }
    get ["compBackgroundLanguageProficiencies"]() {
      return this._compBackgroundLanguageProficiencies;
    }
    get ['compBackgroundToolProficiencies']() {
      return this._compBackgroundToolProficiencies;
    }
    get ["compBackgroundLanguageToolProficiencies"]() {
      return this._compBackgroundLanguageToolProficiencies;
    }
    get ['compBackgroundCharacteristics']() {
      return this._compBackgroundCharacteristics;
    }
    get ["compBackgroundExpertise"]() {
      return this._compBackgroundExpertise;
    }
    get ["compBackgroundWeaponProficiencies"]() {
      return this._compBackgroundWeaponProficiencies;
    }
    get ["compBackgroundArmorProficiencies"]() {
      return this._compBackgroundArmorProficiencies;
    }
    get ["compBackgroundDamageImmunity"]() {
      return this._compBackgroundDamageImmunity;
    }
    get ["compBackgroundDamageResistance"]() {
      return this._compBackgroundDamageResistance;
    }
    get ["compBackgroundDamageVulnerability"]() {
      return this._compBackgroundDamageVulnerability;
    }
    get ["compBackgroundConditionImmunity"]() {
      return this._compBackgroundConditionImmunity;
    }
    get ['isCustomizeLanguagesTools']() {
      return this._state.background_isCustomizeLanguagesTools;
    }
    async pLoad() {
      await this._modalFilterBackgrounds.pPreloadHidden();
    }
    ['getFeatureCustomizedBackground_']({
      ix: _0x40e6e0,
      isAllowStub = true
    } = {}) {
      if (_0x40e6e0 != null) {
        if (~_0x40e6e0) {
          return this._data.background[_0x40e6e0];
        }
        if (!isAllowStub) {
          return null;
        }
        return DataConverterBackground.getBackgroundStub();
      }
      const _0x5d2446 = this._data.background[this._state.background_ixBackground];
      if (!_0x5d2446) {
        return isAllowStub ? DataConverterBackground.getBackgroundStub() : null;
      }
      const _0x40097d = MiscUtil.copy(_0x5d2446);
      if (!this._metaCompBackgroundFeatures?.['comp']) {
        return _0x40097d;
      }
      const _0x2ee9e8 = this._metaCompBackgroundFeatures.comp.getFormData();
      return _0x2ee9e8.data?.["background"];
    }
    getBackground_() {
      return this._data.background[this._state.background_ixBackground];
    }
    
    ["_background_renderBackground_$getWrpCbCustomize"](_0x43dcba) {
      return $$`<label class="ve-flex-v-center ml-auto"><span class="mr-1">Customize</span>${_0x43dcba}</label>`;
    }
    _background_renderBackground_stgFeatures({
      $stgFeatures: parentDiv,
      background: background
    }) {
      if (this._state.background_ixBackground === this._metaCompBackgroundFeatures?.["ixBackground"]) {return;}
      parentDiv.empty();
      if (background) {
        parentDiv.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Features</div>");
        const component = new Charactermancer_Background_Features({
          'background': background,
          'modalFilter': this._modalFilterBackgrounds
        });
        this._metaCompBackgroundFeatures = {
          'comp': component, 'ixBackground': this._state.background_ixBackground
        };
        component.render(parentDiv);
        component.addHookPulseFeatures(() => {
          this._state.background_pulseBackground = !this._state.background_pulseBackground;
        });
      }
      else { parentDiv.hideVe(); this._metaCompBackgroundFeatures = null; }
    }
    _background_renderBackground_stgSkills({
        $stgSkills: parentDiv,
        background: background,
        $wrpCbIsCustomizeSkills: wrapperCheckboxIsCustomizeSkills
    }) {
      wrapperCheckboxIsCustomizeSkills.detach();
      parentDiv.empty();
      this._parent.featureSourceTracker_.unregister(this._compBackgroundSkillProficiencies);
      if (background && background.skillProficiencies) {
        $$`<hr class="hr-2">
                  <div class="mb-2 split-v-center">
                      <div class="bold">Skill Proficiencies</div>
                      ${wrapperCheckboxIsCustomizeSkills}
                  </div>`.appendTo(parentDiv.showVe());

        //TEMPFIX
        //const existingFvtt = {'skillProficiencies': MiscUtil.get(this._actor, "_source", 'system', 'skills') };
        this._compBackgroundSkillProficiencies = new Charactermancer_OtherProficiencySelect({
          'featureSourceTracker': this._parent.featureSourceTracker_,
          //TEMPFIX 'existing': Charactermancer_OtherProficiencySelect.getExisting(existingFvtt),
          //TEMPFIX 'existingFvtt': existingFvtt,
          'available': Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies(this._state.background_isCustomizeSkills ?
             UtilActors.BG_SKILL_PROFS_CUSTOMIZE : background.skillProficiencies)
        });
        this._compBackgroundSkillProficiencies.render(parentDiv);
      }
      else { parentDiv.hideVe(); this._compBackgroundSkillProficiencies = null; }
    }
    _background_renderBackground_stgLanguages({
      $stgLanguages: parentDiv,
      background: background,
      $wrpCbIsCustomizeLanguagesTools: wrapperCheckboxIsCustomizeLanguagesTools
    }) {
      wrapperCheckboxIsCustomizeLanguagesTools.detach();
      parentDiv.empty();
      this._parent.featureSourceTracker_.unregister(this._compBackgroundLanguageProficiencies);
      if (background && background.languageProficiencies && !this._state.background_isCustomizeLanguagesTools) {
        $$`<hr class="hr-2">
                  <div class="mb-2 split-v-center">
                      <div class="bold">Language Proficiencies</div>
                      ${wrapperCheckboxIsCustomizeLanguagesTools}
                  </div>`.appendTo(parentDiv.showVe());
        //TEMPFIX const existingFvtt = {'languageProficiencies': MiscUtil.get(this._actor, '_source', 'system', "traits", "languages")};
        this._compBackgroundLanguageProficiencies = new Charactermancer_OtherProficiencySelect({
          'featureSourceTracker': this._parent.featureSourceTracker_,
          //TEMPFIX 'existing': Charactermancer_OtherProficiencySelect.getExisting(existingFvtt),
          //TEMPFIX 'existingFvtt': existingFvtt,
          'available': Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies(background.languageProficiencies)
        });
        this._compBackgroundLanguageProficiencies.render(parentDiv);
      }
      else { parentDiv.hideVe(); this._compBackgroundLanguageProficiencies = null; }
    }
    _background_renderBackground_stgTools({
      $stgTools: parentDiv,
      background: background,
      $wrpCbIsCustomizeLanguagesTools: wrapperCheckboxIsCustomizeLanguagesTools
    }) {
      wrapperCheckboxIsCustomizeLanguagesTools.detach();
      parentDiv.empty();
      this._parent.featureSourceTracker_.unregister(this._compBackgroundToolProficiencies);
      if (background && background.toolProficiencies && !this._state.background_isCustomizeLanguagesTools) {
        $$`<hr class="hr-2">
                  <div class="mb-2 split-v-center">
                      <div class="bold">Tool Proficiencies</div>
                      ${wrapperCheckboxIsCustomizeLanguagesTools}
                  </div>`.appendTo(parentDiv.showVe());
        const existingFvtt = {'toolProficiencies': MiscUtil.get(this._actor, '_source', "system", 'tools')};
        this._compBackgroundToolProficiencies = new Charactermancer_OtherProficiencySelect({
          'featureSourceTracker': this._parent.featureSourceTracker_,
          //TEMPFIX 'existing': Charactermancer_OtherProficiencySelect.getExisting(existingFvtt),
          //TEMPFIX 'existingFvtt': existingFvtt,
          'available': Charactermancer_OtherProficiencySelect.getMappedToolProficiencies(background.toolProficiencies)
        });
        this._compBackgroundToolProficiencies.render(parentDiv);
      }
      else {  parentDiv.hideVe(); this._compBackgroundToolProficiencies = null;}
    }
    _background_renderBackground_stgLanguagesTools({
      $stgLanguagesTools: parentDiv,
      background: background,
      $wrpCbIsCustomizeLanguagesTools: wrapperCheckboxIsCustomizeLanguagesTools,
      $elesPreFromGroups: elesPreFromGroups
    }) {
      wrapperCheckboxIsCustomizeLanguagesTools.detach();
      Object.values(elesPreFromGroups).forEach(e => e.detach());
      parentDiv.empty();
      this._parent.featureSourceTracker_.unregister(this._compBackgroundLanguageToolProficiencies);
      if (background && (background.skillProficiencies || background.toolProficiencies) && this._state.background_isCustomizeLanguagesTools) {
        $$`<hr class="hr-2">
                  <div class="mb-2 split-v-center">
                      <div class="bold">Language &amp; Tool Proficiencies</div>
                      ${wrapperCheckboxIsCustomizeLanguagesTools}
                  </div>`.appendTo(parentDiv.showVe());
        //TEMPFIX
        /* const existingFvtt = {
          'languageProficiencies': MiscUtil.get(this._actor, "_source", 'system', "traits", "languages"),
          'toolProficiencies': MiscUtil.get(this._actor, "_source", 'system', "tools")
        }; */
        this._compBackgroundLanguageToolProficiencies = new Charactermancer_OtherProficiencySelect({
          'featureSourceTracker': this._parent.featureSourceTracker_,
          //TEMPFIX 'existing': Charactermancer_OtherProficiencySelect.getExisting(existingFvtt),
          //TEMPFIX 'existingFvtt': existingFvtt,
          'available': MiscUtil.copy(UtilActors.LANG_TOOL_PROFS_CUSTOMIZE),
          '$elesPreFromGroups': elesPreFromGroups
        });
        this._compBackgroundLanguageToolProficiencies.render(parentDiv);
      }
      else { parentDiv.hideVe(); this._compBackgroundLanguageToolProficiencies = null; }
    }
    ["_background_hk_showCustomizingRules"]({
      $stgRulesCustomize: _0x77fbe7
    }) {
      const _0x283f3d = this._data.background[this._state.background_ixBackground];
      _0x77fbe7.empty();
      if (_0x283f3d && (this._state.background_isCustomizeSkills || this._state.background_isCustomizeLanguagesTools || this._metaCompBackgroundFeatures?.["comp"] && this._metaCompBackgroundFeatures.comp?.["mode"] !== Charactermancer_Background_Features._MODE_DEFAULT)) {
        $$(_0x77fbe7.showVe())`
                  <div class="w-100">${Renderer.get().setFirstSection(true).render(ActorCharactermancerBackground._ENTRY_CUSTOMIZING, -0x1)}</div>
                  <hr class="hr-3 hr--heavy">`;
      } else {
        _0x77fbe7.hideVe();
      }
    }
    _background_renderBackground_stgCharacteristics({
      $stgCharacteristics: parentDiv,
      background: background
    }) {
      parentDiv.empty();
      if (background) {
        const wrpHeaderControls = $("<div class=\"ve-flex-v-center\"></div>");
        $$`<hr class="hr-2">
                  <div class="split-v-center mb-2">
                      <div class="bold">Characteristics</div>
                      ${wrpHeaderControls}
                  </div>`.appendTo(parentDiv.showVe());
        this._compBackgroundCharacteristics = new Charactermancer_Background_Characteristics({
          'entries': background.entries,
          '$wrpHeaderControls': wrpHeaderControls
        });
        this._compBackgroundCharacteristics.render(parentDiv);
      }
      else { parentDiv.hideVe(); this._compBackgroundCharacteristics = null; }
    }
    _getRenderableBackground() {
      const bk = this._data.background[this._state.background_ixBackground];
      const background = MiscUtil.copy(bk);
      const walker = MiscUtil.getWalker({
        'keyBlocklist': MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
        'isAllowDeleteArrays': true,
        'isAllowDeleteObjects': true
      });
      background.entries = walker.walk(background.entries || [], {
        'array': ar => {
          ar = ar.filter(_0x2f5ea1 => _0x2f5ea1 != null && !_0x2f5ea1?.["data"]?.["isFeature"]);
          if (!ar.length) {
            return undefined;
          }
          return ar;
        },
        'object': ar => {
          if (ar.type === "list") {
            ar.items = (ar.items || []).filter(_0x48b331 => {
              const _0x586aa6 = (_0x48b331.name || '').trim().toLowerCase();
              return !(_0x48b331.type === "item" && (/^skill/.test(_0x586aa6) || /^language/.test(_0x586aa6) || /^tool/.test(_0x586aa6)));
            });
            if (!ar.items.length) {
              return undefined;
            }
          }
          return ar;
        }
      });
      return background;
    }
    _hk_shared_doRenderBackground({
      $dispBackground: parentDiv
    }) {
      const background = this._data.background[this._state.background_ixBackground];
      parentDiv.empty();
      if (background) {
        parentDiv.append(Renderer.hover.$getHoverContent_stats(UrlUtil.PG_BACKGROUNDS, this._getRenderableBackground()));
      }
    }
    _getDefaultState() {
      return {
        'background_ixBackground': null,
        'background_isCustomizeSkills': false,
        'background_isCustomizeLanguagesTools': false,
        'background_pulseBackground': false
      };
    }
}
ActorCharactermancerBackground._ENTRY_CUSTOMIZING = {
'type': 'entries',
'name': "Customizing a Background",
'page': 0x7d,
'source': Parser.SRC_PHB,
'entries': ["You might want to tweak some of the features of a background so it better fits your character or the campaign setting. To customize a background, you can replace one feature with any other one, choose any two skills, and choose a total of two tool proficiencies or languages from the sample backgrounds. [...] Finally, choose two personality traits, one ideal, one bond, and one flaw.", "If you can't find a feature that matches your desired background, work with your DM to create one."]
};

class Charactermancer_Background_Characteristics extends BaseComponent {
    static async pGetUserInput({entries}={}) {
        if (!entries || !entries.length)
            return {
                isFormComplete: true,
                data: {}
            };

        const comp = new this({
            entries
        });
        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            width: Util.getMaxWindowWidth(640),
            height: Util.getMaxWindowHeight(),
        });
    }

    static async pFillActorCharacteristicsData(entries, actUpdate, opts) {
        if (!entries || !entries.length)
            return;

        const formData = await this.pGetUserInput({
            entries
        });
        if (!formData)
            return opts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.applyFormDataToActorUpdate(actUpdate, formData);
    }

    static applyFormDataToActorUpdate(actUpdate, formData) {
        MiscUtil.getOrSet(actUpdate, "system", "details", {});
        Charactermancer_Background_Characteristics._PROP_METAS.forEach(propMeta=>{
            const propDetails = Charactermancer_Background_Characteristics._PROP_TO_ACTOR_DETAILS_PROP[propMeta.prop];
            actUpdate.system.details[propDetails] = [(actUpdate.system.details[propDetails] || "").trim(), ...[...new Array(propMeta.count || 1)].map((_,i)=>{
                const {propValue} = this._getProps(propMeta.prop, i);
                if (!formData.data[propValue])
                    return null;
                return formData.data[propValue];
            }
            ), ].filter(Boolean).join("\n\n");
        }
        );
    }

    static applyExistingActorDataToActorUpdate(actUpdate, actor) {
        const tgt = MiscUtil.getOrSet(actUpdate, "system", "details", {});

        Object.keys(Charactermancer_Background_Characteristics._PROP_TO_ACTOR_DETAILS_PROP).forEach(propDetails=>{
            tgt[propDetails] = MiscUtil.get(actor, "system", "details", propDetails);
        }
        );
    }

    constructor(opts) {
        opts = opts || {};
        super();
        this._tables = Charactermancer_Background_Characteristics._getCharacteristicTables(opts.entries);
        this._$wrpHeaderControls = opts.$wrpHeaderControls;

        Object.assign(this.__state, Charactermancer_Background_Characteristics._PROP_METAS.mergeMap(propMeta=>({
            [Charactermancer_Background_Characteristics._getProps(propMeta.prop).propMode]: this._tables[propMeta.prop] != null ? "standard" : "custom"
        })), );
    }

    static _getProps(prop, ix) {
        return {
            propValue: `${prop}_${ix}_value`,
            propMode: `${prop}_mode`,
        };
    }

    static _getCpyTableCell(tbl, ixRow) {
        const cell = tbl.rows[ixRow]?.[1];
        if (!cell) {
            ui.notifications.error(`No cell found for row ${ixRow}!`);
            return null;
        }
        return Renderer.stripTags(MiscUtil.copy(cell));
    }

    get modalTitle() {
        return `Characteristics`;
    }

    render($wrp) {
        const $wrpsProp = Charactermancer_Background_Characteristics._PROP_METAS.map((propMeta,ixPt)=>{
            const count = propMeta.count || 1;
            const {propMode} = this.constructor._getProps(propMeta.prop);

            let $stgToggleMode;
            let $stgStandard;
            if (this._tables[propMeta.prop]) {
                const $btnToggleMode = $(`<button class="btn btn-default btn-xs" title="Show/Hide Table">View Table</button>`)
                .click(()=>this._state[propMode] = this._state[propMode] === "custom" ? "standard" : "custom");

                $stgToggleMode = $$`<div class="ve-flex-v-center">
					${$btnToggleMode}
				</div>`;

                const tbl = this._tables[propMeta.prop];

                const $rendered = Vetools.withCustomDiceRenderingPatch(()=>{
                    const $rendered = $(`${Renderer.get().render(tbl)}`);

                    $rendered.find(`[data-plut-temp-dice]`).each((i,e)=>{
                        const $e = $(e);

                        const $btnsRoller = [...new Array(count)].map((_,i)=>{
                            return $(`<button class="btn btn-xs btn-default">Roll${count > 1 ? ` ${Parser.getOrdinalForm(i + 1)}` : ""}</button>`).click(async()=>{
                                const {propValue} = this.constructor._getProps(propMeta.prop, i);
                                const headerRowMetas = Renderer.table.getHeaderRowMetas(tbl);

                                let roll;
                                try {
                                    roll = new Roll(Renderer.stripTags(headerRowMetas.last()[0]));
                                    await roll.evaluate({async: true});
                                    roll.toMessage({sound: null});
                                }
                                catch (e) {return ui.notifications.error(`Failed to roll dice! ${VeCt.STR_SEE_CONSOLE}`);}

                                const cell = tbl.rows[roll.total - 1]?.[1];
                                if (!cell){return ui.notifications.error(`No result found for roll of ${roll.total}!`);}

                                this._state[propValue] = Renderer.stripTags(MiscUtil.copy(cell));
                            });
                        });

                        const $wrpBtnsRoller = $$`<div class="ve-flex-vh-center btn-group">${$btnsRoller}</div>`;

                        $e.replaceWith($wrpBtnsRoller);
                    });

                    $rendered.find(`[data-roll-min]`).each((i,e)=>{
                        const $e = $(e);
                        const html = $e.html();
                        $(`<div class="render-roller">${html}</div>`).click(evt=>{
                            const {propValue} = this.constructor._getProps(propMeta.prop, evt.ctrlKey ? 1 : 0);
                            this._state[propValue] = this.constructor._getCpyTableCell(tbl, i);
                        }
                        ).title(count > 1 ? `Left-click to set the first field; CTRL-click to set the second field.` : null).appendTo($e.empty());
                    });
                    return $rendered;
                }, ()=>{ return `<span data-plut-temp-dice="true"></span>`; }, );

                $stgStandard = $$`<div class="ve-flex-col w-100 ve-small">${$rendered}</div>`;

                const hkMode = ()=>{
                    $btnToggleMode.toggleClass("active", this._state[propMode] === "standard");
                    $stgStandard.toggleVe(this._state[propMode] === "standard");
                }
                ;
                this._addHookBase(propMode, hkMode);
                hkMode();
            }

            const $iptsText = [...new Array(count)].map((_,i)=>ComponentUiUtil.$getIptEntries(this, this.constructor._getProps(propMeta.prop, i).propValue).addClass("resize-vertical"));

            if (count !== 1) {
                const iptsText = $iptsText.map(it=>it[0]);
                const resizeObserver = new ResizeObserver(entries=>{
                    if (entries.length !== 1)
                        return;
                    const eleResized = entries[0].target;
                    iptsText.filter(ipt=>ipt !== eleResized).forEach(ipt=>ipt.style.height = eleResized.style.height);
                });
                iptsText.forEach(ipt=>resizeObserver.observe(ipt));
            }

            return $$`<div class="ve-flex-col ${ixPt < Charactermancer_Background_Characteristics._PROP_METAS.length - 1 ? `mb-2` : ""}">
				<div class="split-v-center mb-1">
					<div>${Charactermancer_Background_Characteristics._PROP_TO_FULL[propMeta.prop]}:</div>
					${$stgToggleMode}
				</div>

				${$stgStandard}

				<div class="ve-flex">${$iptsText}</div>
			</div>`;
        });

        const hasAnyTable = !!Object.keys(this._tables).length;
        let $btnToggleAllTables;
        if (hasAnyTable) {
            $btnToggleAllTables = $(`<button class="btn btn-default btn-xs">Hide Tables</button>`).click(()=>{
                const isDoHide = $btnToggleAllTables.text() === "Hide Tables";

                this._proxyAssignSimple("state", Charactermancer_Background_Characteristics._PROP_METAS.mergeMap(propMeta=>({
                    [Charactermancer_Background_Characteristics._getProps(propMeta.prop).propMode]: this._tables[propMeta.prop] != null && !isDoHide ? "standard" : "custom"
                })), );

                $btnToggleAllTables.text(isDoHide ? "Show Tables" : "Hide Tables");
            });

            const hkAllHidden = ()=>{
                const allModes = Charactermancer_Background_Characteristics._PROP_METAS.filter(propMeta=>this._tables[propMeta.prop]).map(propMeta=>this._state[Charactermancer_Background_Characteristics._getProps(propMeta.prop).propMode] === "custom");

                if (allModes.every(Boolean))
                    $btnToggleAllTables.text("Show Tables");
                else if (allModes.every(it=>!it))
                    $btnToggleAllTables.text("Hide Tables");
            };
            Charactermancer_Background_Characteristics._PROP_METAS.map(propMeta=>Charactermancer_Background_Characteristics._getProps(propMeta.prop).propMode).forEach(propMode=>this._addHookBase(propMode, hkAllHidden));
            hkAllHidden();
        }

        let $stgHeaderControls;
        if (!this._$wrpHeaderControls && hasAnyTable) {
            $stgHeaderControls = $$`<div class="mb-2 ve-flex-h-right">${$btnToggleAllTables}</div>`;
        } else if (this._$wrpHeaderControls && hasAnyTable) {
            this._$wrpHeaderControls.append($btnToggleAllTables);
        }

        $$`
			${$stgHeaderControls}
			${$wrpsProp}
		`.appendTo($wrp);
    }

    pGetFormData() {
        const rendered = Charactermancer_Background_Characteristics._PROP_METAS.map(propMeta=>[...new Array(propMeta.count || 1)].map((_,i)=>this.constructor._getProps(propMeta.prop, i).propValue)).flat().mergeMap(propValue=>({
            [propValue]: UiUtil.getEntriesAsText(this._state[propValue])
        }));

        return {
            isFormComplete: Object.values(rendered).every(txt=>txt.trim()),
            data: rendered,
        };
    }

    _getDefaultState() {
        return Charactermancer_Background_Characteristics._PROP_METAS.map(propMeta=>[...new Array(propMeta.count || 1)].map((_,i)=>this.constructor._getProps(propMeta.prop, i).propValue)).flat().mergeMap(propValue=>({
            [propValue]: ""
        }));
    }

    static _getCharacteristicTables(entries) {
        if (!entries)
            return {};

        const out = {};

        UtilDataConverter.WALKER_READONLY_GENERIC.walk(entries, {
            object: (obj)=>{
                if (obj.type !== "table")
                    return;

                const headerRowMetas = Renderer.table.getHeaderRowMetas(obj);
                if (headerRowMetas?.last()?.length !== 2 || Renderer.table.getAutoConvertedRollMode(obj) !== RollerUtil.ROLL_COL_STANDARD)
                    return;

                const captionFlat = headerRowMetas.last()[1].toLowerCase().replace(/\s+/g, "");
                const mCaption = /^(personalitytrait|ideal|bond|flaw)s?$/i.exec(captionFlat);
                if (!mCaption)
                    return;

                out[captionFlat] = MiscUtil.copy(obj);
            }
            ,
        }, );

        return out;
    }
}
Charactermancer_Background_Characteristics._PROP_METAS = [{
    prop: "personalitytrait",
    count: 2
}, {
    prop: "ideal"
}, {
    prop: "bond"
}, {
    prop: "flaw"
}, ];
Charactermancer_Background_Characteristics._PROP_TO_FULL = {
    "personalitytrait": "Personality Traits",
    "ideal": "Ideal",
    "bond": "Bond",
    "flaw": "Flaw",
};
Charactermancer_Background_Characteristics._PROP_TO_ACTOR_DETAILS_PROP = {
    "personalitytrait": "trait",
    "ideal": "ideal",
    "bond": "bond",
    "flaw": "flaw",
};

class Charactermancer_Background_Features extends BaseComponent {
    

    constructor(opts) {
        opts = opts || {};
        super();

        this._background = opts.background;
        if (UtilEntityBackground.isCustomBackground(opts.background))
            this._state.mode = Charactermancer_Background_Features._MODE_OTHER_BACKGROUND;

        this._modalFilter = opts.modalFilter;
    }
    render($wrp) {
        const modesAvail = [UtilEntityBackground.isCustomBackground(this._background) ? null : Charactermancer_Background_Features._MODE_DEFAULT, Charactermancer_Background_Features._MODE_OTHER_BACKGROUND, Charactermancer_Background_Features._MODE_MANUAL, ].filter(mode=>mode != null);

        const $selMode = ComponentUiUtil.$getSelEnum(this, "mode", {
            values: modesAvail,
            fnDisplay: v=>Charactermancer_Background_Features._MODE_TO_FULL[v],
        }, );
        this._addHookBase("mode", ()=>this._state.pulseFeatures = !this._state.pulseFeatures);

        const $btnAddManual = $(`<button class="btn btn-xs btn-5et ml-1"><span class="glyphicon glyphicon-plus"></span> Add Feature</button>`).click(()=>{
            const nxt = this._getDefaultState_manualEntryMeta();
            this._state.manualEntryMetas = [...this._state.manualEntryMetas, nxt];
        });
        const hkMode = ()=>$btnAddManual.toggleVe(this._state.mode === Charactermancer_Background_Features._MODE_MANUAL);
        this._addHookBase("mode", hkMode);
        hkMode();

        const $stgDefault = this._render_default();
        const $stgOther = this._render_other();
        const $stgManual = this._render_manual();

        $$`
			<div class="ve-flex-v-center mb-1">
				${$selMode}
				${$btnAddManual}
			</div>
			${$stgDefault}
			${$stgOther}
			${$stgManual}
		`.appendTo($wrp);
    }

    static getFeatureEntries(bg) {
        return (bg?.entries || []).filter(it=>it.data?.isFeature).map(ent=>{
            const cpyEnt = MiscUtil.copy(ent);
            if (cpyEnt.name)
                cpyEnt.name = cpyEnt.name.replace(/^.*?:\s*/, "");
            cpyEnt.source = cpyEnt.source || bg.source;
            cpyEnt.backgroundName = bg.name;
            cpyEnt.backgroundSource = bg.source;
            cpyEnt.srd = !!bg.srd;
            cpyEnt.basicRules = !!bg.basicRules;
            cpyEnt.page = bg.page;
            cpyEnt.__prop = "backgroundFeature";
            return cpyEnt;
        }
        );
    }

    get modalTitle() {
        return `Customize Background: Features`;
    }

    get mode() {
        return this._state.mode;
    }

    get ixBackgroundOther() {
        return this._state.ixBackgroundOther;
    }

    addHookPulseFeatures(hk) {
        this._addHookBase("pulseFeatures", hk);
    }

    _render_default() {
        const $stg = $$`<div class="ve-flex-col mt-1">
			<div class="w-100">${Vetools.withUnpatchedDiceRendering(()=>Renderer.get().render({
            type: "entries",
            entries: this.constructor.getFeatureEntries(this._background)
        }))}</div>
		</div>`;

        const hkMode = ()=>$stg.toggleVe(this._state.mode === Charactermancer_Background_Features._MODE_DEFAULT);
        this._addHookBase("mode", hkMode);
        hkMode();

        return $stg;
    }

    _getOtherBackground() {
        //TEMPFIX return this._modalFilter.allData[this._state.ixBackgroundOther];
        return ContentGetter.getBackgrounds()[this._state.ixBackgroundOther];
    }

    _render_other() {
        const $btnSelect = $(`<button class="btn btn-default btn-5et w-100 mr-2 mb-2">Choose Background</button>`).click(async()=>{
            const selecteds = await this._modalFilter.pGetUserSelection();
            if (selecteds == null || !selecteds.length){return;}

            this._state.ixBackgroundOther = selecteds[0]?.ix;
        });

        const $dispOther = $(`<div class="w-100"></div>`);
        const hkOther = ()=>{
            const otherBackground = this._getOtherBackground();
            if (!otherBackground) {
                $dispOther.html(`<i class="ve-muted">Select an alternate background, whose feature(s) will replace your current background's feature(s).</i>`);
                return;
            }

            const otherBackgroundFeatureEntries = this.constructor.getFeatureEntries(otherBackground);
            $dispOther.html(Vetools.withUnpatchedDiceRendering(()=>Renderer.get().render(otherBackgroundFeatureEntries?.length ? {
                type: "entries",
                entries: otherBackgroundFeatureEntries
            } : {
                type: "entries",
                entries: ["{@note (No feature(s)).}"]
            })));
            this._state.pulseFeatures = !this._state.pulseFeatures;
        };
        this._addHookBase("ixBackgroundOther", hkOther);
        hkOther();

        const $stg = $$`<div class="ve-flex-col mt-1">
			${$btnSelect}
			${$dispOther}
		</div>`;

        const hkMode = ()=>$stg.toggleVe(this._state.mode === Charactermancer_Background_Features._MODE_OTHER_BACKGROUND);
        this._addHookBase("mode", hkMode);
        hkMode();

        return $stg;
    }

    _render_manual() {
        const $dispNoRows = $(`<div class="italic ve-text-center ve-muted my-1">No features.</div>`);
        const $wrpRows = $(`<div class="ve-flex-col"></div>`);

        const hkManualMetas = ()=>{
            this._renderCollection({
                prop: "manualEntryMetas",
                fnDeleteExisting: ()=>{
                    this._state.pulseFeatures = !this._state.pulseFeatures;
                }
                ,
                fnUpdateExisting: (renderedMeta,featureMeta)=>{
                    renderedMeta.comp._proxyAssignSimple("state", featureMeta.data, true);
                    this._state.pulseFeatures = !this._state.pulseFeatures;
                }
                ,
                fnGetNew: featureMeta=>{
                    const comp = BaseComponent.fromObject(featureMeta.data, "*");
                    comp._addHookAll("state", ()=>{
                        featureMeta.data = comp.toObject("*");
                        this._triggerCollectionUpdate("manualEntryMetas");
                    }
                    );

                    const $iptName = ComponentUiUtil.$getIptStr(comp, "name");

                    const $iptText = ComponentUiUtil.$getIptEntries(comp, "entries");

                    const $btnDelete = $(`<button class="btn btn-5et btn-xs btn-danger ml-1" title="Delete"><span class="glyphicon glyphicon-trash"></span></button>`).click(()=>this._state.manualEntryMetas = this._state.manualEntryMetas.filter(it=>it !== featureMeta));

                    const $wrpRow = $$`<div class="ve-flex-col py-1 w-100 stripe-even">
						<div class="split-v-center mb-1">
							<label class="ve-flex-v-center w-100"><div class="mr-1 text-right pr-1 no-shrink w-50p">Name</div>${$iptName}</label>
							${$btnDelete}
						</div>
						<label class="ve-flex-v-center w-100"><div class="mr-1 text-right pr-1 no-shrink w-50p">Text</div>${$iptText}</label>
					</div>`.appendTo($wrpRows);

                    return {
                        comp,
                        $wrpRow,
                    };
                }
                ,
            });

            $dispNoRows.toggleVe(!this._state.manualEntryMetas?.length);
        }
        ;
        hkManualMetas();
        this._addHookBase("manualEntryMetas", hkManualMetas);

        const $stg = $$`<div class="ve-flex-col">
			<hr class="hr-1">
			${$dispNoRows}
			${$wrpRows}
		</div>`;

        const hkMode = ()=>$stg.toggleVe(this._state.mode === Charactermancer_Background_Features._MODE_MANUAL);
        this._addHookBase("mode", hkMode);
        hkMode();

        return $stg;
    }

    getFormData() {
        let isComplete = true;
        const entries = [];
        const background = MiscUtil.copy(this._background);

        const fromFeature = Object.entries(background.fromFeature || {}).filter(([,v])=>v).map(([k])=>k);

        switch (this._state.mode) {
        case Charactermancer_Background_Features._MODE_DEFAULT:
            {
                entries.push(...this.constructor.getFeatureEntries(this._background));
                break;
            }
        case Charactermancer_Background_Features._MODE_OTHER_BACKGROUND:
            {
                const otherBackground = this._getOtherBackground();

                if (!otherBackground) {
                    isComplete = false;
                    fromFeature.forEach(k=>delete background[k]);
                    break;
                }

                entries.push(...this.constructor.getFeatureEntries(otherBackground));

                this._getFormData_doMergeOtherBackground({
                    background,
                    otherBackground,
                    fromFeature
                });

                break;
            }
        case Charactermancer_Background_Features._MODE_MANUAL:
            {
                const ents = this._state.manualEntryMetas.filter(({data})=>data.entries && data.entries.length).map(({data})=>{
                    data = MiscUtil.copy(data);
                    data.name = data.name || "(Unnamed Feature)";
                    data.type = "entries";
                    return data;
                }
                );

                if (!ents.length)
                    isComplete = false;

                entries.push(...ents);

                fromFeature.forEach(k=>delete background[k]);

                break;
            }
        }

        return {
            isFormComplete: isComplete,
            data: {
                entries,
                isCustomize: this._state.mode !== Charactermancer_Background_Features._MODE_DEFAULT,
                background,
            },
        };
    }

    _getFormData_doMergeOtherBackground({background, otherBackground, fromFeature}) {
        fromFeature.forEach(k=>{
            if (!otherBackground[k])
                return delete background[k];
            background[k] = MiscUtil.copy(otherBackground[k]);
        }
        );

        const fromFeatureOtherBackground = Object.entries(otherBackground.fromFeature || {}).filter(([,v])=>v).map(([k])=>k);
        fromFeatureOtherBackground.forEach(prop=>{
            if (!otherBackground[prop])
                return;
            if (!background[prop]) {
                background[prop] = MiscUtil.copy(otherBackground[prop], {
                    isSafe: true
                });
                return;
            }

            switch (prop) {
            default:
                {
                    const typeA = typeof background[prop];
                    const typeB = typeof otherBackground[prop];

                    if (typeA !== typeB || (typeA === "object" && (Array.isArray(background[prop]) !== Array.isArray(otherBackground[prop])))) {
                        return;
                    }

                    if (typeA !== "object")
                        return;

                    if (Array.isArray(background[prop])) {
                        this._getFormData_doMergeOtherBackground_array({
                            background,
                            otherBackground,
                            prop
                        });
                        return;
                    }

                    this._getFormData_doMergeOtherBackground_object({
                        background,
                        otherBackground,
                        prop
                    });
                }
            }
        }
        );
    }

    _getFormData_doMergeOtherBackground_array({background, otherBackground, prop}) {
        switch (prop) {
        case "additionalSpells":
            {
                if (background[prop].length !== 1 || background[prop].length !== otherBackground[prop].length)
                    return;

                Object.entries(otherBackground[prop][0]).forEach(([addSpellK,addSpellV])=>{
                    if (!["innate", "known", "prepared", "expanded"].includes(addSpellK)) {
                        console.warn(...LGT, `Could not merge additionalSpell property "${addSpellK}"--no merge strategy defined!`);
                        return;
                    }

                    if (!background[prop][0][addSpellK])
                        background[prop][0][addSpellK] = {};

                    Object.entries(addSpellV).forEach(([kLevel,spellList])=>{
                        background[prop][0][addSpellK][kLevel] = background[prop][0][addSpellK][kLevel] || [];
                        background[prop][0][addSpellK][kLevel].push(...spellList);
                    }
                    );
                }
                );

                break;
            }

        case "feats":
            {
                if (background[prop].length !== 1 || background[prop].length !== otherBackground[prop].length)
                    return;

                const out = {};
                Object.entries(background[prop][0]).forEach(([k,v])=>out[k] = (out[k] || 0) + Number(v));
                Object.entries(otherBackground[prop][0]).forEach(([k,v])=>out[k] = (out[k] || 0) + Number(v));
                background[prop][0] = out;

                break;
            }

        default:
            {
                background[prop] = [...background[prop], ...otherBackground[prop]].unique();
            }
        }
    }

    _getFormData_doMergeOtherBackground_object({background, otherBackground, prop}) {
        switch (prop) {
        default:
            Object.assign(background[prop], otherBackground[prop]);
        }
    }

    pGetFormData() {
        return this.getFormData();
    }

    _getDefaultState_manualEntryMeta() {
        return {
            id: CryptUtil.uid(),
            data: {
                name: "",
                entries: [],
            },
        };
    }

    _getDefaultState() {
        return {
            mode: Charactermancer_Background_Features._MODE_DEFAULT,

            ixBackgroundOther: null,

            manualEntryMetas: [this._getDefaultState_manualEntryMeta()],

            pulseFeatures: false,
        };
    }

    static async pGetUserInput({background, modalFilter, ...opts}={}) {
        const comp = new this({
            background,
            modalFilter
        });
        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            width: Util.getMaxWindowWidth(640),
            height: Util.getMaxWindowHeight(480),
            ...opts,
        });
    }
}
Charactermancer_Background_Features._MODE_DEFAULT = 0;
Charactermancer_Background_Features._MODE_OTHER_BACKGROUND = 1;
Charactermancer_Background_Features._MODE_MANUAL = 2;

Charactermancer_Background_Features._MODE_TO_FULL = {
    [Charactermancer_Background_Features._MODE_DEFAULT]: "Add Features from This Background",
    [Charactermancer_Background_Features._MODE_OTHER_BACKGROUND]: "Customize your Background: Add Feature(s) from Another Background",
    [Charactermancer_Background_Features._MODE_MANUAL]: "Customize your Background: Add Custom Feature(s)",
};

//#endregion

//#region Charactermancer Starting Equipment
class ActorCharactermancerEquipment extends ActorCharactermancerBaseComponent {
    constructor(parentInfo) {
      parentInfo = parentInfo || {};
      super();
      this._actor = parentInfo.actor;
      this._data = parentInfo.data;
      this._parent = parentInfo.parent;
      this._tabEquipment = parentInfo.tabEquipment;
      this._tabShop = parentInfo.tabShop;
      const {
        compCurrency: compCurrency,
        compDefault: compDefault,
        compGold: compGold
      } = Charactermancer_StartingEquipment.getComponents(this._actor, {
        'itemDatas': { 'item': this._data.item },
        'fnDoShowShop': () => this._parent.activeTab_ = this._tabShop
      });
      this._compEquipmentCurrency = compCurrency;
      this._compEquipmentStartingDefault = compDefault;
      this._compEquipmentShopGold = compGold;
    }

    async pRenderStarting() {
        const wrpTab = this._tabEquipment?.$wrpTab;
        if (!wrpTab) { return; }

        const redraw = () => {
            const primaryClass = this._parent.compClass.class_getPrimaryClass();
            const customizedBackground = this._parent.compBackground.getFeatureCustomizedBackground_({ 'isAllowStub': false });
            const startingEquipment = MiscUtil.copy(primaryClass?.startingEquipment || {});
            //Check if we should push more options to choose from by looking at the background
            if ((!primaryClass || primaryClass && !primaryClass.startingEquipment || primaryClass && primaryClass.startingEquipment.additionalFromBackground)
            && customizedBackground?.startingEquipment?.length) {
            startingEquipment.defaultData = startingEquipment.defaultData || [];
            startingEquipment.defaultData.push(...MiscUtil.copy(customizedBackground.startingEquipment));
            }

            //Let our components know what we're working with
            this._compEquipmentCurrency.startingEquipment = startingEquipment;
            this._compEquipmentStartingDefault.equiSpecialSource = customizedBackground?.source || primaryClass?.source || null;
            this._compEquipmentStartingDefault.equiSpecialPage = customizedBackground?.page || primaryClass?.page || null;
        };

        this._parent.compClass.addHookBase('class_pulseChange', redraw);
        this._parent.compBackground.addHookBase("background_ixBackground", redraw);
        redraw();
        await this._compEquipmentStartingDefault.pRender(wrpTab);
    }
    async pRenderShop() {
    const wrpTab = this._tabShop?.$wrpTab;
    if (!wrpTab) {
        return;
    }
    await this._compEquipmentShopGold.pRender(wrpTab);
    }

    get compEquipmentCurrency() {
      return this._compEquipmentCurrency;
    }
    get compEquipmentStartingDefault() {
      return this._compEquipmentStartingDefault;
    }
    get compEquipmentShopGold() {
      return this._compEquipmentShopGold;
    }
   
    isStandardStartingEquipmentActive_() {
      return this._compEquipmentCurrency.isStandardStartingEquipmentActive();
    }
}

//TEMPFIX
class Charactermancer_StartingEquipment // extends Application 
{

    constructor(opts) {
        opts = opts || {};

        const compCurrency = opts.actor ? Charactermancer_StartingEquipment.Currency.fromActor(opts.actor, {
            isStandalone: !!opts.isStandalone
        }) : new Charactermancer_StartingEquipment.Currency({
            isStandalone: !!opts.isStandalone
        });
        const compDefault = new Charactermancer_StartingEquipment.ComponentDefault({
            ...opts,
            compCurrency,
            fnDoShowShop: ()=>{
                this._mode = "gold";
                this._doHandleModeSwitch();
            }
        });
        const compGold = new Charactermancer_StartingEquipment.ComponentGold({
            ...opts,
            compCurrency
        });

        if (opts.startingEquipment)
            compCurrency.startingEquipment = opts.startingEquipment;
        if (opts.equiSpecialSource)
            compDefault.equiSpecialSource = opts.equiSpecialSource;
        if (opts.equiSpecialPage)
            compDefault.equiSpecialPage = opts.equiSpecialPage;

            //TEMPFIX
        /* super({
            title: `${compCurrency.rollableExpressionGold ? `Starting ` : ""}Equipment${opts.appSubTitle ? `\u2014${opts.appSubTitle}` : ""}${opts.actor ? ` (Actor "${opts.actor.name}")` : ""}`,
            template: `${SharedConsts.MODULE_LOCATION}/template/ImportListCharacterEquipment.hbs`,
            width: Util.getMaxWindowWidth(1000),
            height: Util.getMaxWindowHeight(),
            resizable: true,
        });
 */
        this._compCurrency = compCurrency;
        this._compDefault = compDefault;
        this._compGold = compGold;

        this._isStandalone = opts.isStandalone;

        this._cntModesAvailable = Number(this._compDefault.isAvailable) + Number(this._compGold.isAvailable);

        if (this._cntModesAvailable) {
            this._resolve = null;
            this._reject = null;
            this._pUserInput = new Promise((resolve,reject)=>{
                this._resolve = resolve;
                this._reject = reject;
            }
            );
        }

        this._mode = null;
        this._$wrpTabs = null;
        this._$btnShowTabStandard = null;
        this._$btnShowTabGoldAlternative = null;
    }

    static prePreInit() {
        this._preInit_registerKeybinds();
    }

    static _preInit_registerKeybinds() {
        const doKeybindingOpenForCharacter = ()=>{
            const actor = UtilKeybinding.getPlayerActor({
                minRole: Config.get("equipmentShop", "minimumRole")
            });
            if (!actor){return true;}
            this._pOpen({ actor });
            return true;
        };

        const doKeybindingOpenForCurrentSheet = ()=>{
            const meta = UtilKeybinding.getCurrentImportableSheetDocumentMeta({
                isRequireActor: true,
                isRequireOwnership: true,
                minRole: Config.get("equipmentShop", "minimumRole")
            });
            if (!meta?.actor)
                return true;
            this._pOpen({
                ...meta
            });
            return true;
        }
        ;

        game.keybindings.register(SharedConsts.MODULE_ID, "Charactermancer_StartingEquipment__openForCharacter", {
            name: "Open Equipment Shop Targeting Player Character",
            editable: [],
            onDown: ()=>doKeybindingOpenForCharacter(),
        }, );

        game.keybindings.register(SharedConsts.MODULE_ID, "Charactermancer_StartingEquipment__openForCurrentSheet", {
            name: "Open Equipment Shop Targeting Current Sheet",
            editable: [],
            onDown: ()=>doKeybindingOpenForCurrentSheet(),
        }, );
    }

    static init() {
        UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, async(diff)=>{
            if (!diff)
                return;

            const prev = MiscUtil.get(diff, "previous", "equipmentShop");
            const curr = MiscUtil.get(diff, "current", "equipmentShop");

            if (!prev || !curr)
                return;

            if (CollectionUtil.deepEquals(prev, curr))
                return;

            const toClose = Object.values(ui.windows).filter(it=>it.constructor === Charactermancer_StartingEquipment);
            if (!toClose.length)
                return;

            if (!await (InputUiUtil.pGetUserBoolean({
                title: `Existing Shop Windows`,
                htmlDescription: `You have ${toClose.length === 1 ? `an existing shop window` : `existing shop windows`} open, which will not be affected by your updated Equipment Shop config.<br>Would you like to close ${toClose.length === 1 ? "this window" : "these windows"}?`,
                textYes: "Yes",
                textNo: "No",
            })))
                return;

            toClose.forEach(it=>it.close());
        }
        );
    }

    static async pHandleButtonClick(evt, app) {
        return this._pOpen({
            actor: app.actor
        });
    }

    static async _pOpen({actor}) {
        const instance = new this({
            actor,
            isStandalone: true,
        });

        const formData = await instance.pWaitForUserInput();

        if (!formData)
            return;
        if (formData === VeCt.SYM_UI_SKIP)
            return;
        await this.pImportEquipmentItemEntries(actor, formData);
        await this.pUpdateActorCurrency(actor, formData);
    }

    static async pImportEquipmentItemEntries(actor, formData, {taskRunner=null}={}) {
        if (!formData?.data?.equipmentItemEntries?.length)
            return;
        const {ImportListItem} = await Promise.resolve().then(function() {
            return ImportListItem;
        });
        const importListItem = new ImportListItem({
            actor: actor
        });
        await importListItem.pInit();
        for (const it of formData.data.equipmentItemEntries) {
            if (it.item && it.name == null && it.source == null) {
                await importListItem.pImportEntry(it.item, {
                    taskRunner
                }, {
                    quantity: it.quantity || 1
                }, );
            } else
                await importListItem.pImportEntry(it, {
                    taskRunner
                });
        }
    }

    static async pUpdateActorCurrency(actor, formData) {
        if (!formData?.data?.currency)
            return;

        await UtilDocuments.pUpdateDocument(actor, {
            system: {
                currency: formData.data.currency,
            },
        }, );
    }

    static getComponents(actor, opts) {
        opts = opts || {};

        const compCurrency = actor ? Charactermancer_StartingEquipment.Currency.fromActor(actor) : new Charactermancer_StartingEquipment.Currency();
        compCurrency.init();

        const compDefault = new Charactermancer_StartingEquipment.ComponentDefault({
            compCurrency, actor, fnDoShowShop: opts.fnDoShowShop
        });
        const compGold = new Charactermancer_StartingEquipment.ComponentGold({
            compCurrency, actor, itemDatas: opts.itemDatas
        });

        return { compCurrency, compDefault, compGold, };
    }

    

    async _pResolveAndClose(resolveAs) {
        this._resolve(resolveAs);
        await this.close();
    }

    activateListeners($html) {
        if (!this._cntModesAvailable)
            return;
        const activeComps = [this._compDefault, this._compGold].filter(it=>it.isAvailable);

        if (this._cntModesAvailable === 2) {
            this._mode = this._compCurrency.cpRolled ? "gold" : "default";

            this._$wrpTabs = activeComps.map(it=>{
                const $wrpTab = $(`<div class="w-100 h-100 min-h-0 ve-flex-col"></div>`).hideVe();
                this._activateListeners_renderTab($wrpTab, it);
                return $wrpTab;
            }
            );

            this._$btnShowTabStandard = $(`<button class="btn btn-default w-50 btn-5et">${this._compCurrency.rollableExpressionGold ? `Standard Starting Equipment` : `Starting Equipment`}</button>`).click(()=>{
                this._mode = "default";
                this._doHandleModeSwitch();
            }
            );

            this._$btnShowTabGoldAlternative = $(`<button class="btn btn-default w-50 btn-5et">${this._compCurrency.rollableExpressionGold ? `Gold Alternative/Shop` : `Shop`}</button>`).click(()=>{
                this._mode = "gold";
                this._doHandleModeSwitch();
            }
            );

            this._doHandleModeSwitch();

            $$($html)`<div class="ve-flex-col w-100 h-100">
				<div class="ve-flex no-shrink btn-group mb-1">${this._$btnShowTabStandard}${this._$btnShowTabGoldAlternative}</div>
				${this._$wrpTabs[0]}
				${this._$wrpTabs[1]}
			</div>`;

            return;
        }

        this._activateListeners_renderTab($html, activeComps[0]);
    }

    _doHandleModeSwitch() {
        this._$btnShowTabStandard.toggleClass("active", this._mode === "default");
        this._$btnShowTabGoldAlternative.toggleClass("active", this._mode === "gold");
        this._$wrpTabs[0].toggleVe(this._mode === "default");
        this._$wrpTabs[1].toggleVe(this._mode === "gold");
    }

    _activateListeners_renderTab($html, comp) {
        comp.pRender($html).then($wrpTabInner=>{
            const $btnAccept = $(`<button class="btn btn-default btn-5et ${this._isStandalone ? "mr-3" : "mr-2"}">Confirm</button>`).click(async()=>{
                const activeComps = [this._compDefault, this._compGold].filter(it=>it.isAvailable);

                const formDatas = await Promise.all(activeComps.map(comp=>comp.pGetFormData()));

                for (const formData of formDatas) {
                    if (!formData.isFormComplete && !(await InputUiUtil.pGetUserBoolean({
                        title: formData.messageInvalid
                    })))
                        return;
                }

                const formDataCurrency = await this._compCurrency.pGetFormData();

                const combinedFormData = {
                    isFormComplete: formDatas.every(it=>it.isFormComplete),
                    data: {
                        equipmentItemEntries: formDatas.map(it=>it.data?.equipmentItemEntries || []).flat(),
                        currency: formDataCurrency?.data?.currency,
                    },
                };

                await this._pResolveAndClose(combinedFormData);
            }
            );

            const $btnSkip = this._isStandalone ? null : $(`<button class="btn btn-default mr-3">Skip</button>`).click(()=>this._pResolveAndClose(VeCt.SYM_UI_SKIP));

            $wrpTabInner.append(`<hr class=hr-1>`);
            $$`<div class="ve-flex-v-center ve-flex-h-right w-100">${$btnAccept}${$btnSkip}</div>`.appendTo($wrpTabInner);
        }
        );
    }

    async close() {
        await super.close();
        if (this._resolve)
            this._resolve(null);
    }

    async pWaitForUserInput() {
        if (!this._cntModesAvailable)
            return VeCt.SYM_UI_SKIP;

        await this.render(true);
        return this._pUserInput;
    }
}

Charactermancer_StartingEquipment.Currency = class extends BaseComponent {
    static fromActor(actor, {isStandalone=false}={}) {
        const initialCurrency = CurrencySheetAdapter.getActorCurrency({
            actor
        });
        const comp = new this({
            isStandalone
        });
        comp.init();
        comp.setCurrencyFromActor(initialCurrency);
        return comp;
    }

    constructor(opts) {
        super();

        opts = opts || {};

        this._isStandalone = !!opts.isStandalone;
        this._prevActorCurrency = null;
        this.__state.startingEquipment = opts.startingEquipment ? MiscUtil.copy(opts.startingEquipment) : null;
        this.__state.cpRolled = this._getInitialCpRolled();
    }

    init() {
        const hkStartingEquipment = ()=>{
            this._state.cpRolled = this._getInitialCpRolled();
            this._state.rollableExpressionGold = this.constructor._getRollableExpressionGold(this._state.startingEquipment);
        }
        ;
        this._addHookBase("startingEquipment", hkStartingEquipment);
        hkStartingEquipment();
    }

    static _getRollableExpressionGold(startingEquipment) {
        if (!startingEquipment?.goldAlternative)
            return null;
        const m = /{@dice ([^|]+)/.exec(startingEquipment.goldAlternative);
        if (m)
            return m[1].replace(/×/g, "*");
        if (!isNaN(`${startingEquipment.goldAlternative}`.trim()))
            return startingEquipment.goldAlternative.trim();
        return null;
    }

    get startingEquipment() {
        return this._state.startingEquipment;
    }
    set startingEquipment(val) {
        this._state.startingEquipment = val;
    }

    get isStandalone() {
        return this._isStandalone;
    }

    get rollableExpressionGold() {
        return this._state.rollableExpressionGold;
    }

    get cpSpent() {
        return this._state.cpSpent;
    }
    set cpSpent(val) {
        this._state.cpSpent = val;
    }

    get cpRolled() {
        return this._state.cpRolled;
    }
    set cpRolled(val) {
        this._state.cpRolled = val;
    }

    get hasShownGoldWarning() {
        return this._state.hasShownGoldWarning;
    }
    set hasShownGoldWarning(val) {
        this._state.hasShownGoldWarning = val;
    }

    set cpFromDefault(val) {
        this._state.cpFromDefault = val;
    }

    setCurrencyFromActor(startingCurrency) {
        this._prevActorCurrency = MiscUtil.copy(startingCurrency);

        const out = {};
        Parser.COIN_ABVS.forEach(k=>out[k] = startingCurrency[k] || 0);
        this._proxyAssignSimple("state", out);
    }

    _getAvailableCp() {
        return (this._state.cpRolled || 0) + (this._state.cpFromDefault || 0) + CurrencyUtil.getAsCopper({
            cp: this._state.cp,
            sp: this._state.sp,
            gp: this._state.gp,
            ep: this._state.ep,
            pp: this._state.pp
        });
    }

    _getOriginalCurrency() {
        const out = Parser.COIN_ABVS.mergeMap(it=>({
            [it]: 0
        }));
        Object.entries(this._prevActorCurrency || {}).forEach(([coin,amount])=>out[coin] = (out[coin] || 0) + amount);

        const fromRolled = CurrencyUtil.doSimplifyCoins({
            cp: this._state.cpRolled || 0
        });
        Object.entries(fromRolled || {}).forEach(([coin,amount])=>out[coin] = (out[coin] || 0) + amount);

        const fromDefault = CurrencyUtil.doSimplifyCoins({
            cp: this._state.cpFromDefault || 0
        });
        Object.entries(fromDefault || {}).forEach(([coin,amount])=>out[coin] = (out[coin] || 0) + amount);

        return out;
    }

    isStandardStartingEquipmentActive() {
        return Object.keys(this.startingEquipment || {}).length && this.cpRolled == null;
    }

    async pGetFormData() {
        return {
            isFormComplete: true,
            data: {
                currency: CurrencyUtil.doSimplifyCoins({
                    cp: this.getRemainingCp(),
                }, {
                    originalCurrency: this._getOriginalCurrency(),
                    isPopulateAllValues: true,
                    currencyConversionTable: Parser.FULL_CURRENCY_CONVERSION_TABLE,
                }, ),
            },
        };
    }

    getRemainingCp() {
        return this._getAvailableCp() - this._state.cpSpent;
    }

    addHookCurrency(hk) {
        this._addHookAll("state", hk);
    }
    addHookCpRolled(hk) {
        this._addHookBase("cpRolled", hk);
    }
    addHookStartingEquipment(hk) {
        this._addHookBase("startingEquipment", hk);
    }
    addHookRollableExpressionGold(hk) {
        this._addHookBase("rollableExpressionGold", hk);
    }

    removeHookCpRolled(hk) {
        this._removeHookBase("cpRolled", hk);
    }

    _getInitialCpRolled() {
        if (this._isStandalone)
            return null;
        const startingGp = Config.get("equipmentShop", "startingGold");
        return startingGp ? CurrencyUtil.getAsCopper({
            gp: startingGp
        }) : null;
    }

    _getDefaultState() {
        return {
            startingEquipment: null,
            rollableExpressionGold: null,

            ...Parser.COIN_ABVS.mergeMap(it=>({
                [it]: 0
            })),
            cpSpent: 0,
            cpRolled: this._getInitialCpRolled(),
            cpFromDefault: 0,

            hasShownGoldWarning: false,
        };
    }
};

Charactermancer_StartingEquipment.ComponentBase = class extends BaseComponent {
    constructor(opts) {
        super();
        this._compCurrency = opts.compCurrency;
        this._actor = opts.actor;
    }

    static _getHumanReadableCoinage(copper) {
        const asCoins = CurrencyUtil.doSimplifyCoins({
            cp: copper
        });
        return [...Parser.COIN_ABVS].reverse().map(coin=>asCoins[coin] ? `${asCoins[coin].toLocaleString()} ${coin}` : null).filter(Boolean).join(", ") || "0 gp";
    }

    async _pIsIgnoreGoldWarning() {
        if (!Object.keys(this._compCurrency.startingEquipment || {}).length || this._compCurrency.hasShownGoldWarning)
            return true;

        const isUseGold = await InputUiUtil.pGetUserBoolean({
            title: `Are you sure?`,
            htmlDescription: `Using gold to buy starting equipment is an alternative to standard starting equipment.<br>Are you sure you want to use gold?`,
            textYes: "Yes",
            textNo: "Cancel",
        });
        if (!isUseGold)
            return false;

        this._compCurrency.hasShownGoldWarning = true;
        return true;
    }

    _$getBtnRollStartingGold() {
        return $(`<button class="btn btn-default btn-xs btn-5et">Roll Starting Gold</button>`).click(async()=>{
            if (!(await this._pIsIgnoreGoldWarning()))
                return;

            const roll = new Roll(this._compCurrency.rollableExpressionGold);
            await roll.evaluate({
                async: true
            });
            this._compCurrency.cpRolled = roll.total * 100;

            const optsToMessage = {
                sound: null
            };
            if (this._actor) {
                optsToMessage.speaker = {
                    actor: this._actor.id
                };
                optsToMessage.flavor = `<div>${this._actor.name} rolls starting gold!</div>`;
            }

            roll.toMessage(optsToMessage).then(null);
        }
        );
    }

    _$getBtnEnterStartingGold() {
        return $(`<button class="btn btn-default btn-xs btn-5et" title="Manually enter a starting gold amount, as an alternate to rolling.">Enter Starting Gold</button>`).click(async()=>{
            if (!(await this._pIsIgnoreGoldWarning()))
                return;

            const opts = {
                min: 0,
                title: "Enter Gold Amount",
                int: true,
            };
            if (this._compCurrency.cpRolled != null)
                opts.default = Math.round(this._compCurrency.cpRolled / 100);

            const amount = await InputUiUtil.pGetUserNumber(opts);
            if (amount == null)
                return;

            this._compCurrency.cpRolled = amount * 100;
        }
        );
    }

    _$getDispRolledGold() {
        const $dispRolled = $(`<div></div>`);

        const hkRolled = ()=>{
            if (this._compCurrency.cpRolled == null && this._compCurrency.rollableExpressionGold != null)
                $dispRolled.html(`<i class="ve-muted">${this._compCurrency.rollableExpressionGold}</i>`);
            else
                $dispRolled.html(this.constructor._getHumanReadableCoinage(this._compCurrency.cpRolled || 0));
        }
        ;
        hkRolled();
        this._compCurrency.addHookRollableExpressionGold(hkRolled);
        this._compCurrency.addHookCpRolled(hkRolled);

        return $dispRolled;
    }

    _$getWrpRollOrManual({$btnRoll, $dispRollOrManual, $btnManual, $dispRolled}) {
        const $stgDispRolled = $dispRolled ? $$`<div class="m-1"> = </div>${$dispRolled}` : null;
        return $$`<div class="ve-flex-v-center">${$btnRoll}${$dispRollOrManual}${$btnManual}${$stgDispRolled}</div>`;
    }

    _doBindRollableExpressionHooks({$dispRollOrManual, $btnRoll, $btnManual, $spcRollOrManual, $wrpRollOrManual}) {
        const hkRollableExpressionGold = ()=>{
            $dispRollOrManual.toggleVe(this._compCurrency.rollableExpressionGold);
            $btnRoll.toggleVe(this._compCurrency.rollableExpressionGold).title(`Rolling ${this._compCurrency.rollableExpressionGold}`);

            $btnManual.toggleVe(this._compCurrency.startingEquipment);

            if ($spcRollOrManual)
                $spcRollOrManual.toggleVe(!this._isPredefinedItemDatas && this._compCurrency.startingEquipment);
            $wrpRollOrManual.toggleVe(this._compCurrency.startingEquipment);
        }
        ;
        this._compCurrency.addHookStartingEquipment(hkRollableExpressionGold);
        this._compCurrency.addHookRollableExpressionGold(hkRollableExpressionGold);
        hkRollableExpressionGold();
    }
};

Charactermancer_StartingEquipment.ComponentDefault = class extends Charactermancer_StartingEquipment.ComponentBase {
    constructor(opts) {
        super(opts);

        opts = opts || {};

        this._equiSpecialSource = opts.equiSpecialSource;
        this._equiSpecialPage = opts.equiSpecialPage;
        this._fnDoShowShop = opts.fnDoShowShop;

        this._fnsUnhook = [];
    }

    async pRender($wrpTab) {
        const $wrpTabInner = $(`<div class="ve-flex-col w-100 h-100 min-h-0"></div>`).appendTo($wrpTab);
        this._render_standard($wrpTabInner);
        return $wrpTabInner;
    }
    _render_standard($wrpTabStandard) {
        const $btnRoll = this._$getBtnRollStartingGold();
        const $dispRollOrManual = $(`<i class="mx-1">\u2013 or \u2013</i>`);
        const $btnManual = this._$getBtnEnterStartingGold();

        const $wrpRollOrManual = this._$getWrpRollOrManual({
            $dispRollOrManual, $btnRoll, $btnManual
        });

        this._doBindRollableExpressionHooks({
            $dispRollOrManual, $btnRoll, $btnManual, $wrpRollOrManual
        });

        const $rowSkipToShop = $$`<div class="w-100 py-1 ve-flex-v-center">
			<div class="mr-1">Alternatively, </div>
			${$wrpRollOrManual}
			<div class="ml-1">to skip to the shop.</div>
		</div>`.appendTo($wrpTabStandard);

        const $btnResetStartingGold = $(`<button class="btn btn-default btn-xs btn-5et">Reset Starting Gold</button>`).click(async()=>{
            const isSure = await InputUiUtil.pGetUserBoolean({
                title: `Are you sure?`,
                htmlDescription: `This will discard your current starting gold roll or value.`,
            });
            if (!isSure)
                return;
            this._compCurrency.cpRolled = null;
        }
        );
        const $rowHasCpRolled = $$`<div class="w-100 py-1 ve-flex-v-center">
			<div class="mr-2">You have rolled or entered a value for starting gold instead of using starting equipment.</div>
			${$btnResetStartingGold}
			<div class="ml-1">to use the equipment listed below.</div>
		</div>`.appendTo($wrpTabStandard);

        const hkCpRolled = ()=>{
            $rowSkipToShop.toggleVe(this._compCurrency.cpRolled == null);
            $rowHasCpRolled.toggleVe(this._compCurrency.cpRolled != null);
        };

        this._compCurrency.addHookCpRolled(hkCpRolled);
        hkCpRolled();

        if (this._fnDoShowShop) {
            const hkOnChangeCurrency = (prop,val,prevVal)=>{
                if (prevVal == null && val != null)
                    this._fnDoShowShop();
            };
            this._compCurrency.addHookCpRolled(hkOnChangeCurrency);
        }

        const $wrpRows = $$`<div class="ve-flex-col w-100 h-100 min-h-0 overflow-y-auto"></div>`.appendTo($wrpTabStandard);

        const hkStartingEquipment = ()=>{
            const defaultData = this._compCurrency.startingEquipment?.defaultData || [];

            this._fnsUnhook.forEach(fn=>fn());
            this._fnsUnhook = [];
            Object.keys(this._state).filter(k=>k.startsWith(`std__`)).forEach(k=>delete this._state[k]);
            $wrpRows.empty();

            const $rows = defaultData.map((group,ixGroup)=>{
                const isSingleOption = Object.keys(group).length === 1;
                const propGroup = `std__choice__${ixGroup}`;
                this._state[propGroup] = 0;
                const choices = Object.entries(group);

                const $wrpsChoices = choices.map(([choiceName,choice],ixChoice)=>{
                    const children = [];
                    choice.forEach((equi,ixEqui)=>{
                        if (typeof equi === "string")
                            children.push(Renderer.get().render(`{@item ${equi}}`));
                        else if (equi.item) {
                            const itemId = this.constructor._getItemIdWithDisplayName(equi.item, equi.displayName);

                            children.push(Renderer.get().render(`${equi.quantity ? `${equi.quantity}× ` : ""}{@item ${itemId}}${equi.containsValue ? ` containing ${this.constructor._getHumanReadableCoinage(equi.containsValue)}` : ""}`));
                        } else if (equi.equipmentType) {
                            const equiChoices = Charactermancer_StartingEquipment._EQUIPMENT_SETS[equi.equipmentType];
                            if (!equiChoices)
                                throw new Error(`Unhandled equipmentType "${equi.equipmentType}"`);

                            const num = equi.quantity || 1;
                            for (let i = 0; i < num; ++i) {
                                const $dispEqui = $(`<div class="inline"></div>`);
                                const propEqui = `std__equi__${ixGroup}__${ixChoice}__${i}`;

                                const hkDispEqui = ()=>{
                                    if (!this._state[propEqui]) {
                                        $dispEqui.html(`<i class="ve-muted">(select an item)</i>`);
                                        return;
                                    }

                                    $dispEqui.html(Renderer.get().render(`{@item ${this._state[propEqui]}}`));
                                };
                                this._addHookBase(propEqui, hkDispEqui);
                                this._fnsUnhook.push(()=>this._removeHookBase(propEqui, hkDispEqui));
                                hkDispEqui();

                                const $btnPick = $(`<button class="btn btn-default btn-xxs" title="Choose an Item"><span class="fas fa-fw fa-search"></span></button>`).click(async()=>{
                                    const equiChoicesName = Charactermancer_StartingEquipment._EQUIPMENT_SET_NAMES[equi.equipmentType];
                                    const {$modalInner, doClose, doAutoResize: doAutoResizeModal} = await UtilApplications.pGetShowApplicationModal({
                                        title: `Choose Item${equiChoicesName ? ` \u2014 ${equiChoicesName}` : ""}`,
                                    });

                                    const $rows = equiChoices.map(itemUid=>{
                                        const $btnChoose = $(`<button class="btn btn-xs btn-default mr-2"><span class="fas fa-fw fa-check"></span></button>`).click(()=>{
                                            this._state[propEqui] = itemUid;
                                            doClose(true);
                                            this._state[propGroup] = ixChoice;
                                        }
                                        );

                                        return $$`<div class="ve-flex-v-center py-1 stripe-even">${$btnChoose}${Renderer.get().render(`{@item ${itemUid.uppercaseFirst()}}`)}</div>`;
                                    }
                                    );

                                    $$($modalInner)`<div class="ve-flex-col h-100">${$rows}</div>`;

                                    doAutoResizeModal();
                                }
                                );

                                children.push($$`<div class="inline">${$btnPick} ${$dispEqui}</div>`);

                                if (i < num - 1)
                                    children.push(", ");
                            }
                        } else if (equi.special) {
                            children.push(Renderer.get().render(`${equi.quantity ? `${equi.quantity}× ` : ""}${equi.special}${equi.containsValue ? ` containing ${this.constructor._getHumanReadableCoinage(equi.containsValue)}` : ""}${equi.worthValue ? `, worth ${this.constructor._getHumanReadableCoinage(equi.worthValue)}` : ""}`));
                        } else if (equi.value != null) {
                            children.push(this.constructor._getHumanReadableCoinage(equi.value));
                        } else
                            throw new Error(`Unknown equipment data format: ${JSON.stringify(equi)}`);

                        if (ixEqui < choice.length - 1)
                            children.push(", ");
                    }
                    );

                    const $btnSelGroup = $(`<button class="btn btn-default btn-sm no-shrink ve-flex-vh-center imp-cls__disp-equi-choice-key mr-2 bold" ${isSingleOption ? "" 
                    : `title="Select Equipment Group ${choiceName}"`}>${isSingleOption ? "&nbsp;" : `(${choiceName})`}</button>`).click(async()=>{
                        if (this._compCurrency.cpRolled != null) {
                            const isSure = await InputUiUtil.pGetUserBoolean({
                                title: `Are you sure?`,
                                htmlDescription: `You have already rolled or set gold for equipment!<br>Selecting default starting equipment will discard this roll or value.`,
                            });
                            if (!isSure)
                                return;

                            this._compCurrency.cpRolled = null;
                        }

                        if (isSingleOption)
                            return;

                        this._state[propGroup] = ixChoice;
                    }
                    );

                    const $wrpChildren = $$`<div class="w-100">${children}</div>`;

                    const hkSelGroup = ()=>{
                        $btnSelGroup.toggleClass("ve-muted", this._compCurrency.cpRolled != null);
                        $wrpChildren.toggleClass("ve-muted", this._compCurrency.cpRolled != null);

                        if (this._compCurrency.cpRolled != null) {
                            $btnSelGroup.removeClass("active");
                            $btnSelGroup.prop("disabled", false);
                            return;
                        }

                        if (isSingleOption)
                            $btnSelGroup.prop("disabled", true);

                        if (this._state[propGroup] === ixChoice)
                            $btnSelGroup.addClass("active");
                        else
                            $btnSelGroup.removeClass("active");
                    }
                    ;
                    this._addHookBase(propGroup, hkSelGroup);
                    this._compCurrency.addHookCpRolled(hkSelGroup);
                    this._fnsUnhook.push(()=>this._removeHookBase(propGroup, hkSelGroup));
                    this._fnsUnhook.push(()=>this._compCurrency.removeHookCpRolled(hkSelGroup));
                    hkSelGroup();

                    if (ixChoice < choices.length - 1)
                        $btnSelGroup.addClass("mb-1");

                    return $$`<div class="ve-flex-vh-center">
							${$btnSelGroup}
							${$wrpChildren}
						</div>`;
                }
                );

                return $$`<div class="ve-flex-col w-100 p-1 my-1 imp-cls__wrp-equi-group">${$wrpsChoices}</div>`;
            }
            );

            $rows.forEach($row=>$wrpRows.append($row));

            if (!$rows.length) {
                $wrpRows.append(`<div class="ve-flex-vh-center w-100 h-100 italic ve-muted">No starting equipment available.</div>`);
            }
        };
        
        this._compCurrency.addHookStartingEquipment(hkStartingEquipment);
        hkStartingEquipment();

        const hkSetCoinsFromDefault = ()=>{
            if (Config.get("equipmentShop", "startingGold") != null) {
                this._compCurrency.cpFromDefault = 0;
                return;
            }

            let cpValue = 0;

            const fnEqui = (ixGroup,ixChoice,equi)=>{
                if (equi.item) {
                    if (equi.containsValue)
                        cpValue += equi.containsValue;
                } else if (equi.special) {
                    if (equi.containsValue)
                        cpValue += equi.containsValue;
                } else if (equi.value) {
                    cpValue += equi.value;
                }
            }
            ;

            this._iterChosenStartingEquipment(fnEqui);

            this._compCurrency.cpFromDefault = cpValue;
        };

        this._addHookAll("state", hkSetCoinsFromDefault);
        hkSetCoinsFromDefault();
    }

    set equiSpecialSource(val) {
        this._equiSpecialSource = val;
    }
    set equiSpecialPage(val) {
        this._equiSpecialPage = val;
    }

    get isAvailable() {
        return !!(this._compCurrency.startingEquipment?.defaultData?.length);
    }

    async pGetFormData() {
        const equipmentItemEntries = [];

        const itemDatasDefault = await this._pGetItemDatasDefault();
        if (itemDatasDefault) {
            equipmentItemEntries.push(...itemDatasDefault);
        }

        const isValid = this._isValid_standard();
        const messageInvalid = isValid ? null : `You have not made all available choices. Are you sure you want to continue?`;

        return {
            isFormComplete: isValid,
            messageInvalid: messageInvalid,
            data: {
                equipmentItemEntries,
            },
        };
    }

    static _getItemIdWithDisplayName(itemId, displayName) {
        if (!displayName)
            return itemId;

        const itemIdParts = itemId.split("|");

        while (itemIdParts.length > 2)
            itemIdParts.pop();
        while (itemIdParts.length < 2)
            itemIdParts.push("");

        itemIdParts.push(displayName);

        return itemIdParts.join("|");
    }

    

    _iterChosenStartingEquipment(fnEqui) {
        const defaultData = (this._compCurrency.startingEquipment?.defaultData || []);

        for (let ixGroup = 0; ixGroup < defaultData.length; ++ixGroup) {
            const group = defaultData[ixGroup];
            const propGroup = `std__choice__${ixGroup}`;

            const choices = Object.entries(group);
            for (let ixChoice = 0; ixChoice < choices.length; ++ixChoice) {
                const [_,choice] = choices[ixChoice];

                if (this._state[propGroup] !== ixChoice)
                    continue;

                for (let ixEqui = 0; ixEqui < choice.length; ++ixEqui) {
                    const equi = choice[ixEqui];

                    const out = fnEqui(ixGroup, ixChoice, equi);
                    if (out !== undefined)
                        return out;
                }
            }
        }
    }

   

    _isValid_standard() {
        if (!this.isAvailable || this._compCurrency.cpRolled != null)
            return true;

        const fnEqui = (ixGroup,ixChoice,equi)=>{
            if (equi.equipmentType) {
                const num = equi.quantity || 1;
                for (let i = 0; i < num; ++i) {
                    const propEqui = `std__equi__${ixGroup}__${ixChoice}__${i}`;
                    if (this._state[propEqui] == null)
                        return false;
                }
            }
        }
        ;

        const out = this._iterChosenStartingEquipment(fnEqui);
        if (out !== undefined)
            return out;
        return true;
    }

    async _pGetItemDatasDefault() {
        if (this._compCurrency.cpRolled)
            return [];

        const outUidMetas = [];
        const outPreloaded = [];

        const addOutUidMeta = (itemUid,quantity)=>{
            const existing = outUidMetas.find(it=>it.itemUid === itemUid);
            if (existing)
                existing.quantity += quantity;
            else
                outUidMetas.push({
                    itemUid,
                    quantity: quantity
                });
        }
        ;

        const fnEqui = (ixGroup,ixChoice,equi)=>{
            if (typeof equi === "string")
                addOutUidMeta(equi, 1);
            else if (equi.item) {
                addOutUidMeta(this.constructor._getItemIdWithDisplayName(equi.item, equi.displayName), equi.quantity || 1);
            } else if (equi.equipmentType) {
                const num = equi.quantity || 1;
                for (let i = 0; i < num; ++i) {
                    const propEqui = `std__equi__${ixGroup}__${ixChoice}__${i}`;
                    const itemUid = this._state[propEqui];
                    if (itemUid != null)
                        addOutUidMeta(itemUid, 1);
                }
            } else if (equi.special) {
                outPreloaded.push({
                    item: {
                        name: Renderer.stripTags(equi.special).toTitleCase(),
                        source: this._equiSpecialSource,
                        page: this._equiSpecialPage,
                        type: "OTH",
                        rarity: "unknown",
                    },
                    quantity: equi.quantity || 1,
                });
            }
        }
        ;

        this._iterChosenStartingEquipment(fnEqui);

        const loadedItems = [];
        for (const itemUidMeta of outUidMetas) {
            const [name,source,displayName] = itemUidMeta.itemUid.split("|");
            const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
                name,
                source
            });

            const loadedItem = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, hash);
            if (!loadedItem) {
                console.warn(...LGT, `Failed to load item "${itemUidMeta.itemUid}"!`);
                continue;
            }

            if (displayName)
                loadedItem._displayName = Renderer.stripTags(displayName).toTitleCase();
            loadedItems.push({
                item: loadedItem,
                quantity: itemUidMeta.quantity,
            });
        }
        const {ImportListItem} = await Promise.resolve().then(function() {
            return ImportListItem;
        });
        const outFromUids = loadedItems.sort((a,b)=>ImportListItem.sortEntries(a.item, b.item));

        return [...outFromUids, ...outPreloaded];
    }

    _getDefaultState() {
        return {};
    }
};

Charactermancer_StartingEquipment.ComponentGold = class extends Charactermancer_StartingEquipment.ComponentBase {
    constructor(opts) {
        super(opts);
        this._isPredefinedItemDatas = !!opts.itemDatas;
        this._state.itemDatas = opts.itemDatas;

        this._modalFilter = null;
    }

    get isAvailable() {
        return true;
    }

    async pGetFormData() {
        const equipmentItemEntries = [];

        const itemDatas = await this._pGetItemEntries();
        if (itemDatas) {
            equipmentItemEntries.push(...itemDatas);
        }

        const isValid = await this._isValid_gold();
        const messageInvalid = isValid ? null : `You have spent more gold than you possess. Are you sure you want to go into debt?`;

        return {
            isFormComplete: isValid,
            messageInvalid,
            data: {
                equipmentItemEntries,
            },
        };
    }

    async pRender($wrpTab) {
        const $wrpTabInner = $(`<div class="ve-flex-col w-100 h-100 min-h-0"><div class="ve-flex-vh-center w-100 h-100 italic">Loading...</div></div>`).appendTo($wrpTab);
        await this._render_pGoldAlternative($wrpTabInner);
        return $wrpTabInner;
    }

    async _render_pGoldAlternative($wrpTabGoldAlternative) {
        await Renderer.item.pPopulatePropertyAndTypeReference();

        const {ImportListItem} = await Promise.resolve().then(function() {
            return ImportListItem;
        });
        const importListItemSources = await (new ImportListItem()).pGetSources();
        const appSourceSelector = new AppSourceSelectorMulti({
            title: `Select Item Sources`,
            filterNamespace: `ImportListCharacter_StartingEquipment_filter`,
            savedSelectionKey: `ImportListCharacter_StartingEquipment_savedSelection`,
            sourcesToDisplay: importListItemSources,
            page: UrlUtil.PG_ITEMS,
            isDedupable: true,
        });

        const $btnChooseSources = this._isPredefinedItemDatas ? null : $(`<button class="btn btn-xs btn-default btn-5et">Choose Item Sources</button>`).click(async()=>{
            const choices = await appSourceSelector.pWaitForUserInput();
            if (choices == null)
                return;

            this._state.itemDatas = choices;
        }
        );

        if (!this._isPredefinedItemDatas) {
            appSourceSelector.pLoadInitialSelection().then(choices=>{
                if (!choices)
                    return;
                this._state.itemDatas = choices;
            }
            );
        }

        const $dispCurrencyRemaining = $(`<div class="ml-auto ve-flex-v-center"></div>`);
        const hkCurrency = ()=>{
            const remainingCp = this._compCurrency.getRemainingCp();
            $dispCurrencyRemaining.html(`
				<div title="The total cost of all items in the &quot;shopping basket,&quot; listed below.">
					<b class="mr-1">Total:</b>
					<span>${this.constructor._getHumanReadableCoinage(this._compCurrency.cpSpent)}</span>
				</div>
				<div class="vr-1"></div>
				<span>(</span>
				<div title="The total remaining gold available to this character. This amount is a combination of the currency on their sheet, plus any contextual modifiers (such as class starting gold when importing a class).">
					<b class="mr-1">Remaining:</b>
					<span ${remainingCp < 0 ? `class="veapp__msg-error bold"` : ""}>${this.constructor._getHumanReadableCoinage(remainingCp)}</span>
				</div>
				<span>)</span>
			`);
        }
        ;
        this._compCurrency.addHookCurrency(hkCurrency);
        hkCurrency();

        const $dispRollOrManual = $(`<i class="mx-1">\u2013 or \u2013</i>`);
        const $btnRoll = this._$getBtnRollStartingGold();
        const $btnManual = this._$getBtnEnterStartingGold();
        const $dispRolled = this._$getDispRolledGold();

        const $spcRollOrManual = $(`<div class="vr-1"></div>`);
        const $wrpRollOrManual = this._$getWrpRollOrManual({
            $dispRollOrManual,
            $btnRoll,
            $btnManual,
            $dispRolled
        }).addClass("mr-3");

        this._doBindRollableExpressionHooks({
            $dispRollOrManual,
            $btnRoll,
            $btnManual,
            $spcRollOrManual,
            $wrpRollOrManual
        });

        const isStandaloneGmInstance = game.user.isGM && this._compCurrency.isStandalone;
        const $btnEditPriceMultiplier = !isStandaloneGmInstance ? null : $(`<button class="btn btn-xs btn-default btn-5et">Edit Config</button>`).on("click", evt=>Config.pOpen({
            evt,
            initialVisibleGroup: "equipmentShop"
        }));
        const $wrpGmPriceMultiplier = !isStandaloneGmInstance ? null : $$`<div class="ml-auto">
			${$btnEditPriceMultiplier}
		</div>`;

        this._modalFilter = new Charactermancer_StartingEquipment.ModalFilterEquipment(this);

        const $wrpItemList = $(`<div class="ve-flex-col w-50 h-100 min-h-0"><div class="ve-flex-vh-center italic w-100 h-100">Loading...</div></div>`);

        this._modalFilter.pPopulateWrapper($wrpItemList, {
            isBuildUi: true,
            $btnOpen: $(`<button class="btn-5et veapp__btn-filter" name="btn-filter">Filter</button>`),
            $btnToggleSummaryHidden: $(`<button class="btn btn-5et" title="Toggle Filter Summary Display" name="btn-toggle-summary"><span class="glyphicon glyphicon-resize-small"></span></button>`),
            $btnReset: $(`<button class="btn-5et veapp__btn-list-reset" name="btn-reset">Reset</button>`),
        }, ).then(meta=>{
            const {list, $btnSendAllToRight} = meta;
            $btnSendAllToRight.addClass("btn-5et ve-grow").click(async evt=>{
                if (list.visibleItems.length > 10 && !(await InputUiUtil.pGetUserBoolean({
                    title: `You are about to add ${list.visibleItems.length} items. Are you sure?`
                })))
                    return;

                const quantity = evt.shiftKey ? 5 : 1;
                list.visibleItems.forEach(it=>this.addBoughtItem(`${it.name}|${it.values.source}`, {
                    quantity,
                    isTriggerUpdate: false
                }));
                this._triggerCollectionUpdate("itemPurchases");
            }
            );

            hkItemDatas();
        }
        );

        const $wrpBoughtList = $(`<div class="w-100 h-100 min-h-0 overflow-y-auto"></div>`);

        const hkGoldItemUids = ()=>{
            this._renderCollection({
                prop: "itemPurchases",
                fnUpdateExisting: (renderedMeta,itemPurchase)=>{
                    renderedMeta.comp._proxyAssignSimple("state", itemPurchase.data, true);
                }
                ,
                fnGetNew: (itemPurchase)=>{
                    const comp = BaseComponent.fromObject(itemPurchase.data);
                    comp._addHookAll("state", ()=>{
                        itemPurchase.data = comp.toObject();
                        this._triggerCollectionUpdate("itemPurchases");
                    }
                    );

                    const [name,source] = itemPurchase.data.uid.split("|");
                    DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
                        name,
                        source
                    })).then(item=>{
                        comp._state.name = item.name;
                        comp._state.value = item.value * Config.get("equipmentShop", "priceMultiplier");
                    }
                    );

                    const hkNoQuantity = ()=>{
                        if (comp._state.quantity > 0)
                            return;
                        this._state.itemPurchases = this._state.itemPurchases.filter(it=>it !== itemPurchase);
                    }
                    ;
                    comp._addHookBase("quantity", hkNoQuantity);

                    const $btnSubtract = $(`<button class="btn btn-xxs btn-5et btn-danger" title="Remove One (SHIFT to remove  5)"><span class="glyphicon glyphicon-minus"></span></button>`).click(evt=>{
                        if (evt.shiftKey)
                            comp._state.quantity -= 5;
                        else
                            comp._state.quantity--;
                    }
                    );

                    const $btnAdd = $(`<button class="btn btn-xxs btn-5et btn-success" title="Add Another (SHIFT to add 5)"><span class="glyphicon glyphicon-plus"></span></button>`).click(evt=>{
                        if (evt.shiftKey)
                            comp._state.quantity += 5;
                        else
                            comp._state.quantity++;
                    }
                    );

                    const $dispQuantity = $(`<div class="ve-text-center no-shrink imp-cls__disp-equi-count"></div>`);
                    const hkQuantity = ()=>$dispQuantity.text(comp._state.quantity);
                    comp._addHookBase("quantity", hkQuantity);
                    hkQuantity();

                    const $dispName = $(`<div class="w-100"></div>`);
                    const hkName = ()=>$dispName.html(Renderer.get().render(`{@item ${comp._state.uid}|${comp._state.name || ""}}`));
                    comp._addHookBase("name", hkName);
                    hkName();

                    const $dispCostIndividual = $(`<div class="no-shrink text-right imp-cls__disp-equi-cost px-1"></div>`);
                    const hkCostIndividual = ()=>$dispCostIndividual.html(comp._state.isIgnoreCost ? `<span class="ve-muted" title="Cost Ignored">\u2014</span>` : this.constructor._getHumanReadableCoinage(comp._state.value));
                    comp._addHookBase("value", hkCostIndividual);
                    hkCostIndividual();

                    const $dispCostTotal = $(`<div class="no-shrink text-right imp-cls__disp-equi-cost px-1"></div>`);
                    const hkCostTotal = ()=>{
                        if (comp._state.value == null || comp._state.quantity == null)
                            return;
                        $dispCostTotal.html(comp._state.isIgnoreCost ? `<span class="ve-muted" title="Cost Ignored">\u2014</span>` : this.constructor._getHumanReadableCoinage(comp._state.value * comp._state.quantity));
                    }
                    ;
                    comp._addHookBase("value", hkCostTotal);
                    comp._addHookBase("quantity", hkCostTotal);
                    hkCostTotal();

                    const $wrpRow = $$`<div class="py-1p my-0 veapp__list-row ve-flex-v-center w-100">
						<div class="btn-group ve-flex-vh-center no-shrink imp-cls__wrp-equi-btns">
							${$btnSubtract}
							${$btnAdd}
						</div>
						${$dispQuantity}
						${$dispName}
						${$dispCostIndividual}
						${$dispCostTotal}
					</div>`.appendTo($wrpBoughtList);

                    return {
                        comp,
                        $wrpRow,
                    };
                }
                ,
            });
        }
        ;
        this._addHookBase("itemPurchases", hkGoldItemUids);
        hkGoldItemUids();

        const pHkItemsPurchased = async()=>{
            try {
                await this._pLock("pHkItemsPurchased");
                this._compCurrency.cpSpent = await this._pGetCpSpent();
            } finally {
                this._unlock("pHkItemsPurchased");
            }
        }
        ;
        this._addHookBase("itemPurchases", pHkItemsPurchased);
        pHkItemsPurchased();

        const hkItemDatas = ()=>{
            this._modalFilter.setDataList(this._state.itemDatas);
        }
        ;
        this._addHookBase("itemDatas", hkItemDatas);

        const $btnClearPurchases = $(`<button class="btn btn-xxs btn-5et btn-danger" title="Remove All Purchases"><span class="glyphicon glyphicon-minus"></span></button>`).click(async()=>{
            if (!(await InputUiUtil.pGetUserBoolean({
                title: `Are you sure you want to remove all purchased items from the list?`
            })))
                return;
            this._state.itemPurchases = [];
        }
        );

        $$($wrpTabGoldAlternative.empty())`
		<div class="ve-flex-v-center">
			<div class="w-50 ve-flex-v-center">
				${$btnChooseSources}
				${$spcRollOrManual}
				${$wrpRollOrManual}
				${$wrpGmPriceMultiplier}
			</div>

			<div class="vr-1"></div>

			<div class="w-50 split-v-center">
				${$dispCurrencyRemaining}
			</div>
		</div>

		<hr class="hr-1">

		<div class="ve-flex h-100 min-h-0 w-100">
			${$wrpItemList}

			<div class="vr-1"></div>

			<div class="w-50 min-h-0 ve-flex-col">
				<div class="ve-flex-v-center pb-1">
					<div class="imp-cls__wrp-equi-btns no-shrink ve-flex-vh-center">${$btnClearPurchases}</div>
					<div class="imp-cls__disp-equi-count no-shrink ve-text-center" title="Quantity">Qt.</div>
					<div class="w-100">Name</div>
					<div class="imp-cls__disp-equi-cost no-shrink ve-text-center">Cost</div>
					<div class="imp-cls__disp-equi-cost no-shrink ve-text-center">Line Total</div>
				</div>

				${$wrpBoughtList}
			</div>
		</div>`;
    }

    _isValid_gold() {
        return this._compCurrency.getRemainingCp() >= 0;
    }

    async _pGetCpSpent() {
        const expenses = await Promise.all(this._state.itemPurchases.map(async itemMeta=>{
            if (itemMeta.data.isIgnoreCost)
                return 0;

            const [name,source] = itemMeta.data.uid.split("|");
            const item = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
                name,
                source
            }));
            return item.value * Config.get("equipmentShop", "priceMultiplier") * (itemMeta.data.quantity || 1);
        }
        ));
        return expenses.reduce((a,b)=>a + b, 0);
    }

    async _pGetItemEntries() {
        if (!this._state.itemPurchases.length)
            return null;

        const combinedItems = {};

        for (const itemPurchase of this._state.itemPurchases) {
            combinedItems[itemPurchase.data.uid] = combinedItems[itemPurchase.data.uid] || 0;
            combinedItems[itemPurchase.data.uid] += itemPurchase.data.quantity || 1;
        }

        const out = [];
        const entries = Object.entries(combinedItems);
        for (const [uid,quantity] of entries) {
            const [name,source] = uid.split("|");
            const item = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
                name,
                source
            }));
            out.push({
                item,
                quantity,
            });
        }

        return out;
    }

    addBoughtItem(itemUid, opts) {
        opts = opts || {};
        opts.quantity = opts.quantity === undefined ? 1 : opts.quantity;
        opts.isTriggerUpdate = opts.isTriggerUpdate === undefined ? true : opts.isTriggerUpdate;
        opts.isIgnoreCost = opts.isIgnoreCost === undefined ? false : opts.isIgnoreCost;

        itemUid = itemUid.toLowerCase();
        const collectionId = `${itemUid}__${opts.isIgnoreCost}`;

        const existing = this._state.itemPurchases.find(it=>it.id === collectionId);
        if (existing) {
            existing.data.quantity += opts.quantity;
        } else {
            this._state.itemPurchases.push({
                id: collectionId,
                data: {
                    uid: itemUid,
                    quantity: opts.quantity,
                    isIgnoreCost: opts.isIgnoreCost,
                },
            });
        }

        if (opts.isTriggerUpdate)
            this._triggerCollectionUpdate("itemPurchases");
    }

    _getDefaultState() {
        return {
            itemPurchases: [],

            itemDatas: [],
        };
    }
};


//#endregion

//#region Charactermancer Spell
class ActorCharactermancerSpell extends ActorCharactermancerBaseComponent {
    constructor(parentInfo) {
      parentInfo = parentInfo || {};
      super();
      this._actor = parentInfo.actor;
      this._data = parentInfo.data;
      this._parent = parentInfo.parent;
      this._tabSpells = parentInfo.tabSpells;
      this._pageFilterSpells = new PageFilterSpells();
      //TEMPFIX
      this._modalFilterSpells = new ModalFilterSpells({//new ModalFilterSpellsFvtt({
        'namespace': "ActorCharactermancer.spells",
        'isRadio': true,
        'allData': this._data.spell
      });
      this._filterValuesSpellsCache = null;
      this._lastSearchTermSpells = '';
      this._compsSpellSpells = [];
      this._compsSpellSpellSlotLevelSelect = [];
      this._compSpellAdditionalSpellRace = null;
      this._compSpellAdditionalSpellBackground = null;
      this._compsSpellAdditionalSpellClass = [];
      this._compsSpellAdditionalSpellSubclass = [];
    }

    async pRender() {
        const wrpTab = this._tabSpells?.$wrpTab;
        if (!wrpTab) { return; }
        const leftContent = $$`<div class="ve-flex-col w-100 h-100 px-1 overflow-y-auto ve-grow veapp__bg-foundry smooth-scroll"></div>`;
        const rightContent = $$`<div class="ve-flex-col w-100"></div>`;
        const dispSpell = $$`<div class="ve-flex-col w-100 h-100"></div>`;
        await this._spell_pRenderFilterBox(leftContent);
        for (let i = 0; i < this._parent.compClass.state.class_ixMax + 1; ++i) {
          this._spell_renderClassSection(leftContent, rightContent, dispSpell, i);
        }
        const refreshClassMax = () => {
          this._spell_renderClassSection(leftContent, rightContent, dispSpell, this._parent.compClass.state.class_ixMax);
        };
        this._parent.compClass.addHookBase("class_ixMax", refreshClassMax);
        this._spell_renderRaceSection(leftContent);
        this._spell_renderBackgroundSection(leftContent);
        this._spell_handleFilterChange();
        $$`<div class="ve-flex w-100 h-100">
                ${leftContent}
    
                <div class="vr-1"></div>
    
                <div class="ve-flex-col w-100 h-100 px-1 overflow-y-auto ve-grow veapp__bg-foundry smooth-scroll">
                    ${rightContent}
                    ${dispSpell}
                </div>
            </div>`.appendTo(wrpTab);
    }

    
    _spell_renderClassSection(div1, div2, dispSpell, classIndex) {
        const {
          propIxClass: propIxClass,
          propIxSubclass: propIxSubclass,
          propTargetLevel: propTargetLevel
        } = ActorCharactermancerBaseComponent.class_getProps(classIndex);
        const dispClassNameLeft = $("<h2 class=\"m-0 b-0 py-1\"></h2>");
        const wrpPreparedLearnedLhs = $$`<div class="mb-1 ve-muted ve-small manc-sp__disp-prepared ve-flex-v-center"></div>`;
        const wrpPreparedLearnedRhs = $$`<div class="mb-1 ve-muted ve-small manc-sp__disp-prepared ve-flex-v-center"></div>`;
        const wrpSlotLevelSelect = $$`<div class="mb-1 ve-flex-col"></div>`;
        const dispClassNameRight = $("<h2 class=\"m-0 b-0 py-1\"></h2>");
        const classSpells = $$`<div class="ve-flex-col"></div>`;
        const classAdditionalSpells = $$`<div class="ve-flex-col"></div>`.hideVe();
        const subclassAdditionalSpells = $$`<div class="ve-flex-col"></div>`.hideVe();
        const spellsTable = $$`<div class="ve-flex-col"></div>`;

        const $leftContentToggle = $("<div class=\"py-1 clickable ve-muted\">[‒]</div>").click(() => {
          $leftContentToggle.text($leftContentToggle.text() === "[+]" ? "[‒]" : "[+]");
          wrpSlotLevelSelect.toggleVe();
          $leftContent.toggleVe();
        });
        const $leftContent = $$`<div class="ve-flex-col w-100">
                ${classSpells}
                ${classAdditionalSpells}
                ${subclassAdditionalSpells}
            </div>`;
        const wrpLeftInner = $$`<div class="ve-flex-col mb-2">
                <div class="split-v-center">
                    ${dispClassNameLeft}
                    ${$leftContentToggle}
                </div>
                ${wrpPreparedLearnedLhs}
                ${wrpSlotLevelSelect}
    
                ${$leftContent}
            </div>`.appendTo(div1);

        const $spellsTableToggle = $("<div class=\"py-1 clickable ve-muted\">[‒]</div>").click(() => {
          $spellsTableToggle.text($spellsTableToggle.text() === "[+]" ? "[‒]" : '[+]');
          $spellsTable.toggleVe();
        });
        const $spellsTable = $$`<div class="ve-flex-col w-100">
                ${spellsTable}
            </div>`;
        const wrpRightInner = $$`<div class="ve-flex-col w-100">
                <div class="split-v-center">
                    ${dispClassNameRight}
                    ${$spellsTableToggle}
                </div>
                ${wrpPreparedLearnedRhs}
    
                ${$spellsTable}
    
                <hr class="hr-2">
            </div>`.appendTo(div2);
        
        const hook_onChangeClass = this._hk_onChangeClass.bind(this, classIndex, {
          '$dispClassNameLeft': dispClassNameLeft,
          '$dispClassNameRight': dispClassNameRight,
          '$stgClassAdditionalSpells': classAdditionalSpells,
          '$stgSubclassAdditionalSpells': subclassAdditionalSpells,
          '$wrpLeftInner': wrpLeftInner,
          '$wrpRightInner': wrpRightInner,
          '$stgClassSpells': classSpells,
          '$stgSpellsTable': spellsTable,
          '$dispSpell': dispSpell,
          '$wrpSlotLevelSelect': wrpSlotLevelSelect,
          '$wrpPreparedLearnedLhs': wrpPreparedLearnedLhs,
          '$wrpPreparedLearnedRhs': wrpPreparedLearnedRhs
        });
        const hook_onChangeSubclass = this._hk_onChangeSubclass.bind(this, classIndex, {
          '$dispClassNameLeft': dispClassNameLeft,
          '$dispClassNameRight': dispClassNameRight,
          '$stgSubclassAdditionalSpells': subclassAdditionalSpells,
          '$wrpLeftInner': wrpLeftInner,
          '$wrpRightInner': wrpRightInner,
          '$stgClassSpells': classSpells,
          '$stgSpellsTable': spellsTable,
          '$dispSpell': dispSpell,
          '$wrpSlotLevelSelect': wrpSlotLevelSelect,
          '$wrpPreparedLearnedLhs': wrpPreparedLearnedLhs,
          '$wrpPreparedLearnedRhs': wrpPreparedLearnedRhs
        });
        const hook_onChangeLevel = this._hk_onChangeLevel.bind(this, classIndex, {
          '$wrpLeftInner': wrpLeftInner,
          '$wrpRightInner': wrpRightInner
        });
        const hook_onChangeAbilityScores = this._hk_onChangeAbilityScores.bind(this, classIndex);
        this._parent.compClass.addHookBase(propIxClass, hook_onChangeClass);
        this._parent.compClass.addHookBase(propIxSubclass, hook_onChangeSubclass);
        this._parent.compClass.addHookBase(propTargetLevel, hook_onChangeLevel);
        this._parent.compAbility.addHookAbilityScores(hook_onChangeAbilityScores);
        hook_onChangeClass();
    }
    _spell_renderRaceSection(wrapperDiv) {
        return this._spell_renderRaceBackgroundSection({
            '$wrpLeft': wrapperDiv,
            'propPulse': 'race_ixRace_version',
            'propCompAdditionalSpells': "_compSpellAdditionalSpellRace",
            'propAlwaysPreparedSpells': "alwaysPreparedSpellsRace",
            'propExpandedSpells': 'expandedSpellsRace',
            'propAlwaysKnownSpells': "alwaysKnownSpellsRace",
            'compEntity': this._parent.compRace,
            'fnGetEntity': () => this._parent.compRace.getRace_()
        });
    }
    _spell_renderBackgroundSection(wrapperDiv) {
    return this._spell_renderRaceBackgroundSection({
        '$wrpLeft': wrapperDiv,
        'propPulse': 'background_pulseBackground',
        'propCompAdditionalSpells': '_compSpellAdditionalSpellBackground',
        'propAlwaysPreparedSpells': 'alwaysPreparedSpellsBackground',
        'propExpandedSpells': "expandedSpellsBackground",
        'propAlwaysKnownSpells': "alwaysKnownSpellsBackground",
        'compEntity': this._parent.compBackground,
        'fnGetEntity': () => this._parent.compBackground.getFeatureCustomizedBackground_({
        'isAllowStub': false
        })
    });
    }
    _spell_renderRaceBackgroundSection({
    $wrpLeft: _0x131507,
    propPulse: _0x4d4b30,
    propCompAdditionalSpells: _0x2c7856,
    propAlwaysPreparedSpells: _0x386d55,
    propExpandedSpells: _0x43a2cb,
    propAlwaysKnownSpells: _0x1ad25b,
    compEntity: _0x643cf8,
    fnGetEntity: _0x130b8f
    }) {
    const _0x4daa7e = $$`<div class="ve-flex-col"></div>`.hideVe();
    const _0x1e5e23 = () => {
        const _0x25399e = this._parent.compClass.getExistingClassTotalLevels_();
        const _0x5d1c58 = this._parent.compClass.state.class_totalLevels;
        if (this[_0x2c7856]) {
        this[_0x2c7856].curLevel = _0x25399e;
        this[_0x2c7856].targetLevel = Math.max(0x1, _0x5d1c58);
        const {
            min: _0x359352,
            max: _0x46f5a0,
            isAnyCantrips: _0x23be13
        } = this._parent.compClass.class_getMinMaxSpellLevel();
        this[_0x2c7856].spellLevelLow = _0x359352;
        this[_0x2c7856].spellLevelHigh = _0x46f5a0;
        this[_0x2c7856].isAnyCantrips = _0x23be13;
        }
    };
    this._parent.compClass.addHookBase("class_totalLevels", _0x1e5e23);
    this._parent.compClass.addHookBase("class_pulseChange", _0x1e5e23);
    const _0x5951b3 = $("<h2 class=\"m-0 b-0 py-1\"></h2>");
    const _0x236ff0 = $("<div class=\"py-1 clickable ve-muted\">[‒]</div>").click(() => {
        _0x236ff0.text(_0x236ff0.text() === "[+]" ? "[‒]" : "[+]");
        _0x3dfdd1.toggleVe();
    });
    const _0x3dfdd1 = $$`<div class="ve-flex-col w-100">
            ${_0x4daa7e}
        </div>`;
    const _0x385acb = $$`<div class="ve-flex-col w-100 mb-2">
            <div class="split-v-center">
                ${_0x5951b3}
                ${_0x236ff0}
            </div>

            ${_0x3dfdd1}
        </div>`.hideVe().appendTo(_0x131507);
    const _0x3fde61 = () => {
        _0x4daa7e.empty();
        const _0x4b8090 = _0x130b8f();
        let _0x41e5d8 = false;
        if (_0x4b8090 && _0x4b8090.additionalSpells) {
        _0x41e5d8 = true;
        _0x4daa7e.showVe();
        this[_0x2c7856] = new Charactermancer_AdditionalSpellsSelect({
            'spellDatas': this._data.spell,
            'additionalSpells': _0x4b8090.additionalSpells,
            'modalFilterSpells': this._modalFilterSpells
        });
        this[_0x2c7856].render(_0x4daa7e);
        const _0x102760 = () => this._compsSpellSpells.filter(Boolean).forEach(_0x3d6b3a => _0x3d6b3a[_0x386d55] = MiscUtil.copy(this[_0x2c7856].spellsAlwaysPrepared));
        this[_0x2c7856].addHookAlwaysPreparedSpells(_0x102760);
        _0x102760();
        const _0x58b6da = () => this._compsSpellSpells.filter(Boolean).forEach(_0x169ba4 => _0x169ba4[_0x43a2cb] = MiscUtil.copy(this[_0x2c7856].spellsExpanded));
        this[_0x2c7856].addHookExpandedSpells(_0x58b6da);
        _0x58b6da();
        const _0x347f7c = () => this._compsSpellSpells.filter(Boolean).forEach(_0x4ad8ca => _0x4ad8ca[_0x1ad25b] = MiscUtil.copy(this[_0x2c7856].spellsAlwaysKnown));
        this[_0x2c7856].addHookAlwaysKnownSpells(_0x347f7c);
        _0x347f7c();
        } else {
        _0x4daa7e.hideVe();
        this[_0x2c7856] = null;
        this._compsSpellSpells.filter(Boolean).forEach(_0x36b14f => _0x36b14f[_0x43a2cb] = []);
        }
        if (_0x4b8090 && _0x41e5d8) {
        _0x385acb.showVe();
        _0x5951b3.text(_0x4b8090.name);
        } else {
        _0x385acb.hideVe();
        }
        _0x1e5e23();
    };
    _0x643cf8.addHookBase(_0x4d4b30, _0x3fde61);
    _0x3fde61();
    }

    get modalFilterSpells() {
      return this._modalFilterSpells;
    }
    get ['filterValuesSpellsCache']() {
      return this._filterValuesSpellsCache;
    }
    get ["filterBoxSpells"]() {
      return this._pageFilterSpells?.["filterBox"];
    }
    get ["compsSpellSpells"]() {
      return this._compsSpellSpells;
    }
    get ["compsSpellSpellSlotLevelSelect"]() {
      return this._compsSpellSpellSlotLevelSelect;
    }
    get ["compSpellAdditionalSpellRace"]() {
      return this._compSpellAdditionalSpellRace;
    }
    get ["compSpellAdditionalSpellBackground"]() {
      return this._compSpellAdditionalSpellBackground;
    }
    get ["compsSpellAdditionalSpellClass"]() {
      return this._compsSpellAdditionalSpellClass;
    }
    get ["compsSpellAdditionalSpellSubclass"]() {
      return this._compsSpellAdditionalSpellSubclass;
    }
    async pLoad() {
      await this._modalFilterSpells.pPreloadHidden();
    }
    
    async _spell_pRenderFilterBox(_0x4d3419) {
      const _0x58361b = $("<button class=\"btn-5et veapp__btn-filter\">Filter</button>");
      const _0x6136bd = $("<button class=\"btn btn-5et\" title=\"Toggle Filter Summary Display\"><span class=\"glyphicon glyphicon-resize-small\"></span></button>");
      const _0x40698b = $("<input type=\"search\" class=\"search w-100 form-control h-initial\" placeholder=\"Find spell...\">");
      const _0x4f7872 = $("<button class=\"btn-5et veapp__btn-list-reset\">Reset</button>").click(() => _0x40698b.val('').keyup());
      const _0x3f79c5 = $("<div class=\"fltr__mini-view btn-group\"></div>");
      const _0x48d54c = $("<button class=\"btn btn-default btn-xs mr-1\" title=\"Save a copy of the current filters, to use when filtering spell lists during import of &quot;prepared spell&quot; casters. For example, if you want your Cleric's spell list to include only PHB spells, you would filter (using the interface above) for PHB spells, then click this button. Note that all the spells that you have selected as learned or that you have selected as prepared will be imported regardless.\">Set Prepared Spell Filter</button>").click(() => {
        this._filterValuesSpellsCache = this._pageFilterSpells.filterBox.getValues();
        ui.notifications.info("Set!");
      });
      const _0x3c7f8e = ComponentUiUtil.$getBtnBool(this, "spells_isIncludeUaEtcSpellLists", {
        '$ele': $("<button class=\"btn btn-default btn-xs\" title=\"Include spell lists defined in Unearthed Arcana, Plane Shift, and other semi-official products when generating the list of spells which can be learned/prepared.\">Include UA/etc. Spell Lists</button>")
      });
      const _0x37412f = () => this._compsSpellSpells.filter(Boolean).forEach(_0x2638d9 => _0x2638d9.isIncludeUaEtcSpellLists = this._state.spells_isIncludeUaEtcSpellLists);
      this._addHookBase("spells_isIncludeUaEtcSpellLists", _0x37412f);
      _0x37412f();
      $$(_0x4d3419)`
              <div class="ve-flex-v-stretch input-group input-group--top no-shrink">
                  ${_0x58361b}
                  ${_0x6136bd}
                  ${_0x40698b}
                  ${_0x4f7872}
              </div>
              ${_0x3f79c5}
              <div class="ve-flex-v-stretch input-group input-group--bottom mb-1 no-shrink">
                  <button class="btn-5et w-100" disabled></button>
              </div>
  
              <div class="mb-1 ve-flex-v-center">${_0x48d54c}${_0x3c7f8e}</div>
          `;
      await this._pageFilterSpells.pInitFilterBox({
        '$iptSearch': _0x40698b,
        '$btnReset': _0x4f7872,
        '$btnOpen': _0x58361b,
        '$btnToggleSummaryHidden': _0x6136bd,
        '$wrpMiniPills': _0x3f79c5,
        'namespace': "ActorCharactermancer.spells_page"
      });
      this._data.spell.forEach(_0x420235 => this._pageFilterSpells.mutateAndAddToFilters(_0x420235));
      this._pageFilterSpells.trimState();
      this._pageFilterSpells.filterBox.render();
      this._filterValuesSpellsCache = this._pageFilterSpells.filterBox.getValues();
      UiUtil.bindTypingEnd({
        '$ipt': _0x40698b,
        'fnKeyup': () => {
          const _0xd1900 = List.getCleanSearchTerm(_0x40698b.val());
          if (this._lastSearchTermSpells === _0xd1900) {
            return;
          }
          this._lastSearchTermSpells = _0xd1900;
          this._compsSpellSpells.filter(Boolean).forEach(_0x34795b => _0x34795b.handleSearch(_0xd1900));
        }
      });
      this._pageFilterSpells.filterBox.on(FilterBox.EVNT_VALCHANGE, this._spell_handleFilterChange.bind(this));
    }
    _spell_handleFilterChange() {
      const filterVals = this._pageFilterSpells.filterBox.getValues();
      this._compsSpellSpells.filter(Boolean).forEach(spell => spell.handleFilterChange(filterVals));
    }
    ["_spell_getFixedLearnedProgression"](_0x17551c, _0x501a5c, _0x53b321, _0x1a246c, {
      isExistingClass: _0x5b35a8,
      isDefault = false
    } = {}) {
      const _0x20bca5 = this._compsSpellSpellSlotLevelSelect[_0x17551c] ? this._compsSpellSpellSlotLevelSelect[_0x17551c].getFormData() : null;
      return Charactermancer_Spell_Util.getFixedLearnedProgression({
        'cls': _0x501a5c,
        'sc': _0x53b321,
        'targetLevel': _0x1a246c,
        'isExistingClass': _0x5b35a8,
        'isDefault': isDefault,
        'formDataSlotSelectFromComp': _0x20bca5
      });
    }
    ['_spell_getMaxPreparedSpells'](_0x1410c8, _0x57434c, _0x179df8, {
      existingAbilityScores: _0x253c72
    } = {}) {
      const _0xc67216 = this._parent.compAbility.getTotals();
      return Charactermancer_Spell_Util.getMaxPreparedSpells({
        'cls': _0x1410c8,
        'sc': _0x57434c,
        'targetLevel': _0x179df8,
        'existingAbilityScores': _0x253c72,
        'abilityScoresFromComp': _0xc67216
      });
    }
    //#region Hooks
    _hk_onChangeClass(classIndex, {
        $stgClassSpells: stgClassSpells,
        $stgSpellsTable: stgSpellsTable,
        $dispClassNameLeft: _0x5277af,
        $dispClassNameRight: _0x2eb7d0,
        $stgClassAdditionalSpells: stgClassAdditionalSpells,
        $stgSubclassAdditionalSpells: _0xb823dd,
        $wrpLeftInner: wrpLeftInner,
        $wrpRightInner: wrpRightInner,
        $dispSpell: dispSpell,
        $wrpSlotLevelSelect: wrpSlotLevelSelect,
        $wrpPreparedLearnedLhs: _0x1f316b,
        $wrpPreparedLearnedRhs: _0x16ec1d
        }) {
        const {
            propIxClass: propIxClass,
            propIxSubclass: propIxSubclass,
            propTargetLevel: propTargetLevel
        } = ActorCharactermancerBaseComponent.class_getProps(classIndex);

        const cls = this._parent.compClass.getClass_({ 'propIxClass': propIxClass });
        const subcls = this._parent.compClass.getSubclass_({ 'cls': cls, 'propIxSubclass': propIxSubclass });

        if (!cls || !this.constructor._spell_isClassCaster(cls, subcls)) {
            this._hk_shared_doCleanupClassSubclass({
            '$stgClassSpells': stgClassSpells,
            '$stgSpellsTable': stgSpellsTable,
            '$wrpLeftInner': wrpLeftInner,
            '$wrpRightInner': wrpRightInner,
            'ix': classIndex
            });
            return;
        }

        stgClassSpells.empty();
        stgSpellsTable.empty();

        this._hk_shared_doInitClassSubclass({
            'ix': classIndex,
            'cls': cls,
            'sc': subcls,
            '$wrpPreparedLearnedLhs': _0x1f316b,
            '$wrpPreparedLearnedRhs': _0x16ec1d,
            'propTargetLevel': propTargetLevel
        });
        stgClassAdditionalSpells.empty();

        if (cls && cls.additionalSpells) {
            stgClassAdditionalSpells.showVe().append("<div class=\"bold mb-2\">Class Spells (" + cls.name + ")</div>");
            this._compsSpellAdditionalSpellClass[classIndex] = new Charactermancer_AdditionalSpellsSelect({
            'spellDatas': this._data.spell,
            'additionalSpells': cls.additionalSpells,
            'modalFilterSpells': this._modalFilterSpells
            });
            this._compsSpellAdditionalSpellClass[classIndex].render(stgClassAdditionalSpells);

            const setAlwaysPrepared = () => {
            if (this._compsSpellSpells[classIndex]) {
                this._compsSpellSpells[classIndex].alwaysPreparedSpellsClass = MiscUtil.copy(this._compsSpellAdditionalSpellClass[classIndex].spellsAlwaysPrepared);
            }
            };
            this._compsSpellAdditionalSpellClass[classIndex].addHookAlwaysPreparedSpells(setAlwaysPrepared);
            const setExpandedSpells = () => {
            if (this._compsSpellSpells[classIndex]) {
                this._compsSpellSpells[classIndex].expandedSpellsClass = MiscUtil.copy(this._compsSpellAdditionalSpellClass[classIndex].spellsExpanded);
            }
            };
            this._compsSpellAdditionalSpellClass[classIndex].addHookExpandedSpells(setExpandedSpells);
            const setAlwaysKnown = () => {
            if (this._compsSpellSpells[classIndex]) {
                this._compsSpellSpells[classIndex].alwaysKnownSpellsClass = MiscUtil.copy(this._compsSpellAdditionalSpellClass[classIndex].spellsAlwaysKnown);
            }
            };
            this._compsSpellAdditionalSpellClass[classIndex].addHookAlwaysKnownSpells(setAlwaysKnown);
        }
        else {
            stgClassAdditionalSpells.hideVe();
            this._compsSpellAdditionalSpellClass[classIndex] = null;
        }
        this._hk_onChangeSubclass(classIndex, {
            '$dispClassNameLeft': _0x5277af,
            '$dispClassNameRight': _0x2eb7d0,
            '$stgClassSpells': stgClassSpells,
            '$stgSpellsTable': stgSpellsTable,
            '$stgSubclassAdditionalSpells': _0xb823dd,
            '$wrpLeftInner': wrpLeftInner,
            '$wrpRightInner': wrpRightInner
        });

        if (this._compsSpellSpells[classIndex] && this._compsSpellAdditionalSpellClass[classIndex]) {
            this._compsSpellSpells[classIndex].alwaysPreparedSpellsClass = MiscUtil.copy(this._compsSpellAdditionalSpellClass[classIndex].spellsAlwaysPrepared);
            this._compsSpellSpells[classIndex].expandedSpellsClass = MiscUtil.copy(this._compsSpellAdditionalSpellClass[classIndex].spellsExpanded);
            this._compsSpellSpells[classIndex].alwaysKnownSpellsClass = MiscUtil.copy(this._compsSpellAdditionalSpellClass[classIndex].spellsAlwaysKnown);
        }
        else {
            if (this._compsSpellSpells[classIndex]) {
            this._compsSpellSpells[classIndex].alwaysPreparedSpellsClass = [];
            }
            if (this._compsSpellSpells[classIndex]) {
            this._compsSpellSpells[classIndex].expandedSpellsClass = [];
            }
            if (this._compsSpellSpells[classIndex]) {
            this._compsSpellSpells[classIndex].alwaysKnownSpellsClass = [];
            }
        }
        this._hk_shared_doRenderClassSubclass({
            'ix': classIndex,
            '$stgClassSpells': stgClassSpells,
            '$stgSpellsTable': stgSpellsTable,
            '$dispSpell': dispSpell,
            '$wrpSlotLevelSelect': wrpSlotLevelSelect
        });
    }
    _hk_shared_doCleanupClassSubclass({
      $stgClassSpells: _0x270abd,
      $stgSpellsTable: _0x1c463d,
      $wrpLeftInner: _0x5d1018,
      $wrpRightInner: _0x371727,
      ix: _0x3f7ee5
    }) {
      _0x270abd.empty();
      _0x1c463d.empty();
      _0x5d1018.hideVe();
      _0x371727.hideVe();
      this._compsSpellSpells[_0x3f7ee5] = null;
      this._compsSpellSpellSlotLevelSelect[_0x3f7ee5] = null;
    }
    _hk_shared_doInitClassSubclass({
        ix: ix,
        cls: cls,
        sc: subcls,
        $wrpPreparedLearnedLhs: wrpPreparedLearnedLhs,
        $wrpPreparedLearnedRhs: wrpPreparedLearnedRhs,
        propTargetLevel: propTargetLevel
        }) {
        const classMeta = this._parent.compClass.existingClassMetas[ix];
        this._compsSpellSpells[ix] = new Charactermancer_Spell({
            'actor': this._actor,
            'existingClass': classMeta ? this._data.class[classMeta.ixClass] : null,
            'existingCasterMeta': this._spell_getExistingCasterMeta({
            'ix': ix,
            'cls': cls,
            'sc': subcls,
            'existingClassMeta': classMeta
            }),
            'spellDatas': this._data.spell,
            'className': cls.name,
            'classSource': cls.source,
            'brewClassSpells': cls.classSpells,
            'subclassName': subcls?.['name'],
            'subclassShortName': subcls?.['shortName'],
            'subclassSource': subcls?.["source"],
            'brewSubclassSpells': subcls?.["subclassSpells"],
            'brewSubSubclassSpells': subcls?.["subSubclassSpells"],
            'pageFilter': this._pageFilterSpells,
            '$wrpsPreparedLearned': [wrpPreparedLearnedLhs, wrpPreparedLearnedRhs]
        });
        this._compsSpellSpellSlotLevelSelect[ix] = new Charactermancer_Spell_SlotLevelSelect({
            'className': cls.name,
            'spellSlotLevelSelection': classMeta?.spellSlotLevelSelection
        });
        const onPulseFixedLearnedProgression = () => {
            const targetLevel = this._parent.compClass.state[propTargetLevel];
            if (this._compsSpellSpells[ix]) {
            this._compsSpellSpells[ix].fixedLearnedProgression = this._spell_getFixedLearnedProgression(ix, cls, subcls, targetLevel);
            this._compsSpellSpells[ix].fixedLearnedProgressionDefault = this._spell_getFixedLearnedProgression(ix, cls, subcls, targetLevel, {
                'isDefault': true
            });
            }
        };
        this._compsSpellSpellSlotLevelSelect[ix].addHookPulseFixedLearnedProgression(onPulseFixedLearnedProgression);
        onPulseFixedLearnedProgression();
    }
    ["_hk_shared_doRenderClassSubclass"]({
      ix: _0x2eeb3f,
      $stgClassSpells: _0x5ba943,
      $stgSpellsTable: _0x2db431,
      $dispSpell: _0x13c893,
      $wrpSlotLevelSelect: _0x438fc7
    }) {
      this._compsSpellSpells[_0x2eeb3f].render(_0x5ba943, _0x13c893);
      this._compsSpellSpellSlotLevelSelect[_0x2eeb3f].render(_0x438fc7);
      const _0x408e9 = this._pageFilterSpells.filterBox.getValues();
      this._compsSpellSpells[_0x2eeb3f].handleFilterChange(_0x408e9);
      if (this._compSpellAdditionalSpellRace) {
        this._compsSpellSpells[_0x2eeb3f].expandedSpellsRace = MiscUtil.copy(this._compSpellAdditionalSpellRace.spellsExpanded);
      }
      if (this._compSpellAdditionalSpellBackground) {
        this._compsSpellSpells[_0x2eeb3f].expandedSpellsBackground = MiscUtil.copy(this._compSpellAdditionalSpellBackground.spellsExpanded);
      }
    }
    ["_hk_shared_doUpdateRenderedClassSubclass"]({
      ix: _0x554247
    }) {
      if (!this._compsSpellSpells[_0x554247]) {
        return;
      }
      const _0x5ab9aa = this._pageFilterSpells.filterBox.getValues();
      this._compsSpellSpells[_0x554247].handleFilterChange(_0x5ab9aa);
    }
    ['_hk_onChangeAbilityScores'](_0x2f45dd) {
      const {
        propIxClass: _0x115421,
        propTargetLevel: _0x46283c,
        propIxSubclass: _0x30dd06
      } = ActorCharactermancerBaseComponent.class_getProps(_0x2f45dd);
      const _0x30db5b = this._parent.compClass.getClass_({
        'propIxClass': _0x115421
      });
      const _0x1df5a1 = this._parent.compClass.getSubclass_({
        'cls': _0x30db5b,
        'propIxSubclass': _0x30dd06
      });
      const _0x4a29fe = this._parent.compClass.state[_0x46283c];
      if (this._compsSpellSpells[_0x2f45dd]) {
        this._compsSpellSpells[_0x2f45dd].maxPrepared = this._spell_getMaxPreparedSpells(_0x30db5b, _0x1df5a1, _0x4a29fe);
      }
    }
    ["_hk_onChangeSubclass"](_0x5b71a4, {
      $stgClassSpells: _0x444f7b,
      $stgSpellsTable: _0x4cb4f2,
      $dispClassNameLeft: _0x52df82,
      $dispClassNameRight: _0x1637ca,
      $stgSubclassAdditionalSpells: _0x15b9ef,
      $wrpLeftInner: _0x33539d,
      $wrpRightInner: _0x40dd6e,
      $wrpPreparedLearnedLhs: _0x43c8b8,
      $wrpPreparedLearnedRhs: _0xa96e32,
      $dispSpell: _0x1cc99a,
      $wrpSlotLevelSelect: _0x15fd72
    }) {
      const {
        propIxClass: _0x1c68a2,
        propIxSubclass: _0x483027,
        propTargetLevel: _0x1d7d55
      } = ActorCharactermancerBaseComponent.class_getProps(_0x5b71a4);
      const _0x37e482 = this._parent.compClass.getClass_({
        'propIxClass': _0x1c68a2
      });
      const _0x7e6e11 = this._parent.compClass.getSubclass_({
        'cls': _0x37e482,
        'propIxSubclass': _0x483027
      });
      const _0x2311c2 = _0x37e482 ? '' + _0x37e482.name + (_0x7e6e11 ? " (" + _0x7e6e11.name + ')' : '') : '';
      _0x52df82.text(_0x2311c2);
      _0x1637ca.text(_0x2311c2);
      this._hk_onChangeSubclass_pRenderSpellTable(_0x5b71a4, {
        'cls': _0x37e482,
        'sc': _0x7e6e11,
        '$stgSpellsTable': _0x4cb4f2
      });
      const _0x5eff8e = this.constructor._spell_isClassCaster(_0x37e482, _0x7e6e11);
      const _0x3599ff = _0x5eff8e && !this._compsSpellSpells[_0x5b71a4];
      if (!_0x5eff8e && this._compsSpellSpells[_0x5b71a4]) {
        this._hk_shared_doCleanupClassSubclass({
          '$stgClassSpells': _0x444f7b,
          '$stgSpellsTable': _0x4cb4f2,
          '$wrpLeftInner': _0x33539d,
          '$wrpRightInner': _0x40dd6e,
          'ix': _0x5b71a4
        });
        return;
      } else if (_0x3599ff) {
        this._hk_shared_doInitClassSubclass({
          'ix': _0x5b71a4,
          'cls': _0x37e482,
          'sc': _0x7e6e11,
          '$wrpPreparedLearnedLhs': _0x43c8b8,
          '$wrpPreparedLearnedRhs': _0xa96e32,
          'propTargetLevel': _0x1d7d55
        });
      }
      _0x15b9ef.empty();
      if (_0x7e6e11 && _0x7e6e11.additionalSpells) {
        _0x15b9ef.showVe().append("<div class=\"bold mb-2\">Subclass Spells (" + _0x7e6e11.name + ")</div>");
        this._compsSpellAdditionalSpellSubclass[_0x5b71a4] = new Charactermancer_AdditionalSpellsSelect({
          'spellDatas': this._data.spell,
          'additionalSpells': _0x7e6e11.additionalSpells,
          'modalFilterSpells': this._modalFilterSpells
        });
        this._compsSpellAdditionalSpellSubclass[_0x5b71a4].render(_0x15b9ef);
        const _0x44f9bf = () => {
          if (this._compsSpellSpells[_0x5b71a4]) {
            this._compsSpellSpells[_0x5b71a4].alwaysPreparedSpellsSubclass = MiscUtil.copy(this._compsSpellAdditionalSpellSubclass[_0x5b71a4].spellsAlwaysPrepared);
          }
        };
        this._compsSpellAdditionalSpellSubclass[_0x5b71a4].addHookAlwaysPreparedSpells(_0x44f9bf);
        const _0x12cd92 = () => {
          if (this._compsSpellSpells[_0x5b71a4]) {
            this._compsSpellSpells[_0x5b71a4].expandedSpellsSubclass = MiscUtil.copy(this._compsSpellAdditionalSpellSubclass[_0x5b71a4].spellsExpanded);
          }
        };
        this._compsSpellAdditionalSpellSubclass[_0x5b71a4].addHookExpandedSpells(_0x12cd92);
        const _0xe969c1 = () => {
          if (this._compsSpellSpells[_0x5b71a4]) {
            this._compsSpellSpells[_0x5b71a4].alwaysKnownSpellsSubclass = MiscUtil.copy(this._compsSpellAdditionalSpellSubclass[_0x5b71a4].spellsAlwaysKnown);
          }
        };
        this._compsSpellAdditionalSpellSubclass[_0x5b71a4].addHookAlwaysKnownSpells(_0xe969c1);
      } else {
        _0x15b9ef.hideVe();
        this._compsSpellAdditionalSpellSubclass[_0x5b71a4] = null;
      }
      this._hk_onChangeLevel(_0x5b71a4, {
        '$wrpLeftInner': _0x33539d,
        '$wrpRightInner': _0x40dd6e
      });
      const _0xec4f0f = DataConverter.getMaxCasterProgression(_0x37e482?.["casterProgression"], _0x7e6e11?.["casterProgression"]);
      if (this._compsSpellSpells[_0x5b71a4]) {
        this._compsSpellSpells[_0x5b71a4].subclassName = _0x7e6e11?.["name"];
        this._compsSpellSpells[_0x5b71a4].subclassShortName = _0x7e6e11?.["shortName"];
        this._compsSpellSpells[_0x5b71a4].subclassSource = _0x7e6e11?.['source'];
        this._compsSpellSpells[_0x5b71a4].casterProgression = _0xec4f0f;
      }
      if (this._compsSpellSpellSlotLevelSelect[_0x5b71a4]) {
        this._compsSpellSpellSlotLevelSelect[_0x5b71a4].casterProgression = _0xec4f0f;
      }
      if (this._compsSpellSpells[_0x5b71a4] && this._compsSpellAdditionalSpellSubclass[_0x5b71a4]) {
        this._compsSpellSpells[_0x5b71a4].alwaysPreparedSpellsSubclass = MiscUtil.copy(this._compsSpellAdditionalSpellSubclass[_0x5b71a4].spellsAlwaysPrepared);
        this._compsSpellSpells[_0x5b71a4].expandedSpellsSubclass = MiscUtil.copy(this._compsSpellAdditionalSpellSubclass[_0x5b71a4].spellsExpanded);
        this._compsSpellSpells[_0x5b71a4].alwaysKnownSpellsSubclass = MiscUtil.copy(this._compsSpellAdditionalSpellSubclass[_0x5b71a4].spellsAlwaysKnown);
      } else {
        if (this._compsSpellSpells[_0x5b71a4]) {
          this._compsSpellSpells[_0x5b71a4].alwaysPreparedSpellsSubclass = [];
        }
        if (this._compsSpellSpells[_0x5b71a4]) {
          this._compsSpellSpells[_0x5b71a4].expandedSpellsSubclass = [];
        }
        if (this._compsSpellSpells[_0x5b71a4]) {
          this._compsSpellSpells[_0x5b71a4].alwaysKnownSpellsSubclass = [];
        }
      }
      if (_0x3599ff) {
        this._hk_shared_doRenderClassSubclass({
          'ix': _0x5b71a4,
          '$stgClassSpells': _0x444f7b,
          '$dispSpell': _0x1cc99a,
          '$wrpSlotLevelSelect': _0x15fd72
        });
      } else {
        this._hk_shared_doUpdateRenderedClassSubclass({
          'ix': _0x5b71a4
        });
      }
    }
    async ["_hk_onChangeSubclass_pRenderSpellTable"](_0x260cc7, {
      cls: _0xf89f34,
      sc: _0x4b6e25,
      $stgSpellsTable: _0x1981f6
    }) {
      const {
        lockChangeSubclassTable: _0x3807b9
      } = this.constructor._spell_getLocks(_0x260cc7);
      try {
        await this._pLock(_0x3807b9);
        await this._hk_onChangeSubclass_pRenderSpellTable_(_0x260cc7, {
          'cls': _0xf89f34,
          'sc': _0x4b6e25,
          '$stgSpellsTable': _0x1981f6
        });
      } finally {
        this._unlock(_0x3807b9);
      }
    }
    async ['_hk_onChangeSubclass_pRenderSpellTable_'](_0x3851f4, {
      cls: _0x466edf,
      sc: _0x38f6f5,
      $stgSpellsTable: _0x2a454d
    }) {
      const _0x1c8632 = _0x466edf ? await DataLoader.pCacheAndGet("class", _0x466edf.source, UrlUtil.URL_TO_HASH_BUILDER["class"](_0x466edf)) : null;
      const _0x4665b7 = _0x38f6f5 ? await DataLoader.pCacheAndGet("subclass", _0x38f6f5.source, UrlUtil.URL_TO_HASH_BUILDER.subclass(_0x38f6f5)) : null;
      const _0x195423 = DataConverterClass.getRenderedClassTableFromDereferenced(_0x1c8632, _0x4665b7, {
        'isSpellsOnly': true
      });
      _0x2a454d.html('').fastSetHtml(_0x195423);
    }
    static ["_spell_getLocks"](_0x262a86) {
      return {
        'lockChangeSubclassTable': "spell_" + _0x262a86 + '_changeSubclassTable'
      };
    }
    _hk_onChangeLevel(classIx, {
        $wrpLeftInner: wrpLeftInner,
        $wrpRightInner: wrpRightInner
        }) {
        const {
            propIxClass: propIxClass,
            propIxSubclass: propIxSubclass,
            propCurLevel: propCurLevel,
            propTargetLevel: propTargetLevel
        } = ActorCharactermancerBaseComponent.class_getProps(classIx);
        const cls = this._parent.compClass.getClass_({
            'propIxClass': propIxClass
        });
        const subcls = this._parent.compClass.getSubclass_({
            'cls': cls,
            'propIxSubclass': propIxSubclass
        });
        const curLevel = this._parent.compClass.state[propCurLevel] ?? 0;
        const targetLevel = this._parent.compClass.state[propTargetLevel];
        const casterProgression = DataConverter.getMaxCasterProgression(cls?.casterProgression, subcls?.casterProgression);
        const casterProgressionMeta = Charactermancer_Spell_Util.getCasterProgressionMeta({
            'casterProgression': casterProgression,
            'curLevel': curLevel,
            'targetLevel': targetLevel
        });

        if (this._compsSpellSpells[classIx]) {
            if (casterProgressionMeta) {
            const {
                spellLevelLow: _0x2987bb,
                spellLevelHigh: _0x4adfd0
            } = casterProgressionMeta;
            this._compsSpellSpells[classIx].spellLevelLow = _0x2987bb;
            this._compsSpellSpells[classIx].spellLevelHigh = _0x4adfd0;
            } else {
            this._compsSpellSpells[classIx].spellLevelLow = null;
            this._compsSpellSpells[classIx].spellLevelHigh = null;
            }
            this._compsSpellSpells[classIx].maxLearnedCantrips = Charactermancer_Spell_Util.getMaxLearnedCantrips({
            'cls': cls,
            'sc': subcls,
            'targetLevel': targetLevel
            });
            this._compsSpellSpells[classIx].fixedLearnedProgression = this._spell_getFixedLearnedProgression(classIx, cls, subcls, targetLevel);
            this._compsSpellSpells[classIx].fixedLearnedProgressionDefault = this._spell_getFixedLearnedProgression(classIx, cls, subcls, targetLevel, {
            'isDefault': true
            });
            this._compsSpellSpells[classIx].isIncludeUaEtcSpellLists = this._state.spells_isIncludeUaEtcSpellLists;
        }
        this._hk_onChangeAbilityScores(classIx);
        if (this._compsSpellSpellSlotLevelSelect[classIx]) {
            this._compsSpellSpellSlotLevelSelect[classIx].curLevel = curLevel;
            this._compsSpellSpellSlotLevelSelect[classIx].targetLevel = targetLevel;
            this._compsSpellSpellSlotLevelSelect[classIx].spellsKnownProgression = cls?.["spellsKnownProgression"] || subcls?.["spellsKnownProgression"];
            this._compsSpellSpellSlotLevelSelect[classIx].casterProgression = casterProgression;
            this._compsSpellSpellSlotLevelSelect[classIx].spellsKnownProgressionFixed = cls?.["spellsKnownProgressionFixed"] || subcls?.["spellsKnownProgressionFixed"];
            this._compsSpellSpellSlotLevelSelect[classIx].spellsKnownProgressionFixedAllowLowerLevel = cls?.['spellsKnownProgressionFixedAllowLowerLevel'] || subcls?.["spellsKnownProgressionFixedAllowLowerLevel"];
        }
        if (this._compsSpellAdditionalSpellClass[classIx]) {
            this._compsSpellAdditionalSpellClass[classIx].curLevel = curLevel;
            this._compsSpellAdditionalSpellClass[classIx].targetLevel = targetLevel;
            if (casterProgressionMeta) {
            const {
                spellLevelLow: _0x5e1ad3,
                spellLevelHigh: _0x2b3c8c
            } = casterProgressionMeta;
            this._compsSpellAdditionalSpellClass[classIx].spellLevelLow = _0x5e1ad3;
            this._compsSpellAdditionalSpellClass[classIx].spellLevelHigh = _0x2b3c8c;
            } else {
            this._compsSpellAdditionalSpellClass[classIx].spellLevelLow = null;
            this._compsSpellAdditionalSpellClass[classIx].spellLevelHigh = null;
            }
        }
        if (this._compsSpellAdditionalSpellSubclass[classIx]) {
            this._compsSpellAdditionalSpellSubclass[classIx].curLevel = curLevel;
            this._compsSpellAdditionalSpellSubclass[classIx].targetLevel = targetLevel;
            if (casterProgressionMeta) {
            const {
                spellLevelLow: _0x494b35,
                spellLevelHigh: _0x11243b
            } = casterProgressionMeta;
            this._compsSpellAdditionalSpellSubclass[classIx].spellLevelLow = _0x494b35;
            this._compsSpellAdditionalSpellSubclass[classIx].spellLevelHigh = _0x11243b;
            } else {
            this._compsSpellAdditionalSpellSubclass[classIx].spellLevelLow = null;
            this._compsSpellAdditionalSpellSubclass[classIx].spellLevelHigh = null;
            }
        }
        if (cls) {
            const isCasterClassAtLevel = this.constructor._spell_isCasterClassAtLevel(cls, subcls, targetLevel);
            wrpLeftInner.toggleVe(isCasterClassAtLevel);
            const isClassCaster = this.constructor._spell_isClassCaster(cls, subcls);
            wrpRightInner.toggleVe(isClassCaster);
        }
    }
    //#endregion
    static ["_spell_isClassCaster"](_0x5c820c, _0xed7b9e) {
      return _0x5c820c?.["casterProgression"] || _0xed7b9e?.["casterProgression"] || _0x5c820c?.["additionalSpells"] || _0xed7b9e?.["additionalSpells"] || _0x5c820c?.["cantripProgression"] || _0xed7b9e?.["cantripProgression"];
    }
    static ["_spell_isCasterClassAtLevel"](_0x2a0e39, _0x31e64f, _0x338223) {
      if (!this._spell_isClassCaster(_0x2a0e39, _0x31e64f)) {
        return false;
      }
      if (_0x338223 == null) {
        return false;
      }
      const {
        casterProgression: _0x1e0ce2
      } = Charactermancer_Class_Util.getCasterProgression(_0x2a0e39, _0x31e64f, {
        'targetLevel': _0x338223
      });
      const _0x462c11 = UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[_0x1e0ce2];
      if ((_0x462c11?.[_0x338223 - 0x1] || []).some(Boolean)) {
        return true;
      }
      if (this._spell_isCasterClassAtLevel_additionalSpells(_0x2a0e39?.["additionalSpells"], _0x338223)) {
        return true;
      }
      if (this._spell_isCasterClassAtLevel_additionalSpells(_0x31e64f?.["additionalSpells"], _0x338223)) {
        return true;
      }
      if (this._spell_isCasterClassAtLevel_cantrips(_0x2a0e39?.["cantripProgression"], _0x338223)) {
        return true;
      }
      if (this._spell_isCasterClassAtLevel_cantrips(_0x31e64f?.['cantripProgression'], _0x338223)) {
        return true;
      }
      return false;
    }
    static ["_spell_isCasterClassAtLevel_additionalSpells"](_0x38e4ef, _0x2fbd60) {
      if (!_0x38e4ef) {
        return false;
      }
      if (_0x2fbd60 == null) {
        return false;
      }
      return _0x38e4ef.some(_0x3b9665 => this._spell_isCasterClassAtLevel_additionalSpellsBlock(_0x3b9665, _0x2fbd60));
    }
    static ["_spell_isCasterClassAtLevel_additionalSpellsBlock"](_0x269f28, _0x72034d) {
      const _0x5c8362 = Object.keys(_0x269f28);
      for (const _0x300d1e of _0x5c8362) {
        switch (_0x300d1e) {
          case "innate":
          case "prepared":
          case "expanded":
            {
              const _0x19d91e = Object.keys(_0x269f28[_0x300d1e] || {}).some(_0x4dbcd1 => {
                const _0x48a620 = /^s(\d+)$/i.exec(_0x4dbcd1);
                if (_0x48a620) {
                  return false;
                }
                if (isNaN(_0x4dbcd1)) {
                  return false;
                }
                return Number(_0x4dbcd1) <= _0x72034d;
              });
              if (_0x19d91e) {
                return true;
              }
            }
        }
      }
      return false;
    }
    static ["_spell_isCasterClassAtLevel_cantrips"](_0x2d0ad1, _0x1d6ef4) {
      return !!_0x2d0ad1?.[_0x1d6ef4 - 0x1];
    }
    ["_spell_getExistingCasterMeta"]({
      ix: _0x357258,
      cls: _0x59d9ff,
      sc: _0x5b73e4,
      existingClassMeta: _0x5783cd
    }) {
      if (!_0x5783cd?.["level"]) {
        return null;
      }
      const _0x458757 = this._compsSpellSpellSlotLevelSelect[_0x357258] ? this._compsSpellSpellSlotLevelSelect[_0x357258].getFormData() : null;
      const _0x5d87e1 = this._parent.compAbility.getTotals();
      return Charactermancer_Spell_Util.getExistingCasterMeta({
        'cls': _0x59d9ff,
        'sc': _0x5b73e4,
        'actor': this._actor,
        'targetLevel': _0x5783cd.level,
        'formDataSlotSelectFromComp': _0x458757,
        'abilityScoresFromComp': _0x5d87e1
      });
    }
    ["_getDefaultState"]() {
      return {
        'spells_isIncludeUaEtcSpellLists': false
      };
    }
}
class Charactermancer_Spell_Util {
    static getCasterProgressionMeta({casterProgression, curLevel, targetLevel, isBreakpointsOnly=false}) {
        if (casterProgression == null || curLevel == null || targetLevel == null)
            return null;

        const progression = UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[casterProgression];
        if (!progression)
            return null;

        const levelToSpellLevel = [];
        let lastSpellLevel = 0;
        progression.forEach(slots=>{
            let isFound = false;
            for (let i = 0; i < slots.length; ++i) {
                const spellLevel = i + 1;
                if (slots[i] && spellLevel > lastSpellLevel) {
                    levelToSpellLevel.push(spellLevel);
                    lastSpellLevel = spellLevel;
                    isFound = true;
                    break;
                }
            }
            if (!isFound) {
                if (isBreakpointsOnly)
                    levelToSpellLevel.push(null);
                else
                    levelToSpellLevel.push(levelToSpellLevel.length ? levelToSpellLevel.last() : null);
            }
        }
        );

        const spannedLevels = levelToSpellLevel.slice(curLevel, targetLevel).filter(Boolean);
        if (!spannedLevels.length)
            return null;

        const spellLevelLow = Math.min(...spannedLevels);
        const spellLevelHigh = Math.max(...spannedLevels);

        const deltaLevels = Math.max(0, targetLevel - curLevel);
        const deltaSpellLevels = spellLevelHigh - spellLevelLow;

        return {
            spellLevelLow,
            spellLevelHigh,
            deltaLevels,
            deltaSpellLevels,
        };
    }

    static getCasterCantripProgressionMeta({cls, sc, curLevel, targetLevel}) {
        if (cls == null || curLevel == null || targetLevel == null)
            return null;

        const atCurLevel = curLevel === 0 ? 0 : this.getMaxLearnedCantrips({
            cls,
            sc,
            targetLevel: curLevel
        });
        const atTargetLevel = this.getMaxLearnedCantrips({
            cls,
            sc,
            targetLevel: targetLevel
        });
        if (atCurLevel == null || atTargetLevel == null)
            return null;

        const deltaLevels = Math.max(0, targetLevel - curLevel);
        const deltaMaxCantrips = atTargetLevel - atCurLevel;

        return {
            maxCantripsLow: atCurLevel,
            maxCantripsHigh: atTargetLevel,
            deltaLevels,
            deltaMaxCantrips,
        };
    }

    static getMaxLearnedCantrips({cls, sc, targetLevel}) {
        if (!cls || targetLevel == null)
            return null;

        let cantripProgression = DataConverter.getMaxCantripProgression(cls.cantripProgression, sc?.cantripProgression);

        if (PrereleaseUtil.hasSourceJson(cls.source) || (sc && PrereleaseUtil.hasSourceJson(sc.source)))
            cantripProgression = cantripProgression || this._getApproximateCantripProgression({
                cls,
                sc
            });
        if (BrewUtil2.hasSourceJson(cls.source) || (sc && BrewUtil2.hasSourceJson(sc.source)))
            cantripProgression = cantripProgression || this._getApproximateCantripProgression({
                cls,
                sc
            });

        if (!cantripProgression)
            return null;

        return cantripProgression[targetLevel - 1];
    }

    static _getApproximateCantripProgression({cls, sc}) {
        return this._getApproximateNumberCol({
            cls,
            sc,
            colNameLower: "cantrips known"
        });
    }

    static _getApproximateSpellsKnownProgression(cls, sc) {
        return this._getApproximateNumberCol({
            cls,
            sc,
            colNameLower: "spells known"
        });
    }

    static _getApproximateNumberCol({cls, sc, colNameLower}) {
        const tableGroups = (PrereleaseUtil.hasSourceJson(cls.source) ? cls.classTableGroups : null) || ((sc && PrereleaseUtil.hasSourceJson(sc.source)) ? sc?.subclassTableGroups : null) || (BrewUtil2.hasSourceJson(cls.source) ? cls.classTableGroups : null) || ((sc && BrewUtil2.hasSourceJson(sc.source)) ? sc?.subclassTableGroups : null);
        if (!tableGroups)
            return;
        for (const tblGroup of tableGroups) {
            const ixCol = (tblGroup.colLabels || []).findIndex(it=>`${it}`.toLowerCase().includes(colNameLower));
            if (!~ixCol)
                continue;

            const numbers = (tblGroup.rowsSpellProgression || tblGroup.rows || []).map(row=>row.filter((_,ixCell)=>ixCell === ixCol)).flat();

            if (numbers.every(it=>!isNaN(it)))
                return numbers.map(it=>Number(it));
        }
    }

    static getFixedLearnedProgression({cls, sc, targetLevel, isExistingClass, isDefault=false, formDataSlotSelectFromComp}={}) {
        if (targetLevel == null)
            return null;

        const casterProgression = DataConverter.getMaxCasterProgression(cls.casterProgression, sc?.casterProgression);

        if (!casterProgression || !UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[casterProgression])
            return null;

        const totalKnownPerLevel = [...new Array(9)].map(()=>0);

        let isAnyData = false;

        const formDataSlotSelect = (isExistingClass || isDefault) ? Charactermancer_Spell_SlotLevelSelect.getDefaultFormData({
            targetLevel,
            casterProgression,
            spellsKnownProgression: cls?.spellsKnownProgression || sc?.spellsKnownProgression,
            spellsKnownProgressionFixed: cls?.spellsKnownProgressionFixed || sc?.spellsKnownProgressionFixed,
        }) : formDataSlotSelectFromComp;

        if (formDataSlotSelect) {
            isAnyData = isAnyData || formDataSlotSelect?.isAnyData;
            if (formDataSlotSelect?.data)
                formDataSlotSelect.data.forEach((it,i)=>totalKnownPerLevel[i] += it);
        }

        if (cls.spellsKnownProgressionFixedByLevel) {
            isAnyData = true;

            Object.entries(cls.spellsKnownProgressionFixedByLevel).forEach(([lvl,spellSummary])=>{
                if (Number(lvl) > targetLevel)
                    return;

                Object.entries(spellSummary).forEach(([lvlSpell,count])=>{
                    lvlSpell = Number(lvlSpell);
                    totalKnownPerLevel[lvlSpell - 1] += count;
                }
                );
            }
            );
        }

        if (!isAnyData)
            return null;

        return totalKnownPerLevel;
    }

    static getMaxPreparedSpells({cls, sc, targetLevel, existingAbilityScores, abilityScoresFromComp}={}) {
        if (!cls || targetLevel == null)
            return null;

        const casterProgression = DataConverter.getMaxCasterProgression(cls.casterProgression, sc?.casterProgression);

        if (!casterProgression || !UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[casterProgression])
            return null;

        const spellSlotsAtLevel = UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[casterProgression][targetLevel - 1];
        if (!spellSlotsAtLevel)
            return null;

        if (!spellSlotsAtLevel.some(Boolean))
            return null;

        if (cls.preparedSpellsProgression || sc?.preparedSpellsProgression)
            return this._getMaxPreparedSpells_preparedSpellsProgression({
                cls,
                sc,
                targetLevel,
                existingAbilityScores,
                abilityScoresFromComp
            });
        return this._getMaxPreparedSpells_preparedSpells({
            cls,
            sc,
            targetLevel,
            existingAbilityScores,
            abilityScoresFromComp
        });
    }

    static _getMaxPreparedSpells_preparedSpells({cls, sc, targetLevel, existingAbilityScores, abilityScoresFromComp}) {
        let preparedSpellExpression = cls.preparedSpells;

        if ((PrereleaseUtil.hasSourceJson(cls.source) || BrewUtil2.hasSourceJson(cls.source)) && !this._hasWellDefinedSpellData(cls, sc)) {
            preparedSpellExpression = preparedSpellExpression || this._getApproximatePreparedFormula(cls, sc);
        }

        if (!preparedSpellExpression)
            return null;

        const totalsAsi = abilityScoresFromComp;
        const preparedSpellExpressionEvaluable = preparedSpellExpression.replace(/<\$([^$]+)\$>/g, (...m)=>{
            switch (m[1]) {
            case "level":
                return targetLevel;
            case "str_mod":
                return this._getMaxPreparedSpells_getAbilityScore({
                    ability: "str",
                    totalsAsi,
                    existingAbilityScores
                });
            case "dex_mod":
                return this._getMaxPreparedSpells_getAbilityScore({
                    ability: "dex",
                    totalsAsi,
                    existingAbilityScores
                });
            case "con_mod":
                return this._getMaxPreparedSpells_getAbilityScore({
                    ability: "con",
                    totalsAsi,
                    existingAbilityScores
                });
            case "int_mod":
                return this._getMaxPreparedSpells_getAbilityScore({
                    ability: "int",
                    totalsAsi,
                    existingAbilityScores
                });
            case "wis_mod":
                return this._getMaxPreparedSpells_getAbilityScore({
                    ability: "wis",
                    totalsAsi,
                    existingAbilityScores
                });
            case "cha_mod":
                return this._getMaxPreparedSpells_getAbilityScore({
                    ability: "cha",
                    totalsAsi,
                    existingAbilityScores
                });
            default:
                throw new Error(`Unknown variable "${m[1]}"`);
            }
        }
        );

        const outRaw = eval(preparedSpellExpressionEvaluable);
        if (isNaN(outRaw)) {
            console.warn(...LGT, `Could not evaluate expression "${preparedSpellExpressionEvaluable}" (originally "${preparedSpellExpression}") as a number!`);
            return null;
        }

        return Math.max(1, Math.floor(outRaw));
    }

    static _getMaxPreparedSpells_preparedSpellsProgression({cls, sc, targetLevel}) {
        const progression = sc?.preparedSpellsProgression || cls.preparedSpellsProgression;
        return progression[Math.max(0, targetLevel - 1)] || 0;
    }

    static getMaxPreparedSpellsFormula({cls, sc}={}) {
        if (!cls)
            return null;

        const casterProgression = DataConverter.getMaxCasterProgression(cls.casterProgression, sc?.casterProgression);

        if (!casterProgression || !UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[casterProgression])
            return null;

        let preparedSpellExpression = cls.preparedSpells;

        if ((PrereleaseUtil.hasSourceJson(cls.source) || BrewUtil2.hasSourceJson(cls.source)) && !this._hasWellDefinedSpellData(cls, sc)) {
            preparedSpellExpression = preparedSpellExpression || this._getApproximatePreparedFormula(cls, sc);
        }

        if (!preparedSpellExpression)
            return null;

        const preparedSpellExpressionEvaluable = preparedSpellExpression.replace(/<\$([^$]+)\$>/g, (...m)=>{
            switch (m[1]) {
            case "level":
                return `@classes.${Parser.stringToSlug(cls.name)}.levels`;
            case "str_mod":
            case "dex_mod":
            case "con_mod":
            case "int_mod":
            case "wis_mod":
            case "cha_mod":
                return `@abilities.${m[1].toLowerCase().slice(0, 3)}.mod`;
            default:
                throw new Error(`Unknown variable "${m[1]}"`);
            }
        }
        );

        return `max(1, floor(${preparedSpellExpressionEvaluable}))`;
    }

    static _getMaxPreparedSpells_getAbilityScore({totalsAsi, existingAbilityScores, ability}) {
        if (existingAbilityScores)
            return existingAbilityScores[ability] || 0;
        return Parser.getAbilityModNumber(totalsAsi?.totals?.[totalsAsi.mode]?.[ability] || 0);
    }

    static _hasWellDefinedSpellData(cls, sc) {
        return ["cantripProgression", "preparedSpells", "preparedSpellsProgression", "spellsKnownProgression", "spellsKnownProgressionFixed", "spellsKnownProgressionFixedAllowLowerLevel", "spellsKnownProgressionFixedByLevel", ].some(prop=>cls?.[prop] != null || sc?.[prop] != null);
    }

    static _getApproximatePreparedFormula(cls, sc) {
        if (!cls)
            return null;

        const casterProgression = DataConverter.getMaxCasterProgression(cls.casterProgression, sc?.casterProgression);

        if (!casterProgression || (!cls.classTableGroups && !sc?.subclassTableGroups) || casterProgression === "pact")
            return null;

        const hasSpellsKnown = [cls.classTableGroups, sc?.subclassTableGroups].filter(Boolean).some(tableGroups=>{
            tableGroups.map(it=>it.colLabels || []).flat().map(lbl=>Renderer.stripTags(`${lbl}`.trim())).some(it=>{
                const parts = it.toLowerCase().split(/[^a-z0-9]/g).map(it=>it.trim()).filter(Boolean);
                return parts.some(pt=>pt === "spell" || pt === "spells") && parts.some(pt=>pt === "known");
            }
            );
        }
        );

        if (hasSpellsKnown)
            return null;

        return `<$level$> ${casterProgression !== "full" ? `/ 2 ` : ""}+ ${cls.spellcastingAbility ? `<$${cls.spellcastingAbility}_mod$>` : "5"}`;
    }

    static getExistingCasterMeta({cls, sc, actor, targetLevel, formDataSlotSelectFromComp=null, abilityScoresFromComp=null}) {
        if (!targetLevel)
            return null;

        const casterProgression = DataConverter.getMaxCasterProgression(cls?.casterProgression, sc?.casterProgression);
        const casterProgressionMeta = Charactermancer_Spell_Util.getCasterProgressionMeta({
            casterProgression,
            curLevel: 0,
            targetLevel: targetLevel
        });

        return {
            maxLearnedCantrips: this.getMaxLearnedCantrips({
                cls,
                sc,
                targetLevel
            }),
            fixedLearnedProgression: this.getFixedLearnedProgression({
                cls,
                sc,
                targetLevel,
                isExistingClass: true,
                formDataSlotSelectFromComp
            }),
            maxPreparedSpells: this.getMaxPreparedSpells({
                cls,
                sc,
                targetLevel,
                existingAbilityScores: Charactermancer_Util.getCurrentAbilityScores(actor),
                abilityScoresFromComp
            }),
            spellLevelLow: casterProgressionMeta?.spellLevelLow,
            spellLevelLowHigh: casterProgressionMeta?.spellLevelHigh,
        };
    }
}

class Charactermancer_Spell_SlotLevelSelect extends BaseComponent {
    constructor({className, spellSlotLevelSelection}) {
        super();
        this._className = className;
        this._prevSpellSlotLevelSelection = spellSlotLevelSelection;
    }

    render($wrp) {
        const $wrpInner = $(`<div class="ve-flex-col w-100"></div>`).appendTo($wrp.empty());

        const hkIsVisible = ()=>$wrpInner.toggleVe(this._isAnyChoice());
        this._addHookBase("curLevel", hkIsVisible);
        this._addHookBase("targetLevel", hkIsVisible);
        this._addHookBase("casterProgression", hkIsVisible);
        this._addHookBase("spellsKnownProgressionFixed", hkIsVisible);
        this._addHookBase("spellsKnownProgressionFixedAllowLowerLevel", hkIsVisible);
        this._addHookBase("spellsKnownProgressionFixedAllowHigherLevel", hkIsVisible);
        this._addHookBase("spellsKnownProgression", hkIsVisible);
        hkIsVisible();

        const hkPopulateGenericKnownState = ()=>this._doPopulateGenericKnownState();
        this._addHookBase("curLevel", hkPopulateGenericKnownState);
        this._addHookBase("targetLevel", hkPopulateGenericKnownState);
        this._addHookBase("casterProgression", hkPopulateGenericKnownState);
        this._addHookBase("spellsKnownProgression", hkPopulateGenericKnownState);
        this._addHookBase("spellsKnownAllowLowerLevel", hkPopulateGenericKnownState);
        this._addHookBase("spellsKnownAllowHigherLevel", hkPopulateGenericKnownState);
        hkPopulateGenericKnownState();

        const hkPopulateFixedKnownState = ()=>this._doPopulateFixedKnownState();
        this._addHookBase("curLevel", hkPopulateFixedKnownState);
        this._addHookBase("targetLevel", hkPopulateFixedKnownState);
        this._addHookBase("casterProgression", hkPopulateFixedKnownState);
        this._addHookBase("spellsKnownProgressionFixed", hkPopulateFixedKnownState);
        this._addHookBase("spellsKnownProgressionFixedAllowLowerLevel", hkPopulateFixedKnownState);
        this._addHookBase("spellsKnownProgressionFixedAllowHigherLevel", hkPopulateFixedKnownState);
        hkPopulateFixedKnownState();

        const $btnToggle = $(`<div class="py-1 clickable ve-muted">[+]</div>`).click(()=>{
            $btnToggle.text($btnToggle.text() === "[+]" ? "[\u2012]" : "[+]");
            $stgBody.toggleVe();
        });

        const $rows = [...new Array(Consts.CHAR_MAX_LEVEL)].map((_,ixLvl)=>{
            const lvl = ixLvl + 1;
            const $cellSpells = $(`<div class="col-9 ve-flex-v-center ve-flex-wrap"></div>`);

            const {propSpellLevelMax} = this.constructor._getPropsGeneral(lvl);
            const {propCnt: propCntGeneric} = this.constructor._getPropsLevel(lvl, "generic");
            const {propCnt: propCntFixed} = this.constructor._getPropsLevel(lvl, "fixed");

            const selMetasGeneric = [];
            const selMetasFixed = [];

            const $row = $$`<div class="ve-flex-v-center stripe-odd">
				<div class="col-3 ve-text-center">${ixLvl + 1}</div>
				${$cellSpells}
			</div>`;

            const $dispNone = $(`<div>\u2014</div>`).appendTo($cellSpells);

            const hk = ()=>{
                let cntVisible = 0;

                cntVisible = cntVisible + this._hkRow_doAdjustElements({
                    namespace: "generic",
                    selMetas: selMetasGeneric,
                    propCnt: propCntGeneric,
                    propIsAllowLower: "spellsKnownAllowLowerLevel",
                    propIsAllowHigher: "spellsKnownAllowHigherLevel",
                    lvl,
                    propSpellLevelMax,
                    $cellSpells,
                });

                cntVisible = cntVisible + this._hkRow_doAdjustElements({
                    namespace: "fixed",
                    selMetas: selMetasFixed,
                    propCnt: propCntFixed,
                    propIsAllowLower: "spellsKnownProgressionFixedAllowLowerLevel",
                    propIsAllowHigher: "spellsKnownProgressionFixedAllowHigherLevel",
                    lvl,
                    propSpellLevelMax,
                    $cellSpells,
                });

                $dispNone.toggleVe(cntVisible === 0);

                $row.toggleVe((this._state.targetLevel ?? 0) >= lvl);
            }
            ;
            this._addHookBase(propCntFixed, hk);
            this._addHookBase(propCntGeneric, hk);
            this._addHookBase(propSpellLevelMax, hk);
            this._addHookBase("curLevel", hk);
            this._addHookBase("targetLevel", hk);
            this._addHookBase("spellsKnownAllowLowerLevel", hk);
            this._addHookBase("spellsKnownAllowHigherLevel", hk);
            this._addHookBase("spellsKnownProgressionFixedAllowLowerLevel", hk);
            this._addHookBase("spellsKnownProgressionFixedAllowHigherLevel", hk);
            hk();

            return $row;
        });

        const $stgBody = $$`<div class="ve-flex-col w-100">
			<div class="ve-muted italic ve-small mb-1">If you wish to swap out learned spell levels for lower/higher (for example, when you swap out a spell on gaining a level as a Bard), you may do so here. Note that your final choices are not validated, so swap with caution, and according to the rules!</div>
			<div class="ve-flex-v-center">
				<div class="col-3 ve-text-center">${this._className} Level</div>
				<div class="col-9">Learned Spell Levels</div>
			</div>
			${$rows}
		</div>`.toggleVe();

        $$($wrpInner)`<div class="ve-flex-col w-100">
			<div class="split-v-center">
				<div class="bold">Learned Slot Level</div>
				${$btnToggle}
			</div>

			${$stgBody}
		</div>`;

        if (this._prevSpellSlotLevelSelection)
            this._proxyAssignSimple("state", {
                ...this._prevSpellSlotLevelSelection
            });
    }

    set curLevel(val) {
        this._state.curLevel = val;
    }
    set targetLevel(val) {
        this._state.targetLevel = val;
    }
    set spellsKnownProgression(val) {
        this._state.spellsKnownProgression = val;
    }
    set casterProgression(val) {
        this._state.casterProgression = val;
    }
    set spellsKnownProgressionFixed(val) {
        this._state.spellsKnownProgressionFixed = val;
    }
    set spellsKnownProgressionFixedAllowLowerLevel(val) {
        this._state.spellsKnownProgressionFixedAllowLowerLevel = val;
    }
    set spellsKnownProgressionFixedAllowHigherLevel(val) {
        this._state.spellsKnownProgressionFixedAllowHigherLevel = val;
    }

    isAnyChoice() {
        return this._isAnyChoice();
    }

    getFlagsChoicesState() {
        return {
            ...this._getFlagsChoicesState_namespace({
                namespace: "generic"
            }),
            ...this._getFlagsChoicesState_namespace({
                namespace: "fixed"
            }),
        };
    }

    _getFlagsChoicesState_namespace({namespace}) {
        const out = {};

        [...new Array(this._state.targetLevel)].forEach((_,ixLvl)=>{
            const lvl = ixLvl + 1;

            const {propCnt} = this.constructor._getPropsLevel(lvl, namespace);

            const numSpells = this._state[propCnt];
            for (let i = 0; i < numSpells; ++i) {
                const {propSpellLevel} = this.constructor._getPropsSpell(lvl, namespace, i);

                out[propSpellLevel] = this._state[propSpellLevel];
            }
        }
        );

        return out;
    }

    addHookPulseFixedLearnedProgression(hk) {
        this._addHookBase("pulseFixedLearnedProgression", hk);
    }

    _doPulseFixedLearnedProgression() {
        this._state.pulseFixedLearnedProgression = !this._state.pulseFixedLearnedProgression;
    }

    

    _hkRow_doAdjustElements({namespace, propCnt, selMetas, lvl, propSpellLevelMax, $cellSpells, propIsAllowLower, propIsAllowHigher}) {
        let cntVisible = 0;

        const numSpellsAtLevel = this._state[propCnt];
        for (let i = 0, len = Math.max(numSpellsAtLevel, selMetas.length); i < len; ++i) {
            let selMeta = selMetas[i];

            if (i > numSpellsAtLevel) {
                selMeta.$sel.hideVe();
                selMeta.$dispStatic.hideVe();
                continue;
            }

            const {propSpellLevel} = this.constructor._getPropsSpell(lvl, namespace, i);

            if (!selMetas[i]) {
                selMeta = ComponentUiUtil.$getSelEnum(this, propSpellLevel, {
                    values: this._geSpellLevelSelValues(propIsAllowLower, propIsAllowHigher, propSpellLevelMax),
                    asMeta: true,
                    fnDisplay: it=>this.constructor._getSpellLevelDisplay(it),
                }, );
                selMeta.$sel.addClass("manc-sp__sel-slot-level ve-text-center p-0 clickable").appendTo($cellSpells);
                selMetas[i] = selMeta;

                const hkSelTitle = ()=>selMeta.$sel.title(`You have selected to learn a ${this._state[propSpellLevel]}-level spell at this level.`);
                this._addHookBase(propSpellLevel, hkSelTitle);
                hkSelTitle();

                this._addHookBase(propSpellLevel, ()=>this._doPulseFixedLearnedProgression());

                const $dispStatic = $(`<div class="ve-flex-vh-center manc-sp__sel-slot-level ve-text-center ve-muted"></div>`).appendTo($cellSpells);
                const hkStatic = ()=>{
                    $dispStatic.toggleVe(this._isShowStaticFixedValue(propIsAllowLower, propIsAllowHigher, propSpellLevelMax));
                    $dispStatic.text(this.constructor._getSpellLevelDisplay(this._state[propSpellLevelMax])).title(`This box indicates you will learn a ${this._state[propSpellLevelMax]}-level spell at this level.`);
                }
                ;
                this._addHookBase(propSpellLevel, hkStatic);
                this._addHookBase(propSpellLevelMax, hkStatic);
                this._addHookBase(propIsAllowLower, hkStatic);
                this._addHookBase(propIsAllowHigher, hkStatic);
                this._addHookBase("curLevel", hkStatic);
                this._addHookBase("targetLevel", hkStatic);
                hkStatic();

                selMeta.$dispStatic = $dispStatic;

                const hkMaxSpellLevel = ()=>{
                    selMeta.setValues(this._geSpellLevelSelValues(propIsAllowLower, propIsAllowHigher, propSpellLevelMax));
                }
                ;
                this._addHookBase(propSpellLevelMax, hkMaxSpellLevel);
                this._addHookBase(propIsAllowLower, hkMaxSpellLevel);
                this._addHookBase(propIsAllowHigher, hkMaxSpellLevel);
                this._addHookBase("curLevel", hkMaxSpellLevel);
                this._addHookBase("targetLevel", hkMaxSpellLevel);
            }

            cntVisible++;

            const isShowStatic = this._isShowStaticFixedValue(propIsAllowLower, propIsAllowHigher, propSpellLevelMax);
            selMeta.$sel.toggleVe(!isShowStatic);
            selMeta.$dispStatic.toggleVe(isShowStatic);
        }

        return cntVisible;
    }

    static _getSpellLevelDisplay(lvl) {
        return `${Parser.getOrdinalForm(lvl)}-level sp.`;
    }

    static _getPropsSpell(lvl, namespace, ix) {
        return {
            propSpellLevel: `${lvl}_${namespace}_${ix}_spellLevel`,
        };
    }

    static _getPropsLevel(lvl, namespace) {
        return {
            propCnt: `${lvl}_${namespace}_cntFixed`,
        };
    }

    static _getPropsGeneral(lvl) {
        return {
            propSpellLevelMax: `${lvl}_spellLevelMax`,
        };
    }

    _isAnyChoice() {
        if (this._state.curLevel == null || this._state.targetLevel == null || this._state.casterProgression == null)
            return false;

        return !!((this._state.spellsKnownProgressionFixed && (this._state.spellsKnownProgressionFixedAllowLowerLevel || this._state.spellsKnownProgressionFixedAllowHigherLevel)) || (this._state.spellsKnownProgression && (this._state.spellsKnownAllowLowerLevel || this._state.spellsKnownAllowHigherLevel)));
    }

    _geSpellLevelSelValues(propIsAllowLower, propIsAllowHigher, propSpellLevelMax) {
        const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
            casterProgression: this._state.casterProgression,
            curLevel: this._state.curLevel,
            targetLevel: this._state.targetLevel,
        })?.spellLevelHigh || 0;

        const min = this._state[propIsAllowLower] ? 1 : maxSpellLevel;
        const max = this._state[propIsAllowHigher] ? maxSpellLevel : this._state[propSpellLevelMax];

        const out = [];
        for (let i = min; i <= max; ++i)
            out.push(i);
        return out;
    }

    _doPopulateGenericKnownState() {
        [...new Array(Consts.CHAR_MAX_LEVEL)].forEach((_,ixLvl)=>this._doPopulateGenericKnownState_forLevel(ixLvl + 1));

        this._doPulseFixedLearnedProgression();
    }

    _doPopulateGenericKnownState_forLevel(lvl) {
        if (this._doPopulateState_forLevel_isDoReset() || !this._state.spellsKnownProgression) {
            this._doPopulateState_forLevel_doReset({
                lvl,
                namespace: "generic"
            });
            return;
        }

        const prevCntSpells = this._state.spellsKnownProgression[lvl - 2] || 0;
        const curCntSpells = this._state.spellsKnownProgression[lvl - 1] || 0;
        const numSpells = curCntSpells - prevCntSpells;

        this._doPopulateState_forLevel_doPopulateForNumSpells({
            lvl,
            namespace: "generic",
            numSpells,
            propIsAllowLower: "spellsKnownAllowLowerLevel",
            propIsAllowHigher: "spellsKnownAllowHigherLevel",
        });
    }

    _doPopulateState_forLevel_isDoReset() {
        return this._state.curLevel == null || this._state.targetLevel == null || this._state.casterProgression == null || UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[this._state.casterProgression] == null;
    }

    _doPopulateState_forLevel_doReset({lvl, namespace}) {
        const {propCnt} = this.constructor._getPropsLevel(lvl, namespace);
        this._state[propCnt] = null;
    }

    _doPopulateState_forLevel_doPopulateForNumSpells({lvl, namespace, numSpells, propIsAllowLower, propIsAllowHigher}) {
        const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
            casterProgression: this._state.casterProgression,
            curLevel: 0,
            targetLevel: lvl,
        })?.spellLevelHigh || 0;

        [...new Array(numSpells)].map((_,i)=>{
            const {propSpellLevel} = this.constructor._getPropsSpell(lvl, namespace, i);

            if (this._state[propSpellLevel] == null)
                this._state[propSpellLevel] = maxSpellLevel;
            else {
                let nxtVal = this._state[propSpellLevel];

                if (!this._state[propIsAllowLower])
                    nxtVal = Math.max(nxtVal, maxSpellLevel);
                if (!this._state[propIsAllowHigher])
                    nxtVal = Math.min(nxtVal, maxSpellLevel);

                this._state[propSpellLevel] = nxtVal;
            }
        }
        );

        const {propCnt} = this.constructor._getPropsLevel(lvl, namespace);
        this._state[propCnt] = numSpells;

        const {propSpellLevelMax} = this.constructor._getPropsGeneral(lvl);
        this._state[propSpellLevelMax] = maxSpellLevel;
    }

    _doPopulateFixedKnownState() {
        [...new Array(Consts.CHAR_MAX_LEVEL)].forEach((_,ixLvl)=>this._doPopulateFixedKnownState_forLevel(ixLvl + 1));

        this._doPulseFixedLearnedProgression();
    }

    _doPopulateFixedKnownState_forLevel(lvl) {
        if (this._doPopulateState_forLevel_isDoReset() || !this._state.spellsKnownProgressionFixed) {
            this._doPopulateState_forLevel_doReset({
                lvl,
                namespace: "fixed"
            });
            return;
        }

        const numSpells = this._state.spellsKnownProgressionFixed[lvl - 1] || 0;
        this._doPopulateState_forLevel_doPopulateForNumSpells({
            lvl,
            namespace: "fixed",
            numSpells,
            propIsAllowLower: "spellsKnownProgressionFixedAllowLowerLevel",
            propIsAllowHigher: "spellsKnownProgressionFixedAllowHigherLevel",
        });
    }

    _isShowStaticFixedValue(propIsAllowLower, propIsAllowHigher, propSpellLevelMax) {
        const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
            casterProgression: this._state.casterProgression,
            curLevel: this._state.curLevel,
            targetLevel: this._state.targetLevel,
        })?.spellLevelHigh || 0;
        if (maxSpellLevel <= 1)
            return true;

        const isAllowLower = this._state[propIsAllowLower] && this._state[propSpellLevelMax] !== 1;
        const isAllowHigher = this._state[propIsAllowHigher] && this._state[propSpellLevelMax] !== 9;
        return !isAllowLower && !isAllowHigher;
    }

    static getDefaultFormData({targetLevel, casterProgression, spellsKnownProgression, spellsKnownProgressionFixed}) {
        const out = [...new Array(9)].map(()=>0);
        let isAnyData = false;

        if (spellsKnownProgression && targetLevel != null && casterProgression) {
            isAnyData = true;
            this._getFormData_handleKnownProgressionGeneric_noChoice(out, {
                targetLevel,
                casterProgression,
                spellsKnownProgression
            });
        }

        if (spellsKnownProgressionFixed && targetLevel != null && casterProgression) {
            isAnyData = true;
            this._getFormData_handleKnownProgressionFixed_noChoice(out, {
                targetLevel,
                casterProgression,
                spellsKnownProgressionFixed
            });
        }

        return {
            isFormComplete: true,
            isAnyData,
            data: out,
        };
    }

    getFormData() {
        const out = [...new Array(9)].map(()=>0);
        let isAnyData = false;

        if (this._state.spellsKnownProgression && this._state.targetLevel != null && this._state.casterProgression) {
            isAnyData = true;
            this._getFormData_handleKnownProgressionGeneric(out);
        }

        if (this._state.spellsKnownProgressionFixed && this._state.targetLevel != null && this._state.casterProgression) {
            isAnyData = true;
            this._getFormData_handleKnownProgressionFixed(out);
        }

        return {
            isFormComplete: true,
            isAnyData,
            data: out,
        };
    }

    _getFormData_handleKnownProgressionGeneric(totalKnownPerLevel) {
        if (!this._state.spellsKnownAllowLowerLevel && !this._state.spellsKnownAllowHigherLevel) {
            this.constructor._getFormData_handleKnownProgressionGeneric_noChoice(totalKnownPerLevel, {
                targetLevel: this._state.targetLevel,
                casterProgression: this._state.casterProgression,
                spellsKnownProgression: this._state.spellsKnownProgression,
            }, );
        } else
            this._getFormData_handleKnownProgressionGeneric_choice(totalKnownPerLevel);
    }

    _getFormData_handleKnownProgressionFixed(totalKnownPerLevel) {
        if (!this._state.spellsKnownProgressionFixedAllowLowerLevel && this._state.spellsKnownProgressionFixedAllowHigherLevel) {
            this.constructor._getFormData_handleKnownProgressionFixed_noChoice(totalKnownPerLevel, {
                targetLevel: this._state.targetLevel,
                casterProgression: this._state.casterProgression,
                spellsKnownProgressionFixed: this._state.spellsKnownProgressionFixed,
            }, );
        } else
            this._getFormData_handleKnownProgressionFixed_choice(totalKnownPerLevel);
    }

    static _getFormData_handleKnownProgressionGeneric_noChoice(totalKnownPerLevel, {targetLevel, casterProgression, spellsKnownProgression}) {
        [...new Array(targetLevel)].forEach((_,i)=>{
            const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
                casterProgression: casterProgression,
                curLevel: 0,
                targetLevel: i + 1,
            })?.spellLevelHigh || 0;

            const ixLastSlot = maxSpellLevel - 1;
            if (ixLastSlot < 0)
                return;

            const prevCntSpells = spellsKnownProgression[i - 1] || 0;
            const curCntSpells = spellsKnownProgression[i] || 0;
            const numSpells = curCntSpells - prevCntSpells;

            totalKnownPerLevel[ixLastSlot] += numSpells;
        }
        );
    }

    _getFormData_handleKnownProgressionGeneric_choice(totalKnownPerLevel) {
        this._getFormData_handleKnownProgression_choice({
            namespace: "generic",
            totalKnownPerLevel,
            propIsAllowLower: "spellsKnownAllowLowerLevel",
            propIsAllowHigher: "spellsKnownAllowHigherLevel",
        });
    }

    static _getFormData_handleKnownProgressionFixed_noChoice(totalKnownPerLevel, {targetLevel, casterProgression, spellsKnownProgressionFixed}) {
        spellsKnownProgressionFixed.slice(0, targetLevel).forEach((lvlFixedValue,i)=>{
            const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
                casterProgression: casterProgression,
                curLevel: 0,
                targetLevel: i + 1,
            })?.spellLevelHigh || 0;

            const ixLastSlot = maxSpellLevel - 1;
            if (ixLastSlot < 0)
                return;

            totalKnownPerLevel[ixLastSlot] += lvlFixedValue;
        }
        );
    }

    _getFormData_handleKnownProgressionFixed_choice(totalKnownPerLevel) {
        this._getFormData_handleKnownProgression_choice({
            namespace: "fixed",
            totalKnownPerLevel,
            propIsAllowLower: "spellsKnownProgressionFixedAllowLowerLevel",
            propIsAllowHigher: "spellsKnownProgressionFixedAllowHigherLevel",
        });
    }

    _getFormData_handleKnownProgression_choice({namespace, totalKnownPerLevel, propIsAllowLower, propIsAllowHigher}) {
        const maxOverallSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
            casterProgression: this._state.casterProgression,
            curLevel: this._state.curLevel,
            targetLevel: this._state.targetLevel,
        })?.spellLevelHigh || 0;

        [...new Array(this._state.targetLevel)].map((_,ixLvl)=>{
            const lvl = ixLvl + 1;

            const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
                casterProgression: this._state.casterProgression,
                curLevel: 0,
                targetLevel: lvl,
            })?.spellLevelHigh || 0;

            const {propCnt} = this.constructor._getPropsLevel(lvl, namespace);

            const numSpells = this._state[propCnt];
            for (let i = 0; i < numSpells; ++i) {
                const {propSpellLevel} = this.constructor._getPropsSpell(lvl, namespace, i);

                let spellLevel = this._state[propSpellLevel];

                if (!this._state[propIsAllowLower])
                    spellLevel = Math.max(spellLevel, maxSpellLevel);
                if (!this._state[propIsAllowHigher])
                    spellLevel = Math.min(spellLevel, maxSpellLevel);

                spellLevel = Math.min(spellLevel, maxOverallSpellLevel);

                totalKnownPerLevel[spellLevel - 1]++;
            }
        }
        );
    }

    _getDefaultState() {
        return {
            curLevel: null,
            targetLevel: null,

            casterProgression: null,

            spellsKnownProgression: null,
            spellsKnownAllowLowerLevel: true,
            spellsKnownAllowHigherLevel: true,
            spellsKnownProgressionFixed: null,
            spellsKnownProgressionFixedAllowLowerLevel: false,
            spellsKnownProgressionFixedAllowHigherLevel: false,

            pulseFixedLearnedProgression: false,
        };
    }
}

class Charactermancer_Spell_SpellMeta {
    constructor({ix, spell, isPrepared, isLearned, isUpdateOnly, existingItemId, preparationMode, usesValue, usesMax, usesPer}) {
        this.ix = ix;
        this.spell = spell;
        this.isPrepared = isPrepared;
        this.isLearned = isLearned;

        this.isUpdateOnly = isUpdateOnly;
        this.existingItemId = existingItemId;

        this.preparationMode = preparationMode;
        this.usesValue = usesValue;
        this.usesMax = usesMax;
        this.usesPer = usesPer;
    }
}

class Charactermancer_Spell extends BaseComponent {
    
    constructor(opts) {
        opts = opts || {};
        super();

        this._actor = opts.actor;
        this._existingClass = opts.existingClass;
        this._existingCasterMeta = opts.existingCasterMeta;
        this._spellDatas = opts.spellDatas;
        this._className = opts.className;
        this._classSource = opts.classSource;
        this._subclassName = opts.subclassName;
        this._subclassShortName = opts.subclassShortName;
        this._subclassSource = opts.subclassSource;
        //Create an array of new components to handle picking spells at each level
        this._compsLevel = [...new Array(opts.maxLevel != null ? (opts.maxLevel + 1) : 10)].map((_,i)=>new Charactermancer_Spell_Level({
            spellDatas: opts.spellDatas,
            spellLevel: i,
            parent: this
        }));
        this._pageFilter = opts.pageFilter;
        this._$wrpsPreparedLearned = opts.$wrpsPreparedLearned;

        this._spellDataLookup = this._getSpellDataLookup();
        this._existingSpellLookup = this._getExistingSpellLookup();

        this._cacheSelectedListItem = null;
        this._cacheFilterValues = null;
        this._cacheBrewClassSpells = Charactermancer_Spell._getBrewClassSubclassSpellCache(opts.brewClassSpells, opts.brewSubclassSpells, opts.brewSubSubclassSpells);
    }

    render($wrp, $dispSpell) {
        const hkPreparedLearned = ()=>{
            const parts = [this._state.maxLearnedCantrips ? `Cantrips learned: ${this._state.cntLearnedCantrips}/${this._state.maxLearnedCantrips}` : null, this._state.fixedLearnedProgression ? `Spells learned: ${this._getCntSpellsKnown()}/${this._getTotalSpellsKnown()}` : null, this._state.maxPrepared ? `Prepared: ${this._state.cntPrepared}/${this._state.maxPrepared}` : null, ].filter(Boolean);

            (this._$wrpsPreparedLearned || []).forEach($it=>{
                $it.toggleVe(parts.length).html(parts.join(`<div class="mx-1">\u2014</div>`));
            }
            );
        }
        ;
        this._addHookBase("cntPrepared", hkPreparedLearned);
        this._addHookBase("maxPrepared", hkPreparedLearned);
        this._addHookBase("fixedLearnedProgression", hkPreparedLearned);
        this._addHookBase("pulseFixedLearned", hkPreparedLearned);
        this._addHookBase("cntLearnedCantrips", hkPreparedLearned);
        this._addHookBase("maxLearnedCantrips", hkPreparedLearned);
        hkPreparedLearned();

        const hkAlwaysPreparedSpells = ()=>this._handleAlwaysPreparedSpells();
        this._addHookBase("alwaysPreparedSpellsRace", hkAlwaysPreparedSpells);
        this._addHookBase("alwaysPreparedSpellsBackground", hkAlwaysPreparedSpells);
        this._addHookBase("alwaysPreparedSpellsClass", hkAlwaysPreparedSpells);
        this._addHookBase("alwaysPreparedSpellsSubclass", hkAlwaysPreparedSpells);
        hkAlwaysPreparedSpells();

        const hkExpandedSpells = ()=>this.handleFilterChange();
        this._addHookBase("expandedSpellsRace", hkExpandedSpells);
        this._addHookBase("expandedSpellsBackground", hkExpandedSpells);
        this._addHookBase("expandedSpellsClass", hkExpandedSpells);
        this._addHookBase("expandedSpellsSubclass", hkExpandedSpells);

        this._addHookBase("isIncludeUaEtcSpellLists", hkExpandedSpells);
        hkExpandedSpells();

        const hkAlwaysKnownSpells = ()=>this._handleAlwaysKnownSpells();
        this._addHookBase("alwaysKnownSpellsRace", hkAlwaysKnownSpells);
        this._addHookBase("alwaysKnownSpellsBackground", hkAlwaysKnownSpells);
        this._addHookBase("alwaysKnownSpellsClass", hkAlwaysKnownSpells);
        this._addHookBase("alwaysKnownSpellsSubclass", hkAlwaysKnownSpells);
        hkAlwaysKnownSpells();

        this._compsLevel.forEach(it=>it.render($wrp));

        const hkDisplaySpell = ()=>{
            $dispSpell.empty();
            const spell = this._spellDatas[this._state.ixViewedSpell];
            if (!spell)
                return $dispSpell.append(`<div class="ve-flex-vh-center w-100 h-100 italic">Select a spell to view</div>`);

            $dispSpell.append(Renderer.hover.$getHoverContent_stats(UrlUtil.PG_SPELLS, MiscUtil.copy(spell)));
        }
        ;
        this._addHookBase("ixViewedSpell", hkDisplaySpell);
        hkDisplaySpell();
    }

    static async pApplyFormDataToActor(actor, formData, {cls, sc, taskRunner=null}) {
        const spells = formData?.data?.spells || [];
        for (let i = 0; i < spells.length; ++i) {
            const {spell, isPrepared,
            isUpdateOnly, existingItemId,
            preparationMode, usesValue, usesMax, usesPer, castAtLevel, } = spells[i];

            if (isUpdateOnly && existingItemId) {
                await DataConverterSpell.pSetSpellItemIsPrepared(actor.items.get(existingItemId), isPrepared);
                continue;
            }

            if (!Charactermancer_Spell._IMPORT_LIST_SPELL || Charactermancer_Spell._IMPORT_LIST_SPELL.actor !== actor) {
                const {ImportListSpell} = await Promise.resolve().then(function() {
                    return ImportListSpell$1;
                });
                Charactermancer_Spell._IMPORT_LIST_SPELL = new ImportListSpell({
                    actor: actor
                });
                await Charactermancer_Spell._IMPORT_LIST_SPELL.pInit();
            }

            await Charactermancer_Spell._IMPORT_LIST_SPELL.pImportEntry(spell, {
                taskRunner,
                isCharactermancer: true,
                opts_pGetSpellItem: {
                    isActorItem: true,

                    isPrepared: isPrepared,
                    ability: sc?.spellcastingAbility || cls.spellcastingAbility,

                    preparationMode,
                    usesValue,
                    usesMax,
                    usesPer,
                    castAtLevel,

                    parentClassName: cls.name,
                    parentClassSource: cls.source,
                    parentSubclassName: sc?.name,
                    parentSubclassShortName: sc?.shortName,
                    parentSubclassSource: sc?.source,
                },
            }, );
        }
    }
    _getSpellDataLookup() {
        const out = {
            hash: {},
            slug: {}
        };
        this._spellDatas.forEach(sp=>{
            MiscUtil.set(out, "hash", UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS](sp), sp);
            MiscUtil.set(out, "slug", Parser.stringToSlug(Parser.sourceJsonToAbv(sp.source)), Parser.stringToSlug(sp.name), sp);
        }
        );
        return out;
    }

    _getExistingSpellLookup() {
        if (!this._existingClass || !this._existingCasterMeta)
            return null;

        const spItems = this._actor.items.filter(it=>it.type === "spell");

        const cntsSeenLearnedPerLevel = {};
        const cntsSeenPreparedPerLevel = {};

        const out = {};

        [...spItems].sort((a,b)=>{
            const flagsA = a.flags?.[SharedConsts.MODULE_ID];
            const flagsB = b.flags?.[SharedConsts.MODULE_ID];
            const a_ = flagsA?.parentClassName && flagsA?.parentClassSource ? 1 : 0;
            const b_ = flagsB?.parentClassName && flagsB?.parentClassSource ? 1 : 0;
            return b_ - a_;
        }
        ).forEach(spItem=>{
            const level = Number(spItem.system.level || 0);
            const lookupName = (spItem.name || "").trim().toLowerCase();
            const itemSourceMeta = UtilDocumentSource.getDocumentSource(spItem);
            const lookupSource = (itemSourceMeta.source || "").toLowerCase();

            const flags = spItem.flags?.[SharedConsts.MODULE_ID];
            const parentClassName = flags?.parentClassName;
            const parentClassSource = flags?.parentClassSource;

            const isItemPrepared = spItem.system.preparation?.mode === "prepared" && spItem.system.preparation?.prepared;
            const isItemAlwaysPrepared = spItem.system.preparation?.mode === "always" || level === 0;

            if (parentClassName && parentClassSource && parentClassName !== this._existingClass.name && parentClassSource !== this._existingClass.source)
                return;

            if (parentClassName && parentClassSource && parentClassName === this._existingClass.name && parentClassSource === this._existingClass.source) {
                const isLearned = level === 0 || (level !== 0 && this._existingCasterMeta.fixedLearnedProgression != null);
                const isPrepared = this._existingCasterMeta.maxPreparedSpells != null && isItemPrepared;

                if (isLearned)
                    cntsSeenLearnedPerLevel[level] = (cntsSeenLearnedPerLevel[level] || 0) + 1;
                if (isPrepared)
                    cntsSeenPreparedPerLevel[level] = (cntsSeenPreparedPerLevel[level] || 0) + 1;

                MiscUtil.set(out, level, lookupSource, lookupName, new Charactermancer_Spell.ExistingSpell({
                    item: spItem,
                    isLearned,
                    isPrepared,
                    isAlwaysPrepared: isItemAlwaysPrepared,
                }));

                return;
            }

            const isItemLearned = level === 0 || (spItem.system.preparation?.mode === "prepared" || spItem.system.preparation?.mode === "pact");

            const isLearned = level === 0 ? isItemLearned && this._existingCasterMeta.maxLearnedCantrips != null && ((cntsSeenLearnedPerLevel[level] || 0) < this._existingCasterMeta.maxLearnedCantrips) : isItemLearned && this._canLearnMoreFixedSpellsOfLevel({
                lvl: level,
                fixedLearnedProgression: this._existingCasterMeta.fixedLearnedProgression,
                cntSpellsKnown: cntsSeenLearnedPerLevel[level] || 0
            });

            const isPrepared = isItemPrepared && this._existingCasterMeta.maxPreparedSpells != null && (cntsSeenPreparedPerLevel[level] || 0) < this._existingCasterMeta.maxPreparedSpells;

            if (!this._getExistingSpellLookup_isOnSpellList(spItem))
                return;

            if (!isLearned && this._isLearnedFixedSpellCasterAtLevel({
                lvl: level,
                fixedLearnedProgression: this._existingCasterMeta.fixedLearnedProgression
            }))
                return;

            if (isLearned)
                cntsSeenLearnedPerLevel[level] = (cntsSeenLearnedPerLevel[level] || 0) + 1;
            if (isPrepared)
                cntsSeenPreparedPerLevel[level] = (cntsSeenPreparedPerLevel[level] || 0) + 1;

            MiscUtil.set(out, level, lookupSource, lookupName, new Charactermancer_Spell.ExistingSpell({
                item: spItem,
                isLearned,
                isPrepared,
                isAlwaysPrepared: isItemAlwaysPrepared,
            }));
        }
        );

        return out;
    }

    _getExistingSpellLookup_isOnSpellList(spItem) {
        const flags = spItem.flags?.[SharedConsts.MODULE_ID];

        if (flags?.page && flags?.source && flags?.hash) {
            const sp = this._spellDataLookup.hash[flags.hash];
            if (!sp)
                return false;
            return this.isAvailableClassSpell_(sp) || this.isAvailableSubclassSpell_(sp) || this.isAvailableExpandedSpell_(sp);
        }

        const itemSourceClean = UtilDocumentSource.getDocumentSource(spItem).source || Parser.SRC_PHB;
        const itemNameClean = spItem.name.trim().replace(/\s+/g, " ").toLowerCase();
        const sp = MiscUtil.get(this._spellDataLookup.slug, Parser.stringToSlug(itemSourceClean), Parser.stringToSlug(itemNameClean));
        if (!sp)
            return false;
        return this.isAvailableClassSpell_(sp) || this.isAvailableSubclassSpell_(sp) || this.isAvailableExpandedSpell_(sp);
    }

    static _getBrewClassSubclassSpellCache(brewClassSpells, brewSubclassSpells, brewSubSubclassSpells) {
        const out = {};
        (brewClassSpells || []).forEach(it=>this._getBrewClassSubclassSpellCache_addItem(out, it));
        (brewSubclassSpells || []).forEach(it=>this._getBrewClassSubclassSpellCache_addItem(out, it));
        (brewSubSubclassSpells || []).forEach(it=>this._getBrewClassSubclassSpellCache_addItem(out, it));
        return out;
    }

    static _getBrewClassSubclassSpellCache_addItem(out, it) {
        if (typeof it === "string") {
            const {name, source} = DataUtil.proxy.unpackUid("spell", it.trim(), "spell", {
                isLower: true
            });
            MiscUtil.set(out, "spell", source, name, true);
            return;
        }

        if (it.name)
            return MiscUtil.set(out, "spell", (it.source || Parser.SRC_PHB).trim().toLowerCase(), it.name.trim().toLowerCase(), true);

        if (it.className) {
            let prop = "class";
            const classSource = it.classSource || Parser.SRC_PHB;
            const path = [classSource, it.className];
            if (it.subclassName) {
                prop = "subclass";
                const subclassSource = it.subclassSource || classSource;
                path.push(subclassSource, it.subclassName);
                if (it.subSubclassName) {
                    prop = "subSubclass";
                    path.push(it.subSubclassName);
                }
            }
            MiscUtil.set(out, prop, ...path.map(it=>it.trim().toLowerCase()), true);
        }
    }

    get pageFilter() {
        return this._pageFilter;
    }

    set subclassName(val) {
        this._subclassName = val;
    }
    set subclassShortName(val) {
        this._subclassShortName = val;
    }
    set subclassSource(val) {
        this._subclassSource = val;
    }

    get cacheSelectedListItem() {
        return this._cacheSelectedListItem;
    }
    set cacheSelectedListItem(val) {
        this._cacheSelectedListItem = val;
    }

    get isPreparedCaster() {
        return this._state.maxPrepared != null;
    }

    set spellLevelLow(val) {
        this._state.spellLevelLow = val;
    }
    get spellLevelLow() {
        return this._state.spellLevelLow;
    }

    set spellLevelHigh(val) {
        this._state.spellLevelHigh = val;
    }
    get spellLevelHigh() {
        return this._state.spellLevelHigh;
    }

    get ixViewedSpell() {
        return this._state.ixViewedSpell;
    }
    set ixViewedSpell(val) {
        this._state.ixViewedSpell = val;
    }

    get maxLearnedCantrips() {
        return this._state.maxLearnedCantrips;
    }
    set maxLearnedCantrips(val) {
        this._state.maxLearnedCantrips = val;
    }

    get fixedLearnedProgression() {
        return this._state.fixedLearnedProgression;
    }
    set fixedLearnedProgression(val) {
        this._state.fixedLearnedProgression = val;
    }

    get fixedLearnedProgressionDefault() {
        return this._state.fixedLearnedProgressionDefault;
    }
    set fixedLearnedProgressionDefault(val) {
        this._state.fixedLearnedProgressionDefault = val;
    }

    get pulseFixedLearned() {
        return this._state.pulseFixedLearned;
    }
    set pulseFixedLearned(val) {
        this._state.pulseFixedLearned = val;
    }

    set maxPrepared(val) {
        this._state.maxPrepared = val;
        if (val != null)
            this._state.maxLearned = null;
    }

    get cntLearnedSpells() {
        return this._state.cntLearnedSpells;
    }
    set cntLearnedSpells(val) {
        this._state.cntLearnedSpells = val;
    }

    get cntLearnedCantrips() {
        return this._state.cntLearnedCantrips;
    }
    set cntLearnedCantrips(val) {
        this._state.cntLearnedCantrips = val;
    }

    get cntPrepared() {
        return this._state.cntPrepared;
    }
    set cntPrepared(val) {
        this._state.cntPrepared = val;
    }

    get casterProgression() {
        return this._state.casterProgression;
    }
    set casterProgression(val) {
        this._state.casterProgression = val;
    }

    set isIncludeUaEtcSpellLists(val) {
        this._state.isIncludeUaEtcSpellLists = val;
    }

    addHookMaxLearnedCantrips(hk) {
        this._addHookBase("maxLearnedCantrips", hk);
    }
    addHookSpellLevelLow(hk) {
        this._addHookBase("spellLevelLow", hk);
    }
    addHookSpellLevelHigh(hk) {
        this._addHookBase("spellLevelHigh", hk);
    }
    addHookFixedLearnedProgression(hk) {
        this._addHookBase("fixedLearnedProgression", hk);
    }

    addHookIsPreparedCaster(hk) {
        this._addHookBase("maxPrepared", hk);
    }

    addHookIsMaxLearnedSpells(hk) {
        this._addHookBase("fixedLearnedProgression", hk);
        this._addHookBase("pulseFixedLearned", hk);
        this._addHookBase("spellLevelLow", hk);
        this._addHookBase("spellLevelHigh", hk);
    }

    addHookIsMaxLearnedCantrips(hk) {
        this._addHookBase("cntLearnedCantrips", hk);
        this._addHookBase("maxLearnedCantrips", hk);
    }

    addHookIsMaxPrepared(hk) {
        this._addHookBase("cntPrepared", hk);
        this._addHookBase("maxPrepared", hk);
    }

    isLearnedFixedSpellCasterAtLevel_(lvl) {
        return this._isLearnedFixedSpellCasterAtLevel({
            lvl,
            fixedLearnedProgression: this._state.fixedLearnedProgressionDefault
        });
    }

    _isLearnedFixedSpellCasterAtLevel({lvl, fixedLearnedProgression}) {
        return lvl > 0 && fixedLearnedProgression != null && fixedLearnedProgression[lvl - 1] > 0;
    }

    canLearnMoreFixedSpellsOfLevel_(lvl) {
        return this._canLearnMoreFixedSpellsOfLevel({
            lvl,
            fixedLearnedProgression: this._state.fixedLearnedProgression,
            cntSpellsKnown: this._compsLevel[lvl].getSpellsKnown().length,
        });
    }

    _canLearnMoreFixedSpellsOfLevel({lvl, fixedLearnedProgression, cntSpellsKnown}) {
        if (!fixedLearnedProgression)
            return false;
        if (!fixedLearnedProgression[lvl - 1])
            return false;
        return cntSpellsKnown < fixedLearnedProgression[lvl - 1];
    }

    isOverLearnFixedSpellsLimitOfLevel_(lvl) {
        if (!this._state.fixedLearnedProgression)
            return false;
        if (!this._state.fixedLearnedProgression[lvl - 1])
            return false;
        const spellsKnown = this._compsLevel[lvl].getSpellsKnown();
        return spellsKnown.length > this._state.fixedLearnedProgression[lvl - 1];
    }

    canLearnMoreCantrips_() {
        return this._state.cntLearnedCantrips < (this._state.maxLearnedCantrips || 0);
    }
    isOverLearnCantripsLimit_() {
        return this._state.cntLearnedCantrips > (this._state.maxLearnedCantrips || 0);
    }

    canPrepareMore_() {
        return this._state.cntPrepared < (this._state.maxPrepared || 0);
    }
    isOverPrepareLimit_() {
        return this._state.cntPrepared > (this._state.maxPrepared || 0);
    }

    _getCntSpellsKnown() {
        return this._compsLevel.map(it=>it.getSpellsKnown().length).sum();
    }
    _getTotalSpellsKnown() {
        return (this._state.fixedLearnedProgression || []).sum();
    }

    _handleAlwaysPreparedSpells() {
        this._compsLevel.forEach(it=>it.handleAlwaysPreparedSpells_());
    }
    _handleAlwaysKnownSpells() {
        this._compsLevel.forEach(it=>it.handleAlwaysKnownSpells_());
    }

    handleFilterChange(f) {
        this._cacheFilterValues = f || this._cacheFilterValues;
        if (!this._cacheFilterValues)
            return;
        this._compsLevel.forEach(it=>it.handleFilterChange(this._cacheFilterValues));
    }

    handleSearch(searchTerm) {
        this._compsLevel.forEach(it=>it.handleSearch(searchTerm));
    }

    getExistingSpellMeta_(spell) {
        if (!this._existingCasterMeta || !this._existingSpellLookup)
            return null;
        const lookupName = spell.name.toLowerCase();
        const lookupSource = spell.source.toLowerCase();
        const lookupSourceAlt = Parser.sourceJsonToAbv(spell.source).toLowerCase();
        return this._existingSpellLookup[spell.level]?.[lookupSource]?.[lookupName] || this._existingSpellLookup[spell.level]?.[lookupSourceAlt]?.[lookupName];
    }

    /**
     * Returns true if this class has the spell available
     * @param {*} sp 
     * @returns 
     */
    isAvailableClassSpell_(sp) {
        if (!this._className || !this._classSource) { return false; }

        const fromClassList = Renderer.spell.getCombinedClasses(sp, "fromClassList"); //This line is probably the problem, we always get an empty array back
        const fromClassListVariant = Renderer.spell.getCombinedClasses(sp, "fromClassListVariant").filter(it=>this._state.isIncludeUaEtcSpellLists ? true 
            : !SourceUtil.isNonstandardSource(it.definedInSource));

        const {className, classSource} = this.constructor._getMappedClassDetails({
            className: this._className,
            classSource: this._classSource
        });

        if (!fromClassList.some(it=>it.name === className && it.source === classSource)
        && !fromClassListVariant.some(it=>it.name === className && it.source === classSource)
        && !this._hasBrewClassSpell(sp, fromClassList, fromClassListVariant)) { return false; }

        return true;
    }

    isAvailableSubclassSpell_(sp) {
        if ((!this._subclassName && !this._subclassShortName) || !this._subclassSource)
            return false;

        const fromSubclassList = Renderer.spell.getCombinedClasses(sp, "fromSubclass");

        const scName = this._subclassShortName || this._subclassName;

        if (!fromSubclassList.some(it=>it?.class.name === this._className && it?.class.source === this._classSource && (it?.subclass.shortName || it?.subclass.name) === scName && it?.subclass.source === this._subclassSource) && !this._hasBrewSubclassSpell(sp, fromSubclassList))
            return false;

        return true;
    }

    _hasBrewClassSpell(sp, fromClassList, fromClassListVariant) {
        if (MiscUtil.get(this._cacheBrewClassSpells, "spell", sp.source.toLowerCase(), sp.name.toLowerCase()))
            return true;
        if (fromClassList.some(it=>MiscUtil.get(this._cacheBrewClassSpells, "class", it.source.toLowerCase(), it.name.toLowerCase())))
            return true;
        if (fromClassListVariant.some(it=>MiscUtil.get(this._cacheBrewClassSpells, "class", it.source.toLowerCase(), it.name.toLowerCase())))
            return true;
        return false;
    }

    _hasBrewSubclassSpell(sp, fromSubclassList) {
        if (MiscUtil.get(this._cacheBrewClassSpells, "spell", sp.source.toLowerCase(), sp.name.toLowerCase()))
            return true;
        if (fromSubclassList.some(it=>!it.subSubclass && MiscUtil.get(this._cacheBrewClassSpells, "subclass", it.class.source.toLowerCase(), it.class.name.toLowerCase(), it.subclass.source.toLowerCase(), it.subclass.name.toLowerCase())))
            return true;
        if (fromSubclassList.some(it=>it.subSubclass && MiscUtil.get(this._cacheBrewClassSpells, "subSubclass", it.class.source.toLowerCase(), it.class.name.toLowerCase(), it.subclass.source.toLowerCase(), it.subclass.name.toLowerCase(), it.subclass.subSubclass.toLowerCase())))
            return true;
        return false;
    }

    isAlwaysPreparedSpell_(sp) {
        const spellUid = this.constructor._getSpellUid(sp);
        if (this._state.alwaysPreparedSpellsRace.includes(spellUid))
            return true;
        if (this._state.alwaysPreparedSpellsBackground.includes(spellUid))
            return true;
        if (this._state.alwaysPreparedSpellsClass.includes(spellUid))
            return true;
        if (this._state.alwaysPreparedSpellsSubclass.includes(spellUid))
            return true;
        return false;
    }

    isAvailableExpandedSpell_(sp) {
        const spellUid = this.constructor._getSpellUid(sp);
        if (this._state.expandedSpellsRace.includes(spellUid))
            return true;
        if (this._state.expandedSpellsBackground.includes(spellUid))
            return true;
        if (this._state.expandedSpellsClass.includes(spellUid))
            return true;
        if (this._state.expandedSpellsSubclass.includes(spellUid))
            return true;
        return false;
    }

    isAlwaysKnownSpell_(sp) {
        const spellUid = this.constructor._getSpellUid(sp);
        if (this._state.alwaysKnownSpellsRace.includes(spellUid))
            return true;
        if (this._state.alwaysKnownSpellsBackground.includes(spellUid))
            return true;
        if (this._state.alwaysKnownSpellsClass.includes(spellUid))
            return true;
        if (this._state.alwaysKnownSpellsSubclass.includes(spellUid))
            return true;
        return false;
    }

    static _getSpellUid(sp) {
        return `${sp.name.toLowerCase()}|${sp.source.toLowerCase()}`;
    }

    set alwaysPreparedSpellsRace(val) {
        this._state.alwaysPreparedSpellsRace = val;
    }
    set alwaysPreparedSpellsBackground(val) {
        this._state.alwaysPreparedSpellsBackground = val;
    }
    set alwaysPreparedSpellsClass(val) {
        this._state.alwaysPreparedSpellsClass = val;
    }
    set alwaysPreparedSpellsSubclass(val) {
        this._state.alwaysPreparedSpellsSubclass = val;
    }

    set expandedSpellsRace(val) {
        this._state.expandedSpellsRace = val;
    }
    set expandedSpellsBackground(val) {
        this._state.expandedSpellsBackground = val;
    }
    set expandedSpellsClass(val) {
        this._state.expandedSpellsClass = val;
    }
    set expandedSpellsSubclass(val) {
        this._state.expandedSpellsSubclass = val;
    }

    set alwaysKnownSpellsRace(val) {
        this._state.alwaysKnownSpellsRace = val;
    }
    set alwaysKnownSpellsBackground(val) {
        this._state.alwaysKnownSpellsBackground = val;
    }
    set alwaysKnownSpellsClass(val) {
        this._state.alwaysKnownSpellsClass = val;
    }
    set alwaysKnownSpellsSubclass(val) {
        this._state.alwaysKnownSpellsSubclass = val;
    }

    async pGetFormData(filterValues) {
        return {
            isFormComplete: (this._state.cntLearnedCantrips === this._state.maxLearnedCantrips || 0) && (this._state.cntPrepared === this._state.maxPrepared || 0),
            data: {
                spells: this._compsLevel.map(comp=>comp.getFormSubData(filterValues)).flat(),
            },
        };
    }

    _getDefaultState() {
        return {
            spellLevelLow: null,
            spellLevelHigh: null,
            ixViewedSpell: null,

            cntLearnedCantrips: 0,
            maxLearnedCantrips: null,

            fixedLearnedProgression: null,
            pulseFixedLearned: false,

            cntPrepared: 0,
            maxPrepared: null,

            alwaysPreparedSpellsRace: [],
            alwaysPreparedSpellsBackground: [],
            alwaysPreparedSpellsClass: [],
            alwaysPreparedSpellsSubclass: [],
            alwaysPreparedSpellsFeat: {},

            expandedSpellsRace: [],
            expandedSpellsBackground: [],
            expandedSpellsClass: [],
            expandedSpellsSubclass: [],
            expandedSpellsFeat: {},

            alwaysKnownSpellsRace: [],
            alwaysKnownSpellsBackground: [],
            alwaysKnownSpellsClass: [],
            alwaysKnownSpellsSubclass: [],
            alwaysKnownSpellsFeat: {},

            casterProgression: null,

            isIncludeUaEtcSpellLists: false,
        };
    }

    static _getMappedClassDetails({className, classSource}) {
        return Charactermancer_Spell._CLASS_MAP?.[classSource]?.[className] || {
            className,
            classSource
        };
    }
}
Charactermancer_Spell._IMPORT_LIST_SPELL = null;
Charactermancer_Spell._CLASS_MAP = {
    [Parser.SRC_UATRR]: {
        "Ranger (Revised)": {
            className: "Ranger",
            classSource: Parser.SRC_PHB,
        },
    },
};

Charactermancer_Spell.ExistingSpell = class {
    constructor({item, isLearned, isPrepared, isAlwaysPrepared}) {
        this.item = item;
        this.isLearned = isLearned;
        this.isPrepared = isPrepared;
        this.isAlwaysPrepared = isAlwaysPrepared;
    }
}
;

class Charactermancer_Spell_Modal extends Charactermancer_Spell {
    constructor(opts) {
        opts.pageFilter = new PageFilterSpells();

        super(opts);
    }

    static pGetUserInput(opts) {
        const comp = new this(opts);
        comp.maxLearnedCantrips = opts.maxLearnedCantrips;

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            width: Util.getMaxWindowWidth(1200),
            height: Util.getMaxWindowHeight(),
        });
    }

    get modalTitle() {
        return `Select Cantrips`;
    }

    pRender($wrpModalInner) {
        const $wrpLhs = $(`<div class="ve-flex-col h-100 w-50"></div>`);
        const $wrpRhs = $(`<div class="ve-flex-col h-100 w-50"></div>`);

        const pRender = this._render_pFilterBox($wrpLhs);
        $wrpRhs.append(`<i class="ve-muted ve-text-center">Select a spell to view it here.</i>`);

        $$`<div class="split w-100 h-100">
			${$wrpLhs}
			<div class="vr-1 h-100"></div>
			${$wrpRhs}
		</div>`.appendTo($wrpModalInner);

        super.render($wrpLhs, $wrpRhs);

        return pRender.then(()=>{
            this.handleFilterChange(this._pageFilter.filterBox.getValues());
        }
        );
    }

    _render_pFilterBox($wrp) {
        const $btnFilter = $(`<button class="btn-5et veapp__btn-filter">Filter</button>`);
        const $btnToggleFilterSummary = $(`<button class="btn btn-5et" title="Toggle Filter Summary Display"><span class="glyphicon glyphicon-resize-small"></span></button>`);
        const $iptSearch = $(`<input type="search" class="search w-100 form-control h-initial" placeholder="Find spell...">`);
        const $btnReset = $(`<button class="btn-5et veapp__btn-list-reset">Reset</button>`).click(()=>$iptSearch.val("").keyup());

        const $wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`);

        $$($wrp)`
			<div class="ve-flex-v-stretch input-group input-group--top no-shrink">
				${$btnFilter}
				${$btnToggleFilterSummary}
				${$iptSearch}
				${$btnReset}
			</div>
			${$wrpMiniPills}
			<div class="ve-flex-v-stretch input-group input-group--bottom mb-1 no-shrink">
				<button class="btn-5et w-100" disabled></button>
			</div>
		`;

        return this._pageFilter.pInitFilterBox({
            $iptSearch: $iptSearch,
            $btnReset: $btnReset,
            $btnOpen: $btnFilter,
            $btnToggleSummaryHidden: $btnToggleFilterSummary,
            $wrpMiniPills: $wrpMiniPills,
            namespace: `Charactermancer_Spell_Modal.filter`,
        }).then(()=>{
            this._spellDatas.forEach(it=>this._pageFilter.mutateAndAddToFilters(it));

            this._pageFilter.trimState();
            this._pageFilter.filterBox.render();

            UiUtil.bindTypingEnd({
                $ipt: $iptSearch,
                fnKeyup: ()=>{
                    const val = List.getCleanSearchTerm($iptSearch.val());
                    if (this._lastSearchTermSpells === val)
                        return;
                    this._lastSearchTermSpells = val;

                    this.handleSearch(val);
                }
                ,
            });

            this._pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, ()=>{
                this.handleFilterChange(this._pageFilter.filterBox.getValues());
            }
            );
        }
        );
    }
}
/**
 * An object that handles choosing spells for a particular level (including cantrips)
 */
class Charactermancer_Spell_Level extends BaseComponent {
    constructor(opts) {
        super();
        opts = opts || {};

        this._spellDatas = opts.spellDatas;
        this._spellLevel = opts.spellLevel;
        this._parent = opts.parent;

        this._$wrpRows = null;
        this._$dispNoRows = null;
        this._list = null;
    }

    _isAvailableSpell(sp) { return sp.level === this._spellLevel; }

    render($wrp) {
        this._$wrpRows = $$`<div class="ve-flex-col manc__list mt-1 mb-3"></div>`;

        //This is only shown when we can't find any spells to offer
        this._$dispNoRows = $(`<div class="ve-flex-vh-center italic ve-muted ve-small mt-1">No matching spells</div>`).hideVe(); //Hide by default
        const doUpdateDispNoRows = ()=>{
            if(this._spellLevel == 0){
                console.log("visible items", this._list.visibleItems);
                if(this._list.visibleItems.length<1){console.error("bad");}
                console.log("searcheditems", this._list._searchedItems);
                //why is visible items not searched items?
                //Something is making them not be visible
            }
            this._$dispNoRows.toggleVe(!this._list.visibleItems.length && $btnToggle.text() !== "[+]");
        };

        const $wrpBtnsSort = $(`<div class="ve-flex-v-stretch input-group no-shrink">
			<button class="btn-5et btn-xxs col-3-2 pr-1 sort" data-sort="name">Name</button>
			<button class="btn-5et btn-xxs col-1-2 px-1 sort" data-sort="time">Time</button>
			<button class="btn-5et btn-xxs col-1-2 px-1 sort" data-sort="school">School</button>
			<button class="btn-5et btn-xxs col-0-5 px-1 sort" data-sort="concentration" title="Concentration">C.</button>
			<button class="btn-5et btn-xxs col-0-5 px-1 sort" data-sort="ritual" title="Ritual">R.</button>
			<button class="btn-5et btn-xxs col-2-6 px-1 sort" data-sort="range">Range</button>
			<button class="btn-5et btn-xxs col-1-2 px-1 sort" data-sort="source">Source</button>
			<button class="btn-5et btn-xxs col-1-6 pl-1" disabled>&nbsp;</button>
		</div>`);

        this._list = new List({
            $wrpList: this._$wrpRows,
            fnSort: PageFilterSpells.sortSpells, //this function is important
            fnSearch: (li,searchTerm)=>{
                return true; //DEBUG
                const {ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell} = this.constructor._getProps(li.ix);
                if ([ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell].some(k=>this._state[k])) { return true; }
                if(!searchTerm || !searchTerm.length){return true;} //TEMPFIX DEBUG maybe this helps?
                return li.searchText.includes(searchTerm);
            },
        });
        SortUtil.initBtnSortHandlers($wrpBtnsSort, this._list);

        this._list.on("updated", ()=>doUpdateDispNoRows()); //Whenever the graphical list of spells is updated, check if we have any list items to show

        const $btnToggle = $(`<div class="py-1 clickable ve-muted">[\u2012]</div>`).click(()=>{
            $btnToggle.text($btnToggle.text() === "[+]" ? "[\u2012]" : "[+]");
            this._$wrpRows.toggleVe();
            $wrpBtnsSort.toggleVe();
            doUpdateDispNoRows();
        }
        );

        const $wrpInner = $$`<div class="ve-flex-col w-100">
			<div class="split-v-center">
				<div class="bold">${Parser.spLevelToFullLevelText(this._spellLevel)}</div>
				${$btnToggle}
			</div>
			${$wrpBtnsSort}
			${this._$dispNoRows}
			${this._$wrpRows}
		</div>`.appendTo($wrp);

        //Go through spellDatas and add spells that are available to us to _list
        const len = this._spellDatas.length;
        for (let i = 0; i < len; ++i) {
            const sp = this._spellDatas[i];
            if (!this._isAvailableSpell(sp)){continue;}
            const listItem = this._getListItem(sp, i); //Create an item to show in the list of choices
            if (!listItem){continue;}
            this._list.addItem(listItem);
        }

        this._list.init();


        const hkSpellLevel = ()=>{
            const isWithinRange = this._isWithinLevelRange();

            $wrpInner.toggleVe(isWithinRange);
            if (!isWithinRange){this._resetLevelSpells();}
        };

        this._parent.addHookMaxLearnedCantrips(hkSpellLevel);
        this._parent.addHookSpellLevelLow(hkSpellLevel);
        this._parent.addHookSpellLevelHigh(hkSpellLevel);
        this._parent.addHookFixedLearnedProgression(hkSpellLevel);
        hkSpellLevel();

        if (this._spellLevel === 0){this._render_bindCantripHooks();}
        else {this._render_bindLevelledSpellHooks();}
    }

    _render_bindCantripHooks() {
        const hkIsMaxLearnedCantrips = ()=>{
            this._$wrpRows.toggleClass("manc-sp__is-max-learned-cantrips", !this._parent.canLearnMoreCantrips_());
            this._$wrpRows.toggleClass("manc-sp__is-max-learned-cantrips--is-over-limit", this._parent.isOverLearnCantripsLimit_());
        }
        ;
        this._parent.addHookIsMaxLearnedCantrips(hkIsMaxLearnedCantrips);
        hkIsMaxLearnedCantrips();
    }

    _render_bindLevelledSpellHooks() {
        const hkIsPrepared = ()=>this._$wrpRows.toggleClass("manc-sp__is-prepared-caster", this._parent.isPreparedCaster);
        this._parent.addHookIsPreparedCaster(hkIsPrepared);
        hkIsPrepared();

        const hkIsMaxLearnedSpells = ()=>{
            const isLearnCaster = this._parent.isLearnedFixedSpellCasterAtLevel_(this._spellLevel);

            let isMaxLearnedSpells = true;
            let isOverMaxLearnedSpells = true;

            if (isLearnCaster) {
                if (this._parent.canLearnMoreFixedSpellsOfLevel_(this._spellLevel))
                    isMaxLearnedSpells = false;
                if (!this._parent.isOverLearnFixedSpellsLimitOfLevel_(this._spellLevel))
                    isOverMaxLearnedSpells = false;
            }

            this._$wrpRows.toggleClass("manc-sp__is-learn-caster", isLearnCaster);
            this._$wrpRows.toggleClass("manc-sp__is-max-learned-spells", isLearnCaster && isMaxLearnedSpells);
            this._$wrpRows.toggleClass("manc-sp__is-max-learned-spells--is-over-limit", isLearnCaster && isOverMaxLearnedSpells);
        }
        ;
        this._parent.addHookIsMaxLearnedSpells(hkIsMaxLearnedSpells);
        hkIsMaxLearnedSpells();

        const hkIsMaxPrepared = ()=>{
            this._$wrpRows.toggleClass("manc-sp__is-max-prepared-spells", !this._parent.canPrepareMore_());
            this._$wrpRows.toggleClass("manc-sp__is-max-prepared-spells--is-over-limit", this._parent.isOverPrepareLimit_());
        }
        ;
        this._parent.addHookIsMaxPrepared(hkIsMaxPrepared);
        hkIsMaxPrepared();
    }

    _isWithinLevelRange() {
        if (this._spellLevel !== 0 && this._parent.fixedLearnedProgression != null && this._parent.fixedLearnedProgression[this._spellLevel - 1])
            return true;

        if (this._spellLevel === 0) {
            return !!this._parent.maxLearnedCantrips;
        }

        return this._spellLevel >= (this._parent.spellLevelLow ?? Number.MAX_SAFE_INTEGER) && this._spellLevel <= (this._parent.spellLevelHigh ?? Number.MIN_SAFE_INTEGER);
    }

    _getListItem(spell, spI) {
        const {ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell} = this.constructor._getProps(spI);

        const existingSpellMeta = this._parent.getExistingSpellMeta_(spell);
        if (existingSpellMeta) {
            if (existingSpellMeta.isLearned) {
                this._state[ixLearned] = true;
                if (spell.level === 0)
                    this._parent.cntLearnedCantrips++;
            }

            if (existingSpellMeta.isPrepared && !existingSpellMeta.isAlwaysPrepared) {
                this._state[ixPrepared] = true;
                this._parent.cntPrepared++;
            }

            if (existingSpellMeta.isAlwaysPrepared) {
                this._state[ixAlwaysPrepared] = true;
            }
        }

        const eleRow = document.createElement("div");
        eleRow.className = `ve-flex-v-center manc__list-row clickable veapp__list-row veapp__list-row-hoverable`;
        eleRow.dataset.ix = spI;

        const source = Parser.sourceJsonToAbv(spell.source);
        const time = PageFilterSpells.getTblTimeStr(spell.time[0]);
        const school = Parser.spSchoolAndSubschoolsAbvsShort(spell.school, spell.subschools);
        const concentration = spell._isConc ? "×" : "";
        const ritual = spell.meta?.ritual ? "×" : "";
        const range = Parser.spRangeToFull(spell.range);

        const isLearnDisabled = existingSpellMeta || this._state[ixAlwaysKnownSpell];

        const isPrepareDisabledExistingSpell = existingSpellMeta && (this._spellLevel === 0 || existingSpellMeta.isLearned);
        const isPrepareDisabled = isPrepareDisabledExistingSpell || this._state[ixAlwaysPrepared];

        eleRow.innerHTML = `
			<div class="col-3-2 pl-0">${spell.name}</div>
			<div class="col-1-2 ve-text-center">${time}</div>
			<div class="col-1-2 sp__school-${spell.school} ve-text-center" title="${Parser.spSchoolAndSubschoolsAbvsToFull(spell.school, spell.subschools)}" ${Parser.spSchoolAbvToStyle(spell.school)}>${school}</div>
			<div class="col-0-5 ve-text-center bold imp-sp__disp-conc" title="Concentration">${concentration}</div>
			<div class="col-0-5 ve-text-center bold imp-sp__disp-ritual" title="Ritual">${ritual}</div>
			<div class="col-2-6 text-right">${range}</div>
			<div class="col-1-2 ve-text-center ${Parser.sourceJsonToColor(spell.source)}" title="${Parser.sourceJsonToFull(spell.source)}" ${Parser.sourceJsonToStyle(spell.source)}>${source}</div>

			<div class="ve-flex-vh-center col-1-6 pr-0">
				<button
					class="btn manc__list-row-button ${this._spellLevel === 0 ? "manc-sp__btn-learn-cantrip" : "manc-sp__btn-learn-spell"} ${this._state[ixLearned] || existingSpellMeta?.isLearned || this._state[ixAlwaysKnownSpell] ? "active" : ""}"
					name="${this._spellLevel === 0 ? "btn-learn-cantrip" : "btn-learn-spell"}"
					${isLearnDisabled ? `disabled` : ""}
					${existingSpellMeta ? `data-plut-is-existing-spell="true"` : ""}
					${existingSpellMeta ? `title="(Previously Learned Spell)"` : ""}
				>Learn</button>

				${this._spellLevel !== 0 ? `<button
					class="btn manc__list-row-button manc-sp__btn-prepare ${this._state[ixPrepared] || this._state[ixAlwaysPrepared] || existingSpellMeta?.isPrepared || existingSpellMeta?.isAlwaysPrepared ? "active" : ""}"
					name="btn-prepare"
					title="${isPrepareDisabledExistingSpell ? `(Previously Added Spell)` : `Prepare`}"
					${isPrepareDisabled ? `disabled` : ""}
					${isPrepareDisabledExistingSpell ? `data-plut-is-existing-spell="true"` : ""}
				>Prep.</button>` : ""}
			</div>
		`;

        const elesBtns = eleRow.querySelectorAll("button");
        const [btnLearn,btnPrepare] = elesBtns;

        const listItem = new ListItem(spI,eleRow,spell.name,{
            source,
            level: spell.level,
            time,
            school: Parser.spSchoolAbvToFull(spell.school),
            concentration,
            ritual,
            normalisedTime: spell._normalisedTime,
            normalisedRange: spell._normalisedRange,
        },{
            btnLearn,
            btnPrepare,
        },);

        elesBtns.forEach(btn=>{
            btn.addEventListener("click", evt=>{
                evt.stopPropagation();
                evt.preventDefault();

                const isActive = btn.classList.contains("active");

                switch (btn.name) {
                case "btn-learn-cantrip":
                    {
                        if (!isActive && !this._parent.canLearnMoreCantrips_())
                            return;

                        btn.classList.toggle("active");
                        this._state[ixLearned] = !this._state[ixLearned];
                        if (this._state[ixLearned])
                            this._parent.cntLearnedCantrips++;
                        else
                            this._parent.cntLearnedCantrips--;

                        break;
                    }

                case "btn-learn-spell":
                    {
                        this._handleListItemBtnLearnClick_doFixed({
                            btnLearn,
                            btnPrepare,
                            isActive,
                            ixPrepared,
                            ixLearned
                        });
                        break;
                    }

                case "btn-prepare":
                    {
                        if (!isActive && !this._parent.canPrepareMore_())
                            return;

                        if (!isActive && this._parent.isLearnedFixedSpellCasterAtLevel_(this._spellLevel) && !this._state[ixLearned]) {
                            const isLearned = this._handleListItemBtnLearnClick_doFixed({
                                btnLearn,
                                btnPrepare,
                                isActive: this._state[ixLearned],
                                ixPrepared,
                                ixLearned
                            });
                            if (!isLearned)
                                return;
                        }

                        btn.classList.toggle("active");
                        this._state[ixPrepared] = !this._state[ixPrepared];
                        if (this._state[ixPrepared])
                            this._parent.cntPrepared++;
                        else
                            this._parent.cntPrepared--;

                        break;
                    }

                default:
                    throw new Error(`Unhandled button name: "${btn.name}"`);
                }
            }
            );
        }
        );

        eleRow.addEventListener("click", evt=>{
            evt.stopPropagation();
            evt.preventDefault();

            if (this._parent.cacheSelectedListItem)
                this._parent.cacheSelectedListItem.ele.classList.remove("list-multi-selected");

            eleRow.classList.add("list-multi-selected");
            this._parent.ixViewedSpell = spI;
            this._parent.cacheSelectedListItem = listItem;
        }
        );

        return listItem;
    }

    _handleListItemBtnLearnClick_do_doLearn({btnLearn, btnPrepare, isActive, ixPrepared, ixLearned}) {
        if (isActive && this._parent.isPreparedCaster && this._state[ixPrepared]) {
            this._state[ixPrepared] = false;
            btnPrepare.classList.remove("active");
            this._parent.cntPrepared--;
        }

        btnLearn.classList.toggle("active");
        this._state[ixLearned] = !this._state[ixLearned];
    }

    _handleListItemBtnLearnClick_doFixed({btnLearn, btnPrepare, isActive, ixPrepared, ixLearned}) {
        if (!isActive && !this._parent.canLearnMoreFixedSpellsOfLevel_(this._spellLevel))
            return false;

        this._handleListItemBtnLearnClick_do_doLearn({
            btnLearn,
            btnPrepare,
            isActive,
            ixPrepared,
            ixLearned
        });
        this._parent.pulseFixedLearned = !this._parent.pulseFixedLearned;

        return true;
    }

    handleFilterChange(f) {
        if (!this._list){return;}

        this._list.filter(it=>{
            const sp = this._spellDatas[it.ix];

            //_parent is a Charactermancer_Spell object
            if (!this._parent.isAvailableClassSpell_(sp) && !this._parent.isAvailableSubclassSpell_(sp) && !this._parent.isAvailableExpandedSpell_(sp))
            {
                return false;
            }



            const {ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell} = this.constructor._getProps(it.ix);

            if ([ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell].some(k=>this._state[k]))
            {return true;}

            return this._parent.pageFilter.toDisplay(f, sp);
        });
    }

    handleSearch(searchTerm) {
        this._list.search(searchTerm);
    }

    handleAlwaysPreparedSpells_() {
        return this._handleAlwaysStateSpells_({
            propIx: "ixPrepared",
            propParentCnt: "cntPrepared",
            propIxAlways: "ixAlwaysPrepared",
            propBtn: "btnPrepare",
            propExistingSpellMetaAlways: "isAlwaysPrepared",
            fnParentCheckAlways: this._parent.isAlwaysPreparedSpell_.bind(this._parent),
        }, );
    }

    handleAlwaysKnownSpells_() {
        return this._handleAlwaysStateSpells_({
            propIx: "ixLearned",
            propParentCnt: this._spellLevel === 0 ? "cntLearnedCantrips" : "cntLearnedSpells",
            propIxAlways: "ixAlwaysKnownSpell",
            propBtn: "btnLearn",
            fnParentCheckAlways: this._parent.isAlwaysKnownSpell_.bind(this._parent),
        }, );
    }

    _handleAlwaysStateSpells_({propIx, propParentCnt, propIxAlways, propBtn, propExistingSpellMetaAlways, fnParentCheckAlways, fnFilterSpell, }, ) {
        if (!this._list)
            return;

        this._list.items.forEach(it=>{
            const sp = this._spellDatas[it.ix];

            if (fnFilterSpell && !fnFilterSpell(sp))
                return;

            const existingSpellMeta = this._parent.getExistingSpellMeta_(sp);
            if (existingSpellMeta?.isLearned || existingSpellMeta?.isPrepared)
                return;

            const allProps = this.constructor._getProps(it.ix);
            const propIxProp = allProps[propIx];
            const propIxAlwaysProp = allProps[propIxAlways];

            const isAlways = (propExistingSpellMetaAlways && existingSpellMeta?.[propExistingSpellMetaAlways]) || fnParentCheckAlways(sp);

            if (isAlways) {
                if (this._state[propIxProp]) {
                    this._state[propIxProp] = false;
                    this._parent[propParentCnt]--;
                }

                if (!this._state[propIxAlwaysProp] && it.data[propBtn]) {
                    it.data[propBtn].classList.add("active");
                    it.data[propBtn].disabled = true;
                }
            } else {
                if (this._state[propIxAlwaysProp] && it.data[propBtn]) {
                    it.data[propBtn].classList.remove("active");
                    it.data[propBtn].disabled = false;
                }
            }

            this._state[propIxAlwaysProp] = isAlways;
        }
        );
    }

    static _getProps(ix) {
        return {
            ixLearned: `ix_learned_${ix}`,
            ixPrepared: `ix_prepared_${ix}`,
            ixAlwaysPrepared: `ix_always_prepared_${ix}`,
            ixAlwaysKnownSpell: `ix_always_known_spell_${ix}`,
        };
    }

    _resetLevelSpells() {
        let numDeLearned = 0;
        let numDePrepared = 0;
        const nxtState = {};

        const len = this._spellDatas.length;
        for (let i = 0; i < len; ++i) {
            const sp = this._spellDatas[i];

            if (!this._isAvailableSpell(sp))
                continue;

            const existingSpellMeta = this._parent.getExistingSpellMeta_(sp);
            if (existingSpellMeta)
                continue;

            const {ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell} = this.constructor._getProps(i);

            if (this._state[ixLearned]) {
                nxtState[ixLearned] = false;
                numDeLearned++;
            }

            if (this._state[ixPrepared]) {
                nxtState[ixPrepared] = false;
                numDePrepared++;
            }

            if (this._state[ixAlwaysPrepared])
                nxtState[ixAlwaysPrepared] = false;

            if (this._state[ixAlwaysKnownSpell])
                nxtState[ixAlwaysKnownSpell] = false;
        }

        this._proxyAssignSimple("state", nxtState);

        if (numDeLearned) {
            if (this._spellLevel === 0) {
                this._parent.cntLearnedCantrips -= numDeLearned;
                this._$wrpRows[0].querySelectorAll(`.manc-sp__btn-learn-cantrip`).forEach(it=>{
                    if (it.dataset?.["plut-is-existing-spell"])
                        return;
                    it.classList.remove("active");
                }
                );
            } else {
                this._parent.cntLearnedSpells -= numDeLearned;
                this._$wrpRows[0].querySelectorAll(`.manc-sp__btn-learn-spell`).forEach(it=>{
                    if (it.dataset?.["plut-is-existing-spell"])
                        return;
                    it.classList.remove("active");
                }
                );
            }
        }

        if (numDePrepared) {
            this._parent.cntPrepared -= numDePrepared;
            this._$wrpRows[0].querySelectorAll(`.manc-sp__btn-prepare`).forEach(it=>{
                if (it.dataset?.["plut-is-existing-spell"])
                    return;
                it.classList.remove("active");
            }
            );
        }
    }

    getSpellsKnown() {
        if (!this._isWithinLevelRange() || this._spellLevel === 0)
            return [];

        const out = [];

        const len = this._spellDatas.length;
        for (let i = 0; i < len; ++i) {
            const sp = this._spellDatas[i];

            if (!this._isAvailableSpell(sp))
                continue;
            if (!this._parent.isAvailableClassSpell_(sp) && !this._parent.isAvailableSubclassSpell_(sp) && !this._parent.isAvailableExpandedSpell_(sp))
                continue;

            const {ixLearned} = this.constructor._getProps(i);

            if (!this._state[ixLearned])
                continue;

            out.push({
                ix: i,
                spell: this._spellDatas[i],
            });
        }

        return out;
    }

    getFormSubData(filterValues) {
        if (!this._isWithinLevelRange())
            return [];

        const out = [];

        const isLearnedAtLevel = this._parent.isLearnedFixedSpellCasterAtLevel_(this._spellLevel);

        const len = this._spellDatas.length;
        for (let i = 0; i < len; ++i) {
            const sp = this._spellDatas[i];

            if (!this._isAvailableSpell(sp))
                continue;
            if (!this._parent.isAvailableClassSpell_(sp) && !this._parent.isAvailableSubclassSpell_(sp) && !this._parent.isAvailableExpandedSpell_(sp))
                continue;

            const {ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell} = this.constructor._getProps(i);

            if (this._state[ixAlwaysPrepared] || this._state[ixAlwaysKnownSpell])
                continue;

            const isLearned = this._state[ixLearned];
            const isPrepared = this._state[ixPrepared] || (this._spellLevel === 0 && isLearned);

            if (this._spellLevel === 0 && !isLearned)
                continue;

            let isUpdatePrepared = false;
            const existingSpellMeta = this._parent.getExistingSpellMeta_(sp);
            if (existingSpellMeta) {
                if (this._spellLevel === 0)
                    continue;
                if (isLearnedAtLevel)
                    continue;
                isUpdatePrepared = existingSpellMeta.isPrepared !== isPrepared;
                if (!isUpdatePrepared)
                    continue;
            }

            if (!isLearned && isLearnedAtLevel)
                continue;

            if (this._parent.isPreparedCaster && !isLearned && !isPrepared && !this._parent.pageFilter.toDisplay(filterValues, sp))
                continue;

            const spellImportOpts = this._getFormSubData_getSpellImportOpts({
                isLearned
            });

            out.push(new Charactermancer_Spell_SpellMeta({
                ...spellImportOpts,
                ix: i,
                spell: this._spellDatas[i],
                isPrepared,
                isLearned,
                isUpdateOnly: isUpdatePrepared,
                existingItemId: existingSpellMeta?.item?.id,
            }));
        }

        return out;
    }

    _getFormSubData_getSpellImportOpts({isLearned}) {
        let preparationMode = "always";
        let usesValue = null;
        let usesMax = null;
        let usesPer = null;

        if (this._spellLevel === 0) {
            preparationMode = "always";
        } else if (this._parent.casterProgression === "pact") {
            if (isLearned) {
                if (this._spellLevel > UtilActors.PACT_CASTER_MAX_SPELL_LEVEL) {
                    preparationMode = "atwill";
                    usesValue = 1;
                    usesMax = 1;
                    usesPer = "lr";
                } else
                    preparationMode = "pact";
            }
        } else {
            preparationMode = this._parent.isPreparedCaster ? "prepared" : "always";
        }

        return {
            preparationMode,
            usesValue,
            usesMax,
            usesPer
        };
    }
}
//#endregion

//#region Charactermancer Feats
class ActorCharactermancerFeat extends ActorCharactermancerBaseComponent {
    constructor(parentInfo) {
      parentInfo = parentInfo || {};
      super();
      this._actor = parentInfo.actor;
      this._data = parentInfo.data;
      this._parent = parentInfo.parent;
      this._tabFeats = parentInfo.tabFeats;
      this._modalFilterFeats = new ModalFilterFeatsFvtt({
        'namespace': "ActorCharactermancer.feats",
        'isRadio': true,
        'allData': this._data.feat
      });
      this._compAdditionalFeatsMetas = {};
      this._isSuspendSyncToStatgen = false;
    }

    render() {
        const tabFeats = this._tabFeats?.["$wrpTab"];
        if (!tabFeats) { return; }
        const wrapper = $$`<div class="ve-flex-col w-100 h-100 px-1 pt-1 overflow-y-auto ve-grow veapp__bg-foundry"></div>`;
        const sectionParent = $$`<div class="ve-flex-col w-100 h-100 px-1 overflow-y-auto ve-grow veapp__bg-foundry"></div>`;
        const noFeatsWarningLbl = $("<div><i class=\"ve-muted\">No feats are available for your current build.</i><hr class=\"hr-1\"></div>").appendTo(wrapper);
        const setAlertNoFeatsAvailable = () => {
          const elements = ["feat_availableFromAsi", "feat_availableFromRace", 'feat_availableFromBackground', "feat_availableFromCustom"]
          .some(prop => this._state[prop]?.length);
          noFeatsWarningLbl.toggleVe(!elements);
        };
        this._addHookBase("feat_availableFromAsi", setAlertNoFeatsAvailable);
        this._addHookBase('feat_availableFromRace', setAlertNoFeatsAvailable);
        this._addHookBase("feat_availableFromBackground", setAlertNoFeatsAvailable);
        this._addHookBase("feat_availableFromCustom", setAlertNoFeatsAvailable);
        setAlertNoFeatsAvailable();
        this._feat_addFeatSection(wrapper, sectionParent, "feat_availableFromAsi", "ability");
        this._feat_addFeatSection(wrapper, sectionParent, "feat_availableFromRace", "race");
        this._feat_addFeatSection(wrapper, sectionParent, "feat_availableFromBackground", "background");
        this._feat_addFeatSection(wrapper, sectionParent, "feat_availableFromCustom", "custom");
        const btnAddCustomFeat = $("<button class=\"btn btn-5et btn-sm\">Add Feat</button>").click(() => this._parent.compAbility.compStatgen.addCustomFeat());
        
        $$`<div class="ve-flex w-100 h-100">
                <div class="ve-flex-col w-100">
                    ${wrapper}
                    <div class="mt-2">${btnAddCustomFeat}</div>
                </div>
                <div class="vr-1"></div>
                ${sectionParent}
            </div>`.appendTo(tabFeats);

        this.setAdditionalFeatStateFromStatgen_();
        const onBackgroundPulse = () => this._state.feat_availableFromBackground = this._parent.compBackground.getFeatureCustomizedBackground_({
          'isAllowStub': false
        })?.["feats"];
        this._parent.compBackground.addHookBase("background_pulseBackground", onBackgroundPulse);

        this._state.feat_availableFromBackground = this._parent.compBackground.getFeatureCustomizedBackground_({
          'isAllowStub': false
        })?.["feats"];
      }

    get modalFilterFeats() {
      return this._modalFilterFeats;
    }
    async pLoad() {
      await this._modalFilterFeats.pPreloadHidden();
    }

    setAdditionalFeatStateFromStatgen_() {
      const _0x534748 = this._parent.compAbility.compStatgen.getFormDataAsi();
      if (!_0x534748.feats) {
        const _0x15f14b = this._getDefaultState();
        const _0xd28403 = ["feat_availableFromAsi", "feat_availableFromRace", "feat_availableFromBackground", 'feat_availableFromCustom'].mergeMap(_0x32df08 => ({
          'prop': _0x15f14b[_0x32df08]
        }));
        this._proxyAssignSimple("state", _0xd28403);
        return;
      }
      const _0x132ba3 = {};
      Object.entries(_0x534748.feats).forEach(([_0x2f879a, _0x50bc00]) => {
        const _0x57e759 = _0x50bc00.filter(Boolean).length;
        switch (_0x2f879a) {
          case "ability":
            _0x132ba3.feat_availableFromAsi = _0x57e759 ? [{
              'any': _0x57e759
            }] : [];
            break;
          case "race":
            _0x132ba3.feat_availableFromRace = this._parent.compRace.getRace_()?.["feats"];
            break;
          case "background":
            _0x132ba3.feat_availableFromBackground = this._parent.compBackground.getBackground_()?.['feats'];
            break;
          case "custom":
            _0x132ba3.feat_availableFromCustom = _0x57e759 ? [{
              'any': _0x57e759
            }] : [];
            break;
          default:
            throw new Error("Unhandled feat namespace \"" + _0x2f879a + "\"");
        }
      });
      this._parent.compFeat.proxyAssignSimple('state', _0x132ba3);
      try {
        this._isSuspendSyncToStatgen = true;
        Object.entries(_0x534748.feats).forEach(([_0xefee79, _0x48661a]) => {
          const _0x49dda2 = this._compAdditionalFeatsMetas[_0xefee79]?.['comp'];
          if (!_0x49dda2) {
            return;
          }
          _0x49dda2.setStateFromStatgenFeatList_(_0x48661a);
        });
      } finally {
        this._isSuspendSyncToStatgen = false;
      }
    }
    
    ['_feat_addFeatSection'](_0x28d80a, _0x5a0170, _0x22e7e5, _0x17a196) {
      let _0x26766e = null;
      const _0xe7fa06 = () => {
        const _0xc8b456 = this._state[_0x22e7e5];
        this._parent.featureSourceTracker_.unregister(_0x26766e);
        if (_0x26766e) {
          _0x26766e.unregisterFeatureSourceTracking();
        }
        _0x26766e = this._feat_renderAdditionalFeats({
          '$wrpLeft': _0x28d80a,
          '$wrpRight': _0x5a0170,
          'namespace': _0x17a196,
          'available': _0xc8b456,
          'prevComp': _0x26766e
        });
      };
      this._addHookBase(_0x22e7e5, _0xe7fa06);
      _0xe7fa06();
    }
    ["_feat_renderAdditionalFeats"]({
      $wrpLeft: _0x2d3832,
      $wrpRight: _0x48f4d1,
      namespace: _0xcd091d,
      available: _0x31988b,
      prevComp = null
    }) {
      if (this._compAdditionalFeatsMetas[_0xcd091d]) {
        this._compAdditionalFeatsMetas[_0xcd091d].cleanup();
      }
      if (!_0x31988b?.["length"]) {
        return;
      }
      const _0x40de9a = $("<div class=\"ve-flex-col w-100\"></div>").appendTo(_0x2d3832);
      const _0x52590d = $("<div class=\"ve-flex-col w-100\"></div>").appendTo(_0x48f4d1);
      const _0xdd1a71 = new Charactermancer_AdditionalFeatsSelect({
        'available': _0x31988b,
        'actor': this._actor,
        'featDatas': this._data.feat,
        'modalFilterFeats': this._modalFilterFeats,
        'modalFilterSpells': this._parent.compSpell.modalFilterSpells,
        'featureSourceTracker': this._parent.featureSourceTracker_,
        'isFeatureSelect': true,
        'prevComp': prevComp
      });
      this._feat_renderAdditionalFeats_addStatgenHandling({
        'compAdditionalFeats': _0xdd1a71,
        'namespace': _0xcd091d
      });
      this._compAdditionalFeatsMetas[_0xcd091d] = {
        'comp': _0xdd1a71,
        'cleanup': () => {
          _0x40de9a.remove();
          _0x52590d.remove();
        }
      };
      _0xdd1a71.renderTwoColumn({
        '$wrpLeft': _0x40de9a,
        '$wrpRight': _0x52590d
      });
      return _0xdd1a71;
    }
    ["_feat_renderAdditionalFeats_addStatgenHandling"]({
      compAdditionalFeats: _0xaff143,
      namespace: _0x498ee3
    }) {
      if (!ActorCharactermancerFeat._NAMESPACES_STATGEN.has(_0x498ee3)) {
        return;
      }
      const _0x1693c1 = () => {
        if (this._isSuspendSyncToStatgen) {
          return;
        }
        const _0x452c82 = _0xaff143.getFormDataReduced();
        const _0x10a56a = _0xaff143.ixSetAvailable;
        if (["race", 'background'].includes(_0x498ee3)) {
          this._parent.compAbility.compStatgen.setIxFeatSet(_0x498ee3, _0x10a56a);
          const _0x5c8d24 = _0x452c82.data.filter(({
            type: _0x1587bd
          }) => _0x1587bd === "choose").map(({
            ix: _0x350e80,
            ixFeat: _0x5d5e1f
          }) => ({
            'ix': _0x350e80,
            'ixFeat': _0x5d5e1f
          }));
          this._parent.compAbility.compStatgen.setIxFeatSetIxFeats(_0x498ee3, _0x5c8d24);
        } else {
          if (['ability'].includes(_0x498ee3)) {
            let _0x4623a2 = -0x1;
            let _0x59ccd9 = 0x0;
            (_0x452c82.ixsStatgen || []).forEach(_0x210be2 => {
              if (_0x210be2 > _0x4623a2 + _0x59ccd9 + 0x1) {
                _0x59ccd9 += _0x210be2 - (_0x4623a2 + _0x59ccd9 + 0x1);
              }
              const _0x417c7e = _0x452c82.data.find(_0x261b70 => _0x261b70.ix + _0x59ccd9 === _0x210be2);
              this._parent.compAbility.compStatgen.setIxFeat(_0x210be2, _0x498ee3, _0x417c7e?.["ixFeat"] ?? -0x1);
              _0x4623a2++;
            });
          } else if (['custom'].includes(_0x498ee3)) {
            _0x452c82.data.forEach(_0x4bb19b => {
              this._parent.compAbility.compStatgen.setIxFeat(_0x4bb19b.ix, _0x498ee3, _0x4bb19b.ixFeat);
            });
          }
        }
      };
      _0xaff143.addHookPulseFeats(_0x1693c1);
      _0x1693c1();
    }
    async ["feat_pGetAdditionalFeatFormData"]() {
      const _0x5c41dd = {
        'ability': null,
        'race': null,
        'background': null,
        'custom': null,
        'isAnyData': false
      };
      for (const _0x358dc0 of ["ability", "race", "background", "custom"]) {
        if (!this._compAdditionalFeatsMetas[_0x358dc0]) {
          continue;
        }
        const {
          comp: _0x2a4200
        } = this._compAdditionalFeatsMetas[_0x358dc0];
        _0x5c41dd[_0x358dc0] = await _0x2a4200.pGetFormData();
        _0x5c41dd.isAnyData = true;
      }
      return _0x5c41dd;
    }
    ["_getDefaultState"]() {
      return {
        'feat_availableFromAsi': [],
        'feat_availableFromRace': null,
        'feat_availableFromBackground': null,
        'feat_availableFromCustom': [],
        'feat_pulseChange': false
      };
    }
  }
  ActorCharactermancerFeat._NAMESPACES_STATGEN = new Set(['ability', "race", "background", "custom"]);
//#endregion

//#region Charactermancer Sheet
class ActorCharactermancerSheet extends ActorCharactermancerBaseComponent{
    constructor(parentInfo) {
        parentInfo = parentInfo || {};
        super();
        this._actor = parentInfo.actor;
        this._data = parentInfo.data; //data is an object containing information about all classes, subclasses, feats, etc
        this._parent = parentInfo.parent;
        this._tabSheet = parentInfo.tabSheet;
  
    }
    render(){
        let wrptab = this._tabSheet?.$wrpTab;
        if (!wrptab) { return; }
        let leftElement = $(`<div class="ve-flex-col w-100 h-100 px-1 pt-1 overflow-y-auto ve-grow veapp__bg-foundry"></div>`);
        let sidebarElement = $(`<div class="ve-flex-col w-100 h-100 px-1 overflow-y-auto ve-grow veapp__bg-foundry"></div>`);
        //this._addHookBase("class_ixPrimaryClass", () => this._state.class_pulseChange = !this._state.class_pulseChange);
  


        console.log("Sheet render");
        const alertIfRaceChanged = () => this._setStateValue('race_ixRace_version', null);
        //this._parent.compRace.addHookBase('race_ixRace', alertIfRaceChanged); //No need for this, looks like
        
        const updateElements = () => {
            console.log("Create sheet info elements");
            //Take all child names of __state
            //Get only the child names that start with "race_" and arent 'race_ixRace' or 'race_ixRace_version'
            //From those, return them all as an array? not sure
            /* const racePropertyNames = Object.keys(this.__state).filter(prop => prop.startsWith('race_')
                && !['race_ixRace', 'race_ixRace_version'].includes(prop)).mergeMap(props => ({
                [props]: null
            })); */

            //this._proxyAssignSimple("state", racePropertyNames);
            let curRace = this.getRace_();

            this.renderRace({$parentElement: leftElement, race: curRace });
        };

        //When race version changes, redraw the elements
        //this.addHookBase("race_ixRace_version", updateElements); //No need for this, looks like
        this._parent.compRace.addHookBase("race_ixRace_version", updateElements);
  
        $$`<div class="ve-flex w-100 h-100">
        <div class="ve-flex-col w-100">
            ${leftElement}
        </div>
        <div class="vr-1"></div>
            ${sidebarElement}
        </div>`.appendTo(wrptab);
    }

    renderRace({ $parentElement: parentElement, race: race }) {
        //parentElement.empty();
        console.log("RENDERRACE", race);
        if (race) {
            //parentElement.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Hit Points</div>");
            parentElement.append(`<div class="bold mb-2">racename</div>`);
        }
        else {
            parentElement.hideVe();
        }
    }

    getRace_() {
        console.log("sheet getrace", this._state);
        const ixRace = this._parent.compRace.state.race_ixRace;
        const curRace = this._data.race[ixRace];
        if (!curRace) { return null; }
        if (this._state.race_ixRace_version == null) { return curRace; }
        const raceVersions = DataUtil.generic.getVersions(curRace);
        return raceVersions[this._state.race_ixRace_version];
    }
}
//#endregion


//#region CONTENT IMPORT

//#region ContentGetter
class ContentGetter {
    static _cachedData;
    static async _getBase(doCache = true)
    {
        ContentGetter._cachedData = null;
        let data = {};
        let content = [];
        content.push(await ContentGetter._getFromIndex("data/class/"));
        content.push(await ContentGetter._getFromFile("data/races.json"));
        content.push(await ContentGetter._getFromFile("data/backgrounds.json"));
        content.push(await ContentGetter._getFromIndex("data/spells/"));

        for(let entry of content){

            //Get all properties of obj that are arrays
            let allProperties = Object.keys(entry);
            let arrayProperties = allProperties.filter(propertyName => Array.isArray(entry[propertyName]));
            for(let propName of arrayProperties){
                if(!data[propName]){data[propName] = [];} //Create array if none exists
                data[propName] = data[propName].concat(entry[propName]);
            }

            /* data.class = data.class.concat(entry.class);
            data.subclass = data.subclass.concat(entry.subclass);
            data.classFeature = data.classFeature.concat(entry.classFeature);
            data.subclassFeature = data.subclassFeature.concat(entry.subclassFeature);
            data.race = data.race.concat(entry.race);
            data.subrace = data.subrace.concat(entry.subrace);
            data.background = data.background.concat(entry.background); */
        }

        data.class = data.class?.filter(cls => !!cls);
        data.classFeature = data.classFeature?.filter(f => !!f);
        data.race = data.race?.filter(r => !!r);
        data.subrace = data.subrace?.filter(sr => !!sr);
        data.background = data.background?.filter(b => !!b);

        if(doCache){ContentGetter._cachedData = data;}

        return data;
    }
    static async _getFromIndex(urlFolder){
        const index = await HelperFunctions.loadJSONFile(urlFolder + "index.json");
        let resultFiles = [];
        let addresses = [];
        Object.keys(index).forEach((k,v) => {
            const name = index[k]; addresses.push(name);
        });
        for(let a of addresses){
            let path = urlFolder + a;
            let file = await HelperFunctions.loadJSONFile(path);
            if(file){resultFiles.push(file);}
        }

        let merged = {};
        for(let obj of resultFiles){
            //Get all properties of obj that are arrays
            const allProperties = Object.keys(obj);
            const arrayProperties = allProperties.filter(propertyName => Array.isArray(obj[propertyName]));
            for(let propName of arrayProperties){
                if(!merged[propName]){merged[propName] = [];} //Create array if none exists
                merged[propName] = merged[propName].concat(obj[propName]);
            }
        }

        return merged;
    }
    static async _getFromFile(url){
        return await HelperFunctions.loadJSONFile(url);
    }
    /**Grabs JSON information from a file filled with information used in specific circumstances, such as figuring out class feature options (which proficiencies you get to choose between)
     * when you level up as one of the base classes
     */
    static _getFoundryData(){
        const _foundry = `{
            "class": [
                {
                    "name": "Sorcerer",
                    "source": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "sorcery-points",
                                "type": "number",
                                "scale": {
                                    "2": {
                                        "value": 2
                                    },
                                    "3": {
                                        "value": 3
                                    },
                                    "4": {
                                        "value": 4
                                    },
                                    "5": {
                                        "value": 5
                                    },
                                    "6": {
                                        "value": 6
                                    },
                                    "7": {
                                        "value": 7
                                    },
                                    "8": {
                                        "value": 8
                                    },
                                    "9": {
                                        "value": 9
                                    },
                                    "10": {
                                        "value": 10
                                    },
                                    "11": {
                                        "value": 11
                                    },
                                    "12": {
                                        "value": 12
                                    },
                                    "13": {
                                        "value": 13
                                    },
                                    "14": {
                                        "value": 14
                                    },
                                    "15": {
                                        "value": 15
                                    },
                                    "16": {
                                        "value": 16
                                    },
                                    "17": {
                                        "value": 17
                                    },
                                    "18": {
                                        "value": 18
                                    },
                                    "19": {
                                        "value": 19
                                    },
                                    "20": {
                                        "value": 20
                                    }
                                }
                            },
                            "title": "Sorcery Points"
                        }
                    ]
                }
            ],
            "subclass": [
                {
                    "name": "Nature Domain",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "Trickery Domain",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "Death Domain",
                    "source": "DMG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "College of Whispers",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "psychic-blades",
                                "type": "dice",
                                "scale": {
                                    "3": {
                                        "n": 2,
                                        "die": 6
                                    },
                                    "5": {
                                        "n": 3,
                                        "die": 6
                                    },
                                    "10": {
                                        "n": 5,
                                        "die": 6
                                    },
                                    "15": {
                                        "n": 8,
                                        "die": 6
                                    }
                                }
                            },
                            "title": "Psychic Blades"
                        }
                    ]
                },
                {
                    "name": "Forge Domain",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "Order Domain",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                }
            ],
            "classFeature": [
                {
                    "name": "Unarmored Defense",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 1,
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Primal Knowledge",
                    "source": "TCE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "athletics",
                                        "intimidation",
                                        "nature",
                                        "perception",
                                        "survival"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Fast Movement",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 5,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ 10"
                                }
                            ]
                        }
                    ],
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Brutal Critical (1 die)",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 9,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.meleeCriticalDamageDice",
                                    "mode": "UPGRADE",
                                    "value": 1
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Brutal Critical (2 dice)",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 13,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.meleeCriticalDamageDice",
                                    "mode": "UPGRADE",
                                    "value": 2
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Brutal Critical (3 dice)",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 17,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.meleeCriticalDamageDice",
                                    "mode": "UPGRADE",
                                    "value": 3
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Primal Champion",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 20,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.abilities.str.value",
                                    "mode": "ADD",
                                    "value": "+ 4"
                                },
                                {
                                    "key": "data.abilities.con.value",
                                    "mode": "ADD",
                                    "value": "+ 4"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Jack of All Trades",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 2,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.jackOfAllTrades",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Harness Divine Power",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "level": 2,
                    "system": {
                        "uses.per": "day",
                        "uses.value": 1,
                        "uses.max": "1 + min(floor(@classes.cleric.levels / 6), 1) + min(floor(@classes.cleric.levels / 18), 1)"
                    }
                },
                {
                    "name": "Channel Divinity",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "level": 6,
                    "isIgnored": true
                },
                {
                    "name": "Channel Divinity",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "level": 18,
                    "isIgnored": true
                },
                {
                    "name": "Druidic",
                    "source": "PHB",
                    "className": "Druid",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "druidic": true
                            }
                        ]
                    }
                },
                {
                    "name": "Fighting Style",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "level": 1,
                    "isIgnored": true
                },
                {
                    "name": "Martial Arts",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 1,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Unarmed Strike (Monk)",
                                "source": "PHB",
                                "page": 76,
                                "srd": true,
                                "type": "M",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "entries": [
                                    {
                                        "type": "quote",
                                        "entries": [
                                            "Tether even a roasted chicken."
                                        ],
                                        "by": "Yamamoto Tsunetomo",
                                        "from": "Hagakure Kikigaki"
                                    }
                                ],
                                "foundrySystem": {
                                    "equipped": true,
                                    "damage.parts": [
                                        [
                                            "@scale.monk.die + @mod",
                                            "bludgeoning"
                                        ]
                                    ],
                                    "ability": "dex"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Unarmored Defense",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 1,
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Unarmored Movement",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 2,
                    "effects": [
                        {
                            "name": "Unarmored Movement",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.walk) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.burrow",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.burrow) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.climb",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.climb) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.fly",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.fly) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.swim",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.swim) * @scale.monk.unarmored-movement)"
                                }
                            ]
                        }
                    ],
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Diamond Soul",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 14,
                    "effects": [
                        {
                            "changes": [
                                {
                                    "key": "flags.dnd5e.diamondSoul",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Fighting Style",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "level": 2,
                    "isIgnored": true
                },
                {
                    "name": "Divine Health",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "level": 3,
                    "effects": [
                        {
                            "name": "Disease Immunity",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.traits.ci.value",
                                    "mode": "ADD",
                                    "value": "diseased"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Deft Explorer",
                    "source": "TCE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "any": 2
                            }
                        ],
                        "expertise": [
                            {
                                "anyProficientSkill": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Fighting Style",
                    "source": "PHB",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "level": 2,
                    "isIgnored": true
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            },
                            {
                                "anyProficientSkill": 1,
                                "thieves' tools": true
                            }
                        ]
                    }
                },
                {
                    "name": "Thieves' Cant",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "thieves' cant": true
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 6,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            },
                            {
                                "anyProficientSkill": 1,
                                "thieves' tools": true
                            }
                        ]
                    }
                },
                {
                    "name": "Reliable Talent",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 11,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.reliableTalent",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Blindsense",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 14,
                    "entryData": {
                        "senses": [
                            {
                                "blindsight": 10
                            }
                        ]
                    }
                },
                {
                    "name": "Slippery Mind",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 15,
                    "entryData": {
                        "savingThrowProficiencies": [
                            {
                                "wis": true
                            }
                        ]
                    }
                },
                {
                    "name": "Font of Magic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 2,
                    "system": {
                        "activation.type": null,
                        "uses.per": null,
                        "uses.value": null,
                        "uses.max": null
                    }
                },
                {
                    "name": "Sorcery Points",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 2,
                    "system": {
                        "uses.per": "lr",
                        "uses.max": "@scale.sorcerer.sorcery-points"
                    },
                    "img": "icons/magic/control/silhouette-hold-change-blue.webp"
                },
                {
                    "name": "Metamagic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 3,
                    "entries": [
                        "At 3rd level, you gain the ability to twist your spells to suit your needs. You gain two Metamagic options of your choice. You gain another one at 10th and 17th level.",
                        "You can use only one Metamagic option on a spell when you cast it, unless otherwise noted."
                    ]
                },
                {
                    "name": "Metamagic Options",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Metamagic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Metamagic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 17,
                    "isIgnored": true
                },
                {
                    "name": "Eldritch Invocations",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "level": 2,
                    "entries": [
                        "In your study of occult lore, you have unearthed eldritch invocations, fragments of forbidden knowledge that imbue you with an abiding magical ability.",
                        "At 2nd level, you gain two eldritch invocations of your choice. Your invocation options are detailed at the end of the class description. When you gain certain warlock levels, you gain additional invocations of your choice, as shown in the Invocations Known column of the Warlock table.",
                        "Additionally, when you gain a level in this class, you can choose one of the invocations you know and replace it with another invocation that you could learn at that level.",
                        "If an eldritch invocation has prerequisites, you must meet them to learn it. You can learn the invocation at the same time that you meet its prerequisites. A level prerequisite refers to your level in this class."
                    ]
                },
                {
                    "name": "Pact Boon",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Infusions Known",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "level": 2,
                    "isIgnored": true
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Expert Sidekick",
                    "classSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "light": true
                            }
                        ],
                        "savingThrowProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "dex",
                                        "int",
                                        "cha"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "skillProficiencies": [
                            {
                                "any": 5
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "TCE",
                    "className": "Expert Sidekick",
                    "classSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "TCE",
                    "className": "Expert Sidekick",
                    "classSource": "TCE",
                    "level": 15,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Spellcaster Sidekick",
                    "classSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "light": true
                            }
                        ],
                        "savingThrowProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "wis",
                                        "int",
                                        "cha"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "insight",
                                        "investigation",
                                        "medicine",
                                        "performance",
                                        "persuasion",
                                        "religion"
                                    ],
                                    "count": 2
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Warrior Sidekick",
                    "classSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "light": true,
                                "medium": true,
                                "heavy": true
                            }
                        ],
                        "savingThrowProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "str",
                                        "dex",
                                        "con"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "acrobatics",
                                        "animal handling",
                                        "athletics",
                                        "intimidation",
                                        "nature",
                                        "perception",
                                        "survival"
                                    ],
                                    "count": 2
                                }
                            }
                        ]
                    }
                }
            ],
            "subclassFeature": [
                {
                    "name": "Eagle",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Totem Warrior",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "activation.type": "bonus",
                        "activation.cost": 1
                    }
                },
                {
                    "name": "Call the Hunt",
                    "source": "TCE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Beast",
                    "subclassSource": "TCE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft"
                    }
                },
                {
                    "name": "Magic Awareness",
                    "source": "TCE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Wild Magic",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft"
                    }
                },
                {
                    "name": "Divine Fury",
                    "source": "XGE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Zealot",
                    "subclassSource": "XGE",
                    "level": 3,
                    "isChooseSystemRenderEntries": true,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "While you're raging, the first creature you hit on each of your turns with a weapon attack"
                    },
                    "chooseSystem": [
                        {
                            "name": "Necrotic Damage",
                            "system": {
                                "damage.parts": [
                                    [
                                        "1d6 + floor(@classes.barbarian.levels / 2)",
                                        "necrotic"
                                    ]
                                ]
                            }
                        },
                        {
                            "name": "Radiant Damage",
                            "system": {
                                "damage.parts": [
                                    [
                                        "1d6 + floor(@classes.barbarian.levels / 2)",
                                        "radiant"
                                    ]
                                ]
                            }
                        }
                    ]
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "any": 3
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "medium": true,
                                "shield|phb": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Performance of Creation",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "object",
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Animating Performance",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "object",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Unsettling Words",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Universal Speech",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 6,
                    "system": {
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Infectious Inspiration",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Tales from Beyond",
                    "source": "VRGR",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Enthralling Performance",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "activation.type": "minute",
                        "activation.cost": 1,
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "medium": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "scimitar|phb": true
                            }
                        ]
                    }
                },
                {
                    "name": "Fighting Style",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Psychic Blades",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "When you hit a creature with a weapon attack",
                        "damage.parts": [
                            [
                                "@scale.college-of-whispers.psychic-blades",
                                "psychic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Words of Terror",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "activation.type": "minute",
                        "activation.cost": 1,
                        "target.value": 1,
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Mantle of Whispers",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Shadow Lore",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Channel Divinity: Touch of Death",
                    "source": "DMG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Death",
                    "subclassSource": "DMG",
                    "level": 2,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "When the cleric hits a creature with a melee attack",
                        "damage.parts": [
                            [
                                "5 + (2 * @classes.cleric.levels)",
                                "necrotic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "DMG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Death",
                    "subclassSource": "DMG",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.death-domain.divine-strike",
                                "necrotic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Blessings of Knowledge",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 2
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Knowledge of the Ages",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "duration.value": 10,
                        "duration.units": "minute"
                    }
                },
                {
                    "name": "Channel Divinity: Read Thoughts",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Visions of the Past",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 17,
                    "system": {
                        "activation.type": "minute",
                        "activation.cost": 1
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Life",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ]
                    }
                },
                {
                    "name": "Disciple of Life",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Life",
                    "subclassSource": "PHB",
                    "level": 1,
                    "effects": [
                        {
                            "name": "Bonus Healing",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.bonuses.heal.damage",
                                    "mode": "ADD",
                                    "value": "+ @item.level + 2"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Channel Divinity: Radiance of the Dawn",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Light",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "damage.parts": [
                            [
                                "2d10 + @classes.cleric.levels",
                                "radiant"
                            ]
                        ],
                        "formula": ""
                    }
                },
                {
                    "name": "Corona of Light",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Light",
                    "subclassSource": "PHB",
                    "level": 17,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Acolyte of Nature",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "nature",
                                        "survival"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Charm Animals and Plants",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "damage.parts": [
                            [
                                "2d10 + @classes.cleric.levels",
                                "radiant"
                            ]
                        ]
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.nature-domain.divine-strike",
                                "cold"
                            ],
                            [
                                "@scale.nature-domain.divine-strike",
                                "fire"
                            ],
                            [
                                "@scale.nature-domain.divine-strike",
                                "lightning"
                            ]
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Tempest",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Invoke Duplicity",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Trickery",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Trickery",
                    "subclassSource": "PHB",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.order-domain.divine-strike",
                                "poison"
                            ]
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "War",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Acolyte of Strength",
                    "source": "PSA",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Strength (PSA)",
                    "subclassSource": "PSA",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "athletics",
                                        "nature",
                                        "survival"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Arcane Initiate",
                    "source": "SCAG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Arcana",
                    "subclassSource": "SCAG",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "arcana": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Arcane Abjuration",
                    "source": "SCAG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Arcana",
                    "subclassSource": "SCAG",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Order",
                    "subclassSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "intimidation",
                                        "persuasion"
                                    ]
                                }
                            }
                        ],
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Order's Demand",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Order",
                    "subclassSource": "TCE",
                    "level": 2,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Order",
                    "subclassSource": "TCE",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.order-domain.divine-strike",
                                "psychic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Emboldening Bond",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Peace",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Implement of Peace",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Peace",
                    "subclassSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "insight",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Twilight",
                    "subclassSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Eyes of Night",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Twilight",
                    "subclassSource": "TCE",
                    "level": 1,
                    "actorTokenMod": {
                        "dimSight": [
                            {
                                "mode": "setMax",
                                "value": 300
                            }
                        ]
                    },
                    "system": {
                        "target.type": "creature",
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TDCSR",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Blood",
                    "subclassSource": "TDCSR",
                    "level": 1,
                    "entryData": {
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Forge",
                    "subclassSource": "XGE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            }
                        ]
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Forge",
                    "subclassSource": "XGE",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.forge-domain.divine-strike",
                                "fire"
                            ]
                        ]
                    }
                },
                {
                    "name": "Saint of Forge and Fire",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Forge",
                    "subclassSource": "XGE",
                    "level": 17,
                    "entryData": {
                        "immune": [
                            "fire"
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Path to the Grave",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Grave",
                    "subclassSource": "XGE",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Sentinel at Death's Door",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Grave",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Keeper of Souls",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Grave",
                    "subclassSource": "XGE",
                    "level": 17,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Nature's Ward",
                    "source": "PHB",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Land",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "immune": [
                            "poison"
                        ],
                        "conditionImmune": [
                            "disease",
                            "poisoned"
                        ]
                    }
                },
                {
                    "name": "Halo of Spores",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Spores",
                    "subclassSource": "TCE",
                    "level": 2,
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "range.units": "self"
                    }
                },
                {
                    "name": "Spreading Spores",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Spores",
                    "subclassSource": "TCE",
                    "level": 10,
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "cube",
                        "range.value": 30,
                        "range.units": "ft",
                        "duration.value": 1,
                        "duration.units": "minute"
                    }
                },
                {
                    "name": "Fungal Body",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Spores",
                    "subclassSource": "TCE",
                    "level": 14,
                    "entryData": {
                        "conditionImmune": [
                            "blinded",
                            "deafened",
                            "frightened",
                            "poisoned"
                        ]
                    }
                },
                {
                    "name": "Summon Wildfire Spirit",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Wildfire",
                    "subclassSource": "TCE",
                    "level": 2,
                    "system": {
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Incarnation of Corruption",
                    "source": "TDCSR",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Blighted",
                    "subclassSource": "TDCSR",
                    "level": 14,
                    "entryData": {
                        "resist": [
                            "necrotic"
                        ]
                    }
                },
                {
                    "name": "Balm of the Summer Court",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Dreams",
                    "subclassSource": "XGE",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 120,
                        "range.units": "ft",
                        "uses.per": "charges",
                        "uses.value": 2,
                        "uses.max": "@classes.druid.levels",
                        "uses.recovery": "@classes.druid.levels",
                        "formula": "1d6",
                        "actionType": "healing"
                    }
                },
                {
                    "name": "Hearth of Moonlight and Shadow",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Dreams",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Hidden Paths",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Dreams",
                    "subclassSource": "XGE",
                    "level": 10,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Speech of the Woods",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Shepherd",
                    "subclassSource": "XGE",
                    "level": 2,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "sylvan": true
                            }
                        ]
                    }
                },
                {
                    "name": "Spirit Totem",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Shepherd",
                    "subclassSource": "XGE",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Unleash Incarnation",
                    "source": "EGW",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Echo Knight",
                    "subclassSource": "EGW",
                    "level": 3,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "Whenever you take the Attack action",
                        "activation.cost": 1
                    }
                },
                {
                    "name": "Combat Superiority",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "resources": [
                            {
                                "name": "Superiority Die",
                                "type": "dicePool",
                                "recharge": "restShort",
                                "count": "floor((<$level$> + 1) / 8) + 4",
                                "number": 1,
                                "faces": "8 + (sign(ceil((<$level$> - 2) / 8) - 1) * 2)"
                            }
                        ]
                    },
                    "system": {
                        "activation.type": null,
                        "uses.value": null,
                        "uses.max": null
                    }
                },
                {
                    "name": "Maneuver Options",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Student of War",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Additional Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 7,
                    "isIgnored": true
                },
                {
                    "name": "Additional Superiority Die",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 7,
                    "isIgnored": true
                },
                {
                    "name": "Additional Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Improved Combat Superiority (d10)",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Additional Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 15,
                    "isIgnored": true
                },
                {
                    "name": "Additional Superiority Die",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 15,
                    "isIgnored": true
                },
                {
                    "name": "Improved Combat Superiority (d12)",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 18,
                    "isIgnored": true
                },
                {
                    "name": "Improved Critical",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Champion",
                    "subclassSource": "PHB",
                    "level": 3,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.weaponCriticalThreshold",
                                    "mode": "OVERRIDE",
                                    "value": 19
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Remarkable Athlete",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Champion",
                    "subclassSource": "PHB",
                    "level": 7,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.remarkableAthlete",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Additional Fighting Style",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Champion",
                    "subclassSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Arcane Charge",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Eldritch Knight",
                    "subclassSource": "PHB",
                    "level": 15,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Rallying Cry",
                    "source": "SCAG",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Purple Dragon Knight (Banneret)",
                    "subclassSource": "SCAG",
                    "level": 3,
                    "system": {
                        "target.value": 3,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Royal Envoy",
                    "source": "SCAG",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Purple Dragon Knight (Banneret)",
                    "subclassSource": "SCAG",
                    "level": 7,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "insight",
                                        "intimidation",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ],
                        "expertise": [
                            {
                                "persuasion": true
                            }
                        ]
                    }
                },
                {
                    "name": "Inspiring Surge",
                    "source": "SCAG",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Purple Dragon Knight (Banneret)",
                    "subclassSource": "SCAG",
                    "level": 10,
                    "system": {
                        "target.value": 1,
                        "target.type": "ally",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Psionic Power",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Psi Warrior",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "resources": [
                            {
                                "name": "Psionic Energy Die",
                                "type": "dicePool",
                                "recharge": "restLong",
                                "count": "2 * PB",
                                "number": 1,
                                "faces": "(6 + ((ceil((<$level$> + 2) / 6) - 1) * 2))"
                            }
                        ]
                    }
                },
                {
                    "name": "Guarded Mind",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Psi Warrior",
                    "subclassSource": "TCE",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "psychic"
                        ]
                    }
                },
                {
                    "name": "Bulwark of Force",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Psi Warrior",
                    "subclassSource": "TCE",
                    "level": 15,
                    "system": {
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "giant": true
                            }
                        ]
                    }
                },
                {
                    "name": "Rune Carver",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entries": [
                        "{@i 3rd-level Rune Knight feature}",
                        "You can use magic runes to enhance your gear. You learn two runes of your choice, from among the runes described below, and each time you gain a level in this class, you can replace one rune you know with a different one from this feature. When you reach certain levels in this class, you learn additional runes, as shown in the Runes Known table.",
                        "Whenever you finish a long rest, you can touch a number of objects equal to the number of runes you know, and you inscribe a different rune onto each of the objects. To be eligible, an object must be a weapon, a suit of armor, a shield, a piece of jewelry, or something else you can wear or hold in a hand. Your rune remains on an object until you finish a long rest, and an object can bear only one of your runes at a time.",
                        {
                            "type": "table",
                            "caption": "Runes Known",
                            "colLabels": [
                                "Fighter Level",
                                "Number of Runes"
                            ],
                            "colStyles": [
                                "col-6 text-center",
                                "col-6 text-center"
                            ],
                            "rows": [
                                [
                                    "3rd",
                                    "2"
                                ],
                                [
                                    "7th",
                                    "3"
                                ],
                                [
                                    "10th",
                                    "4"
                                ],
                                [
                                    "15th",
                                    "5"
                                ]
                            ]
                        },
                        "If a rune has a level requirement, you must be at least that level in this class to learn the rune. If a rune requires a saving throw, your Rune Magic save DC equals 8 + your proficiency bonus + your Constitution modifier."
                    ]
                },
                {
                    "name": "Additional Rune Known",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 7,
                    "entries": [
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Cloud Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Fire Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Frost Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Stone Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Hill Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Storm Rune|TCE"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Runic Shield",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 7,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Additional Rune Known",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 10,
                    "entries": [
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Cloud Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Fire Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Frost Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Stone Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Hill Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Storm Rune|TCE"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Additional Rune Known",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 15,
                    "entries": [
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Cloud Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Fire Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Frost Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Stone Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Hill Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Storm Rune|TCE"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Arcane Archer Lore",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "nature"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Arcane Shot",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "uses.per": "sr",
                        "uses.value": 2,
                        "uses.max": 2
                    }
                },
                {
                    "name": "Arcane Shot Options",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "Arcane shots are all magical effects, and each one is associated with one of the schools of magic.",
                        "If an option requires a saving throw, your Arcane Shot save DC is calculated as follows:",
                        {
                            "type": "abilityDc",
                            "name": "Arcane Shot",
                            "attributes": [
                                "int"
                            ]
                        }
                    ]
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 7,
                    "isIgnored": true
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 15,
                    "isIgnored": true
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 18,
                    "isIgnored": true
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Cavalier",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "history",
                                        "insight",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Samurai",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "history",
                                        "insight",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Elegant Courtier",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Samurai",
                    "subclassSource": "XGE",
                    "level": 7,
                    "entryData": {
                        "savingThrowProficiencies": [
                            {
                                "wis": true
                            },
                            {
                                "choose": {
                                    "from": [
                                        "int",
                                        "cha"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Draconic Disciple",
                    "source": "FTD",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Ascendant Dragon",
                    "subclassSource": "FTD",
                    "level": 3,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Elemental Disciplines",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Extra Elemental Discipline",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 6,
                    "isIgnored": true
                },
                {
                    "name": "Extra Elemental Discipline",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 11,
                    "isIgnored": true
                },
                {
                    "name": "Extra Elemental Discipline",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 17,
                    "isIgnored": true
                },
                {
                    "name": "Shadow Step",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Shadow",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "space"
                    }
                },
                {
                    "name": "Hour of Reaping",
                    "source": "SCAG",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Long Death",
                    "subclassSource": "SCAG",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Implements of Mercy",
                    "source": "TCE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Mercy",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "insight": true,
                                "medicine": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "herbalism kit": true
                            }
                        ]
                    }
                },
                {
                    "name": "Mystical Erudition",
                    "source": "TDCSR",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Cobalt Soul",
                    "subclassSource": "TDCSR",
                    "level": 6,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "investigation",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Mystical Erudition (11th Level)",
                    "source": "TDCSR",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Cobalt Soul",
                    "subclassSource": "TDCSR",
                    "level": 11,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "investigation",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Mystical Erudition (17th Level)",
                    "source": "TDCSR",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Cobalt Soul",
                    "subclassSource": "TDCSR",
                    "level": 17,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "investigation",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Drunken Master",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "performance": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "brewer's supplies": true
                            }
                        ]
                    }
                },
                {
                    "name": "Path of the Kensei",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Kensei",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "calligrapher's supplies",
                                        "painter's supplies"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Radiant Sun Bolt",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Sun Soul",
                    "subclassSource": "XGE",
                    "level": 3,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Radiant Sun Bolt",
                                "source": "XGE",
                                "page": 35,
                                "type": "R",
                                "range": "30",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "entries": [
                                    "This special attack is a ranged spell attack with a range of 30 feet. You are proficient with it, and you add your Dexterity modifier to its attack and damage rolls.",
                                    "When you take the {@action Attack} action on your turn and use this special attack as part of it, you can spend 1 ki point to make this special attack twice as a bonus action. When you gain the Extra Attack feature, this special attack can be used for any of the attacks you make as part of the {@action Attack} action."
                                ],
                                "foundrySystem": {
                                    "equipped": true,
                                    "damage.parts": [
                                        [
                                            "@scale.monk.die + @mod",
                                            "radiant"
                                        ]
                                    ],
                                    "ability": "dex"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Searing Sunburst",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Sun Soul",
                    "subclassSource": "XGE",
                    "level": 11,
                    "system": {
                        "target.value": 20,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "range.value": 150,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Sun Shield",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Sun Soul",
                    "subclassSource": "XGE",
                    "level": 17,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Control Undead",
                    "source": "DMG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Oathbreaker",
                    "subclassSource": "DMG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Dreadful Aspect",
                    "source": "DMG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Oathbreaker",
                    "subclassSource": "DMG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Nature's Wrath",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Ancients",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Turn the Faithless",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Ancients",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Sacred Weapon",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Devotion",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 40,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Turn the Unholy",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Devotion",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Holy Nimbus",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Devotion",
                    "subclassSource": "PHB",
                    "level": 20,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Abjure Enemy",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Vengeance",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Vow of Enmity",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Vengeance",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Champion Challenge",
                    "source": "SCAG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Crown",
                    "subclassSource": "SCAG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Turn the Tide",
                    "source": "SCAG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Crown",
                    "subclassSource": "SCAG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Inspiring Smite",
                    "source": "TCE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Glory",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Glorious Defense",
                    "source": "TCE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Glory",
                    "subclassSource": "TCE",
                    "level": 15,
                    "system": {
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Vigilant Rebuke",
                    "source": "TCE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Watchers",
                    "subclassSource": "TCE",
                    "level": 15,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Conquering Presence",
                    "source": "XGE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Conquest",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Rebuke the Violent",
                    "source": "XGE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Redemption",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Draconic Gift",
                    "source": "FTD",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Drakewarden",
                    "subclassSource": "FTD",
                    "level": 3,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Otherworldly Glamour",
                    "source": "TCE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Fey Wanderer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "deception",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Beguiling Twist",
                    "source": "TCE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Fey Wanderer",
                    "subclassSource": "TCE",
                    "level": 7,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Umbral Sight",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Gloom Stalker",
                    "subclassSource": "XGE",
                    "level": 3,
                    "actorTokenMod": {
                        "_": [
                            {
                                "mode": "conditionals",
                                "conditionals": [
                                    {
                                        "condition": "!PLUT_CONTEXT?.actor?.data?.token?.dimSight",
                                        "mod": {
                                            "dimSight": [
                                                {
                                                    "mode": "set",
                                                    "value": 60
                                                }
                                            ]
                                        }
                                    },
                                    {
                                        "mod": {
                                            "dimSight": [
                                                {
                                                    "mode": "scalarAdd",
                                                    "scalar": 30
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        ]
                    }
                },
                {
                    "name": "Iron Mind",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Gloom Stalker",
                    "subclassSource": "XGE",
                    "level": 7,
                    "entryData": {
                        "savingThrowProficiencies": [
                            {
                                "wis": true
                            },
                            {
                                "choose": {
                                    "from": [
                                        "int",
                                        "cha"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Hunter's Sense",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Monster Slayer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Slayer's Prey",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Monster Slayer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Magic-User's Nemesis",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Monster Slayer",
                    "subclassSource": "XGE",
                    "level": 11,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Assassin",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "disguise kit": true,
                                "poisoner's kit": true
                            }
                        ]
                    }
                },
                {
                    "name": "Wails from the Grave",
                    "source": "TCE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Phantom",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Psionic Power",
                    "source": "TCE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Soulknife",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "resources": [
                            {
                                "name": "Psionic Energy Die",
                                "type": "dicePool",
                                "recharge": "restLong",
                                "count": "2 * PB",
                                "number": 1,
                                "faces": "(6 + (ceil((<$level$> + 2) / 6) - 1) * 2)"
                            }
                        ]
                    }
                },
                {
                    "name": "Master of Intrigue",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Mastermind",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "disguise kit": true,
                                "forgery kit": true,
                                "gaming set": true
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Master of Tactics",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Mastermind",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Survivalist",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Scout",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "expertise": [
                            {
                                "nature": true,
                                "survival": true
                            }
                        ]
                    }
                },
                {
                    "name": "Superior Mobility",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Scout",
                    "subclassSource": "XGE",
                    "level": 9,
                    "effects": [
                        {
                            "name": "Superior Mobility",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ 10"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Draconic Resilience",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 1,
                    "effects": [
                        {
                            "name": "Natural Armor",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.ac.calc",
                                    "mode": "OVERRIDE",
                                    "value": "draconic"
                                }
                            ]
                        },
                        {
                            "name": "HP Increase",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.hp.max",
                                    "mode": "ADD",
                                    "value": "+ @classes.sorcerer.levels"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Dragon Ancestor",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "draconic": true
                            }
                        ]
                    }
                },
                {
                    "name": "Dragon Wings",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 14,
                    "effects": [
                        {
                            "name": "Flying Speed",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.fly",
                                    "mode": "UPGRADE",
                                    "value": "@attributes.movement.walk"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Draconic Presence",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 18,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Telepathic Speech",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Aberrant Mind",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Warping Implosion",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Aberrant Mind",
                    "subclassSource": "TCE",
                    "level": 18,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Restore Balance",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Clockwork Soul",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bastion of Law",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Clockwork Soul",
                    "subclassSource": "TCE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Clockwork Cavalcade",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Clockwork Soul",
                    "subclassSource": "TCE",
                    "level": 18,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "cube"
                    }
                },
                {
                    "name": "Hound of Ill Omen",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Shadow",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Shadow Walk",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Shadow",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Wind Speaker",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Storm",
                    "subclassSource": "XGE",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "primordial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Heart of the Storm",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Storm",
                    "subclassSource": "XGE",
                    "level": 6,
                    "entryData": {
                        "resist": [
                            "lightning",
                            "thunder"
                        ]
                    },
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Wind Soul",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Storm",
                    "subclassSource": "XGE",
                    "level": 18,
                    "entryData": {
                        "immune": [
                            "lightning",
                            "thunder"
                        ]
                    }
                },
                {
                    "name": "Fey Presence",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 1,
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "cube"
                    }
                },
                {
                    "name": "Misty Escape",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Beguiling Defenses",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "conditionImmune": [
                            "charmed"
                        ]
                    }
                },
                {
                    "name": "Dark Delirium",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Awakened Mind",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Great Old One",
                    "subclassSource": "PHB",
                    "level": 1,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Thought Shield",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Great Old One",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "psychic"
                        ]
                    }
                },
                {
                    "name": "Gift of the Sea",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 1,
                    "effects": [
                        {
                            "name": "Gift of the Sea",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.swim",
                                    "mode": "UPGRADE",
                                    "value": "40"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Tentacle of the Deeps",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Oceanic Soul",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 6,
                    "entryData": {
                        "resist": [
                            "cold"
                        ]
                    }
                },
                {
                    "name": "Fathomless Plunge",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "radius",
                        "range.value": 1,
                        "range.units": "mi"
                    }
                },
                {
                    "name": "Sanctuary Vessel",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Genie",
                    "subclassSource": "TCE",
                    "level": 10,
                    "system": {
                        "target.value": 5,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Necrotic Husk",
                    "source": "VRGR",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Undead",
                    "subclassSource": "VRGR",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "necrotic"
                        ]
                    },
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Radiant Soul",
                    "source": "XGE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Celestial",
                    "subclassSource": "XGE",
                    "level": 6,
                    "entryData": {
                        "resist": [
                            "radiant"
                        ]
                    }
                },
                {
                    "name": "Searing Vengeance",
                    "source": "XGE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Celestial",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Hex Warrior",
                    "source": "XGE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Hexblade",
                    "subclassSource": "XGE",
                    "level": 1,
                    "entryData": {
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ],
                        "armorProficiencies": [
                            {
                                "shield|phb": true,
                                "medium": true
                            }
                        ]
                    }
                },
                {
                    "name": "Chronal Shift",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 2,
                    "system": {
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Temporal Awareness",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 2,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.init.total",
                                    "mode": "ADD",
                                    "value": "+ @abilities.int.mod"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Momentary Stasis",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 6,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Convergent Future",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 14,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Adjust Density",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Graviturgy",
                    "subclassSource": "EGW",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Violent Attraction",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Graviturgy",
                    "subclassSource": "EGW",
                    "level": 10,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Event Horizon",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Graviturgy",
                    "subclassSource": "EGW",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Arcane Ward",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Abjuration",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "activation.type": "special",
                        "activation.cost": null,
                        "uses.per": null,
                        "uses.max": "2 * @classes.wizard.levels + floor((@abilities.int.value - 10) / 2)"
                    }
                },
                {
                    "name": "Projected Ward",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Abjuration",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Benign Transposition",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Conjuration",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Hypnotic Gaze",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Enchantment",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 5,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Instinctive Charm",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Enchantment",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Inured to Undeath",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Necromancy",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "necrotic"
                        ]
                    }
                },
                {
                    "name": "Command Undead",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Necromancy",
                    "subclassSource": "PHB",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Training in War and Song (Bladesinging)",
                    "source": "TCE",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Bladesinging",
                    "subclassSource": "TCE",
                    "level": 2,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "performance": true
                            }
                        ],
                        "armorProficiencies": [
                            {
                                "light": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "choose": {
                                    "fromFilter": "type=melee weapon|property=!two-handed|rarity=none"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Deflecting Shroud",
                    "source": "XGE",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "War",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 3,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Tiger",
                    "source": "SCAG",
                    "className": "Barbarian",
                    "classSource": "SCAG",
                    "subclassShortName": "Totem Warrior",
                    "subclassSource": "PHB",
                    "level": 6,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "athletics",
                                        "acrobatics",
                                        "stealth",
                                        "survival"
                                    ],
                                    "count": 2
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Tool Proficiency",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Alchemist",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "alchemist's supplies": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Chemical Mastery",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Alchemist",
                    "subclassSource": "TCE",
                    "level": 15,
                    "entryData": {
                        "resist": [
                            "acid",
                            "poison"
                        ],
                        "conditionImmune": [
                            "poisoned"
                        ]
                    }
                },
                {
                    "name": "Armor Model",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "uses.value": null,
                        "uses.max": null,
                        "uses.per": null
                    }
                },
                {
                    "name": "Defensive Field",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "actionType": "heal",
                        "damage.parts": [
                            [
                                "@classes.artificer.levels",
                                "temphp"
                            ]
                        ]
                    }
                },
                {
                    "name": "Lightning Launcher",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Lightning Launcher",
                                "source": "TCE",
                                "page": 15,
                                "srd": true,
                                "type": "R",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "dmg1": "1d6",
                                "dmgType": "L",
                                "range": "90/300",
                                "entries": [
                                    "This weapon is part of the Infiltrator armor model. When you attack with that weapon, you can add your Intelligence modifier, instead of Strength or Dexterity, to the attack and damage rolls.",
                                    "Once on each of your turns when you hit a creature with the launcher, you can deal an extra {@damage 1d6} lightning damage to that target."
                                ],
                                "foundrySystem": {
                                    "ability": "int"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Powered Steps",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "effects": [
                        {
                            "name": "Powered Steps",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ 5"
                                }
                            ],
                            "disabled": true
                        }
                    ]
                },
                {
                    "name": "Thunder Gauntlets",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Thunder Gauntlets",
                                "source": "TCE",
                                "page": 15,
                                "srd": true,
                                "type": "M",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "dmg1": "1d8",
                                "dmgType": "T",
                                "entries": [
                                    "This weapon is part of the Guardian armor model. When you attack with that weapon, you can add your Intelligence modifier, instead of Strength or Dexterity, to the attack and damage rolls.",
                                    "A creature hit by the gauntlet has disadvantage on attack rolls against targets other than you until the start of your next turn, as the armor magically emits a distracting pulse when the creature attacks someone else."
                                ],
                                "foundrySystem": {
                                    "ability": "int"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Tools of the Trade",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Eldritch Cannon",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Artillerist",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "damage.parts": [
                            [
                                "2d8",
                                "fire"
                            ],
                            [
                                "2d8",
                                "force"
                            ]
                        ],
                        "formula": "1d8 + @abilities.int.mod"
                    }
                },
                {
                    "name": "Tool Proficiency",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Artillerist",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "woodcarver's tools": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Arcane Firearm",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Artillerist",
                    "subclassSource": "TCE",
                    "level": 5,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.bonuses.msak.damage",
                                    "mode": "ADD",
                                    "value": "+ 1d8"
                                },
                                {
                                    "key": "data.bonuses.rsak.damage",
                                    "mode": "ADD",
                                    "value": "+ 1d8"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Battle Ready",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Battle Smith",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Tool Proficiency",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Battle Smith",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                }
            ]
        }
        `;
        let parsed = JSON.parse(_foundry);
        return parsed;
    }
    static getClasses(){
        return ContentGetter._cachedData.class;
    }
    static getSubclasses(){
        return ContentGetter._cachedData.subclass;
    }
    static getRaces(filter=true){
        if(filter){return ContentGetter.getRaces(false).filter(f => !!f && !!f.name);}
        return ContentGetter._cachedData.race;
    }
    static getSubraces(filter=true){
        if(filter){return ContentGetter.getSubraces(false).filter(f => !!f && !!f.name);}
        return ContentGetter._cachedData.subrace;
    }
    static getBackgrounds(filter=true){
        if(filter){return ContentGetter.getBackgrounds(false).filter(f => !!f && !!f.name);}
        return ContentGetter._cachedData.background;
    }
    static getFeaturesFromClass(cls){
        return ContentGetter._cachedData.classFeature.filter(f => !!f && f.className == cls.name && f.classSource == cls.source);
    }
    static getFeaturesFromSubclass(sc){
        return this._cachedData.subclassFeature.filter(f =>
            f.className == sc.className &&
            f.classSource == sc.classSource &&
            f.subclassSource == sc.source &&
            f.subclassShortName == sc.shortName);
    }
    static getClassByNameAndSource(name, source) {
        return ContentGetter.getClasses().filter(cls => !!cls && cls.name == name && cls.source == source);
    }
    static getClassFeatureByUID(featureUID){
        const unpacked = ContentGetter.unpackUidClassFeature(featureUID);
        const foundClasses = this.getClassByNameAndSource(unpacked.className, unpacked.classSource);
        if(foundClasses.length<1){console.error("Did not find any classes with name and source ", unpacked.className, unpacked.classSource);}
        if(foundClasses.length>1){console.error("Found too many classes with name and source ", unpacked.className, unpacked.classSource);}
        const cls = foundClasses[0];
        const allFeatures = ContentGetter.getFeaturesFromClass(cls);
        return allFeatures.filter(f => f.name == unpacked.name && f.level == unpacked.level)[0];
    }
    static async _cookData(data){
        console.log("data", data);
        await ContentGetter.cookClassFeatures(data);
        await ContentGetter.cookSpellClasses(data);
    }
    /**Slightly parses the class features a bit to prepare them with loadeds, a property needed to convert them to option sets later. */
    static async cookClassFeatures(data){
        //Prep class feature info
        const isIgnoredLookup = {
            "elemental disciplines|monk||four elements||3":true,
            "fighting style|bard||swords|xge|3":true,
            "infusions known|artificer|tce|2":true,
            "maneuver options|fighter||battle master||3|tce":true,
            "maneuvers|fighter||battle master||3":true
        };
        
        const opts = {actor: null, isIgnoredLookup: isIgnoredLookup};
        
        for(let j = 0; j < data.class.length; ++j)
        {
            let cls = data.class[j];
            //Make sure the classFeatures aren't just strings, look like this:
            //{classFeature: "string"}
            for(let i = 0; i < cls.classFeatures.length; ++i){
            let f = cls.classFeatures[i];
            if (typeof f !== "object") {cls.classFeatures[i] = {classFeature: f};}
            }
    
            //Now we need to flesh out some more data about the class features, using just the UID we can get a lot of such info.
            //await (cls.classFeatures || []).pSerialAwaitMap(cf => ContentGetter.pInitClassFeatureLoadedsSync({...opts, classFeature: cf, className: cls.name}));
            await (cls.classFeatures || []).map(cf => ContentGetter.pInitClassFeatureLoadedsSync({...opts, classFeature: cf, className: cls.name}));

            if (cls.classFeatures) {cls.classFeatures = cls.classFeatures.filter(it => !it.isIgnored);}
            data.class[j] = cls;
    
            /* for (const sc of cls.subclasses || []) {
            await (sc.subclassFeatures || []).pSerialAwaitMap(scf => this.pInitSubclassFeatureLoadeds({...opts, subclassFeature: scf, className: cls.name, subclassName: sc.name}));
    
            if (sc.subclassFeatures) sc.subclassFeatures = sc.subclassFeatures.filter(it => !it.isIgnored);
        } */
        }
    }
    static async cookSpellClasses(data){
        const _SPELL_SOURCE_LOOKUP = await HelperFunctions.loadJSONFile(`data/generated/gendata-spell-source-lookup.json`);
        DataUtil.spell._SPELL_SOURCE_LOOKUP = _SPELL_SOURCE_LOOKUP;
        for(let i = 0; i < data.spell.length; ++i){
            data.spell[i] = DataUtil.spell._mutEntity(data.spell[i]);
        }
        console.log(data.spell[0]);
    }

    static SRC_PHB = "PHB";
    /**Takes a UID from a class feature (like Rage|Barbarian|1|PHB) and unpacks it into separate values. Returns name, className, classSource, level, source, displayText */
    static unpackUidClassFeature (uid, opts) {
        opts = opts || {};
        if (opts.isLower) uid = uid.toLowerCase();
        let [name, className, classSource, level, source, displayText] = uid.split("|").map(it => it.trim());
        classSource = classSource || (opts.isLower ? ContentGetter.SRC_PHB.toLowerCase() : ContentGetter.SRC_PHB);
        source = source || classSource;
        level = Number(level);
        return {
            name,
            className,
            classSource,
            level,
            source,
            displayText,
        };
    }
    static unpackUidSubclassFeature(uid, opts) {
        opts = opts || {};
        if (opts.isLower){uid = uid.toLowerCase();}
        let[name,className,classSource,subclassShortName,subclassSource,level,source,displayText] = uid.split("|").map(it=>it.trim());
        classSource = classSource || (opts.isLower ? ContentGetter.SRC_PHB.toLowerCase() : ContentGetter.SRC_PHB);
        subclassSource = subclassSource || (opts.isLower ? ContentGetter.SRC_PHB.toLowerCase() : ContentGetter.SRC_PHB);
        source = source || subclassSource;
        level = Number(level);
        return {
            name,
            className,
            classSource,
            subclassShortName,
            subclassSource,
            level,
            source,
            displayText,
        };
    }
    
    static getFeaturesGroupedByOptionsSet(allFeatures) {
        return allFeatures.map(topLevelFeature=>{
            const optionsSets = [];

            let optionsStack = [];
            let lastOptionsSetId = null;
            topLevelFeature.loadeds.forEach(l=>{
                const optionsSetId = MiscUtil.get(l, "optionsMeta", "setId") || null;
                if (lastOptionsSetId !== optionsSetId) {
                    if (optionsStack.length)
                        optionsSets.push(optionsStack);
                    optionsStack = [l];
                    lastOptionsSetId = optionsSetId;
                } else {
                    optionsStack.push(l);
                }
            }
            );
            if (optionsStack.length)
                optionsSets.push(optionsStack);

            return {
                topLevelFeature,
                optionsSets
            };
        }
        );
    }


    static async pInitClassFeatureLoadeds({classFeature, className, ...opts}) {
        if (typeof classFeature !== "object")
            throw new Error(`Expected an object of the form {classFeature: "<UID>"}`);

        const unpacked = MyDataUtil.unpackUidClassFeature(classFeature.classFeature);

        classFeature.hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked);

        const {name, level, source} = unpacked;
        classFeature.name = name;
        classFeature.level = level;
        classFeature.source = source;

        const entityRoot = ContentGetter.getClassFeatureByUID(classFeature.classFeature);
        /* const entityRoot = await DataLoader.pCacheAndGet("raw_classFeature", classFeature.source, classFeature.hash, {
            isCopy: true
        }); */
        const loadedRoot = {
            type: "classFeature",
            entity: entityRoot,
            page: "classFeature",
            source: classFeature.source,
            hash: classFeature.hash,
            className,
        };

       /*  const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, "classFeature");
        if (isIgnored) {
            classFeature.isIgnored = true;
            return;
        }

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: "classFeature",
            ancestorMeta: {
                _ancestorClassName: className,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        classFeature.loadeds = [loadedRoot, ...subLoadeds]; */
    }
    static pInitClassFeatureLoadedsSync({classFeature, className, ...opts}) {
        if (typeof classFeature !== "object")
            throw new Error(`Expected an object of the form {classFeature: "<UID>"}`);

        const unpacked = ContentGetter.unpackUidClassFeature(classFeature.classFeature);
        classFeature.hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked);

        const {name, level, source, classSource, _className} = unpacked;
        classFeature.name = name;
        classFeature.level = level;
        classFeature.source = source;

        const entityRoot = ContentGetter.getClassFeatureByUID(classFeature.classFeature);
        /* const entityRoot = await DataLoader.pCacheAndGet("raw_classFeature", classFeature.source, classFeature.hash, {
            isCopy: true
        }); */
        const loadedRoot = {
            type: "classFeature",
            entity: entityRoot,
            page: "classFeature",
            source: classFeature.source,
            hash: classFeature.hash,
            className,
        };

       /*  const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, "classFeature");
        if (isIgnored) { classFeature.isIgnored = true; return;}

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: "classFeature",
            ancestorMeta: {
                _ancestorClassName: className,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        classFeature.loadeds = [loadedRoot, ...subLoadeds]; */

        //TEMPFIX
        //very lazy fix attempt
        const foundryData = ContentGetter._getFoundryData();
        //console.log("loadedroot", loadedRoot, classFeature);
        let _entryData = loadedRoot.entity.entryData; //Check if the entity has an 'entryData' object (contains info about the choices)
        if(!_entryData){
            //If no entryData exists, let's ask our foundry.json file if they know if this feature should have any entryData
            let foundryFeature = ContentGetter.getFoundryDataForFeature({name: name, level:level, source:source, className:_className, classSource:classSource}, foundryData);
            if(foundryFeature){ loadedRoot.entity.entryData = foundryFeature.entryData; }
        }
        classFeature.loadeds = [loadedRoot];
    }

    /**Deprecated */
    static addClassFeatureEntryDatas(features){
        //First we need to get the features to parse through
    /*  const filteredClassFeatures = MiscUtil.copy(ContentGetter.getFeaturesFromClass(curClass));
        const filteredSubclassFeatures = curSubclass == null? [] : MiscUtil.copy(ContentGetter.getFeaturesFromSubclass(curSubclass));
        
        //Might wanna sort this by level later
        let features = filteredClassFeatures.concat(filteredSubclassFeatures); */
        
        //Right now, the info for class feature choices is unfortunately stored in another JSON files
        //Brewed subclasses on 5eTools should contains this information (i.e. it has the 'entryData' component in the subclass feature)
        //Our base 5e SRD classes unfortunately do not have this information, that's why we need the foundry JSON
        const foundryData = ContentGetter._getFoundryData();
        for(let f of features)
        {
            let _entryData = f.entryData; //Check if the feature has an 'entryData' object (contains info about the choices)
            if(!_entryData){
                //If no entryData exists, let's ask our foundry.json file if they know if this feature should have any entryData
                let foundryFeature = ContentGetter.getFoundryDataForFeature(f, foundryData);
                if(foundryFeature){ _entryData = foundryFeature.entryData; }
            }
            //Maybe it was set during the previous if statement, check again
            if(_entryData){
                f.entryData = _entryData;
            }
        }
    }
    static getFoundryDataForFeature(feature, foundryData){
        const matchClass = false;
        const matchClassSource = false;
        const filtered = foundryData.classFeature.filter(f => 
            f.name == feature.name && f.level == feature.level
            && f.source == feature.source && 
            (!matchClass || f.className == feature.className) &&
            (!matchClassSource || f.classSource == feature.classSource));
        //Should only recieve one answer here
        if(filtered.length > 1){console.error("found too many entries");}
        //if(filtered.length < 1){console.log("Could not find foundry feature to match " + feature.name + "|" + feature.source); return null;} //Dont expect all classFeatures to be listed in here
        //if(filtered.length == 1){console.log("Found match for " + feature.name);}
        return filtered[0];
    }
}

class SourceSelectorTest {
    static async getOutputEntities() {

        const officialSources = new UtilDataSource.DataSourceSpecial("SRD", this._pLoadVetoolsSource.bind(this), {
            'cacheKey': '5etools-charactermancer',
            'filterTypes': [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
            'isDefault': true,
            //'pPostLoad': this._pPostLoad.bind(this, {'actor': _0x2344b6 })
        });
        const sources = [officialSources];

        //Should contain all spells, classes, etc from every source we provide
        const allContentMeta = await UtilDataSource.pGetAllContent({
			sources,
			/* uploadedFileMetas: this.uploadedFileMetas,
			customUrls: this.getCustomUrls(),
			isBackground,

			page: this._page,

			isDedupable: this._isDedupable,
			fnGetDedupedData: this._fnGetDedupedData,

			fnGetBlocklistFilteredData: this._fnGetBlocklistFilteredData,

			isAutoSelectAll, */
		});

        const out = allContentMeta.dedupedAllContentMerged;
        //spells have their classes set already, thankfully
        //however class feature's loadeds are not set
        console.log("loaded content", out);
        //TEMPFIX
       /*  Renderer.spell.populatePrereleaseLookup(await PrereleaseUtil.pGetBrewProcessed(), {isForce: true});
		Renderer.spell.populateBrewLookup(await BrewUtil2.pGetBrewProcessed(), {isForce: true});

		(out.spell || []).forEach(sp => { Renderer.spell.uninitBrewSources(sp); Renderer.spell.initBrewSources(sp); }); */

        return out;
    }
    static async _pLoadVetoolsSource() {
        const combinedSource = {};
        const [classResult, raceResult, backgroundResult, itemResults, spellResults, featResults, optionalFeatureResults]
        = await Promise.all([Vetools.pGetClasses(), Vetools.pGetRaces(), DataUtil.loadJSON(Vetools.DATA_URL_BACKGROUNDS),
            Vetools.pGetItems(), Vetools.pGetAllSpells(), DataUtil.loadJSON(Vetools.DATA_URL_FEATS), DataUtil.loadJSON(Vetools.DATA_URL_OPTIONALFEATURES)]);
        Object.assign(combinedSource, classResult);
        combinedSource.race = raceResult.race;
        combinedSource.background = backgroundResult.background;
        combinedSource.item = itemResults.item;
        combinedSource.spell = spellResults.spell;
        combinedSource.feat = featResults.feat;
        combinedSource.optionalfeature = optionalFeatureResults.optionalfeature;
        return combinedSource;
    }
      /* static async _pPostLoad(_0x4e0586) {
        if (isBrewOrPrerelease) {
          const {
            isPrerelease: _0xd968a5,
            isBrew: _0xbba490
          } = UtilDataSource.getSourceType(_0x4e0586, {
            'isErrorOnMultiple': true
          });
          _0xd968a5;
          isBrew = _0xbba490;
        }
        _0x4e0586 = await UtilDataSource.pPostLoadGeneric({
          'isBrew': isBrew,
          'isPrerelease': _0xd968a5
        }, _0x4e0586);
        if (_0x4e0586["class"] || _0x4e0586.subclass) {
          const {
            DataConverterClassSubclassFeature: _0x1311c6
          } = await Promise.resolve().then(function () {
            return DataConverterClassSubclassFeature$1;
          });
          const _0x2f74ed = await _0x1311c6.pGetClassSubclassFeatureIgnoredLookup({
            'data': _0x4e0586
          });
          const _0x15dc0a = await PageFilterClassesFoundry.pPostLoad({
            'class': _0x4e0586["class"],
            'subclass': _0x4e0586.subclass,
            'classFeature': _0x4e0586.classFeature,
            'subclassFeature': _0x4e0586.subclassFeature
          }, {
            'actor': _0x5d48db,
            'isIgnoredLookup': _0x2f74ed
          });
          Object.assign(_0x4e0586, _0x15dc0a);
          if (_0x4e0586["class"]) {
            _0x4e0586["class"].forEach(_0x4b57f1 => PageFilterClasses.mutateForFilters(_0x4b57f1));
          }
        }
        if (_0x4e0586.feat) {
          _0x4e0586.feat = MiscUtil.copy(_0x4e0586.feat);
        }
        if (_0x4e0586.optionalfeature) {
          _0x4e0586.optionalfeature = MiscUtil.copy(_0x4e0586.optionalfeature);
        }
        return _0x4e0586;
      } */
}

class UtilDataSource {

    static sortListItems(a, b, o) {
        const ixTypeA = Math.min(...a.values.filterTypes.map(it=>UtilDataSource.SOURCE_TYPE_ORDER.indexOf(it)));
        const ixTypeB = Math.min(...b.values.filterTypes.map(it=>UtilDataSource.SOURCE_TYPE_ORDER.indexOf(it)));

        return SortUtil.ascSort(ixTypeA, ixTypeB) || SortUtil.compareListNames(a, b);
    }

    static _PROPS_NO_BLOCKLIST = new Set(["itemProperty", "itemType", "spellList"]);
    static _PROP_RE_FOUNDRY = /^foundry[A-Z]/;

    static getMergedData(data, {isFilterBlocklisted=true}={}) {
        const mergedData = {};

        data.forEach(sourceData=>{
            Object.entries(sourceData).forEach(([prop,arr])=>{
                if (!arr || !(arr instanceof Array))
                    return;
                if (mergedData[prop])
                    mergedData[prop] = [...mergedData[prop], ...MiscUtil.copy(arr)];
                else
                    mergedData[prop] = MiscUtil.copy(arr);
            }
            );
        });

        if (isFilterBlocklisted) {
            Object.entries(mergedData).forEach(([prop,arr])=>{
                if (!arr || !(arr instanceof Array))
                    return;
                mergedData[prop] = mergedData[prop].filter(it=>{
                    if (SourceUtil.getEntitySource(it) === VeCt.STR_GENERIC)
                        return false;

                    if (it.__prop && this._PROPS_NO_BLOCKLIST.has(it.__prop))
                        return true;
                    if (it.__prop && this._PROP_RE_FOUNDRY.test(it.__prop))
                        return false;

                    if (!SourceUtil.getEntitySource(it)) {
                        console.warn(`Entity did not have a "source"! This should never occur.`);
                        return true;
                    }
                    if (!it.__prop) {
                        console.warn(`Entity did not have a "__prop"! This should never occur.`);
                        return true;
                    }
                    if (!UrlUtil.URL_TO_HASH_BUILDER[it.__prop]) {
                        console.warn(`No hash builder found for "__prop" "${it.__prop}"! This should never occur.`);
                        return true;
                    }

                    switch (it.__prop) {
                    case "class":
                        {
                            if (!it.subclasses?.length)
                                break;

                            it.subclasses = it.subclasses.filter(sc=>{
                                if (sc.source === VeCt.STR_GENERIC)
                                    return false;

                                return !ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc), "subclass", sc.source, {
                                    isNoCount: true
                                }, );
                            }
                            );

                            break;
                        }

                    case "item":
                    case "baseitem":
                    case "itemGroup":
                    case "magicvariant":
                    case "_specificVariant":
                        {
                            return !Renderer.item.isExcluded(it);
                        }

                    case "race":
                        {
                            if (this._isExcludedRaceSubrace(it))
                                return false;
                        }
                    }

                    return !ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[it.__prop](it), it.__prop, SourceUtil.getEntitySource(it), {
                        isNoCount: true
                    }, );
                }
                );
            }
            );
        }

        return mergedData;
    }

    static async pHandleBackgroundLoad({pLoad, isBackground=false, cntSources=null}) {
        const pTimeout = isBackground ? MiscUtil.pDelay(500, VeCt.SYM_UTIL_TIMEOUT) : null;

        const promises = [pLoad, pTimeout].filter(Boolean);

        const winner = await Promise.race(promises);
        if (winner === VeCt.SYM_UTIL_TIMEOUT)
            ui.notifications.info(`Please wait while ${cntSources != null ? `${cntSources} source${cntSources === 1 ? " is" : "s are"}` : "data is being"} loaded...`);
        return pLoad;
    }

    static _IGNORED_KEYS = new Set(["_meta", "$schema", ]);

    static async pGetAllContent({sources, uploadedFileMetas, customUrls, isBackground=false, userData, cacheKeys=null,
        page, isDedupable=false, fnGetDedupedData=null, fnGetBlocklistFilteredData=null, isAutoSelectAll=false, }, ) {
        const allContent = [];

        if (isAutoSelectAll && this.isTooManySources({ cntSources: sources.length })) {
            const ptHelp = `This may take a (very) long time! If this seems like too much, ${game.user.isGM ? "your GM" : "you"} may have to adjust ${game.user.isGM ? "your" : "the"} "Data Sources" Config options/${game.user.isGM ? "your" : "the"} "World Data Source Selector" list to limit the number of sources selected by default.`;

            console.warn(...LGT, `${sources.length} source${sources.length === 1 ? "" : "s"} are being loaded! ${ptHelp}`);

            if (!(await InputUiUtil.pGetUserBoolean({
                title: "Too Many Sources",
                htmlDescription: `You are about to load ${sources.length} source${sources.length === 1 ? "" 
                : "s"}. ${ptHelp}<br>Would you like to load ${sources.length} source${sources.length === 1 ? "" : "s"}?`,
                textNo: "Cancel",
                textYes: "Continue",
            })))
                return null;
        }

        const pLoad = sources.pMap(async source=>{
            await source.pLoadAndAddToAllContent({ uploadedFileMetas, customUrls, allContent, cacheKeys });
        });

        await UtilDataSource.pHandleBackgroundLoad({
            pLoad,
            isBackground,
            cntSources: sources.length
        });

        const allContentMerged = {};

        if (allContent.length === 1)
            Object.assign(allContentMerged, allContent[0]);
        else {
            allContent.forEach(obj=>{
                Object.entries(obj).forEach(([k,v])=>{
                    if (v == null)
                        return;
                    if (this._IGNORED_KEYS.has(k))
                        return;

                    if (!(v instanceof Array))
                        console.warn(`Could not merge "${typeof v}" for key "${k}"!`);

                    allContentMerged[k] = allContentMerged[k] || [];
                    allContentMerged[k] = [...allContentMerged[k], ...v];
                }
                );
            });
        }

        let dedupedAllContentMerged = fnGetDedupedData ? fnGetDedupedData({
            allContentMerged,
            isDedupable
        }) : this._getDedupedAllContentMerged({
            allContentMerged,
            isDedupable
        });

        dedupedAllContentMerged = fnGetBlocklistFilteredData ? fnGetBlocklistFilteredData({
            dedupedAllContentMerged,
            page
        }) : this._getBlocklistFilteredData({
            dedupedAllContentMerged,
            page
        });

        if (Config.get("import", "isShowVariantsInLists")) {
            Object.entries(dedupedAllContentMerged).forEach(([k,arr])=>{
                if (!(arr instanceof Array))
                    return;
                dedupedAllContentMerged[k] = arr.map(it=>[it, ...DataUtil.proxy.getVersions(it.__prop, it)]).flat();
            }
            );
        }

        Object.entries(dedupedAllContentMerged).forEach(([k,arr])=>{
            if (!(arr instanceof Array))
                return;
            if (!arr.length)
                delete dedupedAllContentMerged[k];
        }
        );

        return {
            dedupedAllContentMerged,
            cacheKeys,
            userData
        };
    }

    static isTooManySources({cntSources}) {
        return Config.get("dataSources", "tooManySourcesWarningThreshold") != null && cntSources >= Config.get("dataSources", "tooManySourcesWarningThreshold");
    }

    static _getBlocklistFilteredData({dedupedAllContentMerged, page}) {
        if (!UrlUtil.URL_TO_HASH_BUILDER[page])
            return dedupedAllContentMerged;
        dedupedAllContentMerged = {
            ...dedupedAllContentMerged
        };
        Object.entries(dedupedAllContentMerged).forEach(([k,arr])=>{
            if (!(arr instanceof Array))
                return;
            dedupedAllContentMerged[k] = arr.filter(it=>{
                if (it.source === VeCt.STR_GENERIC)
                    return false;

                if (!SourceUtil.getEntitySource(it)) {
                    console.warn(`Entity did not have a "source"! This should never occur.`);
                    return true;
                }
                if (!it.__prop) {
                    console.warn(`Entity did not have a "__prop"! This should never occur.`);
                    return true;
                }

                switch (it.__prop) {
                case "item":
                case "baseitem":
                case "itemGroup":
                case "magicvariant":
                case "_specificVariant":
                    {
                        return !Renderer.item.isExcluded(it);
                    }

                case "race":
                    {
                        if (this._isExcludedRaceSubrace(it))
                            return false;
                    }
                }

                return !ExcludeUtil.isExcluded((UrlUtil.URL_TO_HASH_BUILDER[it.__prop] || UrlUtil.URL_TO_HASH_BUILDER[page])(it), it.__prop, SourceUtil.getEntitySource(it), {
                    isNoCount: true
                }, );
            }
            );
        }
        );
        return dedupedAllContentMerged;
    }

    static _isExcludedRaceSubrace(it) {
        if (it.__prop !== "race")
            return false;
        return it._subraceName && ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER["subrace"]({
            name: it._subraceName,
            source: it.source,
            raceName: it._baseName,
            raceSource: it._baseSource
        }), "subrace", SourceUtil.getEntitySource(it), {
            isNoCount: true
        }, );
    }

    static _getDedupedAllContentMerged({allContentMerged, page, isDedupable=false}) {
        if (!isDedupable)
            return allContentMerged;
        return this._getDedupedData({
            allContentMerged,
            page
        });
    }

    static _getDedupedData({allContentMerged, page}) {
        if (!UrlUtil.URL_TO_HASH_BUILDER[page])
            return allContentMerged;

        const contentHashes = new Set();
        Object.entries(allContentMerged).forEach(([k,arr])=>{
            if (!(arr instanceof Array))
                return;
            allContentMerged[k] = arr.filter(it=>{
                const fnGetHash = UrlUtil.URL_TO_HASH_BUILDER[page];
                if (!fnGetHash)
                    return true;
                const hash = fnGetHash(it);
                if (contentHashes.has(hash))
                    return false;
                contentHashes.add(hash);
                return true;
            }
            );
        }
        );

        return allContentMerged;
    }

    static async pPostLoadGeneric({isPrerelease, isBrew}, out) {
        out = {
            ...out
        };

        if ((isBrew || isPrerelease) && (out.race || out.subrace)) {
            const nxt = await Charactermancer_Race_Util.pPostLoadPrereleaseBrew(out);
            Object.assign(out, nxt || {});
        }

        if ((isBrew || isPrerelease) && (out.item || out.baseitem || out.magicvariant || out.itemGroup)) {
            if (isBrew)
                out.item = await Vetools.pGetBrewItems(out);
            else if (isPrerelease)
                out.item = await Vetools.pGetPrereleaseItems(out);

            delete out.baseitem;
            delete out.magicvariant;
            delete out.itemProperty;
            delete out.itemType;
            delete out.itemGroup;
        }

        return out;
    }

    static getSourceFilterTypes(src) {
        return SourceUtil.isPrereleaseSource(src) ? [UtilDataSource.SOURCE_TYP_PRERELEASE] : SourceUtil.isNonstandardSource(src) ? [UtilDataSource.SOURCE_TYP_EXTRAS] : [UtilDataSource.SOURCE_TYP_OFFICIAL_SINGLE];
    }

    static getSourcesCustomUrl(nxtOpts={}) {
        return [new UtilDataSource.DataSourceUrl("Custom URL","",{
            ...nxtOpts,
            filterTypes: [UtilDataSource.SOURCE_TYP_CUSTOM],
            isAutoDetectPrereleaseBrew: true,
        },), ];
    }

    static getSourcesUploadFile(nxtOpts={}) {
        return [new UtilDataSource.DataSourceFile("Upload File",{
            ...nxtOpts,
            filterTypes: [UtilDataSource.SOURCE_TYP_CUSTOM],
            isAutoDetectPrereleaseBrew: true,
        },), ];
    }

    static async pGetSourcesPrerelease(dirsPrerelease, nxtOpts={}) {
        return this._pGetSourcesPrereleaseBrew({
            brewUtil: PrereleaseUtil,
            localSources: await Vetools.pGetLocalPrereleaseSources(...dirsPrerelease),
            sources: await Vetools.pGetPrereleaseSources(...dirsPrerelease),
            filterTypesLocal: [UtilDataSource.SOURCE_TYP_PRERELEASE, UtilDataSource.SOURCE_TYP_PRERELEASE_LOCAL],
            filterTypes: [UtilDataSource.SOURCE_TYP_PRERELEASE],
            nxtOpts,
        });
    }

    static async pGetSourcesBrew(dirsHomebrew, nxtOpts={}) {
        return this._pGetSourcesPrereleaseBrew({
            brewUtil: BrewUtil2,
            localSources: await Vetools.pGetLocalBrewSources(...dirsHomebrew),
            sources: await Vetools.pGetBrewSources(...dirsHomebrew),
            filterTypesLocal: [UtilDataSource.SOURCE_TYP_BREW, UtilDataSource.SOURCE_TYP_BREW_LOCAL],
            filterTypes: [UtilDataSource.SOURCE_TYP_BREW],
            nxtOpts,
        });
    }

    static async _pGetSourcesPrereleaseBrew({localSources, sources, nxtOpts, brewUtil, filterTypesLocal, filterTypes}) {
        return [...localSources.map(({name, url, abbreviations})=>new UtilDataSource.DataSourceUrl(name,url,{
            ...nxtOpts,
            filterTypes: [...filterTypesLocal],
            abbreviations,
            brewUtil,
            isExistingPrereleaseBrew: true,
        },)), ...sources.map(({name, url, abbreviations})=>new UtilDataSource.DataSourceUrl(name,url,{
            ...nxtOpts,
            filterTypes: [...filterTypes],
            abbreviations,
            brewUtil,
        },)), ];
    }

    static getSourceType(json, {isErrorOnMultiple=false}={}) {
        const isPrereleasePerSource = (json._meta?.sources || []).map(it=>SourceUtil.isPrereleaseSource(it.json || ""));
        const isPrerelease = isPrereleasePerSource.every(it=>it);
        const isBrew = isPrereleasePerSource.every(it=>!it);

        if (isPrerelease && isBrew && isErrorOnMultiple)
            throw new Error(`Could not determine if data contained homebrew or if data contained prerelease content! Please ensure all homebrew/prerelease files have a valid "_meta.sources", and that no file contains both homebrew and prerelease sources.`);

        return {
            isPrerelease,
            isBrew
        };
    }
}
UtilDataSource.SOURCE_TYP_OFFICIAL_BASE = "Official";
UtilDataSource.SOURCE_TYP_OFFICIAL_ALL = `${UtilDataSource.SOURCE_TYP_OFFICIAL_BASE} (All)`;
UtilDataSource.SOURCE_TYP_OFFICIAL_SINGLE = `${UtilDataSource.SOURCE_TYP_OFFICIAL_BASE} (Single Source)`;
UtilDataSource.SOURCE_TYP_CUSTOM = "Custom/User";
UtilDataSource.SOURCE_TYP_EXTRAS = "Extras";
UtilDataSource.SOURCE_TYP_PRERELEASE = "Prerelease";
UtilDataSource.SOURCE_TYP_PRERELEASE_LOCAL = "Local Prerelease";
UtilDataSource.SOURCE_TYP_BREW = "Homebrew";
UtilDataSource.SOURCE_TYP_BREW_LOCAL = "Local Homebrew";
UtilDataSource.SOURCE_TYP_UNKNOWN = "Unknown";

UtilDataSource.SOURCE_TYPE_ORDER = [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL, UtilDataSource.SOURCE_TYP_CUSTOM, UtilDataSource.SOURCE_TYP_OFFICIAL_SINGLE, UtilDataSource.SOURCE_TYP_EXTRAS, UtilDataSource.SOURCE_TYP_PRERELEASE_LOCAL, UtilDataSource.SOURCE_TYP_PRERELEASE, UtilDataSource.SOURCE_TYP_BREW_LOCAL, UtilDataSource.SOURCE_TYP_BREW, UtilDataSource.SOURCE_TYP_UNKNOWN, ];

UtilDataSource.SOURCE_TYPE_ORDER__FILTER = [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL, UtilDataSource.SOURCE_TYP_OFFICIAL_SINGLE, UtilDataSource.SOURCE_TYP_EXTRAS, UtilDataSource.SOURCE_TYP_PRERELEASE_LOCAL, UtilDataSource.SOURCE_TYP_PRERELEASE, UtilDataSource.SOURCE_TYP_BREW_LOCAL, UtilDataSource.SOURCE_TYP_BREW, UtilDataSource.SOURCE_TYP_CUSTOM, UtilDataSource.SOURCE_TYP_UNKNOWN, ];

UtilDataSource.DataSourceBase = class {
    constructor(name, opts) {
        this.name = name;

        this._pPostLoad = opts.pPostLoad;
        this._brewUtil = opts.brewUtil;
        this._isAutoDetectPrereleaseBrew = !!opts.isAutoDetectPrereleaseBrew;
        this._isExistingPrereleaseBrew = !!opts.isExistingPrereleaseBrew;
        this.filterTypes = opts.filterTypes || [UtilDataSource.SOURCE_TYP_UNKNOWN];
        this.isDefault = !!opts.isDefault;
        this.abbreviations = opts.abbreviations;
        this.isWorldSelectable = !!opts.isWorldSelectable;
    }

    get identifier() {
        throw new Error(`Unimplemented!`);
    }
    get identifierWorld() {
        return this.isDefault ? "5etools" : this.identifier;
    }

    isCacheable() {
        throw new Error("Unimplemented!");
    }
    async pGetOutputs({uploadedFileMetas, customUrls}) {
        throw new Error("Unimplemented!");
    }

    async _pGetBrewUtil(...args) {
        if (this._brewUtil)
            return this._brewUtil;
        if (!this._isAutoDetectPrereleaseBrew)
            return null;
        return this._pGetBrewUtilAutodetected(...args);
    }

    async _pGetBrewUtilAutodetected(...args) {
        throw new Error("Unimplemented!");
    }

    async pLoadAndAddToAllContent({uploadedFileMetas, customUrls, allContent, cacheKeys=null}) {
        const meta = await this.pGetOutputs({
            uploadedFileMetas,
            customUrls
        });
        allContent.push(...meta.contents);
        if (cacheKeys && this.isCacheable())
            cacheKeys.push(...meta.cacheKeys);
    }
};

UtilDataSource.DataSourceUrl = class extends UtilDataSource.DataSourceBase {
    constructor(name, url, opts) {
        opts = opts || {};

        super(name, {
            isWorldSelectable: !!url,
            ...opts
        });

        this.url = url;
        this.source = opts.source;
        this.userData = opts.userData;
    }

    get identifier() {
        return this.url === "" ? `VE_SOURCE_CUSTOM_URL` : this.url;
    }
    get identifierWorld() {
        return this.source ?? super.identifierWorld;
    }

    isCacheable() {
        return true;
    }

    async pGetOutputs({uploadedFileMetas, customUrls}) {
        if (this.url === "") {
            customUrls = customUrls || [];

            let loadedDatas;
            try {
                loadedDatas = await Promise.all(customUrls.map(async url=>{
                    const brewUtil = await this._pGetBrewUtil(url);
                    if (brewUtil && !this._isExistingPrereleaseBrew)
                        await brewUtil.pAddBrewFromUrl(url);

                    const data = await DataUtil.loadJSON(url);
                    return this._pPostLoad ? this._pPostLoad(data, this.userData) : data;
                }
                ));
            } catch (e) {
                ui.notifications.error(`Failed to load one or more URLs! ${VeCt.STR_SEE_CONSOLE}`);
                throw e;
            }

            return {
                cacheKeys: customUrls,
                contents: loadedDatas,
            };
        }

        let data;
        try {
            const brewUtil = await this._pGetBrewUtil(this.url);
            if (brewUtil && !this._isExistingPrereleaseBrew)
                await brewUtil.pAddBrewFromUrl(this.url);

            data = await DataUtil.loadJSON(this.url);
            if (this._pPostLoad)
                data = await this._pPostLoad(data, this.userData);
        } catch (e) {
            const msg = `Failed to load URL "${this.url}"!`;
            ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
            console.error(msg);
            throw e;
        }
        return {
            cacheKeys: [this.url],
            contents: [data],
        };
    }

    async _pGetBrewUtilAutodetected(url) {
        const json = await DataUtil.loadJSON(url);
        const {isPrerelease, isBrew} = UtilDataSource.getSourceType(json, {
            isErrorOnMultiple: true
        });
        if (isPrerelease)
            return PrereleaseUtil;
        if (isBrew)
            return BrewUtil2;
        return null;
    }
};

UtilDataSource.DataSourceFile = class extends UtilDataSource.DataSourceBase {
    constructor(name, opts) {
        opts = opts || {};

        super(name, {
            isWorldSelectable: false,
            ...opts
        });

        this.isFile = true;
    }

    get identifier() {
        return `VE_SOURCE_CUSTOM_FILE`;
    }

    isCacheable() {
        return false;
    }

    async pGetOutputs({uploadedFileMetas, customUrls}) {
        uploadedFileMetas = uploadedFileMetas || [];

        const allContent = await uploadedFileMetas.pMap(async fileMeta=>{
            if (!fileMeta)
                return null;

            const brewUtil = await this._pGetBrewUtil(fileMeta.contents);
            if (brewUtil && !this._isExistingPrereleaseBrew)
                await brewUtil.pAddBrewsFromFiles([{
                    json: fileMeta.contents,
                    name: fileMeta.name
                }]);

            const contents = await DataUtil.pDoMetaMerge(CryptUtil.uid(), MiscUtil.copyFast(fileMeta.contents));

            return this._pPostLoad ? this._pPostLoad(contents, this.userData) : contents;
        }
        );

        return {
            contents: allContent.filter(it=>it != null),
        };
    }

    async _pGetBrewUtilAutodetected(json) {
        const {isPrerelease, isBrew} = UtilDataSource.getSourceType(json, {
            isErrorOnMultiple: true
        });
        if (isPrerelease)
            return PrereleaseUtil;
        if (isBrew)
            return BrewUtil2;
        return null;
    }
};

UtilDataSource.DataSourceSpecial = class extends UtilDataSource.DataSourceBase {
    constructor(name, pGet, opts) {
        opts = opts || {};

        super(name, { isWorldSelectable: true, ...opts });
        this.special = { pGet };
        if (!opts.cacheKey) { throw new Error(`No cache key specified!`); }
        this.cacheKey = opts.cacheKey;
    }

    get identifier() {
        return this.cacheKey;
    }

    isCacheable() {
        return true;
    }

    async pGetOutputs({uploadedFileMetas, customUrls}) {
        let loadedData;
        try {
            const json = await Vetools.pLoadImporterSourceSpecial(this);
            loadedData = json;
            if (this._pPostLoad)
                loadedData = await this._pPostLoad(loadedData, json, this.userData);
        } catch (e) {
            //ui.notifications
            console.error(`Failed to load pre-defined source "${this.cacheKey}"! ${VeCt.STR_SEE_CONSOLE}`);
            throw e;
        }
        return {
            cacheKeys: [this.cacheKey],
            contents: [loadedData],
        };
    }

    async _pGetBrewUtilAutodetected() {
        throw new Error("Unimplemented!");
    }
};

//#endregion

//#endregion

//#endregion

//#region CHARACTERMANCER BASE ELEMENTS
class SideDataInterfaceBase {
    static _SIDE_DATA = null;

    static async pPreloadSideData() {
        this._SIDE_DATA = await this._pGetPreloadSideData();
        return this._SIDE_DATA;
    }

    static async _pGetPreloadSideData() {
        throw new Error("Unimplemented!");
    }

    static init() {}

    static _getSideLoadOpts(ent) {
        return null;
    }

    static _SIDE_LOAD_OPTS = null;

    static _getResolvedOpts({ent, propOpts="_SIDE_LOAD_OPTS"}={}) {
        const out = this._getSideLoadOpts(ent) || this[propOpts];
        if (out.propsMatch)
            return out;
        return {
            ...out,
            propsMatch: ["source", "name"],
        };
    }

    static async pGetRoot(ent, {propOpts="_SIDE_LOAD_OPTS", actorType=undefined}={}) {
        const opts = this._getResolvedOpts({
            ent,
            propOpts
        });
        if (!opts)
            return null;

        const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
        return this._pGetStarSideLoaded(ent, {
            propBrew,
            fnLoadJson,
            propJson,
            propsMatch,
            propFromEntity: "foundryRoot",
            propFromSideLoaded: "root",
            actorType
        });
    }

    static async pGetDataSideLoaded(ent, {propOpts="_SIDE_LOAD_OPTS", systemBase=undefined, actorType=undefined}={}) {
        const opts = this._getResolvedOpts({
            ent,
            propOpts
        });
        if (!opts)
            return null;

        const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
        return this._pGetStarSideLoaded(ent, {
            propBrew,
            fnLoadJson,
            propJson,
            propsMatch,
            propFromEntity: "foundrySystem",
            propFromSideLoaded: "system",
            base: systemBase,
            actorType
        });
    }

    static async pGetFlagsSideLoaded(ent, {propOpts="_SIDE_LOAD_OPTS", actorType=undefined}={}) {
        const opts = this._getResolvedOpts({
            ent,
            propOpts
        });
        if (!opts)
            return null;

        const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
        return this._pGetStarSideLoaded(ent, {
            propBrew,
            fnLoadJson,
            propJson,
            propsMatch,
            propFromEntity: "foundryFlags",
            propFromSideLoaded: "flags",
            actorType
        });
    }

    static async _pGetAdvancementSideLoaded(ent, {propOpts="_SIDE_LOAD_OPTS", actorType=undefined}={}) {
        const opts = this._getResolvedOpts({
            ent,
            propOpts
        });
        if (!opts)
            return null;

        const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
        return this._pGetStarSideLoaded(ent, {
            propBrew,
            fnLoadJson,
            propJson,
            propsMatch,
            propFromEntity: "foundryAdvancement",
            propFromSideLoaded: "advancement",
            actorType
        });
    }

    static async pGetImgSideLoaded(ent, {propOpts="_SIDE_LOAD_OPTS", actorType=undefined}={}) {
        const opts = this._getResolvedOpts({
            ent,
            propOpts
        });
        if (!opts)
            return null;

        const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
        return this._pGetStarSideLoaded(ent, {
            propBrew,
            fnLoadJson,
            propJson,
            propsMatch,
            propFromEntity: "foundryImg",
            propFromSideLoaded: "img",
            actorType
        });
    }

    static async pGetIsIgnoredSideLoaded(ent, {propOpts="_SIDE_LOAD_OPTS", actorType=undefined}={}) {
        const opts = this._getResolvedOpts({
            ent,
            propOpts
        });
        if (!opts)
            return null;

        const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
        return this._pGetStarSideLoaded(ent, {
            propBrew,
            fnLoadJson,
            propJson,
            propsMatch,
            propFromEntity: "foundryIsIgnored",
            propFromSideLoaded: "isIgnored",
            actorType
        });
    }

    static async pIsIgnoreSrdEffectsSideLoaded(ent, {propOpts="_SIDE_LOAD_OPTS", actorType=undefined}={}) {
        const opts = this._getResolvedOpts({
            ent,
            propOpts
        });
        if (!opts)
            return null;
        return this._pGetStarSideLoaded(ent, {
            ...opts,
            propFromEntity: "foundryIgnoreSrdEffects",
            propFromSideLoaded: "ignoreSrdEffects",
            actorType
        });
    }

    static async pGetEffectsRawSideLoaded(ent, {propOpts="_SIDE_LOAD_OPTS", actorType=undefined}={}) {
        const opts = this._getResolvedOpts({
            ent,
            propOpts
        });
        if (!opts)
            return null;

        const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
        const out = await this._pGetStarSideLoaded(ent, {
            propBrew,
            fnLoadJson,
            propJson,
            propsMatch,
            propFromEntity: "foundryEffects",
            propFromSideLoaded: "effects",
            actorType
        });

        if (!out?.length)
            return out;

        return out.filter(it=>{
            if (!it)
                return false;
            if (!it.requires)
                return true;

            return Object.keys(it.requires).every(k=>UtilCompat.isModuleActive(k));
        }
        );
    }

    static async pGetEffectsSideLoadedTuples({ent, actor=null, sheetItem=null, additionalData=null, img=null}, {propOpts="_SIDE_LOAD_OPTS"}={}) {
        const outRaw = await this.pGetEffectsRawSideLoaded(ent, {
            propOpts
        });
        if (!outRaw?.length)
            return [];

        return UtilActiveEffects.getExpandedEffects(outRaw, {
            actor,
            sheetItem,
            parentName: UtilEntityGeneric.getName(ent),
            img,
        }, {
            isTuples: true,
        }, );
    }

    static async pGetSideLoaded(ent, {propOpts="_SIDE_LOAD_OPTS", actorType=undefined, isSilent=false}={}) {
        const opts = this._getResolvedOpts({
            ent,
            propOpts
        });
        if (!opts)
            return null;
        return this._pGetSideLoadedMatch(ent, {
            ...opts,
            actorType,
            isSilent
        });
    }

    static async pGetSideLoadedType(ent, {propOpts="_SIDE_LOAD_OPTS", validTypes, actorType=undefined}={}) {
        const opts = this._getResolvedOpts({
            ent,
            propOpts
        });
        if (!opts)
            return null;

        const {propBrew, fnLoadJson, propJson, propsMatch} = opts;

        let out = await this._pGetStarSideLoaded(ent, {
            propBrew,
            fnLoadJson,
            propJson,
            propsMatch,
            propFromEntity: "foundryType",
            propFromSideLoaded: "type",
            actorType
        });
        if (!out)
            return out;
        out = out.toLowerCase().trim();
        if (validTypes && !validTypes.has(out))
            return null;
        return out;
    }

    static async _pGetStarSideLoaded(ent, {propBrew, fnLoadJson, propJson, propsMatch, propFromEntity, propFromSideLoaded, base=undefined, actorType=undefined, }, ) {
        const found = await this._pGetSideLoadedMatch(ent, {
            propBrew,
            fnLoadJson,
            propJson,
            propsMatch,
            propBase: propFromSideLoaded,
            base,
            actorType
        });
        return this._pGetStarSideLoaded_found(ent, {
            propFromEntity,
            propFromSideLoaded,
            found
        });
    }

    static async _pGetStarSideLoaded_found(ent, {propFromEntity, propFromSideLoaded, found}) {
        const fromEntity = ent[propFromEntity];

        if ((!found || !found[propFromSideLoaded]) && !fromEntity)
            return null;

        const out = MiscUtil.copy(found?.[propFromSideLoaded] ? found[propFromSideLoaded] : fromEntity);
        if (found?.[propFromSideLoaded] && fromEntity) {
            if (out instanceof Array)
                out.push(...MiscUtil.copy(fromEntity));
            else
                Object.assign(out, MiscUtil.copy(fromEntity));
        }

        return out;
    }

    static async _pGetSideLoadedMatch(ent, {propBrew, fnLoadJson, propJson, propsMatch, propBase, base=undefined, actorType=undefined, isSilent=false}={}) {
        const founds = [];

        if (UtilCompat.isPlutoniumAddonAutomationActive()) {
            const valsLookup = propsMatch.map(prop=>ent[prop]).filter(Boolean);
            const found = await UtilCompat.getApi(UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION).pGetExpandedAddonData({
                propJson,
                path: valsLookup,
                fnMatch: this._pGetAdditional_fnMatch.bind(this, propsMatch, ent),
                ent,
                propBase,
                base,
                actorType,
                isSilent,
            });
            if (found)
                founds.push(found);
        }

        if (propBrew) {
            const prerelease = await PrereleaseUtil.pGetBrewProcessed();
            const foundPrerelease = (MiscUtil.get(prerelease, propBrew) || []).find(it=>this._pGetAdditional_fnMatch(propsMatch, ent, it));
            if (foundPrerelease)
                founds.push(foundPrerelease);

            const brew = await BrewUtil2.pGetBrewProcessed();
            const foundBrew = (MiscUtil.get(brew, propBrew) || []).find(it=>this._pGetAdditional_fnMatch(propsMatch, ent, it));
            if (foundBrew)
                founds.push(foundBrew);
        }

        if (fnLoadJson && propJson) {
            const sideJson = await fnLoadJson();
            const found = (sideJson[propJson] || []).find(it=>this._pGetAdditional_fnMatch(propsMatch, ent, it));
            if (found)
                founds.push(found);
        }

        if (!founds.length)
            return null;
        if (founds.length === 1)
            return founds[0];

        const out = MiscUtil.copy(founds[0]);
        this._pGetSideLoaded_match_mutMigrateData(out);
        delete out._merge;

        founds.slice(1).forEach((found,i)=>{
            this._pGetSideLoaded_match_mutMigrateData(found);

            Object.entries(found).filter(([prop])=>prop !== "_merge").forEach(([prop,v])=>{
                if (out[prop] === undefined)
                    return out[prop] = v;

                const prevFounds = founds.slice(0, i + 1);
                if (!prevFounds.every(foundPrev=>foundPrev[prop] === undefined || foundPrev._merge?.[prop]))
                    return;

                if (out[prop] == null)
                    return out[prop] = v;
                if (typeof out[prop] !== "object")
                    return out[prop] = v;

                if (out[prop]instanceof Array) {
                    if (!(v instanceof Array))
                        throw new Error(`Could not _merge array and non-array`);
                    return out[prop] = [...out[prop], ...v];
                }

                out[prop] = foundry.utils.mergeObject(v, out[prop]);
            }
            );
        }
        );

        return out;
    }

    static _pGetSideLoaded_match_mutMigrateData(found) {
        if (!found)
            return;
        return found;
    }

    static _pGetAdditional_fnMatch(propsMatch, entity, additionalDataEntity) {
        return propsMatch.every(prop=>{
            if (typeof entity[prop] === "number" || typeof additionalDataEntity[prop] === "number")
                return Number(entity[prop]) === Number(additionalDataEntity[prop]);
            return `${(entity[prop] || "")}`.toLowerCase() === `${(additionalDataEntity[prop] || "").toLowerCase()}`;
        }
        );
    }
}

class SideDataInterfaceClass extends SideDataInterfaceBase {
    static _SIDE_LOAD_OPTS = {
        propBrew: "foundryClass",
        fnLoadJson: async()=>this.pPreloadSideData(),
        propJson: "class",
    };

    static _SIDE_LOAD_OPTS_SUBCLASS = {
        propBrew: "foundrySubclass",
        fnLoadJson: async()=>this.pPreloadSideData(),
        propJson: "subclass",
        propsMatch: ["classSource", "className", "source", "name"],
    };

    static async pPreloadSideData() {
        return Vetools.pGetClassSubclassSideData();
    }

    static init() {
        PageFilterClassesFoundry.setImplSideData("class", this);
        PageFilterClassesFoundry.setImplSideData("subclass", this);
    }
}
//#region List
class ListItem {
    constructor(ix, ele, name, values, data) {
        this.ix = ix;
        this.ele = ele;
        this.name = name;
        this.values = values || {};
        this.data = data || {};

        this.searchText = null;
        this.mutRegenSearchText();

        this._isSelected = false;
    }

    mutRegenSearchText() {
        let searchText = `${this.name} - `;
        for (const k in this.values) {
            const v = this.values[k];
            if (!v)
                continue;
            searchText += `${v} - `;
        }
        this.searchText = searchText.toAscii().toLowerCase();
    }

    set isSelected(val) {
        if (this._isSelected === val)
            return;
        this._isSelected = val;

        if (this.ele instanceof $) {
            if (this._isSelected)
                this.ele.addClass("list-multi-selected");
            else
                this.ele.removeClass("list-multi-selected");
        } else {
            if (this._isSelected)
                this.ele.classList.add("list-multi-selected");
            else
                this.ele.classList.remove("list-multi-selected");
        }
    }

    get isSelected() {
        return this._isSelected;
    }
}

class _ListSearch {
    #isInterrupted = false;

    #term = null;
    #fn = null;
    #items = null;

    constructor({term, fn, items}) {
        this.#term = term;
        this.#fn = fn;
        this.#items = [...items];
    }

    interrupt() {
        this.#isInterrupted = true;
    }

    async pRun() {
        const out = [];
        for (const item of this.#items) {
            if (this.#isInterrupted)
                break;
            if (await this.#fn(item, this.#term))
                out.push(item);
        }
        return {
            isInterrupted: this.#isInterrupted,
            searchedItems: out
        };
    }
}

class List {
    #activeSearch = null;

    constructor(opts) {
        if (opts.fnSearch && opts.isFuzzy)
            throw new Error(`The options "fnSearch" and "isFuzzy" are mutually incompatible!`);

        this._$iptSearch = opts.$iptSearch;
        this._$wrpList = opts.$wrpList;
        this._fnSort = opts.fnSort === undefined ? SortUtil.listSort : opts.fnSort;
        this._fnSearch = opts.fnSearch;
        this._syntax = opts.syntax;
        this._isFuzzy = !!opts.isFuzzy;
        this._isSkipSearchKeybindingEnter = !!opts.isSkipSearchKeybindingEnter;
        this._helpText = opts.helpText;

        this._items = [];
        this._eventHandlers = {};

        this._searchTerm = List._DEFAULTS.searchTerm;
        this._sortBy = opts.sortByInitial || List._DEFAULTS.sortBy;
        this._sortDir = opts.sortDirInitial || List._DEFAULTS.sortDir;
        this._sortByInitial = this._sortBy;
        this._sortDirInitial = this._sortDir;
        this._fnFilter = null;
        this._isUseJquery = opts.isUseJquery;

        if (this._isFuzzy)
            this._initFuzzySearch();

        this._searchedItems = [];
        this._filteredItems = [];
        this._sortedItems = [];

        this._isInit = false;
        this._isDirty = false;

        this._prevList = null;
        this._nextList = null;
        this._lastSelection = null;
        this._isMultiSelection = false;
    }

    get items() {
        return this._items;
    }
    get visibleItems() {
        return this._sortedItems;
    }
    get sortBy() {
        return this._sortBy;
    }
    get sortDir() {
        return this._sortDir;
    }
    set nextList(list) {
        this._nextList = list;
    }
    set prevList(list) {
        this._prevList = list;
    }

    setFnSearch(fn) {
        this._fnSearch = fn;
        this._isDirty = true;
    }

    init() {
        if (this._isInit){return;}

        if (this._$iptSearch) {
            UiUtil.bindTypingEnd({
                $ipt: this._$iptSearch,
                fnKeyup: ()=>this.search(this._$iptSearch.val())
            });
            this._searchTerm = List.getCleanSearchTerm(this._$iptSearch.val());
            this._init_bindKeydowns();

            const helpText = [...(this._helpText || []), ...Object.values(this._syntax || {}).filter(({help})=>help).map(({help})=>help), ];

            if (helpText.length)
                this._$iptSearch.title(helpText.join(" "));
        }

        this._doSearch();
        this._isInit = true;
    }

    _init_bindKeydowns() {
        this._$iptSearch.on("keydown", evt=>{
            if (evt._List__isHandled)
                return;

            switch (evt.key) {
            case "Escape":
                return this._handleKeydown_escape(evt);
            case "Enter":
                return this._handleKeydown_enter(evt);
            }
        }
        );
    }

    _handleKeydown_escape(evt) {
        evt._List__isHandled = true;

        if (!this._$iptSearch.val()) {
            $(document.activeElement).blur();
            return;
        }

        this._$iptSearch.val("");
        this.search("");
    }

    _handleKeydown_enter(evt) {
        if (this._isSkipSearchKeybindingEnter)
            return;

        if (IS_VTT)
            return;
        if (!EventUtil.noModifierKeys(evt))
            return;

        const firstVisibleItem = this.visibleItems[0];
        if (!firstVisibleItem)
            return;

        evt._List__isHandled = true;

        $(firstVisibleItem.ele).click();
        if (firstVisibleItem.values.hash)
            window.location.hash = firstVisibleItem.values.hash;
    }

    _initFuzzySearch() {
        elasticlunr.clearStopWords();
        this._fuzzySearch = elasticlunr(function() {
            this.addField("s");
            this.setRef("ix");
        });
        SearchUtil.removeStemmer(this._fuzzySearch);
    }

    update({isForce=false}={}) {
        if (!this._isInit || !this._isDirty || isForce)
            return false;
        this._doSearch();
        return true;
    }

    _doSearch() {
        this._doSearch_doInterruptExistingSearch();
        this._doSearch_doSearchTerm();
        this._doSearch_doPostSearchTerm();
    }

    _doSearch_doInterruptExistingSearch() {
        if (!this.#activeSearch)
            return;
        this.#activeSearch.interrupt();
        this.#activeSearch = null;
    }

    _doSearch_doSearchTerm() {
        if (this._doSearch_doSearchTerm_preSyntax())
            return;

        const matchingSyntax = this._doSearch_getMatchingSyntax();
        if (matchingSyntax) {
            if (this._doSearch_doSearchTerm_syntax(matchingSyntax))
                return;

            this._searchedItems = [];
            this._doSearch_doSearchTerm_pSyntax(matchingSyntax).then(isContinue=>{
                if (!isContinue)
                    return;
                this._doSearch_doPostSearchTerm();
            }
            );

            return;
        }

        if (this._isFuzzy)
            return this._searchedItems = this._doSearch_doSearchTerm_fuzzy();

        if (this._fnSearch)
            return this._searchedItems = this._items.filter(it=>this._fnSearch(it, this._searchTerm));

        this._searchedItems = this._items.filter(it=>this.constructor.isVisibleDefaultSearch(it, this._searchTerm));
    }

    _doSearch_doSearchTerm_preSyntax() {
        if (!this._searchTerm && !this._fnSearch) {
            this._searchedItems = [...this._items];
            return true;
        }
    }

    _doSearch_getMatchingSyntax() {
        const [command,term] = this._searchTerm.split(/^([a-z]+):/).filter(Boolean);
        if (!command || !term || !this._syntax?.[command])
            return null;
        return {
            term: this._doSearch_getSyntaxSearchTerm(term),
            syntax: this._syntax[command]
        };
    }

    _doSearch_getSyntaxSearchTerm(term) {
        if (!term.startsWith("/") || !term.endsWith("/"))
            return term;
        try {
            return new RegExp(term.slice(1, -1));
        } catch (ignored) {
            return term;
        }
    }

    _doSearch_doSearchTerm_syntax({term, syntax: {fn, isAsync}}) {
        if (isAsync)
            return false;

        this._searchedItems = this._items.filter(it=>fn(it, term));
        return true;
    }

    async _doSearch_doSearchTerm_pSyntax({term, syntax: {fn, isAsync}}) {
        if (!isAsync)
            return false;

        this.#activeSearch = new _ListSearch({
            term,
            fn,
            items: this._items,
        });
        const {isInterrupted, searchedItems} = await this.#activeSearch.pRun();

        if (isInterrupted)
            return false;
        this._searchedItems = searchedItems;
        return true;
    }

    static isVisibleDefaultSearch(li, searchTerm) {
        return li.searchText.includes(searchTerm);
    }

    _doSearch_doSearchTerm_fuzzy() {
        const results = this._fuzzySearch.search(this._searchTerm, {
            fields: {
                s: {
                    expand: true
                },
            },
            bool: "AND",
            expand: true,
        }, );

        return results.map(res=>this._items[res.doc.ix]);
    }

    _doSearch_doPostSearchTerm() {
        this._searchedItems = this._searchedItems.filter(it=>!it.data.isExcluded);

        this._doFilter();
    }

    getFilteredItems({items=null, fnFilter}={}) {
        items = items || this._searchedItems;
        fnFilter = fnFilter || this._fnFilter;

        if (!fnFilter)
            return items;

        return items.filter(it=>fnFilter(it));
    }

    _doFilter() {
        this._filteredItems = this.getFilteredItems();
        this._doSort();
    }

    getSortedItems({items=null}={}) {
        items = items || [...this._filteredItems];

        const opts = {
            sortBy: this._sortBy,
            sortDir: this._sortDir,
        };
        if (this._fnSort)
            items.sort((a,b)=>this._fnSort(a, b, opts));
        if (this._sortDir === "desc")
            items.reverse();

        return items;
    }

    _doSort() {
        this._sortedItems = this.getSortedItems();
        this._doRender();
    }

    _doRender() {
        const len = this._sortedItems.length;

        if (this._isUseJquery) {
            this._$wrpList.children().detach();
            for (let i = 0; i < len; ++i)
                this._$wrpList.append(this._sortedItems[i].ele);
        } else {
            this._$wrpList[0].innerHTML = "";
            const frag = document.createDocumentFragment();
            for (let i = 0; i < len; ++i)
                frag.appendChild(this._sortedItems[i].ele);
            this._$wrpList[0].appendChild(frag);
        }

        this._isDirty = false;
        this._trigger("updated");
    }

    search(searchTerm) {
        const nextTerm = List.getCleanSearchTerm(searchTerm);
        if (nextTerm === this._searchTerm)
            return;
        this._searchTerm = nextTerm;
        return this._doSearch();
    }

    filter(fnFilter) {
        if (this._fnFilter === fnFilter)
            return;
        this._fnFilter = fnFilter;
        this._doFilter();
    }

    sort(sortBy, sortDir) {
        if (this._sortBy !== sortBy || this._sortDir !== sortDir) {
            this._sortBy = sortBy;
            this._sortDir = sortDir;
            this._doSort();
        }
    }

    reset() {
        if (this._searchTerm !== List._DEFAULTS.searchTerm) {
            this._searchTerm = List._DEFAULTS.searchTerm;
            return this._doSearch();
        } else if (this._sortBy !== this._sortByInitial || this._sortDir !== this._sortDirInitial) {
            this._sortBy = this._sortByInitial;
            this._sortDir = this._sortDirInitial;
        }
    }

    addItem(listItem) {
        this._isDirty = true;
        this._items.push(listItem);

        if (this._isFuzzy)
            this._fuzzySearch.addDoc({
                ix: listItem.ix,
                s: listItem.searchText
            });
    }

    removeItem(listItem) {
        const ixItem = this._items.indexOf(listItem);
        return this.removeItemByIndex(listItem.ix, ixItem);
    }

    removeItemByIndex(ix, ixItem) {
        ixItem = ixItem ?? this._items.findIndex(it=>it.ix === ix);
        if (!~ixItem)
            return;

        this._isDirty = true;
        const removed = this._items.splice(ixItem, 1);

        if (this._isFuzzy)
            this._fuzzySearch.removeDocByRef(ix);

        return removed[0];
    }

    removeItemBy(valueName, value) {
        const ixItem = this._items.findIndex(it=>it.values[valueName] === value);
        return this.removeItemByIndex(ixItem, ixItem);
    }

    removeItemByData(dataName, value) {
        const ixItem = this._items.findIndex(it=>it.data[dataName] === value);
        return this.removeItemByIndex(ixItem, ixItem);
    }

    removeAllItems() {
        this._isDirty = true;
        this._items = [];
        if (this._isFuzzy)
            this._initFuzzySearch();
    }

    on(eventName, handler) {
        (this._eventHandlers[eventName] = this._eventHandlers[eventName] || []).push(handler);
    }

    off(eventName, handler) {
        if (!this._eventHandlers[eventName])
            return false;
        const ix = this._eventHandlers[eventName].indexOf(handler);
        if (!~ix)
            return false;
        this._eventHandlers[eventName].splice(ix, 1);
        return true;
    }

    _trigger(eventName) {
        (this._eventHandlers[eventName] || []).forEach(fn=>fn());
    }

    doAbsorbItems(dataArr, opts) {
        const children = [...this._$wrpList[0].children];

        const len = children.length;
        if (len !== dataArr.length)
            throw new Error(`Data source length and list element length did not match!`);

        for (let i = 0; i < len; ++i) {
            const node = children[i];
            const dataItem = dataArr[i];
            const listItem = new ListItem(i,node,opts.fnGetName(dataItem),opts.fnGetValues ? opts.fnGetValues(dataItem) : {},{},);
            if (opts.fnGetData)
                listItem.data = opts.fnGetData(listItem, dataItem);
            if (opts.fnBindListeners)
                opts.fnBindListeners(listItem, dataItem);
            this.addItem(listItem);
        }
    }

    doSelect(item, evt) {
        if (evt && evt.shiftKey) {
            evt.preventDefault();
            if (this._prevList && this._prevList._lastSelection) {
                this._prevList._selectFromItemToEnd(this._prevList._lastSelection, true);
                this._selectToItemFromStart(item);
            } else if (this._nextList && this._nextList._lastSelection) {
                this._nextList._selectToItemFromStart(this._nextList._lastSelection, true);
                this._selectFromItemToEnd(item);
            } else if (this._lastSelection && this.visibleItems.includes(item)) {
                this._doSelect_doMulti(item);
            } else {
                this._doSelect_doSingle(item);
            }
        } else
            this._doSelect_doSingle(item);
    }

    _doSelect_doSingle(item) {
        if (this._isMultiSelection) {
            this.deselectAll();
            if (this._prevList)
                this._prevList.deselectAll();
            if (this._nextList)
                this._nextList.deselectAll();
        } else if (this._lastSelection)
            this._lastSelection.isSelected = false;

        item.isSelected = true;
        this._lastSelection = item;
    }

    _doSelect_doMulti(item) {
        this._selectFromItemToItem(this._lastSelection, item);

        if (this._prevList && this._prevList._isMultiSelection) {
            this._prevList.deselectAll();
        }

        if (this._nextList && this._nextList._isMultiSelection) {
            this._nextList.deselectAll();
        }
    }

    _selectFromItemToEnd(item, isKeepLastSelection=false) {
        this.deselectAll(isKeepLastSelection);
        this._isMultiSelection = true;
        const ixStart = this.visibleItems.indexOf(item);
        const len = this.visibleItems.length;
        for (let i = ixStart; i < len; ++i) {
            this.visibleItems[i].isSelected = true;
        }
    }

    _selectToItemFromStart(item, isKeepLastSelection=false) {
        this.deselectAll(isKeepLastSelection);
        this._isMultiSelection = true;
        const ixEnd = this.visibleItems.indexOf(item);
        for (let i = 0; i <= ixEnd; ++i) {
            this.visibleItems[i].isSelected = true;
        }
    }

    _selectFromItemToItem(item1, item2) {
        this.deselectAll(true);

        if (item1 === item2) {
            if (this._lastSelection)
                this._lastSelection.isSelected = false;
            item1.isSelected = true;
            this._lastSelection = item1;
            return;
        }

        const ix1 = this.visibleItems.indexOf(item1);
        const ix2 = this.visibleItems.indexOf(item2);

        this._isMultiSelection = true;
        const [ixStart,ixEnd] = [ix1, ix2].sort(SortUtil.ascSort);
        for (let i = ixStart; i <= ixEnd; ++i) {
            this.visibleItems[i].isSelected = true;
        }
    }

    deselectAll(isKeepLastSelection=false) {
        if (!isKeepLastSelection)
            this._lastSelection = null;
        this._isMultiSelection = false;
        this._items.forEach(it=>it.isSelected = false);
    }

    updateSelected(item) {
        if (this.visibleItems.includes(item)) {
            if (this._isMultiSelection)
                this.deselectAll(true);

            if (this._lastSelection && this._lastSelection !== item)
                this._lastSelection.isSelected = false;

            item.isSelected = true;
            this._lastSelection = item;
        } else
            this.deselectAll();
    }

    getSelected() {
        return this.visibleItems.filter(it=>it.isSelected);
    }

    static getCleanSearchTerm(str) {
        return (str || "").toAscii().trim().toLowerCase().split(/\s+/g).join(" ");
    }
}
;
List._DEFAULTS = {
    searchTerm: "",
    sortBy: "name",
    sortDir: "asc",
    fnFilter: null,
};
//#endregion


//#endregion

//#region EXTENSION FUNCTIONS

//#region Jquery Extensions
globalThis.JqueryUtil = {
    _isEnhancementsInit: false,
    initEnhancements() {
        if (JqueryUtil._isEnhancementsInit)
            return;
        JqueryUtil._isEnhancementsInit = true;

        JqueryUtil.addSelectors();

        window.$$ = function(parts, ...args) {
            if (parts instanceof jQuery || parts instanceof HTMLElement) {
                return (...passed)=>{
                    const parts2 = [...passed[0]];
                    const args2 = passed.slice(1);
                    parts2[0] = `<div>${parts2[0]}`;
                    parts2.last(`${parts2.last()}</div>`);

                    const $temp = $$(parts2, ...args2);
                    $temp.children().each((i,e)=>$(e).appendTo(parts));
                    return parts;
                }
                ;
            } else {
                const $eles = [];
                let ixArg = 0;

                const handleArg = (arg)=>{
                    if (arg instanceof $) {
                        $eles.push(arg);
                        return `<${arg.tag()} data-r="true"></${arg.tag()}>`;
                    } else if (arg instanceof HTMLElement) {
                        return handleArg($(arg));
                    } else
                        return arg;
                }
                ;
                const raw = parts.reduce((html,p)=>{
                    const myIxArg = ixArg++;
                    if (args[myIxArg] == null)
                        return `${html}${p}`;
                    if (args[myIxArg]instanceof Array)
                        return `${html}${args[myIxArg].map(arg=>handleArg(arg)).join("")}${p}`;
                    else
                        return `${html}${handleArg(args[myIxArg])}${p}`;
                }
                );
                const $res = $(raw);

                if ($res.length === 1) {
                    if ($res.attr("data-r") === "true")
                        return $eles[0];
                    else
                        $res.find(`[data-r=true]`).replaceWith(i=>$eles[i]);
                } else {
                    const $tmp = $(`<div></div>`);
                    $tmp.append($res);
                    $tmp.find(`[data-r=true]`).replaceWith(i=>$eles[i]);
                    return $tmp.children();
                }

                return $res;
            }
        }
        ;

        $.fn.extend({
            disableSpellcheck: function() {
                return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");
            },
            tag: function() {
                return this.prop("tagName").toLowerCase();
            },
            title: function(...args) {
                return this.attr("title", ...args);
            },
            placeholder: function(...args) {
                return this.attr("placeholder", ...args);
            },
            disable: function() {
                return this.attr("disabled", true);
            },

            fastSetHtml: function(html) {
                if (!this.length)
                    return this;
                let tgt = this[0];
                while (tgt.children.length) {
                    tgt = tgt.children[0];
                }
                tgt.innerHTML = html;
                return this;
            },

            blurOnEsc: function() {
                return this.keydown(evt=>{
                    if (evt.which === 27)
                        this.blur();
                }
                );
            },

            hideVe: function() {
                return this.addClass("ve-hidden");
            },
            showVe: function() {
                return this.removeClass("ve-hidden");
            },
            toggleVe: function(val) {
                if (val === undefined)
                    return this.toggleClass("ve-hidden", !this.hasClass("ve-hidden"));
                else
                    return this.toggleClass("ve-hidden", !val);
            },
        });

        $.event.special.destroyed = {
            remove: function(o) {
                if (o.handler)
                    o.handler();
            },
        };
    },

    addSelectors() {
        $.expr[":"].textEquals = (el,i,m)=>$(el).text().toLowerCase().trim() === m[3].unescapeQuotes();

        $.expr[":"].containsInsensitive = (el,i,m)=>{
            const searchText = m[3];
            const textNode = $(el).contents().filter((i,e)=>e.nodeType === 3)[0];
            if (!textNode)
                return false;
            const match = textNode.nodeValue.toLowerCase().trim().match(`${searchText.toLowerCase().trim().escapeRegexp()}`);
            return match && match.length > 0;
        }
        ;
    },

    showCopiedEffect(eleOr$Ele, text="Copied!", bubble) {
        const $ele = eleOr$Ele instanceof $ ? eleOr$Ele : $(eleOr$Ele);

        const top = $(window).scrollTop();
        const pos = $ele.offset();

        const animationOptions = {
            top: "-=8",
            opacity: 0,
        };
        if (bubble) {
            animationOptions.left = `${Math.random() > 0.5 ? "-" : "+"}=${~~(Math.random() * 17)}`;
        }
        const seed = Math.random();
        const duration = bubble ? 250 + seed * 200 : 250;
        const offsetY = bubble ? 16 : 0;

        const $dispCopied = $(`<div class="clp__disp-copied ve-flex-vh-center py-2 px-4"></div>`);
        $dispCopied.html(text).css({
            top: (pos.top - 24) + offsetY - top,
            left: pos.left + ($ele.width() / 2),
        }).appendTo(document.body).animate(animationOptions, {
            duration,
            complete: ()=>$dispCopied.remove(),
            progress: (_,progress)=>{
                if (bubble) {
                    const diffProgress = 0.5 - progress;
                    animationOptions.top = `${diffProgress > 0 ? "-" : "+"}=40`;
                    $dispCopied.css("transform", `rotate(${seed > 0.5 ? "-" : ""}${seed * 500 * progress}deg)`);
                }
            }
            ,
        }, );
    },

    _dropdownInit: false,
    bindDropdownButton($ele) {
        if (!JqueryUtil._dropdownInit) {
            JqueryUtil._dropdownInit = true;
            document.addEventListener("click", ()=>[...document.querySelectorAll(`.open`)].filter(ele=>!(ele.className || "").split(" ").includes(`dropdown--navbar`)).forEach(ele=>ele.classList.remove("open")));
        }
        $ele.click(()=>setTimeout(()=>$ele.parent().addClass("open"), 1));
    },

    _WRP_TOAST: null,
    _ACTIVE_TOAST: [],
    doToast(options) {
        if (typeof window === "undefined")
            return;

        if (JqueryUtil._WRP_TOAST == null) {
            JqueryUtil._WRP_TOAST = e_({
                tag: "div",
                clazz: "toast__container no-events w-100 overflow-y-hidden ve-flex-col",
            });
            document.body.appendChild(JqueryUtil._WRP_TOAST);
        }

        if (typeof options === "string") {
            options = {
                content: options,
                type: "info",
            };
        }
        options.type = options.type || "info";

        options.isAutoHide = options.isAutoHide ?? true;
        options.autoHideTime = options.autoHideTime ?? 5000;

        const eleToast = e_({
            tag: "div",
            clazz: `toast toast--type-${options.type} events-initial relative my-2 mx-auto`,
            children: [e_({
                tag: "div",
                clazz: "toast__wrp-content",
                children: [options.content instanceof $ ? options.content[0] : options.content, ],
            }), e_({
                tag: "div",
                clazz: "toast__wrp-control",
                children: [e_({
                    tag: "button",
                    clazz: "btn toast__btn-close",
                    children: [e_({
                        tag: "span",
                        clazz: "glyphicon glyphicon-remove",
                    }), ],
                }), ],
            }), ],
            mousedown: evt=>{
                evt.preventDefault();
            }
            ,
            click: evt=>{
                evt.preventDefault();
                JqueryUtil._doToastCleanup(toastMeta);

                if (!evt.shiftKey)
                    return;
                [...JqueryUtil._ACTIVE_TOAST].forEach(toastMeta=>JqueryUtil._doToastCleanup(toastMeta));
            }
            ,
        });

        eleToast.prependTo(JqueryUtil._WRP_TOAST);

        const toastMeta = {
            isAutoHide: !!options.isAutoHide,
            eleToast
        };
        JqueryUtil._ACTIVE_TOAST.push(toastMeta);

        AnimationUtil.pRecomputeStyles().then(()=>{
            eleToast.addClass(`toast--animate`);

            if (options.isAutoHide) {
                setTimeout(()=>{
                    JqueryUtil._doToastCleanup(toastMeta);
                }
                , options.autoHideTime);
            }

            if (JqueryUtil._ACTIVE_TOAST.length >= 3) {
                JqueryUtil._ACTIVE_TOAST.filter(({isAutoHide})=>!isAutoHide).forEach(toastMeta=>{
                    JqueryUtil._doToastCleanup(toastMeta);
                }
                );
            }
        }
        );
    },

    _doToastCleanup(toastMeta) {
        toastMeta.eleToast.removeClass("toast--animate");
        JqueryUtil._ACTIVE_TOAST.splice(JqueryUtil._ACTIVE_TOAST.indexOf(toastMeta), 1);
        setTimeout(()=>toastMeta.eleToast.parentElement && toastMeta.eleToast.remove(), 85);
    },

    isMobile() {
        if (navigator?.userAgentData?.mobile)
            return true;
        return window.matchMedia("(max-width: 768px)").matches;
    },
};
//#endregion


//#endregion

//#region UTILITIES 2

//#region TabUIUtil
class TabUiUtilBase {
    static decorate(obj, {isInitMeta=false}={}) {
        if (isInitMeta) {
            obj.__meta = {};
            obj._meta = obj._getProxy("meta", obj.__meta);
        }

        obj.__tabState = {};

        obj._getTabProps = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            return {
                propProxy,
                _propProxy: `_${propProxy}`,
                __propProxy: `__${propProxy}`,
                propActive: `ixActiveTab__${tabGroup}`,
            };
        }
        ;

        obj._renderTabs = function(tabMetas, {$parent, propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP, cbTabChange, additionalClassesWrpHeads}={}) {
            if (!tabMetas.length)
                throw new Error(`One or more tab meta must be specified!`);
            obj._resetTabs({
                tabGroup
            });

            const isSingleTab = tabMetas.length === 1;

            const {propActive, _propProxy, __propProxy} = obj._getTabProps({
                propProxy,
                tabGroup
            });

            this[__propProxy][propActive] = this[__propProxy][propActive] || 0;

            const $dispTabTitle = obj.__$getDispTabTitle({
                isSingleTab
            });

            const renderTabMetas_standard = (it,i)=>{
                const $btnTab = obj.__$getBtnTab({
                    isSingleTab,
                    tabMeta: it,
                    _propProxy,
                    propActive,
                    ixTab: i,
                });

                const $wrpTab = obj.__$getWrpTab({
                    tabMeta: it,
                    ixTab: i
                });

                return {
                    ...it,
                    ix: i,
                    $btnTab,
                    $wrpTab,
                };
            }
            ;

            const tabMetasOut = tabMetas.map((it,i)=>{
                if (it.type)
                    return obj.__renderTypedTabMeta({
                        tabMeta: it,
                        ixTab: i
                    });
                return renderTabMetas_standard(it, i);
            }
            ).filter(Boolean);

            if ($parent)
                obj.__renderTabs_addToParent({
                    $dispTabTitle,
                    $parent,
                    tabMetasOut,
                    additionalClassesWrpHeads
                });

            const hkActiveTab = ()=>{
                tabMetasOut.forEach(it=>{
                    if (it.type)
                        return;
                    const isActive = it.ix === this[_propProxy][propActive];
                    if (isActive && $dispTabTitle)
                        $dispTabTitle.text(isSingleTab ? "" : it.name);
                    if (it.$btnTab)
                        it.$btnTab.toggleClass("active", isActive);
                    it.$wrpTab.toggleVe(isActive);
                }
                );

                if (cbTabChange)
                    cbTabChange();
            }
            ;
            this._addHook(propProxy, propActive, hkActiveTab);
            hkActiveTab();

            obj.__tabState[tabGroup] = {
                fnReset: ()=>{
                    this._removeHook(propProxy, propActive, hkActiveTab);
                }
                ,
                tabMetasOut,
            };

            return tabMetasOut;
        }
        ;

        obj.__renderTabs_addToParent = function({$dispTabTitle, $parent, tabMetasOut, additionalClassesWrpHeads}) {
            const hasBorder = tabMetasOut.some(it=>it.hasBorder);
            $$`<div class="ve-flex-col w-100 h-100">
				${$dispTabTitle}
				<div class="ve-flex-col w-100 h-100 min-h-0">
					<div class="ve-flex ${hasBorder ? `ui-tab__wrp-tab-heads--border` : ""} ${additionalClassesWrpHeads || ""}">${tabMetasOut.map(it=>it.$btnTab)}</div>
					<div class="ve-flex w-100 h-100 min-h-0">${tabMetasOut.map(it=>it.$wrpTab).filter(Boolean)}</div>
				</div>
			</div>`.appendTo($parent);
        }
        ;

        obj._resetTabs = function({tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            if (!obj.__tabState[tabGroup])
                return;
            obj.__tabState[tabGroup].fnReset();
            delete obj.__tabState[tabGroup];
        }
        ;

        obj._hasPrevTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            return obj.__hasTab({
                propProxy,
                tabGroup,
                offset: -1
            });
        }
        ;
        obj._hasNextTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            return obj.__hasTab({
                propProxy,
                tabGroup,
                offset: 1
            });
        }
        ;

        obj.__hasTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP, offset}) {
            const {propActive, _propProxy} = obj._getTabProps({
                propProxy,
                tabGroup
            });
            const ixActive = obj[_propProxy][propActive];
            return !!(obj.__tabState[tabGroup]?.tabMetasOut && obj.__tabState[tabGroup]?.tabMetasOut[ixActive + offset]);
        }
        ;

        obj._doSwitchToPrevTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            return obj.__doSwitchToTab({
                propProxy,
                tabGroup,
                offset: -1
            });
        }
        ;
        obj._doSwitchToNextTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            return obj.__doSwitchToTab({
                propProxy,
                tabGroup,
                offset: 1
            });
        }
        ;

        obj.__doSwitchToTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP, offset}) {
            if (!obj.__hasTab({
                propProxy,
                tabGroup,
                offset
            }))
                return;
            const {propActive, _propProxy} = obj._getTabProps({
                propProxy,
                tabGroup
            });
            obj[_propProxy][propActive] = obj[_propProxy][propActive] + offset;
        }
        ;

        obj._addHookActiveTab = function(hook, {propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            const {propActive} = obj._getTabProps({
                propProxy,
                tabGroup
            });
            this._addHook(propProxy, propActive, hook);
        }
        ;

        obj._getIxActiveTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            const {propActive, _propProxy} = obj._getTabProps({
                propProxy,
                tabGroup
            });
            return obj[_propProxy][propActive];
        }
        ;

        obj._setIxActiveTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP, ixActiveTab}={}) {
            const {propActive, _propProxy} = obj._getTabProps({
                propProxy,
                tabGroup
            });
            obj[_propProxy][propActive] = ixActiveTab;
        }
        ;

        obj._getActiveTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            const tabState = obj.__tabState[tabGroup];
            const ixActiveTab = obj._getIxActiveTab({
                propProxy,
                tabGroup
            });
            return tabState.tabMetasOut[ixActiveTab];
        }
        ;

        obj._setActiveTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP, tab}) {
            const tabState = obj.__tabState[tabGroup];
            const ix = tabState.tabMetasOut.indexOf(tab);
            obj._setIxActiveTab({
                propProxy,
                tabGroup,
                ixActiveTab: ix
            });
        }
        ;

        obj.__$getBtnTab = function() {
            throw new Error("Unimplemented!");
        }
        ;
        obj.__$getWrpTab = function() {
            throw new Error("Unimplemented!");
        }
        ;
        obj.__renderTypedTabMeta = function() {
            throw new Error("Unimplemented!");
        }
        ;
        obj.__$getDispTabTitle = function() {
            throw new Error("Unimplemented!");
        }
        ;
    }
}
TabUiUtilBase._DEFAULT_TAB_GROUP = "_default";
TabUiUtilBase._DEFAULT_PROP_PROXY = "meta";

TabUiUtilBase.TabMeta = class {
    constructor({name, icon=null, type=null, buttons=null}={}) {
        this.name = name;
        this.icon = icon;
        this.type = type;
        this.buttons = buttons;
    }
}
;

let TabUiUtil$1 = class TabUiUtil extends TabUiUtilBase {
    static decorate(obj, {isInitMeta=false}={}) {
        super.decorate(obj, {
            isInitMeta
        });

        obj.__$getBtnTab = function({tabMeta, _propProxy, propActive, ixTab}) {
            return $(`<button class="btn btn-default ui-tab__btn-tab-head ${tabMeta.isHeadHidden ? "ve-hidden" : ""}">${tabMeta.name.qq()}</button>`).click(()=>obj[_propProxy][propActive] = ixTab);
        }
        ;

        obj.__$getWrpTab = function({tabMeta}) {
            return $(`<div class="ui-tab__wrp-tab-body ve-flex-col ve-hidden ${tabMeta.hasBorder ? "ui-tab__wrp-tab-body--border" : ""} ${tabMeta.hasBackground ? "ui-tab__wrp-tab-body--background" : ""}"></div>`);
        }
        ;

        obj.__renderTypedTabMeta = function({tabMeta, ixTab}) {
            switch (tabMeta.type) {
            case "buttons":
                return obj.__renderTypedTabMeta_buttons({
                    tabMeta,
                    ixTab
                });
            default:
                throw new Error(`Unhandled tab type "${tabMeta.type}"`);
            }
        }
        ;

        obj.__renderTypedTabMeta_buttons = function({tabMeta, ixTab}) {
            const $btns = tabMeta.buttons.map((meta,j)=>{
                const $btn = $(`<button class="btn ui-tab__btn-tab-head ${meta.type ? `btn-${meta.type}` : "btn-primary"}" ${meta.title ? `title="${meta.title.qq()}"` : ""}>${meta.html}</button>`).click(evt=>meta.pFnClick(evt, $btn));
                return $btn;
            }
            );

            const $btnTab = $$`<div class="btn-group ve-flex-v-right ve-flex-h-right ml-2 w-100">${$btns}</div>`;

            return {
                ...tabMeta,
                ix: ixTab,
                $btns,
                $btnTab,
            };
        }
        ;

        obj.__$getDispTabTitle = function() {
            return null;
        }
        ;
    }
}
;

globalThis.TabUiUtil = TabUiUtil$1;

TabUiUtil$1.TabMeta = class extends TabUiUtilBase.TabMeta {
    constructor(opts) {
        super(opts);
        this.hasBorder = !!opts.hasBorder;
        this.hasBackground = !!opts.hasBackground;
        this.isHeadHidden = !!opts.isHeadHidden;
        this.isNoPadding = !!opts.isNoPadding;
    }
}
;

let TabUiUtilSide$1 = class TabUiUtilSide extends TabUiUtilBase {
    static decorate(obj, {isInitMeta=false}={}) {
        super.decorate(obj, {
            isInitMeta
        });

        obj.__$getBtnTab = function({isSingleTab, tabMeta, _propProxy, propActive, ixTab}) {
            return isSingleTab ? null : $(`<button class="btn btn-default btn-sm ui-tab-side__btn-tab mb-2 br-0 btr-0 bbr-0 text-left ve-flex-v-center" title="${tabMeta.name.qq()}"><div class="${tabMeta.icon} ui-tab-side__icon-tab mr-2 mobile-ish__mr-0 ve-text-center"></div><div class="mobile-ish__hidden">${tabMeta.name.qq()}</div></button>`).click(()=>this[_propProxy][propActive] = ixTab);
        }
        ;

        obj.__$getWrpTab = function({tabMeta}) {
            return $(`<div class="ve-flex-col w-100 h-100 ui-tab-side__wrp-tab ${tabMeta.isNoPadding ? "" : "px-3 py-2"} overflow-y-auto"></div>`);
        }
        ;

        obj.__renderTabs_addToParent = function({$dispTabTitle, $parent, tabMetasOut}) {
            $$`<div class="ve-flex-col w-100 h-100">
				${$dispTabTitle}
				<div class="ve-flex w-100 h-100 min-h-0">
					<div class="ve-flex-col h-100 pt-2">${tabMetasOut.map(it=>it.$btnTab)}</div>
					<div class="ve-flex-col w-100 h-100 min-w-0">${tabMetasOut.map(it=>it.$wrpTab).filter(Boolean)}</div>
				</div>
			</div>`.appendTo($parent);
        }
        ;

        obj.__renderTypedTabMeta = function({tabMeta, ixTab}) {
            switch (tabMeta.type) {
            case "buttons":
                return obj.__renderTypedTabMeta_buttons({
                    tabMeta,
                    ixTab
                });
            default:
                throw new Error(`Unhandled tab type "${tabMeta.type}"`);
            }
        }
        ;

        obj.__renderTypedTabMeta_buttons = function({tabMeta, ixTab}) {
            const $btns = tabMeta.buttons.map((meta,j)=>{
                const $btn = $(`<button class="btn ${meta.type ? `btn-${meta.type}` : "btn-primary"} btn-sm" ${meta.title ? `title="${meta.title.qq()}"` : ""}>${meta.html}</button>`).click(evt=>meta.pFnClick(evt, $btn));

                if (j === tabMeta.buttons.length - 1)
                    $btn.addClass(`br-0 btr-0 bbr-0`);

                return $btn;
            }
            );

            const $btnTab = $$`<div class="btn-group ve-flex-v-center ve-flex-h-right mb-2">${$btns}</div>`;

            return {
                ...tabMeta,
                ix: ixTab,
                $btnTab,
            };
        }
        ;

        obj.__$getDispTabTitle = function({isSingleTab}) {
            return $(`<div class="ui-tab-side__disp-active-tab-name ${isSingleTab ? `ui-tab-side__disp-active-tab-name--single` : ""} bold"></div>`);
        }
        ;
    }
}
;

globalThis.TabUiUtilSide = TabUiUtilSide$1;
//#endregion

//#region ElementUtil
jQuery.fn.disableSpellcheck = function(){
    return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");
}
jQuery.fn.hideVe = function() {
    this.classList.add("ve-hidden");
    return this;
}
globalThis.ElementUtil = {
    _ATTRS_NO_FALSY: new Set(["checked", "disabled", ]),

    getOrModify({tag, clazz, style, click, contextmenu, change, mousedown, mouseup, mousemove, pointerdown, pointerup, keydown, html, text, txt, ele, children, outer,
    id, name, title, val, href, type, tabindex, value, placeholder, attrs, data, }) {
        ele = ele || (outer ? (new DOMParser()).parseFromString(outer, "text/html").body.childNodes[0] : document.createElement(tag));

        if (clazz)
            ele.className = clazz;
        if (style)
            ele.setAttribute("style", style);
        if (click)
            ele.addEventListener("click", click);
        if (contextmenu)
            ele.addEventListener("contextmenu", contextmenu);
        if (change)
            ele.addEventListener("change", change);
        if (mousedown)
            ele.addEventListener("mousedown", mousedown);
        if (mouseup)
            ele.addEventListener("mouseup", mouseup);
        if (mousemove)
            ele.addEventListener("mousemove", mousemove);
        if (pointerdown)
            ele.addEventListener("pointerdown", pointerdown);
        if (pointerup)
            ele.addEventListener("pointerup", pointerup);
        if (keydown)
            ele.addEventListener("keydown", keydown);
        if (html != null)
            ele.innerHTML = html;
        if (text != null || txt != null)
            ele.textContent = text;
        if (id != null)
            ele.setAttribute("id", id);
        if (name != null)
            ele.setAttribute("name", name);
        if (title != null)
            ele.setAttribute("title", title);
        if (href != null)
            ele.setAttribute("href", href);
        if (val != null)
            ele.setAttribute("value", val);
        if (type != null)
            ele.setAttribute("type", type);
        if (tabindex != null)
            ele.setAttribute("tabindex", tabindex);
        if (value != null)
            ele.setAttribute("value", value);
        if (placeholder != null)
            ele.setAttribute("placeholder", placeholder);

        if (attrs != null) {
            for (const k in attrs) {
                if (attrs[k] === undefined)
                    continue;
                if (!attrs[k] && ElementUtil._ATTRS_NO_FALSY.has(k))
                    continue;
                ele.setAttribute(k, attrs[k]);
            }
        }

        if (data != null) {
            for (const k in data) {
                if (data[k] === undefined)
                    continue;
                ele.dataset[k] = data[k];
            }
        }

        if (children)
            for (let i = 0, len = children.length; i < len; ++i)
                if (children[i] != null)
                    ele.append(children[i]);

        ele.appends = ele.appends || ElementUtil._appends.bind(ele);
        ele.appendTo = ele.appendTo || ElementUtil._appendTo.bind(ele);
        ele.prependTo = ele.prependTo || ElementUtil._prependTo.bind(ele);
        ele.insertAfter = ele.insertAfter || ElementUtil._insertAfter.bind(ele);
        ele.addClass = ele.addClass || ElementUtil._addClass.bind(ele);
        ele.removeClass = ele.removeClass || ElementUtil._removeClass.bind(ele);
        ele.toggleClass = ele.toggleClass || ElementUtil._toggleClass.bind(ele);
        ele.showVe = ele.showVe || ElementUtil._showVe.bind(ele);
        ele.hideVe = ele.hideVe || ElementUtil._hideVe.bind(ele);
        ele.toggleVe = ele.toggleVe || ElementUtil._toggleVe.bind(ele);
        ele.empty = ele.empty || ElementUtil._empty.bind(ele);
        ele.detach = ele.detach || ElementUtil._detach.bind(ele);
        ele.attr = ele.attr || ElementUtil._attr.bind(ele);
        ele.val = ele.val || ElementUtil._val.bind(ele);
        ele.html = ele.html || ElementUtil._html.bind(ele);
        ele.txt = ele.txt || ElementUtil._txt.bind(ele);
        ele.tooltip = ele.tooltip || ElementUtil._tooltip.bind(ele);
        ele.disableSpellcheck = ele.disableSpellcheck || ElementUtil._disableSpellcheck.bind(ele);
        ele.on = ele.on || ElementUtil._onX.bind(ele);
        ele.onClick = ele.onClick || ElementUtil._onX.bind(ele, "click");
        ele.onContextmenu = ele.onContextmenu || ElementUtil._onX.bind(ele, "contextmenu");
        ele.onChange = ele.onChange || ElementUtil._onX.bind(ele, "change");
        ele.onKeydown = ele.onKeydown || ElementUtil._onX.bind(ele, "keydown");
        ele.onKeyup = ele.onKeyup || ElementUtil._onX.bind(ele, "keyup");

        return ele;
    },

    _appends(child) {
        this.appendChild(child);
        return this;
    },

    _appendTo(parent) {
        parent.appendChild(this);
        return this;
    },

    _prependTo(parent) {
        parent.prepend(this);
        return this;
    },

    _insertAfter(parent) {
        parent.after(this);
        return this;
    },

    _addClass(clazz) {
        this.classList.add(clazz);
        return this;
    },

    _removeClass(clazz) {
        this.classList.remove(clazz);
        return this;
    },

    _toggleClass(clazz, isActive) {
        if (isActive == null)
            this.classList.toggle(clazz);
        else if (isActive)
            this.classList.add(clazz);
        else
            this.classList.remove(clazz);
        return this;
    },

    _showVe() {
        this.classList.remove("ve-hidden");
        return this;
    },

    _hideVe() {
        this.classList.add("ve-hidden");
        return this;
    },

    _toggleVe(isActive) {
        this.toggleClass("ve-hidden", isActive == null ? isActive : !isActive);
        return this;
    },

    _empty() {
        this.innerHTML = "";
        return this;
    },

    _detach() {
        if (this.parentElement)
            this.parentElement.removeChild(this);
        return this;
    },

    _attr(name, value) {
        this.setAttribute(name, value);
        return this;
    },

    _html(html) {
        if (html === undefined)
            return this.innerHTML;
        this.innerHTML = html;
        return this;
    },

    _txt(txt) {
        if (txt === undefined)
            return this.innerText;
        this.innerText = txt;
        return this;
    },

    _tooltip(title) {
        return this.attr("title", title);
    },

    _disableSpellcheck() {
        return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");
    },

    _onX(evtName, fn) {
        this.addEventListener(evtName, fn);
        return this;
    },

    _val(val) {
        if (val !== undefined) {
            switch (this.tagName) {
            case "SELECT":
                {
                    let selectedIndexNxt = -1;
                    for (let i = 0, len = this.options.length; i < len; ++i) {
                        if (this.options[i]?.value === val) {
                            selectedIndexNxt = i;
                            break;
                        }
                    }
                    this.selectedIndex = selectedIndexNxt;
                    return this;
                }

            default:
                {
                    this.value = val;
                    return this;
                }
            }
        }

        switch (this.tagName) {
        case "SELECT":
            return this.options[this.selectedIndex]?.value;

        default:
            return this.value;
        }
    },

    getIndexPathToParent(parent, child) {
        if (!parent.contains(child))
            return null;
        const path = [];

        while (child !== parent) {
            if (!child.parentElement)
                return null;
            const ix = [...child.parentElement.children].indexOf(child);
            if (!~ix)
                return null;
            path.push(ix);

            child = child.parentElement;
        }

        return path.reverse();
    },

    getChildByIndexPath(parent, indexPath) {
        for (let i = 0; i < indexPath.length; ++i) {
            const ix = indexPath[i];
            parent = parent.children[ix];
            if (!parent)
                return null;
        }
        return parent;
    },
};
if (typeof window !== "undefined"){window.e_ = ElementUtil.getOrModify;}
//#endregion

//#region CollectionUtil
globalThis.CollectionUtil = {
    ObjectSet: class ObjectSet {
        constructor() {
            this.map = new Map();
            this[Symbol.iterator] = this.values;
        }
        add(item) {
            this.map.set(item._toIdString(), item);
        }

        values() {
            return this.map.values();
        }
    }
    ,

    setEq(a, b) {
        if (a.size !== b.size)
            return false;
        for (const it of a)
            if (!b.has(it))
                return false;
        return true;
    },

    setDiff(set1, set2) {
        return new Set([...set1].filter(it=>!set2.has(it)));
    },

    objectDiff(obj1, obj2) {
        const out = {};

        [...new Set([...Object.keys(obj1), ...Object.keys(obj2)])].forEach(k=>{
            const diff = CollectionUtil._objectDiff_recurse(obj1[k], obj2[k]);
            if (diff !== undefined)
                out[k] = diff;
        }
        );

        return out;
    },

    _objectDiff_recurse(a, b) {
        if (CollectionUtil.deepEquals(a, b))
            return undefined;

        if (a && b && typeof a === "object" && typeof b === "object") {
            return CollectionUtil.objectDiff(a, b);
        }

        return b;
    },

    objectIntersect(obj1, obj2) {
        const out = {};

        [...new Set([...Object.keys(obj1), ...Object.keys(obj2)])].forEach(k=>{
            const diff = CollectionUtil._objectIntersect_recurse(obj1[k], obj2[k]);
            if (diff !== undefined)
                out[k] = diff;
        }
        );

        return out;
    },

    _objectIntersect_recurse(a, b) {
        if (CollectionUtil.deepEquals(a, b))
            return a;

        if (a && b && typeof a === "object" && typeof b === "object") {
            return CollectionUtil.objectIntersect(a, b);
        }

        return undefined;
    },

    deepEquals(a, b) {
        if (Object.is(a, b))
            return true;
        if (a && b && typeof a === "object" && typeof b === "object") {
            if (CollectionUtil._eq_isPlainObject(a) && CollectionUtil._eq_isPlainObject(b))
                return CollectionUtil._eq_areObjectsEqual(a, b);
            const isArrayA = Array.isArray(a);
            const isArrayB = Array.isArray(b);
            if (isArrayA || isArrayB)
                return isArrayA === isArrayB && CollectionUtil._eq_areArraysEqual(a, b);
            const isSetA = a instanceof Set;
            const isSetB = b instanceof Set;
            if (isSetA || isSetB)
                return isSetA === isSetB && CollectionUtil.setEq(a, b);
            return CollectionUtil._eq_areObjectsEqual(a, b);
        }
        return false;
    },

    _eq_isPlainObject: (value)=>value.constructor === Object || value.constructor == null,
    _eq_areObjectsEqual(a, b) {
        const keysA = Object.keys(a);
        const {length} = keysA;
        if (Object.keys(b).length !== length)
            return false;
        for (let i = 0; i < length; i++) {
            if (!b.hasOwnProperty(keysA[i]))
                return false;
            if (!CollectionUtil.deepEquals(a[keysA[i]], b[keysA[i]]))
                return false;
        }
        return true;
    },
    _eq_areArraysEqual(a, b) {
        const {length} = a;
        if (b.length !== length)
            return false;
        for (let i = 0; i < length; i++)
            if (!CollectionUtil.deepEquals(a[i], b[i]))
                return false;
        return true;
    },

    dfs(obj, opts) {
        const {prop=null, fnMatch=null} = opts;
        if (!prop && !fnMatch)
            throw new Error(`One of "prop" or "fnMatch" must be specified!`);

        if (obj instanceof Array) {
            for (const child of obj) {
                const n = CollectionUtil.dfs(child, opts);
                if (n)
                    return n;
            }
            return;
        }

        if (obj instanceof Object) {
            if (prop && obj[prop])
                return obj[prop];
            if (fnMatch && fnMatch(obj))
                return obj;

            for (const child of Object.values(obj)) {
                const n = CollectionUtil.dfs(child, opts);
                if (n)
                    return n;
            }
        }
    },

    bfs(obj, opts) {
        const {prop=null, fnMatch=null} = opts;
        if (!prop && !fnMatch)
            throw new Error(`One of "prop" or "fnMatch" must be specified!`);

        if (obj instanceof Array) {
            for (const child of obj) {
                if (!(child instanceof Array) && child instanceof Object) {
                    if (prop && child[prop])
                        return child[prop];
                    if (fnMatch && fnMatch(child))
                        return child;
                }
            }

            for (const child of obj) {
                const n = CollectionUtil.bfs(child, opts);
                if (n)
                    return n;
            }

            return;
        }

        if (obj instanceof Object) {
            if (prop && obj[prop])
                return obj[prop];
            if (fnMatch && fnMatch(obj))
                return obj;

            return CollectionUtil.bfs(Object.values(obj));
        }
    },
};
//#endregion

//#region UIUtil
let UiUtil$1 = class UiUtil {
    static strToInt(string, fallbackEmpty=0, opts) {
        return UiUtil$1._strToNumber(string, fallbackEmpty, opts, true);
    }

    static strToNumber(string, fallbackEmpty=0, opts) {
        return UiUtil$1._strToNumber(string, fallbackEmpty, opts, false);
    }

    static _strToNumber(string, fallbackEmpty=0, opts, isInt) {
        opts = opts || {};
        let out;
        string = string.trim();
        if (!string)
            out = fallbackEmpty;
        else {
            const num = UiUtil$1._parseStrAsNumber(string, isInt);
            out = isNaN(num) || !isFinite(num) ? opts.fallbackOnNaN !== undefined ? opts.fallbackOnNaN : 0 : num;
        }
        if (opts.max != null)
            out = Math.min(out, opts.max);
        if (opts.min != null)
            out = Math.max(out, opts.min);
        return out;
    }

    static strToBool(string, fallbackEmpty=null, opts) {
        opts = opts || {};
        if (!string)
            return fallbackEmpty;
        string = string.trim().toLowerCase();
        if (!string)
            return fallbackEmpty;
        return string === "true" ? true : string === "false" ? false : opts.fallbackOnNaB;
    }

    static intToBonus(int, {isPretty=false}={}) {
        return `${int >= 0 ? "+" : int < 0 ? (isPretty ? "\u2012" : "-") : ""}${Math.abs(int)}`;
    }

    static getEntriesAsText(entryArray) {
        if (!entryArray || !entryArray.length)
            return "";
        if (!(entryArray instanceof Array))
            return UiUtil$1.getEntriesAsText([entryArray]);

        return entryArray.map(it=>{
            if (typeof it === "string" || typeof it === "number")
                return it;

            return JSON.stringify(it, null, 2).split("\n").map(it=>`  ${it}`);
        }
        ).flat().join("\n");
    }

    static getTextAsEntries(text) {
        try {
            const lines = text.split("\n").filter(it=>it.trim()).map(it=>{
                if (/^\s/.exec(it))
                    return it;
                return `"${it.replace(/"/g, `\\"`)}",`;
            }
            ).map(it=>{
                if (/[}\]]$/.test(it.trim()))
                    return `${it},`;
                return it;
            }
            );
            const json = `[\n${lines.join("")}\n]`.replace(/(.*?)(,)(:?\s*]|\s*})/g, "$1$3");
            return JSON.parse(json);
        } catch (e) {
            const lines = text.split("\n").filter(it=>it.trim());
            const slice = lines.join(" \\ ").substring(0, 30);
            JqueryUtil.doToast({
                content: `Could not parse entries! Error was: ${e.message}<br>Text was: ${slice}${slice.length === 30 ? "..." : ""}`,
                type: "danger",
            });
            return lines;
        }
    }

    static getShowModal(opts) {
        opts = opts || {};

        const doc = (opts.window || window).document;

        UiUtil$1._initModalEscapeHandler({
            doc
        });
        UiUtil$1._initModalMouseupHandlers({
            doc
        });
        if (doc.activeElement)
            doc.activeElement.blur();
        let resolveModal;
        const pResolveModal = new Promise(resolve=>{
            resolveModal = resolve;
        }
        );

        const pHandleCloseClick = async(isDataEntered,...args)=>{
            if (opts.cbClose)
                await opts.cbClose(isDataEntered, ...args);
            resolveModal([isDataEntered, ...args]);

            if (opts.isIndestructible)
                wrpOverlay.detach();
            else
                wrpOverlay.remove();

            ContextUtil.closeAllMenus();

            doTeardown();
        }
        ;

        const doTeardown = ()=>{
            UiUtil$1._popFromModalStack(modalStackMeta);
            if (!UiUtil$1._MODAL_STACK.length)
                doc.body.classList.remove(`ui-modal__body-active`);
        }
        ;

        const doOpen = ()=>{
            wrpOverlay.appendTo(doc.body);
            doc.body.classList.add(`ui-modal__body-active`);
        }
        ;

        const wrpOverlay = e_({
            tag: "div",
            clazz: "ui-modal__overlay"
        });
        if (opts.zIndex != null)
            wrpOverlay.style.zIndex = `${opts.zIndex}`;
        if (opts.overlayColor != null)
            wrpOverlay.style.backgroundColor = `${opts.overlayColor}`;

        const overlayBlind = opts.isFullscreenModal ? e_({
            tag: "div",
            clazz: `ui-modal__overlay-blind w-100 h-100 ve-flex-col`,
        }).appendTo(wrpOverlay) : null;

        const wrpScroller = e_({
            tag: "div",
            clazz: `ui-modal__scroller ve-flex-col`,
        });

        const modalWindowClasses = [opts.isWidth100 ? `w-100` : "", opts.isHeight100 ? "h-100" : "", opts.isUncappedHeight ? "ui-modal__inner--uncap-height" : "", opts.isUncappedWidth ? "ui-modal__inner--uncap-width" : "", opts.isMinHeight0 ? `ui-modal__inner--no-min-height` : "", opts.isMinWidth0 ? `ui-modal__inner--no-min-width` : "", opts.isMaxWidth640p ? `ui-modal__inner--max-width-640p` : "", opts.isFullscreenModal ? `ui-modal__inner--mode-fullscreen my-0 pt-0` : "", opts.hasFooter ? `pb-0` : "", ].filter(Boolean);

        const btnCloseModal = opts.isFullscreenModal ? e_({
            tag: "button",
            clazz: `btn btn-danger btn-xs`,
            html: `<span class="glyphicon glyphicon-remove></span>`,
            click: pHandleCloseClick(false),
        }) : null;

        const modalFooter = opts.hasFooter ? e_({
            tag: "div",
            clazz: `no-shrink w-100 ve-flex-col ui-modal__footer ${opts.isFullscreenModal ? `ui-modal__footer--fullscreen mt-1` : "mt-auto"}`,
        }) : null;

        const modal = e_({
            tag: "div",
            clazz: `ui-modal__inner ve-flex-col ${modalWindowClasses.join(" ")}`,
            children: [!opts.isEmpty && opts.title ? e_({
                tag: "div",
                clazz: `split-v-center no-shrink ${opts.isHeaderBorder ? `ui-modal__header--border` : ""} ${opts.isFullscreenModal ? `ui-modal__header--fullscreen mb-1` : ""}`,
                children: [opts.title ? e_({
                    tag: "h4",
                    clazz: `my-2`,
                    html: opts.title.qq(),
                }) : null,
                opts.$titleSplit ? opts.$titleSplit[0] : null,
                btnCloseModal, ].filter(Boolean),
            }) : null,
            !opts.isEmpty ? wrpScroller : null,
            modalFooter, ].filter(Boolean),
        }).appendTo(opts.isFullscreenModal ? overlayBlind : wrpOverlay);

        wrpOverlay.addEventListener("mouseup", async evt=>{
            if (evt.target !== wrpOverlay)
                return;
            if (evt.target !== UiUtil$1._MODAL_LAST_MOUSEDOWN)
                return;
            if (opts.isPermanent)
                return;
            evt.stopPropagation();
            evt.preventDefault();
            return pHandleCloseClick(false);
        }
        );

        if (!opts.isClosed)
            doOpen();

        const modalStackMeta = {
            isPermanent: opts.isPermanent,
            pHandleCloseClick,
            doTeardown,
        };
        if (!opts.isClosed)
            UiUtil$1._pushToModalStack(modalStackMeta);

        const out = {
            $modal: $(modal),
            $modalInner: $(wrpScroller),
            $modalFooter: $(modalFooter),
            doClose: pHandleCloseClick,
            doTeardown,
            pGetResolved: ()=>pResolveModal,
        };

        if (opts.isIndestructible || opts.isClosed) {
            out.doOpen = ()=>{
                UiUtil$1._pushToModalStack(modalStackMeta);
                doOpen();
            }
            ;
        }

        return out;
    }

    static async pGetShowModal(opts) {
        return UiUtil$1.getShowModal(opts);
    }

    static _pushToModalStack(modalStackMeta) {
        if (!UiUtil$1._MODAL_STACK.includes(modalStackMeta)) {
            UiUtil$1._MODAL_STACK.push(modalStackMeta);
        }
    }

    static _popFromModalStack(modalStackMeta) {
        const ixStack = UiUtil$1._MODAL_STACK.indexOf(modalStackMeta);
        if (~ixStack)
            UiUtil$1._MODAL_STACK.splice(ixStack, 1);
    }

    static _initModalEscapeHandler({doc}) {
        if (UiUtil$1._MODAL_STACK)
            return;
        UiUtil$1._MODAL_STACK = [];

        doc.addEventListener("keydown", evt=>{
            if (evt.which !== 27)
                return;
            if (!UiUtil$1._MODAL_STACK.length)
                return;
            if (EventUtil.isInInput(evt))
                return;

            const outerModalMeta = UiUtil$1._MODAL_STACK.last();
            if (!outerModalMeta)
                return;
            evt.stopPropagation();
            if (!outerModalMeta.isPermanent)
                return outerModalMeta.pHandleCloseClick(false);
        }
        );
    }

    static _initModalMouseupHandlers({doc}) {
        doc.addEventListener("mousedown", evt=>{
            UiUtil$1._MODAL_LAST_MOUSEDOWN = evt.target;
        }
        );
    }

    static isAnyModalOpen() {
        return !!UiUtil$1._MODAL_STACK?.length;
    }

    static addModalSep($modalInner) {
        $modalInner.append(`<hr class="hr-2">`);
    }

    static $getAddModalRow($modalInner, tag="div") {
        return $(`<${tag} class="ui-modal__row"></${tag}>`).appendTo($modalInner);
    }

    static $getAddModalRowHeader($modalInner, headerText, opts) {
        opts = opts || {};
        const $row = UiUtil$1.$getAddModalRow($modalInner, "h5").addClass("bold");
        if (opts.$eleRhs)
            $$`<div class="split ve-flex-v-center w-100 pr-1"><span>${headerText}</span>${opts.$eleRhs}</div>`.appendTo($row);
        else
            $row.text(headerText);
        if (opts.helpText)
            $row.title(opts.helpText);
        return $row;
    }

    static $getAddModalRowCb($modalInner, labelText, objectWithProp, propName, helpText) {
        const $row = UiUtil$1.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--cb`);
        if (helpText)
            $row.title(helpText);
        $row.append(`<span>${labelText}</span>`);
        const $cb = $(`<input type="checkbox">`).appendTo($row).keydown(evt=>{
            if (evt.key === "Escape")
                $cb.blur();
        }
        ).prop("checked", objectWithProp[propName]).on("change", ()=>objectWithProp[propName] = $cb.prop("checked"));
        return $cb;
    }

    static $getAddModalRowCb2({$wrp, comp, prop, text, title=null}) {
        const $cb = ComponentUiUtil$1.$getCbBool(comp, prop);

        const $row = $$`<label class="split-v-center py-1 veapp__ele-hoverable">
			<span>${text}</span>
			${$cb}
		</label>`.appendTo($wrp);
        if (title)
            $row.title(title);

        return $cb;
    }

    static $getAddModalRowSel($modalInner, labelText, objectWithProp, propName, values, opts) {
        opts = opts || {};
        const $row = UiUtil$1.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--sel`);
        if (opts.helpText)
            $row.title(opts.helpText);
        $row.append(`<span>${labelText}</span>`);
        const $sel = $(`<select class="form-control input-xs w-30">`).appendTo($row);
        values.forEach((val,i)=>$(`<option value="${i}"></option>`).text(opts.fnDisplay ? opts.fnDisplay(val) : val).appendTo($sel));
        const ix = values.indexOf(objectWithProp[propName]);
        $sel.val(`${~ix ? ix : 0}`).change(()=>objectWithProp[propName] = values[$sel.val()]);
        return $sel;
    }

    static _parseStrAsNumber(str, isInt) {
        const wrpTree = Renderer.dice.lang.getTree3(str);
        if (!wrpTree)
            return NaN;
        const out = wrpTree.tree.evl({});
        if (!isNaN(out) && isInt)
            return Math.round(out);
        return out;
    }

    static bindTypingEnd({$ipt, fnKeyup, fnKeypress, fnKeydown, fnClick}={}) {
        let timerTyping;
        $ipt.on("keyup search paste", evt=>{
            clearTimeout(timerTyping);
            timerTyping = setTimeout(()=>{
                fnKeyup(evt);
            }
            , UiUtil$1.TYPE_TIMEOUT_MS);
        }
        ).on("blur", evt=>{
            clearTimeout(timerTyping);
            fnKeyup(evt);
        }
        ).on("keypress", evt=>{
            if (fnKeypress)
                fnKeypress(evt);
        }
        ).on("keydown", evt=>{
            if (fnKeydown)
                fnKeydown(evt);
            clearTimeout(timerTyping);
        }
        ).on("click", ()=>{
            if (fnClick)
                fnClick();
        }
        ).on("instantKeyup", ()=>{
            clearTimeout(timerTyping);
            fnKeyup();
        }
        );
    }

    static async pDoForceFocus(ele, {timeout=250}={}) {
        if (!ele)
            return;
        ele.focus();

        const forceFocusStart = Date.now();
        while ((Date.now() < forceFocusStart + timeout) && document.activeElement !== ele) {
            await MiscUtil.pDelay(33);
            ele.focus();
        }
    }
}
;
UiUtil$1.SEARCH_RESULTS_CAP = 75;
UiUtil$1.TYPE_TIMEOUT_MS = 100;
UiUtil$1._MODAL_STACK = null;
UiUtil$1._MODAL_LAST_MOUSEDOWN = null;
globalThis.UiUtil = UiUtil$1;

let ListSelectClickHandlerBase$1 = class ListSelectClickHandlerBase {
    static _EVT_PASS_THOUGH_TAGS = new Set(["A", "BUTTON"]);

    constructor() {
        this._firstSelection = null;
        this._lastSelection = null;

        this._selectionInitialValue = null;
    }

    get _visibleItems() {
        throw new Error("Unimplemented!");
    }

    get _allItems() {
        throw new Error("Unimplemented!");
    }

    _getCb(item, opts) {
        throw new Error("Unimplemented!");
    }

    _setCheckbox(item, opts) {
        throw new Error("Unimplemented!");
    }

    _setHighlighted(item, opts) {
        throw new Error("Unimplemented!");
    }

    handleSelectClick(item, evt, opts) {
        opts = opts || {};

        if (opts.isPassThroughEvents) {
            const evtPath = evt.composedPath();
            const subEles = evtPath.slice(0, evtPath.indexOf(evt.currentTarget));
            if (subEles.some(ele=>this.constructor._EVT_PASS_THOUGH_TAGS.has(ele?.tagName)))
                return;
        }

        evt.preventDefault();
        evt.stopPropagation();

        const cb = this._getCb(item, opts);
        if (cb.disabled)
            return true;

        if (evt && evt.shiftKey && this._firstSelection) {
            if (this._lastSelection === item) {

                this._setCheckbox(item, {
                    ...opts,
                    toVal: !cb.checked
                });
            } else if (this._firstSelection === item && this._lastSelection) {

                const ix1 = this._visibleItems.indexOf(this._firstSelection);
                const ix2 = this._visibleItems.indexOf(this._lastSelection);

                const [ixStart,ixEnd] = [ix1, ix2].sort(SortUtil.ascSort);
                for (let i = ixStart; i <= ixEnd; ++i) {
                    const it = this._visibleItems[i];
                    this._setCheckbox(it, {
                        ...opts,
                        toVal: false
                    });
                }

                this._setCheckbox(item, opts);
            } else {
                this._selectionInitialValue = this._getCb(this._firstSelection, opts).checked;

                const ix1 = this._visibleItems.indexOf(this._firstSelection);
                const ix2 = this._visibleItems.indexOf(item);
                const ix2Prev = this._lastSelection ? this._visibleItems.indexOf(this._lastSelection) : null;

                const [ixStart,ixEnd] = [ix1, ix2].sort(SortUtil.ascSort);
                const nxtOpts = {
                    ...opts,
                    toVal: this._selectionInitialValue
                };
                for (let i = ixStart; i <= ixEnd; ++i) {
                    const it = this._visibleItems[i];
                    this._setCheckbox(it, nxtOpts);
                }

                if (this._selectionInitialValue && ix2Prev != null) {
                    if (ix2Prev > ixEnd) {
                        const nxtOpts = {
                            ...opts,
                            toVal: !this._selectionInitialValue
                        };
                        for (let i = ixEnd + 1; i <= ix2Prev; ++i) {
                            const it = this._visibleItems[i];
                            this._setCheckbox(it, nxtOpts);
                        }
                    } else if (ix2Prev < ixStart) {
                        const nxtOpts = {
                            ...opts,
                            toVal: !this._selectionInitialValue
                        };
                        for (let i = ix2Prev; i < ixStart; ++i) {
                            const it = this._visibleItems[i];
                            this._setCheckbox(it, nxtOpts);
                        }
                    }
                }
            }

            this._lastSelection = item;
        } else {

            const cbMaster = this._getCb(item, opts);
            if (cbMaster) {
                cbMaster.checked = !cbMaster.checked;

                if (opts.fnOnSelectionChange)
                    opts.fnOnSelectionChange(item, cbMaster.checked);

                if (!opts.isNoHighlightSelection) {
                    this._setHighlighted(item, cbMaster.checked);
                }
            } else {
                if (!opts.isNoHighlightSelection) {
                    this._setHighlighted(item, false);
                }
            }

            this._firstSelection = item;
            this._lastSelection = null;
            this._selectionInitialValue = null;
        }
    }

    handleSelectClickRadio(item, evt) {
        evt.preventDefault();
        evt.stopPropagation();

        this._allItems.forEach(itemOther=>{
            const cb = this._getCb(itemOther);

            if (itemOther === item) {
                cb.checked = true;
                this._setHighlighted(itemOther, true);
            } else {
                cb.checked = false;
                this._setHighlighted(itemOther, false);
            }
        }
        );
    }
}
;

globalThis.ListSelectClickHandlerBase = ListSelectClickHandlerBase$1;

let ListSelectClickHandler$1 = class ListSelectClickHandler extends ListSelectClickHandlerBase$1 {
    constructor({list}) {
        super();
        this._list = list;
    }

    get _visibleItems() {
        return this._list.visibleItems;
    }

    get _allItems() {
        return this._list.items;
    }

    _getCb(item, opts={}) {
        return opts.fnGetCb ? opts.fnGetCb(item) : item.data.cbSel;
    }

    _setCheckbox(item, opts={}) {
        return this.setCheckbox(item, opts);
    }

    _setHighlighted(item, isHighlighted) {
        if (isHighlighted)
            item.ele instanceof $ ? item.ele.addClass("list-multi-selected") : item.ele.classList.add("list-multi-selected");
        else
            item.ele instanceof $ ? item.ele.removeClass("list-multi-selected") : item.ele.classList.remove("list-multi-selected");
    }

    setCheckbox(item, {fnGetCb, fnOnSelectionChange, isNoHighlightSelection, toVal=true}={}) {
        const cbSlave = this._getCb(item, {
            fnGetCb,
            fnOnSelectionChange,
            isNoHighlightSelection
        });

        if (cbSlave?.disabled)
            return;

        if (cbSlave) {
            cbSlave.checked = toVal;
            if (fnOnSelectionChange)
                fnOnSelectionChange(item, toVal);
        }

        if (isNoHighlightSelection)
            return;

        this._setHighlighted(item, toVal);
    }

    bindSelectAllCheckbox($cbAll) {
        $cbAll.change(()=>{
            const isChecked = $cbAll.prop("checked");
            this.setCheckboxes({
                isChecked
            });
        }
        );
    }

    setCheckboxes({isChecked, isIncludeHidden}) {
        (isIncludeHidden ? this._list.items : this._list.visibleItems).forEach(item=>{
            if (item.data.cbSel?.disabled)
                return;

            if (item.data.cbSel)
                item.data.cbSel.checked = isChecked;

            this._setHighlighted(item, isChecked);
        }
        );
    }
}
;

globalThis.ListSelectClickHandler = ListSelectClickHandler$1;

let ListUiUtil$1 = class ListUiUtil {
    static bindPreviewButton(page, allData, item, btnShowHidePreview, {$fnGetPreviewStats}={}) {
        btnShowHidePreview.addEventListener("click", evt=>{
            const entity = allData[item.ix];
            page = page || entity?.__prop;

            const elePreviewWrp = this.getOrAddListItemPreviewLazy(item);

            this.handleClickBtnShowHideListPreview(evt, page, entity, btnShowHidePreview, elePreviewWrp, {
                $fnGetPreviewStats
            });
        }
        );
    }

    static handleClickBtnShowHideListPreview(evt, page, entity, btnShowHidePreview, elePreviewWrp, {nxtText=null, $fnGetPreviewStats}={}) {
        evt.stopPropagation();
        evt.preventDefault();

        nxtText = nxtText ?? btnShowHidePreview.innerHTML.trim() === this.HTML_GLYPHICON_EXPAND ? this.HTML_GLYPHICON_CONTRACT : this.HTML_GLYPHICON_EXPAND;
        const isHidden = nxtText === this.HTML_GLYPHICON_EXPAND;
        const isFluff = !!evt.shiftKey;

        elePreviewWrp.classList.toggle("ve-hidden", isHidden);
        btnShowHidePreview.innerHTML = nxtText;

        const elePreviewWrpInner = elePreviewWrp.lastElementChild;

        const isForce = (elePreviewWrp.dataset.dataType === "stats" && isFluff) || (elePreviewWrp.dataset.dataType === "fluff" && !isFluff);
        if (!isForce && elePreviewWrpInner.innerHTML)
            return;

        $(elePreviewWrpInner).empty().off("click").on("click", evt=>{
            evt.stopPropagation();
        }
        );

        if (isHidden)
            return;

        elePreviewWrp.dataset.dataType = isFluff ? "fluff" : "stats";

        const doAppendStatView = ()=>($fnGetPreviewStats || Renderer.hover.$getHoverContent_stats)(page, entity, {
            isStatic: true
        }).appendTo(elePreviewWrpInner);

        if (!evt.shiftKey || !UrlUtil.URL_TO_HASH_BUILDER[page]) {
            doAppendStatView();
            return;
        }

        Renderer.hover.pGetHoverableFluff(page, entity.source, UrlUtil.URL_TO_HASH_BUILDER[page](entity)).then(fluffEntity=>{
            if (elePreviewWrpInner.innerHTML)
                return;

            if (!fluffEntity)
                return doAppendStatView();
            Renderer.hover.$getHoverContent_fluff(page, fluffEntity).appendTo(elePreviewWrpInner);
        }
        );
    }

    static getOrAddListItemPreviewLazy(item) {
        let elePreviewWrp;
        if (item.ele.children.length === 1) {
            elePreviewWrp = e_({
                ag: "div",
                clazz: "ve-hidden ve-flex",
                children: [e_({
                    tag: "div",
                    clazz: "col-0-5"
                }), e_({
                    tag: "div",
                    clazz: "col-11-5 ui-list__wrp-preview py-2 pr-2"
                }), ],
            }).appendTo(item.ele);
        } else
            elePreviewWrp = item.ele.lastElementChild;
        return elePreviewWrp;
    }

    static bindPreviewAllButton($btnAll, list) {
        $btnAll.click(async()=>{
            const nxtHtml = $btnAll.html() === ListUiUtil$1.HTML_GLYPHICON_EXPAND ? ListUiUtil$1.HTML_GLYPHICON_CONTRACT : ListUiUtil$1.HTML_GLYPHICON_EXPAND;

            if (nxtHtml === ListUiUtil$1.HTML_GLYPHICON_CONTRACT && list.visibleItems.length > 500) {
                const isSure = await InputUiUtil$1.pGetUserBoolean({
                    title: "Are You Sure?",
                    htmlDescription: `You are about to expand ${list.visibleItems.length} rows. This may seriously degrade performance.<br>Are you sure you want to continue?`,
                });
                if (!isSure)
                    return;
            }

            $btnAll.html(nxtHtml);

            list.visibleItems.forEach(listItem=>{
                if (listItem.data.btnShowHidePreview.innerHTML !== nxtHtml)
                    listItem.data.btnShowHidePreview.click();
            }
            );
        }
        );
    }

    static ListSyntax = class {
        static _READONLY_WALKER = null;

        constructor({fnGetDataList, pFnGetFluff, }, ) {
            this._fnGetDataList = fnGetDataList;
            this._pFnGetFluff = pFnGetFluff;
        }

        get _dataList() {
            return this._fnGetDataList();
        }

        build() {
            return {
                stats: {
                    help: `"stats:<text>" ("/text/" for regex) to search within stat blocks.`,
                    fn: (listItem,searchTerm)=>{
                        if (listItem.data._textCacheStats == null)
                            listItem.data._textCacheStats = this._getSearchCacheStats(this._dataList[listItem.ix]);
                        return this._listSyntax_isTextMatch(listItem.data._textCacheStats, searchTerm);
                    }
                    ,
                },
                info: {
                    help: `"info:<text>" ("/text/" for regex) to search within info.`,
                    fn: async(listItem,searchTerm)=>{
                        if (listItem.data._textCacheFluff == null)
                            listItem.data._textCacheFluff = await this._pGetSearchCacheFluff(this._dataList[listItem.ix]);
                        return this._listSyntax_isTextMatch(listItem.data._textCacheFluff, searchTerm);
                    }
                    ,
                    isAsync: true,
                },
                text: {
                    help: `"text:<text>" ("/text/" for regex) to search within stat blocks plus info.`,
                    fn: async(listItem,searchTerm)=>{
                        if (listItem.data._textCacheAll == null) {
                            const {textCacheStats, textCacheFluff, textCacheAll} = await this._pGetSearchCacheAll(this._dataList[listItem.ix], {
                                textCacheStats: listItem.data._textCacheStats,
                                textCacheFluff: listItem.data._textCacheFluff
                            });
                            listItem.data._textCacheStats = listItem.data._textCacheStats || textCacheStats;
                            listItem.data._textCacheFluff = listItem.data._textCacheFluff || textCacheFluff;
                            listItem.data._textCacheAll = textCacheAll;
                        }
                        return this._listSyntax_isTextMatch(listItem.data._textCacheAll, searchTerm);
                    }
                    ,
                    isAsync: true,
                },
            };
        }

        _listSyntax_isTextMatch(str, searchTerm) {
            if (!str)
                return false;
            if (searchTerm instanceof RegExp)
                return searchTerm.test(str);
            return str.includes(searchTerm);
        }

        _getSearchCacheStats(entity) {
            return this._getSearchCache_entries(entity);
        }

        static _INDEXABLE_PROPS_ENTRIES = ["entries", ];

        _getSearchCache_entries(entity, {indexableProps=null}={}) {
            if ((indexableProps || this.constructor._INDEXABLE_PROPS_ENTRIES).every(it=>!entity[it]))
                return "";
            const ptrOut = {
                _: ""
            };
            (indexableProps || this.constructor._INDEXABLE_PROPS_ENTRIES).forEach(it=>this._getSearchCache_handleEntryProp(entity, it, ptrOut));
            return ptrOut._;
        }

        _getSearchCache_handleEntryProp(entity, prop, ptrOut) {
            if (!entity[prop])
                return;

            this.constructor._READONLY_WALKER = this.constructor._READONLY_WALKER || MiscUtil.getWalker({
                keyBlocklist: new Set(["type", "colStyles", "style"]),
                isNoModification: true,
            });

            this.constructor._READONLY_WALKER.walk(entity[prop], {
                string: (str)=>this._getSearchCache_handleString(ptrOut, str),
            }, );
        }

        _getSearchCache_handleString(ptrOut, str) {
            ptrOut._ += `${Renderer.stripTags(str).toLowerCase()} -- `;
        }

        async _pGetSearchCacheFluff(entity) {
            const fluff = this._pFnGetFluff ? await this._pFnGetFluff(entity) : null;
            return fluff ? this._getSearchCache_entries(fluff, {
                indexableProps: ["entries"]
            }) : "";
        }

        async _pGetSearchCacheAll(entity, {textCacheStats=null, textCacheFluff=null}) {
            textCacheStats = textCacheStats || this._getSearchCacheStats(entity);
            textCacheFluff = textCacheFluff || await this._pGetSearchCacheFluff(entity);
            return {
                textCacheStats,
                textCacheFluff,
                textCacheAll: [textCacheStats, textCacheFluff].filter(Boolean).join(" -- "),
            };
        }
    }
    ;

}
;
ListUiUtil$1.HTML_GLYPHICON_EXPAND = `[+]`;
ListUiUtil$1.HTML_GLYPHICON_CONTRACT = `[\u2012]`;

globalThis.ListUiUtil = ListUiUtil$1;
//#endregion

//#region ComponentUiUtil
class ComponentUiUtil {
    static trackHook(hooks, prop, hook) {
        hooks[prop] = hooks[prop] || [];
        hooks[prop].push(hook);
    }

    static $getDisp(comp, prop, {html, $ele, fnGetText}={}) {
        $ele = ($ele || $(html || `<div></div>`));

        const hk = ()=>$ele.text(fnGetText ? fnGetText(comp._state[prop]) : comp._state[prop]);
        comp._addHookBase(prop, hk);
        hk();

        return $ele;
    }

    static $getIptInt(component, prop, fallbackEmpty=0, opts) {
        return ComponentUiUtil._$getIptNumeric(component, prop, UiUtil$1.strToInt, fallbackEmpty, opts);
    }

    static $getIptNumber(component, prop, fallbackEmpty=0, opts) {
        return ComponentUiUtil._$getIptNumeric(component, prop, UiUtil$1.strToNumber, fallbackEmpty, opts);
    }

    static _$getIptNumeric(component, prop, fnConvert, fallbackEmpty=0, opts) {
        opts = opts || {};
        opts.offset = opts.offset || 0;

        const setIptVal = ()=>{
            if (opts.isAllowNull && component._state[prop] == null) {
                return $ipt.val(null);
            }

            const num = (component._state[prop] || 0) + opts.offset;
            const val = opts.padLength ? `${num}`.padStart(opts.padLength, "0") : num;
            $ipt.val(val);
        }
        ;

        const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal text-right">`)).disableSpellcheck().keydown(evt=>{
            if (evt.key === "Escape")
                $ipt.blur();
        }
        ).change(()=>{
            const raw = $ipt.val().trim();
            const cur = component._state[prop];

            if (opts.isAllowNull && !raw)
                return component._state[prop] = null;

            if (raw.startsWith("=")) {
                component._state[prop] = fnConvert(raw.slice(1), fallbackEmpty, opts) - opts.offset;
            } else {
                const mUnary = prevValue != null && prevValue < 0 ? /^[+/*^]/.exec(raw) : /^[-+/*^]/.exec(raw);
                if (mUnary) {
                    let proc = raw;
                    proc = proc.slice(1).trim();
                    const mod = fnConvert(proc, fallbackEmpty, opts);
                    const full = `${cur}${mUnary[0]}${mod}`;
                    component._state[prop] = fnConvert(full, fallbackEmpty, opts) - opts.offset;
                } else {
                    component._state[prop] = fnConvert(raw, fallbackEmpty, opts) - opts.offset;
                }
            }

            if (cur === component._state[prop])
                setIptVal();
        }
        );

        let prevValue;
        const hook = ()=>{
            prevValue = component._state[prop];
            setIptVal();
        }
        ;
        if (opts.hookTracker)
            ComponentUiUtil.trackHook(opts.hookTracker, prop, hook);
        component._addHookBase(prop, hook);
        hook();

        if (opts.asMeta)
            return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
        else
            return $ipt;
    }

    static $getIptStr(component, prop, opts) {
        opts = opts || {};

        if ((opts.decorationLeft || opts.decorationRight) && !opts.asMeta)
            throw new Error(`Input must be created with "asMeta" option`);

        const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`)).keydown(evt=>{
            if (evt.key === "Escape")
                $ipt.blur();
        }
        ).disableSpellcheck();
        UiUtil.bindTypingEnd({
            $ipt,
            fnKeyup: ()=>{
                const nxtVal = opts.isNoTrim ? $ipt.val() : $ipt.val().trim();
                component._state[prop] = opts.isAllowNull && !nxtVal ? null : nxtVal;
            }
            ,
        });

        if (opts.placeholder)
            $ipt.attr("placeholder", opts.placeholder);

        if (opts.autocomplete && opts.autocomplete.length)
            $ipt.typeahead({
                source: opts.autocomplete
            });
        const hook = ()=>{
            if (component._state[prop] == null)
                $ipt.val(null);
            else {
                if ($ipt.val().trim() !== component._state[prop])
                    $ipt.val(component._state[prop]);
            }
        }
        ;
        component._addHookBase(prop, hook);
        hook();

        if (opts.asMeta)
            return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
        else
            return $ipt;
    }

    static _getIptDecoratedMeta(component, prop, $ipt, hook, opts) {
        const out = {
            $ipt,
            unhook: ()=>component._removeHookBase(prop, hook)
        };

        if (opts.decorationLeft || opts.decorationRight) {
            let $decorLeft;
            let $decorRight;

            if (opts.decorationLeft) {
                $ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--left`);
                $decorLeft = ComponentUiUtil._$getDecor(component, prop, $ipt, opts.decorationLeft, "left", opts);
            }

            if (opts.decorationRight) {
                $ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--right`);
                $decorRight = ComponentUiUtil._$getDecor(component, prop, $ipt, opts.decorationRight, "right", opts);
            }

            out.$wrp = $$`<div class="relative w-100">${$ipt}${$decorLeft}${$decorRight}</div>`;
        }

        return out;
    }

    static _$getDecor(component, prop, $ipt, decorType, side, opts) {
        switch (decorType) {
        case "search":
            {
                return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>`);
            }
        case "clear":
            {
                return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} ve-flex-vh-center clickable" title="Clear"><span class="glyphicon glyphicon-remove"></span></div>`).click(()=>$ipt.val("").change().keydown().keyup());
            }
        case "ticker":
            {
                const isValidValue = val=>{
                    if (opts.max != null && val > opts.max)
                        return false;
                    if (opts.min != null && val < opts.min)
                        return false;
                    return true;
                }
                ;

                const handleClick = (delta)=>{
                    const nxt = component._state[prop] + delta;
                    if (!isValidValue(nxt))
                        return;
                    component._state[prop] = nxt;
                    $ipt.focus();
                }
                ;

                const $btnUp = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">+</button>`).click(()=>handleClick(1));

                const $btnDown = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">\u2012</button>`).click(()=>handleClick(-1));

                return $$`<div class="ui-ideco__wrp ui-ideco__wrp--${side} ve-flex-vh-center ve-flex-col">
					${$btnUp}
					${$btnDown}
				</div>`;
            }
        case "spacer":
            {
                return "";
            }
        default:
            throw new Error(`Unimplemented!`);
        }
    }

    static $getIptEntries(component, prop, opts) {
        opts = opts || {};

        const $ipt = (opts.$ele || $(`<textarea class="form-control input-xs form-control--minimal resize-vertical"></textarea>`)).keydown(evt=>{
            if (evt.key === "Escape")
                $ipt.blur();
        }
        ).change(()=>component._state[prop] = UiUtil$1.getTextAsEntries($ipt.val().trim()));
        const hook = ()=>$ipt.val(UiUtil$1.getEntriesAsText(component._state[prop]));
        component._addHookBase(prop, hook);
        hook();
        return $ipt;
    }

    static $getIptColor(component, prop, opts) {
        opts = opts || {};

        const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal ui__ipt-color" type="color">`)).change(()=>component._state[prop] = $ipt.val());
        const hook = ()=>$ipt.val(component._state[prop]);
        component._addHookBase(prop, hook);
        hook();
        return $ipt;
    }

    static getBtnBool(component, prop, opts) {
        opts = opts || {};

        let ele = opts.ele;
        if (opts.html)
            ele = e_({
                outer: opts.html
            });

        const activeClass = opts.activeClass || "active";
        const stateName = opts.stateName || "state";
        const stateProp = opts.stateProp || `_${stateName}`;

        const btn = (ele ? e_({
            ele
        }) : e_({
            ele: ele,
            tag: "button",
            clazz: "btn btn-xs btn-default",
            text: opts.text || "Toggle",
        })).onClick(()=>component[stateProp][prop] = !component[stateProp][prop]).onContextmenu(evt=>{
            evt.preventDefault();
            component[stateProp][prop] = !component[stateProp][prop];
        }
        );

        const hk = ()=>{
            btn.toggleClass(activeClass, opts.isInverted ? !component[stateProp][prop] : !!component[stateProp][prop]);
            if (opts.activeTitle || opts.inactiveTitle)
                btn.title(component[stateProp][prop] ? (opts.activeTitle || opts.title || "") : (opts.inactiveTitle || opts.title || ""));
            if (opts.fnHookPost)
                opts.fnHookPost(component[stateProp][prop]);
        }
        ;
        component._addHook(stateName, prop, hk);
        hk();

        return btn;
    }

    static $getBtnBool(component, prop, opts) {
        const nxtOpts = {
            ...opts
        };
        if (nxtOpts.$ele) {
            nxtOpts.ele = nxtOpts.$ele[0];
            delete nxtOpts.$ele;
        }
        return $(this.getBtnBool(component, prop, nxtOpts));
    }

    static $getCbBool(component, prop, opts) {
        opts = opts || {};

        const stateName = opts.stateName || "state";
        const stateProp = opts.stateProp || `_${stateName}`;

        const cb = e_({
            tag: "input",
            type: "checkbox",
            keydown: evt=>{
                if (evt.key === "Escape")
                    cb.blur();
            }
            ,
            change: ()=>{
                if (opts.isTreatIndeterminateNullAsPositive && component[stateProp][prop] == null) {
                    component[stateProp][prop] = false;
                    return;
                }

                component[stateProp][prop] = cb.checked;
            }
            ,
        });

        const hook = ()=>{
            cb.checked = !!component[stateProp][prop];
            if (opts.isDisplayNullAsIndeterminate)
                cb.indeterminate = component[stateProp][prop] == null;
        }
        ;
        component._addHook(stateName, prop, hook);
        hook();

        const $cb = $(cb);

        return opts.asMeta ? ({
            $cb,
            unhook: ()=>component._removeHook(stateName, prop, hook)
        }) : $cb;
    }

    /**Create a dropdown menu with options to click on (used to create a class dropdown menu at least) */
    static $getSelSearchable(comp, prop, opts) {
        opts = opts || {};

        //UI Dropdown element
        const $iptDisplay = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
        .addClass("ui-sel2__ipt-display").attr("tabindex", "-1").click(()=>{
            if (opts.isDisabled){return;}
            $iptSearch.focus().select();
        }
        ).prop("disabled", !!opts.isDisabled);
        //$iptDisplay.disableSpellcheck();
        $iptDisplay.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");

        const handleSearchChange = ()=>{
            const cleanTerm = this._$getSelSearchable_getSearchString($iptSearch.val());
            metaOptions.forEach(it=>{
                it.isVisible = it.searchTerm.includes(cleanTerm);
                it.$ele.toggleVe(it.isVisible && !it.isForceHidden);
            });
        };

        const handleSearchChangeDebounced = MiscUtil.debounce(handleSearchChange, 30);

        const $iptSearch = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`)).addClass("absolute ui-sel2__ipt-search").keydown(evt=>{
            if (opts.isDisabled)
                return;

            switch (evt.key) {
            case "Escape":
                evt.stopPropagation();
                return $iptSearch.blur();

            case "ArrowDown":
                {
                    evt.preventDefault();
                    const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                    if (!visibleMetaOptions.length)
                        return;
                    visibleMetaOptions[0].$ele.focus();
                    break;
                }

            case "Enter":
            case "Tab":
                {
                    const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                    if (!visibleMetaOptions.length)
                        return;
                    comp._state[prop] = visibleMetaOptions[0].value;
                    $iptSearch.blur();
                    break;
                }

            default:
                handleSearchChangeDebounced();
            }
        }
        ).change(()=>handleSearchChangeDebounced()).click(()=>{
            if (opts.isDisabled)
                return;
            $iptSearch.focus().select();
        }
        ).prop("disabled", !!opts.isDisabled)//.disableSpellcheck();
        .attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");

        //This object will be the parent of our choices in the dropdown menu
        const $wrpChoices = $$`<div class="absolute ui-sel2__wrp-options overflow-y-scroll"></div>`;
        const $wrp = $$`<div class="ve-flex relative ui-sel2__wrp w-100 overflow-x-vis">
			${$iptDisplay}
			${$iptSearch}
		</div>`;

        

        const procValues = opts.isAllowNull ? [null, ...opts.values] : opts.values;
        //Create dropdown options here
        const metaOptions = procValues.map((v,i)=>{
            const display = v == null ? (opts.displayNullAs || "\u2014") : opts.fnDisplay ? opts.fnDisplay(v) : v;
            const additionalStyleClasses = opts.fnGetAdditionalStyleClasses ? opts.fnGetAdditionalStyleClasses(v) : null;

            //V is an index that points to a class

            //Here we create an option in the dropdown menu
            const $ele = $(`<div class="ve-flex-v-center py-1 px-1 clickable ui-sel2__disp-option
                ${v == null ? `italic` : ""} ${additionalStyleClasses ? additionalStyleClasses.join(" ") : ""}" tabindex="0">${display}</div>`)
            .click(()=>{ //When an option is clicked
                console.log("BTN CLICKED");
                if (opts.isDisabled){return;}
                //here is where _state first gets set with the [propIxClass] thingy
                //this should probably trigger an event (because _state is a proxy and can run events when something is setted)
                comp._state[prop] = v; 
                $(document.activeElement).blur();
                $wrp.addClass("no-events");
                setTimeout(()=>$wrp.removeClass("no-events"), 50);
            })
            .keydown(evt=>{
                if (opts.isDisabled)
                    return;

                switch (evt.key) {
                case "Escape":
                    evt.stopPropagation();
                    return $ele.blur();

                case "ArrowDown":
                    {
                        evt.preventDefault();
                        const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                        if (!visibleMetaOptions.length)
                            return;
                        const ixCur = visibleMetaOptions.indexOf(out);
                        const nxt = visibleMetaOptions[ixCur + 1];
                        if (nxt)
                            nxt.$ele.focus();
                        break;
                    }

                case "ArrowUp":
                    {
                        evt.preventDefault();
                        const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                        if (!visibleMetaOptions.length)
                            return;
                        const ixCur = visibleMetaOptions.indexOf(out);
                        const prev = visibleMetaOptions[ixCur - 1];
                        if (prev)
                            return prev.$ele.focus();
                        $iptSearch.focus();
                        break;
                    }

                case "Enter":
                    {
                        comp._state[prop] = v;
                        $ele.blur();
                        break;
                    }
                }
            }
            ).appendTo($wrpChoices);


            //TEMPFIX
            const isForceHidden = false; //opts.isHiddenPerValue && !!(opts.isAllowNull ? opts.isHiddenPerValue[i - 1] : opts.isHiddenPerValue[i]);
            if (isForceHidden){$ele.hideVe();}
            
            
        
            $wrp.append($wrpChoices);

            const out = {
                value: v,
                isVisible: true,
                isForceHidden,
                searchTerm: this._$getSelSearchable_getSearchString(display),
                $ele,
            };
            
            return out;
        });

        const fnUpdateHidden = (isHiddenPerValue,isHideNull=false)=>{
            let metaOptions_ = metaOptions;

            if (opts.isAllowNull) {
                metaOptions_[0].isForceHidden = isHideNull;
                metaOptions_ = metaOptions_.slice(1);
            }

            metaOptions_.forEach((it,i)=>it.isForceHidden = !!isHiddenPerValue[i]);
            handleSearchChange();
        };

        const hk = ()=>{
            if (comp._state[prop] == null)
                $iptDisplay.addClass("italic").addClass("ve-muted").val(opts.displayNullAs || "\u2014");
            else
                $iptDisplay.removeClass("italic").removeClass("ve-muted").val(opts.fnDisplay ? opts.fnDisplay(comp._state[prop]) : comp._state[prop]);

            metaOptions.forEach(it=>it.$ele.removeClass("active"));
            const metaActive = metaOptions.find(it=>it.value == null ? comp._state[prop] == null : it.value === comp._state[prop]);
            if (metaActive)
                metaActive.$ele.addClass("active");
        };
        comp._addHookBase(prop, hk);
        hk();
        
        const arrow = $(`<div class="ui-sel2__disp-arrow absolute no-events bold">
            <span class="glyphicon glyphicon-menu-down"></span>
        </div>`);
        $wrp.append(arrow);

        return opts.asMeta ? ({
            $wrp,
            unhook: ()=>comp._removeHookBase(prop, hk),
            $iptDisplay,
            $iptSearch,
            fnUpdateHidden,
        }) : $wrp;
    }

    static _$getSelSearchable_getSearchString(str) {
        if (str == null)
            return "";
        return CleanUtil.getCleanString(str.trim().toLowerCase().replace(/\s+/g, " "));
    }

    static $getSelEnum(component, prop, {values, $ele, html, isAllowNull, fnDisplay, displayNullAs, asMeta, propProxy="state", isSetIndexes=false}={}) {
        const _propProxy = `_${propProxy}`;

        let values_;

        let $sel = $ele || (html ? $(html) : null);
        if (!$sel) {
            const sel = document.createElement("select");
            sel.className = "form-control input-xs";
            $sel = $(sel);
        }

        $sel.change(()=>{
            const ix = Number($sel.val());
            if (~ix)
                return void (component[_propProxy][prop] = isSetIndexes ? ix : values_[ix]);

            if (isAllowNull)
                return void (component[_propProxy][prop] = null);
            component[_propProxy][prop] = isSetIndexes ? 0 : values_[0];
        }
        );

        const setValues_handleResetOnMissing = ({isResetOnMissing, nxtValues})=>{
            if (!isResetOnMissing)
                return;

            if (component[_propProxy][prop] == null)
                return;

            if (isSetIndexes) {
                if (component[_propProxy][prop] >= 0 && component[_propProxy][prop] < nxtValues.length) {
                    if (isAllowNull)
                        return component[_propProxy][prop] = null;
                    return component[_propProxy][prop] = 0;
                }

                return;
            }

            if (!nxtValues.includes(component[_propProxy][prop])) {
                if (isAllowNull)
                    return component[_propProxy][prop] = null;
                return component[_propProxy][prop] = nxtValues[0];
            }
        }
        ;

        const setValues = (nxtValues,{isResetOnMissing=false, isForce=false}={})=>{
            if (!isForce && CollectionUtil.deepEquals(values_, nxtValues))
                return;
            values_ = nxtValues;
            $sel.empty();
            if (isAllowNull) {
                const opt = document.createElement("option");
                opt.value = "-1";
                opt.text = displayNullAs || "\u2014";
                $sel.append(opt);
            }
            values_.forEach((it,i)=>{
                const opt = document.createElement("option");
                opt.value = `${i}`;
                opt.text = fnDisplay ? fnDisplay(it) : it;
                $sel.append(opt);
            }
            );

            setValues_handleResetOnMissing({
                isResetOnMissing,
                nxtValues
            });

            hook();
        }
        ;

        const hook = ()=>{
            if (isSetIndexes) {
                const ix = component[_propProxy][prop] == null ? -1 : component[_propProxy][prop];
                $sel.val(`${ix}`);
                return;
            }

            const searchFor = component[_propProxy][prop] === undefined ? null : component[_propProxy][prop];
            const ix = values_.indexOf(searchFor);
            $sel.val(`${ix}`);
        }
        ;
        component._addHookBase(prop, hook);

        setValues(values);

        if (!asMeta)
            return $sel;

        return {
            $sel,
            unhook: ()=>component._removeHookBase(prop, hook),
            setValues,
        };
    }

    static $getPickEnum(component, prop, opts) {
        return this._$getPickEnumOrString(component, prop, opts);
    }

    static $getPickString(component, prop, opts) {
        return this._$getPickEnumOrString(component, prop, {
            ...opts,
            isFreeText: true
        });
    }

    static _$getPickEnumOrString(component, prop, opts) {
        opts = opts || {};

        const getSubcompValues = ()=>{
            const initialValuesArray = (opts.values || []).concat(opts.isFreeText ? MiscUtil.copyFast((component._state[prop] || [])) : []);
            const initialValsCompWith = opts.isCaseInsensitive ? component._state[prop].map(it=>it.toLowerCase()) : component._state[prop];
            return initialValuesArray.map(v=>opts.isCaseInsensitive ? v.toLowerCase() : v).mergeMap(v=>({
                [v]: component._state[prop] && initialValsCompWith.includes(v)
            }));
        }
        ;

        const initialVals = getSubcompValues();

        let $btnAdd;
        if (opts.isFreeText) {
            $btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add ml-auto">+</button>`).click(async()=>{
                const input = await InputUiUtil$1.pGetUserString();
                if (input == null || input === VeCt.SYM_UI_SKIP)
                    return;
                const inputClean = opts.isCaseInsensitive ? input.trim().toLowerCase() : input.trim();
                pickComp.getPod().set(inputClean, true);
            }
            );
        } else {
            const menu = ContextUtil.getMenu(opts.values.map(it=>new ContextUtil.Action(opts.fnDisplay ? opts.fnDisplay(it) : it,()=>pickComp.getPod().set(it, true),)));

            $btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add">+</button>`).click(evt=>ContextUtil.pOpenMenu(evt, menu));
        }

        const pickComp = BaseComponent$1.fromObject(initialVals);
        pickComp.render = function($parent) {
            $parent.empty();

            Object.entries(this._state).forEach(([k,v])=>{
                if (v === false)
                    return;

                const $btnRemove = $(`<button class="btn btn-danger ui-pick__btn-remove ve-text-center">×</button>`).click(()=>this._state[k] = false);
                const txt = `${opts.fnDisplay ? opts.fnDisplay(k) : k}`;
                $$`<div class="ve-flex mx-1 mb-1 ui-pick__disp-pill max-w-100 min-w-0"><div class="px-1 ui-pick__disp-text ve-flex-v-center text-clip-ellipsis" title="${txt.qq()}">${txt}</div>${$btnRemove}</div>`.appendTo($parent);
            }
            );
        }
        ;

        const $wrpPills = $(`<div class="ve-flex ve-flex-wrap max-w-100 min-w-0"></div>`);
        const $wrp = $$`<div class="ve-flex-v-center w-100">${$btnAdd}${$wrpPills}</div>`;
        pickComp._addHookAll("state", ()=>{
            component._state[prop] = Object.keys(pickComp._state).filter(k=>pickComp._state[k]);
            pickComp.render($wrpPills);
        }
        );
        pickComp.render($wrpPills);

        const hkParent = ()=>pickComp._proxyAssignSimple("state", getSubcompValues(), true);
        component._addHookBase(prop, hkParent);

        return $wrp;
    }

    static $getCbsEnum(component, prop, opts) {
        opts = opts || {};

        const $wrp = $(`<div class="ve-flex-col w-100"></div>`);
        const metas = opts.values.map(it=>{
            const $cb = $(`<input type="checkbox">`).keydown(evt=>{
                if (evt.key === "Escape")
                    $cb.blur();
            }
            ).change(()=>{
                let didUpdate = false;
                const ix = (component._state[prop] || []).indexOf(it);
                if (~ix)
                    component._state[prop].splice(ix, 1);
                else {
                    if (component._state[prop])
                        component._state[prop].push(it);
                    else {
                        didUpdate = true;
                        component._state[prop] = [it];
                    }
                }
                if (!didUpdate)
                    component._state[prop] = [...component._state[prop]];
            }
            );

            $$`<label class="split-v-center my-1 stripe-odd ${opts.isIndent ? "ml-4" : ""}"><div class="no-wrap ve-flex-v-center">${opts.fnDisplay ? opts.fnDisplay(it) : it}</div>${$cb}</label>`.appendTo($wrp);

            return {
                $cb,
                value: it
            };
        }
        );

        const hook = ()=>metas.forEach(meta=>meta.$cb.prop("checked", component._state[prop] && component._state[prop].includes(meta.value)));
        component._addHookBase(prop, hook);
        hook();

        return opts.asMeta ? {
            $wrp,
            unhook: ()=>component._removeHookBase(prop, hook)
        } : $wrp;
    }

    static getMetaWrpMultipleChoice(comp, prop, opts) {
        opts = opts || {};
        this._getMetaWrpMultipleChoice_doValidateOptions(opts);

        const rowMetas = [];
        const $eles = [];
        const ixsSelectionOrder = [];
        const $elesSearchable = {};

        const propIsAcceptable = this.getMetaWrpMultipleChoice_getPropIsAcceptable(prop);
        const propPulse = this.getMetaWrpMultipleChoice_getPropPulse(prop);
        const propIxMax = this._getMetaWrpMultipleChoice_getPropValuesLength(prop);

        const cntRequired = ((opts.required || []).length) + ((opts.ixsRequired || []).length);
        const count = opts.count != null ? opts.count - cntRequired : null;
        const countIncludingRequired = opts.count != null ? count + cntRequired : null;
        const min = opts.min != null ? opts.min - cntRequired : null;
        const max = opts.max != null ? opts.max - cntRequired : null;

        const valueGroups = opts.valueGroups || [{
            values: opts.values
        }];

        let ixValue = 0;
        valueGroups.forEach((group,i)=>{
            if (i !== 0)
                $eles.push($(`<hr class="w-100 hr-2 hr--dotted">`));

            if (group.name) {
                const $wrpName = $$`<div class="split-v-center py-1">
					<div class="ve-flex-v-center"><span class="mr-2">‒</span><span>${group.name}</span></div>
					${opts.valueGroupSplitControlsLookup?.[group.name]}
				</div>`;
                $eles.push($wrpName);
            }

            if (group.text)
                $eles.push($(`<div class="ve-flex-v-center py-1"><div class="ml-1 mr-3"></div><i>${group.text}</i></div>`));

            group.values.forEach(v=>{
                const ixValueFrozen = ixValue;

                const propIsActive = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixValueFrozen);
                const propIsRequired = this.getMetaWrpMultipleChoice_getPropIsRequired(prop, ixValueFrozen);

                const isHardRequired = (opts.required && opts.required.includes(v)) || (opts.ixsRequired && opts.ixsRequired.includes(ixValueFrozen));
                const isRequired = isHardRequired || comp._state[propIsRequired];

                if (comp._state[propIsActive] && !comp._state[propIsRequired])
                    ixsSelectionOrder.push(ixValueFrozen);

                let hk;
                const $cb = isRequired ? $(`<input type="checkbox" disabled checked title="This option is required.">`) : ComponentUiUtil.$getCbBool(comp, propIsActive);

                if (isRequired)
                    comp._state[propIsActive] = true;

                if (!isRequired) {
                    hk = ()=>{
                        const ixIx = ixsSelectionOrder.findIndex(it=>it === ixValueFrozen);
                        if (~ixIx)
                            ixsSelectionOrder.splice(ixIx, 1);
                        if (comp._state[propIsActive])
                            ixsSelectionOrder.push(ixValueFrozen);

                        const activeRows = rowMetas.filter(it=>comp._state[it.propIsActive]);

                        if (count != null) {
                            if (activeRows.length > countIncludingRequired) {
                                const ixFirstSelected = ixsSelectionOrder.splice(ixsSelectionOrder.length - 2, 1)[0];
                                if (ixFirstSelected != null) {
                                    const propIsActiveOther = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixFirstSelected);
                                    comp._state[propIsActiveOther] = false;

                                    comp._state[propPulse] = !comp._state[propPulse];
                                }
                                return;
                            }
                        }

                        let isAcceptable = false;
                        if (count != null) {
                            if (activeRows.length === countIncludingRequired)
                                isAcceptable = true;
                        } else {
                            if (activeRows.length >= (min || 0) && activeRows.length <= (max || Number.MAX_SAFE_INTEGER))
                                isAcceptable = true;
                        }

                        comp._state[propIsAcceptable] = isAcceptable;

                        comp._state[propPulse] = !comp._state[propPulse];
                    }
                    ;
                    comp._addHookBase(propIsActive, hk);
                    hk();
                }

                const displayValue = opts.fnDisplay ? opts.fnDisplay(v, ixValueFrozen) : v;

                rowMetas.push({
                    $cb,
                    displayValue,
                    value: v,
                    propIsActive,
                    unhook: ()=>{
                        if (hk)
                            comp._removeHookBase(propIsActive, hk);
                    }
                    ,
                });

                const $ele = $$`<label class="ve-flex-v-center py-1 stripe-even">
					<div class="col-1 ve-flex-vh-center">${$cb}</div>
					<div class="col-11 ve-flex-v-center">${displayValue}</div>
				</label>`;
                $eles.push($ele);

                if (opts.isSearchable) {
                    const searchText = `${opts.fnGetSearchText ? opts.fnGetSearchText(v, ixValueFrozen) : v}`.toLowerCase().trim();
                    ($elesSearchable[searchText] = $elesSearchable[searchText] || []).push($ele);
                }

                ixValue++;
            }
            );
        }
        );

        ixsSelectionOrder.sort((a,b)=>SortUtil.ascSort(a, b));

        comp.__state[propIxMax] = ixValue;

        let $iptSearch;
        if (opts.isSearchable) {
            const compSub = BaseComponent$1.fromObject({
                search: ""
            });
            $iptSearch = ComponentUiUtil.$getIptStr(compSub, "search");
            const hkSearch = ()=>{
                const cleanSearch = compSub._state.search.trim().toLowerCase();
                if (!cleanSearch) {
                    Object.values($elesSearchable).forEach($eles=>$eles.forEach($ele=>$ele.removeClass("ve-hidden")));
                    return;
                }

                Object.entries($elesSearchable).forEach(([searchText,$eles])=>$eles.forEach($ele=>$ele.toggleVe(searchText.includes(cleanSearch))));
            }
            ;
            compSub._addHookBase("search", hkSearch);
            hkSearch();
        }

        const unhook = ()=>rowMetas.forEach(it=>it.unhook());
        return {
            $ele: $$`<div class="ve-flex-col w-100 overflow-y-auto">${$eles}</div>`,
            $iptSearch,
            rowMetas,
            propIsAcceptable,
            propPulse,
            unhook,
            cleanup: ()=>{
                unhook();
                Object.keys(comp._state).filter(it=>it.startsWith(`${prop}__`)).forEach(it=>delete comp._state[it]);
            }
            ,
        };
    }

    static getMetaWrpMultipleChoice_getPropIsAcceptable(prop) {
        return `${prop}__isAcceptable`;
    }
    static getMetaWrpMultipleChoice_getPropPulse(prop) {
        return `${prop}__pulse`;
    }
    static _getMetaWrpMultipleChoice_getPropValuesLength(prop) {
        return `${prop}__length`;
    }
    static getMetaWrpMultipleChoice_getPropIsActive(prop, ixValue) {
        return `${prop}__isActive_${ixValue}`;
    }
    static getMetaWrpMultipleChoice_getPropIsRequired(prop, ixValue) {
        return `${prop}__isRequired_${ixValue}`;
    }

    static getMetaWrpMultipleChoice_getSelectedIxs(comp, prop) {
        const out = [];
        const len = comp._state[this._getMetaWrpMultipleChoice_getPropValuesLength(prop)] || 0;
        for (let i = 0; i < len; ++i) {
            if (comp._state[this.getMetaWrpMultipleChoice_getPropIsActive(prop, i)])
                out.push(i);
        }
        return out;
    }

    static getMetaWrpMultipleChoice_getSelectedValues(comp, prop, {values, valueGroups}) {
        const selectedIxs = this.getMetaWrpMultipleChoice_getSelectedIxs(comp, prop);
        if (values)
            return selectedIxs.map(ix=>values[ix]);

        const selectedIxsSet = new Set(selectedIxs);
        const out = [];
        let ixValue = 0;
        valueGroups.forEach(group=>{
            group.values.forEach(v=>{
                if (selectedIxsSet.has(ixValue))
                    out.push(v);
                ixValue++;
            }
            );
        }
        );
        return out;
    }

    static _getMetaWrpMultipleChoice_doValidateOptions(opts) {
        if ((Number(!!opts.values) + Number(!!opts.valueGroups)) !== 1)
            throw new Error(`Exactly one of "values" and "valueGroups" must be specified!`);

        if (opts.count != null && (opts.min != null || opts.max != null))
            throw new Error(`Chooser must be either in "count" mode or "min/max" mode!`);
        if (opts.count == null && opts.min == null && opts.max == null)
            opts.count = 1;
    }

    static $getSliderRange(comp, opts) {
        opts = opts || {};
        const slider = new ComponentUiUtil.RangeSlider({
            comp,
            ...opts
        });
        return slider.$get();
    }

    static $getSliderNumber(comp, prop, {min, max, step, $ele, asMeta, }={}, ) {
        const $slider = ($ele || $(`<input type="range">`)).change(()=>comp._state[prop] = Number($slider.val()));

        if (min != null)
            $slider.attr("min", min);
        if (max != null)
            $slider.attr("max", max);
        if (step != null)
            $slider.attr("step", step);

        const hk = ()=>$slider.val(comp._state[prop]);
        comp._addHookBase(prop, hk);
        hk();

        return asMeta ? ({
            $slider,
            unhook: ()=>comp._removeHookBase(prop, hk)
        }) : $slider;
    }
}

ComponentUiUtil.RangeSlider = class {
    constructor({comp, propMin, propMax, propCurMin, propCurMax, fnDisplay, fnDisplayTooltip, sparseValues, }, ) {
        this._comp = comp;
        this._propMin = propMin;
        this._propMax = propMax;
        this._propCurMin = propCurMin;
        this._propCurMax = propCurMax;
        this._fnDisplay = fnDisplay;
        this._fnDisplayTooltip = fnDisplayTooltip;
        this._sparseValues = sparseValues;

        this._isSingle = !this._propCurMax;

        const compCpyState = {
            [this._propMin]: this._comp._state[this._propMin],
            [this._propCurMin]: this._comp._state[this._propCurMin],
            [this._propMax]: this._comp._state[this._propMax],
        };
        if (!this._isSingle)
            compCpyState[this._propCurMax] = this._comp._state[this._propCurMax];
        this._compCpy = BaseComponent$1.fromObject(compCpyState);

        this._comp._addHook("state", this._propMin, ()=>this._compCpy._state[this._propMin] = this._comp._state[this._propMin]);
        this._comp._addHook("state", this._propCurMin, ()=>this._compCpy._state[this._propCurMin] = this._comp._state[this._propCurMin]);
        this._comp._addHook("state", this._propMax, ()=>this._compCpy._state[this._propMax] = this._comp._state[this._propMax]);

        if (!this._isSingle)
            this._comp._addHook("state", this._propCurMax, ()=>this._compCpy._state[this._propCurMax] = this._comp._state[this._propCurMax]);

        this._cacheRendered = null;
        this._dispTrackOuter = null;
        this._dispTrackInner = null;
        this._thumbLow = null;
        this._thumbHigh = null;
        this._dragMeta = null;
    }

    $get() {
        const out = this.get();
        return $(out);
    }

    get() {
        this.constructor._init();
        this.constructor._ALL_SLIDERS.add(this);

        if (this._cacheRendered)
            return this._cacheRendered;

        const dispValueLeft = this._isSingle ? this._getSpcSingleValue() : this._getDispValue({
            isVisible: true,
            side: "left"
        });
        const dispValueRight = this._getDispValue({
            isVisible: true,
            side: "right"
        });

        this._dispTrackInner = this._isSingle ? null : e_({
            tag: "div",
            clazz: "ui-slidr__track-inner h-100 absolute",
        });

        this._thumbLow = this._getThumb();
        this._thumbHigh = this._isSingle ? null : this._getThumb();

        this._dispTrackOuter = e_({
            tag: "div",
            clazz: `relative w-100 ui-slidr__track-outer`,
            children: [this._dispTrackInner, this._thumbLow, this._thumbHigh, ].filter(Boolean),
        });

        const wrpTrack = e_({
            tag: "div",
            clazz: `ve-flex-v-center w-100 h-100 ui-slidr__wrp-track clickable`,
            mousedown: evt=>{
                const thumb = this._getClosestThumb(evt);
                this._handleMouseDown(evt, thumb);
            }
            ,
            children: [this._dispTrackOuter, ],
        });

        const wrpTop = e_({
            tag: "div",
            clazz: "ve-flex-v-center w-100 ui-slidr__wrp-top",
            children: [dispValueLeft, wrpTrack, dispValueRight, ].filter(Boolean),
        });

        const wrpPips = e_({
            tag: "div",
            clazz: `w-100 ve-flex relative clickable h-100 ui-slidr__wrp-pips`,
            mousedown: evt=>{
                const thumb = this._getClosestThumb(evt);
                this._handleMouseDown(evt, thumb);
            }
            ,
        });

        const wrpBottom = e_({
            tag: "div",
            clazz: "w-100 ve-flex-vh-center ui-slidr__wrp-bottom",
            children: [this._isSingle ? this._getSpcSingleValue() : this._getDispValue({
                side: "left"
            }), wrpPips, this._getDispValue({
                side: "right"
            }), ].filter(Boolean),
        });

        const hkChangeValue = ()=>{
            const curMin = this._compCpy._state[this._propCurMin];
            const pctMin = this._getLeftPositionPercentage({
                value: curMin
            });
            this._thumbLow.style.left = `calc(${pctMin}% - ${this.constructor._W_THUMB_PX / 2}px)`;
            const toDisplayLeft = this._fnDisplay ? `${this._fnDisplay(curMin)}`.qq() : curMin;
            const toDisplayLeftTooltip = this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMin)}`.qq() : null;
            if (!this._isSingle) {
                dispValueLeft.html(toDisplayLeft).tooltip(toDisplayLeftTooltip);
            }

            if (!this._isSingle) {
                this._dispTrackInner.style.left = `${pctMin}%`;

                const curMax = this._compCpy._state[this._propCurMax];
                const pctMax = this._getLeftPositionPercentage({
                    value: curMax
                });
                this._dispTrackInner.style.right = `${100 - pctMax}%`;
                this._thumbHigh.style.left = `calc(${pctMax}% - ${this.constructor._W_THUMB_PX / 2}px)`;
                dispValueRight.html(this._fnDisplay ? `${this._fnDisplay(curMax)}`.qq() : curMax).tooltip(this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMax)}`.qq() : null);
            } else {
                dispValueRight.html(toDisplayLeft).tooltip(toDisplayLeftTooltip);
            }
        }
        ;

        const hkChangeLimit = ()=>{
            const pips = [];

            if (!this._sparseValues) {
                const numPips = this._compCpy._state[this._propMax] - this._compCpy._state[this._propMin];
                let pipIncrement = 1;
                if (numPips > ComponentUiUtil.RangeSlider._MAX_PIPS)
                    pipIncrement = Math.ceil(numPips / ComponentUiUtil.RangeSlider._MAX_PIPS);

                let i, len;
                for (i = this._compCpy._state[this._propMin],
                len = this._compCpy._state[this._propMax] + 1; i < len; i += pipIncrement) {
                    pips.push(this._getWrpPip({
                        isMajor: i === this._compCpy._state[this._propMin] || i === (len - 1),
                        value: i,
                    }));
                }

                if (i !== this._compCpy._state[this._propMax])
                    pips.push(this._getWrpPip({
                        isMajor: true,
                        value: this._compCpy._state[this._propMax]
                    }));
            } else {
                const len = this._sparseValues.length;
                this._sparseValues.forEach((val,i)=>{
                    pips.push(this._getWrpPip({
                        isMajor: i === 0 || i === (len - 1),
                        value: val,
                    }));
                }
                );
            }

            wrpPips.empty();
            e_({
                ele: wrpPips,
                children: pips,
            });

            hkChangeValue();
        }
        ;

        this._compCpy._addHook("state", this._propMin, hkChangeLimit);
        this._compCpy._addHook("state", this._propMax, hkChangeLimit);
        this._compCpy._addHook("state", this._propCurMin, hkChangeValue);
        if (!this._isSingle)
            this._compCpy._addHook("state", this._propCurMax, hkChangeValue);

        hkChangeLimit();

        const wrp = e_({
            tag: "div",
            clazz: "ve-flex-col w-100 ui-slidr__wrp",
            children: [wrpTop, wrpBottom, ],
        });

        return this._cacheRendered = wrp;
    }

    destroy() {
        this.constructor._ALL_SLIDERS.delete(this);
        if (this._cacheRendered)
            this._cacheRendered.remove();
    }

    _getDispValue({isVisible, side}) {
        return e_({
            tag: "div",
            clazz: `overflow-hidden ui-slidr__disp-value no-shrink no-grow ve-flex-vh-center bold no-select ${isVisible ? `ui-slidr__disp-value--visible` : ""} ui-slidr__disp-value--${side}`,
        });
    }

    _getSpcSingleValue() {
        return e_({
            tag: "div",
            clazz: `px-2`,
        });
    }

    _getThumb() {
        const thumb = e_({
            tag: "div",
            clazz: "ui-slidr__thumb absolute clickable",
            mousedown: evt=>this._handleMouseDown(evt, thumb),
        }).attr("draggable", true);

        return thumb;
    }

    _getWrpPip({isMajor, value}={}) {
        const style = this._getWrpPip_getStyle({
            value
        });

        const pip = e_({
            tag: "div",
            clazz: `ui-slidr__pip ${isMajor ? `ui-slidr__pip--major` : `absolute`}`,
        });

        const dispLabel = e_({
            tag: "div",
            clazz: "absolute ui-slidr__pip-label ve-flex-vh-center ve-small no-wrap",
            html: isMajor ? this._fnDisplay ? `${this._fnDisplay(value)}`.qq() : value : "",
            title: isMajor && this._fnDisplayTooltip ? `${this._fnDisplayTooltip(value)}`.qq() : null,
        });

        return e_({
            tag: "div",
            clazz: "ve-flex-col ve-flex-vh-center absolute no-select",
            children: [pip, dispLabel, ],
            style,
        });
    }

    _getWrpPip_getStyle({value}) {
        return `left: ${this._getLeftPositionPercentage({
            value
        })}%`;
    }

    _getLeftPositionPercentage({value}) {
        if (this._sparseValues) {
            const ix = this._sparseValues.sort(SortUtil.ascSort).indexOf(value);
            if (!~ix)
                throw new Error(`Value "${value}" was not in the list of sparse values!`);
            return (ix / (this._sparseValues.length - 1)) * 100;
        }

        const min = this._compCpy._state[this._propMin];
        const max = this._compCpy._state[this._propMax];
        return ((value - min) / (max - min)) * 100;
    }

    _getRelativeValue(evt, {trackOriginX, trackWidth}) {
        const xEvt = EventUtil.getClientX(evt) - trackOriginX;

        if (this._sparseValues) {
            const ixMax = this._sparseValues.length - 1;
            const rawVal = Math.round((xEvt / trackWidth) * ixMax);
            return this._sparseValues[Math.min(ixMax, Math.max(0, rawVal))];
        }

        const min = this._compCpy._state[this._propMin];
        const max = this._compCpy._state[this._propMax];

        const rawVal = min + Math.round((xEvt / trackWidth) * (max - min), );

        return Math.min(max, Math.max(min, rawVal));
    }

    _getClosestThumb(evt) {
        if (this._isSingle)
            return this._thumbLow;

        const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();
        const value = this._getRelativeValue(evt, {
            trackOriginX,
            trackWidth
        });

        if (value < this._compCpy._state[this._propCurMin])
            return this._thumbLow;
        if (value > this._compCpy._state[this._propCurMax])
            return this._thumbHigh;

        const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);
        if (distToMax < distToMin)
            return this._thumbHigh;
        return this._thumbLow;
    }

    _getDistsToCurrentMinAndMax(value) {
        if (this._isSingle)
            throw new Error(`Can not get distance to max value for singleton slider!`);

        const distToMin = Math.abs(this._compCpy._state[this._propCurMin] - value);
        const distToMax = Math.abs(this._compCpy._state[this._propCurMax] - value);
        return {
            distToMin,
            distToMax
        };
    }

    _handleClick(evt, value) {
        evt.stopPropagation();
        evt.preventDefault();

        if (value < this._compCpy._state[this._propCurMin])
            this._compCpy._state[this._propCurMin] = value;

        if (value > this._compCpy._state[this._propCurMax])
            this._compCpy._state[this._propCurMax] = value;

        const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);

        if (distToMax < distToMin)
            this._compCpy._state[this._propCurMax] = value;
        else
            this._compCpy._state[this._propCurMin] = value;
    }

    _handleMouseDown(evt, thumb) {
        evt.preventDefault();
        evt.stopPropagation();

        const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();

        thumb.addClass(`ui-slidr__thumb--hover`);

        this._dragMeta = {
            trackOriginX,
            trackWidth,
            thumb,
        };

        this._handleMouseMove(evt);
    }

    _handleMouseUp() {
        const wasActive = this._doDragCleanup();

        if (wasActive) {
            const nxtState = {
                [this._propMin]: this._compCpy._state[this._propMin],
                [this._propMax]: this._compCpy._state[this._propMax],
                [this._propCurMin]: this._compCpy._state[this._propCurMin],
            };
            if (!this._isSingle)
                nxtState[this._propCurMax] = this._compCpy._state[this._propCurMax];

            this._comp._proxyAssignSimple("state", nxtState);
        }
    }

    _handleMouseMove(evt) {
        if (!this._dragMeta)
            return;

        const val = this._getRelativeValue(evt, this._dragMeta);

        if (this._dragMeta.thumb === this._thumbLow) {
            if (val > this._compCpy._state[this._propCurMax])
                return;
            this._compCpy._state[this._propCurMin] = val;
        } else if (this._dragMeta.thumb === this._thumbHigh) {
            if (val < this._compCpy._state[this._propCurMin])
                return;
            this._compCpy._state[this._propCurMax] = val;
        }
    }

    _doDragCleanup() {
        const isActive = this._dragMeta != null;

        if (this._dragMeta?.thumb)
            this._dragMeta.thumb.removeClass(`ui-slidr__thumb--hover`);

        this._dragMeta = null;

        return isActive;
    }

    static _init() {
        if (this._isInit)
            return;
        document.addEventListener("mousemove", evt=>{
            for (const slider of this._ALL_SLIDERS) {
                slider._handleMouseMove(evt);
            }
        }
        );

        document.addEventListener("mouseup", evt=>{
            for (const slider of this._ALL_SLIDERS) {
                slider._handleMouseUp(evt);
            }
        }
        );
    }
}
;
ComponentUiUtil.RangeSlider._isInit = false;
ComponentUiUtil.RangeSlider._ALL_SLIDERS = new Set();
ComponentUiUtil.RangeSlider._W_THUMB_PX = 16;
ComponentUiUtil.RangeSlider._W_LABEL_PX = 24;
ComponentUiUtil.RangeSlider._MAX_PIPS = 40;
//#endregion

//#region UtilPrePreInit
class UtilPrePreInit {
    static _IS_GM = null;

    static isGM() {
        return true;
        //return UtilPrePreInit._IS_GM = UtilPrePreInit._IS_GM ?? game.data.users.find(it=>it._id === game.userId).role >= CONST.USER_ROLES.ASSISTANT;
    }
}
//#endregion
//#region ContextUtil
globalThis.ContextUtil = {
    _isInit: false,
    _menus: [],

    _init() {
        if (ContextUtil._isInit)
            return;
        ContextUtil._isInit = true;

        document.body.addEventListener("click", ()=>ContextUtil.closeAllMenus());
    },

    getMenu(actions) {
        ContextUtil._init();

        const menu = new ContextUtil.Menu(actions);
        ContextUtil._menus.push(menu);
        return menu;
    },

    deleteMenu(menu) {
        if (!menu)
            return;

        menu.remove();
        const ix = ContextUtil._menus.findIndex(it=>it === menu);
        if (~ix)
            ContextUtil._menus.splice(ix, 1);
    },

    pOpenMenu(evt, menu, {userData=null}={}) {
        evt.preventDefault();
        evt.stopPropagation();

        ContextUtil._init();

        ContextUtil._menus.filter(it=>it !== menu).forEach(it=>it.close());

        return menu.pOpen(evt, {
            userData
        });
    },

    closeAllMenus() {
        ContextUtil._menus.forEach(menu=>menu.close());
    },

    Menu: class {
        constructor(actions) {
            this._actions = actions;
            this._pResult = null;
            this.resolveResult_ = null;

            this.userData = null;

            this._$ele = null;
            this._metasActions = [];

            this._menusSub = [];
        }

        remove() {
            if (!this._$ele)
                return;
            this._$ele.remove();
            this._$ele = null;
        }

        width() {
            return this._$ele ? this._$ele.width() : undefined;
        }
        height() {
            return this._$ele ? this._$ele.height() : undefined;
        }

        pOpen(evt, {userData=null, offsetY=null, boundsX=null}={}) {
            evt.stopPropagation();
            evt.preventDefault();

            this._initLazy();

            if (this.resolveResult_)
                this.resolveResult_(null);
            this._pResult = new Promise(resolve=>{
                this.resolveResult_ = resolve;
            }
            );
            this.userData = userData;

            this._$ele.css({
                left: 0,
                top: 0,
                opacity: 0,
                pointerEvents: "none",
            }).showVe().css({
                left: this._getMenuPosition(evt, "x", {
                    bounds: boundsX
                }),
                top: this._getMenuPosition(evt, "y", {
                    offset: offsetY
                }),
                opacity: "",
                pointerEvents: "",
            });

            this._metasActions[0].$eleRow.focus();

            return this._pResult;
        }

        close() {
            if (!this._$ele)
                return;
            this._$ele.hideVe();

            this.closeSubMenus();
        }

        isOpen() {
            if (!this._$ele)
                return false;
            return !this._$ele.hasClass("ve-hidden");
        }

        _initLazy() {
            if (this._$ele) {
                this._metasActions.forEach(meta=>meta.action.update());
                return;
            }

            const $elesAction = this._actions.map(it=>{
                if (it == null)
                    return $(`<div class="my-1 w-100 ui-ctx__divider"></div>`);

                const rdMeta = it.render({
                    menu: this
                });
                this._metasActions.push(rdMeta);
                return rdMeta.$eleRow;
            }
            );

            this._$ele = $$`<div class="ve-flex-col ui-ctx__wrp py-2 absolute">${$elesAction}</div>`.hideVe().appendTo(document.body);
        }

        _getMenuPosition(evt, axis, {bounds=null, offset=null}={}) {
            const {fnMenuSize, fnGetEventPos, fnWindowSize, fnScrollDir} = axis === "x" ? {
                fnMenuSize: "width",
                fnGetEventPos: "getClientX",
                fnWindowSize: "width",
                fnScrollDir: "scrollLeft"
            } : {
                fnMenuSize: "height",
                fnGetEventPos: "getClientY",
                fnWindowSize: "height",
                fnScrollDir: "scrollTop"
            };

            const posMouse = EventUtil[fnGetEventPos](evt);
            const szWin = $(window)[fnWindowSize]();
            const posScroll = $(window)[fnScrollDir]();
            let position = posMouse + posScroll;

            if (offset)
                position += offset;

            const szMenu = this[fnMenuSize]();

            if (bounds != null) {
                const {trailingLower, leadingUpper} = bounds;

                const posTrailing = position;
                const posLeading = position + szMenu;

                if (posTrailing < trailingLower) {
                    position += trailingLower - posTrailing;
                } else if (posLeading > leadingUpper) {
                    position -= posLeading - leadingUpper;
                }
            }

            if (position + szMenu > szWin && szMenu < position)
                position -= szMenu;

            return position;
        }

        addSubMenu(menu) {
            this._menusSub.push(menu);
        }

        closeSubMenus(menuSubExclude=null) {
            this._menusSub.filter(menuSub=>menuSubExclude == null || menuSub !== menuSubExclude).forEach(menuSub=>menuSub.close());
        }
    }
    ,

    Action: function(text, fnAction, opts) {
        opts = opts || {};

        this.text = text;
        this.fnAction = fnAction;

        this.isDisabled = opts.isDisabled;
        this.title = opts.title;
        this.style = opts.style;

        this.fnActionAlt = opts.fnActionAlt;
        this.textAlt = opts.textAlt;
        this.titleAlt = opts.titleAlt;

        this.render = function({menu}) {
            const $btnAction = this._render_$btnAction({
                menu
            });
            const $btnActionAlt = this._render_$btnActionAlt({
                menu
            });

            return {
                action: this,
                $eleRow: $$`<div class="ui-ctx__row ve-flex-v-center ${this.style || ""}">${$btnAction}${$btnActionAlt}</div>`,
                $eleBtn: $btnAction,
            };
        }
        ;

        this._render_$btnAction = function({menu}) {
            const $btnAction = $(`<div class="w-100 min-w-0 ui-ctx__btn py-1 pl-5 ${this.fnActionAlt ? "" : "pr-5"}" ${this.isDisabled ? "disabled" : ""} tabindex="0">${this.text}</div>`).on("click", async evt=>{
                if (this.isDisabled)
                    return;

                evt.preventDefault();
                evt.stopPropagation();

                menu.close();

                const result = await this.fnAction(evt, {
                    userData: menu.userData
                });
                if (menu.resolveResult_)
                    menu.resolveResult_(result);
            }
            ).keydown(evt=>{
                if (evt.key !== "Enter")
                    return;
                $btnAction.click();
            }
            );
            if (this.title)
                $btnAction.title(this.title);

            return $btnAction;
        }
        ;

        this._render_$btnActionAlt = function({menu}) {
            if (!this.fnActionAlt)
                return null;

            const $btnActionAlt = $(`<div class="ui-ctx__btn ml-1 bl-1 py-1 px-4" ${this.isDisabled ? "disabled" : ""}>${this.textAlt ?? `<span class="glyphicon glyphicon-cog"></span>`}</div>`).on("click", async evt=>{
                if (this.isDisabled)
                    return;

                evt.preventDefault();
                evt.stopPropagation();

                menu.close();

                const result = await this.fnActionAlt(evt, {
                    userData: menu.userData
                });
                if (menu.resolveResult_)
                    menu.resolveResult_(result);
            }
            );
            if (this.titleAlt)
                $btnActionAlt.title(this.titleAlt);

            return $btnActionAlt;
        }
        ;

        this.update = function() {}
        ;
    },

    ActionLink: function(text, fnHref, opts) {
        ContextUtil.Action.call(this, text, null, opts);

        this.fnHref = fnHref;
        this._$btnAction = null;

        this._render_$btnAction = function() {
            this._$btnAction = $(`<a href="${this.fnHref()}" class="w-100 min-w-0 ui-ctx__btn py-1 pl-5 ${this.fnActionAlt ? "" : "pr-5"}" ${this.isDisabled ? "disabled" : ""} tabindex="0">${this.text}</a>`);
            if (this.title)
                this._$btnAction.title(this.title);

            return this._$btnAction;
        }
        ;

        this.update = function() {
            this._$btnAction.attr("href", this.fnHref());
        }
        ;
    },

    ActionSelect: function({values, fnOnChange=null, fnGetDisplayValue=null, }, ) {
        this._values = values;
        this._fnOnChange = fnOnChange;
        this._fnGetDisplayValue = fnGetDisplayValue;

        this._sel = null;

        this._ixInitial = null;

        this.render = function({menu}) {
            this._sel = this._render_sel({
                menu
            });

            if (this._ixInitial != null) {
                this._sel.val(`${this._ixInitial}`);
                this._ixInitial = null;
            }

            return {
                action: this,
                $eleRow: $$`<div class="ui-ctx__row ve-flex-v-center">${this._sel}</div>`,
            };
        }
        ;

        this._render_sel = function({menu}) {
            const sel = e_({
                tag: "select",
                clazz: "w-100 min-w-0 mx-5 py-1",
                tabindex: 0,
                children: this._values.map((val,i)=>{
                    return e_({
                        tag: "option",
                        value: i,
                        text: this._fnGetDisplayValue ? this._fnGetDisplayValue(val) : val,
                    });
                }
                ),
                click: async evt=>{
                    evt.preventDefault();
                    evt.stopPropagation();
                }
                ,
                keydown: evt=>{
                    if (evt.key !== "Enter")
                        return;
                    sel.click();
                }
                ,
                change: ()=>{
                    menu.close();

                    const ix = Number(sel.val() || 0);
                    const val = this._values[ix];

                    if (this._fnOnChange)
                        this._fnOnChange(val);
                    if (menu.resolveResult_)
                        menu.resolveResult_(val);
                }
                ,
            });

            return sel;
        }
        ;

        this.setValue = function(val) {
            const ix = this._values.indexOf(val);
            if (!this._sel)
                return this._ixInitial = ix;
            this._sel.val(`${ix}`);
        }
        ;

        this.update = function() {}
        ;
    },

    ActionSubMenu: class {
        constructor(name, actions) {
            this._name = name;
            this._actions = actions;
        }

        render({menu}) {
            const menuSub = ContextUtil.getMenu(this._actions);
            menu.addSubMenu(menuSub);

            const $eleRow = $$`<div class="ui-ctx__btn py-1 px-5 split-v-center">
				<div>${this._name}</div>
				<div class="pl-4"><span class="caret caret--right"></span></div>
			</div>`.on("click", async evt=>{
                evt.stopPropagation();
                if (menuSub.isOpen())
                    return menuSub.close();

                menu.closeSubMenus(menuSub);

                const bcr = $eleRow[0].getBoundingClientRect();

                await menuSub.pOpen(evt, {
                    offsetY: bcr.top - EventUtil.getClientY(evt),
                    boundsX: {
                        trailingLower: bcr.right,
                        leadingUpper: bcr.left,
                    },
                }, );

                menu.close();
            }
            );

            return {
                action: this,
                $eleRow,
            };
        }

        update() {}
    }
    ,
};
//#endregion
//#region StrUtil
globalThis.StrUtil = {
    COMMAS_NOT_IN_PARENTHESES_REGEX: /,\s?(?![^(]*\))/g,
    COMMA_SPACE_NOT_IN_PARENTHESES_REGEX: /, (?![^(]*\))/g,

    uppercaseFirst: function(string) {
        return string.uppercaseFirst();
    },
    TITLE_LOWER_WORDS: ["a", "an", "the", "and", "but", "or", "for", "nor", "as", "at", "by", "for", "from", "in", "into", "near", "of", "on", "onto", "to", "with", "over", "von"],
    TITLE_UPPER_WORDS: ["Id", "Tv", "Dm", "Ok", "Npc", "Pc", "Tpk", "Wip", "Dc"],
    TITLE_UPPER_WORDS_PLURAL: ["Ids", "Tvs", "Dms", "Oks", "Npcs", "Pcs", "Tpks", "Wips", "Dcs"],
    IRREGULAR_PLURAL_WORDS: {
        "cactus": "cacti",
        "child": "children",
        "die": "dice",
        "djinni": "djinn",
        "dwarf": "dwarves",
        "efreeti": "efreet",
        "elf": "elves",
        "fey": "fey",
        "foot": "feet",
        "goose": "geese",
        "ki": "ki",
        "man": "men",
        "mouse": "mice",
        "ox": "oxen",
        "person": "people",
        "sheep": "sheep",
        "slaad": "slaadi",
        "tooth": "teeth",
        "undead": "undead",
        "woman": "women",
    },

    padNumber: (n,len,padder)=>{
        return String(n).padStart(len, padder);
    }
    ,

    elipsisTruncate(str, atLeastPre=5, atLeastSuff=0, maxLen=20) {
        if (maxLen >= str.length)
            return str;

        maxLen = Math.max(atLeastPre + atLeastSuff + 3, maxLen);
        let out = "";
        let remain = maxLen - (3 + atLeastPre + atLeastSuff);
        for (let i = 0; i < str.length - atLeastSuff; ++i) {
            const c = str[i];
            if (i < atLeastPre)
                out += c;
            else if ((remain--) > 0)
                out += c;
        }
        if (remain < 0)
            out += "...";
        out += str.substring(str.length - atLeastSuff, str.length);
        return out;
    },

    toTitleCase(str) {
        return str.toTitleCase();
    },
    qq(str) {
        return (str = str || "").qq();
    },
};
//#endregion
//#region CleanUtil
globalThis.CleanUtil = {
    getCleanJson(data, {isMinify=false, isFast=true}={}) {
        data = MiscUtil.copy(data);
        data = MiscUtil.getWalker().walk(data, {
            string: (str)=>CleanUtil.getCleanString(str, {
                isFast
            })
        });
        let str = isMinify ? JSON.stringify(data) : `${JSON.stringify(data, null, "\t")}\n`;
        return str.replace(CleanUtil.STR_REPLACEMENTS_REGEX, (match)=>CleanUtil.STR_REPLACEMENTS[match]);
    },

    getCleanString(str, {isFast=true}={}) {
        str = str.replace(CleanUtil.SHARED_REPLACEMENTS_REGEX, (match)=>CleanUtil.SHARED_REPLACEMENTS[match]).replace(CleanUtil._SOFT_HYPHEN_REMOVE_REGEX, "");

        if (isFast)
            return str;

        const ptrStack = {
            _: ""
        };
        CleanUtil._getCleanString_walkerStringHandler(ptrStack, 0, str);
        return ptrStack._;
    },

    _getCleanString_walkerStringHandler(ptrStack, tagCount, str) {
        const tagSplit = Renderer.splitByTags(str);
        const len = tagSplit.length;
        for (let i = 0; i < len; ++i) {
            const s = tagSplit[i];
            if (!s)
                continue;
            if (s.startsWith("{@")) {
                const [tag,text] = Renderer.splitFirstSpace(s.slice(1, -1));

                ptrStack._ += `{${tag}${text.length ? " " : ""}`;
                this._getCleanString_walkerStringHandler(ptrStack, tagCount + 1, text);
                ptrStack._ += `}`;
            } else {
                if (tagCount) {
                    ptrStack._ += s;
                } else {
                    ptrStack._ += s.replace(CleanUtil._DASH_COLLAPSE_REGEX, "$1").replace(CleanUtil._ELLIPSIS_COLLAPSE_REGEX, "$1");
                }
            }
        }
    },
};
CleanUtil.SHARED_REPLACEMENTS = {
    "’": "'",
    "‘": "'",
    "": "'",
    "…": "...",
    "\u200B": "",
    "\u2002": " ",
    "ﬀ": "ff",
    "ﬃ": "ffi",
    "ﬄ": "ffl",
    "ﬁ": "fi",
    "ﬂ": "fl",
    "Ĳ": "IJ",
    "ĳ": "ij",
    "Ǉ": "LJ",
    "ǈ": "Lj",
    "ǉ": "lj",
    "Ǌ": "NJ",
    "ǋ": "Nj",
    "ǌ": "nj",
    "ﬅ": "ft",
    "“": `"`,
    "”": `"`,
    "\u201a": ",",
};
CleanUtil.STR_REPLACEMENTS = {
    "—": "\\u2014",
    "–": "\\u2013",
    "‑": "\\u2011",
    "−": "\\u2212",
    " ": "\\u00A0",
    " ": "\\u2007",
};
CleanUtil.SHARED_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.SHARED_REPLACEMENTS).join("|"),"g");
CleanUtil.STR_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.STR_REPLACEMENTS).join("|"),"g");
CleanUtil._SOFT_HYPHEN_REMOVE_REGEX = /\u00AD *\r?\n?\r?/g;
CleanUtil._ELLIPSIS_COLLAPSE_REGEX = /\s*(\.\s*\.\s*\.)/g;
CleanUtil._DASH_COLLAPSE_REGEX = /[ ]*([\u2014\u2013])[ ]*/g;

//#endregion
//#region ExcludeUtil
globalThis.ExcludeUtil = {
    isInitialised: false,
    _excludes: null,
    _cache_excludesLookup: null,
    _lock: null,

    async pInitialise({lockToken=null}={}) {
        try {
            await ExcludeUtil._lock.pLock({
                token: lockToken
            });
            await ExcludeUtil._pInitialise();
        } finally {
            ExcludeUtil._lock.unlock();
        }
    },

    async _pInitialise() {
        if (ExcludeUtil.isInitialised)
            return;

        ExcludeUtil.pSave = MiscUtil.throttle(ExcludeUtil._pSave, 50);
        try {
            ExcludeUtil._excludes = await StorageUtil.pGet(VeCt.STORAGE_EXCLUDES) || [];
            ExcludeUtil._excludes = ExcludeUtil._excludes.filter(it=>it.hash);
        } catch (e) {
            JqueryUtil.doToast({
                content: "Error when loading content blocklist! Purged blocklist data. (See the log for more information.)",
                type: "danger",
            });
            try {
                await StorageUtil.pRemove(VeCt.STORAGE_EXCLUDES);
            } catch (e) {
                setTimeout(()=>{
                    throw e;
                }
                );
            }
            ExcludeUtil._excludes = null;
            window.location.hash = "";
            setTimeout(()=>{
                throw e;
            }
            );
        }
        ExcludeUtil.isInitialised = true;
    },

    getList() {
        return MiscUtil.copyFast(ExcludeUtil._excludes || []);
    },

    async pSetList(toSet) {
        ExcludeUtil._excludes = toSet;
        ExcludeUtil._cache_excludesLookup = null;
        await ExcludeUtil.pSave();
    },

    async pExtendList(toAdd) {
        try {
            const lockToken = await ExcludeUtil._lock.pLock();
            await ExcludeUtil._pExtendList({
                toAdd,
                lockToken
            });
        } finally {
            ExcludeUtil._lock.unlock();
        }
    },

    async _pExtendList({toAdd, lockToken}) {
        await ExcludeUtil.pInitialise({
            lockToken
        });
        this._doBuildCache();

        const out = MiscUtil.copyFast(ExcludeUtil._excludes || []);
        MiscUtil.copyFast(toAdd || []).filter(({hash, category, source})=>{
            if (!hash || !category || !source)
                return false;
            const cacheUid = ExcludeUtil._getCacheUids(hash, category, source, true);
            return !ExcludeUtil._cache_excludesLookup[cacheUid];
        }
        ).forEach(it=>out.push(it));

        await ExcludeUtil.pSetList(out);
    },

    _doBuildCache() {
        if (ExcludeUtil._cache_excludesLookup)
            return;
        if (!ExcludeUtil._excludes)
            return;

        ExcludeUtil._cache_excludesLookup = {};
        ExcludeUtil._excludes.forEach(({source, category, hash})=>{
            const cacheUid = ExcludeUtil._getCacheUids(hash, category, source, true);
            ExcludeUtil._cache_excludesLookup[cacheUid] = true;
        }
        );
    },

    _getCacheUids(hash, category, source, isExact) {
        hash = (hash || "").toLowerCase();
        category = (category || "").toLowerCase();
        source = (source?.source || source || "").toLowerCase();

        const exact = `${hash}__${category}__${source}`;
        if (isExact)
            return [exact];

        return [`${hash}__${category}__${source}`, `*__${category}__${source}`, `${hash}__*__${source}`, `${hash}__${category}__*`, `*__*__${source}`, `*__${category}__*`, `${hash}__*__*`, `*__*__*`, ];
    },

    _excludeCount: 0,
    isExcluded(hash, category, source, opts) {
        if (!ExcludeUtil._excludes || !ExcludeUtil._excludes.length)
            return false;
        if (!source)
            throw new Error(`Entity had no source!`);
        opts = opts || {};

        this._doBuildCache();

        hash = (hash || "").toLowerCase();
        category = (category || "").toLowerCase();
        source = (source.source || source || "").toLowerCase();

        const isExcluded = ExcludeUtil._isExcluded(hash, category, source);
        if (!isExcluded)
            return isExcluded;

        if (!opts.isNoCount)
            ++ExcludeUtil._excludeCount;

        return isExcluded;
    },

    _isExcluded(hash, category, source) {
        for (const cacheUid of ExcludeUtil._getCacheUids(hash, category, source)) {
            if (ExcludeUtil._cache_excludesLookup[cacheUid])
                return true;
        }
        return false;
    },

    isAllContentExcluded(list) {
        return (!list.length && ExcludeUtil._excludeCount) || (list.length > 0 && list.length === ExcludeUtil._excludeCount);
    },
    getAllContentBlocklistedHtml() {
        return `<div class="initial-message">(All content <a href="blocklist.html">blocklisted</a>)</div>`;
    },

    async _pSave() {
        return StorageUtil.pSet(VeCt.STORAGE_EXCLUDES, ExcludeUtil._excludes);
    },

    async pSave() {},
};
//#endregion

//#region SourceUtil
globalThis.SourceUtil = {
    ADV_BOOK_GROUPS: [{
        group: "core",
        displayName: "Core"
    }, {
        group: "supplement",
        displayName: "Supplements"
    }, {
        group: "setting",
        displayName: "Settings"
    }, {
        group: "setting-alt",
        displayName: "Additional Settings"
    }, {
        group: "supplement-alt",
        displayName: "Extras"
    }, {
        group: "prerelease",
        displayName: "Prerelease"
    }, {
        group: "homebrew",
        displayName: "Homebrew"
    }, {
        group: "screen",
        displayName: "Screens"
    }, {
        group: "recipe",
        displayName: "Recipes"
    }, {
        group: "other",
        displayName: "Miscellaneous"
    }, ],

    _subclassReprintLookup: {},
    async pInitSubclassReprintLookup() {
        SourceUtil._subclassReprintLookup = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`);
    },

    isSubclassReprinted(className, classSource, subclassShortName, subclassSource) {
        const fromLookup = MiscUtil.get(SourceUtil._subclassReprintLookup, classSource, className, subclassSource, subclassShortName);
        return fromLookup ? fromLookup.isReprinted : false;
    },

    isSiteSource(source) {
        return !!Parser.SOURCE_JSON_TO_FULL[source];
    },

    isAdventure(source) {
        if (source instanceof FilterItem)
            source = source.item;
        return Parser.SOURCES_ADVENTURES.has(source);
    },

    isCoreOrSupplement(source) {
        if (source instanceof FilterItem)
            source = source.item;
        return Parser.SOURCES_CORE_SUPPLEMENTS.has(source);
    },

    isNonstandardSource(source) {
        if (source == null)
            return false;
        return ((typeof BrewUtil2 === "undefined" || !BrewUtil2.hasSourceJson(source)) && SourceUtil.isNonstandardSourceWotc(source)) || SourceUtil.isPrereleaseSource(source);
    },


    /**
     * Returns true if the source is partnered with WOTC
     * @param {string} source
     * @returns {Boolean}
     */
    isPartneredSourceWotc(source) {
        if (source == null) { return false; }
        return Parser.SOURCES_PARTNERED_WOTC.has(source);
    },

    isPrereleaseSource(source) {
        if (source == null)
            return false;
        if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
            return true;
        return source.startsWith(Parser.SRC_UA_PREFIX) || source.startsWith(Parser.SRC_UA_ONE_PREFIX);
    },

    isNonstandardSourceWotc(source) {
        return SourceUtil.isPrereleaseSource(source) || source.startsWith(Parser.SRC_PS_PREFIX) || source.startsWith(Parser.SRC_AL_PREFIX) || source.startsWith(Parser.SRC_MCVX_PREFIX) || Parser.SOURCES_NON_STANDARD_WOTC.has(source);
    },

    FILTER_GROUP_STANDARD: 0,
    FILTER_GROUP_PARTNERED: 1,
    FILTER_GROUP_NON_STANDARD: 2,
    FILTER_GROUP_HOMEBREW: 3,

    getFilterGroup(source) {
        if (source instanceof FilterItem)
            source = source.item;
        if ((typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) || SourceUtil.isNonstandardSource(source))
            return SourceUtil.FILTER_GROUP_NON_STANDARD;
        if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
            return SourceUtil.FILTER_GROUP_HOMEBREW;
        if (SourceUtil.isPartneredSourceWotc(source))
            return SourceUtil.FILTER_GROUP_PARTNERED;
        return SourceUtil.FILTER_GROUP_STANDARD;
    },

    getAdventureBookSourceHref(source, page) {
        if (!source)
            return null;
        source = source.toLowerCase();

        let docPage, mappedSource;
        if (Parser.SOURCES_AVAILABLE_DOCS_BOOK[source]) {
            docPage = UrlUtil.PG_BOOK;
            mappedSource = Parser.SOURCES_AVAILABLE_DOCS_BOOK[source];
        } else if (Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source]) {
            docPage = UrlUtil.PG_ADVENTURE;
            mappedSource = Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source];
        }
        if (!docPage)
            return null;

        mappedSource = mappedSource.toLowerCase();

        return `${docPage}#${[mappedSource, page ? `page:${page}` : null].filter(Boolean).join(HASH_PART_SEP)}`;
    },

    getEntitySource(it) {
        return it.source || it.inherits?.source;
    },
};
//#endregion
//#region MiscUtil
globalThis.MiscUtil = {
    COLOR_HEALTHY: "#00bb20",
    COLOR_HURT: "#c5ca00",
    COLOR_BLOODIED: "#f7a100",
    COLOR_DEFEATED: "#cc0000",

    copy(obj, {isSafe=false, isPreserveUndefinedValueKeys=false}={}) {
        if (isSafe && obj === undefined)
            return undefined;
        return JSON.parse(JSON.stringify(obj));
    },

    copyFast(obj) {
        if ((typeof obj !== "object") || obj == null)
            return obj;

        if (obj instanceof Array)
            return obj.map(MiscUtil.copyFast);

        const cpy = {};
        for (const k of Object.keys(obj))
            cpy[k] = MiscUtil.copyFast(obj[k]);
        return cpy;
    },

    async pCopyTextToClipboard(text) {
        function doCompatibilityCopy() {
            const $iptTemp = $(`<textarea class="clp__wrp-temp"></textarea>`).appendTo(document.body).val(text).select();
            document.execCommand("Copy");
            $iptTemp.remove();
        }

        if (navigator && navigator.permissions) {
            try {
                const access = await navigator.permissions.query({
                    name: "clipboard-write"
                });
                if (access.state === "granted" || access.state === "prompt") {
                    await navigator.clipboard.writeText(text);
                } else
                    doCompatibilityCopy();
            } catch (e) {
                doCompatibilityCopy();
            }
        } else
            doCompatibilityCopy();
    },

    checkProperty(object, ...path) {
        for (let i = 0; i < path.length; ++i) {
            object = object[path[i]];
            if (object == null)
                return false;
        }
        return true;
    },

    /**Returns null if object doesn't have all the child (and grandchild) properties listed in the path.
     * Returns the final property in the path if it exists */
    get(object, ...path) {
        if (object == null)
            return null;
        for (let i = 0; i < path.length; ++i) {
            object = object[path[i]];
            if (object == null)
                return object;
        }
        return object;
    },

    set(object, ...pathAndVal) {
        if (object == null)
            return null;

        const val = pathAndVal.pop();
        if (!pathAndVal.length)
            return null;

        const len = pathAndVal.length;
        for (let i = 0; i < len; ++i) {
            const pathPart = pathAndVal[i];
            if (i === len - 1)
                object[pathPart] = val;
            else
                object = (object[pathPart] = object[pathPart] || {});
        }

        return val;
    },

    getOrSet(object, ...pathAndVal) {
        if (pathAndVal.length < 2)
            return null;
        const existing = MiscUtil.get(object, ...pathAndVal.slice(0, -1));
        if (existing != null)
            return existing;
        return MiscUtil.set(object, ...pathAndVal);
    },

    getThenSetCopy(object1, object2, ...path) {
        const val = MiscUtil.get(object1, ...path);
        return MiscUtil.set(object2, ...path, MiscUtil.copyFast(val, {
            isSafe: true
        }));
    },

    delete(object, ...path) {
        if (object == null)
            return object;
        for (let i = 0; i < path.length - 1; ++i) {
            object = object[path[i]];
            if (object == null)
                return object;
        }
        return delete object[path.last()];
    },

    deleteObjectPath(object, ...path) {
        const stack = [object];

        if (object == null)
            return object;
        for (let i = 0; i < path.length - 1; ++i) {
            object = object[path[i]];
            stack.push(object);
            if (object === undefined)
                return object;
        }
        const out = delete object[path.last()];

        for (let i = path.length - 1; i > 0; --i) {
            if (!Object.keys(stack[i]).length)
                delete stack[i - 1][path[i - 1]];
        }

        return out;
    },

    merge(obj1, obj2) {
        obj2 = MiscUtil.copyFast(obj2);

        Object.entries(obj2).forEach(([k,v])=>{
            if (obj1[k] == null) {
                obj1[k] = v;
                return;
            }

            if (typeof obj1[k] === "object" && typeof v === "object" && !(obj1[k]instanceof Array) && !(v instanceof Array)) {
                MiscUtil.merge(obj1[k], v);
                return;
            }

            obj1[k] = v;
        }
        );

        return obj1;
    },

    mix: (superclass)=>new MiscUtil._MixinBuilder(superclass),
    _MixinBuilder: function(superclass) {
        this.superclass = superclass;

        this.with = function(...mixins) {
            return mixins.reduce((c,mixin)=>mixin(c), this.superclass);
        }
        ;
    },

    clearSelection() {
        if (document.getSelection) {
            document.getSelection().removeAllRanges();
            document.getSelection().addRange(document.createRange());
        } else if (window.getSelection) {
            if (window.getSelection().removeAllRanges) {
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(document.createRange());
            } else if (window.getSelection().empty) {
                window.getSelection().empty();
            }
        } else if (document.selection) {
            document.selection.empty();
        }
    },

    randomColor() {
        let r;
        let g;
        let b;
        const h = RollerUtil.randomise(30, 0) / 30;
        const i = ~~(h * 6);
        const f = h * 6 - i;
        const q = 1 - f;
        switch (i % 6) {
        case 0:
            r = 1;
            g = f;
            b = 0;
            break;
        case 1:
            r = q;
            g = 1;
            b = 0;
            break;
        case 2:
            r = 0;
            g = 1;
            b = f;
            break;
        case 3:
            r = 0;
            g = q;
            b = 1;
            break;
        case 4:
            r = f;
            g = 0;
            b = 1;
            break;
        case 5:
            r = 1;
            g = 0;
            b = q;
            break;
        }
        return `#${`00${(~~(r * 255)).toString(16)}`.slice(-2)}${`00${(~~(g * 255)).toString(16)}`.slice(-2)}${`00${(~~(b * 255)).toString(16)}`.slice(-2)}`;
    },

    invertColor(hex, opts) {
        opts = opts || {};

        hex = hex.slice(1);
        let r = parseInt(hex.slice(0, 2), 16);
        let g = parseInt(hex.slice(2, 4), 16);
        let b = parseInt(hex.slice(4, 6), 16);

        const isDark = (r * 0.299 + g * 0.587 + b * 0.114) > 186;
        if (opts.dark && opts.light)
            return isDark ? opts.dark : opts.light;
        else if (opts.bw)
            return isDark ? "#000000" : "#FFFFFF";

        r = (255 - r).toString(16);
        g = (255 - g).toString(16);
        b = (255 - b).toString(16);
        return `#${[r, g, b].map(it=>it.padStart(2, "0")).join("")}`;
    },

    scrollPageTop() {
        document.body.scrollTop = document.documentElement.scrollTop = 0;
    },

    expEval(str) {
        return new Function(`return ${str.replace(/[^-()\d/*+.]/g, "")}`)();
    },

    parseNumberRange(input, min=Number.MIN_SAFE_INTEGER, max=Number.MAX_SAFE_INTEGER) {
        if (!input || !input.trim())
            return null;

        const errInvalid = input=>{
            throw new Error(`Could not parse range input "${input}"`);
        }
        ;

        const errOutOfRange = ()=>{
            throw new Error(`Number was out of range! Range was ${min}-${max} (inclusive).`);
        }
        ;

        const isOutOfRange = (num)=>num < min || num > max;

        const addToRangeVal = (range,num)=>range.add(num);

        const addToRangeLoHi = (range,lo,hi)=>{
            for (let i = lo; i <= hi; ++i)
                range.add(i);
        }
        ;

        const clean = input.replace(/\s*/g, "");
        if (!/^((\d+-\d+|\d+),)*(\d+-\d+|\d+)$/.exec(clean))
            errInvalid();

        const parts = clean.split(",");
        const out = new Set();

        for (const part of parts) {
            if (part.includes("-")) {
                const spl = part.split("-");
                const numLo = Number(spl[0]);
                const numHi = Number(spl[1]);

                if (isNaN(numLo) || isNaN(numHi) || numLo === 0 || numHi === 0 || numLo > numHi)
                    errInvalid();

                if (isOutOfRange(numLo) || isOutOfRange(numHi))
                    errOutOfRange();

                if (numLo === numHi)
                    addToRangeVal(out, numLo);
                else
                    addToRangeLoHi(out, numLo, numHi);
                continue;
            }

            const num = Number(part);
            if (isNaN(num) || num === 0)
                errInvalid();

            if (isOutOfRange(num))
                errOutOfRange();
            addToRangeVal(out, num);
        }

        return out;
    },

    findCommonPrefix(strArr, {isRespectWordBoundaries}={}) {
        if (isRespectWordBoundaries) {
            return MiscUtil._findCommonPrefixSuffixWords({
                strArr
            });
        }

        let prefix = null;
        strArr.forEach(s=>{
            if (prefix == null) {
                prefix = s;
                return;
            }

            const minLen = Math.min(s.length, prefix.length);
            for (let i = 0; i < minLen; ++i) {
                const cp = prefix[i];
                const cs = s[i];
                if (cp !== cs) {
                    prefix = prefix.substring(0, i);
                    break;
                }
            }
        }
        );
        return prefix;
    },

    findCommonSuffix(strArr, {isRespectWordBoundaries}={}) {
        if (!isRespectWordBoundaries)
            throw new Error(`Unimplemented!`);

        return MiscUtil._findCommonPrefixSuffixWords({
            strArr,
            isSuffix: true
        });
    },

    _findCommonPrefixSuffixWords({strArr, isSuffix}) {
        let prefixTks = null;
        let lenMax = -1;

        strArr.map(str=>{
            lenMax = Math.max(lenMax, str.length);
            return str.split(" ");
        }
        ).forEach(tks=>{
            if (isSuffix)
                tks.reverse();

            if (prefixTks == null)
                return prefixTks = [...tks];

            const minLen = Math.min(tks.length, prefixTks.length);
            while (prefixTks.length > minLen)
                prefixTks.pop();

            for (let i = 0; i < minLen; ++i) {
                const cp = prefixTks[i];
                const cs = tks[i];
                if (cp !== cs) {
                    prefixTks = prefixTks.slice(0, i);
                    break;
                }
            }
        }
        );

        if (isSuffix)
            prefixTks.reverse();

        if (!prefixTks.length)
            return "";

        const out = prefixTks.join(" ");
        if (out.length === lenMax)
            return out;

        return isSuffix ? ` ${prefixTks.join(" ")}` : `${prefixTks.join(" ")} `;
    },

    calculateBlendedColor(fgHexTarget, fgOpacity, bgHex) {
        const fgDcTarget = CryptUtil.hex2Dec(fgHexTarget);
        const bgDc = CryptUtil.hex2Dec(bgHex);
        return ((fgDcTarget - ((1 - fgOpacity) * bgDc)) / fgOpacity).toString(16);
    },

    debounce(func, wait, options) {
        let lastArgs;
        let lastThis;
        let maxWait;
        let result;
        let timerId;
        let lastCallTime;
        let lastInvokeTime = 0;
        let leading = false;
        let maxing = false;
        let trailing = true;

        wait = Number(wait) || 0;
        if (typeof options === "object") {
            leading = !!options.leading;
            maxing = "maxWait"in options;
            maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing"in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
            let args = lastArgs;
            let thisArg = lastThis;

            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
        }

        function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
            let timeSinceLastCall = time - lastCallTime;
            let timeSinceLastInvoke = time - lastInvokeTime;
            let result = wait - timeSinceLastCall;
            return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result;
        }

        function shouldInvoke(time) {
            let timeSinceLastCall = time - lastCallTime;
            let timeSinceLastInvoke = time - lastInvokeTime;

            return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
        }

        function timerExpired() {
            const time = Date.now();
            if (shouldInvoke(time)) {
                return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
            timerId = undefined;

            if (trailing && lastArgs)
                return invokeFunc(time);
            lastArgs = lastThis = undefined;
            return result;
        }

        function cancel() {
            if (timerId !== undefined)
                clearTimeout(timerId);
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
            return timerId === undefined ? result : trailingEdge(Date.now());
        }

        function debounced() {
            let time = Date.now();
            let isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;

            if (isInvoking) {
                if (timerId === undefined)
                    return leadingEdge(lastCallTime);
                if (maxing) {
                    timerId = setTimeout(timerExpired, wait);
                    return invokeFunc(lastCallTime);
                }
            }
            if (timerId === undefined)
                timerId = setTimeout(timerExpired, wait);
            return result;
        }

        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
    },

    throttle(func, wait, options) {
        let leading = true;
        let trailing = true;

        if (typeof options === "object") {
            leading = "leading"in options ? !!options.leading : leading;
            trailing = "trailing"in options ? !!options.trailing : trailing;
        }

        return this.debounce(func, wait, {
            leading,
            maxWait: wait,
            trailing
        });
    },

    pDelay(msecs, resolveAs) {
        return new Promise(resolve=>setTimeout(()=>resolve(resolveAs), msecs));
    },

    GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST: new Set(["caption", "type", "colLabels", "colLabelGroups", "name", "colStyles", "style", "shortName", "subclassShortName", "id", "path"]),

    getWalker(opts) {
        opts = opts || {};

        if (opts.isBreakOnReturn && !opts.isNoModification)
            throw new Error(`"isBreakOnReturn" may only be used in "isNoModification" mode!`);

        const keyBlocklist = opts.keyBlocklist || new Set();

        const getMappedPrimitive = (obj,primitiveHandlers,lastKey,stack,prop,propPre,propPost)=>{
            if (primitiveHandlers[propPre])
                MiscUtil._getWalker_runHandlers({
                    handlers: primitiveHandlers[propPre],
                    obj,
                    lastKey,
                    stack
                });
            if (primitiveHandlers[prop]) {
                const out = MiscUtil._getWalker_applyHandlers({
                    opts,
                    handlers: primitiveHandlers[prop],
                    obj,
                    lastKey,
                    stack
                });
                if (out === VeCt.SYM_WALKER_BREAK)
                    return out;
                if (!opts.isNoModification)
                    obj = out;
            }
            if (primitiveHandlers[propPost])
                MiscUtil._getWalker_runHandlers({
                    handlers: primitiveHandlers[propPost],
                    obj,
                    lastKey,
                    stack
                });
            return obj;
        }
        ;

        const doObjectRecurse = (obj,primitiveHandlers,stack)=>{
            for (const k of Object.keys(obj)) {
                if (keyBlocklist.has(k))
                    continue;

                const out = fn(obj[k], primitiveHandlers, k, stack);
                if (out === VeCt.SYM_WALKER_BREAK)
                    return VeCt.SYM_WALKER_BREAK;
                if (!opts.isNoModification)
                    obj[k] = out;
            }
        }
        ;

        const fn = (obj,primitiveHandlers,lastKey,stack)=>{
            if (obj === null)
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "null", "preNull", "postNull");

            switch (typeof obj) {
            case "undefined":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "undefined", "preUndefined", "postUndefined");
            case "boolean":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "boolean", "preBoolean", "postBoolean");
            case "number":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "number", "preNumber", "postNumber");
            case "string":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "string", "preString", "postString");
            case "object":
                {
                    if (obj instanceof Array) {
                        if (primitiveHandlers.preArray)
                            MiscUtil._getWalker_runHandlers({
                                handlers: primitiveHandlers.preArray,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            const out = new Array(obj.length);
                            for (let i = 0, len = out.length; i < len; ++i) {
                                out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
                                if (out[i] === VeCt.SYM_WALKER_BREAK)
                                    return out[i];
                            }
                            if (!opts.isNoModification)
                                obj = out;
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.array) {
                                const out = MiscUtil._getWalker_applyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (out === VeCt.SYM_WALKER_BREAK)
                                    return out;
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.array) {
                                const out = MiscUtil._getWalker_applyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (out === VeCt.SYM_WALKER_BREAK)
                                    return out;
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj != null) {
                                const out = new Array(obj.length);
                                for (let i = 0, len = out.length; i < len; ++i) {
                                    if (stack)
                                        stack.push(obj);
                                    out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
                                    if (stack)
                                        stack.pop();
                                    if (out[i] === VeCt.SYM_WALKER_BREAK)
                                        return out[i];
                                }
                                if (!opts.isNoModification)
                                    obj = out;
                            } else {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        }
                        if (primitiveHandlers.postArray)
                            MiscUtil._getWalker_runHandlers({
                                handlers: primitiveHandlers.postArray,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    }

                    if (primitiveHandlers.preObject)
                        MiscUtil._getWalker_runHandlers({
                            handlers: primitiveHandlers.preObject,
                            obj,
                            lastKey,
                            stack
                        });
                    if (opts.isDepthFirst) {
                        if (stack)
                            stack.push(obj);
                        const flag = doObjectRecurse(obj, primitiveHandlers, stack);
                        if (stack)
                            stack.pop();
                        if (flag === VeCt.SYM_WALKER_BREAK)
                            return flag;

                        if (primitiveHandlers.object) {
                            const out = MiscUtil._getWalker_applyHandlers({
                                opts,
                                handlers: primitiveHandlers.object,
                                obj,
                                lastKey,
                                stack
                            });
                            if (out === VeCt.SYM_WALKER_BREAK)
                                return out;
                            if (!opts.isNoModification)
                                obj = out;
                        }
                        if (obj == null) {
                            if (!opts.isAllowDeleteObjects)
                                throw new Error(`Object handler(s) returned null!`);
                        }
                    } else {
                        if (primitiveHandlers.object) {
                            const out = MiscUtil._getWalker_applyHandlers({
                                opts,
                                handlers: primitiveHandlers.object,
                                obj,
                                lastKey,
                                stack
                            });
                            if (out === VeCt.SYM_WALKER_BREAK)
                                return out;
                            if (!opts.isNoModification)
                                obj = out;
                        }
                        if (obj == null) {
                            if (!opts.isAllowDeleteObjects)
                                throw new Error(`Object handler(s) returned null!`);
                        } else {
                            if (stack)
                                stack.push(obj);
                            const flag = doObjectRecurse(obj, primitiveHandlers, stack);
                            if (stack)
                                stack.pop();
                            if (flag === VeCt.SYM_WALKER_BREAK)
                                return flag;
                        }
                    }
                    if (primitiveHandlers.postObject)
                        MiscUtil._getWalker_runHandlers({
                            handlers: primitiveHandlers.postObject,
                            obj,
                            lastKey,
                            stack
                        });
                    return obj;
                }
            default:
                throw new Error(`Unhandled type "${typeof obj}"`);
            }
        }
        ;

        return {
            walk: fn
        };
    },

    _getWalker_applyHandlers({opts, handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        const didBreak = handlers.some(h=>{
            const out = h(obj, lastKey, stack);
            if (opts.isBreakOnReturn && out)
                return true;
            if (!opts.isNoModification)
                obj = out;
        }
        );
        if (didBreak)
            return VeCt.SYM_WALKER_BREAK;
        return obj;
    },

    _getWalker_runHandlers({handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        handlers.forEach(h=>h(obj, lastKey, stack));
    },

    getAsyncWalker(opts) {
        opts = opts || {};
        const keyBlocklist = opts.keyBlocklist || new Set();

        const pFn = async(obj,primitiveHandlers,lastKey,stack)=>{
            if (obj == null) {
                if (primitiveHandlers.null)
                    return MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.null,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            }

            const pDoObjectRecurse = async()=>{
                await Object.keys(obj).pSerialAwaitMap(async k=>{
                    const v = obj[k];
                    if (keyBlocklist.has(k))
                        return;
                    const out = await pFn(v, primitiveHandlers, k, stack);
                    if (!opts.isNoModification)
                        obj[k] = out;
                }
                );
            }
            ;

            const to = typeof obj;
            switch (to) {
            case undefined:
                if (primitiveHandlers.preUndefined)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preUndefined,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.undefined) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.undefined,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postUndefined)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postUndefined,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "boolean":
                if (primitiveHandlers.preBoolean)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preBoolean,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.boolean) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.boolean,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postBoolean)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postBoolean,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "number":
                if (primitiveHandlers.preNumber)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preNumber,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.number) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.number,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postNumber)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postNumber,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "string":
                if (primitiveHandlers.preString)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preString,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.string) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.string,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postString)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postString,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "object":
                {
                    if (obj instanceof Array) {
                        if (primitiveHandlers.preArray)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.preArray,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            const out = await obj.pSerialAwaitMap(it=>pFn(it, primitiveHandlers, lastKey, stack));
                            if (!opts.isNoModification)
                                obj = out;
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.array) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.array) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj != null) {
                                const out = await obj.pSerialAwaitMap(it=>pFn(it, primitiveHandlers, lastKey, stack));
                                if (!opts.isNoModification)
                                    obj = out;
                            } else {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        }
                        if (primitiveHandlers.postArray)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.postArray,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    } else {
                        if (primitiveHandlers.preObject)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.preObject,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            await pDoObjectRecurse();
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.object) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.object,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteObjects)
                                    throw new Error(`Object handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.object) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.object,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteObjects)
                                    throw new Error(`Object handler(s) returned null!`);
                            } else {
                                await pDoObjectRecurse();
                            }
                        }
                        if (primitiveHandlers.postObject)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.postObject,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    }
                }
            default:
                throw new Error(`Unhandled type "${to}"`);
            }
        }
        ;

        return {
            pWalk: pFn
        };
    },

    async _getAsyncWalker_pApplyHandlers({opts, handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        await handlers.pSerialAwaitMap(async pH=>{
            const out = await pH(obj, lastKey, stack);
            if (!opts.isNoModification)
                obj = out;
        }
        );
        return obj;
    },

    async _getAsyncWalker_pRunHandlers({handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        await handlers.pSerialAwaitMap(pH=>pH(obj, lastKey, stack));
    },

    pDefer(fn) {
        return (async()=>fn())();
    },
};
//#endregion
//#region UtilDataConverter
class UtilDataConverter {
    static getNameWithSourcePart(ent, {displayName=null, isActorItem=false}={}) {
        return `${displayName || `${ent.type === "variant" ? "Variant: " : ""}${Renderer.stripTags(UtilEntityGeneric.getName(ent))}`}${!isActorItem && ent.source && Config.get("import", "isAddSourceToName") ? ` (${Parser.sourceJsonToAbv(ent.source)})` : ""}`;
    }

    static async pGetItemWeaponType(uid) {
        uid = uid.toLowerCase().trim();

        if (UtilDataConverter.WEAPONS_MARTIAL.includes(uid)){return "martial";}
        if (UtilDataConverter.WEAPONS_SIMPLE.includes(uid)){return "simple";}

        let[name,source] = Renderer.splitTagByPipe(uid);
        source = source || "phb";
        const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source});

        //TEMPFIX
        return null;
        const found = await DataLoader.pCacheAndGet(UrlUtil.PG_ITEMS, source, hash);
        return found?.weaponCategory;
    }

    static async _pGetClassSubclass_pInitCache({cache}) {
        cache = cache || {};
        if (!cache._allClasses && !cache._allSubclasses) {
            const classData = await DataUtil.class.loadJSON();
            const prerelease = await PrereleaseUtil.pGetBrewProcessed();
            const brew = await BrewUtil2.pGetBrewProcessed();

            cache._allClasses = [...(classData.class || []), ...(prerelease?.class || []), ...(brew?.class || []), ];

            cache._allSubclasses = [...(classData.subclass || []), ...(prerelease?.subclass || []), ...(brew?.subclass || []), ];
        }
        return cache;
    }

    static async pGetClassItemClassAndSubclass({sheetItem, subclassSheetItems, cache=null}={}) {
        cache = await this._pGetClassSubclass_pInitCache({
            cache
        });

        const nameLowerClean = sheetItem.name.toLowerCase().trim();
        const sourceLowerClean = (UtilDocumentSource.getDocumentSource(sheetItem).source || "").toLowerCase();

        const matchingClasses = cache._allClasses.filter(cls=>cls.name.toLowerCase() === nameLowerClean && (!Config.get("import", "isStrictMatching") || sourceLowerClean === Parser.sourceJsonToAbv(cls.source).toLowerCase()), );
        if (!matchingClasses.length)
            return {
                matchingClasses: [],
                matchingSubclasses: [],
                sheetItem
            };

        if (!subclassSheetItems?.length)
            return {
                matchingClasses,
                matchingSubclasses: [],
                sheetItem
            };

        const matchingSubclasses = matchingClasses.map(cls=>{
            const classSubclassSheetItems = subclassSheetItems.filter(scItem=>scItem.system.classIdentifier === sheetItem.system.identifier);
            return cache._allSubclasses.filter(sc=>{
                if (sc.className !== cls.name || sc.classSource !== cls.source)
                    return false;

                return classSubclassSheetItems.some(scItem=>sc.name.toLowerCase() === scItem.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(scItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(sc.source).toLowerCase()), );
            }
            );
        }
        ).flat();

        return {
            matchingClasses,
            matchingSubclasses,
            sheetItem
        };
    }

    static getSpellPointTotal({totalSpellcastingLevels}) {
        if (!totalSpellcastingLevels)
            return 0;

        const spellSlotCounts = UtilDataConverter.CASTER_TYPE_TO_PROGRESSION.full[totalSpellcastingLevels - 1] || UtilDataConverter.CASTER_TYPE_TO_PROGRESSION.full[0];

        return spellSlotCounts.map((countSlots,ix)=>{
            const spellLevel = ix + 1;
            return Parser.spLevelToSpellPoints(spellLevel) * countSlots;
        }
        ).sum();
    }

    static getPsiPointTotal({totalMysticLevels}) {
        if (!totalMysticLevels || isNaN(totalMysticLevels) || totalMysticLevels < 0)
            return 0;

        totalMysticLevels = Math.round(Math.min(totalMysticLevels, Consts.CHAR_MAX_LEVEL));

        return [4, 6, 14, 17, 27, 32, 38, 44, 57, 64, 64, 64, 64, 64, 64, 64, 64, 71, 71, 71][totalMysticLevels - 1];
    }

    static async pGetWithDescriptionPlugins(pFn, {actorId=null, tagHashItemIdMap=null}={}) {
        const hkLink = (entry,procHash)=>this._pGetWithDescriptionPlugins_fnPlugin(entry, procHash);

        const hkStr = (tag,text)=>{
            const inn = `{${tag} ${text}}`;
            const itemId = this._pGetWithDescriptionPlugins_getTagItemId({
                tag,
                text,
                tagHashItemIdMap
            });
            const out = this._getConvertedTagLinkString(inn, {
                actorId,
                itemId
            });
            if (inn === out)
                return null;
            return out;
        }
        ;

        const hkStrFont = (tag,text)=>{
            if (!game.user.isGM)
                return;

            const [,fontFamily] = Renderer.splitTagByPipe(text);

            if (UtilDataConverter._DESCRIPTION_FONTS_TRACKED[fontFamily])
                return;
            UtilDataConverter._DESCRIPTION_FONTS_TRACKED[fontFamily] = true;

            if (FontConfig.getAvailableFontChoices()[fontFamily])
                return;

            if (!Config.get("import", "isAutoAddAdditionalFonts")) {
                ui.notifications.warn(`The "${fontFamily}" font, used by recently-rendered content, is not available in your game. You may need to manually add it via the "Additional Fonts" setting, or text using the "${fontFamily}" font may not display correctly.`);
            }

            const url = BrewUtil2.getMetaLookup("fonts")?.[fontFamily] || PrereleaseUtil.getMetaLookup("fonts")?.[fontFamily];

            if (!url)
                return void ui.notifications.warn(`Failed to load font "${fontFamily}". You may need to manually add it via the "Additional Fonts" setting, or text using the "${fontFamily}" font may not display correctly.`);

            this._pDoLoadAdditionalFont(fontFamily, url).then(null);
        }
        ;

        const hkImg = (entry,url)=>{
            const out = Vetools.getImageSavedToServerUrl({
                originalUrl: url
            });
            Vetools.pSaveImageToServerAndGetUrl({
                originalUrl: url,
                force: true
            }).then(null).catch(()=>{}
            );
            return out;
        }
        ;

        Renderer.get().addPlugin("link_attributesHover", hkLink);
        Renderer.get().addPlugin("string_@font", hkStrFont);
        if (Config.get("import", "isRenderLinksAsTags"))
            Renderer.get().addPlugin("string_tag", hkStr);
        if (Config.get("import", "isSaveImagesToServer")) {
            Renderer.get().addPlugin("image_urlPostProcess", hkImg);
            Renderer.get().addPlugin("image_urlThumbnailPostProcess", hkImg);
        }

        let out;
        try {
            out = await pFn();
        } finally {
            Renderer.get().removePlugin("link_attributesHover", hkLink);
            Renderer.get().removePlugin("string_@font", hkStrFont);
            Renderer.get().removePlugin("string_tag", hkStr);
            Renderer.get().removePlugin("image_urlPostProcess", hkImg);
            Renderer.get().removePlugin("image_urlThumbnailPostProcess", hkImg);
        }

        return out;
    }

    static _DESCRIPTION_FONTS_TRACKED = {};
    static _HAS_NOTIFIED_FONTS_RELOAD = false;

    static async _pDoLoadAdditionalFont(family, url) {
        const hasNotified = this._HAS_NOTIFIED_FONTS_RELOAD;
        this._HAS_NOTIFIED_FONTS_RELOAD = true;

        const definitions = game.settings.get("core", FontConfig.SETTING);
        definitions[family] ??= {
            editor: true,
            fonts: []
        };
        const definition = definitions[family];
        definition.fonts.push({
            urls: [url],
            weight: 400,
            style: "normal"
        });
        await game.settings.set("core", FontConfig.SETTING, definitions);
        await FontConfig.loadFont(family, definition);

        if (hasNotified)
            return;

        ChatNotificationHandlers.getHandler("ReloadFonts").pDoPostChatMessage();
    }

    static _pGetWithDescriptionPlugins_getTagItemId({tag, text, tagHashItemIdMap}) {
        const tagName = tag.slice(1);
        if (!tagHashItemIdMap?.[tagName])
            return null;
        const defaultSource = Renderer.tag.TAG_LOOKUP[tagName]?.defaultSource;
        if (!defaultSource)
            return null;
        const page = Renderer.tag.getPage(tagName);
        if (!page)
            return null;
        const hashBuilder = UrlUtil.URL_TO_HASH_BUILDER[page];
        if (!hashBuilder)
            return null;
        let[name,source] = text.split("|");
        source = source || defaultSource;
        const hash = hashBuilder({
            name,
            source
        });
        return tagHashItemIdMap?.[tagName]?.[hash];
    }

    static _pGetWithDescriptionPlugins_fnPlugin(entry, procHash) {
        const page = entry.href.hover.page;
        const source = entry.href.hover.source;
        const hash = procHash;
        const preloadId = entry.href.hover.preloadId;
        return {
            attributesHoverReplace: [`data-plut-hover="${true}" data-plut-hover-page="${page.qq()}" data-plut-hover-source="${source.qq()}" data-plut-hover-hash="${hash.qq()}" ${preloadId ? `data-plut-hover-preload-id="${preloadId.qq()}"` : ""}`, ],
        };
    }

    static _getConvertedTagLinkString(str, {actorId, itemId}={}) {
        this._getConvertedTagLinkString_initLinkTagMetas();
        for (const {tag, re} of this._LINK_TAG_METAS_REPLACE)
            str = str.replace(re, (...m)=>this._replaceEntityLinks_getReplacement({
                tag,
                text: m.last().text,
                actorId,
                itemId
            }));
        for (const {tag, re} of this._LINK_TAG_METAS_REMOVE)
            str = str.replace(re, (...m)=>this._replaceEntityLinks_getRemoved({
                tag,
                text: m.last().text
            }));
        return str;
    }

    static _LINK_TAGS_TO_REMOVE = new Set(["quickref", ]);
    static _LINK_TAG_METAS_REPLACE = null;
    static _LINK_TAG_METAS_REMOVE = null;

    static _getConvertedTagLinkString_initLinkTagMetas() {
        if (!this._LINK_TAG_METAS_REPLACE) {
            this._LINK_TAG_METAS_REPLACE = Renderer.tag.TAGS.filter(it=>it.defaultSource).map(it=>it.tagName).filter(tag=>!this._LINK_TAGS_TO_REMOVE.has(tag)).map(tag=>({
                tag,
                re: this._getConvertedTagLinkString_getRegex({
                    tag
                })
            }));
        }

        if (!this._LINK_TAG_METAS_REMOVE) {
            this._LINK_TAG_METAS_REMOVE = Renderer.tag.TAGS.filter(it=>it.defaultSource).map(it=>it.tagName).filter(tag=>this._LINK_TAGS_TO_REMOVE.has(tag)).map(tag=>({
                tag,
                re: this._getConvertedTagLinkString_getRegex({
                    tag
                })
            }));
        }
    }

    static _getConvertedTagLinkString_getRegex({tag}) {
        return RegExp(`^{@${tag} (?<text>[^}]+)}$`, "g");
    }

    static getConvertedTagLinkEntries(entries) {
        if (!entries)
            return entries;

        return UtilDataConverter.WALKER_GENERIC.walk(MiscUtil.copy(entries), {
            string: str=>{
                const textStack = [""];
                this._getConvertedTagLinkEntries_recurse(str, textStack);
                return textStack.join("");
            }
            ,
        }, );
    }

    static _getConvertedTagLinkEntries_recurse(str, textStack) {
        const tagSplit = Renderer.splitByTags(str);
        const len = tagSplit.length;
        for (let i = 0; i < len; ++i) {
            const s = tagSplit[i];
            if (!s)
                continue;

            if (s.startsWith("{@")) {
                const converted = this._getConvertedTagLinkString(s);

                if (converted !== s) {
                    textStack[0] += (converted);
                    continue;
                }

                textStack[0] += s.slice(0, 1);
                this._getConvertedTagLinkEntries_recurse(s.slice(1, -1), textStack);
                textStack[0] += s.slice(-1);

                continue;
            }

            textStack[0] += s;
        }
    }

    static _replaceEntityLinks_getReplacement({tag, text, actorId, itemId}) {
        if (actorId && itemId) {
            const [,,displayText] = text.split("|");
            return `@UUID[Actor.${actorId}.Item.${itemId}]${displayText ? `{${displayText}}` : ""}`;
        }
        return `@${tag}[${text}]`;
    }

    static _replaceEntityLinks_getRemoved({tag, text}) {
        return Renderer.stripTags(`{@${tag} ${text}}`);
    }

    static async _pReplaceEntityLinks_pReplace({str, re, tag}) {
        let m;
        while ((m = re.exec(str))) {
            const prefix = str.slice(0, m.index);
            const suffix = str.slice(re.lastIndex);
            const replacement = this._replaceEntityLinks_getReplacement({
                tag,
                m
            });
            str = `${prefix}${replacement}${suffix}`;
            re.lastIndex = prefix.length + replacement.length;
        }
        return str;
    }

    static _RECHARGE_TYPES = {
        "round": null,
        "restShort": "sr",
        "restLong": "lr",
        "dawn": "dawn",
        "dusk": "dusk",
        "midnight": "day",

        "special": null,

        "week": null,
        "month": null,
        "year": null,
        "decade": null,
        "century": null,
    };

    static getFvttUsesPer(it, {isStrict=true}={}) {
        if (isStrict && !this._RECHARGE_TYPES[it])
            return null;
        return Parser._parse_aToB(this._RECHARGE_TYPES, it);
    }

    static getTempDocumentDefaultOwnership({documentType}) {
        if (game.user.isGM)
            return undefined;

        const clazz = CONFIG[documentType].documentClass;

        if (game.user.can(clazz.metadata.permissions.create))
            return undefined;

        return CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
    }
}
UtilDataConverter.WALKER_READONLY_GENERIC = MiscUtil.getWalker({
    isNoModification: true,
    keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST
});
UtilDataConverter.WALKER_GENERIC = MiscUtil.getWalker({
    keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST
});

UtilDataConverter.WEAPONS_MARTIAL = ["battleaxe|phb", "blowgun|phb", "flail|phb", "glaive|phb", "greataxe|phb", "greatsword|phb", "halberd|phb", "hand crossbow|phb", "heavy crossbow|phb", "lance|phb", "longbow|phb", "longsword|phb", "maul|phb", "morningstar|phb", "net|phb", "pike|phb", "rapier|phb", "scimitar|phb", "shortsword|phb", "trident|phb", "war pick|phb", "warhammer|phb", "whip|phb", ];
UtilDataConverter.WEAPONS_SIMPLE = ["club|phb", "dagger|phb", "dart|phb", "greatclub|phb", "handaxe|phb", "javelin|phb", "light crossbow|phb", "light hammer|phb", "mace|phb", "quarterstaff|phb", "shortbow|phb", "sickle|phb", "sling|phb", "spear|phb", ];

UtilDataConverter.CASTER_TYPE_TO_PROGRESSION = {
    "full": [[2, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0, 0], [4, 3, 2, 0, 0, 0, 0, 0, 0], [4, 3, 3, 0, 0, 0, 0, 0, 0], [4, 3, 3, 1, 0, 0, 0, 0, 0], [4, 3, 3, 2, 0, 0, 0, 0, 0], [4, 3, 3, 3, 1, 0, 0, 0, 0], [4, 3, 3, 3, 2, 0, 0, 0, 0], [4, 3, 3, 3, 2, 1, 0, 0, 0], [4, 3, 3, 3, 2, 1, 0, 0, 0], [4, 3, 3, 3, 2, 1, 1, 0, 0], [4, 3, 3, 3, 2, 1, 1, 0, 0], [4, 3, 3, 3, 2, 1, 1, 1, 0], [4, 3, 3, 3, 2, 1, 1, 1, 0], [4, 3, 3, 3, 2, 1, 1, 1, 1], [4, 3, 3, 3, 3, 1, 1, 1, 1], [4, 3, 3, 3, 3, 2, 1, 1, 1], [4, 3, 3, 3, 3, 2, 2, 1, 1], ],
    "artificer": [[2, 0, 0, 0, 0], [2, 0, 0, 0, 0], [3, 0, 0, 0, 0], [3, 0, 0, 0, 0], [4, 2, 0, 0, 0], [4, 2, 0, 0, 0], [4, 3, 0, 0, 0], [4, 3, 0, 0, 0], [4, 3, 2, 0, 0], [4, 3, 2, 0, 0], [4, 3, 3, 0, 0], [4, 3, 3, 0, 0], [4, 3, 3, 1, 0], [4, 3, 3, 1, 0], [4, 3, 3, 2, 0], [4, 3, 3, 2, 0], [4, 3, 3, 3, 1], [4, 3, 3, 3, 1], [4, 3, 3, 3, 2], [4, 3, 3, 3, 2], ],
    "1/2": [[0, 0, 0, 0, 0], [2, 0, 0, 0, 0], [3, 0, 0, 0, 0], [3, 0, 0, 0, 0], [4, 2, 0, 0, 0], [4, 2, 0, 0, 0], [4, 3, 0, 0, 0], [4, 3, 0, 0, 0], [4, 3, 2, 0, 0], [4, 3, 2, 0, 0], [4, 3, 3, 0, 0], [4, 3, 3, 0, 0], [4, 3, 3, 1, 0], [4, 3, 3, 1, 0], [4, 3, 3, 2, 0], [4, 3, 3, 2, 0], [4, 3, 3, 3, 1], [4, 3, 3, 3, 1], [4, 3, 3, 3, 2], [4, 3, 3, 3, 2], ],
    "1/3": [[0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 0, 0], [3, 0, 0, 0], [3, 0, 0, 0], [3, 0, 0, 0], [4, 2, 0, 0], [4, 2, 0, 0], [4, 2, 0, 0], [4, 3, 0, 0], [4, 3, 0, 0], [4, 3, 0, 0], [4, 3, 2, 0], [4, 3, 2, 0], [4, 3, 2, 0], [4, 3, 3, 0], [4, 3, 3, 0], [4, 3, 3, 0], [4, 3, 3, 1], [4, 3, 3, 1], ],
    "pact": [[1, 0, 0, 0, 0], [2, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 2, 0, 0], [0, 0, 2, 0, 0], [0, 0, 0, 2, 0], [0, 0, 0, 2, 0], [0, 0, 0, 0, 2], [0, 0, 0, 0, 2], [0, 0, 0, 0, 3], [0, 0, 0, 0, 3], [0, 0, 0, 0, 3], [0, 0, 0, 0, 3], [0, 0, 0, 0, 3], [0, 0, 0, 0, 3], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4], ],
};
//#endregion
//#region DataConverter
class DataConverter {
    static _configGroup;

    static _SideDataInterface;
    static _ImageFetcher;

    static async pGetDocumentJson(ent, opts) {
        throw new Error("Unimplemented!");
    }

    static isStubEntity(ent) {
        return false;
    }

    static getTagUids(tag, str) {
        const re = new RegExp(`{@${tag} ([^}]+)}`,"gi");
        const out = [];
        str.replace(re, (...m)=>out.push(m[1]));
        return out;
    }

    static getCombinedFoundrySystem(foundrySystem, _foundryData) {
        if (!_foundryData && !foundrySystem)
            return {};

        const combinedFoundrySystem = MiscUtil.copy(_foundryData || {});
        Object.assign(combinedFoundrySystem, MiscUtil.copy(foundrySystem || {}));

        return combinedFoundrySystem;
    }

    static getCombinedFoundryFlags(foundryFlags, _foundryFlags) {
        if (!foundryFlags && !_foundryFlags)
            return {};

        const combinedFoundryFlags = MiscUtil.copy(_foundryFlags || {});

        Object.entries(MiscUtil.copy(foundryFlags || {})).forEach(([flagNamespace,flagData])=>{
            if (!combinedFoundryFlags[flagNamespace])
                return combinedFoundryFlags[flagNamespace] = flagData;
            Object.assign(combinedFoundryFlags[flagNamespace], flagData);
        }
        );

        return combinedFoundryFlags;
    }

    static async pGetEntryDescription(entry, opts) {
        opts = opts || {};
        opts.prop = opts.prop || "entries";

        Renderer.get().setFirstSection(true).resetHeaderIndex();

        let description = "";
        if (entry[opts.prop]) {
            let cpyEntries = MiscUtil.copy(entry[opts.prop]);

            cpyEntries = UtilDataConverter.WALKER_GENERIC.walk(cpyEntries, {
                string: (str)=>{
                    return str.replace(/{@hitYourSpellAttack}/gi, ()=>`{@dice 1d20 + @${SharedConsts.MODULE_ID_FAKE}.userchar.spellAttackRanged|your spell attack modifier}`).replace(/{(@dice|@damage|@scaledice|@scaledamage|@hit) ([^}]+)}/gi, (...m)=>{
                        const [,tag,text] = m;
                        let[rollText,displayText,name,...others] = Renderer.splitTagByPipe(text);
                        const originalRollText = rollText;

                        rollText = this._pGetEntryDescription_getCleanDicePart(rollText, opts);
                        displayText = this._pGetEntryDescription_getCleanDisplayPart({
                            displayText,
                            originalText: originalRollText,
                            text: rollText
                        });

                        return `{${tag} ${[rollText, displayText || "", name || "", ...others].join("|")}}`;
                    }
                    ).replace(/{(@dc) ([^}]+)}/gi, (...m)=>{
                        const [,tag,text] = m;
                        let[dcText,displayText] = Renderer.splitTagByPipe(text);
                        const originalDcText = dcText;

                        dcText = this._pGetEntryDescription_getCleanDicePart(dcText, opts);
                        displayText = this._pGetEntryDescription_getCleanDisplayPart({
                            displayText,
                            originalText: originalDcText,
                            text: dcText
                        });

                        return `{${tag} ${[dcText, displayText || ""].join("|")}}`;
                    }
                    );
                }
                ,
            }, );

            description = await UtilDataConverter.pGetWithDescriptionPlugins(()=>Renderer.get().setFirstSection(true).render({
                type: "entries",
                entries: cpyEntries,
            }, opts.depth != null ? opts.depth : 2, ), );
        }

        return description;
    }

    static _pGetEntryDescription_getCleanDicePart(str, opts) {
        return str.replace(/\bPB\b/gi, `@${SharedConsts.MODULE_ID_FAKE}.userchar.pb`).replace(/\bsummonSpellLevel\b/gi, `${opts.summonSpellLevel ?? 0}`);
    }

    static _pGetEntryDescription_getCleanDisplayPart({displayText, originalText, text}) {
        if (!displayText && originalText !== text) {
            displayText = originalText.replace(/\bsummonSpellLevel\b/gi, `the spell's level`);
        }
        return displayText;
    }

    static mutActorUpdate(actor, actorUpdate, entry, opts) {
        opts = opts || {};

        this._mutActorUpdate_mutFromSideDataMod(actor, actorUpdate, opts);
        this._mutActorUpdate_mutFromSideTokenMod(actor, actorUpdate, opts);
    }

    static _mutActorUpdate_mutFromSideDataMod(actor, actorUpdate, opts) {
        return this._mutActorUpdate_mutFromSideMod(actor, actorUpdate, opts, "actorDataMod", "data");
    }

    static _mutActorUpdate_mutFromSideTokenMod(actor, actorUpdate, opts) {
        return this._mutActorUpdate_mutFromSideMod(actor, actorUpdate, opts, "actorTokenMod", "token");
    }

    static _mutActorUpdate_mutFromSideMod(actor, actorUpdate, opts, sideProp, actorProp) {
        if (!opts.sideData || !opts.sideData[sideProp])
            return;

        Object.entries(opts.sideData[sideProp]).forEach(([path,modMetas])=>this._mutActorUpdate_mutFromSideMod_handleProp(actor, actorUpdate, opts, sideProp, actorProp, path, modMetas));
    }

    static _mutActorUpdate_mutFromSideMod_handleProp(actor, actorUpdate, opts, sideProp, actorProp, path, modMetas) {
        const pathParts = path.split(".");

        if (path === "_") {
            modMetas.forEach(modMeta=>{
                switch (modMeta.mode) {
                case "conditionals":
                    {
                        for (const cond of modMeta.conditionals) {

                            window.PLUT_CONTEXT = {
                                actor
                            };

                            if (cond.condition && !eval(cond.condition))
                                continue;

                            Object.entries(cond.mod).forEach(([path,modMetas])=>this._mutActorUpdate_mutFromSideMod_handleProp(actor, actorUpdate, opts, sideProp, actorProp, path, modMetas));

                            break;
                        }

                        break;
                    }

                default:
                    throw new Error(`Unhandled mode "${modMeta.mode}"`);
                }
            }
            );
            return;
        }

        const fromActor = MiscUtil.get(actor, "system", actorProp, ...pathParts);
        const fromUpdate = MiscUtil.get(actorUpdate, actorProp, ...pathParts);
        const existing = fromUpdate || fromActor;

        modMetas.forEach(modMeta=>{
            switch (modMeta.mode) {
            case "appendStr":
                {
                    const existing = MiscUtil.get(actorUpdate, actorProp, ...pathParts);
                    const next = existing ? `${existing}${modMeta.joiner || ""}${modMeta.str}` : modMeta.str;
                    MiscUtil.set(actorUpdate, actorProp, ...pathParts, next);
                    break;
                }

            case "appendIfNotExistsArr":
                {
                    const existingArr = MiscUtil.copy(existing || []);
                    const out = [...existingArr];
                    out.push(...modMeta.items.filter(it=>!existingArr.some(x=>CollectionUtil.deepEquals(it, x))));
                    MiscUtil.set(actorUpdate, actorProp, ...pathParts, out);
                    break;
                }

            case "scalarAdd":
                {
                    MiscUtil.set(actorUpdate, actorProp, ...pathParts, modMeta.scalar + existing || 0);
                    break;
                }

            case "scalarAddUnit":
                {
                    const existingLower = `${existing || 0}`.toLowerCase();

                    const handle = (toFind)=>{
                        const ix = existingLower.indexOf(toFind.toLowerCase());
                        let numPart = existing.slice(0, ix);
                        const rest = existing.slice(ix);
                        const isSep = numPart.endsWith(" ");
                        numPart = numPart.trim();

                        if (!isNaN(numPart)) {
                            const out = `${modMeta.scalar + Number(numPart)}${isSep ? " " : ""}${rest}`;
                            MiscUtil.set(actorUpdate, actorProp, ...pathParts, out);
                        }
                    }
                    ;

                    if (!existing)
                        MiscUtil.set(actorUpdate, actorProp, ...pathParts, `${modMeta.scalar} ${modMeta.unitShort || modMeta.unit}`);
                    else if (modMeta.unit && existingLower.includes(modMeta.unit.toLowerCase())) {
                        handle(modMeta.unit);
                    } else if (modMeta.unitShort && existingLower.includes(modMeta.unitShort.toLowerCase())) {
                        handle(modMeta.unitShort);
                    }
                    break;
                }

            case "setMax":
                {
                    const existingLower = `${existing || 0}`.toLowerCase();
                    let asNum = Number(existingLower);
                    if (isNaN(asNum))
                        asNum = 0;
                    const maxValue = Math.max(asNum, modMeta.value);
                    MiscUtil.set(actorUpdate, actorProp, ...pathParts, maxValue);
                    break;
                }

            case "set":
                {
                    MiscUtil.set(actorUpdate, actorProp, ...pathParts, MiscUtil.copy(modMeta.value));
                    break;
                }

            default:
                throw new Error(`Unhandled mode "${modMeta.mode}"`);
            }
        }
        );
    }

    static _getProfBonusExpressionParts(str) {
        const parts = str.split(/([-+]\s*[^-+]+)/g).map(it=>it.trim().replace(/\s*/g, "")).filter(Boolean);

        const [partsNumerical,partsNonNumerical] = parts.segregate(it=>!isNaN(it));

        const totalNumerical = partsNumerical.map(it=>Number(it)).sum();

        return {
            partsNumerical,
            partsNonNumerical,
            totalNumerical
        };
    }

    static _PassiveEntryParseState = class {
        constructor({entry, img, name}, opts) {
            this._entry = entry;
            this._opts = opts;

            this.name = name;
            this.img = img;

            let {id,
            description,
            activationType, activationCost, activationCondition,
            saveAbility, saveDc, saveScaling,
            damageParts,
            attackBonus,
            requirements,
            actionType,
            durationValue, durationUnits,
            consumeType, consumeTarget, consumeAmount, consumeScale,
            formula,
            targetValue, targetUnits, targetType, targetPrompt,
            rangeShort, rangeLong, rangeUnits,
            ability,
            usesValue, usesMax, usesPer,
            rechargeValue,
            isProficient,
            typeType, typeSubtype,
            foundrySystem, _foundryData, foundryFlags, _foundryFlags, } = opts;

            this.combinedFoundrySystem = DataConverter.getCombinedFoundrySystem(foundrySystem, _foundryData);
            this.combinedFoundryFlags = DataConverter.getCombinedFoundryFlags(foundryFlags, _foundryFlags);

            if (entry._foundryId && id && entry._foundryId !== id)
                throw new Error(`Item given two different IDs (${this.id} and ${id})! This is a bug!`);

            this.id = entry._foundryId || id;

            this.description = description;

            this.activationType = activationType;
            this.activationCost = activationCost;
            this.activationCondition = activationCondition;

            this.saveAbility = saveAbility;
            this.saveDc = saveDc;
            this.saveScaling = saveScaling;

            this.damageParts = damageParts;

            this.attackBonus = attackBonus;

            this.requirements = requirements;

            this.actionType = actionType;

            this.durationValue = durationValue;
            this.durationUnits = durationUnits;

            this.consumeType = consumeType;
            this.consumeTarget = consumeTarget;
            this.consumeAmount = consumeAmount;
            this.consumeScale = consumeScale;

            this.formula = formula;

            this.targetValue = targetValue;
            this.targetUnits = targetUnits;
            this.targetType = targetType;
            this.targetPrompt = targetPrompt;

            this.rangeShort = rangeShort;
            this.rangeLong = rangeLong;
            this.rangeUnits = rangeUnits;

            this.ability = ability;

            this.usesValue = usesValue;
            this.usesMax = usesMax;
            this.usesPer = usesPer;

            this.rechargeValue = rechargeValue;

            this.isProficient = isProficient;

            this.typeType = typeType;
            this.typeSubtype = typeSubtype;

            this.effectsParsed = [];

            this.flagsParsed = {};
        }

        async pInit({isSkipDescription=false, isSkipImg=false}={}) {
            if (!isSkipDescription && !this.description && !this._opts.isSkipDescription) {
                this.description = await DataConverter.pGetEntryDescription(this._entry, {
                    depth: this._opts.renderDepth,
                    summonSpellLevel: this._opts.summonSpellLevel
                });
            }

            if (!isSkipImg && this._opts.img) {
                this.img = await Vetools.pOptionallySaveImageToServerAndGetUrl(this._opts.img);
            }
        }
    }
    ;

    static async _pGetItemActorPassive(entry, opts) {
        opts = opts || {};

        Renderer.get().setFirstSection(true).resetHeaderIndex();

        opts.modeOptions = opts.modeOptions || {};

        if (opts.mode === "object")
            opts.mode = "creature";

        const state = new this._PassiveEntryParseState({
            entry,
            name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(entry, {
                displayName: opts.displayName,
                isActorItem: opts.isActorItem ?? true
            })),
        },opts,);
        await state.pInit();

        const strEntries = entry.entries ? JSON.stringify(entry.entries) : null;

        this._pGetItemActorPassive_mutRecharge({
            entry,
            opts,
            state
        });
        this._pGetItemActorPassive_mutActivation({
            entry,
            opts,
            state
        });
        this._pGetItemActorPassive_mutUses({
            entry,
            opts,
            strEntries,
            state
        });
        this._pGetItemActorPassive_mutSave({
            entry,
            opts,
            strEntries,
            state
        });
        this._pGetItemActorPassive_mutDuration({
            entry,
            opts,
            state
        });
        this._pGetItemActorPassive_mutDamageAndFormula({
            entry,
            opts,
            strEntries,
            state
        });
        this._pGetItemActorPassive_mutTarget({
            entry,
            opts,
            strEntries,
            state
        });
        this._pGetItemActorPassive_mutActionType({
            entry,
            opts,
            state
        });
        this._pGetItemActorPassive_mutEffects({
            entry,
            opts,
            state
        });

        try {
            state.activationCondition = Renderer.stripTags(state.activationCondition);
        } catch (e) {
            console.error(...LGT, e);
        }

        if ((state.consumeType || state.usesPer || opts.additionalData?.["consume.type"] || opts.additionalData?.consume?.type || opts.additionalData?.["uses.per"] || opts.additionalData?.uses?.per) && !state.activationType)
            state.activationType = "special";

        state.name = state.name.trim().replace(/\s+/g, " ");
        if (!state.name)
            state.name = "(Unnamed)";
        const fauxEntrySourcePage = {
            ...entry
        };
        if (opts.source != null)
            fauxEntrySourcePage.source = opts.source;
        if (opts.page != null)
            fauxEntrySourcePage.page = opts.page;

        this._pGetItemActorPassive_mutFlags({
            entry,
            opts,
            state
        });

        const {name: translatedName, description: translatedDescription, flags: translatedFlags} = this._getTranslationMeta({
            translationData: opts.translationData,
            name: state.name,
            description: state.description,
        });

        return {
            ...this._getIdObj({
                id: state.id
            }),
            name: translatedName,
            type: opts.fvttType || "feat",
            system: {
                source: opts.fvttSource !== undefined ? opts.fvttSource : UtilDocumentSource.getSourceObjectFromEntity(fauxEntrySourcePage),
                description: {
                    value: translatedDescription,
                    chat: "",
                    unidentified: ""
                },

                damage: {
                    parts: state.damageParts ?? [],
                    versatile: "",
                },
                duration: {
                    value: state.durationValue,
                    units: state.durationUnits,
                },
                range: {
                    value: state.rangeShort,
                    long: state.rangeLong,
                    units: state.rangeUnits || ((state.rangeShort != null || state.rangeLong != null) ? "ft" : ""),
                },
                proficient: state.isProficient,
                requirements: state.requirements,

                save: {
                    ability: state.saveAbility,
                    dc: state.saveDc,
                    scaling: state.saveScaling || "flat",
                },

                activation: {
                    type: state.activationType,
                    cost: state.activationCost,
                    condition: state.activationCondition,
                },

                target: {
                    value: state.targetValue,
                    units: state.targetUnits,
                    type: state.targetType,
                    prompt: state.targetPrompt,
                },

                uses: {
                    value: state.usesValue,
                    max: state.usesMax,
                    per: state.usesPer,
                },
                ability: state.ability,
                actionType: state.actionType,
                attackBonus: state.attackBonus,
                chatFlavor: "",
                critical: {
                    threshold: null,
                    damage: ""
                },

                formula: state.formula,

                recharge: {
                    value: state.rechargeValue,
                    charged: state.rechargeValue != null,
                },

                consume: {
                    type: state.consumeType,
                    target: state.consumeTarget,
                    amount: state.consumeAmount,
                    scale: state.consumeScale,
                },

                type: {
                    value: state.typeType,
                    subtype: state.typeSubtype,
                },

                ...(state.combinedFoundrySystem || {}),
                ...(opts.additionalData || {}),
            },
            ownership: {
                default: 0
            },
            img: state.img,
            flags: {
                ...translatedFlags,
                ...state.flagsParsed,
                ...(UtilCompat.getFeatureFlags({
                    isReaction: ["reaction", "reactiondamage", "reactionmanual"].includes(state.activationType)
                })),
                ...(state.combinedFoundryFlags || {}),
                ...opts.additionalFlags,
            },
            effects: DataConverter.getEffectsMutDedupeId([...(opts.effects || []), ...state.effectsParsed, ]),
        };
    }

    static _pGetItemActorPassive_mutRecharge({entry, opts, state}) {
        if (!state.name)
            return;

        const rechargeMeta = UtilEntityGeneric.getRechargeMeta(state.name);
        if (rechargeMeta == null)
            return;

        state.name = rechargeMeta.name;
        if (state.rechargeValue === undefined && rechargeMeta.rechargeValue != null)
            state.rechargeValue = rechargeMeta.rechargeValue;
    }

    static _pGetItemActorPassive_mutActivation({entry, opts, state}) {
        this._pGetItemActorPassive_mutActivation_player({
            entry,
            opts,
            state
        });
        this._pGetItemActorPassive_mutActivation_creature({
            entry,
            opts,
            state
        });
    }

    static _pGetItemActorPassive_mutActivation_player({entry, opts, state}) {
        if (opts.mode !== "player" || !entry.entries?.length)
            return;

        if (state.activationType || state.activationCost) {
            this._pGetItemActorPassive_mutActivation_playerCompat({
                entry,
                opts,
                state
            });
            return;
        }

        let isAction = false;
        let isBonusAction = false;
        let isReaction = false;

        UtilDataConverter.WALKER_READONLY_GENERIC.walk(entry.entries, {
            string: (str)=>{
                if (state.activationType)
                    return str;

                const sentences = Util.getSentences(str);
                for (const sentence of sentences) {
                    if (/\b(?:as an action|can take an action|can use your action)\b/i.test(sentence)) {
                        isAction = true;
                        break;
                    }

                    if (/\bbonus action\b/i.test(sentence)) {
                        isBonusAction = true;
                        break;
                    }

                    const mReact = /\b(?:your reaction|this special reaction|as a reaction)\b/i.exec(sentence);
                    if (mReact) {
                        isReaction = true;

                        let preceding = sentence.slice(0, mReact.index).trim().replace(/,$/, "");
                        const mCondition = /(^|\W)(?:if|when)(?:|\W)/i.exec(preceding);
                        if (mCondition) {
                            preceding = preceding.slice(mCondition.index + mCondition[1].length).trim();
                            state.activationCondition = state.activationCondition || preceding;
                        }

                        break;
                    }
                }
            }
            ,
        }, );

        if (isAction)
            state.activationType = "action";
        else if (isBonusAction)
            state.activationType = "bonus";
        else if (isReaction)
            state.activationType = "reaction";

        if (state.activationType)
            state.activationCost = 1;

        if (!state.activationType) {
            UtilDataConverter.WALKER_READONLY_GENERIC.walk(entry.entries, {
                string: (str)=>{
                    if (state.activationType)
                        return str;

                    const sentences = Util.getSentences(str);

                    for (const sentence of sentences) {
                        if (/you can't use this feature again|once you use this feature/i.test(sentence))
                            state.activationType = "special";
                    }
                }
                ,
            }, );
        }

        this._pGetItemActorPassive_mutActivation_playerCompat({
            entry,
            opts,
            state
        });
    }

    static _pGetItemActorPassive_mutActivation_creature({entry, opts, state}) {
        if (opts.mode !== "creature" || !entry.entries?.length || !entry.name) {
            this._pGetItemActorPassive_mutActivation_creature_enableOtherFields({
                entry,
                opts,
                state
            });
            return;
        }

        if (state.activationType || state.activationCost) {
            this._pGetItemActorPassive_mutActivation_creatureCompat({
                entry,
                opts,
                state
            });
            this._pGetItemActorPassive_mutActivation_creature_enableOtherFields({
                entry,
                opts,
                state
            });
            return;
        }

        MiscUtil.getWalker({
            isNoModification: true,
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
            isBreakOnReturn: true,
        }).walk(entry.entries, {
            string: str=>{
                if (/\bbonus action\b/i.test(str)) {
                    state.activationType = "bonus";
                    state.activationCost = 1;
                    return true;
                }
            }
            ,
        }, );

        if (/^legendary resistance/i.test(entry.name)) {
            state.activationType = "special";
        }

        this._pGetItemActorPassive_mutActivation_creature_enableOtherFields({
            entry,
            opts,
            state
        });

        this._pGetItemActorPassive_mutActivation_creatureCompat({
            entry,
            opts,
            state
        });
    }

    static _pGetItemActorPassive_mutActivation_creature_enableOtherFields({entry, opts, state}) {
        if (state.rechargeValue !== undefined) {
            if (state.activationType == null)
                state.activationType = "special";
        }
    }

    static _pGetItemActorPassive_mutActivation_playerCompat({entry, opts, state}) {
        if (!UtilCompat.isMidiQolActive() || state.activationType !== "reaction")
            return null;

    }

    static _pGetItemActorPassive_mutActivation_creatureCompat({entry, opts, state}) {
        if (!UtilCompat.isMidiQolActive() || state.activationType !== "reaction")
            return;

        state.activationType = "reactionmanual";

        let firstEntry = entry.entries[0];
        if (typeof firstEntry !== "string")
            return;

        firstEntry.replace(/\bcauses the attack to miss\b/i, ()=>{
            state.activationType = "reaction";
            return "";
        }
        )
        .replace(/\badds? (?<ac>\d+) to (its|their|his|her) AC\b/i, (...m)=>{
            const argsDuration = UtilCompat.isDaeActive() ? {
                flags: {
                    [UtilCompat.MODULE_DAE]: {
                        specialDuration: ["1Reaction"]
                    }
                }
            } : {
                durationTurns: 1
            };

            state.effectsParsed.push(UtilActiveEffects.getGenericEffect({
                ...argsDuration,
                key: `system.attributes.ac.bonus`,
                value: UiUtil.intToBonus(Number(m.last().ac)),
                mode: CONST.ACTIVE_EFFECT_MODES.ADD,
                name: `${entry.name}`,
                icon: state.img,
                disabled: false,
                transfer: false,
                priority: UtilActiveEffects.PRIORITY_BONUS,
            }));

            state.targetType = state.targetType || "self";

            return "";
        }
        )
        .replace(/\battack that would (?:hit|miss) (?:it|them|him|her|or miss)\b/i, ()=>{
            state.activationType = "reaction";
            return "";
        }
        ).replace(/\bin response to being (?:hit|missed)\b/i, ()=>{
            state.activationType = "reaction";
            return "";
        }
        )
        .replace(/\bafter taking damage from\b/i, ()=>{
            state.activationType = "reactiondamage";
            return "";
        }
        ).replace(/\bIf [^.!?:]+ takes damage(?:,| while it)\b/i, ()=>{
            state.activationType = "reactiondamage";
            return "";
        }
        ).replace(/\bIn response to taking damage\b/i, ()=>{
            state.activationType = "reactiondamage";
            return "";
        }
        );
    }

    static _pGetItemActorPassive_mutSave({entry, opts, strEntries, state}) {
        this._pGetItemActorPassive_mutSave_player({
            entry,
            opts,
            strEntries,
            state
        });
        this._pGetItemActorPassive_mutSave_creature({
            entry,
            opts,
            strEntries,
            state
        });
    }

    static _pGetItemActorPassive_mutSave_player({entry, opts, strEntries, state}) {
        if (opts.mode !== "player" || !entry.entries?.length)
            return;

        UtilDataConverter.WALKER_READONLY_GENERIC.walk(entry.entries, {
            object: (obj)=>{
                if (obj.type !== "abilityDc")
                    return obj;

                if (state.actionType && state.saveScaling)
                    return obj;

                state.actionType = state.actionType || "save";
                state.saveScaling = obj.attributes[0];
                return obj;
            }
            ,
            string: (str)=>{
                if (state.actionType && state.saveAbility && state.saveScaling)
                    return str;

                str.replace(/8\s*\+\s*your proficiency bonus\s*\+\s*your (.*?) modifier/i, (...m)=>{
                    const customAbilities = [];
                    m[1].replace(/(Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma)/i, (...m2)=>{
                        customAbilities.push(m2[1].toLowerCase().slice(0, 3));
                    }
                    );
                    if (!customAbilities.length)
                        return;

                    state.actionType = state.actionType || "save";
                    state.saveScaling = customAbilities[0];
                }
                );

                str.replace(/(Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma) saving throw against your (.*? )spell save DC/i, (...m)=>{
                    state.actionType = state.actionType || "save";
                    state.saveAbility = state.saveAbility || m[1].toLowerCase().slice(0, 3);
                    state.saveScaling = state.saveScaling || "spell";
                }
                );

                str.replace(/(?:make a|succeed on a) (Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma) saving throw/gi, (...m)=>{
                    state.actionType = state.actionType || "save";
                    state.saveAbility = state.saveAbility || m[1].toLowerCase().slice(0, 3);
                    state.saveScaling = state.saveScaling || "spell";
                }
                );

                return str;
            }
            ,
        }, );
    }

    static _pGetItemActorPassive_mutSave_creature({entry, opts, strEntries, state}) {
        if (opts.mode !== "creature" || !entry.entries?.length)
            return;

        const m = /{@dc (?<save>[^|}]+)(?:\|[^}]+)?}\s+(?<abil>Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma)/i.exec(strEntries);
        if (!m)
            return;

        const {partsNonNumerical, totalNumerical} = this._getProfBonusExpressionParts(m.groups.save);

        state.actionType = state.actionType === undefined ? "save" : state.actionType;
        state.saveAbility = state.saveAbility === undefined ? m.groups.abil.toLowerCase().slice(0, 3) : state.saveAbility;
        state.saveDc = state.saveDc === undefined ? totalNumerical : state.saveDc;

        if (partsNonNumerical.length || opts.pb == null || ((opts.entity == null || Parser.ABIL_ABVS.some(ab=>opts.entity[ab] == null || typeof opts.entity[ab] !== "number")) && (opts.entity != null || Parser.ABIL_ABVS.some(ab=>{
            const abNamespaced = UtilEntityCreatureFeature.getNamespacedProp(ab);
            return entry[abNamespaced] == null || typeof entry[abNamespaced] !== "number";
        }
        )))) {
            state.saveScaling = state.saveScaling === undefined ? "flat" : state.saveScaling;
            return;
        }

        if (state.saveScaling)
            return;

        const fromAbil = state.saveDc - opts.pb - 8;
        const abilToBonus = Parser.ABIL_ABVS.map(ab=>({
            ability: ab,
            bonus: Parser.getAbilityModNumber(opts.entity != null ? Renderer.monster.getSafeAbilityScore(opts.entity, ab, {
                isDefaultTen: true
            }) : Renderer.monster.getSafeAbilityScore(entry, UtilEntityCreatureFeature.getNamespacedProp(ab), {
                isDefaultTen: true
            }), ),
        }));
        const matchingAbils = abilToBonus.filter(it=>it.bonus === fromAbil);

        if (matchingAbils.length === 1)
            state.saveScaling = state.saveScaling || matchingAbils[0].ability;
        else
            state.saveScaling = "flat";
    }

    static _pGetItemActorPassive_mutUses({entry, opts, strEntries, state}) {
        this._pGetItemActorPassive_mutUses_creature({
            entry,
            opts,
            strEntries,
            state
        });
        this._pGetItemActorPassive_mutUses_player({
            entry,
            opts,
            strEntries,
            state
        });
    }

    static _pGetItemActorPassive_mutUses_creature({entry, opts, strEntries, state}) {
        if (opts.mode !== "creature" || !entry.name)
            return;

        const isLegendary = /legendary resistance/gi.test(state.name);

        let isFound = false;

        state.name = state.name.replace(/\(Recharges after a (?<restPart>[^)]+)\)/i, (...m)=>{
            isFound = true;

            if (isLegendary)
                return "";

            if (state.usesValue === undefined)
                state.usesValue = 1;
            if (state.usesMax === undefined)
                state.usesMax = `${state.usesValue}`;

            const restPartClean = m.last().restPart.toLowerCase();
            if (/\bshort\b/.test(restPartClean)) {
                if (state.usesPer === undefined)
                    state.usesPer = "sr";
            } else if (/\blong\b/.test(restPartClean)) {
                if (state.usesPer === undefined)
                    state.usesPer = "lr";
            }

            return "";
        }
        );

        if (state.usesPer === undefined) {
            state.name = state.name.replace(/\(\s*(\d+)\s*\/\s*(Day|Short Rest|Long Rest)\s*\)/i, (...m)=>{
                isFound = true;

                if (isLegendary)
                    return "";

                if (state.usesValue === undefined)
                    state.usesValue = Number(m[1]);
                if (state.usesMax === undefined)
                    state.usesMax = `${state.usesValue}`;

                if (state.usesPer === undefined) {
                    const cleanTime = m[2].trim().toLowerCase();
                    switch (cleanTime) {
                    case "day":
                        state.usesPer = "day";
                        break;
                    case "short rest":
                        state.usesPer = "sr";
                        break;
                    case "long rest":
                        state.usesPer = "lr";
                        break;
                    }
                }

                return "";
            }
            );
        }

        if (state.usesPer === undefined) {
            state.name = state.name.replace(/\(\s*(\d+)\s+Charges\s*\)/i, (...m)=>{
                isFound = true;

                if (isLegendary)
                    return "";

                if (state.usesValue === undefined)
                    state.usesValue = Number(m[1]);
                if (state.usesMax === undefined)
                    state.usesMax = `${state.usesValue}`;
                if (state.usesPer === undefined)
                    state.usesPer = "charges";

                return "";
            }
            );
        }

        if (!isFound)
            return;

        state.name = state.name.trim().replace(/ +/g, " ");

        if (state.activationType === undefined)
            state.activationType = state.activationType || "none";

        if (entry.entries && typeof entry.entries[0] === "string" && /^(?:If |When )/i.test(entry.entries[0].trim())) {
            if (state.activationCondition === undefined)
                state.activationCondition = entry.entries[0].trim();
        }
    }

    static _pGetItemActorPassive_mutUses_player({entry, opts, strEntries, state}) {
        if (opts.mode !== "player" || !entry.entries)
            return;

        if (state.consumeType === "charges")
            return;

        const isShortRest = /\b(?:finish|complete) a short rest\b/.test(strEntries) || /\b(?:finish|complete) a short or long rest\b/.test(strEntries) || /\b(?:finish|complete) a short rest or a long rest\b/.test(strEntries) || /\b(?:finish|complete) a short or long rest\b/.test(strEntries);
        const isLongRest = !isShortRest && /\b(?:finish|complete) a long rest\b/.test(strEntries);

        if (state.usesPer === undefined) {
            if (isShortRest)
                state.usesPer = "sr";
            else if (isLongRest)
                state.usesPer = "lr";
        }

        const mAbilModifier = new RegExp(`a number of times equal to(?: (${Consts.TERMS_COUNT.map(it=>it.tokens.join("")).join("|")}))? your (Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma) modifier(?: \\(minimum of (${Consts.TERMS_COUNT.map(it=>it.tokens.join("")).join("|")})\\))?`,"i").exec(strEntries);
        if (mAbilModifier && opts.actor) {
            const abv = mAbilModifier[2].slice(0, 3).toLowerCase();
            const abilScore = MiscUtil.get(opts.actor, "system", "abilities", abv, "value");
            if (abilScore != null) {
                let mod = Parser.getAbilityModNumber(abilScore);
                let modFormula = `floor((@abilities.${abv}.value - 10) / 2)`;

                if (mAbilModifier[1]) {
                    const multiplier = (Consts.TERMS_COUNT.find(it=>it.tokens.join(" ") === mAbilModifier[1].trim().toLowerCase()) || {}).count || 1;
                    mod = mod * multiplier;
                    modFormula = `${modFormula} * ${multiplier}`;
                }

                if (mAbilModifier[3]) {
                    const min = (Consts.TERMS_COUNT.find(it=>it.tokens.join("") === mAbilModifier[3].trim().toLowerCase()) || {}).count || 1;
                    mod = Math.max(min, mod);
                    modFormula = `max(${min}, ${modFormula})`;
                }

                if (state.usesValue === undefined)
                    state.usesValue = mod;
                if (state.usesMax === undefined)
                    state.usesMax = modFormula;
            }
        }

        strEntries.replace(/(you can ([^.!?]+)) a number of times equal to(?<mult> twice)? your proficiency bonus/i, (...m)=>{
            const mult = m.last().mult ? (Consts.TERMS_COUNT.find(meta=>CollectionUtil.deepEquals(meta.tokens, m.last().mult.trim().toLowerCase().split(/( )/g)))?.count || 1) : 1;
            if (state.usesValue === undefined)
                state.usesValue = opts.actor ? (UtilActors.getProficiencyBonusNumber({
                    actor: opts.actor
                }) * mult) : null;
            if (state.usesMax === undefined)
                state.usesMax = `@prof${mult > 1 ? ` * ${mult}` : ""}`;
        }
        );

        strEntries.replace(/you can use this (?:feature|ability) (?<mult>once|twice|[a-zA-Z]+ times)/i, (...m)=>{
            const mult = (Consts.TERMS_COUNT.find(meta=>CollectionUtil.deepEquals(meta.tokens, m.last().mult.trim().toLowerCase().split(/( )/g)))?.count || 1);
            if (state.usesValue === undefined)
                state.usesValue = mult;
            if (state.usesMax === undefined)
                state.usesMax = mult;
        }
        );

        if (state.usesPer && !state.usesValue && (!state.usesMax || state.usesMax === "0")) {
            if (state.usesValue === undefined)
                state.usesValue = 1;
            if (state.usesMax === undefined)
                state.usesMax = `${state.usesValue}`;
        }
    }

    static _pGetItemActorPassive_mutDuration({entry, opts, state}) {
        this._pGetItemActorPassive_mutDuration_creature({
            entry,
            opts,
            state
        });
        this._pGetItemActorPassive_mutDuration_player({
            entry,
            opts,
            state
        });
    }

    static _pGetItemActorPassive_mutDuration_creature({entry, opts, state}) {
        if (opts.mode !== "creature" || !entry.entries)
            return;

        return "stubbed";
    }

    static _pGetItemActorPassive_mutDuration_player({entry, opts, state}) {
        if (opts.mode !== "player" || !entry.entries)
            return;

        UtilDataConverter.WALKER_READONLY_GENERIC.walk(entry.entries, {
            string: (str)=>{
                if (state.durationValue || state.durationUnits)
                    return;

                str.replace(/(?:^|\W)lasts for (\d+) (minute|hour|day|month|year|turn|round)s?(?:\W|$)/gi, (...m)=>{
                    state.durationValue = Number(m[1]);
                    state.durationUnits = m[2].toLowerCase();
                }
                );

                str.replace(/(?:^|\W)for the next (\d+) (minute|hour|day|month|year|turn|round)s?(?:\W|$)/gi, (...m)=>{
                    state.durationValue = Number(m[1]);
                    state.durationUnits = m[2].toLowerCase();
                }
                );

                str.replace(/(?:^|\W)turned for (\d+) (minute|hour|day|month|year|turn|round)s?(?:\W|$)/gi, (...m)=>{
                    state.durationValue = Number(m[1]);
                    state.durationUnits = m[2].toLowerCase();
                }
                );

                str.replace(/(?:^|\W)this effect lasts for (\d+) (minute|hour|day|month|year|turn|round)s?(?:\W|$)/gi, (...m)=>{
                    state.durationValue = Number(m[1]);
                    state.durationUnits = m[2].toLowerCase();
                }
                );

                str.replace(/(?:^|\W)until the end of your next turn(?:\W|$)/gi, ()=>{
                    state.durationValue = 1;
                    state.durationUnits = "turn";
                }
                );

                Renderer.stripTags(str).replace(/(?:^|\W)is \w+ by you for (\d+) (minute|hour|day|month|year|turn|round)s(?:\W|$)/gi, (...m)=>{
                    state.durationValue = Number(m[1]);
                    state.durationUnits = m[2].toLowerCase();
                }
                );
            }
            ,
        }, );
    }

    static _pGetItemActorPassive_getTargetMeta(strEntries) {
        let targetValue, targetUnits, targetType;
        let found = false;

        let tmpEntries = strEntries.replace(/exhales [^.]*a (?<size>\d+)-foot[- ](?<shape>cone|line)/, (...m)=>{
            targetValue = Number(m.last().size);
            targetUnits = "ft";
            targetType = m.last().shape;
            found = true;

            return "";
        }
        );

        if (found)
            return this._pGetItemActorPassive_getTargetMetricAdjusted({
                targetValue,
                targetUnits,
                targetType
            });

        tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot-radius,? \d+-foot-tall cylinder/, (...m)=>{
            targetValue = Number(m.last().size);
            targetUnits = "ft";
            targetType = "cylinder";

            found = true;
            return "";
        }
        );

        if (found)
            return this._pGetItemActorPassive_getTargetMetricAdjusted({
                targetValue,
                targetUnits,
                targetType
            });

        tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot[- ]radius(?<ptSphere> sphere)?/, (...m)=>{
            targetValue = Number(m.last().size);
            targetUnits = "ft";
            targetType = (m.last().ptSphere ? "sphere" : "radius");

            found = true;
            return "";
        }
        );

        if (found)
            return this._pGetItemActorPassive_getTargetMetricAdjusted({
                targetValue,
                targetUnits,
                targetType
            });

        tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot[- ]cube/, (...m)=>{
            targetValue = Number(m.last().size);
            targetUnits = "ft";
            targetType = "cube";

            found = true;
            return "";
        }
        );

        if (found)
            return this._pGetItemActorPassive_getTargetMetricAdjusted({
                targetValue,
                targetUnits,
                targetType
            });

        tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot[- ]square/, (...m)=>{
            targetValue = Number(m.last().size);
            targetUnits = "ft";
            targetType = "square";

            found = true;
            return "";
        }
        );

        if (found)
            return this._pGetItemActorPassive_getTargetMetricAdjusted({
                targetValue,
                targetUnits,
                targetType
            });

        tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot line/, (...m)=>{
            targetValue = Number(m.last().size);
            targetUnits = "ft";
            targetType = "line";

            found = true;
            return "";
        }
        );

        tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot cone/, (...m)=>{
            targetValue = Number(m.last().size);
            targetUnits = "ft";
            targetType = "cone";

            found = true;
            return "";
        }
        );

        if (found)
            return this._pGetItemActorPassive_getTargetMetricAdjusted({
                targetValue,
                targetUnits,
                targetType
            });

        return {};
    }

    static _pGetItemActorPassive_getTargetMetricAdjusted({targetValue, targetUnits, targetType}) {
        targetValue = Config.getMetricNumberDistance({
            configGroup: this._configGroup,
            originalValue: targetValue,
            originalUnit: "feet"
        });
        if (targetUnits)
            targetUnits = Config.getMetricUnitDistance({
                configGroup: this._configGroup,
                originalUnit: targetUnits
            });

        return {
            targetValue,
            targetUnits,
            targetType
        };
    }

    static _pGetItemActorPassive_mutDamageAndFormula({entry, opts, strEntries, state}) {
        this._pGetItemActorPassive_mutDamageAndFormula_playerOrVehicle({
            entry,
            opts,
            strEntries,
            state
        });
        this._pGetItemActorPassive_mutDamageAndFormula_creature({
            entry,
            opts,
            strEntries,
            state
        });
    }

    static _pGetItemActorPassive_mutDamageAndFormula_playerOrVehicle({entry, opts, state, strEntries}) {
        if (opts.mode !== "player" && opts.mode !== "vehicle")
            return;
        if (!entry.entries)
            return;

        let strEntriesNoDamageDice = strEntries;
        if (!state.damageParts?.length) {
            const {str, damageTupleMetas} = this._getDamageTupleMetas(strEntries, {
                summonSpellLevel: opts.summonSpellLevel
            });
            strEntriesNoDamageDice = str;

            const {damageParts: damageParts_, formula: formula_} = this._getDamagePartsAndOtherFormula(damageTupleMetas);

            state.damageParts = damageParts_;
            state.formula = state.formula ?? formula_;
        }

        if (state.formula == null) {
            strEntriesNoDamageDice.replace(/{(?:@dice|@scaledice) ([^|}]+)(?:\|[^}]+)?}/i, (...m)=>{
                const [dice] = m[1].split("|");
                state.formula = dice;
            }
            );
        }
    }

    static _pGetItemActorPassive_mutDamageAndFormula_creature({entry, opts, strEntries, state}) {
        if (opts.mode !== "creature")
            return;
        if (!entry.entries?.length)
            return;

        if (!state.damageParts?.length && state.formula == null) {
            const str = entry.entries[0];
            if (typeof str !== "string")
                return;

            const {damageTupleMetas} = this._getDamageTupleMetas(str);
            const {damageParts, formula} = this._getDamagePartsAndOtherFormula(damageTupleMetas);

            state.damageParts = damageParts;
            state.formula = formula;
        }
    }

    static _pGetItemActorPassive_mutTarget({entry, opts, strEntries, state}) {
        this._pGetItemActorPassive_mutTarget_player({
            entry,
            opts,
            strEntries,
            state
        });
        this._pGetItemActorPassive_mutTarget_creature({
            entry,
            opts,
            strEntries,
            state
        });
    }

    static _pGetItemActorPassive_mutTarget_player({entry, opts, strEntries, state}) {
        if (opts.mode !== "player")
            return;

        if (state.targetPrompt === undefined)
            state.targetPrompt = Config.getSafe(this._configGroup, "isTargetTemplatePrompt");
    }

    static _pGetItemActorPassive_mutTarget_creature({entry, opts, strEntries, state}) {
        if (opts.mode !== "creature")
            return;
        if (!strEntries)
            return;

        if (!state.targetValue && !state.targetUnits && !state.targetType) {
            const targetMeta = this._pGetItemActorPassive_getTargetMeta(strEntries);
            state.targetValue = targetMeta.targetValue || state.targetValue;
            state.targetUnits = targetMeta.targetUnits || state.targetUnits;
            state.targetType = targetMeta.targetType || state.targetType;
        }

        if (state.targetPrompt === undefined)
            state.targetPrompt = Config.getSafe(this._configGroup, "isTargetTemplatePrompt");
    }

    static _pGetItemActorPassive_mutActionType({entry, opts, state}) {
        this._pGetItemActorPassive_mutActionType_player({
            entry,
            opts,
            state
        });
        this._pGetItemActorPassive_mutActionType_creature({
            entry,
            opts,
            state
        });
    }

    static _pGetItemActorPassive_mutActionType_player({entry, opts, state}) {
        if (state.actionType || opts.mode !== "player" || !entry.entries?.length)
            return;

        const walker = MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
            isNoModification: true,
            isBreakOnReturn: true
        });
        walker.walk(entry.entries, {
            string: str=>{
                const mMeleeRangedWeaponAttack = /you\b[^.!?]*\bmake a (?<type>melee|ranged) weapon attack/i.exec(str);
                if (mMeleeRangedWeaponAttack) {
                    state.actionType = mMeleeRangedWeaponAttack.groups.type.toLowerCase() === "melee" ? "mwak" : "rwak";
                    return true;
                }

                const mMeleeRangedSpellAttack = /you\b[^.!?]*\bmake a (?<type>melee|ranged) spell attack/i.exec(str);
                if (mMeleeRangedSpellAttack) {
                    state.actionType = mMeleeRangedSpellAttack.groups.type.toLowerCase() === "melee" ? "msak" : "rsak";
                    return true;
                }

                const mHeal = /creature\b[^.!?]*\bregains\b[^.!?]*\bhit points?/i.exec(str);
                if (mHeal) {
                    state.actionType = "heal";
                    return true;
                }
            }
            ,
        }, );

        state.actionType = state.actionType || "other";
    }

    static _pGetItemActorPassive_mutActionType_creature({entry, opts, state}) {
        if (state.actionType || opts.mode !== "creature" || !entry.entries?.length)
            return;

        state.actionType = "other";
    }

    static _pGetItemActorPassive_mutEffects({entry, opts, state}) {
        this._pGetItemActorPassive_mutEffects_player({
            entry,
            opts,
            state
        });
        this._pGetItemActorPassive_mutEffects_creature({
            entry,
            opts,
            state
        });
    }

    static _pGetItemActorPassive_mutEffects_player({entry, opts, state}) {
        if (opts.mode !== "player" || !entry.entries?.length)
            return;

        void 0;
    }

    static _pGetItemActorPassive_mutEffects_creature({entry, opts, state}) {
        if (opts.mode !== "creature" || !entry.entries?.length)
            return;

        if (!UtilCompat.isPlutoniumAddonAutomationActive())
            return;

        const effects = UtilAutomation.getCreatureFeatureEffects({
            entry,
            img: state.img
        });
        if (effects.length)
            state.effectsParsed.push(...effects);
    }

    static _pGetItemActorPassive_mutFlags({entry, opts, state}) {
        this._pGetItemActorPassive_mutFlags_player({
            entry,
            opts,
            state
        });
        this._pGetItemActorPassive_mutFlags_creature({
            entry,
            opts,
            state
        });
    }

    static _pGetItemActorPassive_mutFlags_player({entry, opts, state}) {
        if (opts.mode !== "player" || !entry.entries?.length)
            return;

        void 0;
    }

    static _pGetItemActorPassive_mutFlags_creature({entry, opts, state}) {
        if (opts.mode !== "creature" || !entry.entries?.length)
            return;

        if (!UtilCompat.isPlutoniumAddonAutomationActive())
            return;

        const flags = UtilAutomation.getCreatureFeatureFlags({
            entry,
            hasDamageParts: !!state.damageParts?.length,
            hasSavingThrow: !!state.saveDc,
        });

        foundry.utils.mergeObject(state.flagsParsed, flags);
    }

    static _DEFAULT_SAVING_THROW_DATA = {
        saveAbility: undefined,
        saveScaling: undefined,
        saveDc: undefined,
    };

    static getSavingThrowData(entries) {
        if (!entries?.length)
            return MiscUtil.copy(this._DEFAULT_SAVING_THROW_DATA);

        let isFoundParse = false;
        let {saveAbility, saveScaling, saveDc, } = MiscUtil.copy(this._DEFAULT_SAVING_THROW_DATA);

        const walker = MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
            isNoModification: true,
            isBreakOnReturn: true
        });
        const reDc = /(?:{@dc (?<dc>\d+)}|DC\s*(?<dcAlt>\d+))\s*(?<ability>Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma)/i;

        walker.walk(entries, {
            string: (str)=>{
                const mDc = reDc.exec(str);
                if (!mDc)
                    return;

                saveDc = Number(mDc.groups.dc || mDc.groups.dcAlt);
                saveAbility = mDc.groups.ability.toLowerCase().substring(0, 3);
                saveScaling = "flat";
                isFoundParse = true;

                return true;
            }
            ,
        }, );

        return {
            saveAbility,
            saveScaling,
            saveDc,
            isFoundParse
        };
    }

    static getMaxCasterProgression(...casterProgressions) {
        casterProgressions = casterProgressions.filter(Boolean);
        const ixs = casterProgressions.map(it=>this._CASTER_PROGRESSIONS.indexOf(it)).filter(ix=>~ix);
        if (!ixs.length)
            return null;
        return this._CASTER_PROGRESSIONS[Math.min(...ixs)];
    }

    static getMaxCantripProgression(...casterProgressions) {
        const out = [];
        casterProgressions.filter(Boolean).forEach(progression=>{
            progression.forEach((cnt,i)=>{
                if (out[i] == null)
                    return out[i] = cnt;
                out[i] = Math.max(out[i], cnt);
            }
            );
        }
        );
        return out;
    }

    static async pFillActorSkillToolLanguageData({existingProficienciesSkills, existingProficienciesTools, existingProficienciesLanguages, skillProficiencies, languageProficiencies, toolProficiencies, skillToolLanguageProficiencies, actorData, importOpts, titlePrefix, }, ) {
        skillToolLanguageProficiencies = this._pFillActorSkillToolLanguageData_getMergedProfs({
            skillProficiencies,
            languageProficiencies,
            toolProficiencies,
            skillToolLanguageProficiencies,
        });

        const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
            titlePrefix,
            existingFvtt: {
                skillProficiencies: existingProficienciesSkills,
                toolProficiencies: existingProficienciesTools,
                languageProficiencies: existingProficienciesLanguages,
            },
            available: skillToolLanguageProficiencies,
        });
        if (!formData)
            return importOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplySkillFormDataToActorUpdate({
            existingProfsActor: existingProficienciesSkills,
            formData,
            actorData,
        });

        this.doApplyOtherProficienciesFormData({
            existingProfsActor: existingProficienciesLanguages,
            formData,
            formDataProp: "languageProficiencies",
            actorData,
            opts: {
                fnGetMappedItem: it=>UtilActors.getMappedLanguage(it),
                fnGetMappedCustomItem: it=>Renderer.splitTagByPipe(it)[0].toTitleCase(),
                actorTraitProp: "languages",
            },
        });

        this.doApplyToolFormDataToActorUpdate({
            existingProfsActor: existingProficienciesTools,
            formData,
            actorData,
        });
    }

    static _pFillActorSkillToolLanguageData_getMergedProfs({skillProficiencies, languageProficiencies, toolProficiencies, skillToolLanguageProficiencies, }, ) {
        const hasAnySingles = skillProficiencies?.length || languageProficiencies?.length || toolProficiencies?.length;
        if (!hasAnySingles)
            return skillToolLanguageProficiencies;

        if (!skillToolLanguageProficiencies?.length) {
            const out = [];
            this._pFillActorSkillToolLanguageData_doMergeToSingleArray({
                targetArray: out,
                skillProficiencies,
                languageProficiencies,
                toolProficiencies,
            });
            return out;
        }

        if (skillToolLanguageProficiencies?.length && hasAnySingles)
            console.warn(...LGT, `Founds individual skill/language/tool proficiencies alongside combined skill/language/tool; these will be merged together.`);

        const out = MiscUtil.copy(skillToolLanguageProficiencies || []);
        this._pFillActorSkillToolLanguageData_doMergeToSingleArray({
            targetArray: out,
            skillProficiencies,
            languageProficiencies,
            toolProficiencies,
        });
        return out;
    }

    static _pFillActorSkillToolLanguageData_doMergeToSingleArray({targetArray, skillProficiencies, languageProficiencies, toolProficiencies, }, ) {
        const maxLen = Math.max(targetArray?.length || 0, skillProficiencies?.length || 0, languageProficiencies?.length || 0, toolProficiencies?.length || 0, );
        for (let i = 0; i < maxLen; ++i) {
            const tgt = (targetArray[i] = {});

            const skillProfSet = skillProficiencies?.[i];
            const langProfSet = languageProficiencies?.[i];
            const toolProfSet = toolProficiencies?.[i];

            if (skillProfSet) {
                this._pFillActorSkillToolLanguageData_doAddProfType({
                    targetObject: tgt,
                    profSet: skillProfSet,
                    validKeySet: new Set(Object.keys(Parser.SKILL_TO_ATB_ABV)),
                    anyKeySet: new Set(["any"]),
                    anyKeySuffix: "Skill",
                });
            }

            if (langProfSet) {
                this._pFillActorSkillToolLanguageData_doAddProfType({
                    targetObject: tgt,
                    profSet: langProfSet,
                    anyKeySet: new Set(["any", "anyStandard", "anyExotic"]),
                    anyKeySuffix: "Language",
                });
            }

            if (toolProfSet) {
                this._pFillActorSkillToolLanguageData_doAddProfType({
                    targetObject: tgt,
                    profSet: toolProfSet,
                    anyKeySet: new Set(["any"]),
                    anyKeySuffix: "Tool",
                });
            }
        }
    }

    static _pFillActorSkillToolLanguageData_doAddProfType({targetObject, profSet, validKeySet, anyKeySet, anyKeySuffix, }, ) {
        Object.entries(profSet).forEach(([k,v])=>{
            switch (k) {
            case "choose":
                {
                    if (v?.from?.length) {
                        const choose = MiscUtil.copy(v);
                        choose.from = choose.from.filter(kFrom=>!validKeySet || validKeySet.has(kFrom));
                        if (choose.from.length) {
                            const tgtChoose = (targetObject.choose = targetObject.choose || []);
                            tgtChoose.push(choose);
                        }
                    }
                    break;
                }

            default:
                {
                    if (anyKeySet && anyKeySet.has(k)) {
                        targetObject[`${k}${anyKeySuffix}`] = MiscUtil.copy(v);
                        break;
                    }

                    if (!validKeySet || validKeySet.has(k))
                        targetObject[k] = MiscUtil.copy(v);
                }
            }
        }
        );
    }

    static async pFillActorSkillData(existingProfsActor, skillProficiencies, actorData, dataBuilderOpts, opts) {
        return this._pFillActorSkillToolData({
            existingProfsActor,
            proficiencies: skillProficiencies,
            actorData,
            dataBuilderOpts,
            opts,
            fnGetMapped: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
            propProficiencies: "skillProficiencies",
            pFnApplyToActorUpdate: this.doApplySkillFormDataToActorUpdate.bind(this),
        });
    }

    static async pFillActorToolData(existingProfsActor, toolProficiencies, actorData, dataBuilderOpts, opts) {
        return this._pFillActorSkillToolData({
            existingProfsActor,
            proficiencies: toolProficiencies,
            actorData,
            dataBuilderOpts,
            opts,
            fnGetMapped: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
            propProficiencies: "toolProficiencies",
            pFnApplyToActorUpdate: this.doApplyToolFormDataToActorUpdate.bind(this),
        });
    }

    static async _pFillActorSkillToolData({existingProfsActor, proficiencies, actorData, dataBuilderOpts, opts, fnGetMapped, propProficiencies, pFnApplyToActorUpdate, }, ) {
        opts = opts || {};

        if (!proficiencies)
            return {};
        proficiencies = fnGetMapped(proficiencies);

        const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
            ...opts,
            existingFvtt: {
                [propProficiencies]: existingProfsActor,
            },
            available: proficiencies,
        });
        if (!formData)
            return dataBuilderOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        return pFnApplyToActorUpdate({
            existingProfsActor,
            formData,
            actorData
        });
    }

    static doApplySkillFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        return this._doApplySkillToolFormDataToActorUpdate({
            existingProfsActor,
            formData,
            actorData,
            mapAbvToFull: UtilActors.SKILL_ABV_TO_FULL,
            propFormData: "skillProficiencies",
            propActorData: "skills",
        }, );
    }

    static doApplyToolFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        return this._doApplySkillToolFormDataToActorUpdate({
            existingProfsActor,
            formData,
            actorData,
            mapAbvToFull: UtilActors.TOOL_ABV_TO_FULL,
            propFormData: "toolProficiencies",
            propActorData: "tools",
        }, );
    }

    static _doApplySkillToolFormDataToActorUpdate({existingProfsActor, formData, actorData, mapAbvToFull, propFormData, propActorData}) {
        if (!formData?.data?.[propFormData])
            return;

        const out = {};

        actorData[propActorData] = actorData[propActorData] || {};
        Object.entries(mapAbvToFull).filter(([_,name])=>formData.data[propFormData][name]).forEach(([abv,name])=>{
            out[abv] = formData.data[propFormData][name];

            const maxValue = Math.max((existingProfsActor[abv] || {}).value || 0, formData.data[propFormData][name] != null ? Number(formData.data[propFormData][name]) : 0, (actorData[propActorData][abv] || {}).value || 0, );

            const isUpdate = maxValue > (MiscUtil.get(actorData[propActorData], abv, "value") || 0);
            if (isUpdate)
                (actorData[propActorData][abv] = actorData[propActorData][abv] || {}).value = maxValue;
        }
        );

        return out;
    }

    static async pFillActorLanguageData(existingProfsActor, importingProfs, data, importOpts, opts) {
        opts = opts || {};

        if (!importingProfs)
            return;
        importingProfs = Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies(importingProfs);

        const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
            ...opts,
            existingFvtt: {
                languageProficiencies: existingProfsActor,
            },
            available: importingProfs,
        });
        if (!formData)
            return importOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplyLanguageProficienciesFormDataToActorUpdate({
            existingProfsActor,
            formData,
            actorData: data
        });
    }

    static doApplyLanguageProficienciesFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        this.doApplyOtherProficienciesFormData({
            existingProfsActor,
            formData,
            formDataProp: "languageProficiencies",
            actorData,
            opts: {
                fnGetMappedItem: it=>UtilActors.getMappedLanguage(it),
                fnGetMappedCustomItem: it=>Renderer.splitTagByPipe(it)[0].toTitleCase(),
                actorTraitProp: "languages",
            },
        });
    }

    static async pFillActorToolProfData(existingProfsActor, importingProfs, data, dataBuilderOpts, opts) {
        opts = opts || {};

        if (!importingProfs)
            return;
        importingProfs = Charactermancer_OtherProficiencySelect.getMappedToolProficiencies(importingProfs);

        const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
            ...opts,
            existingFvtt: {
                toolProficiencies: existingProfsActor,
            },
            available: importingProfs,
        });
        if (!formData)
            return dataBuilderOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplyToolProficienciesFormDataToActorUpdate({
            existingProfsActor,
            formData,
            actorData: data
        });
    }

    static doApplyToolProficienciesFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        this.doApplyToolFormDataToActorUpdate({
            existingProfsActor: existingProfsActor,
            formData,
            actorData,
        });
    }

    static async pFillActorLanguageOrToolData(existingProfsLanguages, existingProfsTools, importingProfs, actorData, importOpts, opts) {
        opts = opts || {};

        if (!importingProfs)
            return;
        importingProfs = Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies(importingProfs);
        importingProfs = Charactermancer_OtherProficiencySelect.getMappedToolProficiencies(importingProfs);

        const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
            ...opts,
            existingFvtt: {
                languageProficiencies: existingProfsLanguages,
                toolProficiencies: existingProfsTools,
            },
            available: importingProfs,
        });
        if (!formData)
            return importOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplyOtherProficienciesFormData({
            existingProfsActor: existingProfsLanguages,
            formData,
            formDataProp: "languageProficiencies",
            actorData,
            opts: {
                fnGetMappedItem: it=>UtilActors.getMappedLanguage(it),
                fnGetMappedCustomItem: it=>Renderer.splitTagByPipe(it)[0].toTitleCase(),
                actorTraitProp: "languages",
            },
        });

        this.doApplyToolFormDataToActorUpdate({
            existingProfsActor: existingProfsTools,
            formData,
            actorData,
        });
    }

    static async pFillActorArmorProfData(existingProfsActor, importingProfs, data, importOpts, opts) {
        opts = opts || {};

        if (!importingProfs)
            return;
        importingProfs = Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies(importingProfs);

        const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
            ...opts,
            existingFvtt: {
                armorProficiencies: existingProfsActor,
            },
            available: importingProfs,
        });
        if (!formData)
            return importOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplyArmorProficienciesFormDataToActorUpdate({
            existingProfsActor,
            formData,
            actorData: data
        });
    }

    static doApplyArmorProficienciesFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        this.doApplyOtherProficienciesFormData({
            existingProfsActor,
            formData,
            formDataProp: "armorProficiencies",
            actorData,
            opts: {
                fnGetMappedItem: it=>UtilActors.getMappedArmorProficiency(it),
                fnGetMappedCustomItem: it=>Renderer.splitTagByPipe(it)[0].toTitleCase(),
                actorTraitProp: "armorProf",
            },
        });
    }

    static async pFillActorWeaponProfData(existingProfsActor, importingProfs, data, importOpts, opts) {
        opts = opts || {};

        if (!importingProfs)
            return;
        importingProfs = Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies(importingProfs);

        const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
            ...opts,
            existingFvtt: {
                weaponProficiencies: existingProfsActor,
            },
            available: importingProfs,
        });
        if (!formData)
            return importOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplyWeaponProficienciesFormDataToActorUpdate({
            existingProfsActor,
            formData,
            actorData: data
        });
    }

    static doApplyWeaponProficienciesFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        this.doApplyOtherProficienciesFormData({
            existingProfsActor,
            formData,
            formDataProp: "weaponProficiencies",
            actorData,
            opts: {
                fnGetMappedItem: it=>UtilActors.getMappedWeaponProficiency(it),
                fnGetMappedCustomItem: it=>Renderer.splitTagByPipe(it)[0].toTitleCase(),
                actorTraitProp: "weaponProf",
            },
        });
    }

    static doApplyOtherProficienciesFormData({existingProfsActor, formData, formDataProp, actorData, opts}) {
        if (!formData?.data?.[formDataProp])
            return false;

        existingProfsActor = existingProfsActor || {};

        const formDataSet = formData.data[formDataProp];

        if (!Object.keys(formDataSet).length)
            return false;
        const cpyFormDataSet = MiscUtil.copy(formDataSet);

        const profSet = new Set();
        Object.keys(cpyFormDataSet).filter(k=>cpyFormDataSet[k]).forEach(k=>profSet.add(k));

        const mappedValidItems = new Set();
        const customItems = [];

        (existingProfsActor.value || []).forEach(it=>mappedValidItems.add(it));
        (existingProfsActor.custom || "").split(";").map(it=>it.trim()).filter(Boolean).forEach(it=>this._doApplyFormData_doCheckAddCustomItem(customItems, it));

        const existingProfsActorData = MiscUtil.get(actorData, "traits", opts.actorTraitProp);
        (existingProfsActorData?.value || []).forEach(it=>mappedValidItems.add(it));
        (existingProfsActorData?.custom || "").split(";").map(it=>it.trim()).filter(Boolean).forEach(it=>this._doApplyFormData_doCheckAddCustomItem(customItems, it));

        profSet.forEach(it=>{
            const mapped = opts.fnGetMappedItem ? opts.fnGetMappedItem(it) : it;
            if (mapped)
                mappedValidItems.add(mapped);
            else {
                const toAdd = opts.fnGetMappedCustomItem ? opts.fnGetMappedCustomItem(it) : it.toTitleCase();
                this._doApplyFormData_doCheckAddCustomItem(customItems, toAdd);
            }
        }
        );

        const dataTarget = MiscUtil.set(actorData, "traits", opts.actorTraitProp, {});
        dataTarget.value = [...mappedValidItems].map(it=>it.toLowerCase()).sort(SortUtil.ascSortLower);
        dataTarget.custom = customItems.join(";");
    }

    static _doApplyFormData_doCheckAddCustomItem(customItems, item) {
        const cleanItem = item.trim().toLowerCase();
        if (!customItems.some(it=>it.trim().toLowerCase() === cleanItem))
            customItems.push(item);
    }

    static doApplySavingThrowProficienciesFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        if (!formData?.data?.savingThrowProficiencies)
            return;

        actorData.abilities = actorData.abilities || {};
        Parser.ABIL_ABVS.filter(ab=>formData.data.savingThrowProficiencies[ab]).forEach(ab=>{
            const maxValue = Math.max(existingProfsActor[ab]?.proficient || 0, formData.data.savingThrowProficiencies[ab] ? 1 : 0, actorData.abilities[ab]?.proficient || 0, );
            const isUpdate = maxValue > (MiscUtil.get(actorData.abilities, ab, "proficient") || 0);
            if (isUpdate)
                MiscUtil.set(actorData.abilities, ab, "proficient", maxValue);
        }
        );
    }

    static async pFillActorImmunityData(existingProfsActor, importing, data, importOpts, opts) {
        opts = opts || {};

        const formData = await Charactermancer_DamageImmunitySelect.pGetUserInput({
            ...opts,
            existingFvtt: {
                immune: existingProfsActor,
            },
            available: importing,
        });
        if (!formData)
            return importOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplyDamageImmunityFormDataToActorUpdate({
            existingProfsActor,
            formData,
            actorData: data
        });
    }

    static async pFillActorResistanceData(existingProfsActor, importing, data, importOpts, opts) {
        opts = opts || {};

        const formData = await Charactermancer_DamageResistanceSelect.pGetUserInput({
            ...opts,
            existingFvtt: {
                resist: existingProfsActor,
            },
            available: importing,
        });
        if (!formData)
            return importOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplyDamageResistanceFormDataToActorUpdate({
            existingProfsActor,
            formData,
            actorData: data
        });
    }

    static async pFillActorVulnerabilityData(existingProfsActor, importing, data, importOpts, opts) {
        opts = opts || {};

        const formData = await Charactermancer_DamageVulnerabilitySelect.pGetUserInput({
            ...opts,
            existingFvtt: {
                vulnerable: existingProfsActor,
            },
            available: importing,
        });
        if (!formData)
            return importOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplyDamageVulnerabilityFormDataToActorUpdate({
            existingProfsActor,
            formData,
            actorData: data
        });
    }

    static async pFillActorConditionImmunityData(existing, importing, data, importOpts, opts) {
        opts = opts || {};

        const formData = await Charactermancer_ConditionImmunitySelect.pGetUserInput({
            ...opts,
            existingFvtt: {
                conditionImmune: existing,
            },
            available: importing,
        });
        if (!formData)
            return importOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplyConditionImmunityFormDataToActorUpdate({
            existingProfsActor: existing,
            formData,
            actorData: data
        });
    }

    static doApplyDamageImmunityFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        this.doApplyOtherProficienciesFormData({
            existingProfsActor,
            formData,
            formDataProp: "immune",
            actorData,
            opts: {
                actorTraitProp: "di",
            },
        });
    }

    static doApplyDamageResistanceFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        this.doApplyOtherProficienciesFormData({
            existingProfsActor,
            formData,
            formDataProp: "resist",
            actorData,
            opts: {
                actorTraitProp: "dr",
            },
        });
    }

    static doApplyDamageVulnerabilityFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        this.doApplyOtherProficienciesFormData({
            existingProfsActor,
            formData,
            formDataProp: "vulnerable",
            actorData,
            opts: {
                actorTraitProp: "dv",
            },
        });
    }

    static doApplyConditionImmunityFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        this.doApplyOtherProficienciesFormData({
            existingProfsActor,
            formData,
            formDataProp: "conditionImmune",
            actorData,
            opts: {
                fnGetMappedItem: it=>it === "disease" ? "diseased" : it,
                actorTraitProp: "ci",
            },
        });
    }

    static async pFillActorExpertiseData({existingProficienciesSkills, existingProficienciesTools, expertise, actorData, importOpts, titlePrefix, }, ) {
        const mergedExistingProficienciesSkills = existingProficienciesSkills ? MiscUtil.copy(existingProficienciesSkills) : existingProficienciesSkills;
        const mergedExistingProficienciesTools = existingProficienciesTools ? MiscUtil.copy(existingProficienciesTools) : existingProficienciesTools;

        if (mergedExistingProficienciesSkills && actorData.skills) {
            Object.entries(actorData.skills).forEach(([key,meta])=>{
                if (!meta)
                    return;

                mergedExistingProficienciesSkills[key] = mergedExistingProficienciesSkills[key] || MiscUtil.copy(meta);
                mergedExistingProficienciesSkills[key].value = Math.max(mergedExistingProficienciesSkills[key].value, meta.value);
            }
            );
        }

        if (mergedExistingProficienciesSkills && actorData.tools) {
            Object.entries(actorData.tools).forEach(([key,meta])=>{
                if (!meta)
                    return;

                mergedExistingProficienciesTools[key] = mergedExistingProficienciesTools[key] || MiscUtil.copy(meta);
                mergedExistingProficienciesTools[key].value = Math.max(mergedExistingProficienciesTools[key].value, meta.value);
            }
            );
        }

        const formData = await Charactermancer_ExpertiseSelect.pGetUserInput({
            titlePrefix,
            existingFvtt: {
                skillProficiencies: mergedExistingProficienciesSkills,
                toolProficiencies: mergedExistingProficienciesTools,
            },
            available: expertise,
        });
        if (!formData)
            return importOpts.isCancelled = true;
        if (formData === VeCt.SYM_UI_SKIP)
            return;

        this.doApplyExpertiseFormDataToActorUpdate({
            existingProfsActor: {
                skillProficiencies: existingProficienciesSkills,
                toolProficiencies: existingProficienciesTools,
            },
            formData,
            actorData: actorData,
        });
    }

    static doApplyExpertiseFormDataToActorUpdate({existingProfsActor, formData, actorData}) {
        this.doApplySkillFormDataToActorUpdate({
            existingProfsActor: existingProfsActor.skillProficiencies,
            formData,
            actorData,
        });

        this.doApplyToolFormDataToActorUpdate({
            existingProfsActor: existingProfsActor.toolProficiencies,
            formData,
            actorData,
        });
    }

    static doApplySensesFormDataToActorUpdate({existingSensesActor, existingTokenActor, formData, actorData, actorToken, configGroup}) {
        if (!Object.keys(formData?.data).length)
            return;

        const dataTarget = MiscUtil.getOrSet(actorData, "attributes", "senses", {});
        Object.assign(dataTarget, MiscUtil.copy(existingSensesActor));

        const foundrySenseData = this._getFoundrySenseData({
            configGroup,
            formData
        });

        this._getSensesNumericalKeys(foundrySenseData).forEach(kSense=>{
            const range = foundrySenseData[kSense];
            delete foundrySenseData[kSense];

            if (range == null)
                return;
            dataTarget[kSense] = Math.max(dataTarget[kSense], range);
        }
        );

        Object.assign(dataTarget, foundrySenseData);

        let {sight: {range: curSightRange}} = existingTokenActor || {
            sight: {}
        };
        if (curSightRange == null || isNaN(curSightRange) || Number(curSightRange) !== curSightRange) {
            const cleanedSightRange = curSightRange == null || isNaN(curSightRange) ? 0 : Number(curSightRange);
            if (curSightRange === 0)
                MiscUtil.set(actorToken, "sight", "range", cleanedSightRange);
        }

        MiscUtil.set(actorToken, "sight", "enabled", true);

        this.mutTokenSight({
            dataAttributesSenses: dataTarget,
            dataToken: actorToken,
            configGroup,
        });
    }

    static _getFoundrySenseData({configGroup, formData}) {
        const out = {};

        Object.entries(formData.data).forEach(([sense,range])=>{
            if (!range)
                return out[sense] = null;

            range = Config.getMetricNumberDistance({
                configGroup,
                originalValue: range,
                originalUnit: "feet"
            });
            range = Number(range.toFixed(2));

            out[sense] = range;
        }
        );

        const units = Config.getMetricUnitDistance({
            configGroup,
            originalUnit: "ft"
        });
        if (!out.units || units !== "ft")
            out.units = units;

        return out;
    }

    static _getSensesNumericalKeys() {
        const sensesModel = CONFIG.Item.dataModels.race.defineSchema().senses;
        return Object.entries(sensesModel.fields).filter(([,v])=>v instanceof foundry.data.fields.NumberField).map(([k])=>k);
    }

    static mutTokenSight({dataAttributesSenses, dataToken, configGroup}) {
        if (!dataAttributesSenses)
            return {
                dataAttributesSenses,
                dataToken
            };

        if (dataAttributesSenses.darkvision) {
            MiscUtil.set(dataToken, "sight", "range", Math.max(dataToken.sight?.dim ?? 0, dataAttributesSenses.darkvision));
            if (dataToken.sight?.visionMode == null || dataToken.sight?.visionMode === "basic")
                MiscUtil.set(dataToken, "sight", "visionMode", "darkvision");
        }

        let hasNonDarkvisionSense = false;
        for (const prop of ["blindsight", "tremorsense", "truesight"]) {
            if (!dataAttributesSenses[prop])
                continue;

            hasNonDarkvisionSense = true;

            const isUse = dataAttributesSenses[prop] > (dataToken.sight?.range ?? 0);
            if (!isUse)
                continue;

            MiscUtil.set(dataToken, "sight", "range", dataAttributesSenses[prop]);

            if (dataToken.sight?.visionMode === "basic") {
                MiscUtil.set(dataToken, "sight", "visionMode", prop === "tremorsense" ? "tremorsense" : "darkvision");
            }
        }

        if (dataAttributesSenses.truesight)
            this._mutTokenSight_addUpdateDetectionMode({
                dataToken,
                id: "seeAll",
                range: dataAttributesSenses.truesight
            });
        if (dataAttributesSenses.tremorsense)
            this._mutTokenSight_addUpdateDetectionMode({
                dataToken,
                id: "feelTremor",
                range: dataAttributesSenses.tremorsense
            });
        if (dataAttributesSenses.blindsight)
            this._mutTokenSight_addUpdateDetectionMode({
                dataToken,
                id: "blindsight",
                range: dataAttributesSenses.blindsight
            });

        if (dataAttributesSenses.darkvision && !hasNonDarkvisionSense && Config.getSafe(configGroup, "tokenVisionSaturation") !== ConfigConsts.C_USE_GAME_DEFAULT) {
            MiscUtil.set(dataToken, "sight", "saturation", -1);
        }

        return {
            dataAttributesSenses,
            dataToken
        };
    }

    static _mutTokenSight_addUpdateDetectionMode({dataToken, id, range}) {
        const detectionModeArr = MiscUtil.getOrSet(dataToken, "detectionModes", []);
        const existing = detectionModeArr.find(mode=>mode?.id === id);
        if (existing)
            return existing.range = Math.max(existing.range, range);
        detectionModeArr.push({
            id,
            range,
            enabled: true
        });
    }

    static _RE_IS_VERSATILE = / (?:two|both) hands/i;
    static _getDamageTupleMetas(str, {summonSpellLevel=0}={}) {
        const damageTupleMetas = [];

        const ixFirstDc = str.indexOf(`{@dc `);

        let ixLastMatch = null;
        let lenLastMatch = null;

        const strOut = str.replace(/(?:(?<dmgFlat>\d+)|\(?{@(?:dice|damage) (?<dmgDice1>[^|}]+)(?:\|[^}]+)?}(?:\s+[-+]\s+the spell's level)?(?: plus {@(?:dice|damage) (?<dmgDice2>[^|}]+)(?:\|[^}]+)?})?\)?)(?:\s+[-+]\s+[-+a-zA-Z0-9 ]*?)?(?: (?<dmgType>[^ ]+))? damage/gi, (...mDamage)=>{
            const [fullMatch] = mDamage;
            const [ixMatch,,{dmgFlat, dmgDice1, dmgDice2, dmgType}] = mDamage.slice(-3);

            const dmgDice1Clean = dmgDice1 ? dmgDice1.split("|")[0] : null;
            const dmgDice2Clean = dmgDice2 ? dmgDice2.split("|")[0] : null;
            const dmgTypeClean = dmgType || "";

            const isFlatDamage = dmgFlat != null;
            let dmg = isFlatDamage ? dmgFlat : dmgDice2Clean ? `${dmgDice1Clean} + ${dmgDice2Clean}` : dmgDice1Clean;

            if (isFlatDamage) {
                const tokens = str.split(/( )/g);
                let lenTokenStack = 0;
                const tokenStack = [];
                for (let i = 0; i < tokens.length; ++i) {
                    tokenStack.push(tokens[i]);
                    lenTokenStack += tokens[i].length;

                    if (lenTokenStack === ixMatch) {
                        const lastFourTokens = tokenStack.slice(-4);
                        if (/^by dealing$/i.test(lastFourTokens.join("").trim())) {
                            return "";
                        }
                    }
                }
            }

            dmg = dmg.replace(/\bPB\b/gi, `@${SharedConsts.MODULE_ID_FAKE}.userchar.pb`);

            dmg = dmg.replace(/\bsummonSpellLevel\b/gi, `${summonSpellLevel ?? 0}`);

            const tupleMeta = {
                tuple: [dmg, dmgTypeClean],
                isOnFailSavingThrow: false,
                isAlternateRoll: false,
            };

            if (~ixFirstDc && ixMatch >= ixFirstDc) {
                tupleMeta.isOnFailSavingThrow = true;
            }

            if (damageTupleMetas.last()?.isAlternateRoll || (damageTupleMetas.length && /\bor\b/.test(str.slice(ixLastMatch + lenLastMatch, ixMatch)) && !this._RE_IS_VERSATILE.test(str.slice(ixMatch + fullMatch.length)))) {
                tupleMeta.isAlternateRoll = true;
            }

            damageTupleMetas.push(tupleMeta);

            ixLastMatch = ixMatch;
            lenLastMatch = fullMatch.length;

            return "";
        }
        ).replace(/ +/g, " ");

        return {
            str: strOut,
            damageTupleMetas: damageTupleMetas.filter(it=>it.tuple.length),
        };
    }

    static _getDamagePartsAndOtherFormula(damageTupleMetas) {
        damageTupleMetas = damageTupleMetas || [];

        const damageTuples = [];
        const otherFormulaParts = [];

        damageTupleMetas.forEach(meta=>{
            if ((!Config.get("import", "isUseOtherFormulaFieldForSaveHalvesDamage") || !meta.isOnFailSavingThrow) && (!Config.get("import", "isUseOtherFormulaFieldForSaveHalvesDamage") || !meta.isAlternateRoll))
                return damageTuples.push(meta.tuple);

            otherFormulaParts.push(`${meta.tuple[1] ? "(" : ""}${meta.tuple[0]}${meta.tuple[1] ? `)[${meta.tuple[1]}]` : ""}`);
        }
        );

        if (!damageTuples.length)
            return {
                damageParts: damageTupleMetas.map(it=>it.tuple),
                formula: ""
            };

        return {
            damageParts: damageTuples,
            formula: otherFormulaParts.join(" + ")
        };
    }

    static _getSpeedValue(speeds, prop, configGroup) {
        if (speeds == null)
            return null;

        if (typeof speeds === "number") {
            return prop === "walk" ? Config.getMetricNumberDistance({
                configGroup,
                originalValue: speeds,
                originalUnit: "feet"
            }) : null;
        }

        const speed = speeds[prop];

        if (speed == null)
            return null;
        if (typeof speed === "boolean")
            return null;
        if (speed.number != null)
            return Config.getMetricNumberDistance({
                configGroup,
                originalValue: speed.number,
                originalUnit: "feet"
            });
        if (isNaN(speed))
            return null;
        return Config.getMetricNumberDistance({
            configGroup,
            originalValue: Number(speed),
            originalUnit: "feet"
        });
    }

    static _SPEED_PROPS_IS_EQUAL_MAP = {
        burrow: "burrow",
        climb: "climb",
        fly: "fly",
        swim: "swim",
    };

    static async _pGetSpeedEffects(speeds, {actor, actorItem, iconEntity, iconPropCompendium, taskRunner=null}={}) {
        if (speeds == null)
            return [];

        const icon = iconEntity && iconPropCompendium ? await this._ImageFetcher.pGetSaveImagePath(iconEntity, {
            propCompendium: iconPropCompendium,
            taskRunner
        }) : undefined;

        if (typeof speeds === "number")
            return [];

        const toMap = Object.entries(speeds).filter(([k,v])=>this._SPEED_PROPS_IS_EQUAL_MAP[k] && v === true);

        if (!toMap.length)
            return [];

        return [...toMap.map(([k])=>{
            return UtilActiveEffects.getGenericEffect({
                key: `system.attributes.movement.${this._SPEED_PROPS_IS_EQUAL_MAP[k]}`,
                value: `@attributes.movement.walk`,
                mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
                name: `${k.toTitleCase()} Speed`,
                icon,
                disabled: false,
                priority: UtilActiveEffects.PRIORITY_BASE,
                originActor: actor,
                originActorItem: actorItem,
            });
        }
        ), ];
    }

    static _isSpeedHover(speed) {
        if (typeof speed === "number")
            return false;
        return !!speed.canHover;
    }

    static getMovement(speed, {configGroup=null, propAllowlist=null}={}) {
        return {
            burrow: (!propAllowlist || propAllowlist.has("burrow")) ? this._getSpeedValue(speed, "burrow", configGroup) : null,
            climb: (!propAllowlist || propAllowlist.has("climb")) ? this._getSpeedValue(speed, "climb", configGroup) : null,
            fly: (!propAllowlist || propAllowlist.has("fly")) ? this._getSpeedValue(speed, "fly", configGroup) : null,
            swim: (!propAllowlist || propAllowlist.has("swim")) ? this._getSpeedValue(speed, "swim", configGroup) : null,
            walk: (!propAllowlist || propAllowlist.has("walk")) ? this._getSpeedValue(speed, "walk", configGroup) : null,
            units: Config.getMetricUnitDistance({
                configGroup,
                originalUnit: "ft"
            }),
            hover: this._isSpeedHover(speed),
        };
    }

    static _getParsedWeaponEntryData(ent) {
        if (!(ent.entries && ent.entries[0] && typeof ent.entries[0] === "string"))
            return;

        const damageTupleMetas = [];
        let attackBonus = 0;

        const str = ent.entries[0];

        damageTupleMetas.push(...this._getDamageTupleMetas(str).damageTupleMetas);

        const {rangeShort, rangeLong, rangeUnits} = this._getAttackRange(str);

        const mHit = /{@hit ([^|}]+)(?:\|[^}]+)?}/gi.exec(str);
        if (mHit) {
            const hitBonus = Number(mHit[1]);
            if (!isNaN(hitBonus)) {
                attackBonus = hitBonus;
            }
        }

        return {
            damageTupleMetas,
            rangeShort,
            rangeLong,
            rangeUnits,
            attackBonus,
        };
    }

    static _getAttackRange(str) {
        let rangeShort = null;
        let rangeLong = null;

        const mRange = /range (\d+)(?:\/(\d+))? ft/gi.exec(str);
        if (mRange) {
            rangeShort = Number(mRange[1]);
            if (mRange[2])
                rangeLong = Number(mRange[2]);
        } else {
            const mReach = /reach (\d+) ft/gi.exec(str);
            if (mReach) {
                rangeShort = Number(mReach[1]);
            }
        }

        rangeShort = Config.getMetricNumberDistance({
            configGroup: this._configGroup,
            originalValue: rangeShort,
            originalUnit: "feet"
        });
        rangeLong = Config.getMetricNumberDistance({
            configGroup: this._configGroup,
            originalValue: rangeLong,
            originalUnit: "feet"
        });

        return {
            rangeShort,
            rangeLong,
            rangeUnits: rangeShort || rangeLong ? Config.getMetricUnitDistance({
                configGroup: this._configGroup,
                originalUnit: "feet"
            }) : null,
        };
    }

    static getActorDamageResImmVulnConditionImm(ent) {
        const out = {};

        const allDis = new Set();
        const bypassDis = new Set();
        let customDis = [];
        this._getActorDamageResImmVulnConditionImm_addDamageTypesOrConditionTypes({
            ent,
            validTypesArr: UtilActors.VALID_DAMAGE_TYPES,
            fnRender: Parser.getFullImmRes,
            prop: "immune",
            allSet: allDis,
            bypassSet: bypassDis,
            customStack: customDis,
        });

        out.di = {
            value: [...allDis],
            custom: customDis.join(", "),
            bypasses: [...bypassDis],
        };

        const allDrs = new Set();
        const bypassDrs = new Set();
        let customDrs = [];
        this._getActorDamageResImmVulnConditionImm_addDamageTypesOrConditionTypes({
            ent,
            validTypesArr: UtilActors.VALID_DAMAGE_TYPES,
            fnRender: Parser.getFullImmRes,
            prop: "resist",
            allSet: allDrs,
            bypassSet: bypassDrs,
            customStack: customDrs,
        });

        out.dr = {
            value: [...allDrs],
            custom: customDrs.join(", "),
            bypasses: [...bypassDrs],
        };

        const allDvs = new Set();
        const bypassDvs = new Set();
        let customDvs = [];
        this._getActorDamageResImmVulnConditionImm_addDamageTypesOrConditionTypes({
            ent,
            validTypesArr: UtilActors.VALID_DAMAGE_TYPES,
            fnRender: Parser.getFullImmRes,
            prop: "vulnerable",
            allSet: allDvs,
            bypassSet: bypassDvs,
            customStack: customDvs,
        });

        out.dv = {
            value: [...allDvs],
            custom: customDvs.join(", "),
            bypasses: [...bypassDvs],
        };

        const allCis = new Set();
        let customCis = [];
        this._getActorDamageResImmVulnConditionImm_addDamageTypesOrConditionTypes({
            ent,
            validTypesArr: UtilActors.VALID_CONDITIONS,
            fnRender: arr=>Parser.getFullCondImm(arr, {
                isPlainText: true
            }),
            prop: "conditionImmune",
            allSet: allCis,
            customStack: customCis,
        });

        out.ci = {
            value: [...allCis],
            custom: customCis.join(", "),
        };

        return out;
    }

    static _getActorDamageResImmVulnConditionImm_addDamageTypesOrConditionTypes({ent, validTypesArr, fnRender, prop, allSet, bypassSet, customStack}, ) {
        if (!ent[prop])
            return;

        ent[prop].forEach(it=>{
            if (validTypesArr.includes(it)) {
                allSet.add(it);
                return;
            }

            if (this._PROPS_DAMAGE_IMM_VULN_RES.has(prop) && it[prop] && it[prop]instanceof Array && CollectionUtil.setEq(new Set(it[prop]), this._SET_PHYSICAL_DAMAGE) && it.note && it.cond) {
                const mNote = /\bnon[- ]?magical\b.*?(?:\baren't (?<bypass>silvered|adamantine)\b)?$/.exec(it.note);

                if (mNote) {
                    bypassSet.add("mgc");

                    switch ((mNote.groups.bypass || "").toLowerCase()) {
                    case "silvered":
                        bypassSet.add("sil");
                        break;
                    case "adamantine":
                        bypassSet.add("ada");
                        break;
                    }

                    it[prop].forEach(sub=>allSet.add(sub));
                    return;
                }
            }

            const asText = fnRender([it]);
            customStack.push(asText);
        }
        );
    }

    static getImportedEmbed(importedEmbeds, itemData) {
        const importedEmbed = importedEmbeds.find(it=>it.raw === itemData);

        if (!importedEmbed) {
            ui.notifications.warn(`Failed to link embedded entity for active effects! ${VeCt.STR_SEE_CONSOLE}`);
            console.warn(...LGT, `Could not find loaded item data`, itemData, `in imported embedded entities`, importedEmbeds);
            return null;
        }

        return importedEmbed;
    }

    static getConsumedSheetItem({consumes, actor}) {
        const lookupNames = [consumes.name.toLowerCase().trim(), consumes.name.toLowerCase().trim().toPlural(), ];

        return (actor?.items?.contents || []).find(it=>it.type === "feat" && lookupNames.includes(it.name.toLowerCase().trim()));
    }

    static _mutApplyDocOwnership(docData, {defaultOwnership, isAddDefaultOwnershipFromConfig, userOwnership, }, ) {
        if (defaultOwnership != null)
            docData.ownership = {
                default: defaultOwnership
            };
        else if (isAddDefaultOwnershipFromConfig)
            docData.ownership = {
                default: Config.get(this._configGroup, "ownership")
            };

        if (userOwnership)
            Object.assign(docData.ownership ||= {}, userOwnership);
    }

    static mutEffectsDisabledTransfer(effects, configGroup, opts={}) {
        if (!effects)
            return;

        return effects.map(effect=>this.mutEffectDisabledTransfer(effect, configGroup, opts));
    }

    static mutEffectDisabledTransfer(effect, configGroup, {hintDisabled=null, hintTransfer=null, hintSelfTarget=null, }={}, ) {
        if (!effect)
            return;

        const disabled = Config.get(configGroup, "setEffectDisabled");
        switch (disabled) {
        case ConfigConsts.C_USE_PLUT_VALUE:
            effect.disabled = hintDisabled != null ? hintDisabled : false;
            break;
        case ConfigConsts.C_BOOL_DISABLED:
            effect.disabled = false;
            break;
        case ConfigConsts.C_BOOL_ENABLED:
            effect.disabled = true;
            break;
        }

        const transfer = Config.get(configGroup, "setEffectTransfer");
        switch (transfer) {
        case ConfigConsts.C_USE_PLUT_VALUE:
            effect.transfer = hintTransfer != null ? hintTransfer : true;
            break;
        case ConfigConsts.C_BOOL_DISABLED:
            effect.transfer = false;
            break;
        case ConfigConsts.C_BOOL_ENABLED:
            effect.transfer = true;
            break;
        }

        if (UtilCompat.isPlutoniumAddonAutomationActive()) {
            const val = hintTransfer != null ? hintSelfTarget : false;
            MiscUtil.set(effect, "flags", UtilCompat.MODULE_DAE, "selfTarget", val);
            MiscUtil.set(effect, "flags", UtilCompat.MODULE_DAE, "selfTargetAlways", val);
        }

        return effect;
    }

    static getEffectsMutDedupeId(effects) {
        if (!effects?.length)
            return effects;

        const usedDedupeIds = new Set();

        effects.forEach(eff=>{
            const dedupeIdExisting = eff.flags?.[SharedConsts.MODULE_ID]?.dedupeId;
            if (dedupeIdExisting && !usedDedupeIds.has(dedupeIdExisting)) {
                usedDedupeIds.add(dedupeIdExisting);
                return;
            }

            if (!eff.name)
                throw new Error(`Effect did not have a name!`);

            const dedupeIdBase = dedupeIdExisting ?? eff.name.slugify({
                strict: true
            });
            if (!usedDedupeIds.has(dedupeIdBase)) {
                usedDedupeIds.add(dedupeIdBase);
                MiscUtil.set(eff, "flags", SharedConsts.MODULE_ID, "dedupeId", dedupeIdBase);
                return;
            }

            for (let i = 0; i < 99; ++i) {
                const dedupeId = `${dedupeIdBase}-${i}`;
                if (!usedDedupeIds.has(dedupeId)) {
                    usedDedupeIds.add(dedupeId);
                    MiscUtil.set(eff, "flags", SharedConsts.MODULE_ID, "dedupeId", dedupeId);
                    return;
                }
            }

            throw new Error(`Could not find an available dedupeId for base "${dedupeIdBase}"!`);
        }
        );

        return effects;
    }

    static _getTranslationData({srdData, }, ) {
        if (!srdData || !Config.get("integrationBabele", "isEnabled") || !UtilCompat.isBabeleActive() || !srdData.flags?.[UtilCompat.MODULE_BABELE])
            return null;

        return {
            name: srdData.name,
            description: srdData.system?.description?.value,
            flags: {
                [UtilCompat.MODULE_BABELE]: {
                    translated: !!srdData.flags[UtilCompat.MODULE_BABELE].translated,
                    hasTranslation: !!srdData.flags[UtilCompat.MODULE_BABELE].hasTranslation,
                },
            },
        };
    }

    static _getTranslationMeta({name, translationData, description, }, ) {
        if (translationData == null)
            return {
                name,
                description,
                flags: {}
            };

        const flags = {
            [UtilCompat.MODULE_BABELE]: {
                ...(translationData.flags?.[UtilCompat.MODULE_BABELE] || {}),
                originalName: name,
            },
        };

        name = translationData.name;

        if (description && Config.get("integrationBabele", "isUseTranslatedDescriptions"))
            description = translationData.description || description;

        return {
            name,
            description,
            flags
        };
    }

    static _getIdObj({id=null}={}) {
        if (id == null)
            id = foundry.utils.randomID();
        return {
            _id: id,
            id,
        };
    }
}

DataConverter.SYM_AT = "<PLUT_SYM__AT>";

DataConverter.ITEM_TYPES_ACTOR_TOOLS = new Set(["AT", "GS", "INS", "T"]);
DataConverter.ITEM_TYPES_ACTOR_WEAPONS = new Set(["M", "R"]);
DataConverter.ITEM_TYPES_ACTOR_ARMOR = new Set(["LA", "MA", "HA", "S"]);

DataConverter._PROPS_DAMAGE_IMM_VULN_RES = new Set(["immune", "resist", "vulnerable"]);
DataConverter._SET_PHYSICAL_DAMAGE = new Set(["bludgeoning", "piercing", "slashing"]);

DataConverter._CASTER_PROGRESSIONS = ["full", "artificer", "1/2", "1/3", "pact", ];

var DataConverter$1 = /*#__PURE__*/
Object.freeze({
    __proto__: null,
    DataConverter: DataConverter
});

class DataConverterJournal extends DataConverter {
    static _mutPageDataOwnershipFlags({pageData, flags}) {
        pageData.ownership = {
            default: CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT
        };
        pageData.flags = flags ? MiscUtil.copy(flags) : {};
    }

    static _getContentPage({name, content, flags}) {
        if (!content)
            return null;

        const pageData = {
            name,
            type: "text",
            text: {
                format: 1,
                content,
            },
        };
        this._mutPageDataOwnershipFlags({
            pageData,
            flags
        });
        return pageData;
    }

    static _getImgPage({name, img, flags}) {
        if (!img)
            return null;

        const pageData = {
            name: `${name} (Image)`,
            type: "image",
            src: img,
        };
        this._mutPageDataOwnershipFlags({
            pageData,
            flags
        });
        return pageData;
    }

    static _getPages({name, content, img, flags}) {
        return [this._getContentPage({
            name,
            content,
            flags
        }), this._getImgPage({
            name,
            img,
            flags
        }), ].filter(Boolean);
    }

    static async _pGetWithJournalDescriptionPlugins(pFn) {
        return UtilDataConverter.pGetWithDescriptionPlugins(async()=>{
            const renderer = Renderer.get().setPartPageExpandCollapseDisabled(true);
            const out = await pFn();
            renderer.setPartPageExpandCollapseDisabled(false);
            return out;
        }
        );
    }
}

class DataConverterClass extends DataConverter {
    static _configGroup = "importClass";

    static _SideDataInterface = SideDataInterfaceClass;
    //TEMPFIX static _ImageFetcher = ImageFetcherClass;

    static _getDoNotUseNote() {
        return UtilDataConverter.pGetWithDescriptionPlugins(()=>`<p>${Renderer.get().render(`{@note Note: importing a class as an item is provided for display purposes only. If you wish to import a class to a character sheet, please use the importer on the sheet instead.}`)}</p>`);
    }

    static _getDataHitDice(cls) {
        if (cls.hd?.number !== 1)
            return null;
        if (!cls.hd?.faces)
            return null;

        const asString = `d${cls.hd.faces}`;
        if (!CONFIG.DND5E.hitDieTypes.includes(asString))
            return null;
        return asString;
    }

    static async pGetClassItem(cls, opts) {
        opts = opts || {};
        if (opts.actor)
            opts.isActorItem = true;

        Renderer.get().setFirstSection(true).resetHeaderIndex();

        const itemId = foundry.utils.randomID();

        if (!opts.isClsDereferenced) {
            cls = await DataLoader.pCacheAndGet("class", cls.source, UrlUtil.URL_TO_HASH_BUILDER["class"](cls), {
                isRequired: true
            });
        }

        if (opts.pageFilter?.filterBox && opts.filterValues) {
            cls = MiscUtil.copy(cls);

            Renderer.class.mutFilterDereferencedClassFeatures({
                cpyCls: cls,
                pageFilter: opts.pageFilter,
                filterValues: opts.filterValues,
            });
        }

        const srdData = await UtilCompendium.getSrdCompendiumEntity("class", cls, {
            taskRunner: opts.taskRunner
        });

        const {name: translatedName, description: translatedDescription, flags: translatedFlags} = this._getTranslationMeta({
            translationData: this._getTranslationData({
                srdData
            }),
            name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(cls, {
                isActorItem: opts.isActorItem
            })),
            description: await this._pGetClassDescription(cls, opts),
        });

        const identifierCls = UtilDocumentItem.getNameAsIdentifier(cls.name);

        //TEMPFIX
        /* const img = await this._ImageFetcher.pGetSaveImagePath(cls, {
            propCompendium: "class",
            taskRunner: opts.taskRunner
        }); */

        const hitDice = this._getDataHitDice(cls);

        const additionalData = await this._SideDataInterface.pGetDataSideLoaded(cls);
        const additionalFlags = await this._SideDataInterface.pGetFlagsSideLoaded(cls);
        const additionalAdvancement = await this._SideDataInterface._pGetAdvancementSideLoaded(cls);

        const effectsSideTuples = await this._SideDataInterface.pGetEffectsSideLoadedTuples({
            ent: cls,
            img,
            actor: opts.actor
        });
        effectsSideTuples.forEach(({effect, effectRaw})=>DataConverter.mutEffectDisabledTransfer(effect, "importClass", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

        const out = {
            id: itemId,
            _id: itemId,
            name: translatedName,
            type: "class",
            system: {
                identifier: identifierCls,
                description: {
                    value: translatedDescription,
                    chat: "",
                    unidentified: ""
                },
                source: UtilDocumentSource.getSourceObjectFromEntity(cls),
                levels: opts.level ?? 1,
                hitDice,
                hitDiceUsed: 0,
                spellcasting: {
                    progression: UtilActors.getMappedCasterType(cls.casterProgression) || cls.casterProgression,
                    ability: cls.spellcastingAbility,
                },
                advancement: [...(srdData?.system?.advancement || []).filter(it=>it.type === "ScaleValue"), ...this._getClassAdvancement(cls, opts), ...(additionalAdvancement || []), ],

                ...additionalData,
            },
            ownership: {
                default: 0
            },
            flags: {
                ...translatedFlags,
                ...this._getClassSubclassFlags({
                    cls,
                    filterValues: opts.filterValues,
                    proficiencyImportMode: opts.proficiencyImportMode,
                    isActorItem: opts.isActorItem,
                    spellSlotLevelSelection: opts.spellSlotLevelSelection,
                }),
                ...additionalFlags,
            },
            effects: DataConverter.getEffectsMutDedupeId([await this._pGetPreparedSpellsEffect({
                cls,
                actorId: opts.actor?.id,
                itemId,
                existing: this._getExistingPreparedSpellsEffect({
                    actor: opts.actor
                }),
                taskRunner: opts.taskRunner,
            }), ...effectsSideTuples.map(it=>it.effect), ].filter(Boolean), ),
            img,
        };

        this._mutApplyDocOwnership(out, opts);

        return out;
    }

    static async _pGetClassDescription(cls, opts) {
        const ptDoNotUse = !opts.isActorItem ? await this._getDoNotUseNote() : "";

        const ptTable = await UtilDataConverter.pGetWithDescriptionPlugins(()=>this.pGetRenderedClassTable(cls));

        const ptFluff = cls?.fluff?.length ? await UtilDataConverter.pGetWithDescriptionPlugins(()=>Renderer.get().setFirstSection(true).render({
            type: cls.fluff[0].type || "section",
            entries: cls.fluff[0].entries || []
        })) : "";

        const ptFeatures = !opts.isActorItem ? await UtilDataConverter.pGetWithDescriptionPlugins(()=>Renderer.get().setFirstSection(true).render({
            type: "section",
            entries: cls.classFeatures.flat()
        })) : "";

        if (!Config.get("importClass", "isImportDescription"))
            return `<div class="mb-2 ve-flex-col">${ptDoNotUse}${ptTable}</div>`;

        return `<div class="mb-2 ve-flex-col">${ptDoNotUse}${ptTable}${ptFluff}${ptFeatures}</div>`;
    }

    static _getClassAdvancement(cls, opts) {
        return [...this._getClassAdvancement_hitPoints(cls, opts), ...this._getClassAdvancement_saves(cls, opts), ...this._getClassAdvancement_skills(cls, opts), ];
    }

    static _getClassAdvancement_hitPoints(cls, opts) {
        const hitDice = this._getDataHitDice(cls);
        if (hitDice == null)
            return [];

        const advancement = UtilAdvancements.getAdvancementHitPoints({
            hpAdvancementValue: opts.hpAdvancementValue,
            isActorItem: opts.isActorItem,
        });
        if (advancement == null)
            return [];

        return [advancement];
    }

    static _getClassAdvancement_saves(cls, opts) {
        const saves = (cls.proficiency || []).filter(it=>Parser.ATB_ABV_TO_FULL[it]);
        if (!saves.length)
            return [];

        const advancement = UtilAdvancements.getAdvancementSaves({
            savingThrowProficiencies: [saves.mergeMap(abv=>({
                [abv]: true
            }))],
            classRestriction: "primary",
            level: 1,
        });
        if (advancement == null)
            return [];

        return [advancement];
    }

    static _getClassAdvancement_skills(cls, opts) {
        return [UtilAdvancements.getAdvancementSkills({
            skillProficiencies: cls.startingProficiencies?.skills,
            classRestriction: "primary",
            skillsChosenFvtt: opts.proficiencyImportMode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY ? opts.startingSkills : null,
            level: 1,
        }), UtilAdvancements.getAdvancementSkills({
            skillProficiencies: cls.multiclassing?.proficienciesGained?.skills,
            classRestriction: "secondary",
            skillsChosenFvtt: opts.proficiencyImportMode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS ? opts.startingSkills : null,
            level: 1,
        }), ].filter(Boolean);
    }

    static _getClassSubclassFlags({cls, sc, filterValues, proficiencyImportMode, isActorItem, spellSlotLevelSelection}) {
        const out = {
            [SharedConsts.MODULE_ID]: {
                page: UrlUtil.PG_CLASSES,
                source: sc ? sc.source : cls.source,
                hash: sc ? UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc) : UrlUtil.URL_TO_HASH_BUILDER["class"](cls),

                propDroppable: sc ? "subclass" : "class",
                filterValues,

                isPrimaryClass: proficiencyImportMode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY,

                spellSlotLevelSelection,
            },
        };

        if (isActorItem)
            out[SharedConsts.MODULE_ID].isDirectImport = true;

        return out;
    }

    static _getAllSkillChoices(skillProfs) {
        const allSkills = new Set();

        skillProfs.forEach(skillProfGroup=>{
            Object.keys(Parser.SKILL_TO_ATB_ABV).filter(skill=>skillProfGroup[skill]).forEach(skill=>allSkills.add(skill));

            if (skillProfGroup.choose?.from?.length) {
                skillProfGroup.choose.from.filter(skill=>Parser.SKILL_TO_ATB_ABV[skill]).forEach(skill=>allSkills.add(skill));
            }
        }
        );

        return Object.entries(UtilActors.SKILL_ABV_TO_FULL).filter(([,vetKey])=>allSkills.has(vetKey)).map(([fvttKey])=>fvttKey);
    }

    static async pGetSubclassItem(cls, sc, opts) {
        opts = opts || {};
        if (opts.actor)
            opts.isActorItem = true;

        Renderer.get().setFirstSection(true).resetHeaderIndex();

        const itemId = foundry.utils.randomID();

        if (!opts.isScDereferenced) {
            sc = await DataLoader.pCacheAndGet("subclass", sc.source, UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc));
        }

        if (opts.pageFilter?.filterBox && opts.filterValues) {
            sc = MiscUtil.copy(sc);

            Renderer.class.mutFilterDereferencedSubclassFeatures({
                cpySc: sc,
                pageFilter: opts.pageFilter,
                filterValues: opts.filterValues,
            });
        }

        const srdData = await UtilCompendium.getSrdCompendiumEntity("subclass", sc, {
            taskRunner: opts.taskRunner
        });

        const {name: translatedName, description: translatedDescription, flags: translatedFlags} = this._getTranslationMeta({
            translationData: this._getTranslationData({
                srdData
            }),
            name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(sc, {
                isActorItem: opts.isActorItem
            })),
            description: await this._pGetSubclassDescription(cls, sc, opts),
        });

        const identifierCls = UtilDocumentItem.getNameAsIdentifier(cls.name);
        const identifierSc = UtilDocumentItem.getNameAsIdentifier(sc.name);

        //TEMPFIX
       /*  const imgMetaSc = await this._ImageFetcher.pGetSaveImagePathMeta(sc, {
            propCompendium: "subclass",
            taskRunner: opts.taskRunner
        });
        const imgMetaCls = (Config.get("importClass", "isUseDefaultSubclassImage") || (imgMetaSc && !imgMetaSc.isFallback)) ? null : await this._ImageFetcher.pGetSaveImagePathMeta(cls, {
            propCompendium: "class",
            taskRunner: opts.taskRunner
        }); */

        const img = (imgMetaSc && !imgMetaSc.isFallback) ? imgMetaSc.img : imgMetaCls && !imgMetaCls.isFallback ? imgMetaCls.img : (imgMetaSc?.img || imgMetaCls.img);

        const additionalData = await this._SideDataInterface.pGetDataSideLoaded(sc, {
            propOpts: "_SIDE_LOAD_OPTS_SUBCLASS"
        });
        const additionalFlags = await this._SideDataInterface.pGetFlagsSideLoaded(sc, {
            propOpts: "_SIDE_LOAD_OPTS_SUBCLASS"
        });
        const additionalAdvancement = await this._SideDataInterface._pGetAdvancementSideLoaded(sc, {
            propOpts: "_SIDE_LOAD_OPTS_SUBCLASS"
        });

        const effectsSideTuples = await this._SideDataInterface.pGetEffectsSideLoadedTuples({
            ent: sc,
            img,
            actor: opts.actor
        }, {
            propOpts: "_SIDE_LOAD_OPTS_SUBCLASS"
        });
        effectsSideTuples.forEach(({effect, effectRaw})=>DataConverter.mutEffectDisabledTransfer(effect, "importClass", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

        const out = {
            id: itemId,
            _id: itemId,
            name: translatedName,
            type: "subclass",
            system: {
                identifier: identifierSc,
                classIdentifier: identifierCls,
                description: {
                    value: translatedDescription,
                    chat: "",
                    unidentified: ""
                },
                source: UtilDocumentSource.getSourceObjectFromEntity(sc),
                spellcasting: {
                    progression: UtilActors.getMappedCasterType(sc.casterProgression) || sc.casterProgression,
                    ability: sc.spellcastingAbility,
                },
                advancement: [...(srdData?.system?.advancement || []).filter(it=>it.type === "ScaleValue"), ...(additionalAdvancement || []), ],

                ...additionalData,
            },
            ownership: {
                default: 0
            },
            flags: {
                ...translatedFlags,
                ...this._getClassSubclassFlags({
                    cls,
                    sc,
                    filterValues: opts.filterValues,
                    proficiencyImportMode: opts.proficiencyImportMode,
                    isActorItem: opts.isActorItem,
                }),
                ...additionalFlags,
            },
            effects: DataConverter.getEffectsMutDedupeId([await this._pGetPreparedSpellsEffect({
                cls,
                sc,
                actorId: opts.actor?.id,
                itemId,
                existing: this._getExistingPreparedSpellsEffect({
                    actor: opts.actor
                }),
                taskRunner: opts.taskRunner,
            }), ...effectsSideTuples.map(it=>it.effect), ].filter(Boolean), ),
            img,
        };

        this._mutApplyDocOwnership(out, opts);

        return out;
    }

    static async _pGetSubclassDescription(cls, sc, opts) {
        const ptDoNotUse = !opts.isActorItem ? await this._getDoNotUseNote() : "";

        const fluff = MiscUtil.copy(Renderer.findEntry(sc.subclassFeatures || {}));

        const cleanEntries = MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST
        }).walk(MiscUtil.copy(fluff.entries), {
            array: (arr)=>{
                return arr.filter(it=>!it?.data?.isFvttSyntheticFeatureLink);
            }
            ,
        }, );

        const ptFluff = opts.isActorItem ? Renderer.get().setFirstSection(true).render({
            type: "entries",
            entries: cleanEntries
        }) : "";

        const ptFeatures = !opts.isActorItem ? await UtilDataConverter.pGetWithDescriptionPlugins(()=>Renderer.get().setFirstSection(true).render({
            type: "section",
            entries: sc.subclassFeatures.flat()
        })) : "";

        if (!Config.get("importClass", "isImportDescription"))
            return `<div class="mb-2 ve-flex-col">${ptDoNotUse}</div>`;

        return `<div class="mb-2 ve-flex-col">${ptDoNotUse}${ptFluff}${ptFeatures}</div>`;
    }

    static async pGetRenderedClassTable(cls, sc, opts={}) {
        if (!Config.get("importClass", "isImportClassTable"))
            return "";

        return UtilDataConverter.pGetWithDescriptionPlugins(async()=>{
            cls = await DataLoader.pCacheAndGet("class", cls.source, UrlUtil.URL_TO_HASH_BUILDER["class"](cls));

            if (sc) {
                sc = await DataLoader.pCacheAndGet("subclass", sc.source, UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc));
            }

            return this.getRenderedClassTableFromDereferenced(cls, sc, opts);
        }
        );
    }

    static getRenderedClassTableFromDereferenced(cls, sc, {isAddHeader=false, isSpellsOnly=false}={}) {
        if (!cls)
            return "";

        return Vetools.withUnpatchedDiceRendering(()=>{
            Renderer.get().setFirstSection(true).resetHeaderIndex();

            const tblGroupHeaders = [];
            const tblHeaders = [];

            const renderTableGroupHeader = (tableGroup)=>{
                let thGroupHeader;
                if (tableGroup.title) {
                    thGroupHeader = `<th class="cls-tbl__col-group" colspan="${tableGroup.colLabels.length}">${tableGroup.title}</th>`;
                } else {
                    thGroupHeader = `<th colspan="${tableGroup.colLabels.length}"></th>`;
                }
                tblGroupHeaders.push(thGroupHeader);

                tableGroup.colLabels.forEach(lbl=>{
                    tblHeaders.push(`<th class="cls-tbl__col-generic-center"><div class="cls__squash_header">${Renderer.get().render(lbl)}</div></th>`);
                }
                );
            }
            ;

            if (cls.classTableGroups) {
                cls.classTableGroups.forEach(tableGroup=>{
                    if (isSpellsOnly)
                        tableGroup = this._getRenderedClassTableFromDereferenced_getSpellsOnlyTableGroup(tableGroup);
                    if (!tableGroup)
                        return;
                    renderTableGroupHeader(tableGroup);
                }
                );
            }

            if (sc?.subclassTableGroups) {
                sc.subclassTableGroups.forEach(tableGroup=>{
                    if (isSpellsOnly)
                        tableGroup = this._getRenderedClassTableFromDereferenced_getSpellsOnlyTableGroup(tableGroup);
                    if (!tableGroup)
                        return;
                    renderTableGroupHeader(tableGroup);
                }
                );
            }

            const tblRows = cls.classFeatures.map((lvlFeatures,ixLvl)=>{
                const pb = Math.ceil((ixLvl + 1) / 4) + 1;

                const lvlFeaturesFilt = lvlFeatures.filter(it=>it.name && it.type !== "inset");
                const dispsFeatures = lvlFeaturesFilt.map((it,ixFeature)=>`<div class="inline-block">${it.name}${ixFeature === lvlFeaturesFilt.length - 1 ? "" : `<span class="mr-1">,</span>`}</div>`);

                const ptTableGroups = [];

                const renderTableGroupRow = (tableGroup)=>{
                    const row = (tableGroup.rowsSpellProgression || tableGroup.rows)[ixLvl] || [];
                    const cells = row.map(cell=>`<td class="cls-tbl__col-generic-center">${cell === 0 ? "\u2014" : Renderer.get().render(cell)}</td>`);
                    ptTableGroups.push(...cells);
                }
                ;

                if (cls.classTableGroups) {
                    cls.classTableGroups.forEach(tableGroup=>{
                        if (isSpellsOnly)
                            tableGroup = this._getRenderedClassTableFromDereferenced_getSpellsOnlyTableGroup(tableGroup);
                        if (!tableGroup)
                            return;
                        renderTableGroupRow(tableGroup);
                    }
                    );
                }

                if (sc?.subclassTableGroups) {
                    sc.subclassTableGroups.forEach(tableGroup=>{
                        if (isSpellsOnly)
                            tableGroup = this._getRenderedClassTableFromDereferenced_getSpellsOnlyTableGroup(tableGroup);
                        if (!tableGroup)
                            return;
                        renderTableGroupRow(tableGroup);
                    }
                    );
                }

                return `<tr class="cls-tbl__stripe-odd">
					<td class="cls-tbl__col-level">${Parser.getOrdinalForm(ixLvl + 1)}</td>
					${isSpellsOnly ? "" : `<td class="cls-tbl__col-prof-bonus">+${pb}</td>`}
					${isSpellsOnly ? "" : `<td>${dispsFeatures.join("") || `\u2014`}</td>`}
					${ptTableGroups.join("")}
				</tr>`;
            }
            );

            return `<table class="cls-tbl shadow-big w-100 mb-3">
				<tbody>
				<tr><th class="border" colspan="15"></th></tr>
				${isAddHeader ? `<tr><th class="cls-tbl__disp-name" colspan="15">${cls.name}</th></tr>` : ""}
				<tr>
					<th colspan="${isSpellsOnly ? "1" : "3"}"></th>
					${tblGroupHeaders.join("")}
				</tr>
				<tr>
					<th class="cls-tbl__col-level">Level</th>
					${isSpellsOnly ? "" : `<th class="cls-tbl__col-prof-bonus">Proficiency Bonus</th>`}
					${isSpellsOnly ? "" : `<th>Features</th>`}
					${tblHeaders.join("")}
				</tr>
				${tblRows.join("")}
				<tr><th class="border" colspan="15"></th></tr>
				</tbody>
			</table>`;
        }
        );
    }

    static _getRenderedClassTableFromDereferenced_getSpellsOnlyTableGroup(tableGroup) {
        tableGroup = MiscUtil.copy(tableGroup);

        if (/spell/i.test(`${tableGroup.title || ""}`))
            return tableGroup;

        if (!tableGroup.colLabels)
            return null;

        const ixsSpellLabels = new Set(tableGroup.colLabels.map((it,ix)=>{
            const stripped = Renderer.stripTags(`${it || ""}`);
            return /cantrip|spell|slot level/i.test(stripped) ? ix : null;
        }
        ).filter(ix=>ix != null));

        if (!ixsSpellLabels.size)
            return null;

        tableGroup.colLabels = tableGroup.colLabels.filter((_,ix)=>ixsSpellLabels.has(ix));
        if (tableGroup.rowsSpellProgression)
            tableGroup.rowsSpellProgression = tableGroup.rowsSpellProgression.map(row=>row.filter((_,ix)=>ixsSpellLabels.has(ix)));
        if (tableGroup.rows)
            tableGroup.rows = tableGroup.rows.map(row=>row.filter((_,ix)=>ixsSpellLabels.has(ix)));

        return tableGroup;
    }

    static _getExistingPreparedSpellsEffect({actor}) {
        if (!actor)
            return null;
        return actor.effects.contents.find(it=>(it.name || "").toLowerCase().trim() === "prepared spells");
    }

    static async _pGetPreparedSpellsEffect({cls, sc, actorId, itemId, existing, taskRunner}) {
        if (existing)
            return null;
        if (sc && !sc.preparedSpells)
            return null;
        if (!sc && !cls.preparedSpells)
            return null;

        const spellsPreparedFormula = Charactermancer_Spell_Util.getMaxPreparedSpellsFormula({
            cls,
            sc
        });
        if (!spellsPreparedFormula)
            return null;

        if (game)
            return null;

        return UtilActiveEffects.getGenericEffect({
            key: `flags.${UtilCompat.MODULE_TIDY5E_SHEET}.maxPreparedSpells`,
            value: spellsPreparedFormula,
            mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
            name: `Prepared Spells`,
            //TEMPFIX
            /* icon: await this._ImageFetcher.pGetSaveImagePath(cls, {
                propCompendium: "class",
                taskRunner
            }), */
            disabled: false,
            priority: UtilActiveEffects.PRIORITY_BASE,
            originActorId: actorId,
            originActorItemId: itemId,
        });
    }

    static isStubClass(cls) {
        if (!cls)
            return false;
        return cls.name === DataConverterClass.STUB_CLASS.name && cls.source === DataConverterClass.STUB_CLASS.source;
    }

    static isStubSubclass(sc) {
        if (!sc)
            return false;
        return sc.name === DataConverterClass.STUB_SUBCLASS.name && sc.source === DataConverterClass.STUB_SUBCLASS.source;
    }

    static getClassStub() {
        const out = MiscUtil.copy(DataConverterClass.STUB_CLASS);
        out.subclasses = [{
            ...MiscUtil.copy(DataConverterClass.STUB_SUBCLASS),
            className: out.name,
            classSource: out.source,
        }, ];
        return out;
    }

    static getSubclassStub({cls}) {
        const out = MiscUtil.copy(DataConverterClass.STUB_SUBCLASS);
        out.className = cls.name;
        out.classSource = cls.source;
        return out;
    }
}
//#endregion
//#region Util
class Util {
    static _getLogTag() {
        return [`%cPlutonium`, `color: #337ab7; font-weight: bold;`, `|`, ];
    }

    static isDebug() {
        return !!CONFIG?.debug?.module?.[SharedConsts.MODULE_ID];
    }

    static _HEIGHT_MAX_OFFSET = 160;
    static getMaxWindowHeight(desiredHeight) {
        const targetHeight = Math.min(desiredHeight || Number.MAX_SAFE_INTEGER, document.documentElement.clientHeight - this._HEIGHT_MAX_OFFSET);
        return Math.max(this._HEIGHT_MAX_OFFSET, targetHeight);
    }

    static _WIDTH_MAX_OFFSET = 250;
    static getMaxWindowWidth(desiredWidth) {
        const targetWidth = Math.min(desiredWidth || Number.MAX_SAFE_INTEGER, document.documentElement.clientWidth - this._WIDTH_MAX_OFFSET);
        return Math.max(this._WIDTH_MAX_OFFSET, targetWidth);
    }

    static getWithoutParens(str) {
        return str.replace(/\([^)]+\)/g, "").trim();
    }
    static getTokens(str) {
        return str.split(/([ ,:;()"])/g).filter(Boolean);
    }
    static isPunctuation(token) {
        return /[,:;()"]/.test(token);
    }
    static isCapsFirst(word) {
        return /^[A-Z]/.test(word);
    }
    static getSentences(str) {
        return str.replace(/ +/g, " ").split(/[.?!]/g).map(it=>it.trim()).filter(Boolean);
    }

    static getRounded(n, dp) {
        return Number(n.toFixed(dp));
    }

    static trimObject(obj) {
        const walker = MiscUtil.getWalker({
            isAllowDeleteObjects: true,
            isDepthFirst: true,
        });

        return walker.walk(obj, {
            object: (it)=>{
                Object.entries(it).forEach(([k,v])=>{
                    if (v === undefined)
                        delete it[k];
                }
                );
                if (!Object.keys(it).length)
                    return undefined;
                return it;
            }
            ,
        }, );
    }

    static getCleanServerUrl(url) {
        return url.replace(/^(.*?)\/*$/, "$1/");
    }
}

const LGT = Util._getLogTag();
Util.Fvtt = class {
    static getOwnershipEnum({isIncludeDefault=false}={}) {
        return [isIncludeDefault ? {
            value: -1,
            name: "Default"
        } : null, ...Object.entries(CONST.DOCUMENT_OWNERSHIP_LEVELS).map(([name,value])=>({
            value,
            name: name.toTitleCase(),
        })), ].filter(Boolean);
    }

    static getMinimumRolesEnum() {
        return [...Object.entries(CONST.USER_ROLES).map(([name,value])=>({
            value,
            name: name.toTitleCase(),
        })), {
            value: CONST.USER_ROLES.GAMEMASTER + 1,
            name: `Cheater (Disable Feature)`,
        }, ];
    }

    static canUserCreateFolders() {
        return game.user.isGM;
    }
}
;
//#endregion
//#region UtilCompat
class UtilCompat {
    static isModuleActive(moduleId) {
        return !!game.modules.get(moduleId)?.active;
    }

    static _MODULE_LIB_WRAPPER = "lib-wrapper";
    static MODULE_DAE = "dae";
    static _MODULE_DRAG_UPLOAD = "dragupload";
    static MODULE_MIDI_QOL = "midi-qol";
    static MODULE_KANKA_FOUNDRY = "kanka-foundry";
    static MODULE_SMOL_FOUNDRY = "smol-foundry";
    static MODULE_PERMISSION_VIEWER = "permission_viewer";
    static _MODULE_TWILIGHT_UI = "twilight-ui";
    static MODULE_TIDY5E_SHEET = "tidy5e-sheet";
    static _MODULE_OBSIDIAN = "obsidian";
    static MODULE_BABELE = "babele";
    static MODULE_MONKS_LITTLE_DETAILS = "monks-little-details";
    static MODULE_MONKS_BLOODSPLATS = "monks-bloodsplats";
    static MODULE_MONKS_ENHANCED_JOURNAL = "monks-enhanced-journal";
    static MODULE_BETTER_ROLLTABLES = "better-rolltables";
    static _MODULE_BETTER_ROLLTABLES = "item-piles";
    static MODULE_PLUTONIUM_ADDON_AUTOMATION = "plutonium-addon-automation";
    static MODULE_LEVELS = "levels";
    static MODULE_MULTICLASS_SPELLBOOK_FILTER = "spell-class-filter-for-5e";
    static MODULE_ROLLDATA_AWARE_ACTIVE_EFFECTS = "fvtt-rolldata-aware-active-effects";
    static MODULE_QUICK_INSERT = "quick-insert";
    static MODULE_PF2E_TOKENS_BESTIARIES = "pf2e-tokens-bestiaries";
    static _MODULE_DFREDS_CONVENIENT_EFFECTS = "dfreds-convenient-effects";
    static MODULE_LEVELS_3D_PREVIEW = "levels-3d-preview";
    static _MODULE_CANVAS_3D_COMPENDIUM = "canvas3dcompendium";
    static _MODULE_CANVAS_3D_TOKEN_COMPENDIUM = "canvas3dtokencompendium";
    static _MODULE_FOUNDRY_SUMMONS = "foundry-summons";
    static _MODULE_TOKEN_ACTION_HUD = "token-action-hud";
    static _MODULE_TOKEN_ACTION_HUD_CORE = "token-action-hud-core";
    static MODULE_SIMPLE_CALENDAR = "foundryvtt-simple-calendar";

    static isLibWrapperActive() {
        return this.isModuleActive(UtilCompat._MODULE_LIB_WRAPPER);
    }
    static isDaeActive() {
        return this.isModuleActive(UtilCompat.MODULE_DAE);
    }
    static isDragUploadActive() {
        return this.isModuleActive(UtilCompat._MODULE_DRAG_UPLOAD);
    }
    static isPermissionViewerActive() {
        return this.isModuleActive(UtilCompat.MODULE_PERMISSION_VIEWER);
    }
    static isSmolFoundryActive() {
        return this.isModuleActive(UtilCompat.MODULE_SMOL_FOUNDRY);
    }
    static isTwilightUiActive() {
        return this.isModuleActive(UtilCompat._MODULE_TWILIGHT_UI);
    }
    static isTidy5eSheetActive() {
        return this.isModuleActive(UtilCompat.MODULE_TIDY5E_SHEET);
    }
    static isObsidianActive() {
        return this.isModuleActive(UtilCompat._MODULE_OBSIDIAN);
    }
    static isBabeleActive() {
        return this.isModuleActive(UtilCompat.MODULE_BABELE);
    }
    static isMonksLittleDetailsActive() {
        return this.isModuleActive(UtilCompat.MODULE_MONKS_LITTLE_DETAILS);
    }
    static isMonksBloodsplatsActive() {
        return this.isModuleActive(UtilCompat.MODULE_MONKS_BLOODSPLATS);
    }
    static isBetterRolltablesActive() {
        return this.isModuleActive(UtilCompat.MODULE_BETTER_ROLLTABLES);
    }
    static isItemPilesActive() {
        return this.isModuleActive(UtilCompat._MODULE_BETTER_ROLLTABLES);
    }
    static isPlutoniumAddonAutomationActive() {
        return this.isModuleActive(UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION);
    }
    static isMidiQolActive() {
        return this.isModuleActive(UtilCompat.MODULE_MIDI_QOL);
    }
    static isModuleMulticlassSpellbookFilterActive() {
        return this.isModuleActive(UtilCompat.MODULE_MULTICLASS_SPELLBOOK_FILTER);
    }
    static isQuickInsertActive() {
        return this.isModuleActive(UtilCompat.MODULE_QUICK_INSERT);
    }
    static isPf2eTokensBestiaryActive() {
        return this.isModuleActive(UtilCompat.MODULE_PF2E_TOKENS_BESTIARIES);
    }
    static isDfredsConvenientEffectsActive() {
        return this.isModuleActive(UtilCompat._MODULE_DFREDS_CONVENIENT_EFFECTS);
    }
    static isLevels3dPreviewActive() {
        return this.isModuleActive(UtilCompat.MODULE_LEVELS_3D_PREVIEW);
    }
    static _isCanvas3dCompendiumActive() {
        return this.isModuleActive(UtilCompat._MODULE_CANVAS_3D_COMPENDIUM);
    }
    static _iCanvas3dTokenCompendiumActive() {
        return this.isModuleActive(UtilCompat._MODULE_CANVAS_3D_TOKEN_COMPENDIUM);
    }
    static isFoundrySummonsActive() {
        return this.isModuleActive(UtilCompat._MODULE_FOUNDRY_SUMMONS);
    }
    static isTokenActionHudActive() {
        return this.isModuleActive(UtilCompat._MODULE_TOKEN_ACTION_HUD) || this.isModuleActive(UtilCompat._MODULE_TOKEN_ACTION_HUD_CORE);
    }
    static isSimpleCalendarActive() {
        return this.isModuleActive(UtilCompat.MODULE_SIMPLE_CALENDAR);
    }

    static isThreeDiTokensActive() {
        return this.isLevels3dPreviewActive() && this._isCanvas3dCompendiumActive() && this._iCanvas3dTokenCompendiumActive();
    }

    static getApi(moduleName) {
        if (!this.isModuleActive(moduleName))
            return null;
        return game.modules.get(moduleName).api;
    }

    static getName(moduleName) {
        if (!this.isModuleActive(moduleName))
            return null;
        return game.modules.get(moduleName).title;
    }

    static isDaeGeneratingArmorEffects() {
        if (!this.isDaeActive())
            return false;
        return !!UtilGameSettings.getSafe(UtilCompat.MODULE_DAE, "calculateArmor");
    }

    static getFeatureFlags({isReaction}) {
        const out = {};

        if (isReaction) {
            out.adnd5e = {
                itemInfo: {
                    type: "reaction"
                }
            };
        }

        return out;
    }

    static MonksLittleDetails = class {
        static isDefeated(token) {
            return ((token.combatant && token.isDefeated) || token.actor?.effects.some(it=>it.statuses.has(CONFIG.specialStatusEffects.DEFEATED)) || token.document.overlayEffect === CONFIG.controlIcons.defeated);
        }
    }
    ;

    static DfredsConvenientEffects = class {
        static getCustomEffectsItemId() {
            return UtilGameSettings.getSafe(UtilCompat._MODULE_DFREDS_CONVENIENT_EFFECTS, "customEffectsItemId");
        }
    }
    ;

    static FoundrySummons = class {
        static getBlankNpcIds() {
            return (UtilGameSettings.getSafe(UtilCompat._MODULE_FOUNDRY_SUMMONS, "blankNPC") || []).map(it=>it?.id).filter(Boolean);
        }
    }
    ;
}
//#endregion

//#region DataUtil
class _DataUtilPropConfig {
    static _MERGE_REQUIRES_PRESERVE = {};
    static _PAGE = null;

    static get PAGE() {
        return this._PAGE;
    }

    static async pMergeCopy(lst, ent, options) {
        return DataUtil.generic._pMergeCopy(this, this._PAGE, lst, ent, options);
    }
}

class _DataUtilPropConfigSingleSource extends _DataUtilPropConfig {
    static _FILENAME = null;

    static getDataUrl() {
        return `${Renderer.get().baseUrl}data/${this._FILENAME}`;
    }

    static async loadJSON() {
        return this.loadRawJSON();
    }
    static async loadRawJSON() {
        return DataUtil.loadJSON(this.getDataUrl());
    }
    static async loadUnmergedJSON() {
        return DataUtil.loadRawJSON(this.getDataUrl());
    }
}

class _DataUtilPropConfigMultiSource extends _DataUtilPropConfig {
    static _DIR = null;
    static _PROP = null;
    static _IS_MUT_ENTITIES = false;

    static get _isFluff() {
        return this._PROP.endsWith("Fluff");
    }

    static _P_INDEX = null;

    static pLoadIndex() {
        this._P_INDEX = this._P_INDEX || DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${this._DIR}/${this._isFluff ? `fluff-` : ""}index.json`);
        return this._P_INDEX;
    }

    static async pLoadAll() {
        const json = await this.loadJSON();
        return json[this._PROP];
    }

    static async loadJSON() {
        return this._loadJSON({
            isUnmerged: false
        });
    }
    static async loadUnmergedJSON() {
        return this._loadJSON({
            isUnmerged: true
        });
    }

    static async _loadJSON({isUnmerged=false}={}) {
        const index = await this.pLoadIndex();

        const allData = await Object.entries(index).pMap(async([source,file])=>this._pLoadSourceEntities({
            source,
            isUnmerged,
            file
        }));

        return {
            [this._PROP]: allData.flat()
        };
    }

    static async pLoadSingleSource(source) {
        const index = await this.pLoadIndex();

        const file = index[source];
        if (!file)
            return null;

        return {
            [this._PROP]: await this._pLoadSourceEntities({
                source,
                file
            })
        };
    }

    static async _pLoadSourceEntities({source, isUnmerged=false, file}) {
        await this._pInitPreData();

        const fnLoad = isUnmerged ? DataUtil.loadRawJSON.bind(DataUtil) : DataUtil.loadJSON.bind(DataUtil);

        let data = await fnLoad(`${Renderer.get().baseUrl}data/${this._DIR}/${file}`);
        data = data[this._PROP].filter(it=>it.source === source);

        if (!this._IS_MUT_ENTITIES)
            return data;

        return data.map(ent=>this._mutEntity(ent));
    }

    static _P_INIT_PRE_DATA = null;

    static async _pInitPreData() {
        return (this._P_INIT_PRE_DATA = this._P_INIT_PRE_DATA || this._pInitPreData_());
    }

    static async _pInitPreData_() {}

    static _mutEntity(ent) {
        return ent;
    }
}

class _DataUtilPropConfigCustom extends _DataUtilPropConfig {
    static async loadJSON() {
        throw new Error("Unimplemented!");
    }
    static async loadUnmergedJSON() {
        throw new Error("Unimplemented!");
    }
}

class _DataUtilBrewHelper {
    constructor({defaultUrlRoot}) {
        this._defaultUrlRoot = defaultUrlRoot;
    }

    _getCleanUrlRoot(urlRoot) {
        if (urlRoot && urlRoot.trim()) {
            urlRoot = urlRoot.trim();
            if (!urlRoot.endsWith("/"))
                urlRoot = `${urlRoot}/`;
            return urlRoot;
        }
        return this._defaultUrlRoot;
    }

    async pLoadTimestamps(urlRoot) {
        urlRoot = this._getCleanUrlRoot(urlRoot);
        return DataUtil.loadJSON(`${urlRoot}_generated/index-timestamps.json`);
    }

    async pLoadPropIndex(urlRoot) {
        urlRoot = this._getCleanUrlRoot(urlRoot);
        return DataUtil.loadJSON(`${urlRoot}_generated/index-props.json`);
    }

    async pLoadMetaIndex(urlRoot) {
        urlRoot = this._getCleanUrlRoot(urlRoot);
        return DataUtil.loadJSON(`${urlRoot}_generated/index-meta.json`);
    }

    async pLoadSourceIndex(urlRoot) {
        urlRoot = this._getCleanUrlRoot(urlRoot);
        return DataUtil.loadJSON(`${urlRoot}_generated/index-sources.json`);
    }

    getFileUrl(path, urlRoot) {
        urlRoot = this._getCleanUrlRoot(urlRoot);
        return `${urlRoot}${path}`;
    }
}
globalThis.DataUtil = {
    _loading: {},
    _loaded: {},
    _merging: {},
    _merged: {},

    async _pLoad({url, id, isBustCache=false}) {
        if (DataUtil._loading[id] && !isBustCache) {
            await DataUtil._loading[id];
            return DataUtil._loaded[id];
        }

        DataUtil._loading[id] = new Promise((resolve,reject)=>{
            const request = new XMLHttpRequest();

            request.open("GET", url, true);
            request.overrideMimeType("application/json");

            request.onload = function() {
                try { DataUtil._loaded[id] = JSON.parse(this.response); resolve(); }
                catch (e) { reject(new Error(`Could not parse JSON from ${url}: ${e.message}`)); }
            }
            ;
            request.onerror = (e)=>{
                const ptDetail = ["status", "statusText", "readyState", "response", "responseType", ].map(prop=>`${prop}=${JSON.stringify(e.target[prop])}`).join(" ");
                reject(new Error(`Error during JSON request: ${ptDetail}`));
            };

            request.send();
        });

        await DataUtil._loading[id];
        return DataUtil._loaded[id];
    },

    _mutAddProps(data) {
        if (data && typeof data === "object") {
            for (const k in data) {
                if (data[k]instanceof Array) {
                    for (const it of data[k]) {
                        if (typeof it !== "object")
                            continue;
                        it.__prop = k;
                    }
                }
            }
        }
    },

    async loadJSON(url) { return DataUtil._loadJson(url, { isDoDataMerge: true }); },

    async loadRawJSON(url, {isBustCache}={}) {
        return DataUtil._loadJson(url, { isBustCache });
    },

    async _loadJson(url, {isDoDataMerge=false, isBustCache=false}={}) {
        const procUrl = UrlUtil.link(url, { isBustCache });

        let data;
        try { data = await DataUtil._pLoad({url: procUrl, id: url, isBustCache });}
        catch (e) {setTimeout(()=>{throw e;});}

        if (!data){data = await DataUtil._pLoad({url: url, id: url, isBustCache});}
        
        if (isDoDataMerge){await DataUtil.pDoMetaMerge(url, data);}

        return data;
    },

    async pDoMetaMerge(ident, data, options) {
        DataUtil._mutAddProps(data);
        DataUtil._merging[ident] = DataUtil._merging[ident] || DataUtil._pDoMetaMerge(ident, data, options);
        await DataUtil._merging[ident];
        const out = DataUtil._merged[ident];

        if (options?.isSkipMetaMergeCache) {
            delete DataUtil._merging[ident];
            delete DataUtil._merged[ident];
        }

        return out;
    },

    _pDoMetaMerge_handleCopyProp(prop, arr, entry, options) {
        if (!entry._copy)
            return;
        let fnMergeCopy = DataUtil[prop]?.pMergeCopy;
        if (!fnMergeCopy)
            throw new Error(`No dependency _copy merge strategy specified for property "${prop}"`);
        fnMergeCopy = fnMergeCopy.bind(DataUtil[prop]);
        return fnMergeCopy(arr, entry, options);
    },

    async _pDoMetaMerge(ident, data, options) {
        if (data._meta) {
            const loadedSourceIds = new Set();

            if (data._meta.dependencies) {
                await Promise.all(Object.entries(data._meta.dependencies).map(async([dataProp,sourceIds])=>{
                    sourceIds.forEach(sourceId=>loadedSourceIds.add(sourceId));

                    if (!data[dataProp])
                        return;
                    const isHasInternalCopies = (data._meta.internalCopies || []).includes(dataProp);

                    const dependencyData = await Promise.all(sourceIds.map(sourceId=>DataUtil.pLoadByMeta(dataProp, sourceId)));

                    const flatDependencyData = dependencyData.map(dd=>dd[dataProp]).flat().filter(Boolean);
                    await Promise.all(data[dataProp].map(entry=>DataUtil._pDoMetaMerge_handleCopyProp(dataProp, flatDependencyData, entry, {
                        ...options,
                        isErrorOnMissing: !isHasInternalCopies
                    })));
                }
                ));
                delete data._meta.dependencies;
            }

            if (data._meta.internalCopies) {
                for (const prop of data._meta.internalCopies) {
                    if (!data[prop])
                        continue;
                    for (const entry of data[prop]) {
                        await DataUtil._pDoMetaMerge_handleCopyProp(prop, data[prop], entry, {
                            ...options,
                            isErrorOnMissing: true
                        });
                    }
                }
                delete data._meta.internalCopies;
            }

            if (data._meta.includes) {
                const includesData = await Promise.all(Object.entries(data._meta.includes).map(async([dataProp,sourceIds])=>{
                    sourceIds = sourceIds.filter(it=>!loadedSourceIds.has(it));

                    sourceIds.forEach(sourceId=>loadedSourceIds.add(sourceId));

                    const includesData = await Promise.all(sourceIds.map(sourceId=>DataUtil.pLoadByMeta(dataProp, sourceId)));

                    const flatIncludesData = includesData.map(dd=>dd[dataProp]).flat().filter(Boolean);
                    return {
                        dataProp,
                        flatIncludesData
                    };
                }
                ));
                delete data._meta.includes;

                includesData.forEach(({dataProp, flatIncludesData})=>{
                    data[dataProp] = [...data[dataProp] || [], ...flatIncludesData];
                }
                );
            }
        }

        if (data._meta && data._meta.otherSources) {
            await Promise.all(Object.entries(data._meta.otherSources).map(async([dataProp,sourceIds])=>{
                const additionalData = await Promise.all(Object.entries(sourceIds).map(async([sourceId,findWith])=>({
                    findWith,
                    dataOther: await DataUtil.pLoadByMeta(dataProp, sourceId),
                })));

                additionalData.forEach(({findWith, dataOther})=>{
                    const toAppend = dataOther[dataProp].filter(it=>it.otherSources && it.otherSources.find(os=>os.source === findWith));
                    if (toAppend.length)
                        data[dataProp] = (data[dataProp] || []).concat(toAppend);
                }
                );
            }
            ));
            delete data._meta.otherSources;
        }

        if (data._meta && !Object.keys(data._meta).length)
            delete data._meta;

        DataUtil._merged[ident] = data;
    },

    async pDoMetaMergeSingle(prop, meta, ent) {
        return (await DataUtil.pDoMetaMerge(CryptUtil.uid(), {
            _meta: meta,
            [prop]: [ent],
        }, {
            isSkipMetaMergeCache: true,
        }, ))[prop][0];
    },

    getCleanFilename(filename) {
        return filename.replace(/[^-_a-zA-Z0-9]/g, "_");
    },

    getCsv(headers, rows) {
        function escapeCsv(str) {
            return `"${str.replace(/"/g, `""`).replace(/ +/g, " ").replace(/\n\n+/gi, "\n\n")}"`;
        }

        function toCsv(row) {
            return row.map(str=>escapeCsv(str)).join(",");
        }

        return `${toCsv(headers)}\n${rows.map(r=>toCsv(r)).join("\n")}`;
    },

    userDownload(filename, data, {fileType=null, isSkipAdditionalMetadata=false, propVersion="siteVersion", valVersion=VERSION_NUMBER}={}) {
        filename = `${filename}.json`;
        if (isSkipAdditionalMetadata || data instanceof Array)
            return DataUtil._userDownload(filename, JSON.stringify(data, null, "\t"), "text/json");

        data = {
            [propVersion]: valVersion,
            ...data
        };
        if (fileType != null)
            data = {
                fileType,
                ...data
            };
        return DataUtil._userDownload(filename, JSON.stringify(data, null, "\t"), "text/json");
    },

    userDownloadText(filename, string) {
        return DataUtil._userDownload(filename, string, "text/plain");
    },

    _userDownload(filename, data, mimeType) {
        const a = document.createElement("a");
        const t = new Blob([data],{
            type: mimeType
        });
        a.href = window.URL.createObjectURL(t);
        a.download = filename;
        a.dispatchEvent(new MouseEvent("click",{
            bubbles: true,
            cancelable: true,
            view: window
        }));
        setTimeout(()=>window.URL.revokeObjectURL(a.href), 100);
    },

    pUserUpload({isMultiple=false, expectedFileTypes=null, propVersion="siteVersion", }={}, ) {
        return new Promise(resolve=>{
            const $iptAdd = $(`<input type="file" ${isMultiple ? "multiple" : ""} class="ve-hidden" accept=".json">`).on("change", (evt)=>{
                const input = evt.target;

                const reader = new FileReader();
                let readIndex = 0;
                const out = [];
                const errs = [];

                reader.onload = async()=>{
                    const name = input.files[readIndex - 1].name;
                    const text = reader.result;

                    try {
                        const json = JSON.parse(text);

                        const isSkipFile = expectedFileTypes != null && json.fileType && !expectedFileTypes.includes(json.fileType) && !(await InputUiUtil.pGetUserBoolean({
                            textYes: "Yes",
                            textNo: "Cancel",
                            title: "File Type Mismatch",
                            htmlDescription: `The file "${name}" has the type "${json.fileType}" when the expected file type was "${expectedFileTypes.join("/")}".<br>Are you sure you want to upload this file?`,
                        }));

                        if (!isSkipFile) {
                            delete json.fileType;
                            delete json[propVersion];

                            out.push({
                                name,
                                json
                            });
                        }
                    } catch (e) {
                        errs.push({
                            filename: name,
                            message: e.message
                        });
                    }

                    if (input.files[readIndex]) {
                        reader.readAsText(input.files[readIndex++]);
                        return;
                    }

                    resolve({
                        files: out,
                        errors: errs,
                        jsons: out.map(({json})=>json),
                    });
                }
                ;

                reader.readAsText(input.files[readIndex++]);
            }
            ).appendTo(document.body);

            $iptAdd.click();
        }
        );
    },

    doHandleFileLoadErrorsGeneric(errors) {
        if (!errors)
            return;
        errors.forEach(err=>{
            JqueryUtil.doToast({
                content: `Could not load file "${err.filename}": <code>${err.message}</code>. ${VeCt.STR_SEE_CONSOLE}`,
                type: "danger",
            });
        }
        );
    },

    cleanJson(cpy, {isDeleteUniqueId=true}={}) {
        if (!cpy)
            return cpy;
        cpy.name = cpy._displayName || cpy.name;
        if (isDeleteUniqueId)
            delete cpy.uniqueId;
        DataUtil.__cleanJsonObject(cpy);
        return cpy;
    },

    _CLEAN_JSON_ALLOWED_UNDER_KEYS: ["_copy", "_versions", "_version", ],
    __cleanJsonObject(obj) {
        if (obj == null)
            return obj;
        if (typeof obj !== "object")
            return obj;

        if (obj instanceof Array) {
            return obj.forEach(it=>DataUtil.__cleanJsonObject(it));
        }

        Object.entries(obj).forEach(([k,v])=>{
            if (DataUtil._CLEAN_JSON_ALLOWED_UNDER_KEYS.includes(k))
                return;
            if ((k.startsWith("_") && k !== "_") || k === "customHashId")
                delete obj[k];
            else
                DataUtil.__cleanJsonObject(v);
        }
        );
    },

    _MULTI_SOURCE_PROP_TO_DIR: {
        "monster": "bestiary",
        "monsterFluff": "bestiary",
        "spell": "spells",
        "spellFluff": "spells",
        "class": "class",
        "subclass": "class",
        "classFeature": "class",
        "subclassFeature": "class",
    },
    _MULTI_SOURCE_PROP_TO_INDEX_NAME: {
        "class": "index.json",
        "subclass": "index.json",
        "classFeature": "index.json",
        "subclassFeature": "index.json",
    },
    async pLoadByMeta(prop, source) {

        switch (prop) {
        case "monster":
        case "spell":
        case "monsterFluff":
        case "spellFluff":
            {
                const data = await DataUtil[prop].pLoadSingleSource(source);
                if (data)
                    return data;

                return DataUtil._pLoadByMeta_pGetPrereleaseBrew(source);
            }

        case "class":
        case "subclass":
        case "classFeature":
        case "subclassFeature":
            {
                const baseUrlPart = `${Renderer.get().baseUrl}data/${DataUtil._MULTI_SOURCE_PROP_TO_DIR[prop]}`;
                const index = await DataUtil.loadJSON(`${baseUrlPart}/${DataUtil._MULTI_SOURCE_PROP_TO_INDEX_NAME[prop]}`);
                if (index[source])
                    return DataUtil.loadJSON(`${baseUrlPart}/${index[source]}`);

                return DataUtil._pLoadByMeta_pGetPrereleaseBrew(source);
            }

        case "item":
        case "itemGroup":
        case "baseitem":
            {
                const data = await DataUtil.item.loadRawJSON();
                if (data[prop] && data[prop].some(it=>it.source === source))
                    return data;
                return DataUtil._pLoadByMeta_pGetPrereleaseBrew(source);
            }
        case "race":
            {
                const data = await DataUtil.race.loadJSON({
                    isAddBaseRaces: true
                });
                if (data[prop] && data[prop].some(it=>it.source === source))
                    return data;
                return DataUtil._pLoadByMeta_pGetPrereleaseBrew(source);
            }

        default:
            {
                const impl = DataUtil[prop];
                if (impl && (impl.getDataUrl || impl.loadJSON)) {
                    const data = await (impl.loadJSON ? impl.loadJSON() : DataUtil.loadJSON(impl.getDataUrl()));
                    if (data[prop] && data[prop].some(it=>it.source === source))
                        return data;

                    return DataUtil._pLoadByMeta_pGetPrereleaseBrew(source);
                }

                throw new Error(`Could not get loadable URL for \`${JSON.stringify({
                    key: prop,
                    value: source
                })}\``);
            }
        }
    },

    async _pLoadByMeta_pGetPrereleaseBrew(source) {
        const fromPrerelease = await DataUtil.pLoadPrereleaseBySource(source);
        if (fromPrerelease)
            return fromPrerelease;

        const fromBrew = await DataUtil.pLoadBrewBySource(source);
        if (fromBrew)
            return fromBrew;

        throw new Error(`Could not find prerelease/brew URL for source "${source}"`);
    },

    async pLoadPrereleaseBySource(source) {
        if (typeof PrereleaseUtil === "undefined")
            return null;
        return this._pLoadPrereleaseBrewBySource({
            source,
            brewUtil: PrereleaseUtil
        });
    },

    async pLoadBrewBySource(source) {
        if (typeof BrewUtil2 === "undefined")
            return null;
        return this._pLoadPrereleaseBrewBySource({
            source,
            brewUtil: BrewUtil2
        });
    },

    async _pLoadPrereleaseBrewBySource({source, brewUtil}) {
        const fromExisting = await brewUtil.pGetBrewBySource(source);
        if (fromExisting)
            return MiscUtil.copyFast(fromExisting.body);

        const url = await brewUtil.pGetSourceUrl(source);
        if (!url)
            return null;

        return DataUtil.loadJSON(url);
    },

    dbg: {
        isTrackCopied: false,
    },

    generic: {
        _MERGE_REQUIRES_PRESERVE_BASE: {
            page: true,
            otherSources: true,
            srd: true,
            basicRules: true,
            reprintedAs: true,
            hasFluff: true,
            hasFluffImages: true,
            hasToken: true,
            _versions: true,
        },

        _walker_replaceTxt: null,

        unpackUid(uid, tag, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,source,displayText,...others] = uid.split("|").map(Function.prototype.call.bind(String.prototype.trim));

            source = source || Parser.getTagSource(tag, source);
            if (opts.isLower)
                source = source.toLowerCase();

            return {
                name,
                source,
                displayText,
                others,
            };
        },

        packUid(ent, tag) {
            const sourceDefault = Parser.getTagSource(tag);
            return [ent.name, (ent.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : ent.source, ].join("|").replace(/\|+$/, "");
        },

        getNormalizedUid(uid, tag) {
            const {name, source} = DataUtil.generic.unpackUid(uid, tag, {
                isLower: true
            });
            return [name, source].join("|");
        },

        getUid(ent, {isMaintainCase=false}={}) {
            const {name} = ent;
            const source = SourceUtil.getEntitySource(ent);
            if (!name || !source)
                throw new Error(`Entity did not have a name and source!`);
            const out = [name, source].join("|");
            if (isMaintainCase)
                return out;
            return out.toLowerCase();
        },

        async _pMergeCopy(impl, page, entryList, entry, options) {
            if (!entry._copy)
                return;

            const hashCurrent = UrlUtil.URL_TO_HASH_BUILDER[page](entry);
            const hash = UrlUtil.URL_TO_HASH_BUILDER[page](entry._copy);

            if (hashCurrent === hash)
                throw new Error(`${hashCurrent} _copy self-references! This is a bug!`);

            const it = (impl._mergeCache = impl._mergeCache || {})[hash] || DataUtil.generic._pMergeCopy_search(impl, page, entryList, entry, options);

            if (!it) {
                if (options.isErrorOnMissing) {
                    if (!IS_DEPLOYED && !IS_VTT)
                        throw new Error(`Could not find "${page}" entity "${entry._copy.name}" ("${entry._copy.source}") to copy in copier "${entry.name}" ("${entry.source}")`);
                }
                return;
            }

            if (DataUtil.dbg.isTrackCopied)
                it.dbg_isCopied = true;
            if (it._copy)
                await DataUtil.generic._pMergeCopy(impl, page, entryList, it, options);

            const templateData = entry._copy?._trait ? (await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/bestiary/template.json`)) : null;
            return DataUtil.generic.copyApplier.getCopy(impl, MiscUtil.copyFast(it), entry, templateData, options);
        },

        _pMergeCopy_search(impl, page, entryList, entry, options) {
            const entryHash = UrlUtil.URL_TO_HASH_BUILDER[page](entry._copy);
            return entryList.find(it=>{
                const hash = UrlUtil.URL_TO_HASH_BUILDER[page](it);
                impl._mergeCache[hash] = it;
                return hash === entryHash;
            }
            );
        },

        COPY_ENTRY_PROPS: ["action", "bonus", "reaction", "trait", "legendary", "mythic", "variant", "spellcasting", "actionHeader", "bonusHeader", "reactionHeader", "legendaryHeader", "mythicHeader", ],

        copyApplier: class {
            static _normaliseMods(obj) {
                Object.entries(obj._mod).forEach(([k,v])=>{
                    if (!(v instanceof Array))
                        obj._mod[k] = [v];
                }
                );
            }

            static _doEnsureArray({obj, prop}) {
                if (!(obj[prop]instanceof Array))
                    obj[prop] = [obj[prop]];
            }

            static _getRegexFromReplaceModInfo({replace, flags}) {
                return new RegExp(replace,`g${flags || ""}`);
            }

            static _doReplaceStringHandler({re, withStr}, str) {
                const split = Renderer.splitByTags(str);
                const len = split.length;
                for (let i = 0; i < len; ++i) {
                    if (split[i].startsWith("{@"))
                        continue;
                    split[i] = split[i].replace(re, withStr);
                }
                return split.join("");
            }

            static _doMod_appendStr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (copyTo[prop])
                    copyTo[prop] = `${copyTo[prop]}${modInfo.joiner || ""}${modInfo.str}`;
                else
                    copyTo[prop] = modInfo.str;
            }

            static _doMod_replaceName({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (!copyTo[prop])
                    return;

                DataUtil.generic._walker_replaceTxt = DataUtil.generic._walker_replaceTxt || MiscUtil.getWalker();
                const re = this._getRegexFromReplaceModInfo({
                    replace: modInfo.replace,
                    flags: modInfo.flags
                });
                const handlers = {
                    string: this._doReplaceStringHandler.bind(null, {
                        re: re,
                        withStr: modInfo.with
                    })
                };

                copyTo[prop].forEach(it=>{
                    if (it.name)
                        it.name = DataUtil.generic._walker_replaceTxt.walk(it.name, handlers);
                }
                );
            }

            static _doMod_replaceTxt({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (!copyTo[prop])
                    return;

                DataUtil.generic._walker_replaceTxt = DataUtil.generic._walker_replaceTxt || MiscUtil.getWalker();
                const re = this._getRegexFromReplaceModInfo({
                    replace: modInfo.replace,
                    flags: modInfo.flags
                });
                const handlers = {
                    string: this._doReplaceStringHandler.bind(null, {
                        re: re,
                        withStr: modInfo.with
                    })
                };

                const props = modInfo.props || [null, "entries", "headerEntries", "footerEntries"];
                if (!props.length)
                    return;

                if (props.includes(null)) {
                    copyTo[prop] = copyTo[prop].map(it=>{
                        if (typeof it !== "string")
                            return it;
                        return DataUtil.generic._walker_replaceTxt.walk(it, handlers);
                    }
                    );
                }

                copyTo[prop].forEach(it=>{
                    props.forEach(prop=>{
                        if (prop == null)
                            return;
                        if (it[prop])
                            it[prop] = DataUtil.generic._walker_replaceTxt.walk(it[prop], handlers);
                    }
                    );
                }
                );
            }

            static _doMod_prependArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "items"
                });
                copyTo[prop] = copyTo[prop] ? modInfo.items.concat(copyTo[prop]) : modInfo.items;
            }

            static _doMod_appendArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "items"
                });
                copyTo[prop] = copyTo[prop] ? copyTo[prop].concat(modInfo.items) : modInfo.items;
            }

            static _doMod_appendIfNotExistsArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "items"
                });
                if (!copyTo[prop])
                    return copyTo[prop] = modInfo.items;
                copyTo[prop] = copyTo[prop].concat(modInfo.items.filter(it=>!copyTo[prop].some(x=>CollectionUtil.deepEquals(it, x))));
            }

            static _doMod_replaceArr({copyTo, copyFrom, modInfo, msgPtFailed, prop, isThrow=true}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "items"
                });

                if (!copyTo[prop]) {
                    if (isThrow)
                        throw new Error(`${msgPtFailed} Could not find "${prop}" array`);
                    return false;
                }

                let ixOld;
                if (modInfo.replace.regex) {
                    const re = new RegExp(modInfo.replace.regex,modInfo.replace.flags || "");
                    ixOld = copyTo[prop].findIndex(it=>it.name ? re.test(it.name) : typeof it === "string" ? re.test(it) : false);
                } else if (modInfo.replace.index != null) {
                    ixOld = modInfo.replace.index;
                } else {
                    ixOld = copyTo[prop].findIndex(it=>it.name ? it.name === modInfo.replace : it === modInfo.replace);
                }

                if (~ixOld) {
                    copyTo[prop].splice(ixOld, 1, ...modInfo.items);
                    return true;
                } else if (isThrow)
                    throw new Error(`${msgPtFailed} Could not find "${prop}" item with name "${modInfo.replace}" to replace`);
                return false;
            }

            static _doMod_replaceOrAppendArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                const didReplace = this._doMod_replaceArr({
                    copyTo,
                    copyFrom,
                    modInfo,
                    msgPtFailed,
                    prop,
                    isThrow: false
                });
                if (!didReplace)
                    this._doMod_appendArr({
                        copyTo,
                        copyFrom,
                        modInfo,
                        msgPtFailed,
                        prop
                    });
            }

            static _doMod_insertArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "items"
                });
                if (!copyTo[prop])
                    throw new Error(`${msgPtFailed} Could not find "${prop}" array`);
                copyTo[prop].splice(~modInfo.index ? modInfo.index : copyTo[prop].length, 0, ...modInfo.items);
            }

            static _doMod_removeArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (modInfo.names) {
                    this._doEnsureArray({
                        obj: modInfo,
                        prop: "names"
                    });
                    modInfo.names.forEach(nameToRemove=>{
                        const ixOld = copyTo[prop].findIndex(it=>it.name === nameToRemove);
                        if (~ixOld)
                            copyTo[prop].splice(ixOld, 1);
                        else {
                            if (!modInfo.force)
                                throw new Error(`${msgPtFailed} Could not find "${prop}" item with name "${nameToRemove}" to remove`);
                        }
                    }
                    );
                } else if (modInfo.items) {
                    this._doEnsureArray({
                        obj: modInfo,
                        prop: "items"
                    });
                    modInfo.items.forEach(itemToRemove=>{
                        const ixOld = copyTo[prop].findIndex(it=>it === itemToRemove);
                        if (~ixOld)
                            copyTo[prop].splice(ixOld, 1);
                        else
                            throw new Error(`${msgPtFailed} Could not find "${prop}" item "${itemToRemove}" to remove`);
                    }
                    );
                } else
                    throw new Error(`${msgPtFailed} One of "names" or "items" must be provided!`);
            }

            static _doMod_calculateProp({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                copyTo[prop] = copyTo[prop] || {};
                const toExec = modInfo.formula.replace(/<\$([^$]+)\$>/g, (...m)=>{
                    switch (m[1]) {
                    case "prof_bonus":
                        return Parser.crToPb(copyTo.cr);
                    case "dex_mod":
                        return Parser.getAbilityModNumber(copyTo.dex);
                    default:
                        throw new Error(`${msgPtFailed} Unknown variable "${m[1]}"`);
                    }
                }
                );
                copyTo[prop][modInfo.prop] = eval(toExec);
            }

            static _doMod_scalarAddProp({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                const applyTo = (k)=>{
                    const out = Number(copyTo[prop][k]) + modInfo.scalar;
                    const isString = typeof copyTo[prop][k] === "string";
                    copyTo[prop][k] = isString ? `${out >= 0 ? "+" : ""}${out}` : out;
                }
                ;

                if (!copyTo[prop])
                    return;
                if (modInfo.prop === "*")
                    Object.keys(copyTo[prop]).forEach(k=>applyTo(k));
                else
                    applyTo(modInfo.prop);
            }

            static _doMod_scalarMultProp({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                const applyTo = (k)=>{
                    let out = Number(copyTo[prop][k]) * modInfo.scalar;
                    if (modInfo.floor)
                        out = Math.floor(out);
                    const isString = typeof copyTo[prop][k] === "string";
                    copyTo[prop][k] = isString ? `${out >= 0 ? "+" : ""}${out}` : out;
                }
                ;

                if (!copyTo[prop])
                    return;
                if (modInfo.prop === "*")
                    Object.keys(copyTo[prop]).forEach(k=>applyTo(k));
                else
                    applyTo(modInfo.prop);
            }

            static _doMod_addSenses({copyTo, copyFrom, modInfo, msgPtFailed}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "senses"
                });
                copyTo.senses = copyTo.senses || [];
                modInfo.senses.forEach(sense=>{
                    let found = false;
                    for (let i = 0; i < copyTo.senses.length; ++i) {
                        const m = new RegExp(`${sense.type} (\\d+)`,"i").exec(copyTo.senses[i]);
                        if (m) {
                            found = true;
                            if (Number(m[1]) < sense.range) {
                                copyTo.senses[i] = `${sense.type} ${sense.range} ft.`;
                            }
                            break;
                        }
                    }

                    if (!found)
                        copyTo.senses.push(`${sense.type} ${sense.range} ft.`);
                }
                );
            }

            static _doMod_addSaves({copyTo, copyFrom, modInfo, msgPtFailed}) {
                copyTo.save = copyTo.save || {};
                Object.entries(modInfo.saves).forEach(([save,mode])=>{
                    const total = mode * Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(copyTo[save]);
                    const asText = total >= 0 ? `+${total}` : total;
                    if (copyTo.save && copyTo.save[save]) {
                        if (Number(copyTo.save[save]) < total)
                            copyTo.save[save] = asText;
                    } else
                        copyTo.save[save] = asText;
                }
                );
            }

            static _doMod_addSkills({copyTo, copyFrom, modInfo, msgPtFailed}) {
                copyTo.skill = copyTo.skill || {};
                Object.entries(modInfo.skills).forEach(([skill,mode])=>{
                    const total = mode * Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(copyTo[Parser.skillToAbilityAbv(skill)]);
                    const asText = total >= 0 ? `+${total}` : total;
                    if (copyTo.skill && copyTo.skill[skill]) {
                        if (Number(copyTo.skill[skill]) < total)
                            copyTo.skill[skill] = asText;
                    } else
                        copyTo.skill[skill] = asText;
                }
                );
            }

            static _doMod_addAllSaves({copyTo, copyFrom, modInfo, msgPtFailed}) {
                return this._doMod_addSaves({
                    copyTo,
                    copyFrom,
                    modInfo: {
                        mode: "addSaves",
                        saves: Object.keys(Parser.ATB_ABV_TO_FULL).mergeMap(it=>({
                            [it]: modInfo.saves
                        })),
                    },
                    msgPtFailed,
                });
            }

            static _doMod_addAllSkills({copyTo, copyFrom, modInfo, msgPtFailed}) {
                return this._doMod_addSkills({
                    copyTo,
                    copyFrom,
                    modInfo: {
                        mode: "addSkills",
                        skills: Object.keys(Parser.SKILL_TO_ATB_ABV).mergeMap(it=>({
                            [it]: modInfo.skills
                        })),
                    },
                    msgPtFailed,
                });
            }

            static _doMod_addSpells({copyTo, copyFrom, modInfo, msgPtFailed}) {
                if (!copyTo.spellcasting)
                    throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

                const spellcasting = copyTo.spellcasting[0];

                if (modInfo.spells) {
                    const spells = spellcasting.spells;

                    Object.keys(modInfo.spells).forEach(k=>{
                        if (!spells[k])
                            spells[k] = modInfo.spells[k];
                        else {
                            const spellCategoryNu = modInfo.spells[k];
                            const spellCategoryOld = spells[k];
                            Object.keys(spellCategoryNu).forEach(kk=>{
                                if (!spellCategoryOld[kk])
                                    spellCategoryOld[kk] = spellCategoryNu[kk];
                                else {
                                    if (typeof spellCategoryOld[kk] === "object") {
                                        if (spellCategoryOld[kk]instanceof Array)
                                            spellCategoryOld[kk] = spellCategoryOld[kk].concat(spellCategoryNu[kk]).sort(SortUtil.ascSortLower);
                                        else
                                            throw new Error(`${msgPtFailed} Object at key ${kk} not an array!`);
                                    } else
                                        spellCategoryOld[kk] = spellCategoryNu[kk];
                                }
                            }
                            );
                        }
                    }
                    );
                }

                ["constant", "will", "ritual"].forEach(prop=>{
                    if (!modInfo[prop])
                        return;
                    modInfo[prop].forEach(sp=>(spellcasting[prop] = spellcasting[prop] || []).push(sp));
                }
                );

                ["recharge", "charges", "rest", "daily", "weekly", "yearly"].forEach(prop=>{
                    if (!modInfo[prop])
                        return;

                    for (let i = 1; i <= 9; ++i) {
                        const e = `${i}e`;

                        spellcasting[prop] = spellcasting[prop] || {};

                        if (modInfo[prop][i]) {
                            modInfo[prop][i].forEach(sp=>(spellcasting[prop][i] = spellcasting[prop][i] || []).push(sp));
                        }

                        if (modInfo[prop][e]) {
                            modInfo[prop][e].forEach(sp=>(spellcasting[prop][e] = spellcasting[prop][e] || []).push(sp));
                        }
                    }
                }
                );
            }

            static _doMod_replaceSpells({copyTo, copyFrom, modInfo, msgPtFailed}) {
                if (!copyTo.spellcasting)
                    throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

                const spellcasting = copyTo.spellcasting[0];

                const handleReplace = (curSpells,replaceMeta,k)=>{
                    this._doEnsureArray({
                        obj: replaceMeta,
                        prop: "with"
                    });

                    const ix = curSpells[k].indexOf(replaceMeta.replace);
                    if (~ix) {
                        curSpells[k].splice(ix, 1, ...replaceMeta.with);
                        curSpells[k].sort(SortUtil.ascSortLower);
                    } else
                        throw new Error(`${msgPtFailed} Could not find spell "${replaceMeta.replace}" to replace`);
                }
                ;

                if (modInfo.spells) {
                    const trait0 = spellcasting.spells;
                    Object.keys(modInfo.spells).forEach(k=>{
                        if (trait0[k]) {
                            const replaceMetas = modInfo.spells[k];
                            const curSpells = trait0[k];
                            replaceMetas.forEach(replaceMeta=>handleReplace(curSpells, replaceMeta, "spells"));
                        }
                    }
                    );
                }

                if (modInfo.daily) {
                    for (let i = 1; i <= 9; ++i) {
                        const e = `${i}e`;

                        if (modInfo.daily[i]) {
                            modInfo.daily[i].forEach(replaceMeta=>handleReplace(spellcasting.daily, replaceMeta, i));
                        }

                        if (modInfo.daily[e]) {
                            modInfo.daily[e].forEach(replaceMeta=>handleReplace(spellcasting.daily, replaceMeta, e));
                        }
                    }
                }
            }

            static _doMod_removeSpells({copyTo, copyFrom, modInfo, msgPtFailed}) {
                if (!copyTo.spellcasting)
                    throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

                const spellcasting = copyTo.spellcasting[0];

                if (modInfo.spells) {
                    const spells = spellcasting.spells;

                    Object.keys(modInfo.spells).forEach(k=>{
                        if (!spells[k]?.spells)
                            return;

                        spells[k].spells = spells[k].spells.filter(it=>!modInfo.spells[k].includes(it));
                    }
                    );
                }

                ["constant", "will", "ritual"].forEach(prop=>{
                    if (!modInfo[prop])
                        return;
                    spellcasting[prop].filter(it=>!modInfo[prop].includes(it));
                }
                );

                ["recharge", "charges", "rest", "daily", "weekly", "yearly"].forEach(prop=>{
                    if (!modInfo[prop])
                        return;

                    for (let i = 1; i <= 9; ++i) {
                        const e = `${i}e`;

                        spellcasting[prop] = spellcasting[prop] || {};

                        if (modInfo[prop][i]) {
                            spellcasting[prop][i] = spellcasting[prop][i].filter(it=>!modInfo[prop][i].includes(it));
                        }

                        if (modInfo[prop][e]) {
                            spellcasting[prop][e] = spellcasting[prop][e].filter(it=>!modInfo[prop][e].includes(it));
                        }
                    }
                }
                );
            }

            static _doMod_scalarAddHit({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (!copyTo[prop])
                    return;
                copyTo[prop] = JSON.parse(JSON.stringify(copyTo[prop]).replace(/{@hit ([-+]?\d+)}/g, (m0,m1)=>`{@hit ${Number(m1) + modInfo.scalar}}`));
            }

            static _doMod_scalarAddDc({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (!copyTo[prop])
                    return;
                copyTo[prop] = JSON.parse(JSON.stringify(copyTo[prop]).replace(/{@dc (\d+)(?:\|[^}]+)?}/g, (m0,m1)=>`{@dc ${Number(m1) + modInfo.scalar}}`));
            }

            static _doMod_maxSize({copyTo, copyFrom, modInfo, msgPtFailed}) {
                const sizes = [...copyTo.size].sort(SortUtil.ascSortSize);

                const ixsCur = sizes.map(it=>Parser.SIZE_ABVS.indexOf(it));
                const ixMax = Parser.SIZE_ABVS.indexOf(modInfo.max);

                if (!~ixMax || ixsCur.some(ix=>!~ix))
                    throw new Error(`${msgPtFailed} Unhandled size!`);

                const ixsNxt = ixsCur.filter(ix=>ix <= ixMax);
                if (!ixsNxt.length)
                    ixsNxt.push(ixMax);

                copyTo.size = ixsNxt.map(ix=>Parser.SIZE_ABVS[ix]);
            }

            static _doMod_scalarMultXp({copyTo, copyFrom, modInfo, msgPtFailed}) {
                const getOutput = (input)=>{
                    let out = input * modInfo.scalar;
                    if (modInfo.floor)
                        out = Math.floor(out);
                    return out;
                }
                ;

                if (copyTo.cr.xp)
                    copyTo.cr.xp = getOutput(copyTo.cr.xp);
                else {
                    const curXp = Parser.crToXpNumber(copyTo.cr);
                    if (!copyTo.cr.cr)
                        copyTo.cr = {
                            cr: copyTo.cr
                        };
                    copyTo.cr.xp = getOutput(curXp);
                }
            }

            static _doMod_setProp({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                const propPath = modInfo.prop.split(".");
                if (prop !== "*")
                    propPath.unshift(prop);
                MiscUtil.set(copyTo, ...propPath, MiscUtil.copyFast(modInfo.value));
            }

            static _doMod_handleProp({copyTo, copyFrom, modInfos, msgPtFailed, prop=null}) {
                modInfos.forEach(modInfo=>{
                    if (typeof modInfo === "string") {
                        switch (modInfo) {
                        case "remove":
                            return delete copyTo[prop];
                        default:
                            throw new Error(`${msgPtFailed} Unhandled mode: ${modInfo}`);
                        }
                    } else {
                        switch (modInfo.mode) {
                        case "appendStr":
                            return this._doMod_appendStr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "replaceName":
                            return this._doMod_replaceName({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "replaceTxt":
                            return this._doMod_replaceTxt({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "prependArr":
                            return this._doMod_prependArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "appendArr":
                            return this._doMod_appendArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "replaceArr":
                            return this._doMod_replaceArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "replaceOrAppendArr":
                            return this._doMod_replaceOrAppendArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "appendIfNotExistsArr":
                            return this._doMod_appendIfNotExistsArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "insertArr":
                            return this._doMod_insertArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "removeArr":
                            return this._doMod_removeArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "calculateProp":
                            return this._doMod_calculateProp({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "scalarAddProp":
                            return this._doMod_scalarAddProp({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "scalarMultProp":
                            return this._doMod_scalarMultProp({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "setProp":
                            return this._doMod_setProp({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "addSenses":
                            return this._doMod_addSenses({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "addSaves":
                            return this._doMod_addSaves({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "addSkills":
                            return this._doMod_addSkills({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "addAllSaves":
                            return this._doMod_addAllSaves({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "addAllSkills":
                            return this._doMod_addAllSkills({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "addSpells":
                            return this._doMod_addSpells({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "replaceSpells":
                            return this._doMod_replaceSpells({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "removeSpells":
                            return this._doMod_removeSpells({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "maxSize":
                            return this._doMod_maxSize({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "scalarMultXp":
                            return this._doMod_scalarMultXp({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "scalarAddHit":
                            return this._doMod_scalarAddHit({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "scalarAddDc":
                            return this._doMod_scalarAddDc({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        default:
                            throw new Error(`${msgPtFailed} Unhandled mode: ${modInfo.mode}`);
                        }
                    }
                }
                );
            }

            static _doMod({copyTo, copyFrom, modInfos, msgPtFailed, props=null, isExternalApplicationIdentityOnly}) {
                if (isExternalApplicationIdentityOnly)
                    return;

                if (props?.length)
                    props.forEach(prop=>this._doMod_handleProp({
                        copyTo,
                        copyFrom,
                        modInfos,
                        msgPtFailed,
                        prop
                    }));
                else
                    this._doMod_handleProp({
                        copyTo,
                        copyFrom,
                        modInfos,
                        msgPtFailed
                    });
            }

            static getCopy(impl, copyFrom, copyTo, templateData, {isExternalApplicationKeepCopy=false, isExternalApplicationIdentityOnly=false}={}) {
                if (isExternalApplicationKeepCopy)
                    copyTo.__copy = MiscUtil.copyFast(copyFrom);

                const msgPtFailed = `Failed to apply _copy to "${copyTo.name}" ("${copyTo.source}").`;

                const copyMeta = copyTo._copy || {};

                if (copyMeta._mod)
                    this._normaliseMods(copyMeta);

                let template = null;
                if (copyMeta._trait) {
                    template = templateData.monsterTemplate.find(t=>t.name.toLowerCase() === copyMeta._trait.name.toLowerCase() && t.source.toLowerCase() === copyMeta._trait.source.toLowerCase());
                    if (!template)
                        throw new Error(`${msgPtFailed} Could not find traits to apply with name "${copyMeta._trait.name}" and source "${copyMeta._trait.source}"`);
                    template = MiscUtil.copyFast(template);

                    if (template.apply._mod) {
                        this._normaliseMods(template.apply);

                        if (copyMeta._mod) {
                            Object.entries(template.apply._mod).forEach(([k,v])=>{
                                if (copyMeta._mod[k])
                                    copyMeta._mod[k] = copyMeta._mod[k].concat(v);
                                else
                                    copyMeta._mod[k] = v;
                            }
                            );
                        } else
                            copyMeta._mod = template.apply._mod;
                    }

                    delete copyMeta._trait;
                }

                const copyToRootProps = new Set(Object.keys(copyTo));

                Object.keys(copyFrom).forEach(k=>{
                    if (copyTo[k] === null)
                        return delete copyTo[k];
                    if (copyTo[k] == null) {
                        if (DataUtil.generic._MERGE_REQUIRES_PRESERVE_BASE[k] || impl?._MERGE_REQUIRES_PRESERVE[k]) {
                            if (copyTo._copy._preserve?.["*"] || copyTo._copy._preserve?.[k])
                                copyTo[k] = copyFrom[k];
                        } else
                            copyTo[k] = copyFrom[k];
                    }
                }
                );

                if (template && template.apply._root) {
                    Object.entries(template.apply._root).filter(([k,v])=>!copyToRootProps.has(k)).forEach(([k,v])=>copyTo[k] = v);
                }

                if (copyMeta._mod) {
                    Object.entries(copyMeta._mod).forEach(([k,v])=>{
                        copyMeta._mod[k] = DataUtil.generic.variableResolver.resolve({
                            obj: v,
                            ent: copyTo
                        });
                    }
                    );

                    Object.entries(copyMeta._mod).forEach(([prop,modInfos])=>{
                        if (prop === "*")
                            this._doMod({
                                copyTo,
                                copyFrom,
                                modInfos,
                                props: DataUtil.generic.COPY_ENTRY_PROPS,
                                msgPtFailed,
                                isExternalApplicationIdentityOnly
                            });
                        else if (prop === "_")
                            this._doMod({
                                copyTo,
                                copyFrom,
                                modInfos,
                                msgPtFailed,
                                isExternalApplicationIdentityOnly
                            });
                        else
                            this._doMod({
                                copyTo,
                                copyFrom,
                                modInfos,
                                props: [prop],
                                msgPtFailed,
                                isExternalApplicationIdentityOnly
                            });
                    }
                    );
                }

                copyTo._isCopy = true;

                delete copyTo._copy;
            }
        }
        ,

        variableResolver: class {
            static _getSize({ent}) {
                return ent.size?.[0] || Parser.SZ_MEDIUM;
            }

            static _SIZE_TO_MULT = {
                [Parser.SZ_LARGE]: 2,
                [Parser.SZ_HUGE]: 3,
                [Parser.SZ_GARGANTUAN]: 4,
            };

            static _getSizeMult(size) {
                return this._SIZE_TO_MULT[size] ?? 1;
            }

            static _getCleanMathExpression(str) {
                return str.replace(/[^-+/*0-9.,]+/g, "");
            }

            static resolve({obj, ent, msgPtFailed=null}) {
                return JSON.parse(JSON.stringify(obj).replace(/<\$(?<variable>[^$]+)\$>/g, (...m)=>{
                    const [mode,detail] = m.last().variable.split("__");

                    switch (mode) {
                    case "name":
                        return ent.name;
                    case "short_name":
                    case "title_short_name":
                        {
                            return Renderer.monster.getShortName(ent, {
                                isTitleCase: mode === "title_short_name"
                            });
                        }

                    case "dc":
                    case "spell_dc":
                        {
                            if (!Parser.ABIL_ABVS.includes(detail))
                                throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
                            return 8 + Parser.getAbilityModNumber(Number(ent[detail])) + Parser.crToPb(ent.cr);
                        }

                    case "to_hit":
                        {
                            if (!Parser.ABIL_ABVS.includes(detail))
                                throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
                            const total = Parser.crToPb(ent.cr) + Parser.getAbilityModNumber(Number(ent[detail]));
                            return total >= 0 ? `+${total}` : total;
                        }

                    case "damage_mod":
                        {
                            if (!Parser.ABIL_ABVS.includes(detail))
                                throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
                            const total = Parser.getAbilityModNumber(Number(ent[detail]));
                            return total === 0 ? "" : total > 0 ? ` + ${total}` : ` - ${Math.abs(total)}`;
                        }

                    case "damage_avg":
                        {
                            const replaced = detail.replace(/\b(?<abil>str|dex|con|int|wis|cha)\b/gi, (...m)=>Parser.getAbilityModNumber(Number(ent[m.last().abil]))).replace(/\bsize_mult\b/g, ()=>this._getSizeMult(this._getSize({
                                ent
                            })));

                            return Math.floor(eval(this._getCleanMathExpression(replaced)));
                        }

                    case "size_mult":
                        {
                            const mult = this._getSizeMult(this._getSize({
                                ent
                            }));

                            if (!detail)
                                return mult;

                            return Math.floor(eval(`${mult} * ${this._getCleanMathExpression(detail)}`));
                        }

                    default:
                        return m[0];
                    }
                }
                ), );
            }
        }
        ,

        getVersions(parent, {impl=null, isExternalApplicationIdentityOnly=false}={}) {
            if (!parent?._versions?.length)
                return [];

            return parent._versions.map(ver=>{
                if (ver._template && ver._implementations?.length)
                    return DataUtil.generic._getVersions_template({
                        ver
                    });
                return DataUtil.generic._getVersions_basic({
                    ver
                });
            }
            ).flat().map(ver=>DataUtil.generic._getVersion({
                parentEntity: parent,
                version: ver,
                impl,
                isExternalApplicationIdentityOnly
            }));
        },

        _getVersions_template({ver}) {
            return ver._implementations.map(impl=>{
                let cpyTemplate = MiscUtil.copyFast(ver._template);
                const cpyImpl = MiscUtil.copyFast(impl);

                DataUtil.generic._getVersions_mutExpandCopy({
                    ent: cpyTemplate
                });

                if (cpyImpl._variables) {
                    cpyTemplate = MiscUtil.getWalker().walk(cpyTemplate, {
                        string: str=>str.replace(/{{([^}]+)}}/g, (...m)=>cpyImpl._variables[m[1]]),
                    }, );
                    delete cpyImpl._variables;
                }

                Object.assign(cpyTemplate, cpyImpl);

                return cpyTemplate;
            }
            );
        },

        _getVersions_basic({ver}) {
            const cpyVer = MiscUtil.copyFast(ver);
            DataUtil.generic._getVersions_mutExpandCopy({
                ent: cpyVer
            });
            return cpyVer;
        },

        _getVersions_mutExpandCopy({ent}) {
            ent._copy = {
                _mod: ent._mod,
                _preserve: ent._preserve || {
                    "*": true
                },
            };
            delete ent._mod;
            delete ent._preserve;
        },

        _getVersion({parentEntity, version, impl=null, isExternalApplicationIdentityOnly}) {
            const additionalData = {
                _versionBase_isVersion: true,
                _versionBase_name: parentEntity.name,
                _versionBase_source: parentEntity.source,
                _versionBase_hasToken: parentEntity.hasToken,
                _versionBase_hasFluff: parentEntity.hasFluff,
                _versionBase_hasFluffImages: parentEntity.hasFluffImages,
            };
            const cpyParentEntity = MiscUtil.copyFast(parentEntity);

            delete cpyParentEntity._versions;
            delete cpyParentEntity.hasToken;
            delete cpyParentEntity.hasFluff;
            delete cpyParentEntity.hasFluffImages;

            DataUtil.generic.copyApplier.getCopy(impl, cpyParentEntity, version, null, {
                isExternalApplicationIdentityOnly
            }, );
            Object.assign(version, additionalData);
            return version;
        },
    },

    proxy: {
        getVersions(prop, ent, {isExternalApplicationIdentityOnly=false}={}) {
            if (DataUtil[prop]?.getVersions)
                return DataUtil[prop]?.getVersions(ent, {
                    isExternalApplicationIdentityOnly
                });
            return DataUtil.generic.getVersions(ent, {
                isExternalApplicationIdentityOnly
            });
        },

        unpackUid(prop, uid, tag, opts) {
            if (DataUtil[prop]?.unpackUid)
                return DataUtil[prop]?.unpackUid(uid, tag, opts);
            return DataUtil.generic.unpackUid(uid, tag, opts);
        },

        getNormalizedUid(prop, uid, tag, opts) {
            if (DataUtil[prop]?.getNormalizedUid)
                return DataUtil[prop].getNormalizedUid(uid, tag, opts);
            return DataUtil.generic.getNormalizedUid(uid, tag, opts);
        },

        getUid(prop, ent, opts) {
            if (DataUtil[prop]?.getUid)
                return DataUtil[prop].getUid(ent, opts);
            return DataUtil.generic.getUid(ent, opts);
        },
    },

    spell: class extends _DataUtilPropConfigMultiSource {
        static _PAGE = UrlUtil.PG_SPELLS;
        static _DIR = "spells";
        static _PROP = "spell";
        static _IS_MUT_ENTITIES = true;

        static _SPELL_SOURCE_LOOKUP = null;

        static PROPS_SPELL_SOURCE = ["classes", "races", "optionalfeatures", "backgrounds", "feats", "charoptions", "rewards", ];

        static setSpellSourceLookup(lookup, {isExternalApplication=false}={}) {
            if (!isExternalApplication)
                throw new Error("Should not be calling this!");
            this._SPELL_SOURCE_LOOKUP = MiscUtil.copyFast(lookup);
        }

        static mutEntity(sp, {isExternalApplication=false}={}) {
            if (!isExternalApplication)
                throw new Error("Should not be calling this!");
            return this._mutEntity(sp);
        }

        static unmutEntity(sp, {isExternalApplication=false}={}) {
            if (!isExternalApplication)
                throw new Error("Should not be calling this!");
            this.PROPS_SPELL_SOURCE.forEach(prop=>delete sp[prop]);
            delete sp._isMutEntity;
        }

        static mutEntityBrewBuilder(sp, sourcesLookup) {
            const out = this._mutEntity(sp, {
                sourcesLookup
            });
            delete sp._isMutEntity;
            return out;
        }

        static async _pInitPreData_() {
            this._SPELL_SOURCE_LOOKUP = await DataUtil.loadRawJSON(`${Renderer.get().baseUrl}data/generated/gendata-spell-source-lookup.json`);
        }

        static _mutEntity(sp, {sourcesLookup=null}={}) {
            if (sp._isMutEntity)
                return sp;

            const spSources = (sourcesLookup ?? this._SPELL_SOURCE_LOOKUP)[sp.source.toLowerCase()]?.[sp.name.toLowerCase()];
            if (!spSources)
                return sp;

            this._mutSpell_class({
                sp,
                spSources,
                propSources: "class",
                propClasses: "fromClassList"
            });
            this._mutSpell_class({
                sp,
                spSources,
                propSources: "classVariant",
                propClasses: "fromClassListVariant"
            });
            this._mutSpell_subclass({ sp, spSources });
            this._mutSpell_race({ sp, spSources });
            this._mutSpell_optionalfeature({ sp, spSources });
            this._mutSpell_background({ sp, spSources });
            this._mutSpell_feat({ sp, spSources });
            this._mutSpell_charoption({ sp, spSources });
            this._mutSpell_reward({ sp, spSources });

            sp._isMutEntity = true;

            return sp;
        }

        static _mutSpell_class({sp, spSources, propSources, propClasses}) {
            if (!spSources[propSources])
                return;

            Object.entries(spSources[propSources]).forEach(([source,nameTo])=>{
                const tgt = MiscUtil.getOrSet(sp, "classes", propClasses, []);

                Object.entries(nameTo).forEach(([name,val])=>{
                    if (tgt.some(it=>it.name === nameTo && it.source === source))
                        return;

                    const toAdd = {
                        name,
                        source
                    };
                    if (val === true)
                        return tgt.push(toAdd);

                    if (val.definedInSource) {
                        toAdd.definedInSource = val.definedInSource;
                        tgt.push(toAdd);
                        return;
                    }

                    if (val.definedInSources) {
                        val.definedInSources.forEach(definedInSource=>{
                            const cpyToAdd = MiscUtil.copyFast(toAdd);

                            if (definedInSource == null) {
                                return tgt.push(cpyToAdd);
                            }

                            cpyToAdd.definedInSource = definedInSource;
                            tgt.push(cpyToAdd);
                        }
                        );

                        return;
                    }

                    throw new Error("Unimplemented!");
                }
                );
            }
            );
        }

        static _mutSpell_subclass({sp, spSources}) {
            if (!spSources.subclass)
                return;

            Object.entries(spSources.subclass).forEach(([classSource,classNameTo])=>{
                Object.entries(classNameTo).forEach(([className,sourceTo])=>{
                    Object.entries(sourceTo).forEach(([source,nameTo])=>{
                        const tgt = MiscUtil.getOrSet(sp, "classes", "fromSubclass", []);

                        Object.entries(nameTo).forEach(([name,val])=>{
                            if (val === true)
                                throw new Error("Unimplemented!");

                            if (tgt.some(it=>it.class.name === className && it.class.source === classSource && it.subclass.name === name && it.subclass.source === source && ((it.subclass.subSubclass == null && val.subSubclasses == null) || val.subSubclasses.includes(it.subclass.subSubclass))))
                                return;

                            const toAdd = {
                                class: {
                                    name: className,
                                    source: classSource,
                                },
                                subclass: {
                                    name: val.name,
                                    shortName: name,
                                    source,
                                },
                            };

                            if (!val.subSubclasses?.length)
                                return tgt.push(toAdd);

                            val.subSubclasses.forEach(subSubclass=>{
                                const cpyToAdd = MiscUtil.copyFast(toAdd);
                                cpyToAdd.subclass.subSubclass = subSubclass;
                                tgt.push(cpyToAdd);
                            }
                            );
                        }
                        );
                    }
                    );
                }
                );
            }
            );
        }

        static _mutSpell_race({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "race",
                propSpell: "races"
            });
        }

        static _mutSpell_optionalfeature({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "optionalfeature",
                propSpell: "optionalfeatures"
            });
        }

        static _mutSpell_background({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "background",
                propSpell: "backgrounds"
            });
        }

        static _mutSpell_feat({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "feat",
                propSpell: "feats"
            });
        }

        static _mutSpell_charoption({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "charoption",
                propSpell: "charoptions"
            });
        }

        static _mutSpell_reward({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "reward",
                propSpell: "rewards"
            });
        }

        static _mutSpell_generic({sp, spSources, propSources, propSpell}) {
            if (!spSources[propSources])
                return;

            Object.entries(spSources[propSources]).forEach(([source,nameTo])=>{
                const tgt = MiscUtil.getOrSet(sp, propSpell, []);

                Object.entries(nameTo).forEach(([name,val])=>{
                    if (tgt.some(it=>it.name === nameTo && it.source === source))
                        return;

                    const toAdd = {
                        name,
                        source
                    };
                    if (val === true)
                        return tgt.push(toAdd);

                    Object.assign(toAdd, {
                        ...val
                    });
                    tgt.push(toAdd);
                }
                );
            }
            );
        }
    }
    ,

    spellFluff: class extends _DataUtilPropConfigMultiSource {
        static _PAGE = UrlUtil.PG_SPELLS;
        static _DIR = "spells";
        static _PROP = "spellFluff";
    }
    ,

    background: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_BACKGROUNDS;
        static _FILENAME = "backgrounds.json";
    }
    ,

    backgroundFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_BACKGROUNDS;
        static _FILENAME = "fluff-backgrounds.json";
    }
    ,

    charoption: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;
        static _FILENAME = "charcreationoptions.json";
    }
    ,

    charoptionFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;
        static _FILENAME = "fluff-charcreationoptions.json";
    }
    ,

    condition: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
        static _FILENAME = "conditionsdiseases.json";
    }
    ,

    conditionFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
        static _FILENAME = "fluff-conditionsdiseases.json";
    }
    ,

    disease: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
        static _FILENAME = "conditionsdiseases.json";
    }
    ,

    feat: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_FEATS;
        static _FILENAME = "feats.json";
    }
    ,

    featFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_FEATS;
        static _FILENAME = "fluff-feats.json";
    }
    ,

    item: class extends _DataUtilPropConfigCustom {
        static _MERGE_REQUIRES_PRESERVE = {
            lootTables: true,
            tier: true,
        };
        static _PAGE = UrlUtil.PG_ITEMS;

        static async loadRawJSON() {
            if (DataUtil.item._loadedRawJson)
                return DataUtil.item._loadedRawJson;

            DataUtil.item._pLoadingRawJson = (async()=>{
                const urlItems = `${Renderer.get().baseUrl}data/items.json`;
                const urlItemsBase = `${Renderer.get().baseUrl}data/items-base.json`;
                const urlVariants = `${Renderer.get().baseUrl}data/magicvariants.json`;

                const [dataItems,dataItemsBase,dataVariants] = await Promise.all([DataUtil.loadJSON(urlItems), DataUtil.loadJSON(urlItemsBase), DataUtil.loadJSON(urlVariants), ]);

                DataUtil.item._loadedRawJson = {
                    item: MiscUtil.copyFast(dataItems.item),
                    itemGroup: MiscUtil.copyFast(dataItems.itemGroup),
                    magicvariant: MiscUtil.copyFast(dataVariants.magicvariant),
                    baseitem: MiscUtil.copyFast(dataItemsBase.baseitem),
                };
            }
            )();
            await DataUtil.item._pLoadingRawJson;

            return DataUtil.item._loadedRawJson;
        }

        static async loadJSON() {
            return {
                item: await Renderer.item.pBuildList()
            };
        }

        static async loadPrerelease() {
            return {
                item: await Renderer.item.pGetItemsFromPrerelease()
            };
        }

        static async loadBrew() {
            return {
                item: await Renderer.item.pGetItemsFromBrew()
            };
        }
    }
    ,

    itemGroup: class extends _DataUtilPropConfig {
        static _MERGE_REQUIRES_PRESERVE = {
            lootTables: true,
            tier: true,
        };
        static _PAGE = UrlUtil.PG_ITEMS;

        static async pMergeCopy(...args) {
            return DataUtil.item.pMergeCopy(...args);
        }
        static async loadRawJSON(...args) {
            return DataUtil.item.loadRawJSON(...args);
        }
    }
    ,

    baseitem: class extends _DataUtilPropConfig {
        static _PAGE = UrlUtil.PG_ITEMS;

        static async pMergeCopy(...args) {
            return DataUtil.item.pMergeCopy(...args);
        }
        static async loadRawJSON(...args) {
            return DataUtil.item.loadRawJSON(...args);
        }
    }
    ,

    itemFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_ITEMS;
        static _FILENAME = "fluff-items.json";
    }
    ,

    itemType: class extends _DataUtilPropConfig {
        static _PAGE = "itemType";
    }
    ,

    language: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_LANGUAGES;
        static _FILENAME = "languages.json";

        static async loadJSON() {
            const rawData = await super.loadJSON();

            const scriptLookup = {};
            (rawData.languageScript || []).forEach(script=>scriptLookup[script.name] = script);

            const out = {
                language: MiscUtil.copyFast(rawData.language)
            };
            out.language.forEach(lang=>{
                if (!lang.script || lang.fonts === false)
                    return;

                const script = scriptLookup[lang.script];
                if (!script)
                    return;

                lang._fonts = [...script.fonts];
            }
            );

            return out;
        }
    }
    ,

    languageFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_LANGUAGES;
        static _FILENAME = "fluff-languages.json";
    }
    ,

    object: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_OBJECTS;
        static _FILENAME = "objects.json";
    }
    ,

    objectFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_OBJECTS;
        static _FILENAME = "fluff-objects.json";
    }
    ,

    race: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_RACES;
        static _FILENAME = "races.json";

        static _loadCache = {};
        static _pIsLoadings = {};
        static async loadJSON({isAddBaseRaces=false}={}) {
            if (!DataUtil.race._pIsLoadings[isAddBaseRaces]) {
                DataUtil.race._pIsLoadings[isAddBaseRaces] = (async()=>{
                    DataUtil.race._loadCache[isAddBaseRaces] = DataUtil.race.getPostProcessedSiteJson(await this.loadRawJSON(), {
                        isAddBaseRaces
                    }, );
                }
                )();
            }
            await DataUtil.race._pIsLoadings[isAddBaseRaces];
            return DataUtil.race._loadCache[isAddBaseRaces];
        }

        static getPostProcessedSiteJson(rawRaceData, {isAddBaseRaces=false}={}) {
            rawRaceData = MiscUtil.copyFast(rawRaceData);
            (rawRaceData.subrace || []).forEach(sr=>{
                const r = rawRaceData.race.find(it=>it.name === sr.raceName && it.source === sr.raceSource);
                if (!r)
                    return JqueryUtil.doToast({
                        content: `Failed to find race "${sr.raceName}" (${sr.raceSource})`,
                        type: "danger"
                    });
                const cpySr = MiscUtil.copyFast(sr);
                delete cpySr.raceName;
                delete cpySr.raceSource;
                (r.subraces = r.subraces || []).push(sr);
            }
            );
            delete rawRaceData.subrace;
            const raceData = Renderer.race.mergeSubraces(rawRaceData.race, {
                isAddBaseRaces
            });
            raceData.forEach(it=>it.__prop = "race");
            return {
                race: raceData
            };
        }

        static async loadPrerelease({isAddBaseRaces=true}={}) {
            return DataUtil.race._loadPrereleaseBrew({
                isAddBaseRaces,
                brewUtil: typeof PrereleaseUtil !== "undefined" ? PrereleaseUtil : null
            });
        }

        static async loadBrew({isAddBaseRaces=true}={}) {
            return DataUtil.race._loadPrereleaseBrew({
                isAddBaseRaces,
                brewUtil: typeof BrewUtil2 !== "undefined" ? BrewUtil2 : null
            });
        }

        static async _loadPrereleaseBrew({isAddBaseRaces=true, brewUtil}={}) {
            if (!brewUtil)
                return {};

            const rawSite = await DataUtil.race.loadRawJSON();
            const brew = await brewUtil.pGetBrewProcessed();
            return DataUtil.race.getPostProcessedPrereleaseBrewJson(rawSite, brew, {
                isAddBaseRaces
            });
        }

        static getPostProcessedPrereleaseBrewJson(rawSite, brew, {isAddBaseRaces=false}={}) {
            rawSite = MiscUtil.copyFast(rawSite);
            brew = MiscUtil.copyFast(brew);

            const rawSiteUsed = [];
            (brew.subrace || []).forEach(sr=>{
                const rSite = rawSite.race.find(it=>it.name === sr.raceName && it.source === sr.raceSource);
                const rBrew = (brew.race || []).find(it=>it.name === sr.raceName && it.source === sr.raceSource);
                if (!rSite && !rBrew)
                    return JqueryUtil.doToast({
                        content: `Failed to find race "${sr.raceName}" (${sr.raceSource})`,
                        type: "danger"
                    });
                const rTgt = rSite || rBrew;
                const cpySr = MiscUtil.copyFast(sr);
                delete cpySr.raceName;
                delete cpySr.raceSource;
                (rTgt.subraces = rTgt.subraces || []).push(sr);
                if (rSite && !rawSiteUsed.includes(rSite))
                    rawSiteUsed.push(rSite);
            }
            );
            delete brew.subrace;

            const raceDataBrew = Renderer.race.mergeSubraces(brew.race || [], {
                isAddBaseRaces
            });
            const raceDataSite = Renderer.race.mergeSubraces(rawSiteUsed, {
                isAddBaseRaces: false
            });

            const out = [...raceDataBrew, ...raceDataSite];
            out.forEach(it=>it.__prop = "race");
            return {
                race: out
            };
        }
    }
    ,

    raceFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_RACES;
        static _FILENAME = "fluff-races.json";

        static _getApplyUncommonMonstrous(data) {
            data = MiscUtil.copyFast(data);
            data.raceFluff.forEach(raceFluff=>{
                if (raceFluff.uncommon) {
                    raceFluff.entries = raceFluff.entries || [];
                    raceFluff.entries.push(MiscUtil.copyFast(data.raceFluffMeta.uncommon));
                    delete raceFluff.uncommon;
                }

                if (raceFluff.monstrous) {
                    raceFluff.entries = raceFluff.entries || [];
                    raceFluff.entries.push(MiscUtil.copyFast(data.raceFluffMeta.monstrous));
                    delete raceFluff.monstrous;
                }
            }
            );
            return data;
        }

        static async loadJSON() {
            const data = await super.loadJSON();
            return this._getApplyUncommonMonstrous(data);
        }

        static async loadUnmergedJSON() {
            const data = await super.loadUnmergedJSON();
            return this._getApplyUncommonMonstrous(data);
        }
    }
    ,

    raceFeature: class extends _DataUtilPropConfig {
        static _PAGE = "raceFeature";
    }
    ,

    recipe: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_RECIPES;
        static _FILENAME = "recipes.json";

        static async loadJSON() {
            const rawData = await super.loadJSON();
            return {
                recipe: await DataUtil.recipe.pGetPostProcessedRecipes(rawData.recipe)
            };
        }

        static async pGetPostProcessedRecipes(recipes) {
            if (!recipes?.length)
                return;

            recipes = MiscUtil.copyFast(recipes);

            recipes.forEach(r=>Renderer.recipe.populateFullIngredients(r));

            const out = [];

            for (const r of recipes) {
                const fluff = await Renderer.utils.pGetFluff({
                    entity: r,
                    fnGetFluffData: DataUtil.recipeFluff.loadJSON.bind(DataUtil.recipeFluff),
                    fluffProp: "recipeFluff",
                });

                if (!fluff) {
                    out.push(r);
                    continue;
                }

                const cpyR = MiscUtil.copyFast(r);
                cpyR.fluff = MiscUtil.copyFast(fluff);
                delete cpyR.fluff.name;
                delete cpyR.fluff.source;
                out.push(cpyR);
            }

            return out;
        }

        static async loadPrerelease() {
            return this._loadPrereleaseBrew({
                brewUtil: typeof PrereleaseUtil !== "undefined" ? PrereleaseUtil : null
            });
        }

        static async loadBrew() {
            return this._loadPrereleaseBrew({
                brewUtil: typeof BrewUtil2 !== "undefined" ? BrewUtil2 : null
            });
        }

        static async _loadPrereleaseBrew({brewUtil}) {
            if (!brewUtil)
                return {};

            const brew = await brewUtil.pGetBrewProcessed();
            if (!brew?.recipe?.length)
                return brew;

            return {
                ...brew,
                recipe: await DataUtil.recipe.pGetPostProcessedRecipes(brew.recipe),
            };
        }
    }
    ,

    recipeFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_RECIPES;
        static _FILENAME = "fluff-recipes.json";
    }
    ,

    vehicle: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_VEHICLES;
        static _FILENAME = "vehicles.json";
    }
    ,

    vehicleFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_VEHICLES;
        static _FILENAME = "fluff-vehicles.json";
    }
    ,

    optionalfeature: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_OPT_FEATURES;
        static _FILENAME = "optionalfeatures.json";
    }
    ,

    class: class clazz extends _DataUtilPropConfigCustom {
        static _PAGE = UrlUtil.PG_CLASSES;

        static _pLoadJson = null;
        static _pLoadRawJson = null;

        static loadJSON() {
            return DataUtil.class._pLoadJson = DataUtil.class._pLoadJson || (async()=>{
                return {
                    class: await DataLoader.pCacheAndGetAllSite("class"),
                    subclass: await DataLoader.pCacheAndGetAllSite("subclass"),
                };
            }
            )();
        }

        static loadRawJSON() {
            return DataUtil.class._pLoadRawJson = DataUtil.class._pLoadRawJson || (async()=>{
                const index = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/index.json`);
                const allData = await Promise.all(Object.values(index).map(it=>DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/${it}`)));

                return {
                    class: MiscUtil.copyFast(allData.map(it=>it.class || []).flat()),
                    subclass: MiscUtil.copyFast(allData.map(it=>it.subclass || []).flat()),
                    classFeature: allData.map(it=>it.classFeature || []).flat(),
                    subclassFeature: allData.map(it=>it.subclassFeature || []).flat(),
                };
            }
            )();
        }

        static async loadPrerelease() {
            return {
                class: await DataLoader.pCacheAndGetAllPrerelease("class"),
                subclass: await DataLoader.pCacheAndGetAllPrerelease("subclass"),
            };
        }

        static async loadBrew() {
            return {
                class: await DataLoader.pCacheAndGetAllBrew("class"),
                subclass: await DataLoader.pCacheAndGetAllBrew("subclass"),
            };
        }

        static packUidSubclass(it) {
            const sourceDefault = Parser.getTagSource("subclass");
            return [it.name, it.className, (it.classSource || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.classSource, (it.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.source, ].join("|").replace(/\|+$/, "");
        }

        static unpackUidClassFeature(uid, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,className,classSource,level,source,displayText] = uid.split("|").map(it=>it.trim());
            classSource = classSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
            source = source || classSource;
            level = Number(level);
            return {
                name,
                className,
                classSource,
                level,
                source,
                displayText,
            };
        }

        static isValidClassFeatureUid(uid) {
            const {name, className, level} = DataUtil.class.unpackUidClassFeature(uid);
            return !(!name || !className || isNaN(level));
        }

        static packUidClassFeature(f) {
            return [f.name, f.className, f.classSource === Parser.SRC_PHB ? "" : f.classSource, f.level, f.source === f.classSource ? "" : f.source, ].join("|").replace(/\|+$/, "");
        }

        static unpackUidSubclassFeature(uid, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,className,classSource,subclassShortName,subclassSource,level,source,displayText] = uid.split("|").map(it=>it.trim());
            classSource = classSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
            subclassSource = subclassSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
            source = source || subclassSource;
            level = Number(level);
            return {
                name,
                className,
                classSource,
                subclassShortName,
                subclassSource,
                level,
                source,
                displayText,
            };
        }

        static isValidSubclassFeatureUid(uid) {
            const {name, className, subclassShortName, level} = DataUtil.class.unpackUidSubclassFeature(uid);
            return !(!name || !className || !subclassShortName || isNaN(level));
        }

        static packUidSubclassFeature(f) {
            return [f.name, f.className, f.classSource === Parser.SRC_PHB ? "" : f.classSource, f.subclassShortName, f.subclassSource === Parser.SRC_PHB ? "" : f.subclassSource, f.level, f.source === f.subclassSource ? "" : f.source, ].join("|").replace(/\|+$/, "");
        }

        static _CACHE_SUBCLASS_LOOKUP_PROMISE = null;
        static _CACHE_SUBCLASS_LOOKUP = null;
        static async pGetSubclassLookup() {
            DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE = DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE || (async()=>{
                const subclassLookup = {};
                Object.assign(subclassLookup, await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`));
                DataUtil.class._CACHE_SUBCLASS_LOOKUP = subclassLookup;
            }
            )();
            await DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE;
            return DataUtil.class._CACHE_SUBCLASS_LOOKUP;
        }
    }
    ,

    subclass: class extends _DataUtilPropConfig {
        static _PAGE = "subclass";
    }
    ,

    deity: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_DEITIES;
        static _FILENAME = "deities.json";

        static doPostLoad(data) {
            const PRINT_ORDER = [Parser.SRC_PHB, Parser.SRC_DMG, Parser.SRC_SCAG, Parser.SRC_VGM, Parser.SRC_MTF, Parser.SRC_ERLW, Parser.SRC_EGW, Parser.SRC_TDCSR, ];

            const inSource = {};
            PRINT_ORDER.forEach(src=>{
                inSource[src] = {};
                data.deity.filter(it=>it.source === src).forEach(it=>inSource[src][it.reprintAlias || it.name] = it);
            }
            );

            const laterPrinting = [PRINT_ORDER.last()];
            [...PRINT_ORDER].reverse().slice(1).forEach(src=>{
                laterPrinting.forEach(laterSrc=>{
                    Object.keys(inSource[src]).forEach(name=>{
                        const newer = inSource[laterSrc][name];
                        if (newer) {
                            const old = inSource[src][name];
                            old.reprinted = true;
                            if (!newer._isEnhanced) {
                                newer.previousVersions = newer.previousVersions || [];
                                newer.previousVersions.push(old);
                            }
                        }
                    }
                    );
                }
                );

                laterPrinting.push(src);
            }
            );
            data.deity.forEach(g=>g._isEnhanced = true);

            return data;
        }

        static async loadJSON() {
            const data = await super.loadJSON();
            DataUtil.deity.doPostLoad(data);
            return data;
        }

        static getUid(ent, opts) {
            return this.packUidDeity(ent, opts);
        }

        static getNormalizedUid(uid, tag) {
            const {name, pantheon, source} = this.unpackUidDeity(uid, tag, {
                isLower: true
            });
            return [name, pantheon, source].join("|");
        }

        static unpackUidDeity(uid, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,pantheon,source,displayText,...others] = uid.split("|").map(it=>it.trim());

            pantheon = pantheon || "forgotten realms";
            if (opts.isLower)
                pantheon = pantheon.toLowerCase();

            source = source || Parser.getTagSource("deity", source);
            if (opts.isLower)
                source = source.toLowerCase();

            return {
                name,
                pantheon,
                source,
                displayText,
                others,
            };
        }

        static packUidDeity(it) {
            const sourceDefault = Parser.getTagSource("deity");
            return [it.name, (it.pantheon || "").toLowerCase() === "forgotten realms" ? "" : it.pantheon, (it.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.source, ].join("|").replace(/\|+$/, "");
        }
    }
    ,

    table: class extends _DataUtilPropConfigCustom {
        static async loadJSON() {
            const datas = await Promise.all([`${Renderer.get().baseUrl}data/generated/gendata-tables.json`, `${Renderer.get().baseUrl}data/tables.json`, ].map(url=>DataUtil.loadJSON(url)));
            const combined = {};
            datas.forEach(data=>{
                Object.entries(data).forEach(([k,v])=>{
                    if (combined[k] && combined[k]instanceof Array && v instanceof Array)
                        combined[k] = combined[k].concat(v);
                    else if (combined[k] == null)
                        combined[k] = v;
                    else
                        throw new Error(`Could not merge keys for key "${k}"`);
                }
                );
            }
            );

            return combined;
        }
    }
    ,

    legendaryGroup: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_BESTIARY;
        static _FILENAME = "bestiary/legendarygroups.json";

        static async pLoadAll() {
            return (await this.loadJSON()).legendaryGroup;
        }
    }
    ,

    variantrule: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_VARIANTRULES;
        static _FILENAME = "variantrules.json";

        static async loadJSON() {
            const rawData = await super.loadJSON();
            const rawDataGenerated = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-variantrules.json`);

            return {
                variantrule: [...rawData.variantrule, ...rawDataGenerated.variantrule]
            };
        }
    }
    ,

    deck: class extends _DataUtilPropConfigCustom {
        static _PAGE = UrlUtil.PG_DECKS;

        static _pLoadJson = null;
        static _pLoadRawJson = null;

        static loadJSON() {
            return DataUtil.deck._pLoadJson = DataUtil.deck._pLoadJson || (async()=>{
                return {
                    deck: await DataLoader.pCacheAndGetAllSite("deck"),
                    card: await DataLoader.pCacheAndGetAllSite("card"),
                };
            }
            )();
        }

        static loadRawJSON() {
            return DataUtil.deck._pLoadRawJson = DataUtil.deck._pLoadRawJson || DataUtil.loadJSON(`${Renderer.get().baseUrl}data/decks.json`);
        }

        static async loadPrerelease() {
            return {
                deck: await DataLoader.pCacheAndGetAllPrerelease("deck"),
                card: await DataLoader.pCacheAndGetAllPrerelease("card"),
            };
        }

        static async loadBrew() {
            return {
                deck: await DataLoader.pCacheAndGetAllBrew("deck"),
                card: await DataLoader.pCacheAndGetAllBrew("card"),
            };
        }

        static unpackUidCard(uid, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,set,source,displayText] = uid.split("|").map(it=>it.trim());
            set = set || "none";
            source = source || Parser.getTagSource("card", source)[opts.isLower ? "toLowerCase" : "toString"]();
            return {
                name,
                set,
                source,
                displayText,
            };
        }
    }
    ,

    reward: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_REWARDS;
        static _FILENAME = "rewards.json";
    }
    ,

    rewardFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_REWARDS;
        static _FILENAME = "fluff-rewards.json";
    }
    ,

    trap: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_TRAPS_HAZARDS;
        static _FILENAME = "trapshazards.json";
    }
    ,

    trapFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_TRAPS_HAZARDS;
        static _FILENAME = "fluff-trapshazards.json";
    }
    ,

    hazard: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_TRAPS_HAZARDS;
        static _FILENAME = "trapshazards.json";
    }
    ,

    hazardFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_TRAPS_HAZARDS;
        static _FILENAME = "fluff-trapshazards.json";
    }
    ,

    quickreference: {
        unpackUid(uid, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,source,ixChapter,ixHeader,displayText] = uid.split("|").map(it=>it.trim());
            source = source || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
            ixChapter = Number(ixChapter || 0);
            return {
                name,
                ixChapter,
                ixHeader,
                source,
                displayText,
            };
        },
    },

    brew: new _DataUtilBrewHelper({
        defaultUrlRoot: VeCt.URL_ROOT_BREW
    }),
    prerelease: new _DataUtilBrewHelper({
        defaultUrlRoot: VeCt.URL_ROOT_PRERELEASE
    }),
};
//#endregion
//#region RollerUtil
globalThis.RollerUtil = {
    isCrypto() {
        return typeof window !== "undefined" && typeof window.crypto !== "undefined";
    },

    randomise(max, min=1) {
        if (min > max)
            return 0;
        if (max === min)
            return max;
        if (RollerUtil.isCrypto()) {
            return RollerUtil._randomise(min, max + 1);
        } else {
            return RollerUtil.roll(max) + min;
        }
    },

    rollOnArray(array) {
        return array[RollerUtil.randomise(array.length) - 1];
    },

    _randomise: (min,max)=>{
        if (isNaN(min) || isNaN(max))
            throw new Error(`Invalid min/max!`);

        const range = max - min;
        const bytesNeeded = Math.ceil(Math.log2(range) / 8);
        const randomBytes = new Uint8Array(bytesNeeded);
        const maximumRange = (2 ** 8) ** bytesNeeded;
        const extendedRange = Math.floor(maximumRange / range) * range;
        let i;
        let randomInteger;
        while (true) {
            window.crypto.getRandomValues(randomBytes);
            randomInteger = 0;
            for (i = 0; i < bytesNeeded; i++) {
                randomInteger <<= 8;
                randomInteger += randomBytes[i];
            }
            if (randomInteger < extendedRange) {
                randomInteger %= range;
                return min + randomInteger;
            }
        }
    }
    ,

    roll(max, fn=Math.random) {
        return Math.floor(fn() * max);
    },

    getColRollType(colLabel) {
        if (typeof colLabel !== "string")
            return false;
        colLabel = Renderer.stripTags(colLabel);

        if (Renderer.dice.lang.getTree3(colLabel))
            return RollerUtil.ROLL_COL_STANDARD;

        colLabel = colLabel.replace(RollerUtil._REGEX_ROLLABLE_COL_LABEL, "$1");
        if (Renderer.dice.lang.getTree3(colLabel))
            return RollerUtil.ROLL_COL_VARIABLE;

        return RollerUtil.ROLL_COL_NONE;
    },

    getFullRollCol(lbl) {
        if (lbl.includes("@dice"))
            return lbl;

        if (Renderer.dice.lang.getTree3(lbl))
            return `{@dice ${lbl}}`;

        const m = RollerUtil._REGEX_ROLLABLE_COL_LABEL.exec(lbl);
        if (!m)
            return lbl;

        return `{@dice ${m[1]}${m[2]}#$prompt_number:title=Enter a ${m[3].trim()}$#|${lbl}}`;
    },

    _DICE_REGEX_STR: "((([1-9]\\d*)?d([1-9]\\d*)(\\s*?[-+×x*÷/]\\s*?(\\d,\\d|\\d)+(\\.\\d+)?)?))+?",
};
RollerUtil.DICE_REGEX = new RegExp(RollerUtil._DICE_REGEX_STR,"g");
RollerUtil.REGEX_DAMAGE_DICE = /(?<average>\d+)(?<prefix> \((?:{@dice |{@damage ))(?<diceExp>[-+0-9d ]*)(?<suffix>}\)(?:\s*\+\s*the spell's level)? [a-z]+( \([-a-zA-Z0-9 ]+\))?( or [a-z]+( \([-a-zA-Z0-9 ]+\))?)? damage)/gi;
RollerUtil.REGEX_DAMAGE_FLAT = /(?<prefix>Hit: |{@h})(?<flatVal>[0-9]+)(?<suffix> [a-z]+( \([-a-zA-Z0-9 ]+\))?( or [a-z]+( \([-a-zA-Z0-9 ]+\))?)? damage)/gi;
RollerUtil._REGEX_ROLLABLE_COL_LABEL = /^(.*?\d)(\s*[-+/*^×÷]\s*)([a-zA-Z0-9 ]+)$/;
RollerUtil.ROLL_COL_NONE = 0;
RollerUtil.ROLL_COL_STANDARD = 1;
RollerUtil.ROLL_COL_VARIABLE = 2;
//#endregion
//#region CryptUtil
globalThis.CryptUtil = {
    _md5cycle: (x,k)=>{
        let a = x[0];
        let b = x[1];
        let c = x[2];
        let d = x[3];

        a = CryptUtil._ff(a, b, c, d, k[0], 7, -680876936);
        d = CryptUtil._ff(d, a, b, c, k[1], 12, -389564586);
        c = CryptUtil._ff(c, d, a, b, k[2], 17, 606105819);
        b = CryptUtil._ff(b, c, d, a, k[3], 22, -1044525330);
        a = CryptUtil._ff(a, b, c, d, k[4], 7, -176418897);
        d = CryptUtil._ff(d, a, b, c, k[5], 12, 1200080426);
        c = CryptUtil._ff(c, d, a, b, k[6], 17, -1473231341);
        b = CryptUtil._ff(b, c, d, a, k[7], 22, -45705983);
        a = CryptUtil._ff(a, b, c, d, k[8], 7, 1770035416);
        d = CryptUtil._ff(d, a, b, c, k[9], 12, -1958414417);
        c = CryptUtil._ff(c, d, a, b, k[10], 17, -42063);
        b = CryptUtil._ff(b, c, d, a, k[11], 22, -1990404162);
        a = CryptUtil._ff(a, b, c, d, k[12], 7, 1804603682);
        d = CryptUtil._ff(d, a, b, c, k[13], 12, -40341101);
        c = CryptUtil._ff(c, d, a, b, k[14], 17, -1502002290);
        b = CryptUtil._ff(b, c, d, a, k[15], 22, 1236535329);

        a = CryptUtil._gg(a, b, c, d, k[1], 5, -165796510);
        d = CryptUtil._gg(d, a, b, c, k[6], 9, -1069501632);
        c = CryptUtil._gg(c, d, a, b, k[11], 14, 643717713);
        b = CryptUtil._gg(b, c, d, a, k[0], 20, -373897302);
        a = CryptUtil._gg(a, b, c, d, k[5], 5, -701558691);
        d = CryptUtil._gg(d, a, b, c, k[10], 9, 38016083);
        c = CryptUtil._gg(c, d, a, b, k[15], 14, -660478335);
        b = CryptUtil._gg(b, c, d, a, k[4], 20, -405537848);
        a = CryptUtil._gg(a, b, c, d, k[9], 5, 568446438);
        d = CryptUtil._gg(d, a, b, c, k[14], 9, -1019803690);
        c = CryptUtil._gg(c, d, a, b, k[3], 14, -187363961);
        b = CryptUtil._gg(b, c, d, a, k[8], 20, 1163531501);
        a = CryptUtil._gg(a, b, c, d, k[13], 5, -1444681467);
        d = CryptUtil._gg(d, a, b, c, k[2], 9, -51403784);
        c = CryptUtil._gg(c, d, a, b, k[7], 14, 1735328473);
        b = CryptUtil._gg(b, c, d, a, k[12], 20, -1926607734);

        a = CryptUtil._hh(a, b, c, d, k[5], 4, -378558);
        d = CryptUtil._hh(d, a, b, c, k[8], 11, -2022574463);
        c = CryptUtil._hh(c, d, a, b, k[11], 16, 1839030562);
        b = CryptUtil._hh(b, c, d, a, k[14], 23, -35309556);
        a = CryptUtil._hh(a, b, c, d, k[1], 4, -1530992060);
        d = CryptUtil._hh(d, a, b, c, k[4], 11, 1272893353);
        c = CryptUtil._hh(c, d, a, b, k[7], 16, -155497632);
        b = CryptUtil._hh(b, c, d, a, k[10], 23, -1094730640);
        a = CryptUtil._hh(a, b, c, d, k[13], 4, 681279174);
        d = CryptUtil._hh(d, a, b, c, k[0], 11, -358537222);
        c = CryptUtil._hh(c, d, a, b, k[3], 16, -722521979);
        b = CryptUtil._hh(b, c, d, a, k[6], 23, 76029189);
        a = CryptUtil._hh(a, b, c, d, k[9], 4, -640364487);
        d = CryptUtil._hh(d, a, b, c, k[12], 11, -421815835);
        c = CryptUtil._hh(c, d, a, b, k[15], 16, 530742520);
        b = CryptUtil._hh(b, c, d, a, k[2], 23, -995338651);

        a = CryptUtil._ii(a, b, c, d, k[0], 6, -198630844);
        d = CryptUtil._ii(d, a, b, c, k[7], 10, 1126891415);
        c = CryptUtil._ii(c, d, a, b, k[14], 15, -1416354905);
        b = CryptUtil._ii(b, c, d, a, k[5], 21, -57434055);
        a = CryptUtil._ii(a, b, c, d, k[12], 6, 1700485571);
        d = CryptUtil._ii(d, a, b, c, k[3], 10, -1894986606);
        c = CryptUtil._ii(c, d, a, b, k[10], 15, -1051523);
        b = CryptUtil._ii(b, c, d, a, k[1], 21, -2054922799);
        a = CryptUtil._ii(a, b, c, d, k[8], 6, 1873313359);
        d = CryptUtil._ii(d, a, b, c, k[15], 10, -30611744);
        c = CryptUtil._ii(c, d, a, b, k[6], 15, -1560198380);
        b = CryptUtil._ii(b, c, d, a, k[13], 21, 1309151649);
        a = CryptUtil._ii(a, b, c, d, k[4], 6, -145523070);
        d = CryptUtil._ii(d, a, b, c, k[11], 10, -1120210379);
        c = CryptUtil._ii(c, d, a, b, k[2], 15, 718787259);
        b = CryptUtil._ii(b, c, d, a, k[9], 21, -343485551);

        x[0] = CryptUtil._add32(a, x[0]);
        x[1] = CryptUtil._add32(b, x[1]);
        x[2] = CryptUtil._add32(c, x[2]);
        x[3] = CryptUtil._add32(d, x[3]);
    }
    ,

    _cmn: (q,a,b,x,s,t)=>{
        a = CryptUtil._add32(CryptUtil._add32(a, q), CryptUtil._add32(x, t));
        return CryptUtil._add32((a << s) | (a >>> (32 - s)), b);
    }
    ,

    _ff: (a,b,c,d,x,s,t)=>{
        return CryptUtil._cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    ,

    _gg: (a,b,c,d,x,s,t)=>{
        return CryptUtil._cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    ,

    _hh: (a,b,c,d,x,s,t)=>{
        return CryptUtil._cmn(b ^ c ^ d, a, b, x, s, t);
    }
    ,

    _ii: (a,b,c,d,x,s,t)=>{
        return CryptUtil._cmn(c ^ (b | (~d)), a, b, x, s, t);
    }
    ,

    _md51: (s)=>{
        let n = s.length;
        let state = [1732584193, -271733879, -1732584194, 271733878];
        let i;
        for (i = 64; i <= s.length; i += 64) {
            CryptUtil._md5cycle(state, CryptUtil._md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        let tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < s.length; i++)
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            CryptUtil._md5cycle(state, tail);
            for (i = 0; i < 16; i++)
                tail[i] = 0;
        }
        tail[14] = n * 8;
        CryptUtil._md5cycle(state, tail);
        return state;
    }
    ,

    _md5blk: (s)=>{
        let md5blks = [];
        for (let i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }
    ,

    _hex_chr: "0123456789abcdef".split(""),

    _rhex: (n)=>{
        let s = "";
        for (let j = 0; j < 4; j++) {
            s += CryptUtil._hex_chr[(n >> (j * 8 + 4)) & 0x0F] + CryptUtil._hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }
    ,

    _add32: (a,b)=>{
        return (a + b) & 0xFFFFFFFF;
    }
    ,

    hex: (x)=>{
        for (let i = 0; i < x.length; i++) {
            x[i] = CryptUtil._rhex(x[i]);
        }
        return x.join("");
    }
    ,

    hex2Dec(hex) {
        return parseInt(`0x${hex}`);
    },

    md5: (s)=>{
        return CryptUtil.hex(CryptUtil._md51(s));
    }
    ,

    hashCode(obj) {
        if (typeof obj === "string") {
            if (!obj)
                return 0;
            let h = 0;
            for (let i = 0; i < obj.length; ++i)
                h = 31 * h + obj.charCodeAt(i);
            return h;
        } else if (typeof obj === "number")
            return obj;
        else
            throw new Error(`No hashCode implementation for ${obj}`);
    },

    uid() {
        if (RollerUtil.isCrypto()) {
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c=>(c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
        } else {
            let d = Date.now();
            if (typeof performance !== "undefined" && typeof performance.now === "function") {
                d += performance.now();
            }
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
                const r = (d + Math.random() * 16) % 16 | 0;
                d = Math.floor(d / 16);
                return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
    },
};
//#endregion


//#endregion

//#region 5ETOOLS SPECIFIC
//#region VeTools
globalThis.VeLock = function({name=null, isDbg=false}={}) {
    this._name = name;
    this._isDbg = isDbg;
    this._lockMeta = null;

    this._getCaller = ()=>{
        return (new Error()).stack.split("\n")[3].trim();
    }
    ;

    this.pLock = async({token=null}={})=>{
        if (token != null && this._lockMeta?.token === token) {
            ++this._lockMeta.depth;
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" add (now ${this._lockMeta.depth}) at ${this._getCaller()}`);
            return token;
        }

        while (this._lockMeta)
            await this._lockMeta.lock;

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" acquired at ${this._getCaller()}`);

        let unlock = null;
        const lock = new Promise(resolve=>unlock = resolve);
        this._lockMeta = {
            lock,
            unlock,
            token: CryptUtil.uid(),
            depth: 0,
        };

        return this._lockMeta.token;
    }
    ;

    this.unlock = ()=>{
        if (!this._lockMeta)
            return;

        if (this._lockMeta.depth > 0) {
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" sub (now ${this._lockMeta.depth - 1}) at ${this._getCaller()}`);
            return --this._lockMeta.depth;
        }

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" released at ${this._getCaller()}`);

        const lockMeta = this._lockMeta;
        this._lockMeta = null;
        lockMeta.unlock();
    }
    ;
}
;
class Vetools {
    static PRERELEASE_INDEX__SOURCE = {};
    static PRERELEASE_INDEX__PROP = {};
    static PRERELEASE_INDEX__META = {};

    static BREW_INDEX__SOURCE = {};
    static BREW_INDEX__PROP = {};
    static BREW_INDEX__META = {};

    static async pDoPreload() {
        if (Config.get("dataSources", "isNoPrereleaseBrewIndexes"))
            return;

        Vetools._pGetPrereleaseBrewIndices().then(({propPrerelease, sourcePrerelease, metaPrerelease, sourceBrew, propBrew, metaBrew})=>{
            Vetools.PRERELEASE_INDEX__PROP = propPrerelease;
            Vetools.PRERELEASE_INDEX__SOURCE = sourcePrerelease;
            Vetools.PRERELEASE_INDEX__META = metaPrerelease;

            Vetools.BREW_INDEX__PROP = propBrew;
            Vetools.BREW_INDEX__SOURCE = sourceBrew;
            Vetools.BREW_INDEX__META = metaBrew;

            console.log(...LGT, "Loaded prerelease/homebrew indexes.");
        }
        ).catch(e=>{
            Vetools.PRERELEASE_INDEX__SOURCE = {};
            Vetools.PRERELEASE_INDEX__PROP = {};
            Vetools.PRERELEASE_INDEX__META = {};

            Vetools.BREW_INDEX__PROP = {};
            Vetools.BREW_INDEX__SOURCE = {};
            Vetools.BREW_INDEX__META = {};

            ui.notifications.error(`Failed to load prerelease/homebrew indexes! ${VeCt.STR_SEE_CONSOLE}`);
            setTimeout(()=>{
                throw e;
            }
            );
        }
        );
    }

    static withUnpatchedDiceRendering(fn) {
        Renderer.getRollableEntryDice = Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE;
        const out = fn();
        Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
        return out;
    }

    static withCustomDiceRenderingPatch(fn, fnRender) {
        Renderer.getRollableEntryDice = fnRender;
        const out = fn();
        Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
        return out;
    }

    static getCleanDiceString(diceString) {
        return diceString.replace(/×/g, "*").replace(/÷/g, "/").replace(/#\$.*?\$#/g, "0");
    }

    static doMonkeyPatchPreConfig() {
        VeCt.STR_SEE_CONSOLE = "See the console (F12 or CTRL+SHIFT+J) for details.";

        StorageUtil.pSet = GameStorage.pSetClient.bind(GameStorage);
        StorageUtil.pGet = GameStorage.pGetClient.bind(GameStorage);
        StorageUtil.pRemove = GameStorage.pRemoveClient.bind(GameStorage);

        ["monster", "vehicle", "object", "trap", "race", "background"].forEach(prop=>{
            const propFullName = `${prop}Name`;
            const propFullSource = `${prop}Source`;
            (Renderer[prop].CHILD_PROPS_EXTENDED || Renderer[prop].CHILD_PROPS || ["feature"]).forEach(propChild=>{
                const propChildFull = `${prop}${propChild.uppercaseFirst()}`;
                if (UrlUtil.URL_TO_HASH_BUILDER[propChildFull])
                    return;
                UrlUtil.URL_TO_HASH_BUILDER[propChildFull] = it=>UrlUtil.encodeForHash([it.name, it[propFullName], it[propFullSource], it.source]);
            }
            );
        }
        );
    }

    static _CACHED_DATA_UTIL_LOAD_JSON = null;
    static _CACHED_DATA_UTIL_LOAD_RAW_JSON = null;

    static doMonkeyPatchPostConfig() {
        JqueryExtension.init();
        this._initSourceLookup();

        UtilsChangelog._RELEASE_URL = "https://github.com/TheGiddyLimit/plutonium-next/tags";

        const hkSetRendererUrls = ()=>{
            Renderer.get().setBaseUrl(Vetools.BASE_SITE_URL);

            if (Config.get("import", "isUseLocalImages")) {
                const localImageDirPath = `${Config.get("import", "localImageDirectoryPath")}/`.replace(/\/+$/, "/");
                Renderer.get().setBaseMediaUrl("img", localImageDirPath);
                return;
            }

            if (this._isCustomBaseSiteUrl()) {
                Renderer.get().setBaseMediaUrl("img", Vetools.BASE_SITE_URL);
                return;
            }

            Renderer.get().setBaseMediaUrl("img", null);
        }
        ;
        hkSetRendererUrls();

        UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, hkSetRendererUrls);

        Renderer.hover.MIN_Z_INDEX = Consts.Z_INDEX_MAX_FOUNDRY + 1;
        Renderer.hover._MAX_Z_INDEX = Renderer.hover.MIN_Z_INDEX + 10;

        Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE = Renderer.getRollableEntryDice;
        Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE = (entry,name,toDisplay,{isAddHandlers=true, pluginResults=null, }={},)=>{
            const cpy = MiscUtil.copy(entry);

            if (typeof cpy.toRoll !== "string") {
                cpy.toRoll = Renderer.legacyDiceToString(cpy.toRoll);
            }

            if (cpy.prompt) {
                const minAdditionalDiceLevel = Math.min(...Object.keys(cpy.prompt.options).map(it=>Number(it)).filter(it=>cpy.prompt.options[it]));
                cpy.toRoll = cpy.prompt.options[minAdditionalDiceLevel];
            }

            const toRollClean = this.getCleanDiceString(cpy.toRoll);

            if (Config.get("import", "isRendererDiceDisabled"))
                return toDisplay || toRollClean;

            const ptDisplay = toRollClean.toLowerCase().trim() !== toDisplay.toLowerCase().trim() ? `{${toDisplay}}` : "";

            if (cpy.autoRoll)
                return `[[${toRollClean}]]${ptDisplay}`;

            if (Config.get("import", "isRenderCustomDiceEnrichers") && entry.subtype === "damage") {
                return `[[/damage ${toRollClean} ${cpy.damageType ? `type=${cpy.damageType}` : ""}]]${ptDisplay}`;
            }

            return `[[/r ${toRollClean}]]${ptDisplay}`;
        }
        ;

        Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;

        const cachedRenderHoverMethods = {};
        const renderHoverMethods = ["$getHoverContent_stats", "$getHoverContent_fluff", "$getHoverContent_statsCode", "$getHoverContent_miscCode", "$getHoverContent_generic", ];
        renderHoverMethods.forEach(methodName=>{
            cachedRenderHoverMethods[methodName] = Renderer.hover[methodName];
            Renderer.hover[methodName] = (...args)=>{
                Renderer.getRollableEntryDice = Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE;
                const out = cachedRenderHoverMethods[methodName](...args);
                Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
                return out;
            }
            ;
        }
        );

        const cachedGetMakePredefinedHover = Renderer.hover.getMakePredefinedHover.bind(Renderer.hover);
        Renderer.hover.getMakePredefinedHover = (entry,opts)=>{
            const out = cachedGetMakePredefinedHover(entry, opts);
            out.html = `data-plut-hover="${true}" data-plut-hover-preload="${true}" data-plut-hover-preload-id="${out.id}" ${opts ? `data-plut-hover-preload-options="${JSON.stringify(opts).qq()}"` : ""}`;
            return out;
        }
        ;

        const cachedGetInlineHover = Renderer.hover.getInlineHover.bind(Renderer.hover);
        Renderer.hover.getInlineHover = (entry,opts)=>{
            const out = cachedGetInlineHover(entry, opts);
            out.html = `data-plut-hover="${true}" data-plut-hover-inline="${true}" data-plut-hover-inline-entry="${JSON.stringify(entry).qq()}" ${opts ? `data-plut-hover-inline-options="${JSON.stringify(opts).qq()}"` : ""}`;
            return out;
        }
        ;

        Renderer.dice.rollerClick = (evtMock,ele,packed,name)=>{
            const entry = JSON.parse(packed);
            if (entry.toRoll)
                (new Roll(entry.toRoll)).toMessage();
        }
        ;

        Renderer.dice.pRollEntry = (entry,rolledBy,opts)=>{
            if (entry.toRoll)
                (new Roll(entry.toRoll)).toMessage();
        }
        ;

        Renderer.dice.pRoll2 = async(str,rolledBy,opts)=>{
            const roll = new Roll(str);
            await roll.evaluate({
                async: true
            });
            await roll.toMessage();
            return roll.total;
        }
        ;

        Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS = Renderer.monster.doBindCompactContentHandlers;
        Renderer.monster.doBindCompactContentHandlers = (opts)=>{
            const nxtOpts = {
                ...opts
            };
            nxtOpts.fnRender = (...args)=>Vetools.withUnpatchedDiceRendering(()=>opts.fnRender(...args));
            return Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS(nxtOpts);
        }
        ;

        JqueryUtil.doToast = (options)=>{
            if (typeof options === "string") {
                options = {
                    content: options,
                    type: "info",
                };
            }
            options.type = options.type || "info";

            switch (options.type) {
            case "warning":
                return ui.notifications.warn(options.content);
            case "danger":
                return ui.notifications.error(options.content);
            default:
                return ui.notifications.info(options.content);
            }
        }
        ;

        UiUtil.pGetShowModal = opts=>UtilApplications.pGetShowApplicationModal(opts);
        InputUiUtil._pGetShowModal = opts=>UtilApplications.pGetShowApplicationModal(opts);

        this._CACHED_DATA_UTIL_LOAD_JSON = DataUtil.loadJSON.bind(DataUtil);
        this._CACHED_DATA_UTIL_LOAD_RAW_JSON = DataUtil.loadRawJSON.bind(DataUtil);

        DataUtil.loadJSON = async(url,...rest)=>Vetools._CACHED_DATA_UTIL_LOAD_JSON(this._getMaybeLocalUrl(url), ...rest);
        DataUtil.loadRawJSON = async(url,...rest)=>Vetools._CACHED_DATA_UTIL_LOAD_RAW_JSON(this._getMaybeLocalUrl(url), ...rest);

        Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET = DataLoader.pCacheAndGet.bind(DataLoader);
        DataLoader.pCacheAndGet = async function(page, source, ...others) {
            const sourceLower = `${source}`.toLowerCase();
            if (!Vetools._VET_SOURCE_LOOKUP[sourceLower]) {
                Vetools._pCachingLocalPrerelease = Vetools._pCachingLocalPrerelease || Vetools._pDoCacheLocalPrerelease();
                Vetools._pCachingLocalBrew = Vetools._pCachingLocalBrew || Vetools._pDoCacheLocalBrew();

                await Promise.all([Vetools._pCachingLocalPrerelease, Vetools._pCachingLocalBrew, ]);
            }

            return Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET(page, source, ...others);
        }
        ;

        PrereleaseUtil._storage = new StorageUtilMemory();
        BrewUtil2._storage = new StorageUtilMemory();
    }

    static _initSourceLookup() {
        Object.keys(Parser.SOURCE_JSON_TO_FULL).forEach(source=>Vetools._VET_SOURCE_LOOKUP[source.toLowerCase()] = true);
    }

    static _pCachingLocalPrerelease = null;
    static _pCachingLocalBrew = null;

    static async _pDoCacheLocalPrerelease() {
        await this.pGetLocalPrereleaseSources();
    }
    static async _pDoCacheLocalBrew() {
        await this.pGetLocalBrewSources();
    }

    static _getMaybeLocalUrl(url) {
        if (!url.includes("?"))
            url = `${url}?t=${Consts.RUN_TIME}`;

        const parts = url.split(Vetools._RE_HTTP_URL).filter(Boolean);
        parts[parts.length - 1] = parts.last().replace(/\/+/g, "/");
        url = parts.join("");

        if (!Config.get("dataSources", "isNoLocalData") && (url.startsWith(`${Vetools.BASE_SITE_URL}data/`) || url.startsWith(`${Vetools.BASE_SITE_URL}search/`)) && url !== this._getChangelogUrl()) {
            const urlPart = url.split(Vetools.BASE_SITE_URL).slice(1).join(Vetools.BASE_SITE_URL);
            if(SETTINGS.LOCALPATH_REDIRECT){return urlPart;}
            return `modules/${SharedConsts.MODULE_ID}/${urlPart}`;
        } else {
            return url;
        }
    }

    static _CACHE_IMPORTER_SOURCE_SPECIAL = {};

    static async pLoadImporterSourceSpecial(source) {
        if (!source.special.cacheKey)
            return source.special.pGet();

        this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey] = this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey] || source.special.pGet();

        return this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey];
    }

    static _getChangelogUrl() {
        return `${Vetools.BASE_SITE_URL}data/changelog.json`;
    }
    static async pGetChangelog() {
        return DataUtil.loadJSON(this._getChangelogUrl());
    }

    static async pGetPackageIndex() {
        return DataUtil.loadJSON(Config.get("importAdventure", "indexUrl"));
    }

    static async pGetItems() {
        return {
            item: (await Renderer.item.pBuildList()).filter(it=>!it._isItemGroup)
        };
    }

    static async pGetPrereleaseItems(data) {
        return this._pGetPrereleaseBrewItems({
            data,
            pFnGetItems: Renderer.item.pGetItemsFromPrerelease.bind(Renderer.item)
        });
    }

    static async pGetBrewItems(data) {
        return this._pGetPrereleaseBrewItems({
            data,
            pFnGetItems: Renderer.item.pGetItemsFromBrew.bind(Renderer.item)
        });
    }

    static async _pGetPrereleaseBrewItems({data, pFnGetItems}) {
        const sources = new Set();
        ["item", "magicvariant", "baseitem"].forEach(prop=>{
            if (!data[prop])
                return;
            data[prop].forEach(ent=>sources.add(SourceUtil.getEntitySource(ent)));
        }
        );
        return (await pFnGetItems()).filter(ent=>sources.has(SourceUtil.getEntitySource(ent)));
    }

    static async pGetRaces(opts) {
        return DataUtil.race.loadJSON(opts);
    }

    static async pGetClasses() {
        return DataUtil.class.loadRawJSON();
    }

    static async pGetClassSubclassFeatures() {
        return DataUtil.class.loadRawJSON();
    }

    static async pGetRollableTables() {
        return DataUtil.table.loadJSON();
    }

    static async pGetDecks() {
        return DataUtil.deck.loadJSON();
    }

    static async _pGetAdventureBookIndex(filename, {prop, fnGetUrl}) {
        const url = `${Vetools.BASE_SITE_URL}data/${filename}`;
        const index = await DataUtil.loadJSON(url);
        index[prop].forEach(it=>{
            it._pubDate = new Date(it.published || "1970-01-01");
            it._url = fnGetUrl(it.id);
        }
        );
        return index;
    }

    static async pGetAdventureIndex() {
        return this._pGetAdventureBookIndex("adventures.json", {
            prop: "adventure",
            fnGetUrl: Vetools.getAdventureUrl.bind(Vetools)
        });
    }

    static async pGetBookIndex() {
        return this._pGetAdventureBookIndex("books.json", {
            prop: "book",
            fnGetUrl: Vetools.getBookUrl.bind(Vetools)
        });
    }

    static _getAdventureBookUrl(type, id) {
        return `${Vetools.BASE_SITE_URL}data/${type}/${type}-${id.toLowerCase()}.json`;
    }

    static getAdventureUrl(id) {
        return this._getAdventureBookUrl("adventure", id);
    }

    static getBookUrl(id) {
        return this._getAdventureBookUrl("book", id);
    }

    static pGetImageUrlFromFluff(fluff) {
        if (!fluff?.images?.length)
            return;

        const imgEntry = fluff.images[0];
        if (!imgEntry?.href)
            return;

        const urlsWarn = [];
        const out = fluff.images.first(imgEntry=>{
            const url = this._pGetImageUrlFromFluff_getUrlFromEntry({
                imgEntry
            });
            if (!this._isValidImageUrl({
                url
            })) {
                urlsWarn.push(url);
                return null;
            }
            return url;
        }
        );

        if (urlsWarn.length)
            ui.notifications.warn(`Image URL${urlsWarn.length === 1 ? "" : "s"} did not have valid extensions: ${urlsWarn.map(it=>`"${it}"`).join(", ")}`);

        return out;
    }

    static _pGetImageUrlFromFluff_getUrlFromEntry({imgEntry}) {
        if (imgEntry.href.type === "internal") {
            return imgEntry.href.path ? `${Vetools.getInternalImageUrl(imgEntry.href.path)}` : null;
        }

        if (imgEntry.href.type === "external") {
            return imgEntry.href.url ? imgEntry.href.url : null;
        }
    }

    static _isValidImageUrl({url}) {
        return foundry.data.validators.hasFileExtension(url, Object.keys(CONST.IMAGE_FILE_EXTENSIONS));
    }

    static async pHasTokenUrl(entityType, it, opts) {
        return (await Vetools._pGetTokenUrl(entityType, it, opts))?.hasToken;
    }

    static async pGetTokenUrl(entityType, it, opts) {
        return (await Vetools._pGetTokenUrl(entityType, it, opts))?.url;
    }

    static _isSaveableToServerUrl(originalUrl) {
        return originalUrl && typeof originalUrl === "string" && Vetools._RE_HTTP_URL.test(originalUrl);
    }
    static _isSaveTypedImagesToServer({imageType="image"}={}) {
        switch (imageType) {
        case "image":
            return Config.get("import", "isSaveImagesToServer");
        case "token":
            return Config.get("import", "isSaveTokensToServer");
        default:
            throw new Error(`Unhandled type "${imageType}"!`);
        }
    }

    static async _pGetTokenUrl(entityType, it, {isSilent=false}={}) {
        if (it.tokenUrl)
            return {
                url: it.tokenUrl,
                hasToken: true
            };

        const fallbackMeta = {
            url: this.getBlankTokenUrl(),
            hasToken: false,
        };

        switch (entityType) {
        case "monster":
        case "vehicle":
        case "object":
            {
                const fnGets = {
                    "monster": Renderer.monster.getTokenUrl,
                    "vehicle": Renderer.vehicle.getTokenUrl,
                    "object": Renderer.object.getTokenUrl,
                };
                const fnGet = fnGets[entityType];
                if (!fnGet)
                    throw new Error(`Missing getter!`);

                if (it.hasToken)
                    return {
                        url: fnGet(it),
                        hasToken: true
                    };
                if (it._versionBase_hasToken)
                    return {
                        url: fnGet({
                            name: it._versionBase_name,
                            source: it._versionBase_source
                        }),
                        hasToken: true
                    };

                return fallbackMeta;
            }
        case "trap":
            return fallbackMeta;
        default:
            {
                if (isSilent)
                    return null;
                throw new Error(`Unhandled entity type "${entityType}"`);
            }
        }
    }

    static getBlankTokenUrl() {
        return UrlUtil.link(`${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/blank.png`);
    }

    static getImageUrl(entry) {
        if (entry?.href.type === "internal")
            return Vetools.getInternalImageUrl(entry.href.path, {
                isSkipEncode: true
            });
        return entry.href?.url;
    }

    static getInternalImageUrl(path, {isSkipEncode=false}={}) {
        if (!path)
            return null;
        const fnEncode = isSkipEncode ? it=>it : encodeURI;

        const out = `${fnEncode(Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl)}img/${fnEncode(path)}`;

        if (isSkipEncode)
            return out;
        return out.replace(/'/g, "%27");
    }

    static async pOptionallySaveImageToServerAndGetUrl(originalUrl, {imageType="image"}={}) {
        if (this._isLocalUrl({
            originalUrl
        }))
            return originalUrl;
        if (!this._isSaveTypedImagesToServer({
            imageType
        }))
            return originalUrl;
        return this.pSaveImageToServerAndGetUrl({
            originalUrl
        });
    }

    static _isLocalUrl({originalUrl}) {
        return new URL(document.baseURI).origin === new URL(originalUrl,document.baseURI).origin;
    }

    static getImageSavedToServerUrl({originalUrl=null, path, isSaveToRoot=false}={}) {
        if (!path && !this._isSaveableToServerUrl(originalUrl))
            return originalUrl;

        const pathPart = (new URL(path ? `https://example.com/${path}` : originalUrl)).pathname;
        return `${isSaveToRoot ? "" : `${Config.get("import", "localImageDirectoryPath")}/`}${decodeURI(pathPart)}`.replace(/\/+/g, "/");
    }

    static _getImageSavedToServerUrlMeta({originalUrl=null, path, isSaveToRoot=false}) {
        const cleanOutPath = this.getImageSavedToServerUrl({
            originalUrl,
            path,
            isSaveToRoot
        });
        const serverUrlPathParts = cleanOutPath.split("/");
        const serverUrlDirParts = serverUrlPathParts.slice(0, -1);
        const serverUrlDir = serverUrlDirParts.join("/");

        return {
            serverUrl: cleanOutPath,
            serverUrlPathParts,
            serverUrlDir,
            serverUrlDirParts,
        };
    }

    static async pSaveImageToServerAndGetUrl({originalUrl=null, blob, force=false, path=null, isSaveToRoot=false}={}) {
        if (blob && originalUrl)
            throw new Error(`"blob" and "originalUrl" arguments are mutually exclusive!`);

        if (!blob && !this._isSaveableToServerUrl(originalUrl))
            return originalUrl;

        let out;
        try {
            await Vetools._LOCK_DOWNLOAD_IMAGE.pLock();
            out = await this._pSaveImageToServerAndGetUrl_({
                originalUrl,
                blob,
                force,
                path,
                isSaveToRoot
            });
        } finally {
            Vetools._LOCK_DOWNLOAD_IMAGE.unlock();
        }
        return out;
    }

    static async _pSaveImageToServerAndGetUrl_({originalUrl=null, blob, force=false, path=null, isSaveToRoot=false}={}) {
        if (blob && originalUrl)
            throw new Error(`"blob" and "originalUrl" arguments are mutually exclusive!`);

        const {serverUrl, serverUrlPathParts, serverUrlDir, serverUrlDirParts, } = this._getImageSavedToServerUrlMeta({
            originalUrl,
            path,
            isSaveToRoot
        });

        const {dirListing, isDirExists, isError: isErrorDirListing, } = await this.pGetDirectoryListing({
            originalUrl,
            path,
            isSaveToRoot
        });

        if (isErrorDirListing) {
            const msgStart = `Could not check for existing files when saving imported images to server!`;
            if (!force && blob)
                throw new Error(msgStart);

            const msg = `${msgStart}${force ? "" : ` The original image URL will be used instead.`}`;
            UtilNotifications.notifyOnce({
                type: "warn",
                message: msg
            });
            return force ? serverUrl : originalUrl;
        }

        if (dirListing?.files && dirListing?.files.map(it=>UtilFileBrowser.decodeUrl(it)).includes(serverUrl))
            return serverUrl;

        if (!this._canUploadFiles()) {
            if (!force && blob)
                throw new Error(`Your permission levels do not allow you to upload files!`);

            const msg = `You have the "Save Imported Images to Server" config option enabled, but your permission levels do not allow you to upload files!${force ? "" : ` The original image URL will be used instead.`}`;
            UtilNotifications.notifyOnce({
                type: "warn",
                message: msg
            });
            return force ? serverUrl : originalUrl;
        }

        if (!isDirExists) {
            try {
                await this._pSaveImageToServerAndGetUrl_pCreateDirectories(serverUrlDirParts);
            } catch (e) {
                const msgStart = `Could not create required directories when saving imported images to server!`;
                if (!force && blob)
                    throw new Error(msgStart);

                const msg = `${msgStart}${force ? "" : ` The original image URL will be used instead.`}`;
                UtilNotifications.notifyOnce({
                    type: "warn",
                    message: msg
                });
                return force ? serverUrl : originalUrl;
            }
        }

        try {
            blob = blob || await this._pSaveImageToServerAndGetUrl_pGetBlob(originalUrl);
        } catch (e) {
            const msg = `Failed to download image "${originalUrl}" when saving imported images to server!${force ? "" : ` The original image URL will be used instead.`} ${VeCt.STR_SEE_CONSOLE}`;
            UtilNotifications.notifyOnce({
                type: "warn",
                message: msg
            });
            console.error(...LGT, e);
            return force ? serverUrl : originalUrl;
        }

        const name = serverUrlPathParts.last();
        let mimeType = `image/${(name.split(".").last() || "").trim().toLowerCase()}`;
        if (mimeType === "image/jpg")
            mimeType = "image/jpeg";

        const resp = await FilePicker.upload("data", serverUrlDir, new File([blob],name,{
            lastModified: Date.now(),
            type: mimeType,
        },), {}, {
            notify: false,
        }, );
        if (resp?.path)
            return UtilFileBrowser.decodeUrl(resp.path);

        return force ? serverUrl : originalUrl;
    }

    static async _pSaveImageToServerAndGetUrl_pGetBlob(originalUrl) {
        const isBackend = await UtilBackend.pGetBackendVersion();

        try {
            const blobResp = await fetch(originalUrl);
            return blobResp.blob();
        } catch (e) {
            if (!isBackend)
                throw e;
            console.warn(...LGT, `Could not directly load image from ${originalUrl}\u2014falling back on alternate loader (backend mod).`);
        }

        const blobResp = await fetch(Config.backendEndpoint, {
            method: "post",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                type: "getBinaryData",
                url: originalUrl,
            }),
        }, );
        return blobResp.blob();
    }

    static async _pSaveImageToServerAndGetUrl_pCreateDirectories(serverUrlDirParts) {
        if (!serverUrlDirParts.length)
            return;
        for (let i = 0; i < serverUrlDirParts.length; ++i) {
            const dirPartSlice = serverUrlDirParts.slice(0, i + 1);
            try {
                await FilePicker.createDirectory("data", dirPartSlice.join("/"));
            } catch (e) {
                if (/EEXIST/.test(`${e}`))
                    continue;
                throw new Error(e);
            }
        }
    }

    static _canUploadFiles() {
        return game.isAdmin || (game.user && game.user.can("FILES_UPLOAD"));
    }

    static async pGetDirectoryListing({originalUrl=null, path=null, isSaveToRoot=false, isDirPath=false}) {
        if (originalUrl && isDirPath)
            throw new Error(`Arguments "originalUrl" and "isDirPath" are mutually exclusive`);
        if (!path && isDirPath)
            throw new Error(`Argument "isDirPath" requires the "path" argument to be passed!`);

        const {serverUrlDir} = this._getImageSavedToServerUrlMeta({
            originalUrl,
            path: path && isDirPath ? `${path}/stub` : path,
            isSaveToRoot,
        });

        let dirListing = null;
        let isDirExists = false;
        let isError = false;
        try {
            dirListing = await FilePicker.browse("data", serverUrlDir);
            if (dirListing?.target)
                isDirExists = true;
        } catch (e) {
            isError = !/Directory .*? does not exist/.test(`${e}`);
        }

        return {
            dirListing,
            isDirExists,
            isError,
        };
    }

    static async pGetAllSpells({isFilterNonStandard=false, additionalSourcesPrerelease=[], additionalSourcesBrew=[], isIncludeLoadedBrew=false, isIncludeLoadedPrerelease=false, isApplyBlocklist=false, }={}, ) {
        let spells = MiscUtil.copyFast(await DataUtil.spell.pLoadAll());
        if (isFilterNonStandard)
            spells = spells.filter(sp=>!SourceUtil.isNonstandardSource(sp.source));

        if (isIncludeLoadedPrerelease) {
            const prerelease = await PrereleaseUtil.pGetBrewProcessed();
            if (prerelease.spell?.length)
                spells = spells.concat(prerelease.spell);
        }

        if (isIncludeLoadedBrew) {
            const brew = await BrewUtil2.pGetBrewProcessed();
            if (brew.spell?.length)
                spells = spells.concat(brew.spell);
        }

        const pHandleAdditionalSources = async({additionalSources, pFnLoad})=>{
            for (const src of additionalSources) {
                const json = await pFnLoad(src);
                if (!json)
                    continue;
                if (json.spell?.length)
                    spells = spells.concat(json.spell);
            }
        }
        ;

        if (additionalSourcesPrerelease?.length)
            await pHandleAdditionalSources({
                additionalSources: additionalSourcesPrerelease,
                pFnLoad: DataUtil.pLoadPrereleaseBySource.bind(DataUtil)
            });
        if (additionalSourcesBrew?.length)
            await pHandleAdditionalSources({
                additionalSources: additionalSourcesBrew,
                pFnLoad: DataUtil.pLoadBrewBySource.bind(DataUtil)
            });

        if (isApplyBlocklist) {
            spells = spells.filter(sp=>!ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS](sp), "spell", sp.source, {
                isNoCount: true
            }, ), );
        }

        spells.forEach(sp=>Renderer.spell.initBrewSources(sp));

        return {
            spell: spells
        };
    }

    static async pGetAllCreatures(isFilterNonStandard=false) {
        let creatures = await DataUtil.monster.pLoadAll();

        if (isFilterNonStandard)
            creatures = creatures.filter(mon=>!SourceUtil.isNonstandardSource(mon.source));

        return {
            monster: creatures
        };
    }

    static async _pGetPrereleaseBrewIndices() {
        const out = {
            sourcePrerelease: {},
            propPrerelease: {},
            metaPrerelease: {},

            sourceBrew: {},
            propBrew: {},
            metaBrew: {},
        };

        try {
            const [sourceIndexPrerelease,propIndexPrerelease,metaIndexPrerelease,
            sourceIndexBrew,propIndexBrew,metaIndexBrew,] = await Promise.all([DataUtil.prerelease.pLoadSourceIndex(Config.get("dataSources", "basePrereleaseUrl")), DataUtil.prerelease.pLoadPropIndex(Config.get("dataSources", "basePrereleaseUrl")), DataUtil.prerelease.pLoadMetaIndex(Config.get("dataSources", "basePrereleaseUrl")),
            DataUtil.brew.pLoadSourceIndex(Config.get("dataSources", "baseBrewUrl")), DataUtil.brew.pLoadPropIndex(Config.get("dataSources", "baseBrewUrl")), DataUtil.brew.pLoadMetaIndex(Config.get("dataSources", "baseBrewUrl")), ]);

            out.sourcePrerelease = sourceIndexPrerelease;
            out.propPrerelease = propIndexPrerelease;
            out.metaPrerelease = metaIndexPrerelease;

            out.sourceBrew = sourceIndexBrew;
            out.propBrew = propIndexBrew;
            out.metaBrew = metaIndexBrew;
        } catch (e) {
            ui.notifications.error(`Failed to load prerelease/homebrew index! ${VeCt.STR_SEE_CONSOLE}`);
            setTimeout(()=>{
                throw e;
            }
            );
        }

        return out;
    }

    static async pGetPrereleaseSources(...dirs) {
        return this._pGetPrereleaseBrewSources({
            dirs,
            brewUtil: PrereleaseUtil,
            indexProp: Vetools.PRERELEASE_INDEX__PROP,
            indexMeta: Vetools.PRERELEASE_INDEX__META,
            configKey: "basePrereleaseUrl",
        });
    }

    static async pGetBrewSources(...dirs) {
        return this._pGetPrereleaseBrewSources({
            dirs,
            brewUtil: BrewUtil2,
            indexProp: Vetools.BREW_INDEX__PROP,
            indexMeta: Vetools.BREW_INDEX__META,
            configKey: "baseBrewUrl",
        });
    }

    static async _pGetPrereleaseBrewSources({dirs, brewUtil, indexProp, indexMeta, configKey}) {
        const urlRoot = Config.get("dataSources", configKey);

        let paths;
        if (dirs.includes("*")) {
            paths = Object.values(indexProp).map(obj=>Object.keys(obj)).flat().unique();
        } else {
            paths = dirs.map(dir=>Object.keys(indexProp[brewUtil.getDirProp(dir)] || {})).flat().unique();
        }

        return paths.map((path)=>{
            const metaName = UrlUtil.getFilename(path);
            return ({
                url: brewUtil.getFileUrl(path, urlRoot),
                name: this._getPrereleaseBrewName(path),
                abbreviations: indexMeta[metaName]?.a || [],
            });
        }
        ).sort((a,b)=>SortUtil.ascSortLower(a.name, b.name));
    }

    static _getPrereleaseBrewName(brewPath) {
        return brewPath.split("/").slice(-1).join("").replace(/\.json$/i, "");
    }

    static _LOCAL_PRERELEASE_SOURCE_SEEN_URLS = new Set();
    static async pGetLocalPrereleaseSources(...dirs) {
        return this._pGetLocalPrereleaseBrewSources({
            brewUtil: PrereleaseUtil,
            dirs,
            displayName: "prerelease",
            configKeyLocal: "localPrerelease",
            configKeyIsLoadIndex: "isLoadLocalPrereleaseIndex",
            configKeyIsUseIndex: "isUseLocalPrereleaseIndexJson",
            configKeyDirectoryPath: "localPrereleaseDirectoryPath",
            setSeenUrls: this._LOCAL_PRERELEASE_SOURCE_SEEN_URLS,
        });
    }

    static _LOCAL_BREW_SOURCE_SEEN_URLS = new Set();
    static async pGetLocalBrewSources(...dirs) {
        return this._pGetLocalPrereleaseBrewSources({
            brewUtil: BrewUtil2,
            dirs,
            displayName: "homebrew",
            configKeyLocal: "localHomebrew",
            configKeyIsLoadIndex: "isLoadLocalHomebrewIndex",
            configKeyIsUseIndex: "isUseLocalHomebrewIndexJson",
            configKeyDirectoryPath: "localHomebrewDirectoryPath",
            setSeenUrls: this._LOCAL_BREW_SOURCE_SEEN_URLS,
        });
    }

    static async _pGetLocalPrereleaseBrewSources({brewUtil, dirs, displayName, configKeyLocal, configKeyIsLoadIndex, configKeyIsUseIndex, configKeyDirectoryPath, setSeenUrls}) {
        try {
            const listLocal = await this._pGetLocalPrereleaseBrewList({
                displayName,
                configKeyIsLoadIndex,
                configKeyIsUseIndex,
                configKeyDirectoryPath,
            });

            const allFilenames = [...(listLocal || []), ...(Config.get("dataSources", configKeyLocal) || []), ];

            if (!allFilenames.length)
                return [];

            await allFilenames.pSerialAwaitMap(async name=>{
                if (setSeenUrls.has(name))
                    return;
                setSeenUrls.add(name);
                await brewUtil.pAddBrewFromUrl(name, {
                    isLazy: true
                });
            }
            );
            await brewUtil.pAddBrewsLazyFinalize();

            const brews = await allFilenames.pSerialAwaitMap(async name=>({
                url: name,
                data: await DataUtil.loadJSON(name),
                name: this._getPrereleaseBrewName(name),
            }));

            const desiredProps = new Set(dirs.map(dir=>brewUtil.getDirProp(dir)));

            return brews.filter(({data})=>{
                if (desiredProps.has("*"))
                    return true;

                const propsInBrew = new Set([...Object.keys(data || {}).filter(it=>!it.startsWith("_")), ...Object.keys(data?._meta?.includes || {}), ]);

                return [...desiredProps].some(it=>propsInBrew.has(it));
            }
            ).map(it=>{
                it.abbreviations = (it.data?._meta?.sources || []).map(it=>it.abbreviation).filter(Boolean);
                return it;
            }
            ).map(({name, url, abbreviations})=>({
                name,
                url,
                abbreviations
            }));
        } catch (e) {
            const msg = `Failed to load local homebrew index!`;
            console.error(...LGT, msg, e);
            ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
        }
        return [];
    }

    static async _pGetLocalPrereleaseBrewList({displayName, configKeyIsLoadIndex, configKeyIsUseIndex, configKeyDirectoryPath}) {
        if (!Config.get("dataSources", configKeyIsLoadIndex))
            return null;

        const isUseIndexJson = Config.get("dataSources", configKeyIsUseIndex);

        if (isUseIndexJson) {
            const indexUrl = `${Config.get("dataSources", configKeyDirectoryPath)}/index.json`.replace(/\/+/g, "/");
            const index = await DataUtil.loadJSON(indexUrl);
            if (!index?.toImport)
                return [];
            return index.toImport.map(it=>{
                if (Vetools._RE_HTTP_URL.test(it))
                    return it;

                return [...indexUrl.split("/").slice(0, -1), it].join("/");
            }
            );
        }

        try {
            const existingFiles = await FilePicker.browse("data", Config.get("dataSources", configKeyDirectoryPath));
            if (!existingFiles?.files?.length)
                return null;

            return existingFiles.files.map(it=>decodeURIComponent(it));
        } catch (e) {
            const ptReason = /You do not have permission to browse the host file system/i.test(e.message) ? `You do not have "Use File Browser" permissions!` : `Does the ${isUseIndexJson ? "file" : "directory"} "<data_dir>/${Config.get("dataSources", configKeyDirectoryPath)}${isUseIndexJson ? "/index.json" : ""}" exist?`;
            const msg = `Failed to load local ${displayName}${isUseIndexJson ? " index" : ""}! ${ptReason}`;
            console.error(...LGT, msg, e);
            ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
            return null;
        }
    }

    static async pGetSpellSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/spells/foundry.json`);
    }
    static async pGetOptionalFeatureSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-optionalfeatures.json`);
    }
    static async pGetClassSubclassSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/class/foundry.json`);
    }
    static async pGetRaceSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-races.json`);
    }
    static async pGetItemSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-items.json`);
    }
    static async pGetFeatSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-feats.json`);
    }
    static async pGetRewardSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-rewards.json`);
    }
    static async pGetActionSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-actions.json`);
    }
    static async pGetVehicleUpgradeSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-vehicles.json`);
    }
    static async pGetCreatureSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/bestiary/foundry.json`);
    }
    static async pGeBackgroundSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-backgrounds.json`);
    }
    static async pGetPsionicsSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-psionics.json`);
    }

    static async pGetConditionDiseaseSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-conditionsdiseases.json`);
    }
    static async pGetObjectSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-objects.json`);
    }
    static async pGetVehicleSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-vehicles.json`);
    }
    static async pGetCharCreationOptionSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-charcreationoptions.json`);
    }
    static async pGetCultBoonSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-cultsboons.json`);
    }
    static async pGetTrapHazardSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-trapshazards.json`);
    }
    static async pGetDeckSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-decks.json`);
    }
    static async pGetDeitySideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-deities.json`);
    }
    static async pGetTableSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-tables.json`);
    }
    static async pGetLanguageSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-languages.json`);
    }
    static async pGetRecipeSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-recipes.json`);
    }
    static async pGetVariantruleSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-variantrules.json`);
    }

    static async pGetCreatureFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }
    static async pGetObjectFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }
    static async pGetVehicleFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }
    static async pGetTrapFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }

    static getModuleDataUrl(filename) {
        if(SETTINGS.LOCALPATH_REDIRECT){return `data/${filename}`;}
        return `modules/${SharedConsts.MODULE_ID}/data/${filename}`;
    }

    static async pGetIconLookup(entityType) {
        return DataUtil.loadJSON(this.getModuleDataUrl(`icon-${entityType}s.json`));
    }

    static get BASE_SITE_URL() {
        if (this._isCustomBaseSiteUrl()) {
            return Util.getCleanServerUrl(Config.get("dataSources", "baseSiteUrl"));
        }
        return Vetools._BASE_SITE_URL;
    }

    static _isCustomBaseSiteUrl() {
        const val = Config.get("dataSources", "baseSiteUrl");
        return !!(val && val.trim());
    }

    static get DATA_URL_FEATS() {
        return `${Vetools.BASE_SITE_URL}data/feats.json`;
    }
    static get DATA_URL_BACKGROUNDS() {
        return `${Vetools.BASE_SITE_URL}data/backgrounds.json`;
    }
    static get DATA_URL_VARIANTRULES() {
        return `${Vetools.BASE_SITE_URL}data/variantrules.json`;
    }
    static get DATA_URL_PSIONICS() {
        return `${Vetools.BASE_SITE_URL}data/psionics.json`;
    }
    static get DATA_URL_OPTIONALFEATURES() {
        return `${Vetools.BASE_SITE_URL}data/optionalfeatures.json`;
    }
    static get DATA_URL_CONDITIONSDISEASES() {
        return `${Vetools.BASE_SITE_URL}data/conditionsdiseases.json`;
    }
    static get DATA_URL_VEHICLES() {
        return `${Vetools.BASE_SITE_URL}data/vehicles.json`;
    }
    static get DATA_URL_REWARDS() {
        return `${Vetools.BASE_SITE_URL}data/rewards.json`;
    }
    static get DATA_URL_OBJECTS() {
        return `${Vetools.BASE_SITE_URL}data/objects.json`;
    }
    static get DATA_URL_DEITIES() {
        return `${Vetools.BASE_SITE_URL}data/deities.json`;
    }
    static get DATA_URL_RECIPES() {
        return `${Vetools.BASE_SITE_URL}data/recipes.json`;
    }
    static get DATA_URL_CHAR_CREATION_OPTIONS() {
        return `${Vetools.BASE_SITE_URL}data/charcreationoptions.json`;
    }
    static get DATA_URL_CULTSBOONS() {
        return `${Vetools.BASE_SITE_URL}data/cultsboons.json`;
    }
    static get DATA_URL_ACTIONS() {
        return `${Vetools.BASE_SITE_URL}data/actions.json`;
    }
    static get DATA_URL_LANGUAGES() {
        return `${Vetools.BASE_SITE_URL}data/languages.json`;
    }
    static get DATA_URL_TRAPS_HAZARDS() {
        return `${Vetools.BASE_SITE_URL}data/trapshazards.json`;
    }
}
Vetools._RE_HTTP_URL = /(^https?:\/\/)/;
Vetools._BASE_SITE_URL = "https://5etools-mirror-1.github.io/";
Vetools.BESTIARY_FLUFF_INDEX = null;
Vetools.BESTIARY_TOKEN_LOOKUP = null;
Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE = null;
Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE = null;
Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS = null;
Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET = null;
Vetools._LOCK_DOWNLOAD_IMAGE = new VeLock();
Vetools._VET_SOURCE_LOOKUP = {};
//#endregion

//#region VeLock
globalThis.VeLock = function({name=null, isDbg=false}={}) {
    this._name = name;
    this._isDbg = isDbg;
    this._lockMeta = null;

    this._getCaller = ()=>{
        return (new Error()).stack.split("\n")[3].trim();
    }
    ;

    this.pLock = async({token=null}={})=>{
        if (token != null && this._lockMeta?.token === token) {
            ++this._lockMeta.depth;
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" add (now ${this._lockMeta.depth}) at ${this._getCaller()}`);
            return token;
        }

        while (this._lockMeta)
            await this._lockMeta.lock;

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" acquired at ${this._getCaller()}`);

        let unlock = null;
        const lock = new Promise(resolve=>unlock = resolve);
        this._lockMeta = {
            lock,
            unlock,
            token: CryptUtil.uid(),
            depth: 0,
        };

        return this._lockMeta.token;
    }
    ;

    this.unlock = ()=>{
        if (!this._lockMeta)
            return;

        if (this._lockMeta.depth > 0) {
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" sub (now ${this._lockMeta.depth - 1}) at ${this._getCaller()}`);
            return --this._lockMeta.depth;
        }

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" released at ${this._getCaller()}`);

        const lockMeta = this._lockMeta;
        this._lockMeta = null;
        lockMeta.unlock();
    }
    ;
};
//#endregion


//#endregion

//#region DATALOADER
class _DataLoaderConst {
    static SOURCE_SITE_ALL = Symbol("SOURCE_SITE_ALL");
    static SOURCE_PRERELEASE_ALL_CURRENT = Symbol("SOURCE_PRERELEASE_ALL_CURRENT");
    static SOURCE_BREW_ALL_CURRENT = Symbol("SOURCE_BREW_ALL_CURRENT");

    static ENTITY_NULL = Symbol("ENTITY_NULL");
}

class _DataLoaderInternalUtil {
    static getCleanPageSourceHash({page, source, hash}) {
        return {
            page: this.getCleanPage({
                page
            }),
            source: this.getCleanSource({
                source
            }),
            hash: this.getCleanHash({
                hash
            }),
        };
    }

    static getCleanPage({page}) {
        return page.toLowerCase();
    }
    static getCleanSource({source}) {
        return source.toLowerCase();
    }
    static getCleanHash({hash}) {
        return hash.toLowerCase();
    }

    static getCleanPageFluff({page}) {
        return `${this.getCleanPage({
            page
        })}fluff`;
    }

    static _NOTIFIED_FAILED_DEREFERENCES = new Set();

    static doNotifyFailedDereferences({missingRefSets, diagnostics}) {
        const missingRefSetsUnseen = Object.entries(missingRefSets).mergeMap(([prop,set])=>({
            [prop]: new Set([...set].filter(ref=>{
                const refLower = ref.toLowerCase();
                const out = !this._NOTIFIED_FAILED_DEREFERENCES.has(refLower);
                this._NOTIFIED_FAILED_DEREFERENCES.add(refLower);
                return out;
            }
            ),),
        }));

        const cntMissingRefs = Object.values(missingRefSetsUnseen).map(({size})=>size).sum();
        if (!cntMissingRefs)
            return;

        const notificationRefs = Object.entries(missingRefSetsUnseen).map(([k,v])=>`${k}: ${[...v].sort(SortUtil.ascSortLower).join(", ")}`).join("; ");

        const ptDiagnostics = DataLoader.getDiagnosticsSummary(diagnostics);
        const msgStart = `Failed to load references for ${cntMissingRefs} entr${cntMissingRefs === 1 ? "y" : "ies"}!`;

        JqueryUtil.doToast({
            type: "danger",
            content: `${msgStart} Reference types and values were: ${[notificationRefs, ptDiagnostics].join(" ")}`,
            isAutoHide: false,
        });

        const cnslRefs = [...Object.entries(missingRefSetsUnseen).map(([k,v])=>`${k}:\n\t${[...v].sort(SortUtil.ascSortLower).join("\n\t")}`), ptDiagnostics, ].filter(Boolean).join("\n");

        setTimeout(()=>{
            throw new Error(`${msgStart}\nReference types and values were:\n${cnslRefs}`);
        }
        );
    }
}

class _DataLoaderDereferencerBase {
    static _DereferenceMeta = class {
        constructor({cntReplaces=0, offsetIx=0}) {
            this.cntReplaces = cntReplaces;
            this.offsetIx = offsetIx;
        }
    }
    ;

    static _WALKER_MOD = MiscUtil.getWalker({
        keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
    });

    _pPreloadingRefContentSite = null;
    _pPreloadingRefContentPrerelease = null;
    _pPreloadingRefContentBrew = null;

    _preloadingPrereleaseLastIdent = null;
    _preloadingBrewLastIdent = null;

    async pPreloadRefContent() {
        await (this._pPreloadingRefContentSite = this._pPreloadingRefContentSite || this._pPreloadRefContentSite());

        if (typeof PrereleaseUtil !== "undefined") {
            const identPrerelease = PrereleaseUtil.getCacheIteration();
            if (identPrerelease !== this._preloadingPrereleaseLastIdent)
                this._pPreloadingRefContentPrerelease = null;
            this._preloadingPrereleaseLastIdent = identPrerelease;
            await (this._pPreloadingRefContentPrerelease = this._pPreloadingRefContentPrerelease || this._pPreloadRefContentPrerelease());
        }

        if (typeof BrewUtil2 !== "undefined") {
            const identBrew = BrewUtil2.getCacheIteration();
            if (identBrew !== this._preloadingBrewLastIdent)
                this._pPreloadingRefContentBrew = null;
            this._preloadingBrewLastIdent = identBrew;
            await (this._pPreloadingRefContentBrew = this._pPreloadingRefContentBrew || this._pPreloadRefContentBrew());
        }
    }

    async _pPreloadRefContentSite() {}
    async _pPreloadRefContentPrerelease() {}
    async _pPreloadRefContentBrew() {}

    dereference({ent, entriesWithoutRefs, toReplaceMeta, ixReplace}) {
        throw new Error("Unimplemented!");
    }

    _getCopyFromCache({page, entriesWithoutRefs, refUnpacked, refHash}) {
        if (page.toLowerCase().endsWith(".html"))
            throw new Error(`Could not dereference "${page}" content. Dereferencing is only supported for props!`);

        return entriesWithoutRefs[page]?.[refHash] ? MiscUtil.copyFast(entriesWithoutRefs[page]?.[refHash]) : DataLoader.getFromCache(page, refUnpacked.source, refHash, {
            isCopy: true
        });
    }
}

class _DataLoaderDereferencerClassSubclassFeatures extends _DataLoaderDereferencerBase {
    dereference({ent, entriesWithoutRefs, toReplaceMeta, ixReplace}) {
        const prop = toReplaceMeta.type === "refClassFeature" ? "classFeature" : "subclassFeature";
        const refUnpacked = toReplaceMeta.type === "refClassFeature" ? DataUtil.class.unpackUidClassFeature(toReplaceMeta.classFeature) : DataUtil.class.unpackUidSubclassFeature(toReplaceMeta.subclassFeature);
        const refHash = UrlUtil.URL_TO_HASH_BUILDER[prop](refUnpacked);

        if (ExcludeUtil.isInitialised && ExcludeUtil.isExcluded(refHash, prop, refUnpacked.source, {
            isNoCount: true
        })) {
            toReplaceMeta.array[toReplaceMeta.ix] = {};
            return new this.constructor._DereferenceMeta({
                cntReplaces: 1
            });
        }

        const cpy = this._getCopyFromCache({
            page: prop,
            entriesWithoutRefs,
            refUnpacked,
            refHash
        });
        if (!cpy)
            return new this.constructor._DereferenceMeta({
                cntReplaces: 0
            });

        delete cpy.header;
        if (toReplaceMeta.name)
            cpy.name = toReplaceMeta.name;
        toReplaceMeta.array[toReplaceMeta.ix] = cpy;
        return new this.constructor._DereferenceMeta({
            cntReplaces: 1
        });
    }
}

class _DataLoaderDereferencerOptionalfeatures extends _DataLoaderDereferencerBase {
    async _pPreloadRefContentSite() {
        await DataLoader.pCacheAndGetAllSite(UrlUtil.PG_OPT_FEATURES);
    }
    async _pPreloadRefContentPrerelease() {
        await DataLoader.pCacheAndGetAllPrerelease(UrlUtil.PG_OPT_FEATURES);
    }
    async _pPreloadRefContentBrew() {
        await DataLoader.pCacheAndGetAllBrew(UrlUtil.PG_OPT_FEATURES);
    }

    dereference({ent, entriesWithoutRefs, toReplaceMeta, ixReplace}) {
        const refUnpacked = DataUtil.generic.unpackUid(toReplaceMeta.optionalfeature, "optfeature");
        const refHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES](refUnpacked);

        if (ExcludeUtil.isInitialised && ExcludeUtil.isExcluded(refHash, "optionalfeature", refUnpacked.source, {
            isNoCount: true
        })) {
            toReplaceMeta.array[toReplaceMeta.ix] = {};
            return new this.constructor._DereferenceMeta({
                cntReplaces: 1
            });
        }

        const cpy = this._getCopyFromCache({
            page: "optionalfeature",
            entriesWithoutRefs,
            refUnpacked,
            refHash
        });
        if (!cpy)
            return new this.constructor._DereferenceMeta({
                cntReplaces: 0
            });

        delete cpy.featureType;
        delete cpy.prerequisite;
        if (toReplaceMeta.name)
            cpy.name = toReplaceMeta.name;
        toReplaceMeta.array[toReplaceMeta.ix] = cpy;

        return new this.constructor._DereferenceMeta({
            cntReplaces: 1
        });
    }
}

class _DataLoaderDereferencerItemEntries extends _DataLoaderDereferencerBase {
    async _pPreloadRefContentSite() {
        await DataLoader.pCacheAndGetAllSite(UrlUtil.PG_ITEMS);
    }
    async _pPreloadRefContentPrerelease() {
        await DataLoader.pCacheAndGetAllPrerelease(UrlUtil.PG_ITEMS);
    }
    async _pPreloadRefContentBrew() {
        await DataLoader.pCacheAndGetAllBrew(UrlUtil.PG_ITEMS);
    }

    dereference({ent, entriesWithoutRefs, toReplaceMeta, ixReplace}) {
        const refUnpacked = DataUtil.generic.unpackUid(toReplaceMeta.itemEntry, "itemEntry");
        const refHash = UrlUtil.URL_TO_HASH_BUILDER["itemEntry"](refUnpacked);

        const cpy = this._getCopyFromCache({
            page: "itemEntry",
            entriesWithoutRefs,
            refUnpacked,
            refHash
        });
        if (!cpy)
            return new this.constructor._DereferenceMeta({
                cntReplaces: 0
            });

        cpy.entriesTemplate = this.constructor._WALKER_MOD.walk(cpy.entriesTemplate, {
            string: (str)=>{
                return Renderer.utils.applyTemplate(ent, str, );
            }
            ,
        }, );

        toReplaceMeta.array.splice(toReplaceMeta.ix, 1, ...cpy.entriesTemplate);

        return new this.constructor._DereferenceMeta({
            cntReplaces: 1,
            offsetIx: cpy.entriesTemplate.length - 1,
        });
    }
}

class _DataLoaderDereferencer {
    static _REF_TYPE_TO_DEREFERENCER = {};

    static _init() {
        this._REF_TYPE_TO_DEREFERENCER["refClassFeature"] = this._REF_TYPE_TO_DEREFERENCER["refSubclassFeature"] = new _DataLoaderDereferencerClassSubclassFeatures();

        this._REF_TYPE_TO_DEREFERENCER["refOptionalfeature"] = new _DataLoaderDereferencerOptionalfeatures();

        this._REF_TYPE_TO_DEREFERENCER["refItemEntry"] = new _DataLoaderDereferencerItemEntries();

        return null;
    }

    static _ = this._init();

    static _WALKER_READ = MiscUtil.getWalker({
        keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
        isNoModification: true,
        isBreakOnReturn: true,
    });

    static async pGetDereferenced(entities, page, {propEntries="entries", propIsRef=null, }={}, ) {
        if (page.toLowerCase().endsWith(".html"))
            throw new Error(`Could not dereference "${page}" content. Dereferencing is only supported for props!`);

        if (!entities || !entities.length)
            return {};

        const out = {};
        const entriesWithRefs = {};
        const entriesWithoutRefs = {};

        this._pGetDereferenced_doSegregateWithWithoutRefs({
            entities,
            page,
            propEntries,
            propIsRef,
            entriesWithRefs,
            entriesWithoutRefs,
        });

        await this._pGetDereferenced_pDoDereference({
            propEntries,
            entriesWithRefs,
            entriesWithoutRefs
        });
        this._pGetDereferenced_doNotifyFailed({
            entriesWithRefs,
            entities
        });
        this._pGetDereferenced_doPopulateOutput({
            page,
            out,
            entriesWithoutRefs,
            entriesWithRefs
        });

        return out;
    }

    static _pGetDereferenced_doSegregateWithWithoutRefs({entities, page, propEntries, propIsRef, entriesWithRefs, entriesWithoutRefs}) {
        const hashBuilder = UrlUtil.URL_TO_HASH_BUILDER[page];
        entities.forEach(ent=>{
            const hash = hashBuilder(ent);
            const hasRefs = this._pGetDereferenced_hasRefs({
                ent,
                propEntries,
                propIsRef
            });

            ((hasRefs ? entriesWithRefs : entriesWithoutRefs)[page] = (hasRefs ? entriesWithRefs : entriesWithoutRefs)[page] || {})[hash] = hasRefs ? MiscUtil.copyFast(ent) : ent;
        }
        );
    }

    static _pGetDereferenced_hasRefs({ent, propEntries, propIsRef}) {
        if (propIsRef != null)
            return !!ent[propIsRef];

        const ptrHasRef = {
            _: false
        };
        this._WALKER_READ.walk(ent[propEntries], this._pGetDereferenced_doPopulateRaw_getHandlers({
            ptrHasRef
        }));
        return ptrHasRef._;
    }

    static _pGetDereferenced_doPopulateRaw_getHandlers({ptrHasRef}) {
        return {
            object: (obj)=>{
                if (this._REF_TYPE_TO_DEREFERENCER[obj.type])
                    return ptrHasRef._ = true;
            }
            ,
            string: (str)=>{
                if (str.startsWith("{#") && str.endsWith("}"))
                    return ptrHasRef._ = true;
            }
            ,
        };
    }

    static _MAX_DEREFERENCE_LOOPS = 25;
    static async _pGetDereferenced_pDoDereference({propEntries, entriesWithRefs, entriesWithoutRefs}) {
        for (let i = 0; i < this._MAX_DEREFERENCE_LOOPS; ++i) {
            if (!Object.keys(entriesWithRefs).length)
                break;

            for (const [page,pageEntries] of Object.entries(entriesWithRefs)) {
                for (const [hash,ent] of Object.entries(pageEntries)) {
                    const toReplaceMetas = [];
                    this._WALKER_READ.walk(ent[propEntries], this._pGetDereferenced_doDereference_getHandlers({
                        toReplaceMetas
                    }), );

                    for (const {type} of toReplaceMetas) {
                        if (!this._REF_TYPE_TO_DEREFERENCER[type])
                            continue;
                        await this._REF_TYPE_TO_DEREFERENCER[type].pPreloadRefContent();
                    }

                    let cntReplaces = 0;
                    for (let ixReplace = 0; ixReplace < toReplaceMetas.length; ++ixReplace) {
                        const toReplaceMeta = this._pGetDereferenced_doDereference_getToReplaceMeta(toReplaceMetas[ixReplace]);

                        const derefMeta = this._REF_TYPE_TO_DEREFERENCER[toReplaceMeta.type].dereference({
                            ent,
                            entriesWithoutRefs,
                            toReplaceMeta,
                            ixReplace,
                        });
                        cntReplaces += derefMeta.cntReplaces;

                        if (!derefMeta.offsetIx)
                            continue;

                        toReplaceMetas.slice(ixReplace + 1).forEach(it=>it.ix += derefMeta.offsetIx);
                    }

                    if (cntReplaces === toReplaceMetas.length) {
                        delete pageEntries[hash];
                        (entriesWithoutRefs[page] = entriesWithoutRefs[page] || {})[hash] = ent;
                    }
                }

                if (!Object.keys(pageEntries).length)
                    delete entriesWithRefs[page];
            }
        }
    }

    static _pGetDereferenced_doDereference_getHandlers({toReplaceMetas}) {
        return {
            array: (arr)=>{
                arr.forEach((it,i)=>{
                    if (this._REF_TYPE_TO_DEREFERENCER[it.type]) {
                        toReplaceMetas.push({
                            ...it,
                            array: arr,
                            ix: i,
                        });
                        return;
                    }

                    if (typeof it === "string" && it.startsWith("{#") && it.endsWith("}")) {
                        toReplaceMetas.push({
                            string: it,
                            array: arr,
                            ix: i,
                        });
                    }
                }
                );
            }
            ,
        };
    }

    static _pGetDereferenced_doDereference_getToReplaceMeta(toReplaceMetaRaw) {
        if (toReplaceMetaRaw.string == null)
            return toReplaceMetaRaw;

        const str = toReplaceMetaRaw.string;
        delete toReplaceMetaRaw.string;
        return {
            ...toReplaceMetaRaw,
            ...Renderer.hover.getRefMetaFromTag(str)
        };
    }

    static _pGetDereferenced_doNotifyFailed({entriesWithRefs, entities}) {
        const entriesWithRefsVals = Object.values(entriesWithRefs).map(hashToEntry=>Object.values(hashToEntry)).flat();

        if (!entriesWithRefsVals.length)
            return;

        const missingRefSets = {};
        this._WALKER_READ.walk(entriesWithRefsVals, {
            object: (obj)=>{
                switch (obj.type) {
                case "refClassFeature":
                    (missingRefSets["classFeature"] = missingRefSets["classFeature"] || new Set()).add(obj.classFeature);
                    break;
                case "refSubclassFeature":
                    (missingRefSets["subclassFeature"] = missingRefSets["subclassFeature"] || new Set()).add(obj.subclassFeature);
                    break;
                case "refOptionalfeature":
                    (missingRefSets["optionalfeature"] = missingRefSets["optionalfeature"] || new Set()).add(obj.optionalfeature);
                    break;
                case "refItemEntry":
                    (missingRefSets["itemEntry"] = missingRefSets["itemEntry"] || new Set()).add(obj.itemEntry);
                    break;
                }
            }
            ,
        }, );

        _DataLoaderInternalUtil.doNotifyFailedDereferences({
            missingRefSets,
            diagnostics: entities.map(ent=>ent.__diagnostic).filter(Boolean),
        });
    }

    static _pGetDereferenced_doPopulateOutput({isOverwrite, out, entriesWithoutRefs, entriesWithRefs}) {
        [...Object.entries(entriesWithoutRefs), ...Object.entries(entriesWithRefs), ].forEach(([page,hashToEnt])=>{
            Object.entries(hashToEnt).forEach(([hash,ent])=>{
                if (!isOverwrite && DataLoader.getFromCache(page, ent.source, hash))
                    return;
                (out[page] = out[page] || []).push(ent);
            }
            );
        }
        );
    }
}

class _DataLoaderCache {
    static _PARTITION_UNKNOWN = 0;
    static _PARTITION_SITE = 1;
    static _PARTITION_PRERELEASE = 2;
    static _PARTITION_BREW = 3;

    _cache = {};
    _cacheSiteLists = {};
    _cachePrereleaseLists = {};
    _cacheBrewLists = {};

    get(pageClean, sourceClean, hashClean) {
        return this._cache[pageClean]?.[sourceClean]?.[hashClean];
    }

    getAllSite(pageClean) {
        return Object.values(this._cacheSiteLists[pageClean] || {});
    }

    getAllPrerelease(pageClean) {
        return Object.values(this._cachePrereleaseLists[pageClean] || {});
    }

    getAllBrew(pageClean) {
        return Object.values(this._cacheBrewLists[pageClean] || {});
    }

    set(pageClean, sourceClean, hashClean, ent) {
        let pageCache = this._cache[pageClean];
        if (!pageCache) {
            pageCache = {};
            this._cache[pageClean] = pageCache;
        }

        let sourceCache = pageCache[sourceClean];
        if (!sourceCache) {
            sourceCache = {};
            pageCache[sourceClean] = sourceCache;
        }

        sourceCache[hashClean] = ent;

        if (ent === _DataLoaderConst.ENTITY_NULL)
            return;

        switch (this._set_getPartition(ent)) {
        case this.constructor._PARTITION_SITE:
            {
                return this._set_addToPartition({
                    cache: this._cacheSiteLists,
                    pageClean,
                    hashClean,
                    ent,
                });
            }

        case this.constructor._PARTITION_PRERELEASE:
            {
                return this._set_addToPartition({
                    cache: this._cachePrereleaseLists,
                    pageClean,
                    hashClean,
                    ent,
                });
            }

        case this.constructor._PARTITION_BREW:
            {
                return this._set_addToPartition({
                    cache: this._cacheBrewLists,
                    pageClean,
                    hashClean,
                    ent,
                });
            }

        }
    }

    _set_getPartition(ent) {
        if (ent.adventure)
            return this._set_getPartition_fromSource(SourceUtil.getEntitySource(ent.adventure));
        if (ent.book)
            return this._set_getPartition_fromSource(SourceUtil.getEntitySource(ent.book));

        if (ent.__prop !== "item" || ent._category !== "Specific Variant")
            return this._set_getPartition_fromSource(SourceUtil.getEntitySource(ent));

        const entitySource = SourceUtil.getEntitySource(ent);
        const partitionBaseitem = this._set_getPartition_fromSource(entitySource);
        const partitionMagicvariant = this._set_getPartition_fromSource(ent._baseSource ?? entitySource);

        if (partitionBaseitem === partitionMagicvariant && partitionBaseitem === this.constructor._PARTITION_SITE)
            return this.constructor._PARTITION_SITE;
        if (partitionBaseitem === this.constructor._PARTITION_BREW || partitionMagicvariant === this.constructor._PARTITION_BREW)
            return this.constructor._PARTITION_BREW;
        return this.constructor._PARTITION_PRERELEASE;
    }

    _set_getPartition_fromSource(partitionSource) {
        if (SourceUtil.isSiteSource(partitionSource))
            return this.constructor._PARTITION_SITE;
        if (PrereleaseUtil.hasSourceJson(partitionSource))
            return this.constructor._PARTITION_PRERELEASE;
        if (BrewUtil2.hasSourceJson(partitionSource))
            return this.constructor._PARTITION_BREW;
        return this.constructor._PARTITION_UNKNOWN;
    }

    _set_addToPartition({cache, pageClean, hashClean, ent}) {
        let siteListCache = cache[pageClean];
        if (!siteListCache) {
            siteListCache = {};
            cache[pageClean] = siteListCache;
        }
        siteListCache[hashClean] = ent;
    }
}

class _DataTypeLoader {
    static PROPS = [];
    static PAGE = null;
    static IS_FLUFF = false;

    static register({fnRegister}) {
        fnRegister({
            loader: new this(),
            props: this.PROPS,
            page: this.PAGE,
            isFluff: this.IS_FLUFF,
        });
    }

    static _getAsRawPrefixed(json, {propsRaw}) {
        return {
            ...propsRaw.mergeMap(prop=>({
                [`raw_${prop}`]: json[prop]
            })),
        };
    }

    phase1CachePropAllowlist;

    phase2CachePropAllowlist;

    hasPhase2Cache = false;

    _cache_pSiteData = {};
    _cache_pPostCaches = {};

    _getSiteIdent({pageClean, sourceClean}) {
        throw new Error("Unimplemented!");
    }

    _isPrereleaseAvailable() {
        return typeof PrereleaseUtil !== "undefined";
    }

    _isBrewAvailable() {
        return typeof BrewUtil2 !== "undefined";
    }

    async _pPrePopulate({data, isPrerelease, isBrew}) {}

    async pGetSiteData({pageClean, sourceClean}) {
        const propCache = this._getSiteIdent({
            pageClean,
            sourceClean
        });
        this._cache_pSiteData[propCache] = this._cache_pSiteData[propCache] || this._pGetSiteData({
            pageClean,
            sourceClean
        });
        return this._cache_pSiteData[propCache];
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        throw new Error("Unimplemented!");
    }

    async pGetStoredPrereleaseData() {
        if (!this._isPrereleaseAvailable())
            return {};
        return this._pGetStoredPrereleaseData();
    }

    async pGetStoredBrewData() {
        if (!this._isBrewAvailable())
            return {};
        return this._pGetStoredBrewData();
    }

    async _pGetStoredPrereleaseData() {
        return this._pGetStoredPrereleaseBrewData({
            brewUtil: PrereleaseUtil,
            isPrerelease: true
        });
    }

    async _pGetStoredBrewData() {
        return this._pGetStoredPrereleaseBrewData({
            brewUtil: BrewUtil2,
            isBrew: true
        });
    }

    async _pGetStoredPrereleaseBrewData({brewUtil, isPrerelease, isBrew}) {
        const prereleaseBrewData = await brewUtil.pGetBrewProcessed();
        await this._pPrePopulate({
            data: prereleaseBrewData,
            isPrerelease,
            isBrew
        });
        return prereleaseBrewData;
    }

    async pGetPostCacheData({siteData=null, prereleaseData=null, brewData=null, lockToken2}) {}

    async _pGetPostCacheData_obj_withCache({obj, propCache, lockToken2}) {
        this._cache_pPostCaches[propCache] = this._cache_pPostCaches[propCache] || this._pGetPostCacheData_obj({
            obj,
            lockToken2
        });
        return this._cache_pPostCaches[propCache];
    }

    async _pGetPostCacheData_obj({obj, lockToken2}) {
        throw new Error("Unimplemented!");
    }

    hasCustomCacheStrategy({obj}) {
        return false;
    }

    addToCacheCustom({cache, obj}) {}
}

class _DataTypeLoaderSingleSource extends _DataTypeLoader {
    _filename;

    _getSiteIdent({pageClean, sourceClean}) {
        return this._filename;
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        return DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${this._filename}`);
    }
}

class _DataTypeLoaderBackground extends _DataTypeLoaderSingleSource {
    static PROPS = ["background"];
    static PAGE = UrlUtil.PG_BACKGROUNDS;

    _filename = "backgrounds.json";
}

class _DataTypeLoaderPsionic extends _DataTypeLoaderSingleSource {
    static PROPS = ["psionic"];
    static PAGE = UrlUtil.PG_PSIONICS;

    _filename = "psionics.json";
}

class _DataTypeLoaderObject extends _DataTypeLoaderSingleSource {
    static PROPS = ["object"];
    static PAGE = UrlUtil.PG_OBJECTS;

    _filename = "objects.json";
}

class _DataTypeLoaderAction extends _DataTypeLoaderSingleSource {
    static PROPS = ["action"];
    static PAGE = UrlUtil.PG_ACTIONS;

    _filename = "actions.json";
}

class _DataTypeLoaderFeat extends _DataTypeLoaderSingleSource {
    static PROPS = ["feat"];
    static PAGE = UrlUtil.PG_FEATS;

    _filename = "feats.json";
}

class _DataTypeLoaderOptionalfeature extends _DataTypeLoaderSingleSource {
    static PROPS = ["optionalfeature"];
    static PAGE = UrlUtil.PG_OPT_FEATURES;

    _filename = "optionalfeatures.json";
}

class _DataTypeLoaderReward extends _DataTypeLoaderSingleSource {
    static PROPS = ["reward"];
    static PAGE = UrlUtil.PG_REWARDS;

    _filename = "rewards.json";
}

class _DataTypeLoaderCharoption extends _DataTypeLoaderSingleSource {
    static PROPS = ["charoption"];
    static PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;

    _filename = "charcreationoptions.json";
}

class _DataTypeLoaderTrapHazard extends _DataTypeLoaderSingleSource {
    static PROPS = ["trap", "hazard"];
    static PAGE = UrlUtil.PG_TRAPS_HAZARDS;

    _filename = "trapshazards.json";
}

class _DataTypeLoaderCultBoon extends _DataTypeLoaderSingleSource {
    static PROPS = ["cult", "boon"];
    static PAGE = UrlUtil.PG_CULTS_BOONS;

    _filename = "cultsboons.json";
}

class _DataTypeLoaderVehicle extends _DataTypeLoaderSingleSource {
    static PROPS = ["vehicle", "vehicleUpgrade"];
    static PAGE = UrlUtil.PG_VEHICLES;

    _filename = "vehicles.json";
}

class _DataTypeLoaderConditionDisease extends _DataTypeLoaderSingleSource {
    static PROPS = ["condition", "disease", "status"];
    static PAGE = UrlUtil.PG_CONDITIONS_DISEASES;

    _filename = "conditionsdiseases.json";
}

class _DataTypeLoaderSkill extends _DataTypeLoaderSingleSource {
    static PROPS = ["skill"];

    _filename = "skills.json";
}

class _DataTypeLoaderSense extends _DataTypeLoaderSingleSource {
    static PROPS = ["sense"];

    _filename = "senses.json";
}

class _DataTypeLoaderLegendaryGroup extends _DataTypeLoaderSingleSource {
    static PROPS = ["legendaryGroup"];

    _filename = "bestiary/legendarygroups.json";
}

class _DataTypeLoaderItemEntry extends _DataTypeLoaderSingleSource {
    static PROPS = ["itemEntry"];

    _filename = "items-base.json";
}

class _DataTypeLoaderItemMastery extends _DataTypeLoaderSingleSource {
    static PROPS = ["itemMastery"];

    _filename = "items-base.json";

    async _pPrePopulate({data, isPrerelease, isBrew}) {
        await Renderer.item.pGetSiteUnresolvedRefItems();
        Renderer.item.addPrereleaseBrewPropertiesAndTypesFrom({
            data
        });
    }
}

class _DataTypeLoaderBackgroundFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["backgroundFluff"];
    static PAGE = UrlUtil.PG_BACKGROUNDS;
    static IS_FLUFF = true;

    _filename = "fluff-backgrounds.json";
}

class _DataTypeLoaderFeatFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["featFluff"];
    static PAGE = UrlUtil.PG_FEATS;
    static IS_FLUFF = true;

    _filename = "fluff-feats.json";
}

class _DataTypeLoaderItemFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["itemFluff"];
    static PAGE = UrlUtil.PG_ITEMS;
    static IS_FLUFF = true;

    _filename = "fluff-items.json";
}

class _DataTypeLoaderRaceFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["raceFluff"];
    static PAGE = UrlUtil.PG_RACES;
    static IS_FLUFF = true;

    _filename = "fluff-races.json";
}

class _DataTypeLoaderLanguageFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["languageFluff"];
    static PAGE = UrlUtil.PG_LANGUAGES;
    static IS_FLUFF = true;

    _filename = "fluff-languages.json";
}

class _DataTypeLoaderVehicleFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["vehicleFluff"];
    static PAGE = UrlUtil.PG_VEHICLES;
    static IS_FLUFF = true;

    _filename = "fluff-vehicles.json";
}

class _DataTypeLoaderObjectFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["objectFluff"];
    static PAGE = UrlUtil.PG_OBJECTS;
    static IS_FLUFF = true;

    _filename = "fluff-objects.json";
}

class _DataTypeLoaderCharoptionFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["charoptionFluff"];
    static PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;
    static IS_FLUFF = true;

    _filename = "fluff-charcreationoptions.json";
}

class _DataTypeLoaderRecipeFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["recipeFluff"];
    static PAGE = UrlUtil.PG_RECIPES;
    static IS_FLUFF = true;

    _filename = "fluff-recipes.json";
}

class _DataTypeLoaderConditionDiseaseFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["conditionFluff", "diseaseFluff", "statusFluff"];
    static PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
    static IS_FLUFF = true;

    _filename = "fluff-conditionsdiseases.json";
}

class _DataTypeLoaderTrapHazardFluff extends _DataTypeLoaderSingleSource {
    static PROPS = ["trapFluff", "hazardFluff"];
    static PAGE = UrlUtil.PG_TRAPS_HAZARDS;
    static IS_FLUFF = true;

    _filename = "fluff-trapshazards.json";
}

class _DataTypeLoaderPredefined extends _DataTypeLoader {
    _loader;
    _loadJsonArgs = null;
    _loadPrereleaseArgs = null;
    _loadBrewArgs = null;

    _getSiteIdent({pageClean, sourceClean}) {
        return this._loader;
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        return DataUtil[this._loader].loadJSON(this._loadJsonArgs);
    }

    async _pGetStoredPrereleaseData() {
        if (!DataUtil[this._loader].loadPrerelease)
            return super._pGetStoredPrereleaseData();
        return DataUtil[this._loader].loadPrerelease(this._loadPrereleaseArgs);
    }

    async _pGetStoredBrewData() {
        if (!DataUtil[this._loader].loadBrew)
            return super._pGetStoredBrewData();
        return DataUtil[this._loader].loadBrew(this._loadBrewArgs);
    }
}

class _DataTypeLoaderRace extends _DataTypeLoaderPredefined {
    static PROPS = [...UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_RACES]];
    static PAGE = UrlUtil.PG_RACES;

    _loader = "race";
    _loadJsonArgs = {
        isAddBaseRaces: true
    };
    _loadPrereleaseArgs = {
        isAddBaseRaces: true
    };
    _loadBrewArgs = {
        isAddBaseRaces: true
    };
}

class _DataTypeLoaderDeity extends _DataTypeLoaderPredefined {
    static PROPS = ["deity"];
    static PAGE = UrlUtil.PG_DEITIES;

    _loader = "deity";
}

class _DataTypeLoaderVariantrule extends _DataTypeLoaderPredefined {
    static PROPS = ["variantrule"];
    static PAGE = UrlUtil.PG_VARIANTRULES;

    _loader = "variantrule";
}

class _DataTypeLoaderTable extends _DataTypeLoaderPredefined {
    static PROPS = ["table", "tableGroup"];
    static PAGE = UrlUtil.PG_TABLES;

    _loader = "table";
}

class _DataTypeLoaderLanguage extends _DataTypeLoaderPredefined {
    static PROPS = ["language"];
    static PAGE = UrlUtil.PG_LANGUAGES;

    _loader = "language";
}

class _DataTypeLoaderRecipe extends _DataTypeLoaderPredefined {
    static PROPS = ["recipe"];
    static PAGE = UrlUtil.PG_RECIPES;

    _loader = "recipe";
}

class _DataTypeLoaderMultiSource extends _DataTypeLoader {
    _prop;

    _getSiteIdent({pageClean, sourceClean}) {
        return `${this._prop}__${sourceClean.toString()}`;
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        const data = await this._pGetSiteData_data({
            sourceClean
        });

        if (data == null)
            return {};

        await this._pPrePopulate({
            data
        });

        return data;
    }

    async _pGetSiteData_data({sourceClean}) {
        if (sourceClean === _DataLoaderConst.SOURCE_SITE_ALL)
            return this._pGetSiteDataAll();

        const source = Parser.sourceJsonToJson(sourceClean);
        return DataUtil[this._prop].pLoadSingleSource(source);
    }

    async _pGetSiteDataAll() {
        return DataUtil[this._prop].loadJSON();
    }
}

class _DataTypeLoaderCustomMonster extends _DataTypeLoaderMultiSource {
    static PROPS = ["monster"];
    static PAGE = UrlUtil.PG_BESTIARY;

    _prop = "monster";

    async _pGetSiteData({pageClean, sourceClean}) {
        await DataUtil.monster.pPreloadMeta();
        return super._pGetSiteData({
            pageClean,
            sourceClean
        });
    }

    async _pPrePopulate({data, isPrerelease, isBrew}) {
        DataUtil.monster.populateMetaReference(data);
    }
}

class _DataTypeLoaderCustomMonsterFluff extends _DataTypeLoaderMultiSource {
    static PROPS = ["monsterFluff"];
    static PAGE = UrlUtil.PG_BESTIARY;
    static IS_FLUFF = true;

    _prop = "monsterFluff";
}

class _DataTypeLoaderCustomSpell extends _DataTypeLoaderMultiSource {
    static PROPS = [...UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_SPELLS]];
    static PAGE = UrlUtil.PG_SPELLS;

    _prop = "spell";

    async _pPrePopulate({data, isPrerelease, isBrew}) {
        Renderer.spell.prePopulateHover(data);
        if (isPrerelease)
            Renderer.spell.prePopulateHoverPrerelease(data);
        if (isBrew)
            Renderer.spell.prePopulateHoverBrew(data);
    }
}

class _DataTypeLoaderCustomSpellFluff extends _DataTypeLoaderMultiSource {
    static PROPS = ["spellFluff"];
    static PAGE = UrlUtil.PG_SPELLS;
    static IS_FLUFF = true;

    _prop = "spellFluff";
}

class _DataTypeLoaderCustomRawable extends _DataTypeLoader {
    static _PROPS_RAWABLE;

    hasPhase2Cache = true;

    _getSiteIdent({pageClean, sourceClean}) {
        return `${pageClean}__${this.constructor.name}`;
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        const json = await this._pGetRawSiteData();
        return this.constructor._getAsRawPrefixed(json, {
            propsRaw: this.constructor._PROPS_RAWABLE
        });
    }

    async _pGetRawSiteData() {
        throw new Error("Unimplemented!");
    }

    async _pGetStoredPrereleaseBrewData({brewUtil, isPrerelease, isBrew}) {
        const prereleaseBrew = await brewUtil.pGetBrewProcessed();
        return this.constructor._getAsRawPrefixed(prereleaseBrew, {
            propsRaw: this.constructor._PROPS_RAWABLE
        });
    }

    static _pGetDereferencedData_doNotifyFailed({ent, uids, prop}) {
        const missingRefSets = {
            [prop]: new Set(uids),
        };

        _DataLoaderInternalUtil.doNotifyFailedDereferences({
            missingRefSets,
            diagnostics: [ent.__diagnostic].filter(Boolean),
        });
    }
}

class _DataTypeLoaderCustomClassesSubclass extends _DataTypeLoaderCustomRawable {
    static PROPS = ["raw_class", "raw_subclass", "class", "subclass"];
    static PAGE = UrlUtil.PG_CLASSES;

    static _PROPS_RAWABLE = ["class", "subclass"];

    async _pGetRawSiteData() {
        return DataUtil.class.loadRawJSON();
    }

    async _pGetPostCacheData_obj({obj, lockToken2}) {
        if (!obj)
            return null;

        const out = {};

        if (obj.raw_class?.length)
            out.class = await obj.raw_class.pSerialAwaitMap(cls=>this.constructor._pGetDereferencedClassData(cls, {
                lockToken2
            }));
        if (obj.raw_subclass?.length)
            out.subclass = await obj.raw_subclass.pSerialAwaitMap(sc=>this.constructor._pGetDereferencedSubclassData(sc, {
                lockToken2
            }));

        return out;
    }

    static _mutEntryNestLevel(feature) {
        const depth = (feature.header == null ? 1 : feature.header) - 1;
        for (let i = 0; i < depth; ++i) {
            const nxt = MiscUtil.copyFast(feature);
            feature.entries = [nxt];
            delete feature.name;
            delete feature.page;
            delete feature.source;
        }
    }

    static async _pGetDereferencedClassData(cls, {lockToken2}) {
        if (cls.classFeatures && cls.classFeatures.every(it=>typeof it !== "string" && !it.classFeature))
            return cls;

        cls = MiscUtil.copyFast(cls);

        const byLevel = await this._pGetDereferencedClassSubclassData(cls, {
            lockToken2,
            propFeatures: "classFeatures",
            propFeature: "classFeature",
            fnUnpackUid: DataUtil.class.unpackUidClassFeature.bind(DataUtil.class),
            fnIsInvalidUnpackedUid: ({name, className, level})=>!name || !className || !level || isNaN(level),
        }, );

        cls.classFeatures = [...new Array(Math.max(0, ...Object.keys(byLevel).map(Number)))].map((_,i)=>byLevel[i + 1] || []);

        return cls;
    }

    static async _pGetDereferencedSubclassData(sc, {lockToken2}) {
        if (sc.subclassFeatures && sc.subclassFeatures.every(it=>typeof it !== "string" && !it.subclassFeature))
            return sc;

        sc = MiscUtil.copyFast(sc);

        const byLevel = await this._pGetDereferencedClassSubclassData(sc, {
            lockToken2,
            propFeatures: "subclassFeatures",
            propFeature: "subclassFeature",
            fnUnpackUid: DataUtil.class.unpackUidSubclassFeature.bind(DataUtil.class),
            fnIsInvalidUnpackedUid: ({name, className, subclassShortName, level})=>!name || !className || !subclassShortName || !level || isNaN(level),
        }, );

        sc.subclassFeatures = Object.keys(byLevel).map(Number).sort(SortUtil.ascSort).map(k=>byLevel[k]);

        return sc;
    }

    static async _pGetDereferencedClassSubclassData(clsOrSc, {lockToken2, propFeatures, propFeature, fnUnpackUid, fnIsInvalidUnpackedUid, }, ) {
        if (clsOrSc[propFeatures] && clsOrSc[propFeatures].every(it=>typeof it !== "string" && !it[propFeature]))
            return clsOrSc;

        clsOrSc = MiscUtil.copyFast(clsOrSc);

        const byLevel = {};
        const notFoundUids = [];

        await (clsOrSc[propFeatures] || []).pSerialAwaitMap(async featureRef=>{
            const uid = featureRef[propFeature] ? featureRef[propFeature] : featureRef;
            const unpackedUid = fnUnpackUid(uid);
            const {source, displayText} = unpackedUid;

            if (fnIsInvalidUnpackedUid(unpackedUid))
                return;

            if (source === Parser.SRC_5ETOOLS_TMP)
                return;

            const hash = UrlUtil.URL_TO_HASH_BUILDER[propFeature](unpackedUid);

            if (ExcludeUtil.isInitialised && ExcludeUtil.isExcluded(hash, propFeature, source, {
                isNoCount: true
            }))
                return;

            const feature = await DataLoader.pCacheAndGet(propFeature, source, hash, {
                isCopy: true,
                lockToken2
            });
            if (!feature)
                return notFoundUids.push(uid);

            if (displayText)
                feature._displayName = displayText;
            if (featureRef.tableDisplayName)
                feature._displayNameTable = featureRef.tableDisplayName;

            if (featureRef.gainSubclassFeature)
                feature.gainSubclassFeature = true;
            if (featureRef.gainSubclassFeatureHasContent)
                feature.gainSubclassFeatureHasContent = true;

            if (clsOrSc.otherSources && clsOrSc.source === feature.source)
                feature.otherSources = MiscUtil.copyFast(clsOrSc.otherSources);

            this._mutEntryNestLevel(feature);

            (byLevel[feature.level || 1] = byLevel[feature.level || 1] || []).push(feature);
        }
        );

        this._pGetDereferencedData_doNotifyFailed({
            ent: clsOrSc,
            uids: notFoundUids,
            prop: propFeature
        });

        return byLevel;
    }

    async pGetPostCacheData({siteData=null, prereleaseData=null, brewData=null, lockToken2}) {
        return {
            siteDataPostCache: await this._pGetPostCacheData_obj_withCache({
                obj: siteData,
                lockToken2,
                propCache: "site"
            }),
            prereleaseDataPostCache: await this._pGetPostCacheData_obj({
                obj: prereleaseData,
                lockToken2
            }),
            brewDataPostCache: await this._pGetPostCacheData_obj({
                obj: brewData,
                lockToken2
            }),
        };
    }
}

class _DataTypeLoaderCustomClassSubclassFeature extends _DataTypeLoader {
    static PROPS = ["raw_classFeature", "raw_subclassFeature", "classFeature", "subclassFeature"];
    static PAGE = UrlUtil.PG_CLASS_SUBCLASS_FEATURES;

    static _PROPS_RAWABLE = ["classFeature", "subclassFeature"];

    hasPhase2Cache = true;

    _getSiteIdent({pageClean, sourceClean}) {
        return `${pageClean}__${this.constructor.name}`;
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        const json = await DataUtil.class.loadRawJSON();
        return this.constructor._getAsRawPrefixed(json, {
            propsRaw: this.constructor._PROPS_RAWABLE
        });
    }

    async _pGetStoredPrereleaseBrewData({brewUtil, isPrerelease, isBrew}) {
        const prereleaseBrew = await brewUtil.pGetBrewProcessed();
        return this.constructor._getAsRawPrefixed(prereleaseBrew, {
            propsRaw: this.constructor._PROPS_RAWABLE
        });
    }

    async _pGetPostCacheData_obj({obj, lockToken2}) {
        if (!obj)
            return null;

        const out = {};

        if (obj.raw_classFeature?.length)
            out.classFeature = (await _DataLoaderDereferencer.pGetDereferenced(obj.raw_classFeature, "classFeature"))?.classFeature || [];
        if (obj.raw_subclassFeature?.length)
            out.subclassFeature = (await _DataLoaderDereferencer.pGetDereferenced(obj.raw_subclassFeature, "subclassFeature"))?.subclassFeature || [];

        return out;
    }

    async pGetPostCacheData({siteData=null, prereleaseData=null, brewData=null, lockToken2}) {
        return {
            siteDataPostCache: await this._pGetPostCacheData_obj_withCache({
                obj: siteData,
                lockToken2,
                propCache: "site"
            }),
            prereleaseDataPostCache: await this._pGetPostCacheData_obj({
                obj: prereleaseData,
                lockToken2
            }),
            brewDataPostCache: await this._pGetPostCacheData_obj({
                obj: brewData,
                lockToken2
            }),
        };
    }
}

class _DataTypeLoaderCustomItem extends _DataTypeLoader {
    static PROPS = [...UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_ITEMS]];
    static PAGE = UrlUtil.PG_ITEMS;

    phase1CachePropAllowlist = new Set(["itemEntry"]);

    hasPhase2Cache = true;

    _getSiteIdent({pageClean, sourceClean}) {
        return this.constructor.name;
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        return Renderer.item.pGetSiteUnresolvedRefItems();
    }

    async _pGetStoredPrereleaseBrewData({brewUtil, isPrerelease, isBrew}) {
        const prereleaseBrewData = await brewUtil.pGetBrewProcessed();
        await this._pPrePopulate({
            data: prereleaseBrewData,
            isPrerelease,
            isBrew
        });
        return {
            item: await Renderer.item.pGetSiteUnresolvedRefItemsFromPrereleaseBrew({
                brewUtil,
                brew: prereleaseBrewData
            }),
            itemEntry: prereleaseBrewData.itemEntry || [],
        };
    }

    async _pPrePopulate({data, isPrerelease, isBrew}) {
        Renderer.item.addPrereleaseBrewPropertiesAndTypesFrom({
            data
        });
    }

    async _pGetPostCacheData_obj({siteData, obj, lockToken2}) {
        if (!obj)
            return null;

        const out = {};

        if (obj.item?.length) {
            out.item = (await _DataLoaderDereferencer.pGetDereferenced(obj.item, "item", {
                propEntries: "entries",
                propIsRef: "hasRefs"
            }))?.item || [];
            out.item = (await _DataLoaderDereferencer.pGetDereferenced(out.item, "item", {
                propEntries: "_fullEntries",
                propIsRef: "hasRefs"
            }))?.item || [];
        }

        return out;
    }

    async pGetPostCacheData({siteData=null, prereleaseData=null, brewData=null, lockToken2}) {
        return {
            siteDataPostCache: await this._pGetPostCacheData_obj_withCache({
                obj: siteData,
                lockToken2,
                propCache: "site"
            }),
            prereleaseDataPostCache: await this._pGetPostCacheData_obj({
                obj: prereleaseData,
                lockToken2
            }),
            brewDataPostCache: await this._pGetPostCacheData_obj({
                obj: brewData,
                lockToken2
            }),
        };
    }
}

class _DataTypeLoaderCustomCard extends _DataTypeLoader {
    static PROPS = ["card"];
    static PAGE = UrlUtil.PG_DECKS;

    _getSiteIdent({pageClean, sourceClean}) {
        return `${pageClean}__${this.constructor.name}`;
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        const json = await DataUtil.deck.loadRawJSON();
        return {
            card: json.card
        };
    }
}

class _DataTypeLoaderCustomDeck extends _DataTypeLoaderCustomRawable {
    static PROPS = ["raw_deck", "deck"];
    static PAGE = UrlUtil.PG_DECKS;

    static _PROPS_RAWABLE = ["deck"];

    async _pGetRawSiteData() {
        return DataUtil.deck.loadRawJSON();
    }

    async _pGetPostCacheData_obj({obj, lockToken2}) {
        if (!obj)
            return null;

        const out = {};

        if (obj.raw_deck?.length)
            out.deck = await obj.raw_deck.pSerialAwaitMap(ent=>this.constructor._pGetDereferencedDeckData(ent, {
                lockToken2
            }));

        return out;
    }

    static async _pGetDereferencedDeckData(deck, {lockToken2}) {
        deck = MiscUtil.copyFast(deck);

        deck.cards = await this._pGetDereferencedCardData(deck, {
            lockToken2
        });

        return deck;
    }

    static async _pGetDereferencedCardData(deck, {lockToken2}) {
        const notFoundUids = [];

        const out = (await (deck.cards || []).pSerialAwaitMap(async cardMeta=>{
            const uid = typeof cardMeta === "string" ? cardMeta : cardMeta.uid;
            const count = typeof cardMeta === "string" ? 1 : cardMeta.count ?? 1;
            const isReplacement = typeof cardMeta === "string" ? false : cardMeta.replacement ?? false;

            const unpackedUid = DataUtil.deck.unpackUidCard(uid);
            const {source} = unpackedUid;

            if (unpackedUid.name == null || unpackedUid.set == null || unpackedUid.source == null)
                return;

            const hash = UrlUtil.URL_TO_HASH_BUILDER["card"](unpackedUid);

            if (ExcludeUtil.isInitialised && ExcludeUtil.isExcluded(hash, "card", source, {
                isNoCount: true
            }))
                return;

            const card = await DataLoader.pCacheAndGet("card", source, hash, {
                isCopy: true,
                lockToken2
            });
            if (!card)
                return notFoundUids.push(uid);

            if (deck.otherSources && deck.source === card.source)
                card.otherSources = MiscUtil.copyFast(deck.otherSources);
            if (isReplacement)
                card._isReplacement = true;

            return [...new Array(count)].map(()=>MiscUtil.copyFast(card));
        }
        )).flat().filter(Boolean);

        this._pGetDereferencedData_doNotifyFailed({
            ent: deck,
            uids: notFoundUids,
            prop: "card"
        });

        return out;
    }

    async pGetPostCacheData({siteData=null, prereleaseData=null, brewData=null, lockToken2}) {
        return {
            siteDataPostCache: await this._pGetPostCacheData_obj_withCache({
                obj: siteData,
                lockToken2,
                propCache: "site"
            }),
            prereleaseDataPostCache: await this._pGetPostCacheData_obj({
                obj: prereleaseData,
                lockToken2
            }),
            brewDataPostCache: await this._pGetPostCacheData_obj({
                obj: brewData,
                lockToken2
            }),
        };
    }
}

class _DataTypeLoaderCustomQuickref extends _DataTypeLoader {
    static PROPS = ["reference", "referenceData"];
    static PAGE = UrlUtil.PG_QUICKREF;

    _getSiteIdent({pageClean, sourceClean}) {
        return this.constructor.name;
    }

    _isPrereleaseAvailable() {
        return false;
    }

    _isBrewAvailable() {
        return false;
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        const json = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/bookref-quick.json`);
        return {
            reference: json.reference["bookref-quick"],
            referenceData: json.data["bookref-quick"],
        };
    }

    hasCustomCacheStrategy({obj}) {
        return this.constructor.PROPS.some(prop=>obj[prop]?.length);
    }

    addToCacheCustom({cache, obj}) {
        obj.referenceData.forEach((chapter,ixChapter)=>this._addToCacheCustom_chapter({
            cache,
            chapter,
            ixChapter
        }));
        return [...this.constructor.PROPS];
    }

    _addToCacheCustom_chapter({cache, chapter, ixChapter}) {
        const metas = IndexableFileQuickReference.getChapterNameMetas(chapter, {
            isRequireQuickrefFlag: false
        });

        metas.forEach(nameMeta=>{
            const hashParts = ["bookref-quick", ixChapter, UrlUtil.encodeForHash(nameMeta.name.toLowerCase()), ];
            if (nameMeta.ixBook)
                hashParts.push(nameMeta.ixBook);

            const hash = hashParts.join(HASH_PART_SEP);

            const {page: pageClean, source: sourceClean, hash: hashClean} = _DataLoaderInternalUtil.getCleanPageSourceHash({
                page: UrlUtil.PG_QUICKREF,
                source: nameMeta.source,
                hash,
            });
            cache.set(pageClean, sourceClean, hashClean, nameMeta.entry);

            if (nameMeta.ixBook)
                return;

            hashParts.push(nameMeta.ixBook);
            const hashAlt = hashParts.join(HASH_PART_SEP);
            const hashAltClean = _DataLoaderInternalUtil.getCleanHash({
                hash: hashAlt
            });
            cache.set(pageClean, sourceClean, hashAltClean, nameMeta.entry);
        }
        );
    }
}

class _DataTypeLoaderCustomAdventureBook extends _DataTypeLoader {
    _filename;

    _getSiteIdent({pageClean, sourceClean}) {
        return `${pageClean}__${sourceClean}`;
    }

    hasCustomCacheStrategy({obj}) {
        return this.constructor.PROPS.some(prop=>obj[prop]?.length);
    }

    addToCacheCustom({cache, obj}) {
        const [prop,propData] = this.constructor.PROPS;

        const dataIds = (obj[propData] || []).filter(it=>it.id).map(it=>it.id);
        const contentsIds = new Set((obj[prop] || []).filter(it=>it.id).map(it=>it.id));
        const matchingIds = dataIds.filter(id=>contentsIds.has(id));

        matchingIds.forEach(id=>{
            const data = (obj[propData] || []).find(it=>it.id === id);
            const contents = (obj[prop] || []).find(it=>it.id === id);

            const hash = UrlUtil.URL_TO_HASH_BUILDER[this.constructor.PAGE](contents);
            this._addImageBackReferences(data, this.constructor.PAGE, contents.source, hash);

            const {page: pageClean, source: sourceClean, hash: hashClean} = _DataLoaderInternalUtil.getCleanPageSourceHash({
                page: this.constructor.PAGE,
                source: contents.source,
                hash,
            });

            const pack = {
                [prop]: contents,
                [propData]: data,
            };

            cache.set(pageClean, sourceClean, hashClean, pack);
        }
        );

        return [prop, propData];
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        const [prop,propData] = this.constructor.PROPS;

        const index = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${this._filename}`);
        const contents = index[prop].find(contents=>_DataLoaderInternalUtil.getCleanSource({
            source: contents.source
        }) === sourceClean);

        if (!contents)
            return {};

        const json = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${prop}/${prop}-${UrlUtil.encodeForHash(contents.id.toLowerCase())}.json`);

        return {
            [prop]: [contents],
            [propData]: [{
                source: contents.source,
                id: contents.id,
                ...json,
            }, ],
        };
    }

    _addImageBackReferences(json, page, source, hash) {
        if (!json)
            return;

        const walker = MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
            isNoModification: true
        });
        walker.walk(json, {
            object: (obj)=>{
                if (obj.type === "image" && obj.mapRegions) {
                    obj.page = obj.page || page;
                    obj.source = obj.source || source;
                    obj.hash = obj.hash || hash;
                }
            }
            ,
        }, );
    }
}

class _DataTypeLoaderCustomAdventure extends _DataTypeLoaderCustomAdventureBook {
    static PROPS = ["adventure", "adventureData"];
    static PAGE = UrlUtil.PG_ADVENTURE;

    _filename = "adventures.json";
}

class _DataTypeLoaderCustomBook extends _DataTypeLoaderCustomAdventureBook {
    static PROPS = ["book", "bookData"];
    static PAGE = UrlUtil.PG_BOOK;

    _filename = "books.json";
}

class _DataTypeLoaderCitation extends _DataTypeLoader {
    static PROPS = ["citation"];

    _getSiteIdent({pageClean, sourceClean}) {
        return this.constructor.name;
    }

    async _pGetSiteData({pageClean, sourceClean}) {
        return {
            citation: []
        };
    }
}

class DataLoader {
    static _PROP_TO_HASH_PAGE = {
        "monster": UrlUtil.PG_BESTIARY,
        "spell": UrlUtil.PG_SPELLS,
        "class": UrlUtil.PG_CLASSES,
        "subclass": UrlUtil.PG_CLASSES,
        "item": UrlUtil.PG_ITEMS,
        "background": UrlUtil.PG_BACKGROUNDS,
        "psionic": UrlUtil.PG_PSIONICS,
        "object": UrlUtil.PG_OBJECTS,
        "action": UrlUtil.PG_ACTIONS,
        "trap": UrlUtil.PG_TRAPS_HAZARDS,
        "hazard": UrlUtil.PG_TRAPS_HAZARDS,
        "cult": UrlUtil.PG_CULTS_BOONS,
        "boon": UrlUtil.PG_CULTS_BOONS,
        "condition": UrlUtil.PG_CONDITIONS_DISEASES,
        "deck": UrlUtil.PG_DECKS,
        "disease": UrlUtil.PG_CONDITIONS_DISEASES,
        "status": UrlUtil.PG_CONDITIONS_DISEASES,
        "vehicle": UrlUtil.PG_VEHICLES,
        "vehicleUpgrade": UrlUtil.PG_VEHICLES,
        "feat": UrlUtil.PG_FEATS,
        "optionalfeature": UrlUtil.PG_OPT_FEATURES,
        "reward": UrlUtil.PG_REWARDS,
        "charoption": UrlUtil.PG_CHAR_CREATION_OPTIONS,
        "race": UrlUtil.PG_RACES,
        "subrace": UrlUtil.PG_RACES,
        "deity": UrlUtil.PG_DEITIES,
        "variantrule": UrlUtil.PG_VARIANTRULES,
        "table": UrlUtil.PG_TABLES,
        "tableGroup": UrlUtil.PG_TABLES,
        "language": UrlUtil.PG_LANGUAGES,
        "recipe": UrlUtil.PG_RECIPES,
        "classFeature": UrlUtil.PG_CLASS_SUBCLASS_FEATURES,
        "subclassFeature": UrlUtil.PG_CLASS_SUBCLASS_FEATURES,
        "reference": UrlUtil.PG_QUICKREF,
        "referenceData": UrlUtil.PG_QUICKREF,
        "adventure": UrlUtil.PG_ADVENTURE,
        "adventureData": UrlUtil.PG_ADVENTURE,
        "book": UrlUtil.PG_BOOK,
        "bookData": UrlUtil.PG_BOOK,
    };

    static _DATA_TYPE_LOADERS = {};
    static _DATA_TYPE_LOADER_LIST = [];

    static _init() {
        this._registerPropToHashPages();
        this._registerDataTypeLoaders();
        return null;
    }

    static _registerPropToHashPages() {
        Object.entries(this._PROP_TO_HASH_PAGE).forEach(([k,v])=>this._PROP_TO_HASH_PAGE[`${k}Fluff`] = _DataLoaderInternalUtil.getCleanPageFluff({
            page: v
        }));
    }

    static _registerDataTypeLoader({loader, props, page, isFluff}) {
        this._DATA_TYPE_LOADER_LIST.push(loader);

        if (!props?.length)
            throw new Error(`No "props" specified for loader "${loader.constructor.name}"!`);

        props.forEach(prop=>this._DATA_TYPE_LOADERS[_DataLoaderInternalUtil.getCleanPage({
            page: prop
        })] = loader);

        if (!page)
            return;

        this._DATA_TYPE_LOADERS[isFluff ? _DataLoaderInternalUtil.getCleanPageFluff({
            page
        }) : _DataLoaderInternalUtil.getCleanPage({
            page
        })] = loader;
    }

    static _registerDataTypeLoaders() {
        const fnRegister = this._registerDataTypeLoader.bind(this);

        _DataTypeLoaderCustomMonster.register({
            fnRegister
        });
        _DataTypeLoaderCustomMonsterFluff.register({
            fnRegister
        });
        _DataTypeLoaderCustomSpell.register({
            fnRegister
        });
        _DataTypeLoaderCustomSpellFluff.register({
            fnRegister
        });

        _DataTypeLoaderRace.register({
            fnRegister
        });
        _DataTypeLoaderDeity.register({
            fnRegister
        });
        _DataTypeLoaderVariantrule.register({
            fnRegister
        });
        _DataTypeLoaderTable.register({
            fnRegister
        });
        _DataTypeLoaderLanguage.register({
            fnRegister
        });
        _DataTypeLoaderRecipe.register({
            fnRegister
        });

        _DataTypeLoaderCustomClassesSubclass.register({
            fnRegister
        });
        _DataTypeLoaderCustomClassSubclassFeature.register({
            fnRegister
        });
        _DataTypeLoaderCustomItem.register({
            fnRegister
        });
        _DataTypeLoaderCustomCard.register({
            fnRegister
        });
        _DataTypeLoaderCustomDeck.register({
            fnRegister
        });
        _DataTypeLoaderCustomQuickref.register({
            fnRegister
        });
        _DataTypeLoaderCustomAdventure.register({
            fnRegister
        });
        _DataTypeLoaderCustomBook.register({
            fnRegister
        });

        _DataTypeLoaderBackground.register({
            fnRegister
        });
        _DataTypeLoaderPsionic.register({
            fnRegister
        });
        _DataTypeLoaderObject.register({
            fnRegister
        });
        _DataTypeLoaderAction.register({
            fnRegister
        });
        _DataTypeLoaderFeat.register({
            fnRegister
        });
        _DataTypeLoaderOptionalfeature.register({
            fnRegister
        });
        _DataTypeLoaderReward.register({
            fnRegister
        });
        _DataTypeLoaderCharoption.register({
            fnRegister
        });

        _DataTypeLoaderTrapHazard.register({
            fnRegister
        });
        _DataTypeLoaderCultBoon.register({
            fnRegister
        });
        _DataTypeLoaderVehicle.register({
            fnRegister
        });

        _DataTypeLoaderConditionDisease.register({
            fnRegister
        });

        _DataTypeLoaderSkill.register({
            fnRegister
        });
        _DataTypeLoaderSense.register({
            fnRegister
        });
        _DataTypeLoaderLegendaryGroup.register({
            fnRegister
        });
        _DataTypeLoaderItemEntry.register({
            fnRegister
        });
        _DataTypeLoaderItemMastery.register({
            fnRegister
        });
        _DataTypeLoaderCitation.register({
            fnRegister
        });

        _DataTypeLoaderBackgroundFluff.register({
            fnRegister
        });
        _DataTypeLoaderFeatFluff.register({
            fnRegister
        });
        _DataTypeLoaderItemFluff.register({
            fnRegister
        });
        _DataTypeLoaderRaceFluff.register({
            fnRegister
        });
        _DataTypeLoaderLanguageFluff.register({
            fnRegister
        });
        _DataTypeLoaderVehicleFluff.register({
            fnRegister
        });
        _DataTypeLoaderObjectFluff.register({
            fnRegister
        });
        _DataTypeLoaderCharoptionFluff.register({
            fnRegister
        });
        _DataTypeLoaderRecipeFluff.register({
            fnRegister
        });

        _DataTypeLoaderConditionDiseaseFluff.register({
            fnRegister
        });
        _DataTypeLoaderTrapHazardFluff.register({
            fnRegister
        });
    }

    static _ = this._init();

    static _CACHE = new _DataLoaderCache();
    static _LOCK_1 = new VeLock({
        isDbg: false,
        name: "loader-lock-1"
    });
    static _LOCK_2 = new VeLock({
        isDbg: false,
        name: "loader-lock-2"
    });

    static getFromCache(page, source, hash, {isCopy=false, isRequired=false, _isReturnSentinel=false, _isInsertSentinelOnMiss=false, }={}, ) {
        const {page: pageClean, source: sourceClean, hash: hashClean} = _DataLoaderInternalUtil.getCleanPageSourceHash({
            page,
            source,
            hash
        });
        const ent = this._getFromCache({
            pageClean,
            sourceClean,
            hashClean,
            isCopy,
            _isReturnSentinel,
            _isInsertSentinelOnMiss
        });
        return this._getVerifiedRequiredEntity({
            pageClean,
            sourceClean,
            hashClean,
            ent,
            isRequired
        });
    }

    static _getFromCache({pageClean, sourceClean, hashClean, isCopy=false, _isInsertSentinelOnMiss=false, _isReturnSentinel=false, }, ) {
        const out = this._CACHE.get(pageClean, sourceClean, hashClean);

        if (out === _DataLoaderConst.ENTITY_NULL) {
            if (_isReturnSentinel)
                return out;
            if (!_isReturnSentinel)
                return null;
        }

        if (out == null && _isInsertSentinelOnMiss) {
            this._CACHE.set(pageClean, sourceClean, hashClean, _DataLoaderConst.ENTITY_NULL);
        }

        if (!isCopy || out == null)
            return out;
        return MiscUtil.copyFast(out);
    }

    static _getVerifiedRequiredEntity({pageClean, sourceClean, hashClean, ent, isRequired}) {
        if (ent || !isRequired)
            return ent;
        throw new Error(`Could not find entity for page/prop "${pageClean}" with source "${sourceClean}" and hash "${hashClean}"`);
    }

    static async pCacheAndGetAllSite(page, {isSilent=false}={}) {
        const pageClean = _DataLoaderInternalUtil.getCleanPage({
            page
        });

        if (this._PAGES_NO_CONTENT.has(pageClean))
            return null;

        const dataLoader = this._pCache_getDataTypeLoader({
            pageClean,
            isSilent
        });
        if (!dataLoader)
            return null;

        const {siteData} = await this._pCacheAndGet_getCacheMeta({
            pageClean,
            sourceClean: _DataLoaderConst.SOURCE_SITE_ALL,
            dataLoader
        });
        await this._pCacheAndGet_processCacheMeta({
            dataLoader,
            siteData
        });

        return this._CACHE.getAllSite(pageClean);
    }

    static async pCacheAndGetAllPrerelease(page, {isSilent=false}={}) {
        return this._CacheAndGetAllPrerelease.pCacheAndGetAll({
            parent: this,
            page,
            isSilent
        });
    }

    static async pCacheAndGetAllBrew(page, {isSilent=false}={}) {
        return this._CacheAndGetAllBrew.pCacheAndGetAll({
            parent: this,
            page,
            isSilent
        });
    }

    static _CacheAndGetAllPrereleaseBrew = class {
        static _SOURCE_ALL;
        static _PROP_DATA;

        static async pCacheAndGetAll({parent, page, isSilent, }, ) {
            const pageClean = _DataLoaderInternalUtil.getCleanPage({
                page
            });

            if (parent._PAGES_NO_CONTENT.has(pageClean))
                return null;

            const dataLoader = parent._pCache_getDataTypeLoader({
                pageClean,
                isSilent
            });
            if (!dataLoader)
                return null;

            const cacheMeta = await parent._pCacheAndGet_getCacheMeta({
                pageClean,
                sourceClean: this._SOURCE_ALL,
                dataLoader
            });
            await parent._pCacheAndGet_processCacheMeta({
                dataLoader,
                [this._PROP_DATA]: cacheMeta[this._PROP_DATA]
            });

            return this._getAllCached({
                parent,
                pageClean
            });
        }

        static _getAllCached({parent, pageClean}) {
            throw new Error("Unimplemented!");
        }
    }
    ;

    static _CacheAndGetAllPrerelease = class extends this._CacheAndGetAllPrereleaseBrew {
        static _SOURCE_ALL = _DataLoaderConst.SOURCE_PRERELEASE_ALL_CURRENT;
        static _PROP_DATA = "prereleaseData";

        static _getAllCached({parent, pageClean}) {
            return parent._CACHE.getAllPrerelease(pageClean);
        }
    }
    ;

    static _CacheAndGetAllBrew = class extends this._CacheAndGetAllPrereleaseBrew {
        static _SOURCE_ALL = _DataLoaderConst.SOURCE_BREW_ALL_CURRENT;
        static _PROP_DATA = "brewData";

        static _getAllCached({parent, pageClean}) {
            return parent._CACHE.getAllBrew(pageClean);
        }
    }
    ;

    static _PAGES_NO_CONTENT = new Set([_DataLoaderInternalUtil.getCleanPage({
        page: "generic"
    }), _DataLoaderInternalUtil.getCleanPage({
        page: "hover"
    }), ]);

    /**
	 * @param page
	 * @param source
	 * @param hash
	 * @param [isCopy] If a copy, rather than the original entity, should be returned.
	 * @param [isRequired] If an error should be thrown on a missing entity.
	 * @param [isSilent] If errors should not be thrown on a missing implementation.
	 * @param [lockToken2] Post-process lock token for recursive calls.
	 */
    static async pCacheAndGet(page, source, hash, {isCopy=false, isRequired=false, isSilent=false, lockToken2}={}) {
        const fromCache = this.getFromCache(page, source, hash, {
            isCopy,
            _isReturnSentinel: true
        });
        if (fromCache === _DataLoaderConst.ENTITY_NULL)
            return null;
        if (fromCache)
            return fromCache;

        const {page: pageClean, source: sourceClean, hash: hashClean} = _DataLoaderInternalUtil.getCleanPageSourceHash({
            page,
            source,
            hash
        });

        if (this._PAGES_NO_CONTENT.has(pageClean))
            return this._getVerifiedRequiredEntity({
                pageClean,
                sourceClean,
                hashClean,
                ent: null,
                isRequired
            });

        const dataLoader = this._pCache_getDataTypeLoader({ pageClean, isSilent });
        if (!dataLoader)
            return this._getVerifiedRequiredEntity({
                pageClean,
                sourceClean,
                hashClean,
                ent: null,
                isRequired
            });

        const isUnavailablePrerelease = await this._PrereleasePreloader._pPreloadMissing({ parent: this,  sourceClean });
        if (isUnavailablePrerelease)
            return this._getVerifiedRequiredEntity({
                pageClean,
                sourceClean,
                hashClean,
                ent: null,
                isRequired
            });

        const isUnavailableBrew = await this._BrewPreloader._pPreloadMissing({ parent: this, sourceClean });
        if (isUnavailableBrew)
            return this._getVerifiedRequiredEntity({
                pageClean,
                sourceClean,
                hashClean,
                ent: null,
                isRequired
            });

        const {siteData=null, prereleaseData=null, brewData=null}
        = await this._pCacheAndGet_getCacheMeta({ pageClean, sourceClean, dataLoader });

        await this._pCacheAndGet_processCacheMeta({ dataLoader, siteData, prereleaseData, brewData, lockToken2 });

        return this.getFromCache(page, source, hash, { isCopy, _isInsertSentinelOnMiss: true });
    }

    static async pCacheAndGetHash(page, hash, opts) {
        const source = UrlUtil.decodeHash(hash).last();
        return DataLoader.pCacheAndGet(page, source, hash, opts);
    }

    static _PrereleaseBrewPreloader = class {
        static _LOCK_0;
        static _SOURCES_ATTEMPTED;
        static _CACHE_SOURCE_CLEAN_TO_URL;
        static _SOURCE_ALL;

        static async pPreloadMissing({parent, sourceClean}) {
            try {
                await this._LOCK_0.pLock();
                return (await this._pPreloadMissing({
                    parent,
                    sourceClean
                }));
            } finally {
                this._LOCK_0.unlock();
            }
        }

        static async _pPreloadMissing({parent, sourceClean}) {
            if (this._isExistingMiss({
                parent,
                sourceClean
            }))
                return true;

            if (!this._isPossibleSource({
                parent,
                sourceClean
            }))
                return false;
            if (sourceClean === this._SOURCE_ALL)
                return false;

            const brewUtil = this._getBrewUtil();
            if (!brewUtil) {
                this._setExistingMiss({
                    parent,
                    sourceClean
                });
                return true;
            }

            if (brewUtil.hasSourceJson(sourceClean))
                return false;

            const urlBrew = await this._pGetSourceUrl({
                parent,
                sourceClean
            });
            if (!urlBrew) {
                this._setExistingMiss({
                    parent,
                    sourceClean
                });
                return true;
            }

            await brewUtil.pAddBrewFromUrl(urlBrew);
            return false;
        }

        static _isExistingMiss({sourceClean}) {
            return this._SOURCES_ATTEMPTED.has(sourceClean);
        }

        static _setExistingMiss({sourceClean}) {
            this._SOURCES_ATTEMPTED.add(sourceClean);
        }

        static async _pInitCacheSourceToUrl() {
            if (this._CACHE_SOURCE_CLEAN_TO_URL)
                return;

            const index = await this._pGetUrlIndex();
            if (!index)
                return this._CACHE_SOURCE_CLEAN_TO_URL = {};

            const brewUtil = this._getBrewUtil();
            const urlRoot = await brewUtil.pGetCustomUrl();

            this._CACHE_SOURCE_CLEAN_TO_URL = Object.entries(index).mergeMap(([src,url])=>({
                [_DataLoaderInternalUtil.getCleanSource({
                    source: src
                })]: brewUtil.getFileUrl(url, urlRoot)
            }));
        }

        static async _pGetUrlIndex() {
            try {
                return (await this._pGetSourceIndex());
            } catch (e) {
                setTimeout(()=>{
                    throw e;
                }
                );
                return null;
            }
        }

        static async _pGetSourceUrl({sourceClean}) {
            await this._pInitCacheSourceToUrl();
            return this._CACHE_SOURCE_CLEAN_TO_URL[sourceClean];
        }

        static _isPossibleSource({parent, sourceClean}) {
            throw new Error("Unimplemented!");
        }
        static _getBrewUtil() {
            throw new Error("Unimplemented!");
        }
        static _pGetSourceIndex() {
            throw new Error("Unimplemented!");
        }
    }
    ;

    static _PrereleasePreloader = class extends this._PrereleaseBrewPreloader {
        static _LOCK_0 = new VeLock({
            isDbg: false,
            name: "loader-lock-0--prerelease"
        });
        static _SOURCE_ALL = _DataLoaderConst.SOURCE_BREW_ALL_CURRENT;
        static _SOURCES_ATTEMPTED = new Set();
        static _CACHE_SOURCE_CLEAN_TO_URL = null;

        static _isPossibleSource({parent, sourceClean}) {
            return parent._isPrereleaseSource({
                sourceClean
            }) && !Parser.SOURCE_JSON_TO_FULL[Parser.sourceJsonToJson(sourceClean)];
        }
        static _getBrewUtil() {
            return typeof PrereleaseUtil !== "undefined" ? PrereleaseUtil : null;
        }
        static _pGetSourceIndex() {
            return DataUtil.prerelease.pLoadSourceIndex();
        }
    }
    ;

    static _BrewPreloader = class extends this._PrereleaseBrewPreloader {
        static _LOCK_0 = new VeLock({
            isDbg: false,
            name: "loader-lock-0--brew"
        });
        static _SOURCE_ALL = _DataLoaderConst.SOURCE_PRERELEASE_ALL_CURRENT;
        static _SOURCES_ATTEMPTED = new Set();
        static _CACHE_SOURCE_CLEAN_TO_URL = null;

        static _isPossibleSource({parent, sourceClean}) {
            return !parent._isSiteSource({
                sourceClean
            }) && !parent._isPrereleaseSource({
                sourceClean
            });
        }
        static _getBrewUtil() {
            return typeof BrewUtil2 !== "undefined" ? BrewUtil2 : null;
        }
        static _pGetSourceIndex() {
            return DataUtil.brew.pLoadSourceIndex();
        }
    }
    ;

    static async _pCacheAndGet_getCacheMeta({pageClean, sourceClean, dataLoader}) {
        try {
            await this._LOCK_1.pLock();
            return (await this._pCache({ pageClean, sourceClean, dataLoader }));
        }
        finally { this._LOCK_1.unlock(); }
    }

    static async _pCache({pageClean, sourceClean, dataLoader}) {
        //#region Fetch from site data
        const siteData = await dataLoader.pGetSiteData({ pageClean, sourceClean });
        this._pCache_addToCache({ allDataMerged: siteData, propAllowlist: dataLoader.phase1CachePropAllowlist || new Set(dataLoader.constructor.PROPS) });
        // Always early-exit, regardless of whether the entity was found in the cache, if we know this is a site source
        if (this._isSiteSource({ sourceClean })) return { siteData };
        //#endregion

        const out = { siteData };

        //As we have preloaded missing prerelease/brew earlier in the flow, we know that a prerelease/brew is either
		//present, or unavailable
        if (typeof PrereleaseUtil !== "undefined") {
            const prereleaseData = await dataLoader.pGetStoredPrereleaseData();
            this._pCache_addToCache({
                allDataMerged: prereleaseData,
                propAllowlist: dataLoader.phase1CachePropAllowlist || new Set(dataLoader.constructor.PROPS)
            });
            out.prereleaseData = prereleaseData;
        }

        if (typeof BrewUtil2 !== "undefined") {
            const brewData = await dataLoader.pGetStoredBrewData();
            this._pCache_addToCache({
                allDataMerged: brewData,
                propAllowlist: dataLoader.phase1CachePropAllowlist || new Set(dataLoader.constructor.PROPS)
            });
            out.brewData = brewData;
        }

        return out;
    }

    static async _pCacheAndGet_processCacheMeta({dataLoader, siteData=null, prereleaseData=null, brewData=null, lockToken2=null}) {
        if (!dataLoader.hasPhase2Cache){return;}

        try {
            lockToken2 = await this._LOCK_2.pLock({ token: lockToken2 });
            await this._pCacheAndGet_processCacheMeta_({ dataLoader, siteData, prereleaseData, brewData, lockToken2 });
        }
        finally { this._LOCK_2.unlock(); }
    }

    static async _pCacheAndGet_processCacheMeta_({dataLoader, siteData=null, prereleaseData=null, brewData=null, lockToken2=null}) {
        const {siteDataPostCache, prereleaseDataPostCache, brewDataPostCache} = await dataLoader.pGetPostCacheData({
            siteData,
            prereleaseData,
            brewData,
            lockToken2
        });

        this._pCache_addToCache({
            allDataMerged: siteDataPostCache,
            propAllowlist: dataLoader.phase2CachePropAllowlist || new Set(dataLoader.constructor.PROPS)
        });
        this._pCache_addToCache({
            allDataMerged: prereleaseDataPostCache,
            propAllowlist: dataLoader.phase2CachePropAllowlist || new Set(dataLoader.constructor.PROPS)
        });
        this._pCache_addToCache({
            allDataMerged: brewDataPostCache,
            propAllowlist: dataLoader.phase2CachePropAllowlist || new Set(dataLoader.constructor.PROPS)
        });
    }

    static _pCache_getDataTypeLoader({pageClean, isSilent}) {
        const dataLoader = this._DATA_TYPE_LOADERS[pageClean];
        if (!dataLoader && !isSilent)
            throw new Error(`No loading strategy found for page "${pageClean}"!`);
        return dataLoader;
    }

    static _pCache_addToCache({allDataMerged, propAllowlist}) {
        if (!allDataMerged)
            return;

        allDataMerged = {
            ...allDataMerged
        };

        this._DATA_TYPE_LOADER_LIST.filter(loader=>loader.hasCustomCacheStrategy({
            obj: allDataMerged
        })).forEach(loader=>{
            const propsToRemove = loader.addToCacheCustom({
                cache: this._CACHE,
                obj: allDataMerged
            });
            propsToRemove.forEach(prop=>delete allDataMerged[prop]);
        }
        );

        Object.keys(allDataMerged).forEach(prop=>{
            if (!propAllowlist.has(prop))
                return;

            const arr = allDataMerged[prop];
            if (!arr?.length || !(arr instanceof Array))
                return;

            const hashBuilder = UrlUtil.URL_TO_HASH_BUILDER[prop];
            if (!hashBuilder)
                return;

            arr.forEach(ent=>{
                this._pCache_addEntityToCache({
                    prop,
                    hashBuilder,
                    ent
                });
                DataUtil.proxy.getVersions(prop, ent).forEach(entVer=>this._pCache_addEntityToCache({
                    prop,
                    hashBuilder,
                    ent: entVer
                }));
            }
            );
        }
        );
    }

    static _pCache_addEntityToCache({prop, hashBuilder, ent}) {
        ent.__prop = ent.__prop || prop;

        const page = this._PROP_TO_HASH_PAGE[prop];
        const source = SourceUtil.getEntitySource(ent);
        const hash = hashBuilder(ent);

        const {page: propClean, source: sourceClean, hash: hashClean} = _DataLoaderInternalUtil.getCleanPageSourceHash({
            page: prop,
            source,
            hash
        });
        const pageClean = page ? _DataLoaderInternalUtil.getCleanPage({
            page
        }) : null;

        this._CACHE.set(propClean, sourceClean, hashClean, ent);
        if (pageClean)
            this._CACHE.set(pageClean, sourceClean, hashClean, ent);
    }

    static _CACHE_SITE_SOURCE_CLEAN = null;

    static _doBuildSourceCaches() {
        this._CACHE_SITE_SOURCE_CLEAN = this._CACHE_SITE_SOURCE_CLEAN || new Set(Object.keys(Parser.SOURCE_JSON_TO_FULL).map(src=>_DataLoaderInternalUtil.getCleanSource({
            source: src
        })));
    }

    static _isSiteSource({sourceClean}) {
        if (sourceClean === _DataLoaderConst.SOURCE_SITE_ALL)
            return true;
        if (sourceClean === _DataLoaderConst.SOURCE_BREW_ALL_CURRENT)
            return false;
        if (sourceClean === _DataLoaderConst.SOURCE_PRERELEASE_ALL_CURRENT)
            return false;

        this._doBuildSourceCaches();

        return this._CACHE_SITE_SOURCE_CLEAN.has(sourceClean);
    }

    static _isPrereleaseSource({sourceClean}) {
        if (sourceClean === _DataLoaderConst.SOURCE_SITE_ALL)
            return false;
        if (sourceClean === _DataLoaderConst.SOURCE_BREW_ALL_CURRENT)
            return false;
        if (sourceClean === _DataLoaderConst.SOURCE_PRERELEASE_ALL_CURRENT)
            return true;

        this._doBuildSourceCaches();

        return sourceClean.startsWith(_DataLoaderInternalUtil.getCleanSource({
            source: Parser.SRC_UA_PREFIX
        })) || sourceClean.startsWith(_DataLoaderInternalUtil.getCleanSource({
            source: Parser.SRC_UA_ONE_PREFIX
        }));
    }

    static getDiagnosticsSummary(diagnostics) {
        diagnostics = diagnostics.filter(Boolean);
        if (!diagnostics.length)
            return "";

        const filenames = diagnostics.map(it=>it.filename).filter(Boolean).unique().sort(SortUtil.ascSortLower);

        if (!filenames.length)
            return "";

        return `Filename${filenames.length === 1 ? " was" : "s were"}: ${filenames.map(it=>`"${it}"`).join("; ")}.`;
    }
};
//#endregion


//#region CHARACTERMANCER UTILS
class Charactermancer_Util {
    static getCurrentLevel(actor) {
        return actor.items.filter(it=>it.type === "class").map(it=>Number(it.system.levels || 0)).sum();
    }

    static getBaseAbilityScores(actor) {
        return this._getAbilityScores(actor, true);
    }

    static getCurrentAbilityScores(actor) {
        return this._getAbilityScores(actor, false);
    }

    static _getAbilityScores(actor, isBase) {
        const actorData = isBase ? (actor.system._source || actor.system) : actor.system;
        const out = {
            str: Number(MiscUtil.get(actorData, "abilities", "str", "value") || 0),
            dex: Number(MiscUtil.get(actorData, "abilities", "dex", "value") || 0),
            con: Number(MiscUtil.get(actorData, "abilities", "con", "value") || 0),
            int: Number(MiscUtil.get(actorData, "abilities", "int", "value") || 0),
            wis: Number(MiscUtil.get(actorData, "abilities", "wis", "value") || 0),
            cha: Number(MiscUtil.get(actorData, "abilities", "cha", "value") || 0),
        };
        Object.entries(out).forEach(([abv,val])=>{
            if (isNaN(val))
                out[abv] = 0;
        }
        );
        return out;
    }

    static getBaseHp(actor) {
        return this._getHp(actor, true);
    }

    static _getHp(actor, isBase) {
        const actorData = isBase ? (actor.system._source || actor.system) : actor.system;
        return {
            value: (actorData?.attributes?.hp?.value || 0),
            max: actorData?.attributes?.hp?.max,
        };
    }

    static getAttackAbilityScore(itemAttack, abilityScores, mode) {
        if (!itemAttack || !abilityScores)
            return null;
        switch (mode) {
        case "melee":
            {
                const isFinesse = !!MiscUtil.get(itemAttack, "system", "properties", "fin");
                if (!isFinesse)
                    return abilityScores.str;
                return abilityScores.str > abilityScores.dex ? abilityScores.str : abilityScores.dex;
            }
        case "ranged":
            {
                const isThrown = !!MiscUtil.get(itemAttack, "system", "properties", "thr");
                if (!isThrown)
                    return abilityScores.dex;
                return abilityScores.str > abilityScores.dex ? abilityScores.str : abilityScores.dex;
            }
        default:
            throw new Error(`Unhandled mode "${mode}"`);
        }
    }

    static getFilteredFeatures(allFeatures, pageFilter, filterValues) {
        return allFeatures.filter(f=>{
            //Try to get the source of the feature
            const source = f.source || (f.classFeature ? DataUtil.class.unpackUidClassFeature(f.classFeature).source 
            : f.subclassFeature ? DataUtil.class.unpackUidSubclassFeature(f.subclassFeature) : null);

            //Then filter out this feature if we don't allow the source
            if (!pageFilter.sourceFilter.toDisplay(filterValues, source)){return false;}

            f.loadeds = f.loadeds.filter(meta=>{
                return Charactermancer_Class_Util.isClassEntryFilterMatch(meta.entity, pageFilter, filterValues);
            });

            return f.loadeds.length;
        });
    }

    /**Filters an array of features to only those we should import. For example removes features such as those that grant you a subclass */
    static getImportableFeatures(allFeatures) {
        return allFeatures.filter(f=>{
            if (f.gainSubclassFeature && !f.gainSubclassFeatureHasContent){return false;}
            if(!f.name){console.error("Feature does not have property 'name' assigned!", f);}

            const lowName = f.name.toLowerCase();
            switch (lowName) {
                case "proficiency versatility": return false;
                default: return true;
            }
        });
    }

    static doApplyFilterToFeatureEntries_bySource(allFeatures, pageFilter, filterValues) {
        allFeatures.forEach(f=>{
            f.loadeds.forEach(loaded=>{
                switch (loaded.type) {
                case "classFeature":
                case "subclassFeature":
                    {
                        if (loaded.entity.entries)
                            loaded.entity.entries = Charactermancer_Class_Util.getFilteredEntries_bySource(loaded.entity.entries, pageFilter, filterValues);
                        break;
                    }
                }
            }
            );
        }
        );

        return allFeatures;
    }

    /**Expects each feature to have a .loadeds property */
    static getFeaturesGroupedByOptionsSet(allFeatures) {
        return allFeatures.map(topLevelFeature=>{

            if(!topLevelFeature.loadeds){console.error("Feature does not have any loadeds!", topLevelFeature);}
            const optionsSets = []; //Blank optionsSets array
            let optionsStack = [];
            let lastOptionsSetId = null;
            //Go through each loadeds
            topLevelFeature.loadeds.forEach(l=>{
                //try to get l.optionsMeta.setId;
                const optionsSetId = MiscUtil.get(l, "optionsMeta", "setId") || null;
                if (lastOptionsSetId !== optionsSetId) {
                    if (optionsStack.length) { optionsSets.push(optionsStack); }
                    optionsStack = [l];
                    lastOptionsSetId = optionsSetId;
                }
                else { optionsStack.push(l); }
            });
            if (optionsStack.length) { optionsSets.push(optionsStack); }

            return {topLevelFeature, optionsSets};
        });
    }

    /**
     * Create a select element that can search for its options and can use a modalfilter
     * @param {any} comp
     * @param {string} prop
     * @param {string} propVersion
     * @param {any} data
     * @param {ModalFilter} modalFilter
     * @param {any} title
     * @returns {any}
     */
    static getFilterSearchMeta({comp, prop, propVersion=null, data, modalFilter, title}) {
        const {$wrp: $sel, fnUpdateHidden: fnUpdateSelHidden, unhook} =
        ComponentUiUtil.$getSelSearchable(comp, prop, {
            values: data.map((_,i)=>i),
            isAllowNull: true,
            fnDisplay: ix=>{
                const it = data[ix];

                if (!it) {
                    console.warn(...LGT, `Could not find ${prop} with index ${ix} (${data.length} ${prop} entries were available)`);
                    return "(Unknown)";
                }

                return `${it.name} ${it.source !== Parser.SRC_PHB ? `[${Parser.sourceJsonToAbv(it.source)}]` : ""}`;
            }
            ,
            fnGetAdditionalStyleClasses: ix=>{
                if (ix == null)
                    return null;
                const it = data[ix];
                if (!it)
                    return;
                return it._versionBase_isVersion ? ["italic"] : null;
            }
            ,
            asMeta: true,
        }, );

        const doApplyFilterToSel = ()=>{
            //try to set filterbox to only be PHB
            const f = modalFilter.pageFilter.filterBox.getValues();
            let sourcesEnabled = []; for(let key of Object.keys(f.Source)){ if(f.Source[key] > 0){sourcesEnabled[key] = f.Source[key];}}
            const isHiddenPer = data.map(it=>!modalFilter.pageFilter.toDisplay(f, it));
            fnUpdateSelHidden(isHiddenPer, false);
        };

        //TEMPFIX
        if(SETTINGS.FILTERS){modalFilter.pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, doApplyFilterToSel, );
        doApplyFilterToSel();}

        const $btnFilter = $(`<button class="btn btn-xs btn-5et br-0 pr-2" title="Filter for a ${title}"><span class="glyphicon glyphicon-filter"></span> Filter</button>`).click(async()=>{
            const selecteds = await modalFilter.pGetUserSelection();
            if (selecteds == null || !selecteds.length)
                return;

            const selected = selecteds[0];
            const ix = data.findIndex(it=>it.name === selected.name && it.source === selected.values.sourceJson);
            if (!~ix)
                throw new Error(`Could not find selected entity: ${JSON.stringify(selected)}`);
            comp._state[prop] = ix;
        }
        );

        const {$stg: $stgSelVersion=null, unhook: unhookVersion=null} = this._getFilterSearchMeta_getVersionMeta({
            comp,
            prop,
            propVersion,
            data
        }) || {};

        return {
            $sel,
            $btnFilter,
            $stgSelVersion,
            unhook: ()=>{
                unhook();
                modalFilter.pageFilter.filterBox.off(FilterBox.EVNT_VALCHANGE, doApplyFilterToSel);
                if (unhookVersion)
                    unhookVersion();
            }
            ,
        };
    }

    static _getFilterSearchMeta_getVersionMeta({comp, prop, propVersion, data}) {
        if (!propVersion)
            return;

        const {$sel, setValues, unhook} = ComponentUiUtil.$getSelEnum(comp, propVersion, {
            values: [],
            isAllowNull: true,
            displayNullAs: "(Base version)",
            fnDisplay: it=>`${it.name}${it.source !== data[comp._state[prop]]?.source ? ` (${Parser.sourceJsonToAbv(it.source)})` : ""}`,
            asMeta: true,
            isSetIndexes: true,
        }, );

        const hkProp = ()=>{
            const ent = data[comp._state[prop]];
            if (ent == null) {
                setValues([]);
                return $stg.hideVe();
            }

            const versions = DataUtil.generic.getVersions(ent);
            setValues(versions);
            $stg.toggleVe(versions.length);
        }
        ;
        comp._addHookBase(prop, hkProp);

        const $stg = $$`<div class="ve-flex-col mt-2">
			<label class="split-v-center btn-group w-100">
				<div class="mr-2">Version:</div>
				${$sel}
			</label>
		</div>`;

        hkProp();

        return {
            $stg,
            unhook: ()=>{
                unhook();
                comp._removeHookBase(prop, hkProp);
            }
            ,
        };
    }
}
Charactermancer_Util.STR_WARN_SOURCE_SELECTION = `Did you change your source selection since using the Charactermancer initially?`;

class Charactermancer_Class_Util {
    /**return all features from a class (UID string format, except for gainSubclass features, which are objects with properties)*/
    static getAllFeatures(cls) {
        let allFeatures = [];
        const seenSubclassFeatureHashes = new Set();

        const gainSubclassFeatureLevels = cls.classFeatures.filter(it=>it.gainSubclassFeature).map(cf=>cf.level ??
            DataUtil.class.unpackUidClassFeature(cf.classFeature || cf).level);

        cls.classFeatures.forEach(cf=>{
            allFeatures.push(cf);

            const cfLevel = cf.level ?? DataUtil.class.unpackUidClassFeature(cf.classFeature || cf).level;
            const nxtCfLevel = gainSubclassFeatureLevels.includes(cfLevel) ? gainSubclassFeatureLevels[gainSubclassFeatureLevels.indexOf(cfLevel) + 1] : null;

            cls.subclasses.forEach(sc=>{
                sc.subclassFeatures.filter(scf=>{
                    const scfHash = scf.hash ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).hash;
                    const scfLevel = scf.level ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).level;

                    if (seenSubclassFeatureHashes.has(scfHash))
                        return false;

                    if (scf.isGainAtNextFeatureLevel) {
                        if (!cf.gainSubclassFeature)
                            return false;

                        if (cfLevel === gainSubclassFeatureLevels[0] && scfLevel <= cfLevel)
                            return true;

                        if (scfLevel <= cfLevel && (nxtCfLevel == null || scfLevel < nxtCfLevel))
                            return true;

                        return false;
                    }

                    return scfLevel === cfLevel;
                }
                ).forEach(scf=>{
                    const scfHash = scf.hash ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).hash;
                    seenSubclassFeatureHashes.add(scfHash);

                    scf.level = cfLevel;

                    allFeatures.push(scf);
                }
                );
            }
            );
        }
        );

        return MiscUtil.copy(allFeatures);
    }

    static isClassEntryFilterMatch(entry, pageFilter, filterValues) {
        const source = entry.source;
        const options = entry.isClassFeatureVariant ? {isClassFeatureVariant: true} : null;

        if (pageFilter.filterBox) {
            return pageFilter.filterBox.toDisplayByFilters(filterValues, ...[{
                filter: pageFilter.sourceFilter, value: source, }, pageFilter.optionsFilter ? {
                filter: pageFilter.optionsFilter,
                value: options,
            } : null, ].filter(Boolean), );
        }

        return pageFilter.sourceFilter.toDisplay(filterValues, source) && (!pageFilter.optionsFilter
            || pageFilter.optionsFilter.toDisplay(filterValues, options));
    }

    static getFilteredEntries_bySource(entries, pageFilter, filterValues) {
        const isDisplayableEntry = ({entry, filterValues, pageFilter})=>{
            if (!entry.source){return true;}

            return this.isClassEntryFilterMatch(entry, pageFilter, filterValues);
        };

        return this._getFilteredEntries({
            entries,
            pageFilter,
            filterValues,
            fnIsDisplayableEntry: isDisplayableEntry,
        }, );
    }
    static _getFilteredEntries({entries, pageFilter, filterValues, fnIsDisplayableEntry, }, ) {
        const recursiveFilter = (entry)=>{
            if (entry == null)
                return entry;
            if (typeof entry !== "object")
                return entry;

            if (entry instanceof Array) {
                entry = entry.filter(it=>fnIsDisplayableEntry({
                    entry: it, pageFilter, filterValues, }));

                return entry.map(it=>recursiveFilter(it));
            }

            Object.keys(entry).forEach(k=>{
                if (entry[k]instanceof Array) {
                    entry[k] = recursiveFilter(entry[k]);
                    if (!entry[k].length)
                        delete entry[k];
                } else
                    entry[k] = recursiveFilter(entry[k]);
            }
            );
            return entry;
        };

        entries = MiscUtil.copy(entries);
        return recursiveFilter(entries);
    }

    static async pGetPreparableSpells(spells, cls, spellLevelLow, spellLevelHigh) {
        Renderer.spell.populatePrereleaseLookup(await PrereleaseUtil.pGetBrewProcessed(), {
            isForce: true
        });
        Renderer.spell.populateBrewLookup(await BrewUtil2.pGetBrewProcessed(), {
            isForce: true
        });

        return spells.filter(it=>{
            if (!(it.level > 0 && it.level >= spellLevelLow && it.level <= spellLevelHigh))
                return false;

            Renderer.spell.uninitBrewSources(it);
            Renderer.spell.initBrewSources(it);

            const fromClassList = Renderer.spell.getCombinedClasses(it, "fromClassList");
            return fromClassList.some(c=>(c.name || "").toLowerCase() === cls.name.toLowerCase() && (c.source || Parser.SRC_PHB).toLowerCase() === cls.source.toLowerCase());
        }
        );
    }

    static getCasterProgression(cls, sc, {targetLevel, otherExistingClassItems=null, otherExistingSubclassItems=null}) {
        otherExistingClassItems = otherExistingClassItems || [];
        otherExistingSubclassItems = otherExistingSubclassItems || [];

        const isSpellcastingMulticlass = [...otherExistingClassItems.filter(it=>it.system?.spellcasting && it.system?.spellcasting !== "none"), ...otherExistingSubclassItems.filter(it=>it.system?.spellcasting && it.system?.spellcasting !== "none"), cls.casterProgression != null || sc?.casterProgression != null, ].filter(Boolean).length > 1;

        let {totalSpellcastingLevels, casterClassCount, maxPactCasterLevel, } = UtilActors.getActorSpellcastingInfo({
            sheetItems: [...otherExistingClassItems, ...otherExistingSubclassItems],
            isForceSpellcastingMulticlass: isSpellcastingMulticlass,
        });

        maxPactCasterLevel = Math.max(maxPactCasterLevel, targetLevel);

        const casterProgression = sc?.casterProgression || cls.casterProgression;
        const spellAbility = sc?.spellcastingAbility || cls.spellcastingAbility;

        if (casterProgression) {
            const fnRound = casterClassCount ? Math.floor : Math.ceil;
            switch (casterProgression) {
            case "full":
                totalSpellcastingLevels += targetLevel;
                break;
            case "1/2":
                totalSpellcastingLevels += fnRound(targetLevel / 2);
                break;
            case "1/3":
                totalSpellcastingLevels += fnRound(targetLevel / 3);
                break;
            }
        }

        return {
            casterProgression,
            spellAbility,
            totalSpellcastingLevels,
            maxPactCasterLevel,
        };
    }

    static getMysticProgression({cls=null, targetLevel=0, otherExistingClassItems=null, otherExistingSubclassItems=null}) {
        otherExistingClassItems = otherExistingClassItems || [];
        otherExistingSubclassItems = otherExistingSubclassItems || [];
        let totalMysticLevels = 0;

        if (cls?.name === "Mystic" && cls?.source === Parser.SRC_UATMC)
            totalMysticLevels += targetLevel;

        if (otherExistingClassItems) {
            totalMysticLevels += otherExistingClassItems.filter(it=>it.name.toLowerCase().trim() === "mystic").map(it=>it.system.levels).sum();
        }

        return {
            totalMysticLevels,
        };
    }

    static addFauxOptionalFeatureFeatures(classList, optfeatList) {
        for (const cls of classList) {
            if (cls.classFeatures && cls.optionalfeatureProgression?.length) {
                for (const optFeatProgression of cls.optionalfeatureProgression) {
                    this._addFauxOptionalFeatureFeatures_handleClassProgression(optfeatList, cls, null, optFeatProgression, );
                }
            }

            for (const sc of cls.subclasses) {
                if (sc.subclassFeatures && sc.optionalfeatureProgression?.length) {
                    for (const optFeatProgression of sc.optionalfeatureProgression) {
                        this._addFauxOptionalFeatureFeatures_handleClassProgression(optfeatList, cls, sc, optFeatProgression, );
                    }
                }
            }
        }
    }

    static _addFauxOptionalFeatureFeatures_handleClassProgression(optfeatList, cls, sc, optFeatProgression) {
        const fauxLoadeds = this._addFauxOptionalFeatureFeatures_getLoadeds(optfeatList, cls, optFeatProgression);

        let progression = optFeatProgression.progression;
        if (!(progression instanceof Array)) {
            if (progression["*"]) {
                progression = MiscUtil.copy(progression);
                progression[1] = progression["*"];
            }

            const populated = new Set(Object.keys(progression).map(it=>Number(it)).sort(SortUtil.ascSort));
            const nxt = [];
            const lvlMax = Math.max(...populated, Consts.CHAR_MAX_LEVEL);
            for (let i = 0; i < lvlMax; ++i) {
                nxt[i] = populated.has(i + 1) ? progression[i + 1] : nxt.length ? nxt.last() : 0;
            }
            progression = nxt;
        }

        let required = optFeatProgression.required;
        if (required && !(required instanceof Array)) {
            const populated = new Set(Object.keys(required).map(it=>Number(it)).sort(SortUtil.ascSort));
            const nxt = [];
            const lvlMax = Math.max(...populated, Consts.CHAR_MAX_LEVEL);
            for (let i = 0; i < lvlMax; ++i) {
                nxt[i] = populated.has(i + 1) ? required[i + 1] : [];
            }
            required = nxt;
        }

        const propFeatures = sc ? "subclassFeatures" : "classFeatures";
        const propFeature = sc ? "subclassFeature" : "classFeature";
        const fnUnpackUidFeature = sc ? DataUtil.class.unpackUidSubclassFeature : DataUtil.class.unpackUidClassFeature;

        let cntPrev = 0;
        progression.forEach((cntOptFeats,ixLvl)=>{
            if (cntOptFeats === cntPrev)
                return;
            const cntDelta = cntOptFeats - cntPrev;
            if (!~cntDelta)
                return;
            const lvl = ixLvl + 1;
            const requiredUidsUnpacked = (required?.[ixLvl] || []).map(it=>DataUtil.proxy.unpackUid("optionalfeature", it, "optfeature", {
                isLower: true
            }));

            const feature = this._addFauxOptionalFeatureFeatures_getFauxFeature(cls, sc, optFeatProgression, lvl, fauxLoadeds, cntDelta, requiredUidsUnpacked);

            const ixInsertBefore = (sc || cls)[propFeatures].findIndex(it=>{
                return (it.level || fnUnpackUidFeature(it[propFeature] || it).level) > lvl;
            }
            );
            if (~ixInsertBefore)
                (sc || cls)[propFeatures].splice(ixInsertBefore, 0, feature);
            else
                (sc || cls)[propFeatures].push(feature);

            cntPrev = cntOptFeats;
        }
        );
    }

    static _addFauxOptionalFeatureFeatures_getLoadeds(optfeatList, clsSc, optFeatProgression) {
        const availOptFeats = optfeatList.filter(it=>optFeatProgression.featureType instanceof Array && (optFeatProgression.featureType || []).some(ft=>it.featureType.includes(ft)));
        const optionsMeta = {
            setId: CryptUtil.uid(),
            name: optFeatProgression.name
        };
        return availOptFeats.map(it=>{
            return {
                type: "optionalfeature",
                entry: `{@optfeature ${it.name}|${it.source}}`,
                entity: MiscUtil.copy(it),
                optionsMeta,
                page: UrlUtil.PG_OPT_FEATURES,
                source: it.source,
                hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES](it),
                isRequiredOption: false,
            };
        }
        );
    }

    static _addFauxOptionalFeatureFeatures_getFauxFeature(cls, sc, optFeatProgression, lvl, fauxLoadeds, cntOptions, requiredUidsUnpacked) {
        const loadeds = MiscUtil.copy(fauxLoadeds).filter(l=>!ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES]({
            name: l.entity.name,
            source: l.entity.source
        }), "optionalfeature", l.entity.source, {
            isNoCount: true
        }, ));

        loadeds.forEach(l=>{
            l.isRequiredOption = requiredUidsUnpacked.some(it=>it.name === l.entity.name.toLowerCase() && it.source === l.entity.source.toLowerCase());
            l.optionsMeta.count = cntOptions;
            PageFilterClassesFoundry.populateEntityTempData({
                entity: l.entity,
                ancestorClassName: cls.name,
                ancestorSubclassName: sc?.name,
                level: lvl,
                ancestorType: "optionalfeature",
                displayName: `${optFeatProgression.name}: ${l.entity.name}`,
                foundrySystem: {
                    requirements: cls.name ? `${cls.name}${sc ? ` (${sc.name})` : ""} ${lvl}` : null,
                },
            });
        }
        );

        const out = {
            name: optFeatProgression.name,
            level: lvl,
            loadeds: loadeds,
        };

        if (sc) {
            Object.assign(out, {
                source: sc.source,
                subclassFeature: `${optFeatProgression.name}|${cls.name}|${cls.source}|${sc.shortName}|${sc.source}|${lvl}|${Parser.SRC_5ETOOLS_TMP}`,
                hash: UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"]({
                    name: optFeatProgression.name,
                    subclassName: sc.name,
                    subclassSource: sc.source,
                    className: cls.name,
                    classSource: cls.source,
                    level: lvl,
                    source: Parser.SRC_5ETOOLS_TMP,
                }),
            }, );
        } else {
            Object.assign(out, {
                source: cls.source,
                classFeature: `${optFeatProgression.name}|${cls.name}|${cls.source}|${lvl}|${Parser.SRC_5ETOOLS_TMP}`,
                hash: UrlUtil.URL_TO_HASH_BUILDER["classFeature"]({
                    name: optFeatProgression.name,
                    className: cls.name,
                    classSource: cls.source,
                    level: lvl,
                    source: Parser.SRC_5ETOOLS_TMP,
                }),
            }, );
        }

        return out;
    }

    static getExistingClassItems(actor, cls) {
        if (!cls){return [];}

        return actor.items.filter(actItem=>{
            if (actItem.type !== "class"){return;}

            const {page, source, hash, propDroppable} = MiscUtil.get(actItem, "flags", SharedConsts.MODULE_ID) || {};
            if (page === UrlUtil.PG_CLASSES && propDroppable === "class" && source === cls.source && hash === UrlUtil.URL_TO_HASH_BUILDER["class"](cls))
                return true;

            return (actItem.name || "").toLowerCase().trim() === cls.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(actItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(cls.source).toLowerCase());
        }
        );
    }

    static getExistingSubclassItems(actor, cls, sc) {
        if (!cls || !sc)
            return [];

        return actor.items.filter(actItem=>{
            if (actItem.type !== "subclass")
                return false;

            const {page, source, hash, propDroppable} = MiscUtil.get(actItem, "flags", SharedConsts.MODULE_ID) || {};
            if (page === UrlUtil.PG_CLASSES && propDroppable === "subclass" && source === sc.source && hash === UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc))
                return true;

            return (actItem.name || "").toLowerCase().trim() === sc.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(actItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(sc.source).toLowerCase());
        }
        );
    }

    static getClassFromExistingClassItem(existingClassItem, classes) {
        if (!existingClassItem || existingClassItem.type !== "class" || !classes?.length)
            return null;

        classes = [...classes].sort(this._sortByOfficialAndRecent.bind(this));

        return classes.find(cls=>cls.name.toLowerCase().trim() === existingClassItem.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(existingClassItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(cls.source).toLowerCase()), );
    }

    static getSubclassFromExistingSubclassItem(existingSubclassItem, cls, subclasses) {
        if (!existingSubclassItem || existingSubclassItem.type !== "subclass" || !subclasses?.length)
            return null;

        subclasses = subclasses.filter(it=>it.className === cls.name && it.classSource === cls.source);

        subclasses = [...subclasses].sort(this._sortByOfficialAndRecent.bind(this));

        return subclasses.find(sc=>sc.name.toLowerCase().trim() === existingSubclassItem.name.toLowerCase().trim() || sc.shortName.toLowerCase().trim() === existingSubclassItem.name.toLowerCase().trim(), );
    }

    static _sortByOfficialAndRecent(a, b) {
        const isNonStandardSourceA = SourceUtil.isNonstandardSource(a.source);
        const isNonStandardSourceB = SourceUtil.isNonstandardSource(b.source);

        if (isNonStandardSourceA === isNonStandardSourceB) {
            return SortUtil.ascSortDateString(Parser.sourceJsonToDate(a.source), Parser.sourceJsonToDate(b.source)) || SortUtil.ascSortLower(a.name, b.name);
        }

        return isNonStandardSourceA ? 1 : -1;
    }

    static getClassSubclassFeatureReferences(obj) {
        const refsClassFeature = [];
        const refsSubclassFeature = [];

        MiscUtil.getWalker({
            isNoModification: true
        }).walk(obj, {
            object: (obj)=>{
                if (obj.type === "refClassFeature") {
                    refsClassFeature.push(MiscUtil.copy(obj));
                    return;
                }

                if (obj.type === "refSubclassFeature") {
                    refsSubclassFeature.push(MiscUtil.copy(obj));
                }
            }
            ,
        }, );

        return {
            refsClassFeature,
            refsSubclassFeature
        };
    }

    static getClassSubclassItemTuples({classItems, subclassItems}) {
        if (!classItems?.length)
            return [];

        subclassItems = subclassItems || [];

        return classItems.map(classItem=>({
            classItem,
            subclassItem: subclassItems.find(it=>it.system.classIdentifier === classItem.system.identifier),
        }));
    }

    static getToolProficiencyData(profs) {
        if (!profs)
            return null;
        if (profs.toolProficiencies)
            return profs.toolProficiencies;
        if (!profs.tools)
            return null;

        const out = {};
        profs.tools.forEach(str=>{
            const itemUid = UtilActors.getItemUIdFromToolProficiency(str);
            if (!itemUid)
                return;
            const mappedTool = UtilActors.getMappedTool(itemUid);
            if (!mappedTool)
                return;
            const unmappedTool = UtilActors.getUnmappedTool(mappedTool);
            if (!unmappedTool)
                return;
            out[unmappedTool] = true;
        }
        );

        return [out];
    }
}

Charactermancer_Class_Util.ExistingFeatureChecker = class {
    constructor(actor) {
        this._actor = actor;

        this._existingSheetFeatures = {};
        this._existingImportFeatures = {};

        actor.items.filter(it=>it.type === "feat").forEach(it=>{
            const cleanSource = (UtilDocumentSource.getDocumentSource(it).source || "").trim().toLowerCase();
            Charactermancer_Class_Util.ExistingFeatureChecker._getNameAliases(it.name).forEach(alias=>this._existingSheetFeatures[alias] = cleanSource);

            const {page, source, hash} = it.flags?.[SharedConsts.MODULE_ID] || {};
            if (page && source && hash)
                this.addImportFeature(page, source, hash);
        }
        );
    }

    static _getNameAliases(name) {
        const cleanName = name.trim().toLowerCase();
        const out = [cleanName, ];

        const mTrailingParens = /^(.*?)\(.*\)$/.exec(cleanName);
        if (mTrailingParens)
            out.push(mTrailingParens[1].trim());

        if (cleanName.includes(": ")) {
            const cleanNamePostColon = cleanName.split(":").slice(1).join(":").trim();
            out.push(cleanNamePostColon);
            const mTrailingParensPostColon = /^(.*?)\(.*\)$/.exec(cleanNamePostColon);
            if (mTrailingParensPostColon)
                out.push(mTrailingParensPostColon[1].trim());
        }

        return out;
    }

    isExistingFeature(name, page, source, hash) {
        if (MiscUtil.get(this._existingImportFeatures, page, source, hash))
            return true;

        const searchNameAliases = Charactermancer_Class_Util.ExistingFeatureChecker._getNameAliases(name);
        if (!searchNameAliases.some(it=>this._existingSheetFeatures[it]))
            return false;

        if (!Config.get("import", "isStrictMatching"))
            return true;

        const searchSource = Parser.sourceJsonToAbv(source).trim().toLowerCase();
        return searchNameAliases.some(it=>this._existingSheetFeatures[it] === searchSource);
    }

    addImportFeature(page, source, hash) {
        MiscUtil.set(this._existingImportFeatures, page, source, hash, true);
    }
};

class Charactermancer_ProficiencySelect extends BaseComponent {
}

Charactermancer_ProficiencySelect.PropGroup = class {
    constructor({prop, propTrackerPulse, propTracker}) {
        this.prop = prop;
        this.propTrackerPulse = propTrackerPulse;
        this.propTracker = propTracker;
    }
};

class Charactermancer_OtherProficiencySelect extends Charactermancer_ProficiencySelect {
    static async pGetUserInput(opts) {
        opts = opts || {};

        if (!opts.available)
            return {
                isFormComplete: true,
                data: {}
            };

        const comp = new this({
            ...opts,
            existing: this.getExisting(opts.existingFvtt),
            existingFvtt: opts.existingFvtt,
        });
        if (comp.isNoChoice())
            return comp.pGetFormData();

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            width: 640,
            isAutoResize: true,
        });
    }

    static getExistingFvttFromActor(actor) {
        return {
            skillProficiencies: MiscUtil.get(actor, "_source", "system", "skills"),
            toolProficiencies: MiscUtil.get(actor, "_source", "system", "tools"),
            languageProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "languages"),
            armorProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "armorProf"),
            weaponProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "weaponProf"),
            savingThrowProficiencies: MiscUtil.get(actor, "_source", "system", "abilities"),
        };
    }

    static getExisting(existingFvtt) {
        if(!SETTINGS.USE_EXISTING){return null;} //TEMPFIX
        return {
            skillProficiencies: this._getExistingSkillToolProficiencies({
                existingProficienciesSetFvtt: existingFvtt.skillProficiencies,
                mapAbvToFull: UtilActors.SKILL_ABV_TO_FULL,
            }),
            toolProficiencies: this._getExistingSkillToolProficiencies({
                existingProficienciesSetFvtt: existingFvtt.toolProficiencies,
                mapAbvToFull: UtilActors.SKILL_ABV_TO_FULL,
            }),
            languageProficiencies: this._getExistingProficiencies({
                existingProficienciesSetFvtt: existingFvtt?.languageProficiencies,
                vetToFvttProfs: UtilActors.VALID_LANGUAGES,
                allProfsVet: Parser.LANGUAGES_ALL,
            }),
            armorProficiencies: this._getExistingProficiencies({
                existingProficienciesSetFvtt: existingFvtt?.armorProficiencies,
                vetToFvttProfs: UtilActors.VALID_ARMOR_PROFICIENCIES,
                allProfsVet: UtilActors.ARMOR_PROFICIENCIES,
            }),
            weaponProficiencies: this._getExistingProficiencies({
                existingProficienciesSetFvtt: existingFvtt?.weaponProficiencies,
                vetToFvttProfs: UtilActors.VALID_WEAPON_PROFICIENCIES,
                allProfsVet: UtilActors.WEAPON_PROFICIENCIES,
            }),
            savingThrowProficiencies: this._getExistingSavingThrowProficiencies(existingFvtt),
        };
    }

    static isNoChoice(available) {
        return this._isNoChoice({
            available
        });
    }

    static _isNoChoice({available, isAlreadyMapped}) {
        if (!available?.length)
            return true;
        if (isAlreadyMapped && !this._isValidAvailableData(available))
            throw new Error(`Proficiency data was not valid! Data was:\n${JSON.stringify(available)}`);

        if (!isAlreadyMapped)
            available = Charactermancer_OtherProficiencySelect._getNormalizedAvailableProficiencies(available);

        return available.length === 1 && !available[0].choose;
    }

    static _isValidAvailableData(available) {
        if (!(available instanceof Array))
            return false;

        for (const profSet of available) {
            const badKeys = Object.keys(profSet).filter(it=>it !== "static" && it !== "choose");
            if (badKeys.length)
                return false;

            if ((profSet.static || []).filter(it=>!it.prop).length)
                return false;
            if ((profSet.choose || []).filter(it=>it.from && it.from.some(from=>!from.prop)).length)
                return false;
            if ((profSet.choose || []).filter(it=>it.fromFilter && !it.prop).length)
                return false;
        }

        return true;
    }

    static getMappedSkillProficiencies(skillProficiencies) {
        if (!skillProficiencies)
            return skillProficiencies;
        return skillProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anySkill = it.any;
                delete it.any;
            }
            if (it.choose?.from && CollectionUtil.setEq(new Set(it.choose.from), new Set(Renderer.generic.FEATURE__ALL_SKILLS))) {
                it.anySkill = it.choose.count ?? 1;
                delete it.choose;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "skillProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedLanguageProficiencies(languageProficiencies) {
        if (!languageProficiencies)
            return languageProficiencies;
        return languageProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyLanguage = it.any;
                delete it.any;
            }
            if (it.anyStandard) {
                it.anyStandardLanguage = it.anyStandard;
                delete it.anyStandard;
            }
            if (it.anyExotic) {
                it.anyExoticLanguage = it.anyExotic;
                delete it.anyExotic;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "languageProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "languageProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedToolProficiencies(toolProficiencies) {
        if (!toolProficiencies)
            return toolProficiencies;
        return toolProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyTool = it.any;
                delete it.any;
            }
            if (it.anyArtisans) {
                it.anyArtisansTool = it.anyArtisans;
                delete it.anyArtisans;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "toolProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "toolProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedArmorProficiencies(armorProficiencies) {
        if (!armorProficiencies)
            return armorProficiencies;
        return armorProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyArmor = it.any;
                delete it.any;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "armorProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "armorProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedWeaponProficiencies(weaponProficiencies) {
        if (!weaponProficiencies)
            return weaponProficiencies;
        return weaponProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyWeapon = it.any;
                delete it.any;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "weaponProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "weaponProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedSavingThrowProficiencies(savingThrowProficiencies) {
        if (!savingThrowProficiencies)
            return savingThrowProficiencies;
        return savingThrowProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anySavingThrow = it.any;
                delete it.any;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "savingThrowProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "savingThrowProficiencies"
            });
            return it;
        }
        );
    }

    static _getMappedProficiencies_expandChoose({proficienciesSet, prop}) {
        if (!proficienciesSet.choose)
            return;
        if (proficienciesSet.choose.fromFilter)
            proficienciesSet.choose.prop = prop;
        if (proficienciesSet.choose.from) {
            proficienciesSet.choose.from = proficienciesSet.choose.from.map(it=>{
                if (typeof it !== "string")
                    return it;
                return {
                    prop,
                    name: it
                };
            }
            );
        }
        proficienciesSet.choose = [proficienciesSet.choose];
    }

    static _getMappedProficiencies_expandStatic({proficienciesSet, prop, ignoredKeys}) {
        Object.entries(proficienciesSet).forEach(([k,v])=>{
            if ((ignoredKeys && ignoredKeys.has(k)) || Charactermancer_OtherProficiencySelect._MAPPED_IGNORE_KEYS.has(k))
                return;

            if (typeof v === "boolean") {
                proficienciesSet[k] = {
                    prop
                };
                return;
            }
            if (typeof v === "number") {
                proficienciesSet[k] = {
                    prop,
                    count: v
                };
                return;
            }

            throw new Error(`Unhandled type "${typeof v}" for value of proficiency "${k}"`);
        }
        );
    }

    static _getExistingFvttProficiencySetsMeta(existingFvtt) {
        return {
            existingProficienciesFvttSet: new Set(existingFvtt?.value || []),
            existingProficienciesFvttSetCustom: new Set((existingFvtt?.custom || "").split(";").map(it=>it.trim().toLowerCase()).filter(Boolean)),
        };
    }

    constructor(opts) {
        opts = opts || {};
        super();

        this._existing = opts.existing;
        this._available = Charactermancer_OtherProficiencySelect._getNormalizedAvailableProficiencies(opts.available);
        this._titlePrefix = opts.titlePrefix;
        this._featureSourceTracker = opts.featureSourceTracker || new Charactermancer_FeatureSourceTracker();
        this._$elesPreFromGroups = opts.$elesPreFromGroups;
        this._$elesPostFromGroups = opts.$elesPostFromGroups;

        this._lastMetas = [];
        this._hkExisting = null;
    }

    static _getNormalizedAvailableProficiencies(availProfs) {
        return availProfs.map(availProfSet=>{
            const out = {};

            Object.entries(availProfSet).forEach(([k,v])=>{
                if (!v)
                    return;

                switch (k) {
                case "choose":
                    {
                        v.forEach(choose=>{
                            const mappedCount = choose.count != null && !isNaN(choose.count) ? Number(choose.count) : 1;
                            if (mappedCount <= 0)
                                return;

                            const mappedFroms = (choose?.from || []).map(it=>Renderer.generic.getMappedAnyProficiency({
                                keyAny: it,
                                countRaw: mappedCount
                            }) || this._getNormalizedProficiency(null, it)).filter(Boolean);

                            const mappedFromFilter = (choose?.fromFilter || "").trim();

                            if (!mappedFroms.length && !mappedFromFilter)
                                return;
                            if (mappedFroms.length && mappedFromFilter)
                                throw new Error(`Invalid proficiencies! Only one of "from" and "fromFilter" may be provided. Data was:\n${JSON.stringify(choose)}`);

                            const tgt = (out.choose = out.choose || []);

                            if (mappedFromFilter) {
                                if (!choose.type && !choose.prop)
                                    throw new Error(`"fromFilter" did not have an associated "type"!`);
                                tgt.push({
                                    fromFilter: mappedFromFilter,
                                    count: mappedCount,
                                    prop: choose.prop || this._getNormalizedProficiencyPropFromType(choose.type)
                                });
                                return;
                            }

                            if (!mappedFroms.length)
                                return;

                            const subOut = {
                                from: [],
                                count: mappedCount
                            };
                            mappedFroms.forEach(it=>{
                                if (it.from) {
                                    subOut.from = [...subOut.from, ...it.from];
                                    if (it.groups)
                                        Object.assign((subOut.groups = subOut.groups || {}), it.groups);
                                    return;
                                }

                                subOut.from.push(it);
                            }
                            );
                            tgt.push(subOut);
                        }
                        );

                        break;
                    }

                case "anySkill":
                case "anyTool":
                case "anyArtisansTool":
                case "anyMusicalInstrument":
                case "anyLanguage":
                case "anyStandardLanguage":
                case "anyExoticLanguage":
                case "anyWeapon":
                case "anyArmor":
                case "anySavingThrow":
                    {
                        const mappedAny = Renderer.generic.getMappedAnyProficiency({
                            keyAny: k,
                            countRaw: v
                        });
                        if (!mappedAny)
                            break;
                        (out.choose = out.choose || []).push(mappedAny);
                        break;
                    }

                default:
                    {
                        if (k === "static")
                            throw new Error(`Property handling for "static" is unimplemented!`);

                        if (v?.prop) {
                            (out.static = out.static || []).push({
                                name: k,
                                prop: v.prop
                            });
                            break;
                        }
                        if (v?.type) {
                            (out.static = out.static || []).push({
                                name: k,
                                prop: this._getNormalizedProficiencyPropFromType(v.type)
                            });
                            break;
                        }

                        const normalized = this._getNormalizedProficiency(k, v);
                        if (normalized)
                            (out.static = out.static || []).push(normalized);
                    }
                }
            }
            );

            if (out.static && out.choose) {
                out.choose.forEach(choose=>{
                    if (choose.fromFilter)
                        return;

                    choose.from = choose.from.filter(({name, prop})=>!out.static.some(({name: nameStatic, prop: propStatic})=>nameStatic === name && propStatic === prop));
                }
                );
            }

            return out;
        }
        );
    }

    static _getNormalizedProficiency(k, v) {
        if (!v){return null;}

        let name = v?.name ?? k ?? v;
        if (!name || typeof name !== "string"){return null;}
        name = name.trim();

        if (v?.prop) {
            return {
                name,
                prop: v.prop
            };
        }

        if (v?.type) {
            const prop = this._getNormalizedProficiencyPropFromType(v.type);
            return {
                name,
                prop
            };
        }

        if (Charactermancer_OtherProficiencySelect._VALID_SKILLS.has(name))
            return {
                name,
                prop: "skillProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_TOOLS.has(name))
            return {
                name,
                prop: "toolProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_LANGUAGES.has(name))
            return {
                name,
                prop: "languageProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_WEAPONS.has(name))
            return {
                name,
                prop: "weaponProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_ARMORS.has(name))
            return {
                name,
                prop: "armorProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_SAVING_THROWS.has(name))
            return {
                name,
                prop: "savingThrowProficiencies"
            };

        console.warn(...LGT, `Could not discern the type of proficiency "${name}"\u2014you may need to specify it directly with "type".`);

        return null;
    }

    static _getNormalizedProficiencyPropFromType(type) {
        type = type.trim().toLowerCase();
        switch (type) {
        case "skill":
            return "skillProficiencies";
        case "tool":
            return "toolProficiencies";
        case "language":
            return "languageProficiencies";
        case "weapon":
            return "weaponProficiencies";
        case "armor":
            return "armorProficiencies";
        case "savingThrow":
            return "savingThrowProficiencies";
        default:
            throw new Error(`Type "${type}" did not have an associated proficiency property!`);
        }
    }

    static _getTagFromProp(prop) {
        switch (prop) {
        case "armorProficiencies":
            return "@item";
        case "weaponProficiencies":
            return "@item";
        default:
            throw new Error(`Cannot get @tag from prop "${prop}"`);
        }
    }

    _getTitle() {
        const props = this._getAllPossibleProps();
        return `${props.map(prop=>this.constructor._getPropDisplayName({
            prop
        })).join("/")} Proficiency`;
    }

    _getTitlePlural() {
        const props = this._getAllPossibleProps();
        return `${props.map(prop=>this.constructor._getPropDisplayName({
            prop,
            isPlural: true
        })).join("/")} Proficiencies`;
    }

    _getAllPossibleProps() {
        const propSet = new Set();

        this._available.forEach(profSet=>{
            const subSet = this.constructor._getAllPossiblePropsForProfSet(profSet);
            subSet.forEach(prop=>propSet.add(prop));
        }
        );

        return [...propSet];
    }

    static _getAllPossiblePropsForProfSet(profSet) {
        const out = new Set();
        (profSet.static || []).forEach(it=>out.add(it.prop));
        (profSet.choose || []).forEach(it=>{
            if (it.prop)
                return out.add(it.prop);
            it.from.forEach(from=>out.add(from.prop));
        }
        );
        return out;
    }

    get modalTitle() {
        return this._getTitlePlural();
    }

    render($wrp) {
        const $stgSelGroup = this._render_$getStgSelGroup();

        const $stgGroup = $$`<div class="ve-flex-col"></div>`;

        const hkIxSet = ()=>{
            $stgGroup.empty();

            if (this._featureSourceTracker && this._hkExisting) {
                Object.values(Charactermancer_OtherProficiencySelect._PROP_GROUPS).forEach(({propTrackerPulse})=>this._featureSourceTracker.removeHook(this, propTrackerPulse, this._hkExisting));
            }
            this._lastMetas.forEach(it=>it.cleanup());
            this._lastMetas = [];

            const selProfs = this._available[this._state.ixSet];

            if (this._featureSourceTracker){this._doSetTrackerState();}

            const $ptsExistingStatic = selProfs.static?.length ? this._render_renderPtStatic($stgGroup, selProfs.static) : null;

            if ($ptsExistingStatic && selProfs.choose?.length){$stgGroup.append(`<hr class="hr-2">`);}

            const $ptsExistingChoose = (selProfs.choose || []).map(({count, from, groups, fromFilter, prop},i)=>{
                if (this._$elesPreFromGroups?.[i])
                    $stgGroup.append(this._$elesPreFromGroups?.[i]);

                const $outPtsExisting = fromFilter ? this._render_renderPtChooseFromFilter($stgGroup, {
                    ix: i,
                    count,
                    fromFilter,
                    prop
                }) : this._render_renderPtChooseFrom($stgGroup, {
                    ix: i,
                    count,
                    from,
                    groups
                });

                if (this._$elesPostFromGroups?.[i])
                    $stgGroup.append(this._$elesPostFromGroups?.[i]);

                if (selProfs.choose.length > 1 && (i < selProfs.choose.length - 1)) {
                    $stgGroup.append(`<hr class="hr-2">`);
                }

                return $outPtsExisting;
            }
            );

            this._hkExisting = ()=>this._hk_pUpdatePtsExisting($ptsExistingStatic, $ptsExistingChoose);
            if (this._featureSourceTracker) {
                Object.values(Charactermancer_OtherProficiencySelect._PROP_GROUPS).forEach(({propTrackerPulse})=>this._featureSourceTracker.addHook(this, propTrackerPulse, this._hkExisting));
            }
            this._hkExisting();
        }
        ;
        this._addHookBase("ixSet", hkIxSet);
        hkIxSet();

        $$`
			${$stgSelGroup}
			${$stgGroup}
		`.appendTo($wrp);
    }

    _doSetTrackerState() {
        const formData = this._getFormData();
        this._featureSourceTracker.setState(this, Object.keys(Charactermancer_OtherProficiencySelect._PROP_GROUPS).mergeMap(prop=>({
            [prop]: formData.data?.[prop]
        })), );
    }

    static _render_getStaticKeyFullText({name, prop}) {
        switch (prop) {
        case "weaponProficiencies":
            return name.split("|")[0].toTitleCase();

        case "armorProficiencies":
            {
                switch (name) {
                case "light":
                case "medium":
                case "heavy":
                    return name.toTitleCase();
                case "shield|phb":
                    return "Shields";
                default:
                    return name.split("|")[0].toTitleCase();
                }
            }

        case "savingThrowProficiencies":
            return Parser.attAbvToFull(name).toTitleCase();

        default:
            return name.toTitleCase();
        }
    }

    static _render_getStaticKeyFullTextOther({prop}) {
        switch (prop) {
        case "skillProficiencies":
            return "(Other skill proficiency)";
        case "toolProficiencies":
            return "(Other tool proficiency)";
        case "languageProficiencies":
            return "(Other language proficiency)";
        case "weaponProficiencies":
            return "(Other weapon proficiency)";
        case "armorProficiencies":
            return "(Other armor proficiency)";
        case "savingThrowProficiencies":
            return "(Other saving throw proficiency)";
        default:
            throw new Error(`Unhandled prop "${prop}"`);
        }
    }

    static async _pGetParentGroup({prop, name}) {
        switch (prop) {
        case "weaponProficiencies":
            return UtilDataConverter.pGetItemWeaponType(name);
        default:
            return null;
        }
    }

    static _getRenderedStatic({prop, name}) {
        switch (prop) {
        case "skillProficiencies":
            return this._getRenderedStatic_skillProficiencies(name);
        case "languageProficiencies":
            return this._getRenderedStatic_languageProficiencies(name);
        case "toolProficiencies":
            return this._getRenderedStatic_toolProficiencies(name);
        case "armorProficiencies":
            return this._getRenderedStatic_armorProficiencies(name);
        case "weaponProficiencies":
            return Renderer.get().render(`{@item ${name.split("|").map(sub=>sub.toTitleCase()).join("|")}}`);
        case "savingThrowProficiencies":
            return Parser.attAbvToFull(name).toTitleCase();
        default:
            return name.toTitleCase();
        }
    }

    static _getRenderedStatic_skillProficiencies(name) {
        const atb = Parser.skillToAbilityAbv(name);
        const ptAbility = `<div class="ml-1 ve-small ve-muted" title="${Parser.attAbvToFull(atb)}">(${atb.toTitleCase()})</div>`;

        return `<div class="ve-inline-flex-v-center">${Renderer.get().render(`{@skill ${name.toTitleCase()}}`)}${ptAbility}</div>`;
    }

    static _getRenderedStatic_languageProficiencies(name) {
        if (name === "other"){return name.toTitleCase();}
        if (UtilActors.LANGUAGES_PRIMORDIAL.includes(name))
            {return Renderer.get().render(`{@language primordial||${name.toTitleCase()}}`);}
        return Renderer.get().render(`{@language ${name.toTitleCase()}}`);
    }

    static _getRenderedStatic_toolProficiencies(name) {
        if (UtilActors.TOOL_PROFICIENCIES_TO_UID[name])
            return Renderer.get().render(`{@item ${UtilActors.TOOL_PROFICIENCIES_TO_UID[name].toTitleCase()}}`);
        return name.toTitleCase();
    }

    static _getRenderedStatic_armorProficiencies(key) {
        if (key === "light" || key === "medium" || key === "heavy")
            return key.toTitleCase();
        if (key === "shield|phb")
            return Renderer.get().render(`{@item shield|phb|Shields}`);
        return Renderer.get().render(`{@item ${key.split("|").map(sub=>sub.toTitleCase()).join("|")}}`);
    }

    static _getPropDisplayName({prop}) {
        switch (prop) {
        case "skillProficiencies":
            return `Skill`;
        case "toolProficiencies":
            return `Tool`;
        case "languageProficiencies":
            return `Language`;
        case "weaponProficiencies":
            return `Weapon`;
        case "armorProficiencies":
            return `Armor`;
        case "savingThrowProficiencies":
            return `Saving Throw`;
        default:
            throw new Error(`Unhandled prop "${prop}"`);
        }
    }

    _render_$getStgSelGroup() {
        if (this._available.length <= 1)
            return null;

        const $selIxSet = ComponentUiUtil.$getSelEnum(this, "ixSet", {
            placeholder: `Select ${this._getTitle()} Set`,
            values: this._available.map((_,i)=>i),
            fnDisplay: ix=>{
                const selProfs = this._available[ix];

                const out = [];

                if (selProfs.static) {
                    const pt = MiscUtil.copy(selProfs.static).sort((a,b)=>SortUtil.ascSortLower(a.name, b.name)).map(({name, prop})=>{
                        if (name === "other")
                            return this.constructor._render_getStaticKeyFullTextOther({
                                prop
                            });
                        return this.constructor._render_getStaticKeyFullText({
                            name,
                            prop
                        });
                    }
                    ).join(", ");
                    out.push(pt);
                }

                if (selProfs.choose) {
                    selProfs.choose.forEach(fromBlock=>{
                        if (fromBlock.name) {
                            out.push(`Choose ${fromBlock.name.toLowerCase()}`);
                            return;
                        }

                        if (fromBlock.fromFilter) {
                            out.push(`Choose ${Parser.numberToText(fromBlock.count)} from filtered selection`);
                            return;
                        }

                        if (fromBlock.groups) {
                            out.push(`Choose ${Parser.numberToText(fromBlock.count)} from ${Object.values(fromBlock.groups).map(({name})=>name).joinConjunct(", ", " or ")}`);
                            return;
                        }

                        out.push(`Choose ${Parser.numberToText(fromBlock.count || 1)} from ${fromBlock.from.map(({name})=>name.toTitleCase()).join(", ")}`);
                    }
                    );
                }

                return out.filter(Boolean).join("; ") || "(Nothing)";
            }
            ,
        }, );

        if (this._featureSourceTracker) {
            const hk = ()=>{
                const formData = this._getFormData().data;
                const trackerState = Object.keys(formData.data || {}).filter(k=>Charactermancer_OtherProficiencySelect._PROP_GROUPS[k]).mergeMap(it=>it);
                this._featureSourceTracker.setState(this, trackerState);
            }
            ;
            this._addHookBase("ixSet", hk);
        }

        return $$`<div class="w-100 mb-2 ve-flex-vh-center">
			${$selIxSet}
		</div>`;
    }

    _getAllValuesMaybeInUseLookup() {
        const out = {};

        const activeSet = this._available[this._state.ixSet] || {};

        if (activeSet.static) {
            activeSet.static.forEach(({name, prop})=>{
                out[prop] = out[prop] || new Set();
                out[prop].add(name);
            }
            );
        }

        if (activeSet.choose) {
            activeSet.choose.forEach(({from, fromFilter})=>{
                if (fromFilter) {
                    const prefix = `${this._getStateKeyPrefix()}_chooseFilter_`;
                    Object.entries(this._state).filter(([k,v])=>k.startsWith(prefix) && v).forEach(([,{prop, name}])=>{
                        if (!name)
                            throw new Error(`"fromFilter" choice had no "name"--this should never occur!`);
                        out[prop] = out[prop] || new Set();
                        out[prop].add(name);
                    }
                    );
                    return;
                }

                from.forEach(({name, prop})=>{
                    out[prop] = out[prop] || new Set();
                    out[prop].add(name);
                }
                );
            }
            );
        }

        return out;
    }

    _getStateKeyPrefix() {
        return "otherProfSelect";
    }

    _getPropsChooseFromFilter({ixChoose, ixCount}) {
        return {
            propState: `${this._getStateKeyPrefix()}_chooseFilter_${ixChoose}_${ixCount}`,
        };
    }

    _getPropsChooseFrom({ixChoose}) {
        return {
            propState: `${this._getStateKeyPrefix()}_${ixChoose}`,
        };
    }

    async _hk_pUpdatePtsExisting($ptsExistingStatic, $ptsExistingChooseFrom) {
        try {
            await this._pLock("updateExisting");
            await this._hk_pUpdatePtsExisting_({
                $ptsExistingStatic,
                $ptsExistingChooseFrom
            });
        } finally {
            this._unlock("updateExisting");
        }
    }

    async _hk_pUpdatePtsExisting_({$ptsExistingStatic, $ptsExistingChooseFrom}) {
        const allValueLookupEntries = Object.entries(this._getAllValuesMaybeInUseLookup());

        if ($ptsExistingStatic)
            await this._hk_pUpdatePtsExisting_part({
                allValueLookupEntries,
                $ptsExisting: $ptsExistingStatic
            });
        if (!$ptsExistingChooseFrom)
            return;
        for (const $ptsExisting of $ptsExistingChooseFrom)
            await this._hk_pUpdatePtsExisting_part({
                allValueLookupEntries,
                $ptsExisting
            });
    }

    async _hk_pUpdatePtsExisting_part({allValueLookupEntries, $ptsExisting}) {
        for (const [prop,allProfs] of allValueLookupEntries) {
            const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(prop, {
                ignore: this
            }) : null;

            for (const v of allProfs) {
                const parentGroup = await this.constructor._pGetParentGroup({
                    prop,
                    name: v
                });

                if (!$ptsExisting[prop]?.[v] && !parentGroup)
                    continue;

                let maxExisting = this._existing?.[prop]?.[v] || (parentGroup && this._existing?.[prop]?.[parentGroup]) || 0;

                if (otherStates)
                    otherStates.forEach(otherState=>maxExisting = Math.max(maxExisting, otherState[v] || 0, (parentGroup ? otherState[parentGroup] : 0) || 0));

                const helpText = maxExisting === 0 ? "" : `${UtilActors.PROF_TO_TEXT[maxExisting]} from Another Source`;

                $ptsExisting[prop][v].title(helpText).toggleClass("ml-1", !!maxExisting).html(maxExisting ? `(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[maxExisting]}"></i>)` : "");
            }
        }
    }

    _render_renderPtStatic($stgGroup, profsStatic) {
        const $ptsExisting = {};

        const byProp = {};
        profsStatic.forEach(({prop, name})=>MiscUtil.set(byProp, prop, name, true));
        const isMultiProp = this.constructor._getAllPossiblePropsForProfSet(this._available[this._state.ixSet]).size > 1;

        const $wrps = Object.entries(byProp).map(([prop,profsStaticSet])=>{
            const ptPropType = isMultiProp ? ` (${this.constructor._getPropDisplayName({
                prop
            })} Proficiency)` : "";
            const profsStaticSetKeys = Object.keys(profsStaticSet);
            return profsStaticSetKeys.sort(SortUtil.ascSortLower).map((name,i)=>{
                const $ptExisting = $(`<div class="ve-small veapp__msg-warning inline-block"></div>`);
                MiscUtil.set($ptsExisting, prop, name, $ptExisting);
                const isNotLast = i < profsStaticSetKeys.length - 1;
                return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${this.constructor._getRenderedStatic({
                    prop,
                    name
                })}${ptPropType}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
            }
            );
        }
        ).flat();

        $$`<div class="block">
			${$wrps}
		</div>`.appendTo($stgGroup);

        return $ptsExisting;
    }

    _render_renderPtChooseFrom($stgGroup, {ix, count, from, groups}) {
        const {propState} = this._getPropsChooseFrom({
            ixChoose: ix
        });

        const $ptsExisting = {};
        const compOpts = {
            count,
            fnDisplay: ({prop, name})=>{
                const $ptExisting = $(`<div class="ve-small veapp__msg-warning"></div>`);
                MiscUtil.set($ptsExisting, prop, name, $ptExisting);

                return $$`<div class="ve-flex-v-center w-100">
					<div class="ve-flex-v-center">${this.constructor._getRenderedStatic({
                    prop,
                    name
                })}</div>
					${$ptExisting}
				</div>`;
            }
            ,
        };

        const fromProps = new Set(from.map(({prop})=>prop));

        const byPropThenGroup = {};

        from.forEach(({name, prop, group})=>{
            group = group ?? "_";
            MiscUtil.set(byPropThenGroup, prop, group, name, Charactermancer_OtherProficiencySelect._PROFICIENT);
        }
        );

        const isMultiProp = Object.keys(byPropThenGroup).length > 1;
        const isGrouped = Object.values(byPropThenGroup).some(groupMeta=>Object.keys(groupMeta).some(group=>group !== "_"));

        if (isMultiProp || isGrouped) {
            const valueGroups = [];
            Object.entries(byPropThenGroup).forEach(([prop,groupMeta])=>{
                Object.entries(groupMeta).forEach(([groupId,names])=>{
                    const groupDetails = groups?.[groupId];

                    valueGroups.push({
                        name: [(isMultiProp ? `${this.constructor._getPropDisplayName({
                            prop
                        })} Proficiencies` : ""), groupDetails?.name, ].filter(Boolean).join(""),
                        text: groupDetails?.hint,
                        values: Object.keys(names).map(name=>({
                            prop,
                            name
                        })),
                    });
                }
                );
            }
            );

            compOpts.valueGroups = valueGroups;
        } else {
            compOpts.values = from;
        }

        const meta = ComponentUiUtil.getMetaWrpMultipleChoice(this, propState, compOpts, );

        let hkSetTrackerInfo = null;
        if (this._featureSourceTracker) {
            hkSetTrackerInfo = ()=>this._doSetTrackerState();
            this._addHookBase(meta.propPulse, hkSetTrackerInfo);
        }

        this._lastMetas.push({
            cleanup: ()=>{
                meta.cleanup();
                if (hkSetTrackerInfo)
                    this._removeHookBase(meta.propPulse, hkSetTrackerInfo);
            }
            ,
        });

        const header = fromProps.size === 1 ? (`${this.constructor._getPropDisplayName({
            prop: [...fromProps][0]
        })} ${count === 1 ? "Proficiency" : "Proficiencies"}`) : (count === 1 ? this._getTitle() : this._getTitlePlural());
        $stgGroup.append(`<div class="mb-1">${this._titlePrefix ? `${this._titlePrefix}: ` : ""}Choose ${Parser.numberToText(count)} ${header}:</div>`);
        meta.$ele.appendTo($stgGroup);

        return $ptsExisting;
    }

    _render_renderPtChooseFromFilter($stgGroup, {ix, fromFilter, count, prop}) {
        const $ptsExisting = {};

        const $row = $(`<div class="ve-flex-v-center"></div>`);

        [...new Array(count)].forEach((_,i)=>{
            const {propState} = this._getPropsChooseFromFilter({
                ixChoose: ix,
                ixCount: i
            });

            const $ptExisting = $(`<div class="ve-small veapp__msg-warning"></div>`);

            const $disp = $(`<div class="ve-flex-v-center"></div>`);
            const hkChosen = (propHk,valueHk,prevValueHk)=>{
                const isFirstRun = !propHk;
                if (!isFirstRun) {
                    if (prevValueHk) {
                        const {prop: propPrev, name: namePrev} = prevValueHk;
                        const uidPrev = (namePrev || "").toLowerCase();
                        MiscUtil.delete($ptsExisting, propPrev, uidPrev, $ptExisting);
                    }

                    if (valueHk) {
                        const {prop, name} = valueHk || {};
                        const uid = (name || "").toLowerCase();
                        MiscUtil.set($ptsExisting, prop, uid, $ptExisting);
                    }
                }

                $disp.html(this._state[propState] != null ? `<div>${Renderer.get().render(`{${this.constructor._getTagFromProp(prop)} ${this._state[propState].name.toLowerCase()}}`)}</div>` : `<div class="italic ve-muted">(select a ${this.constructor._getPropDisplayName({
                    prop
                }).toLowerCase()} proficiency)</div>`, );

                if (!isFirstRun && this._featureSourceTracker)
                    this._doSetTrackerState();
            }
            ;
            this._addHookBase(propState, hkChosen);
            this._lastMetas.push({
                cleanup: ()=>this._removeHookBase(propState, hkChosen)
            });
            hkChosen();

            const $btnFilter = $(`<button class="btn btn-default btn-xxs mx-1" title="Choose a ${this.constructor._getPropDisplayName({
                prop
            })} Proficiency"><span class="fas fa-fw fa-search"></span></button>`).click(async()=>{
                const selecteds = await this._pGetFilterChoice({
                    prop,
                    fromFilter
                });
                if (selecteds == null || !selecteds.length)
                    return;

                const selected = selecteds[0];
                this._state[propState] = {
                    prop,
                    name: `${selected.name}|${selected.values.sourceJson}`.toLowerCase()
                };
            }
            );

            $$`<div class="ve-flex-v-center mr-1">${$btnFilter}${$disp}${$ptExisting}</div>`.appendTo($row);
        }
        );

        $$`<div class="py-1 ve-flex-v-center">
			${$row}
		</div>`.appendTo($stgGroup);

        return $ptsExisting;
    }

    _pGetFilterChoice({prop, fromFilter}) {
        switch (prop) {
        case "armorProficiencies":
        case "weaponProficiencies":
            {
                const modalFilterItems = new ModalFilterItemsFvtt({
                    filterExpression: fromFilter,
                    namespace: "Charactermancer_OtherProficiencySelect.items",
                    isRadio: true,
                });
                return modalFilterItems.pGetUserSelection({
                    filterExpression: fromFilter
                });
            }

        default:
            throw new Error(`Filter choices for "${prop}" are unimplemented!`);
        }
    }

    isNoChoice() {
        return this.constructor._isNoChoice({
            available: this._available,
            isAlreadyMapped: true
        });
    }

    _getFormData() {
        let isFormComplete = true;
        const out = {};

        const selProfs = this._available[this._state.ixSet];

        (selProfs.static || []).forEach(({prop, name})=>MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT));

        (selProfs.choose || []).forEach(({count, from, groups, fromFilter, prop},ixChoose)=>{
            if (fromFilter) {
                [...new Array(count)].forEach((_,ixCount)=>{
                    const {propState} = this._getPropsChooseFromFilter({
                        ixChoose,
                        ixCount
                    });

                    if (!this._state[propState])
                        return isFormComplete = false;

                    const {prop, name} = this._state[propState];
                    MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT);
                }
                );

                return;
            }

            const {propState} = this._getPropsChooseFrom({
                ixChoose
            });

            const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, propState);
            ixs.map(ix=>from[ix]).forEach(({prop, name})=>MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT));

            if (!this._state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable(propState)])
                isFormComplete = false;
        }
        );

        return {
            isFormComplete,
            data: out,
        };
    }

    pGetFormData() {
        return this._getFormData();
    }

    _getDefaultState() {
        return {
            ixSet: 0,
        };
    }

    static _getExistingProficiencies({existingProficienciesSetFvtt, vetToFvttProfs, allProfsVet}) {
        const {existingProficienciesFvttSet, existingProficienciesFvttSetCustom} = this._getExistingFvttProficiencySetsMeta(existingProficienciesSetFvtt);

        const existing = {};

        Object.entries(vetToFvttProfs).filter(([_,fvtt])=>existingProficienciesFvttSet.has(fvtt)).forEach(([vet,fvtt])=>{
            existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
            existingProficienciesFvttSet.delete(fvtt);
        }
        );

        allProfsVet.forEach(vet=>{
            if (existingProficienciesFvttSet.has(vet)) {
                existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
                existingProficienciesFvttSet.delete(vet);
            } else if (existingProficienciesFvttSetCustom.has(vet)) {
                existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
                existingProficienciesFvttSetCustom.delete(vet);
            }
        }
        );

        if (existingProficienciesFvttSet.size || existingProficienciesFvttSetCustom.size) {
            existing.other = existingProficienciesFvttSet.size + existingProficienciesFvttSetCustom.size;
        }

        return existing;
    }

    static _getExistingSkillToolProficiencies({existingProficienciesSetFvtt, mapAbvToFull}) {
        const existing = {};

        Object.entries(existingProficienciesSetFvtt || {}).forEach(([abv,data])=>{
            if (!data.value)
                return;
            existing[mapAbvToFull[abv]] = data.value;
        });

        return existing;
    }

    static _getExistingSavingThrowProficiencies(existingFvtt) {
        const existing = {};

        Object.entries(existingFvtt?.savingThrowProficiencies || {}).forEach(([ab,data])=>{
            if (!data.proficient)
                return;
            existing[ab] = data.proficient;
        }
        );

        return existing;
    }
}
Charactermancer_OtherProficiencySelect._PROFICIENT = 1;
Charactermancer_OtherProficiencySelect._PROP_GROUPS = {
    "skillProficiencies": {
        propTrackerPulse: "pulseSkillProficiencies",
    },
    "toolProficiencies": {
        propTrackerPulse: "pulseToolProficiencies",
    },
    "languageProficiencies": {
        propTrackerPulse: "pulseLanguageProficiencies",
    },
    "weaponProficiencies": {
        propTrackerPulse: "pulseWeaponProficiencies",
    },
    "armorProficiencies": {
        propTrackerPulse: "pulseArmorProficiencies",
    },
    "savingThrowProficiencies": {
        propTrackerPulse: "pulseSavingThrowProficiencies",
    },
};

Charactermancer_OtherProficiencySelect._MAPPED_IGNORE_KEYS = new Set(["choose", "any", "anySkill", "anyTool", "anyArtisansTool", "anyMusicalInstrument", "anyLanguage", "anyStandardLanguage", "anyExoticLanguage", "anyWeapon", "anyArmor", "anySavingThrow", ]);

Charactermancer_OtherProficiencySelect._VALID_SKILLS = new Set([...Renderer.generic.FEATURE__SKILLS_ALL, "anySkill", ]);
Charactermancer_OtherProficiencySelect._VALID_TOOLS = new Set([...Renderer.generic.FEATURE__TOOLS_ALL, "anyTool", "anyArtisansTool", "anyMusicalInstrument", ]);
Charactermancer_OtherProficiencySelect._VALID_LANGUAGES = new Set([...Renderer.generic.FEATURE__LANGUAGES_ALL, "anyLanguage", "anyStandardLanguage", "anyExoticLanguage", ]);
Charactermancer_OtherProficiencySelect._VALID_WEAPONS = new Set([...UtilActors.WEAPON_PROFICIENCIES, "anyWeapon", ]);
Charactermancer_OtherProficiencySelect._VALID_ARMORS = new Set([...UtilActors.ARMOR_PROFICIENCIES, "anyArmor", ]);
Charactermancer_OtherProficiencySelect._VALID_SAVING_THROWS = new Set([...Parser.ABIL_ABVS, "anySavingThrow", ]);

class Charactermancer_SkillSaveProficiencySelect extends Charactermancer_ProficiencySelect {
    static async pGetUserInput(opts) {
        opts = opts || {};

        if (!opts.available)
            return {
                isFormComplete: true,
                data: {}
            };

        const comp = new this({
            ...opts,
            existing: this.getExisting(opts.existingFvtt),
            existingFvtt: opts.existingFvtt,
        });
        if (comp.isNoChoice())
            return comp.pGetFormData();

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            isAutoResize: true
        });
    }

    static getExisting(existingFvtt) {
        throw new Error(`Unimplemented!`);
    }

    static isNoChoice(available) {
        if (!available?.length)
            return true;
        return available.length === 1 && !available[0].choose;
    }

    constructor(opts) {
        opts = opts || {};
        super();

        this._propGroup = opts.propGroup;
        this._existing = opts.existing;
        this._existingFvtt = opts.existingFvtt;
        this._available = opts.available;
        this._titlePrefix = opts.titlePrefix;
        this._featureSourceTracker = opts.featureSourceTracker;
        this._modalTitle = opts.modalTitle;
        this._title = opts.title;
        this._titlePlural = opts.titlePlural;

        this._hkUpdateExisting = null;
        this._$stgGroup = null;
        this._lastMeta = null;
    }

    get modalTitle() {
        return this._modalTitle;
    }

    _getStaticDisplay(prof, {isPlainText=false}={}) {
        throw new Error(`Unimplemented!`);
    }
    _getMultiChoiceDisplay($ptsExisting, profOrObj) {
        throw new Error(`Unimplemented!`);
    }
    _getMultiChoiceTitle(cpyProfSet, count) {
        throw new Error(`Unimplemented!`);
    }

    _getNonStaticDisplay(key, value, {isPlainText=false}={}) {
        switch (key) {
        case "choose":
            return this._getChooseFromDisplay(key, value, {
                isPlainText
            });
        default:
            throw new Error(`Unhandled non-static key "${key}" (value was ${JSON.stringify(value)})`);
        }
    }

    _getChooseFromDisplay(key, value, {isPlainText=false}={}) {
        return `Choose ${value.count || 1} from ${value.from.map(it=>this._getStaticDisplay(it, {
            isPlainText
        })).join(", ")}`;
    }

    render($wrp) {
        const $stgSelGroup = this._render_$getStgSelGroup();
        this._$stgGroup = $$`<div class="ve-flex-col"></div>`;

        this._addHookBase("ixSet", this._hk_ixSet.bind(this));
        this._hk_ixSet();

        $$`
			${$stgSelGroup}
			${this._$stgGroup}
		`.appendTo($wrp);
    }

    _render_$getStgSelGroup() {
        if (this._available.length <= 1)
            return null;

        const $selIxSet = ComponentUiUtil.$getSelEnum(this, "ixSet", {
            values: this._available.map((_,i)=>i),
            fnDisplay: ix=>{
                const v = this._available[ix];

                const out = [];

                out.push(Object.keys(v).sort(SortUtil.ascSortLower).filter(it=>this._isStaticKey(it)).map(k=>this._getStaticDisplay(k, {
                    isPlainText: true
                })).join(", "), );

                Object.keys(v).filter(it=>!this._isStaticKey(it)).forEach(k=>out.push(this._getNonStaticDisplay(k, v[k], {
                    isPlainText: true
                })));

                return out.filter(Boolean).join("; ") || "(Nothing)";
            }
            ,
        }, );

        if (this._featureSourceTracker)
            this._addHookBase("ixSet", ()=>this._doSetTrackerState());

        return $$`<div class="w-100 mb-2 ve-flex-vh-center">
			${$selIxSet}
		</div>`;
    }

    _doSetTrackerState() {
        this._featureSourceTracker.setState(this, {
            [this._propGroup.propTracker]: this._getFormData().data?.[this._propGroup.prop]
        });
    }

    static _getSortedProfSet(profSet) {
        if (!profSet)
            return profSet;

        profSet = MiscUtil.copy(profSet);

        if (profSet.choose?.from) {
            profSet.choose.from.sort((a,b)=>{
                if (typeof a === "object" && typeof b === "object")
                    return 0;
                if (typeof a === "object")
                    return 1;
                if (typeof b === "object")
                    return -1;
                return SortUtil.ascSortLower(a, b);
            }
            );
        }

        return profSet;
    }

    _render_renderPtStatic($stgGroup, profSet) {
        const $ptsExisting = {};

        const profList = this._getStaticKeys_profSet().filter(key=>profSet[key]);

        const $wrps = profList.map((it,i)=>{
            const $ptExisting = $(`<div class="ve-small veapp__msg-warning inline-block"></div>`);
            ($ptsExisting[it] = $ptsExisting[it] || []).push($ptExisting);
            const isNotLast = i < profList.length - 1;
            return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${this._getStaticDisplay(it)}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
        }
        );

        $$`<div class="block">
			${$wrps}
		</div>`.appendTo($stgGroup);

        return $ptsExisting;
    }

    _getStaticKeys_all() {
        throw new Error("Unimplemented!");
    }

    _getStaticKeys_profSet() {
        throw new Error("Unimplemented!");
    }

    _hk_ixSet() {
        this._$stgGroup.empty();

        if (this._featureSourceTracker && this._hkUpdateExisting)
            this._featureSourceTracker.removeHook(this, this._propGroup.propTrackerPulse, this._hkUpdateExisting);
        if (this._lastMeta)
            this._lastMeta.cleanup();

        const profSet = this._available[this._state.ixSet];

        if (this._featureSourceTracker)
            this._doSetTrackerState();

        this._hk_ixSet_renderPts(profSet);

        if (this._featureSourceTracker)
            this._featureSourceTracker.addHook(this, this._propGroup.propTrackerPulse, this._hkUpdateExisting);
        this._hkUpdateExisting();
    }

    _hk_ixSet_renderPts(profSet) {
        const $ptsExistingStatic = Object.keys(profSet).some(it=>this._isStaticKey(it)) ? this._render_renderPtStatic(this._$stgGroup, profSet) : null;

        if ($ptsExistingStatic && profSet.choose)
            this._$stgGroup.append(`<hr class="hr-2 hr--dotted">`);
        const $ptsExistingChooseFrom = profSet.choose ? this._render_renderPtChooseFrom(this._$stgGroup, profSet) : null;

        this._hkUpdateExisting = ()=>this._hk_updatePtsExisting($ptsExistingStatic, $ptsExistingChooseFrom);
    }

    _isStaticKey(key) {
        return this._getStaticKeys_all().includes(key);
    }

    _hk_updatePtsExisting($ptsExistingStatic, $ptsExistingChoose) {
        const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(this._propGroup.propTracker, {
            ignore: this
        }) : null;

        const $ptsExistings = [$ptsExistingStatic, $ptsExistingChoose].filter(Boolean);

        this._getStaticKeys_all().forEach(prof=>{
            $ptsExistings.forEach($ptsExisting=>{
                if (!$ptsExisting[prof])
                    return;

                let maxExisting = this._existing?.[prof] || 0;

                if (otherStates)
                    otherStates.forEach(otherState=>maxExisting = Math.max(maxExisting, otherState[prof] || 0));

                if (maxExisting) {
                    const helpText = maxExisting === 1 ? `Proficient from Another Source` : maxExisting === 2 ? `Proficient with Expertise from Another Source` : `Half-Proficient from Another Source`;

                    $ptsExisting[prof].forEach($ptExisting=>{
                        $ptExisting.title(helpText).addClass("ml-1").html(`(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[maxExisting]}"></i>)`);
                    }
                    );
                } else {
                    $ptsExisting[prof].forEach($ptExisting=>{
                        $ptExisting.title("").removeClass("ml-1").html("");
                    }
                    );
                }
            }
            );
        }
        );
    }

    _render_renderPtChooseFrom($stgGroup, profSet) {
        const count = profSet.choose.count || 1;

        const cpyProfSet = this.constructor._getSortedProfSet(profSet);

        const $ptsExisting = {};
        const multiChoiceMeta = ComponentUiUtil.getMetaWrpMultipleChoice(this, "proficiencyChoice", {
            count,
            values: cpyProfSet.choose.from,
            fnDisplay: profOrObj=>this._getMultiChoiceDisplay($ptsExisting, profOrObj),
        }, );

        let hkSetTrackerInfo = null;
        if (this._featureSourceTracker) {
            hkSetTrackerInfo = ()=>this._doSetTrackerState();
            this._addHookBase(multiChoiceMeta.propPulse, hkSetTrackerInfo);
        }

        $stgGroup.append(`<div class="mb-1">${this._getMultiChoiceTitle(cpyProfSet, count)}:</div>`);
        multiChoiceMeta.$ele.appendTo($stgGroup);

        this._lastMeta = {
            cleanup: ()=>{
                multiChoiceMeta.cleanup();
                if (hkSetTrackerInfo)
                    this._removeHookBase(multiChoiceMeta.propPulse, hkSetTrackerInfo);
            }
            ,
        };

        return $ptsExisting;
    }

    isNoChoice() {
        return this.constructor.isNoChoice(this._available);
    }

    _getFormData() {
        const out = {};

        const profSet = this._available[this._state.ixSet];

        const cpyProfSet = this.constructor._getSortedProfSet(profSet);

        this._getStaticKeys_all().filter(name=>cpyProfSet[name]).map(name=>out[name] = 1);

        if (cpyProfSet.choose) {
            const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, "proficiencyChoice");
            ixs.map(it=>cpyProfSet.choose.from[it]).forEach(name=>out[name] = 1);
        }

        return {
            isFormComplete: !!this._state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable("proficiencyChoice")],
            data: {
                [this._propGroup.prop]: out,
            },
        };
    }

    pGetFormData() {
        return this._getFormData();
    }

    _getDefaultState() {
        return {
            ixSet: 0,
        };
    }
}
class Charactermancer_ImmResVulnSelect extends BaseComponent {
    static async pGetUserInput(opts) {
        opts = opts || {};

        if (!opts.available)
            return {
                isFormComplete: true,
                data: {}
            };

        const comp = new this({
            ...opts,
            existing: this.getExisting(opts.existingFvtt),
            existingFvtt: opts.existingFvtt,
        });
        if (comp.isNoChoice())
            return comp.pGetFormData();

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            isAutoResize: true
        });
    }

    static getExisting() {
        throw new TypeError(`Unimplemented!`);
    }

    static isNoChoice(available) {
        let cntChoices = 0;
        UtilDataConverter.WALKER_READONLY_GENERIC.walk(available, {
            object: (obj)=>{
                if (obj.choose)
                    cntChoices++;
            }
        });
        return cntChoices === 0;
    }

    constructor(opts) {
        opts = opts || {};
        super();

        this._existing = opts.existing;
        this._available = opts.available;
        this._prop = opts.prop;
        this._modalTitle = opts.modalTitle;
        this._titlePlural = opts.titlePlural;
        this._titleSingle = opts.titleSingle;

        this._lastChoiceMeta = null;

        Object.assign(this.__state.readonly_selectedValues, this._getOutputObject());
    }

    get modalTitle() {
        return this._modalTitle;
    }

    render($wrp) {
        this._lastChoiceMeta = {
            isActive: true,
            children: []
        };
        this._render_recurse($wrp, MiscUtil.copy(this._available), this._lastChoiceMeta, false);
    }

    _render_recurse($wrp, arr, outMeta, isChoices) {
        const arrStrings = arr.filter(it=>typeof it === "string").sort(SortUtil.ascSortLower);

        if (!isChoices) {
            const staticValues = arrStrings.map(it=>{
                outMeta.children.push({
                    isActive: true,
                    value: it
                });
                return it.toTitleCase();
            }
            );
            $wrp.append(`<div>${staticValues.join(", ")}</div>`);
        } else {
            arrStrings.forEach(it=>{
                const $cb = $(`<input type="checkbox" class="ml-1 mr-2">`).change(()=>{
                    if ($cb.prop("checked")) {
                        const numChecked = outMeta.children.filter(it=>it.isChoosable && it.isActive()).length;
                        if (numChecked > outMeta.count) {
                            const toDeActive = outMeta.lastChecked || outMeta.children.filter(it=>it.isChoosable).last();
                            toDeActive.setActive(false);
                        }
                        outMeta.lastChecked = node;
                    } else {
                        if (outMeta.lastChecked === node)
                            outMeta.lastChecked = null;
                    }

                    this._state.readonly_selectedValues = this._getOutputObject();
                }
                );

                const node = {
                    isActive: ()=>$cb.prop("checked") ? it : null,
                    value: it,
                    isChoosable: true,
                    setActive: (val)=>$cb.prop("checked", val),
                };
                outMeta.children.push(node);

                return $$`<label class="py-1 stripe-even ve-flex-v-center">
						${$cb}
						<span>${it.toTitleCase()}</span>
					</label>`.appendTo($wrp);
            }
            );
        }

        arr.filter(it=>typeof it !== "string").forEach((it,i)=>{
            if (!it.choose)
                throw new Error(`Unhandled immune/resist/vulnerability properties "${Object.keys(it).join(", ")}"`);

            if (isChoices) {

                const $btnSetActive = $(`<button class="btn btn-primary btn-5et btn-xs">Set Group Active</button>`).click(()=>{
                    outMeta.children.forEach(it=>it.isActive = false);
                    nxtMeta.isActive = true;
                    this._state.readonly_selectedValues = this._getOutputObject();
                }
                );

                const nxtMeta = {
                    isActive: false,
                    children: []
                };

                const $wrpChoice = $(`<div class="ve-flex-col my-1"></div>`);
                this._render_recurse($wrpChoice, it.choose.from, nxtMeta, true);

                $$`<div class="ve-flex-col pl-2 stripe-even">
						<div class="ve-flex-v-center my-1">${$btnSetActive}</div>
						${$wrpChoice}
					</div>`;

                return;
            }

            const count = it.choose.count || 1;
            const nxtMeta = {
                isActive: true,
                children: [],
                count,
                lastChecked: null
            };
            outMeta.children.push(nxtMeta);

            const $wrpChoice = $(`<div class="ve-flex-col py-1 pt-0">
					${arrStrings.length || i > 0 ? `<hr class="hr-2 hr--dotted">` : ""}
					<div class="py-1">Choose ${count} ${count === 1 ? this._titleSingle : this._titlePlural}:</div>
				</div>`).appendTo($wrp);
            this._render_recurse($wrpChoice, it.choose.from, nxtMeta, true);
        }
        );
    }

    isNoChoice() {
        return this.constructor.isNoChoice(this._available);
    }

    _getOutputSet() {
        const outSet = new Set(this._existing[this._prop] || []);
        if (this._lastChoiceMeta)
            this._getOutputSet_recurse(outSet, this._lastChoiceMeta);
        else
            UtilDataConverter.WALKER_READONLY_GENERIC.walk(this._available, {
                string: (str)=>{
                    outSet.add(str);
                }
            });

        return outSet;
    }

    _getOutputSet_recurse(outSet, node) {
        if (!node.isActive)
            return;
        const isNodeActive = node.isActive === true || node.isActive();
        if (!isNodeActive)
            return;

        if (node.value)
            outSet.add(node.value);
        if (node.children)
            node.children.forEach(it=>this._getOutputSet_recurse(outSet, it));
    }

    _getOutputObject() {
        return [...this._getOutputSet()].sort(SortUtil.ascSortLower).mergeMap(it=>({
            [it]: true
        }));
    }

    pGetFormData() {
        let isFormComplete = true;

        return {
            isFormComplete,
            data: {
                [this._prop]: MiscUtil.copy(this._state.readonly_selectedValues),
            },
        };
    }

    _getDefaultState() {
        return {
            readonly_selectedValues: {},
        };
    }
}

class Charactermancer_DamageImmunitySelect extends Charactermancer_ImmResVulnSelect {
    static getExisting(existingFvtt) {
        return MiscUtil.copy([existingFvtt?.immune?.value || []]);
    }

    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Damage Immunities`,
            titlePlural: `Damage Immunities`,
            titleSingle: `Damage Immunity`,
            prop: "immune",
        });
    }
}

class Charactermancer_DamageResistanceSelect extends Charactermancer_ImmResVulnSelect {
    static getExisting(existingFvtt) {
        return MiscUtil.copy([existingFvtt?.resist?.value || []]);
    }

    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Damage Resistances`,
            titlePlural: `Damage Resistances`,
            titleSingle: `Damage Resistance`,
            prop: "resist",
        });
    }
}

class Charactermancer_DamageVulnerabilitySelect extends Charactermancer_ImmResVulnSelect {
    static getExisting(existingFvtt) {
        return MiscUtil.copy([existingFvtt?.vulnerable?.value || []]);
    }

    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Damage Vulnerabilities`,
            titlePlural: `Damage Vulnerabilities`,
            titleSingle: `Damage Vulnerability`,
            prop: "vulnerable",
        });
    }
}

class Charactermancer_ConditionImmunitySelect extends Charactermancer_ImmResVulnSelect {
    static getExisting(existingFvtt) {
        return [existingFvtt?.conditionImmune?.value || []].map(it=>it === "diseased" ? "disease" : it);
    }

    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Condition Immunities`,
            titlePlural: `Condition Immunities`,
            titleSingle: `Condition Immunity`,
            prop: "conditionImmune",
        });
    }
}

class Charactermancer_ExpertiseSelect extends Charactermancer_SkillSaveProficiencySelect {
    constructor(opts) {
        super({
            ...opts,
            propGroup: new Charactermancer_ProficiencySelect.PropGroup({
                prop: "expertise",
                propTrackerPulse: "pulseExpertise",
                propTracker: "expertise",
            }),
            modalTitle: "Expertise",
            title: "Expertise",
            titlePlural: "Expertise",
        });
    }
    
    static getExisting(existingFvtt) {
        const existingSkills = Object.entries(Charactermancer_OtherProficiencySelect.getExisting({
            skillProficiencies: existingFvtt.skillProficiencies
        })?.skillProficiencies || {}).filter(([,profLevel])=>Number(profLevel) === 2).mergeMap(([prof,profLevel])=>({
            [prof]: profLevel
        }));

        const existingTools = Object.entries(Charactermancer_OtherProficiencySelect.getExisting({
            skillProficiencies: existingFvtt.toolProficiencies
        })?.toolProficiencies || {}).filter(([,profLevel])=>Number(profLevel) === 2).mergeMap(([prof,profLevel])=>({
            [prof]: profLevel
        }));

        return {
            ...existingSkills,
            ...existingTools
        };
    }

    static getExistingFvttFromActor(actor) {
        return {
            skillProficiencies: MiscUtil.get(actor, "_source", "system", "skills"),
            toolProficiencies: MiscUtil.get(actor, "_source", "system", "tools"),
        };
    }

    static isNoChoice(available) {
        if (!available?.length)
            return true;
        return available.length === 1 && !available[0].choose && !available[0].anyProficientSkill && !available[0].anyProficientTool;
    }

    

    _getStaticDisplay(key, {isPlainText=false}={}) {
        if (isPlainText)
            return key.toTitleCase();

        if (Parser.SKILL_TO_ATB_ABV[key])
            return Renderer.get().render(`{@skill ${key.toTitleCase()}}`);
        return key.toTitleCase();
    }

    _getNonStaticDisplay(key, value, {isPlainText=false}={}) {
        switch (key) {
        case "anyProficientSkill":
            return `Choose ${value || 1} existing skill ${value > 1 ? "proficiencies" : "proficiency"}`;
        case "anyProficientTool":
            return `Choose ${value || 1} existing tool ${value > 1 ? "proficiencies" : "proficiency"}`;
        default:
            return super._getNonStaticDisplay(key, value, {
                isPlainText
            });
        }
    }

    _getStaticKeys_all() {
        return this._available.map(profSet=>this._getStaticKeys_profSet({
            profSet
        })).flat().unique();
    }

    _getStaticKeys_profSet({profSet=null}={}) {
        profSet = profSet || this._available[this._state.ixSet];
        return Object.keys(profSet).filter(it=>this._isStaticKey(it));
    }

    _isStaticKey(key) {
        return !["anyProficientSkill", "anyProficientTool"].includes(key);
    }

    _isSkillKey(key) {
        return key === "anyProficientSkill" || Object.keys(Parser.SKILL_TO_ATB_ABV).includes(key);
    }

    _hk_ixSet_renderPts(profSet) {
        this._lastMeta = {
            cleanup: ()=>{
                this._lastMeta._fnsCleanup.forEach(fn=>fn());
            }
            ,
            _fnsCleanup: [],
        };

        const $ptsExistingStatic = Object.keys(profSet).some(it=>this._isStaticKey(it)) ? this._render_renderPtStatic(this._$stgGroup, profSet) : null;
        let needsHr = $ptsExistingStatic != null;

        if (needsHr && profSet.anyProficientSkill) {
            needsHr = false;
            this._$stgGroup.append(`<hr class="hr-2 hr--dotted">`);
        }
        const $ptsExistingChooseAnyProficientSkill = profSet.anyProficientSkill ? this._render_renderPtChooseAnyProficientSkill(this._$stgGroup, profSet) : null;
        needsHr = needsHr || $ptsExistingChooseAnyProficientSkill != null;

        if (needsHr && profSet.anyProficientTool) {
            needsHr = false;
            this._$stgGroup.append(`<hr class="hr-2 hr--dotted">`);
        }
        const $ptsExistingChooseAnyProficientTool = profSet.anyProficientTool ? this._render_renderPtChooseAnyProficientTool(this._$stgGroup, profSet) : null;

        this._hkUpdateExisting = ()=>this._hk_updatePtsExisting($ptsExistingStatic, $ptsExistingChooseAnyProficientSkill, $ptsExistingChooseAnyProficientTool);
    }

    _getProps(prop, ix) {
        return {
            propAnyProficientSkill: `${prop}_ix_skill_${ix}`,
            propAnyProficientTool: `${prop}_ix_tool_${ix}`,
        };
    }

    _render_$getPtExisting() {
        return $(`<div class="ve-small veapp__msg-warning inline-block ml-1 no-shrink" title="Expertise from Another Source">(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[2]}"></i>)</div>`);
    }

    _render_renderPtStatic($stgGroup, profSet) {
        const $ptsExisting = [];

        const profList = this._getStaticKeys_profSet().filter(key=>profSet[key]);

        const $wrps = profList.map((it,i)=>{
            const $ptExisting = this._render_$getPtExisting();

            $ptsExisting.push({
                prof: it,
                $ptExisting,
            });

            const isNotLast = i < profList.length - 1;
            return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${this._getStaticDisplay(it)}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
        }
        );

        $$`<div class="block">
			${$wrps}
		</div>`.appendTo($stgGroup);

        return $ptsExisting;
    }

    _render_renderPtChooseAnyProficientSkill($stgGroup, profSet) {
        return this._render_renderPtChooseAnyProficient({
            $stgGroup,
            profSet,
            propProfSet: "anyProficientSkill",
            propIxProps: "propAnyProficientSkill",
            fnGetValues: this._getAvailableSkills.bind(this),
            propPulse: "pulseSkillProficiencies",
            titleRow: "Existing Skill",
        });
    }

    _render_renderPtChooseAnyProficientTool($stgGroup, profSet) {
        return this._render_renderPtChooseAnyProficient({
            $stgGroup,
            profSet,
            propProfSet: "anyProficientTool",
            propIxProps: "propAnyProficientTool",
            fnGetValues: this._getAvailableTools.bind(this),
            propPulse: "pulseToolProficiencies",
            titleRow: "Existing Tool",
        });
    }

    _render_renderPtChooseAnyProficient({$stgGroup, profSet, propProfSet, propIxProps, fnGetValues, propPulse, titleRow, }, ) {
        const numChoices = Number(profSet[propProfSet] || 1);

        const $wrp = $(`<div class="ve-flex-col"></div>`).appendTo($stgGroup);

        const $ptsExisting = [];

        for (let i = 0; i < numChoices; ++i) {
            const ixProps = this._getProps(propProfSet, i);

            const selMeta = ComponentUiUtil.$getSelEnum(this, ixProps[propIxProps], {
                values: fnGetValues(),
                isAllowNull: true,
                asMeta: true,
                fnDisplay: it=>it.toTitleCase(),
            }, );
            this._lastMeta._fnsCleanup.push(selMeta.unhook);

            const $ptExisting = this._render_$getPtExisting();
            $ptsExisting.push({
                prop: ixProps[propIxProps],
                $ptExisting,
            });

            const hk = ()=>selMeta.setValues(fnGetValues(), {
                isResetOnMissing: true
            });
            if (this._featureSourceTracker) {
                this._featureSourceTracker.addHook(this, propPulse, hk);
                this._lastMeta._fnsCleanup.push(()=>this._featureSourceTracker.removeHook(this, propPulse, hk));

                const hkSetTrackerInfo = ()=>this._doSetTrackerState();
                this._addHookBase(ixProps[propIxProps], hkSetTrackerInfo);
                this._lastMeta._fnsCleanup.push(()=>this._removeHookBase(ixProps[propIxProps], hkSetTrackerInfo));
            }
            hk();

            this._lastMeta._fnsCleanup.push(()=>delete this._state[ixProps[propIxProps]]);

            $$`<div class="ve-flex-v-center ${i ? "mt-2" : ""}">
					<div class="mr-2 no-wrap">${titleRow}:</div>
					${selMeta.$sel}
					${$ptExisting}
				</div>`.appendTo($wrp);
        }

        return $ptsExisting;
    }

    _getAvailableSkills() {
        return this._getAvailableByType({
            propExistingFvtt: "skillProficiencies",
            propFeatureTracker: "skillProficiencies",
        });
    }

    _getAvailableTools() {
        return this._getAvailableByType({
            propExistingFvtt: "toolProficiencies",
            propFeatureTracker: "toolProficiencies",
        });
    }

    _getAvailableByType({propExistingFvtt, propFeatureTracker, }, ) {
        //Read existing proficencies on the foundry character
       /*  const existingAnyProfLevel = Charactermancer_OtherProficiencySelect.getExisting({
            [propExistingFvtt]: this._existingFvtt[propExistingFvtt],
        });
        const out = new Set(Object.entries(existingAnyProfLevel[propExistingFvtt]).filter(([,profLevel])=>profLevel >= 1).map(([prof])=>prof)); */

        const out = new Set();
        if (this.featureSourceTracker) { //this is a Charactermancer_FeatureSourceTracker
            (this.featureSourceTracker.getStatesForKey(propFeatureTracker, {
                ignore: this
            }) || []).forEach(otherState=>{
                Object.entries(otherState).filter(([,isAvailable])=>isAvailable).forEach(([prof])=>out.add(prof));
            });
        }
        else{
            console.error("No FeatureSourceTracker provided. Could not read existing proficiencies and learn what expertise options are available");
        }

        return [...out].sort(SortUtil.ascSortLower);
    }

    _hk_updatePtsExisting($ptsExistingStatic, $ptsExistingChooseAnyProficientSkill, $ptsExistingChooseAnyProficientTool) {
        const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(this._propGroup.propTracker, {
            ignore: this
        }) : null;

        const ptsExistingMetas = [$ptsExistingStatic, $ptsExistingChooseAnyProficientSkill, $ptsExistingChooseAnyProficientTool].filter(Boolean).flat();

        ptsExistingMetas.forEach(ptExistingMeta=>{
            const prof = ptExistingMeta.prof ?? this._state[ptExistingMeta.prop];

            if (prof == null) {
                ptExistingMeta.$ptExisting.hideVe();
                return;
            }

            let maxExisting = this._existing?.[prof] || 0;

            if (otherStates)
                otherStates.forEach(otherState=>maxExisting = Math.max(maxExisting, otherState[prof] || 0));

            ptExistingMeta.$ptExisting.toggleVe(maxExisting === 2);
        }
        );
    }

    _doSetTrackerState() {
        const formData = this._getFormData();
        this._featureSourceTracker.setState(this, {
            [this._propGroup.propTracker]: formData.data?.[this._propGroup.prop],
            "skillProficiencies": formData.data?.skillProficiencies,
            "toolProficiencies": formData.data?.toolProficiencies,
        });
    }

    _getFormData() {
        const outSkills = {};
        const outTools = {};
        const outExpertise = {};

        let isFormComplete = true;

        const profSet = this._available[this._state.ixSet];

        Object.entries(profSet).forEach(([k,v])=>{
            if (k === "anyProficientSkill" || k === "anyProficientTool") {
                const numChoices = Number(v || 1);
                for (let i = 0; i < numChoices; ++i) {
                    const {propAnyProficientSkill, propAnyProficientTool} = this._getProps(k, i);
                    const prop = this._isSkillKey(k) ? propAnyProficientSkill : propAnyProficientTool;
                    const chosenProf = this._state[prop];
                    if (chosenProf == null) {
                        isFormComplete = false;
                        continue;
                    }
                    (this._isSkillKey(k) ? outSkills : outTools)[chosenProf] = outExpertise[chosenProf] = 2;
                }
                return;
            }

            (this._isSkillKey(k) ? outSkills : outTools)[k] = outExpertise[k] = 2;
        });

        return {
            isFormComplete,
            data: {
                skillProficiencies: outSkills,
                toolProficiencies: outTools,
                expertise: outExpertise,
            },
        };
    }

    pGetFormData() {
        return this._getFormData();
    }

    _getDefaultState() {
        return {
            ixSet: 0,
        };
    }

    /**
     * @returns {Charactermancer_FeatureSourceTracker}
     */
    get featureSourceTracker(){
        return this._featureSourceTracker;
    }
}

class Charactermancer_ResourceSelect extends BaseComponent {
    static isNoChoice() {
        return true;
    }

    static async pApplyFormDataToActor(actor, formData) {
        if (!formData?.data?.length)
            return;

        const itemLookup = {};
        actor.items.contents.forEach(it=>itemLookup[it.name.toLowerCase().trim()] = it);

        const toCreate = [];

        formData.data.forEach(res=>{
            const existing = itemLookup[res.name.toLowerCase().trim()];

            if (existing)
                return;

            toCreate.push({
                name: res.name,
                type: "feat",
                data: this._getItemDataData({
                    res
                }),
                img: this._getItemDataImg({
                    res
                }),
            });
        }
        );

        await UtilDocuments.pCreateEmbeddedDocuments(actor, toCreate, {
            ClsEmbed: Item,
            isRender: false,
        }, );
    }

    render() {}

    static _getItemDataData({res}) {
        switch (res.type) {
        case "dicePool":
            return this._getItemDataData_dicePool({
                res
            });
        default:
            throw new Error(`Unhandled resource type "${res.type}"`);
        }
    }

    static _getItemDataData_dicePool({res}) {
        return {
            actionType: "other",
            formula: `${res.number}d${res.faces}`,
            activation: {
                type: "special",
            },
            uses: {
                value: 0,
                max: res.count,
                per: UtilDataConverter.getFvttUsesPer(res.recharge),
            },
        };
    }

    static _IMAGES = {
        "Superiority Die": `icons/sundries/gaming/dice-runed-brown.webp`,
        "Psionic Energy Die": "icons/sundries/gaming/dice-pair-white-green.webp",
    };
    static _getItemDataImg({res}) {
        if (this._IMAGES[res.name])
            return this._IMAGES[res.name];

        if (/\b(?:dice|die)\b/i.test((res.name || "")))
            return `icons/sundries/gaming/dice-runed-brown.webp`;

        return `modules/${SharedConsts.MODULE_ID}/media/icon/mighty-force.svg`;
    }

    constructor({resources, className, classSource, subclassShortName, subclassSource}) {
        super();
        this._resources = resources;
        this._className = className;
        this._classSource = classSource;
        this._subclassShortName = subclassShortName;
        this._subclassSource = subclassSource;

        this._mappedResources = this._getMappedResources();
    }

    _getMappedResources() {
        return (this._resources || []).map(res=>{
            switch (res.type) {
            case "dicePool":
                return this._getMappedResources_dicePool({
                    res
                });
            default:
                throw new Error(`Unhandled resource type "${res.type}"`);
            }
        }
        );
    }

    _getMappedResources_dicePool({res}) {
        res = MiscUtil.copy(res);
        res.number = this._getMappedResources_getReplacedVars(res.number || 1);
        res.faces = this._getMappedResources_getReplacedVars(res.faces);
        res.count = this._getMappedResources_getReplacedVars(res.count || 1);
        return res;
    }

    _getMappedResources_getReplacedVars(val) {
        return `${val}`.replace(/\bPB\b/g, "@attributes.prof").replace(/<\$(?<variable>[^$]+)\$>/g, (...m)=>{
            switch (m.last().variable) {
            case "level":
                return `@classes.${Parser.stringToSlug(this._className || "unknown")}.levels`;
            default:
                return m[0];
            }
        }
        );
    }

    pGetFormData() {
        return {
            isFormComplete: true,
            data: MiscUtil.copy(this._mappedResources || []),
        };
    }
}

class Charactermancer_SenseSelect extends BaseComponent {
    static isNoChoice() {
        return true;
    }

    static getExistingFvttFromActor(actor) {
        return {
            senses: MiscUtil.get(actor, "_source", "system", "attributes", "senses"),
        };
    }

    static getExisting(existingFvtt) {
        return Object.keys(CONFIG.DND5E.senses).filter(sense=>existingFvtt?.senses[sense]).mergeMap(sense=>({
            [sense]: existingFvtt?.senses[sense]
        }));
    }

    render() {}

    constructor({senses, existing, existingFvtt}) {
        super();
        this._senses = senses;
        this._existing = existing;
        this._existingFvtt = existingFvtt;
    }

    static getFormDataFromRace(race) {
        return {
            isFormComplete: true,
            data: {
                darkvision: race.darkvision,
                blindsight: race.blindsight,
                truesight: race.truesight,
                tremorsense: race.tremorsense,
            },
        };
    }

    pGetFormData() {
        return {
            isFormComplete: true,
            data: MiscUtil.copy(this._senses[0] || {}),
        };
    }
}

class Charactermancer_FeatureOptionsSelect extends BaseComponent {
    constructor(opts) {
        super();

        this._optionsSet = opts.optionsSet;
        this._actor = opts.actor;
        this._level = opts.level;
        this._existingFeatureChecker = opts.existingFeatureChecker;
        this._featureSourceTracker = opts.featureSourceTracker;
        this._isModal = !!opts.isModal;
        this._modalFilterSpells = opts.modalFilterSpells;
        this._isSkipCharactermancerHandled = !!opts.isSkipCharactermancerHandled;
        this._isSkipRenderingFirstFeatureTitle = !!opts.isSkipRenderingFirstFeatureTitle;

        if (this._isOptions()) {
            this._optionsSet.sort((a,b)=>SortUtil.ascSortLower(a.entity.name, b.entity.name)
            || SortUtil.ascSortLower(Parser.sourceJsonToAbv(a.entity.source), Parser.sourceJsonToAbv(b.entity.source)));
        }

        this._lastMeta = null;
        this._lastSubMetas = [];

        this._subCompsSkillToolLanguageProficiencies = [];
        this._subCompsSkillProficiencies = [];
        this._subCompsLanguageProficiencies = [];
        this._subCompsToolProficiencies = [];
        this._subCompsWeaponProficiencies = [];
        this._subCompsArmorProficiencies = [];
        this._subCompsSavingThrowProficiencies = [];
        this._subCompsDamageImmunities = [];
        this._subCompsDamageResistances = [];
        this._subCompsDamageVulnerabilities = [];
        this._subCompsConditionImmunities = [];
        this._subCompsExpertise = [];
        this._subCompsResources = [];
        this._subCompsSenses = [];
        this._subCompsAdditionalSpells = [];

        this._prevSubCompsSkillToolLanguageProficiencies = null;
        this._prevSubCompsSkillProficiencies = null;
        this._prevSubCompsLanguageProficiencies = null;
        this._prevSubCompsToolProficiencies = null;
        this._prevSubCompsWeaponProficiencies = null;
        this._prevSubCompsArmorProficiencies = null;
        this._prevSubCompsSavingThrowProficiencies = null;
        this._prevSubCompsDamageImmunities = [];
        this._prevSubCompsDamageResistances = [];
        this._prevSubCompsDamageVulnerabilities = [];
        this._prevSubCompsConditionImmunities = [];
        this._prevSubCompsExpertise = [];
        this._prevSubCompsResources = [];
        this._prevSubCompsSenses = null;
        this._prevSubCompsAdditionalSpells = null;
    }

    render($wrp) {
        const $stgSubChoiceData = $$`<div class="w-100 ve-flex-col mt-2"></div>`.hideVe();

        this._render_options();

        $$`<div class="ve-flex-col min-h-0 overflow-y-auto">
			${this._lastMeta?.$ele}
			${$stgSubChoiceData}
		</div>`.appendTo($wrp);

        this._addHookBase(ComponentUiUtil.getMetaWrpMultipleChoice_getPropPulse("ixsChosen"), ()=>this._render_pHkIxsChosen({
            $stgSubChoiceData
        }), );
        return this._render_pHkIxsChosen({$stgSubChoiceData});
    }

    get optionSet_() {
        return this._optionsSet;
    }

    async pIsNoChoice() {
        if (this._isOptions())
            return false;
        //TEMPFIX
        /* if (await this._pHasChoiceInSideData_chooseSystem())
            return false;
        if (await this._pHasChoiceInSideData_chooseFlags())
            return false; */
        if (await this._pHasSubChoice_entryData_skillToolLanguageProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_skillProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_languageProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_toolProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_weaponProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_armorProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_savingThrowProficiencies())
            return false;
        if (await this._pHasSubChoice_damageImmunities())
            return false;
        if (await this._pHasSubChoice_damageResistances())
            return false;
        if (await this._pHasSubChoice_damageVulnerabilities())
            return false;
        if (await this._pHasSubChoice_conditionImmunities())
            return false;
        if (await this._pHasSubChoice_expertise())
            return false;
        if (await this._pHasSubChoice_resources())
            return false;
        if (await this._pHasSubChoice_entryData_senses())
            return false;
        if (await this._pHasSubChoice_entryData_additionalSpells())
            return false;
        return true;
    }

    async pIsForceDisplay() {
        if (await this._pIsForceDisplay_skillToolLanguageProficiencies())
            return true;
        if (await this._pIsForceDisplay_skillProficiencies())
            return true;
        if (await this._pIsForceDisplay_languageProficiencies())
            return true;
        if (await this._pIsForceDisplay_toolProficiencies())
            return true;
        if (await this._pIsForceDisplay_weaponProficiencies())
            return true;
        if (await this._pIsForceDisplay_armorProficiencies())
            return true;
        if (await this._pIsForceDisplay_savingThrowProficiencies())
            return true;
        if (await this._pIsForceDisplay_damageImmunities())
            return true;
        if (await this._pIsForceDisplay_damageResistances())
            return true;
        if (await this._pIsForceDisplay_damageVulnerabilities())
            return true;
        if (await this._pIsForceDisplay_conditionImmunities())
            return true;
        if (await this._pIsForceDisplay_expertise())
            return true;
        if (await this._pIsForceDisplay_resources())
            return true;
        if (await this._pIsForceDisplay_senses())
            return true;
        if (await this._pIsForceDisplay_additionalSpells())
            return true;
        return false;
    }

    async pIsAvailable() {
        if (await this._pIsAvailable_skillToolLanguageProficiencies())
            return true;
        if (await this._pIsAvailable_skillProficiencies())
            return true;
        if (await this._pIsAvailable_languageProficiencies())
            return true;
        if (await this._pIsAvailable_toolProficiencies())
            return true;
        if (await this._pIsAvailable_weaponProficiencies())
            return true;
        if (await this._pIsAvailable_armorProficiencies())
            return true;
        if (await this._pIsAvailable_savingThrowProficiencies())
            return true;
        if (await this._pIsAvailable_damageImmunities())
            return true;
        if (await this._pIsAvailable_damageResistances())
            return true;
        if (await this._pIsAvailable_damageVulnerabilities())
            return true;
        if (await this._pIsAvailable_conditionImmunities())
            return true;
        if (await this._pIsAvailable_expertise())
            return true;
        if (await this._pIsAvailable_resources())
            return true;
        if (await this._pIsAvailable_senses())
            return true;
        if (await this._pIsAvailable_additionalSpells())
            return true;
        return false;
    }

    _isOptions() {
        return !!(this._optionsSet[0] && this._optionsSet[0].optionsMeta);
    }

    unregisterFeatureSourceTracking() {
        if (this._featureSourceTracker)
            this._featureSourceTracker.unregister(this);
        this._unregisterSubComps();
    }

    async _pIsSubChoiceForceDisplay(selectedLoadeds) {
        //TEMPFIX
        const isSubChoice_sideDataChooseSystem = false;//await this._pHasChoiceInSideData_chooseSystem(selectedLoadeds);
        const isSubChoice_sideDataChooseFlags = false; //await this._pHasChoiceInSideData_chooseFlags(selectedLoadeds);
        const isForceDisplay_entryDataSkillToolLanguageProficiencies = await this._pIsForceDisplay_skillToolLanguageProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataSkillProficiencies = await this._pIsForceDisplay_skillProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataLanguageProficiencies = await this._pIsForceDisplay_languageProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataToolProficiencies = await this._pIsForceDisplay_toolProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataWeaponProficiencies = await this._pIsForceDisplay_weaponProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataArmorProficiencies = await this._pIsForceDisplay_armorProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataSavingThrowProficiencies = await this._pIsForceDisplay_savingThrowProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataDamageImmunities = await this._pIsForceDisplay_damageImmunities(selectedLoadeds);
        const isForceDisplay_entryDataDamageResistances = await this._pIsForceDisplay_damageResistances(selectedLoadeds);
        const isForceDisplay_entryDataDamageVulnerabilities = await this._pIsForceDisplay_damageVulnerabilities(selectedLoadeds);
        const isForceDisplay_entryDataConditionImmunities = await this._pIsForceDisplay_conditionImmunities(selectedLoadeds);
        const isForceDisplay_entryDataExpertise = await this._pIsForceDisplay_expertise(selectedLoadeds);
        const isForceDisplay_entryDataResources = await this._pIsForceDisplay_resources(selectedLoadeds);
        const isForceDisplay_entryDataSenses = await this._pIsForceDisplay_senses(selectedLoadeds);
        const isForceDisplay_entryDataAdditionalSpells = await this._pIsForceDisplay_additionalSpells(selectedLoadeds);

        return [isSubChoice_sideDataChooseSystem, isSubChoice_sideDataChooseFlags, isForceDisplay_entryDataSkillToolLanguageProficiencies, isForceDisplay_entryDataSkillProficiencies, isForceDisplay_entryDataLanguageProficiencies, isForceDisplay_entryDataToolProficiencies, isForceDisplay_entryDataWeaponProficiencies, isForceDisplay_entryDataArmorProficiencies, isForceDisplay_entryDataSavingThrowProficiencies, isForceDisplay_entryDataDamageImmunities, isForceDisplay_entryDataDamageResistances, isForceDisplay_entryDataDamageVulnerabilities, isForceDisplay_entryDataConditionImmunities, isForceDisplay_entryDataExpertise, isForceDisplay_entryDataResources, isForceDisplay_entryDataSenses, isForceDisplay_entryDataAdditionalSpells, ].some(Boolean);
    }
    async _pIsSubChoiceAvailable(selectedLoadeds) {
        //TEMPFIX
        const isSubChoice_sideDataChooseSystem = false; //await this._pHasChoiceInSideData_chooseSystem(selectedLoadeds);
        const isSubChoice_sideDataChooseFlags = false; //await this._pHasChoiceInSideData_chooseFlags(selectedLoadeds);
        const isAvailable_entryDataSkillToolLanguageProficiencies = await this._pIsAvailable_skillToolLanguageProficiencies(selectedLoadeds);
        const isAvailable_entryDataSkillProficiencies = await this._pIsAvailable_skillProficiencies(selectedLoadeds);
        const isAvailable_entryDataLanguageProficiencies = await this._pIsAvailable_languageProficiencies(selectedLoadeds);
        const isAvailable_entryDataToolProficiencies = await this._pIsAvailable_toolProficiencies(selectedLoadeds);
        const isAvailable_entryDataWeaponProficiencies = await this._pIsAvailable_weaponProficiencies(selectedLoadeds);
        const isAvailable_entryDataArmorProficiencies = await this._pIsAvailable_armorProficiencies(selectedLoadeds);
        const isAvailable_entryDataSavingThrowProficiencies = await this._pIsAvailable_savingThrowProficiencies(selectedLoadeds);
        const isAvailable_entryDataDamageImmunities = await this._pIsAvailable_damageImmunities(selectedLoadeds);
        const isAvailable_entryDataDamageResistances = await this._pIsAvailable_damageResistances(selectedLoadeds);
        const isAvailable_entryDataDamageVulnerabilities = await this._pIsAvailable_damageVulnerabilities(selectedLoadeds);
        const isAvailable_entryDataConditionImmunities = await this._pIsAvailable_conditionImmunities(selectedLoadeds);
        const isAvailable_entryDataExpertise = await this._pIsAvailable_expertise(selectedLoadeds);
        const isAvailable_entryDataResources = await this._pIsAvailable_resources(selectedLoadeds);
        const isAvailable_entryDataSenses = await this._pIsAvailable_senses(selectedLoadeds);
        const isAvailable_entryDataAdditionalSpells = await this._pIsAvailable_additionalSpells(selectedLoadeds);

        return [isSubChoice_sideDataChooseSystem, isSubChoice_sideDataChooseFlags, isAvailable_entryDataSkillToolLanguageProficiencies, isAvailable_entryDataSkillProficiencies, isAvailable_entryDataLanguageProficiencies, isAvailable_entryDataToolProficiencies, isAvailable_entryDataWeaponProficiencies, isAvailable_entryDataArmorProficiencies, isAvailable_entryDataSavingThrowProficiencies, isAvailable_entryDataDamageImmunities, isAvailable_entryDataDamageResistances, isAvailable_entryDataDamageVulnerabilities, isAvailable_entryDataConditionImmunities, isAvailable_entryDataExpertise, isAvailable_entryDataResources, isAvailable_entryDataSenses, isAvailable_entryDataAdditionalSpells, ].some(Boolean);
    }

    

    async _pHasChoiceInSideData_chooseSystem(optionsSet) {
        return this._pHasChoiceInSideData_chooseSystemOrFlags({
            optionsSet,
            propChoose: "chooseSystem"
        });
    }
    async _pHasChoiceInSideData_chooseFlags(optionsSet) {
        return this._pHasChoiceInSideData_chooseSystemOrFlags({
            optionsSet,
            propChoose: "chooseFlags"
        });
    }
    async _pHasChoiceInSideData_chooseSystemOrFlags({optionsSet, propChoose}) {
        optionsSet = optionsSet || this._optionsSet;

        if (this._isSkipCharactermancerHandled)
            return false;

        for (const loaded of optionsSet) {
            const {entity, type} = loaded;

            console.log(loaded, type);
            const sideDataConverterMeta = this.constructor._ENTITY_TYPE_TO_SIDE_DATA_META[type];

            if (sideDataConverterMeta) {
                if (!sideDataConverterMeta.file.startsWith("SideDataInterface"))
                    throw new Error(`Expected side-data interface to start with "SideDataInterface"!`);
                const mod = await __variableDynamicImportRuntime2__(`./SideDataInterface/SideDataInterface${sideDataConverterMeta.file.replace(/^SideDataInterface/, "")}.js`);

                const sideData = await mod[sideDataConverterMeta.sideDataInterface].pGetSideLoaded(entity);
                if (sideData?.[propChoose]?.length)
                    return true;
            }
        }
        return false;
    }
    static _ENTITY_TYPE_TO_SIDE_DATA_META = {
        "backgroundFeature": {
            file: "SideDataInterfaceBackgroundFeature",
            sideDataInterface: "SideDataInterfaceBackgroundFeature"
        },
        "charoption": {
            file: "SideDataInterfaceCharCreationOption",
            sideDataInterface: "SideDataInterfaceCharCreationOption"
        },
        "classFeature": {
            file: "SideDataInterfaceClassSubclassFeature",
            sideDataInterface: "SideDataInterfaceClassSubclassFeature"
        },
        "subclassFeature": {
            file: "SideDataInterfaceClassSubclassFeature",
            sideDataInterface: "SideDataInterfaceClassSubclassFeature"
        },
        "feat": {
            file: "SideDataInterfaceFeat",
            sideDataInterface: "SideDataInterfaceFeat"
        },
        "optionalfeature": {
            file: "SideDataInterfaceOptionalfeature",
            sideDataInterface: "SideDataInterfaceOptionalfeature"
        },
        "raceFeature": {
            file: "SideDataInterfaceRaceFeature",
            sideDataInterface: "SideDataInterfaceRaceFeature"
        },
        "reward": {
            file: "SideDataInterfaceReward",
            sideDataInterface: "SideDataInterfaceReward"
        },
        "vehicleUpgrade": {
            file: "SideDataInterfaceVehicleUpgrade",
            sideDataInterface: "SideDataInterfaceVehicleUpgrade"
        },
    };

    async _pHasSubChoice_entryData_skillToolLanguageProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "skillToolLanguageProficiencies",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_entryData_skillProficiencies(optionsSet) {
        //Check if optionsSet has the property "skillProficiencies" in its entryData (or in the root object), and checks if its a choice between several
        //Also provides it a function to map the choices
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "skillProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_entryData_languageProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "languageProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_entryData_toolProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "toolProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_entryData_weaponProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "weaponProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_entryData_armorProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "armorProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_entryData_savingThrowProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "savingThrowProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSavingThrowProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_damageImmunities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_DamageImmunitySelect,
            prop: "immune",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_damageResistances(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_DamageResistanceSelect,
            prop: "resist",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_damageVulnerabilities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_DamageVulnerabilitySelect,
            prop: "vulnerable",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_conditionImmunities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ConditionImmunitySelect,
            prop: "conditionImmune",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_expertise(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ExpertiseSelect,
            prop: "expertise",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_resources(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ResourceSelect,
            prop: "resources",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_entryData_senses(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_SenseSelect,
            prop: "senses",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_entryData_additionalSpells(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_AdditionalSpellsSelect,
            prop: "additionalSpells",
            isRequireChoice: true,
        });
    }

    /**Checks if an object has a property in their entryData called 'prop'*/
    async _pHasEntryData_prop({optionsSet, CompClass, prop, isRequireChoice, fnGetMappedProficiencies}) {
        optionsSet = optionsSet || this._optionsSet;

        if (this._isSkipCharactermancerHandled){return false;}

        for (const loaded of optionsSet) {
            const {entity} = loaded;

            let proficiencies = entity?.[prop] || entity?.entryData?.[prop];
            if (proficiencies) {
                if (fnGetMappedProficiencies){proficiencies = fnGetMappedProficiencies(proficiencies);}

                if (!isRequireChoice){return true;}
                else {
                    const isNoChoice = CompClass.isNoChoice(proficiencies);
                    if (!isNoChoice){return true;}
                }
            }
        }
        return false;
    }

    async _pIsForceDisplay_skillToolLanguageProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "skillToolLanguageProficiencies",
        });
    }

    async _pIsForceDisplay_skillProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "skillProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_languageProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "languageProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_toolProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "toolProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_weaponProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "weaponProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_armorProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "armorProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_savingThrowProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "savingThrowProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSavingThrowProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_damageImmunities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ConditionImmunitySelect,
            prop: "immune",
        });
    }

    async _pIsForceDisplay_damageResistances(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_DamageResistanceSelect,
            prop: "resist",
        });
    }

    async _pIsForceDisplay_damageVulnerabilities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_DamageVulnerabilitySelect,
            prop: "vulnerable",
        });
    }

    async _pIsForceDisplay_conditionImmunities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ConditionImmunitySelect,
            prop: "conditionImmune",
        });
    }

    async _pIsForceDisplay_expertise(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ExpertiseSelect,
            prop: "expertise",
        });
    }

    async _pIsForceDisplay_resources(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ResourceSelect,
            prop: "resources",
            isRequireChoice: true,
        });
    }

    _pIsForceDisplay_senses(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_SenseSelect,
            prop: "senses",
            isRequireChoice: true,
        });
    }

    _pIsForceDisplay_additionalSpells(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_AdditionalSpellsSelect,
            prop: "additionalSpells",
        });
    }

    _pIsAvailable_skillToolLanguageProficiencies(...args) {
        return this._pIsForceDisplay_skillToolLanguageProficiencies(...args);
    }
    _pIsAvailable_skillProficiencies(...args) {
        return this._pIsForceDisplay_skillProficiencies(...args);
    }
    _pIsAvailable_languageProficiencies(...args) {
        return this._pIsForceDisplay_languageProficiencies(...args);
    }
    _pIsAvailable_toolProficiencies(...args) {
        return this._pIsForceDisplay_toolProficiencies(...args);
    }
    _pIsAvailable_weaponProficiencies(...args) {
        return this._pIsForceDisplay_weaponProficiencies(...args);
    }
    _pIsAvailable_armorProficiencies(...args) {
        return this._pIsForceDisplay_armorProficiencies(...args);
    }
    _pIsAvailable_savingThrowProficiencies(...args) {
        return this._pIsForceDisplay_savingThrowProficiencies(...args);
    }
    _pIsAvailable_damageImmunities(...args) {
        return this._pIsForceDisplay_damageImmunities(...args);
    }
    _pIsAvailable_damageResistances(...args) {
        return this._pIsForceDisplay_damageResistances(...args);
    }
    _pIsAvailable_damageVulnerabilities(...args) {
        return this._pIsForceDisplay_damageVulnerabilities(...args);
    }
    _pIsAvailable_conditionImmunities(...args) {
        return this._pIsForceDisplay_conditionImmunities(...args);
    }
    _pIsAvailable_expertise(...args) {
        return this._pIsForceDisplay_expertise(...args);
    }

    async _pIsAvailable_resources(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ResourceSelect,
            prop: "resources",
        });
    }

    _pIsAvailable_senses(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_SenseSelect,
            prop: "senses",
        });
    }

    _pIsAvailable_additionalSpells(...args) {
        return this._pIsForceDisplay_additionalSpells(...args);
    }

    async _pGetLoadedsSideDataRaws(optionsSet) {
        optionsSet = optionsSet || this._optionsSet;
        const out = [];
        for (const loaded of optionsSet) {
            const {entity, type} = loaded;

            switch (type) {
            case "classFeature":
            case "subclassFeature":
                {
                    const {SideDataInterfaceClassSubclassFeature} = await Promise.resolve().then(function() {
                        return SideDataInterfaceClassSubclassFeature$1;
                    });
                    const sideData = await SideDataInterfaceClassSubclassFeature.pGetSideLoaded(entity);
                    out.push(sideData);
                    break;
                }

            default:
                {
                    out.push(null);
                    break;
                }
            }
        }
        return out;
    }

   

    _getTrackableFeatures() {
        const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, "ixsChosen");
        const selectedLoadeds = ixs.map(ix=>this._optionsSet[ix]);

        return selectedLoadeds.map(({page, hash})=>({
            page,
            hash
        }));
    }

    findAndCopyStateFrom(comps) {
        if (!comps?.length)
            return;

        const comp = comps.find(it=>CollectionUtil.deepEquals(it.optionSet_, this.optionSet_));
        if (comp) {
            this._proxyAssignSimple("state", MiscUtil.copy(comp.__state));
            this._prevSubCompsSkillToolLanguageProficiencies = comp._subCompsSkillToolLanguageProficiencies;
            this._prevSubCompsSkillProficiencies = comp._subCompsSkillProficiencies;
            this._prevSubCompsLanguageProficiencies = comp._subCompsLanguageProficiencies;
            this._prevSubCompsToolProficiencies = comp._subCompsToolProficiencies;
            this._prevSubCompsWeaponProficiencies = comp._subCompsWeaponProficiencies;
            this._prevSubCompsArmorProficiencies = comp._subCompsArmorProficiencies;
            this._prevSubCompsSavingThrowProficiencies = comp._subCompsSavingThrowProficiencies;
            this._prevSubCompsDamageImmunities = comp._prevSubCompsDamageImmunities;
            this._prevSubCompsDamageResistances = comp._prevSubCompsDamageResistances;
            this._prevSubCompsDamageVulnerabilities = comp._prevSubCompsDamageVulnerabilities;
            this._prevSubCompsConditionImmunities = comp._prevSubCompsConditionImmunities;
            this._prevSubCompsExpertise = comp._prevSubCompsExpertise;
            this._prevSubCompsResources = comp._prevSubCompsResources;
            this._prevSubCompsSenses = comp._subCompsSenses;
            this._prevSubCompsAdditionalSpells = comp._subCompsAdditionalSpells;
        }
    }

    async pGetFormData() {
        if (await this.pIsNoChoice() && !await this.pIsAvailable()) {
            const sideDatas = await this._pGetLoadedsSideDataRaws();
            const cpyOptionsSet = MiscUtil.copy(this._optionsSet);
            cpyOptionsSet.forEach((loaded,i)=>{
                const sideData = sideDatas[i];
                if (!sideData)
                    return;

                const {entity} = loaded;
                if (sideData.data)
                    entity.foundryAdditionalSystem = MiscUtil.copy(sideData.data);
                if (sideData.flags)
                    entity.foundryAdditionalFlags = MiscUtil.copy(sideData.flags);
                if (sideData.effects)
                    entity.effectsRaw = MiscUtil.copy(sideData.effects);
            }
            );

            return {
                isFormComplete: true,
                data: {
                    features: cpyOptionsSet,
                },
            };
        }

        await this._pGate("ixsChosen");

        const selectedLoadeds = this._getSelectedLoadeds();

        const sideDatas = await this._pGetLoadedsSideDataRaws(selectedLoadeds);
        const cpySelectedLoadeds = MiscUtil.copy(selectedLoadeds);

        const outSkillToolLanguageProficiencies = [];
        const outSkillProficiencies = [];
        const outLanguageProficiencies = [];
        const outToolProficiencies = [];
        const outWeaponProficiencies = [];
        const outArmorProficiencies = [];
        const outSavingThrowProficiencies = [];
        const outDamageImmunities = [];
        const outDamageResistances = [];
        const outDamageVulnerabilities = [];
        const outConditionImmunities = [];
        const outExpertise = [];
        const outResources = [];
        const outSenses = [];
        const outAdditionalSpells = [];

        for (let i = 0; i < cpySelectedLoadeds.length; ++i) {
            const loaded = cpySelectedLoadeds[i];

            const sideData = sideDatas[i];

            const {entity} = loaded;

            if (sideData) {
                if (sideData.data)
                    entity.foundryAdditionalSystem = MiscUtil.copy(sideData.data);
                if (sideData.flags)
                    entity.foundryAdditionalFlags = MiscUtil.copy(sideData.flags);
                if (sideData.effects)
                    entity.effectsRaw = MiscUtil.copy(sideData.effects);

                const selectedChooseDataSystem = this._getFormData_getChooseSystemOrChooseFlags({
                    sideData,
                    ixCpySelectedLoaded: i,
                    propChoose: "chooseSystem",
                    propCompProp: "propChooseSystem",
                });
                if (selectedChooseDataSystem) {
                    entity.foundryAdditionalSystem = entity.foundryAdditionalSystem || {};
                    Object.assign(entity.foundryAdditionalSystem, MiscUtil.copy(selectedChooseDataSystem.system));
                }

                const selectedChooseDataFlags = this._getFormData_getChooseSystemOrChooseFlags({
                    sideData,
                    ixCpySelectedLoaded: i,
                    propChoose: "chooseFlags",
                    propCompProp: "propChooseFlags",
                });
                if (selectedChooseDataFlags) {
                    entity.foundryAdditionalFlags = entity.foundryAdditionalFlags || {};
                    foundry.utils.mergeObject(entity.foundryAdditionalFlags, MiscUtil.copy(selectedChooseDataFlags.flags));
                }
            }

            if (!this._isSkipCharactermancerHandled) {
                if ((entity?.skillToolLanguageProficiencies || entity?.entryData?.skillToolLanguageProficiencies) && this._subCompsSkillToolLanguageProficiencies[i]) {
                    const formData = await this._subCompsSkillToolLanguageProficiencies[i].pGetFormData();
                    outSkillToolLanguageProficiencies.push(formData);
                }

                if ((entity?.skillProficiencies || entity?.entryData?.skillProficiencies) && this._subCompsSkillProficiencies[i]) {
                    const formData = await this._subCompsSkillProficiencies[i].pGetFormData();
                    outSkillProficiencies.push(formData);
                }

                if ((entity?.languageProficiencies || entity?.entryData?.languageProficiencies) && this._subCompsLanguageProficiencies[i]) {
                    const formData = await this._subCompsLanguageProficiencies[i].pGetFormData();
                    outLanguageProficiencies.push(formData);
                }

                if ((entity?.toolProficiencies || entity?.entryData?.toolProficiencies) && this._subCompsToolProficiencies[i]) {
                    const formData = await this._subCompsToolProficiencies[i].pGetFormData();
                    outToolProficiencies.push(formData);
                }

                if ((entity?.weaponProficiencies || entity?.entryData?.weaponProficiencies) && this._subCompsWeaponProficiencies[i]) {
                    const formData = await this._subCompsWeaponProficiencies[i].pGetFormData();
                    outWeaponProficiencies.push(formData);
                }

                if ((entity?.armorProficiencies || entity?.entryData?.armorProficiencies) && this._subCompsArmorProficiencies[i]) {
                    const formData = await this._subCompsArmorProficiencies[i].pGetFormData();
                    outArmorProficiencies.push(formData);
                }

                if ((entity?.savingThrowProficiencies || entity?.entryData?.savingThrowProficiencies) && this._subCompsSavingThrowProficiencies[i]) {
                    const formData = await this._subCompsSavingThrowProficiencies[i].pGetFormData();
                    outSavingThrowProficiencies.push(formData);
                }

                if ((entity?.immune || entity?.entryData?.immune) && this._subCompsDamageImmunities[i]) {
                    const formData = await this._subCompsDamageImmunities[i].pGetFormData();
                    outDamageImmunities.push(formData);
                }

                if ((entity?.resist || entity?.entryData?.resist) && this._subCompsDamageResistances[i]) {
                    const formData = await this._subCompsDamageResistances[i].pGetFormData();
                    outDamageResistances.push(formData);
                }

                if ((entity?.vulnerable || entity?.entryData?.vulnerable) && this._subCompsDamageVulnerabilities[i]) {
                    const formData = await this._subCompsDamageVulnerabilities[i].pGetFormData();
                    outDamageVulnerabilities.push(formData);
                }

                if ((entity?.conditionImmune || entity?.entryData?.conditionImmune) && this._subCompsConditionImmunities[i]) {
                    const formData = await this._subCompsConditionImmunities[i].pGetFormData();
                    outConditionImmunities.push(formData);
                }

                if ((entity?.expertise || entity?.entryData?.expertise) && this._subCompsExpertise[i]) {
                    const formData = await this._subCompsExpertise[i].pGetFormData();
                    outExpertise.push(formData);
                }

                if ((entity?.resources || entity?.entryData?.resources) && this._subCompsResources[i]) {
                    const formData = await this._subCompsResources[i].pGetFormData();
                    outResources.push(formData);
                }

                if ((entity?.senses || entity?.entryData?.senses) && this._subCompsSenses[i]) {
                    const formData = await this._subCompsSenses[i].pGetFormData();
                    outSenses.push(formData);
                }

                if ((entity?.additionalSpells || entity?.entryData?.additionalSpells) && this._subCompsAdditionalSpells[i]) {
                    const formData = await this._subCompsAdditionalSpells[i].pGetFormData();
                    outAdditionalSpells.push(formData);
                }
            }
        }

        return {
            isFormComplete: true,
            data: {
                features: cpySelectedLoadeds,
                formDatasSkillToolLanguageProficiencies: outSkillToolLanguageProficiencies,
                formDatasSkillProficiencies: outSkillProficiencies,
                formDatasLanguageProficiencies: outLanguageProficiencies,
                formDatasToolProficiencies: outToolProficiencies,
                formDatasWeaponProficiencies: outWeaponProficiencies,
                formDatasArmorProficiencies: outArmorProficiencies,
                formDatasSavingThrowProficiencies: outSavingThrowProficiencies,
                formDatasDamageImmunities: outDamageImmunities,
                formDatasDamageResistances: outDamageResistances,
                formDatasDamageVulnerabilities: outDamageVulnerabilities,
                formDatasConditionImmunities: outConditionImmunities,
                formDatasExpertise: outExpertise,
                formDatasResources: outResources,
                formDatasSenses: outSenses,
                formDatasAdditionalSpells: outAdditionalSpells,
            },
        };
    }

    _getFormData_getChooseSystemOrChooseFlags({sideData, ixCpySelectedLoaded, propChoose, propCompProp}) {
        if (!sideData[propChoose])
            return null;

        const compProps = this._getProps(ixCpySelectedLoaded);

        const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, compProps[propCompProp]);
        const selectedChoose = ixs.map(ix=>sideData[propChoose][ix]);

        if (!selectedChoose.length)
            return null;

        return selectedChoose[0];
    }

    _getOptionsNameAndCount() {
        const {name, count} = this._optionsSet[0].optionsMeta;
        const required = this._optionsSet.map((it,ix)=>({
            it,
            ix
        })).filter(({it})=>it.isRequiredOption).map(({ix})=>ix);
        const dispCount = count - required.length;

        return {
            name,
            count,
            dispCount,
            required
        };
    }

    get modalTitle() {
        if (!this._isOptions())
            return null;

        const {dispCount, name} = this._getOptionsNameAndCount();
        return `Choose ${dispCount === 1 ? "" : `${dispCount} `}Option${dispCount === 1 ? "" : "s"}: ${name}${this._level != null ? ` (Level ${this._level})` : ""}`;
    }

    static _getLoadedTmpUid(loaded) {
        return `${loaded.page}__${loaded.hash}`;
    }

    _getSelectedLoadeds() {
        if (this._isOptions()) {
            const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, "ixsChosen");
            const {required} = this._getOptionsNameAndCount();
            return [...ixs, ...required].map(ix=>this._optionsSet[ix]);
        } else {
            return this._optionsSet;
        }
    }

    

    async pRender($wrp) {
        return this.render($wrp);
    }

    async _render_pHkIxsChosen({$stgSubChoiceData}) {
        try {
            await this._pLock("ixsChosen");
            await this._render_pHkIxsChosen_({
                $stgSubChoiceData
            });
        } finally {
            this._unlock("ixsChosen");
        }
    }

    async _render_pHkIxsChosen_({$stgSubChoiceData}) {
        const {prefixSubComps} = this._getProps();
        Object.keys(this._state).filter(k=>k.startsWith(prefixSubComps)).forEach(k=>delete this._state[k]);

        const selectedLoadeds = this._getSelectedLoadeds();

        if (!selectedLoadeds.length)
            return this._render_noSubChoices({
                $stgSubChoiceData
            });

        const isSubChoiceForceDisplay = await this._pIsSubChoiceForceDisplay(selectedLoadeds);
        const isSubChoiceAvailable = await this._pIsSubChoiceAvailable(selectedLoadeds);
        if (!isSubChoiceForceDisplay && !isSubChoiceAvailable)
            return this._render_noSubChoices({
                $stgSubChoiceData
            });

        $stgSubChoiceData.empty();
        this._unregisterSubComps();

        //TEMPFIX
        const sideDataRaws = null;//await this._pGetLoadedsSideDataRaws(selectedLoadeds);
        const ptrIsFirstSection = {_: true };

        for (let i = 0; i < selectedLoadeds.length; ++i) {
            const loaded = selectedLoadeds[i];

            if (!(await this._pIsSubChoiceForceDisplay([selectedLoadeds[i]]) || await this._pIsSubChoiceAvailable([selectedLoadeds[i]])))
                continue;
            //TEMPFIX
            const isSubChoice_sideDataChooseSystem = false; //await this._pHasChoiceInSideData_chooseSystem([selectedLoadeds[i]]);
            const isSubChoice_sideDataChooseFlags = false; //await this._pHasChoiceInSideData_chooseFlags([selectedLoadeds[i]]);

            const isForceDisplay_entryDataSkillToolLanguageProficiencies = await this._pIsForceDisplay_skillToolLanguageProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataSkillProficiencies = await this._pIsForceDisplay_skillProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataLanguageProficiencies = await this._pIsForceDisplay_languageProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataToolProficiencies = await this._pIsForceDisplay_toolProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataWeaponProficiencies = await this._pIsForceDisplay_weaponProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataArmorProficiencies = await this._pIsForceDisplay_armorProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataSavingThrowProficiencies = await this._pIsForceDisplay_savingThrowProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataDamageImmunities = await this._pIsForceDisplay_damageImmunities([selectedLoadeds[i]]);
            const isForceDisplay_entryDataDamageResistances = await this._pIsForceDisplay_damageResistances([selectedLoadeds[i]]);
            const isForceDisplay_entryDataDamageVulnerabilities = await this._pIsForceDisplay_damageVulnerabilities([selectedLoadeds[i]]);
            const isForceDisplay_entryDataConditionImmunities = await this._pIsForceDisplay_conditionImmunities([selectedLoadeds[i]]);
            const isForceDisplay_entryDataExpertise = await this._pIsForceDisplay_expertise([selectedLoadeds[i]]);
            const isForceDisplay_entryDataResources = await this._pIsForceDisplay_resources([selectedLoadeds[i]]);
            const isForceDisplay_entryDataSenses = await this._pIsForceDisplay_senses([selectedLoadeds[i]]);
            const isForceDisplay_entryDataAdditionalSpells = await this._pIsForceDisplay_additionalSpells([selectedLoadeds[i]]);

            const isAvailable_entryDataSkillToolLanguageProficiencies = await this._pIsAvailable_skillToolLanguageProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataSkillProficiencies = await this._pIsAvailable_skillProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataLanguageProficiencies = await this._pIsAvailable_languageProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataToolProficiencies = await this._pIsAvailable_toolProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataWeaponProficiencies = await this._pIsAvailable_weaponProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataArmorProficiencies = await this._pIsAvailable_armorProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataSavingThrowProficiencies = await this._pIsAvailable_savingThrowProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataDamageImmunities = await this._pIsAvailable_damageImmunities([selectedLoadeds[i]]);
            const isAvailable_entryDataDamageResistances = await this._pIsAvailable_damageResistances([selectedLoadeds[i]]);
            const isAvailable_entryDataDamageVulnerabilities = await this._pIsAvailable_damageVulnerabilities([selectedLoadeds[i]]);
            const isAvailable_entryDataConditionImmunities = await this._pIsAvailable_conditionImmunities([selectedLoadeds[i]]);
            const isAvailable_entryDataExpertise = await this._pIsAvailable_expertise([selectedLoadeds[i]]);
            const isAvailable_entryDataResources = await this._pIsAvailable_resources([selectedLoadeds[i]]);
            const isAvailable_entryDataSenses = await this._pIsAvailable_senses([selectedLoadeds[i]]);
            const isAvailable_entryDataAdditionalSpells = await this._pIsAvailable_additionalSpells([selectedLoadeds[i]]);

            const {entity, type} = loaded;

            if (i !== 0 || !this._isSkipRenderingFirstFeatureTitle)
                $stgSubChoiceData.append(this._render_getSubCompTitle(entity));

            //TEMPFIX
           /*  if (isSubChoice_sideDataChooseSystem) {
                const sideDataRaw = sideDataRaws[i];
                if (sideDataRaw?.chooseSystem) {
                    ptrIsFirstSection._ = false;
                    this._render_renderSubComp_chooseSystem(i, $stgSubChoiceData, entity, type, sideDataRaw);
                }
            }

            if (isSubChoice_sideDataChooseFlags) {
                const sideDataRaw = sideDataRaws[i];
                if (sideDataRaw?.chooseFlags) {
                    ptrIsFirstSection._ = false;
                    this._render_renderSubComp_chooseFlags(i, $stgSubChoiceData, entity, type, sideDataRaw);
                }
            } */

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsSkillToolLanguageProficiencies",
                propPrevSubComps: "_prevSubCompsSkillToolLanguageProficiencies",
                isAvailable: isAvailable_entryDataSkillToolLanguageProficiencies,
                isForceDisplay: isForceDisplay_entryDataSkillToolLanguageProficiencies,
                prop: "skillToolLanguageProficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                fnGetExistingFvtt: Charactermancer_OtherProficiencySelect.getExistingFvttFromActor.bind(Charactermancer_OtherProficiencySelect),
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsSkillProficiencies",
                propPrevSubComps: "_prevSubCompsSkillProficiencies",
                isAvailable: isAvailable_entryDataSkillProficiencies,
                isForceDisplay: isForceDisplay_entryDataSkillProficiencies,
                prop: "skillProficiencies",
                title: "Skill Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "skills"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsLanguageProficiencies",
                propPrevSubComps: "_prevSubCompsLanguageProficiencies",
                isAvailable: isAvailable_entryDataLanguageProficiencies,
                isForceDisplay: isForceDisplay_entryDataLanguageProficiencies,
                prop: "languageProficiencies",
                title: "Language Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "traits", "languages"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsToolProficiencies",
                propPrevSubComps: "_prevSubCompsToolProficiencies",
                isAvailable: isAvailable_entryDataToolProficiencies,
                isForceDisplay: isForceDisplay_entryDataToolProficiencies,
                prop: "toolProficiencies",
                title: "Tool Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "tools"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsWeaponProficiencies",
                propPrevSubComps: "_prevSubCompsWeaponProficiencies",
                isAvailable: isAvailable_entryDataWeaponProficiencies,
                isForceDisplay: isForceDisplay_entryDataWeaponProficiencies,
                prop: "weaponProficiencies",
                title: "Weapon Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "traits", "weaponProf"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsArmorProficiencies",
                propPrevSubComps: "_prevSubCompsArmorProficiencies",
                isAvailable: isAvailable_entryDataArmorProficiencies,
                isForceDisplay: isForceDisplay_entryDataArmorProficiencies,
                prop: "armorProficiencies",
                title: "Armor Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "traits", "armorProf"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsSavingThrowProficiencies",
                propPrevSubComps: "_prevSubCompsSavingThrowProficiencies",
                isAvailable: isAvailable_entryDataSavingThrowProficiencies,
                isForceDisplay: isForceDisplay_entryDataSavingThrowProficiencies,
                prop: "savingThrowProficiencies",
                title: "Saving Throw Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "abilities"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSavingThrowProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsDamageImmunities",
                propPrevSubComps: "_prevSubCompsDamageImmunities",
                isAvailable: isAvailable_entryDataDamageImmunities,
                isForceDisplay: isForceDisplay_entryDataDamageImmunities,
                prop: "immune",
                title: "Damage Immunities",
                ptrIsFirstSection,
                CompClass: Charactermancer_DamageImmunitySelect,
                propPathActorExistingProficiencies: ["system", "traits", "di"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsDamageResistances",
                propPrevSubComps: "_prevSubCompsDamageResistances",
                isAvailable: isAvailable_entryDataDamageResistances,
                isForceDisplay: isForceDisplay_entryDataDamageResistances,
                prop: "resist",
                title: "Damage Resistances",
                ptrIsFirstSection,
                CompClass: Charactermancer_DamageResistanceSelect,
                propPathActorExistingProficiencies: ["system", "traits", "dr"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsDamageVulnerabilities",
                propPrevSubComps: "_prevSubCompsDamageVulnerabilities",
                isAvailable: isAvailable_entryDataDamageVulnerabilities,
                isForceDisplay: isForceDisplay_entryDataDamageVulnerabilities,
                prop: "vulnerable",
                title: "Damage Vulnerabilities",
                ptrIsFirstSection,
                CompClass: Charactermancer_DamageVulnerabilitySelect,
                propPathActorExistingProficiencies: ["system", "traits", "dv"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsConditionImmunities",
                propPrevSubComps: "_prevSubCompsConditionImmunities",
                isAvailable: isAvailable_entryDataConditionImmunities,
                isForceDisplay: isForceDisplay_entryDataConditionImmunities,
                prop: "conditionImmune",
                title: "Condition Immunities",
                CompClass: Charactermancer_ConditionImmunitySelect,
                propPathActorExistingProficiencies: ["system", "traits", "ci"],
                ptrIsFirstSection,
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsExpertise",
                propPrevSubComps: "_prevSubCompsExpertise",
                isAvailable: isAvailable_entryDataExpertise,
                isForceDisplay: isForceDisplay_entryDataExpertise,
                prop: "expertise",
                title: "Expertise",
                ptrIsFirstSection,
                fnSetComp: this._render_pHkIxsChosen_setCompExpertise.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsResources",
                propPrevSubComps: "_prevSubCompsResources",
                isAvailable: isAvailable_entryDataResources,
                isForceDisplay: isForceDisplay_entryDataResources,
                prop: "resources",
                ptrIsFirstSection,
                fnSetComp: this._render_pHkIxsChosen_setCompResources.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsSenses",
                propPrevSubComps: "_prevSubCompsSenses",
                isAvailable: isAvailable_entryDataSenses,
                isForceDisplay: isForceDisplay_entryDataSenses,
                prop: "senses",
                ptrIsFirstSection,
                fnSetComp: this._render_pHkIxsChosen_setCompSenses.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsAdditionalSpells",
                propPrevSubComps: "_prevSubCompsAdditionalSpells",
                isAvailable: isAvailable_entryDataAdditionalSpells,
                isForceDisplay: isForceDisplay_entryDataAdditionalSpells,
                prop: "additionalSpells",
                ptrIsFirstSection,
                fnSetComp: this._render_pHkIxsChosen_setCompAdditionalSpells.bind(this),
            });
        }

        this._prevSubCompsSkillToolLanguageProficiencies = null;
        this._prevSubCompsSkillProficiencies = null;
        this._prevSubCompsLanguageProficiencies = null;
        this._prevSubCompsToolProficiencies = null;
        this._prevSubCompsWeaponProficiencies = null;
        this._prevSubCompsArmorProficiencies = null;
        this._prevSubCompsSavingThrowProficiencies = null;
        this._prevSubCompsDamageImmunities = null;
        this._prevSubCompsDamageResistances = null;
        this._prevSubCompsDamageVulnerabilities = null;
        this._prevSubCompsConditionImmunities = null;
        this._prevSubCompsExpertise = null;
        this._prevSubCompsResources = null;
        this._prevSubCompsSenses = null;
        this._prevSubCompsAdditionalSpells = null;

        $stgSubChoiceData.toggleVe(isSubChoiceForceDisplay);
    }

    _render_pHkIxsChosen_comp({ix, $stgSubChoiceData, propSubComps, propPrevSubComps, isAvailable, isForceDisplay, selectedLoadeds, prop, title, CompClass, propPathActorExistingProficiencies, ptrIsFirstSection, fnSetComp, fnGetMappedProficiencies, fnGetExistingFvtt, }, ) {
        this[propSubComps][ix] = null;
        if (!isAvailable)
            return;

        const {entity} = selectedLoadeds[ix];

        if (!entity?.[prop] && !entity?.entryData?.[prop])
            return;

        fnSetComp({
            ix,
            propSubComps,
            prop,
            CompClass,
            propPathActorExistingProficiencies,
            entity,
            fnGetMappedProficiencies,
            fnGetExistingFvtt,
        });

        if (this[propPrevSubComps] && this[propPrevSubComps][ix]) {
            this[propSubComps][ix]._proxyAssignSimple("state", MiscUtil.copy(this[propPrevSubComps][ix].__state));
        }

        if (!isForceDisplay)
            return;

        if (!title)
            title = this[propSubComps][ix]?.modalTitle;

        if (title)
            $stgSubChoiceData.append(`${ptrIsFirstSection._ ? "" : `<div class="w-100 mt-1 mb-2"></div>`}<div class="bold mb-2">${title}</div>`);
        this[propSubComps][ix].render($stgSubChoiceData);
        ptrIsFirstSection._ = false;
    }

    _render_pHkIxsChosen_setCompOtherProficiencies({ix, propSubComps, prop, CompClass, propPathActorExistingProficiencies, entity, fnGetMappedProficiencies, fnGetExistingFvtt, }, ) {
        const availableRaw = entity[prop] || entity.entryData[prop];
        const existingFvtt = fnGetExistingFvtt ? fnGetExistingFvtt() : {
            [prop]: MiscUtil.get(this._actor, ...propPathActorExistingProficiencies)
        };
        this[propSubComps][ix] = new CompClass({
            featureSourceTracker: this._featureSourceTracker,
            existing: CompClass.getExisting(existingFvtt),
            existingFvtt,
            available: fnGetMappedProficiencies ? fnGetMappedProficiencies(availableRaw) : availableRaw,
        });
    }

    _render_pHkIxsChosen_setCompExpertise({ix, propSubComps, prop, entity, }, ) {
        const existingFvtt = Charactermancer_ExpertiseSelect.getExistingFvttFromActor(this._actor);
        this[propSubComps][ix] = new Charactermancer_ExpertiseSelect({
            featureSourceTracker: this._featureSourceTracker,
            existing: Charactermancer_ExpertiseSelect.getExisting(existingFvtt),
            existingFvtt,
            available: entity[prop] || entity.entryData[prop],
        });
    }

    _render_pHkIxsChosen_setCompResources({ix, propSubComps, prop, entity, }, ) {
        this[propSubComps][ix] = new Charactermancer_ResourceSelect({
            resources: entity[prop] || entity.entryData[prop],
            className: entity.className,
            classSource: entity.classSource,
            subclassShortName: entity.subclassShortName,
            subclassSource: entity.subclassSource,
        });
    }

    _render_pHkIxsChosen_setCompSenses({ix, propSubComps, prop, entity, }, ) {
        const existingFvtt = Charactermancer_SenseSelect.getExistingFvttFromActor(this._actor);
        this[propSubComps][ix] = new Charactermancer_SenseSelect({
            existing: Charactermancer_SenseSelect.getExisting(existingFvtt),
            existingFvtt,
            senses: entity[prop] || entity.entryData[prop],
        });
    }

    _render_pHkIxsChosen_setCompAdditionalSpells({ix, propSubComps, prop, entity, }, ) {
        this[propSubComps][ix] = Charactermancer_AdditionalSpellsSelect.getComp({
            additionalSpells: entity[prop] || entity.entryData[prop],
            modalFilterSpells: this._modalFilterSpells,

            curLevel: 0,
            targetLevel: Consts.CHAR_MAX_LEVEL,
            spellLevelLow: 0,
            spellLevelHigh: 9,
        });
    }

    _getProps(ix) {
        return {
            prefixSubComps: "subComp_",
            propChooseSystem: `subComp_${ix}_chooseSystem`,
            propChooseFlags: `subComp_${ix}_chooseFlags`,
        };
    }

    _unregisterSubComps() {
        if (!this._featureSourceTracker)
            return;

        this._subCompsSkillToolLanguageProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsSkillProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsLanguageProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsToolProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsWeaponProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsArmorProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsSavingThrowProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsDamageImmunities.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsDamageResistances.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsDamageVulnerabilities.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsConditionImmunities.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsExpertise.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsResources.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsSenses.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsAdditionalSpells.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
    }

    _render_noSubChoices({$stgSubChoiceData}) {
        this._lastSubMetas.forEach(it=>it.unhook());
        this._lastSubMetas = [];

        this._unregisterSubComps();

        this._subCompsSkillToolLanguageProficiencies = [];
        this._subCompsSkillProficiencies = [];
        this._subCompsLanguageProficiencies = [];
        this._subCompsToolProficiencies = [];
        this._subCompsWeaponProficiencies = [];
        this._subCompsArmorProficiencies = [];
        this._subCompsSavingThrowProficiencies = [];
        this._subCompsDamageImmunities = [];
        this._subCompsDamageResistances = [];
        this._subCompsDamageVulnerabilities = [];
        this._subCompsConditionImmunities = [];
        this._subCompsExpertise = [];
        this._subCompsResources = [];
        this._subCompsSenses = [];
        this._subCompsAdditionalSpells = [];

        $stgSubChoiceData.empty().hideVe();
    }

    _render_options() {
        if (!this._isOptions())
            return;

        const {count, required} = this._getOptionsNameAndCount();

        const $ptsExisting = {};
        this._lastMeta = ComponentUiUtil.getMetaWrpMultipleChoice(this, "ixsChosen", {
            values: this._optionsSet,
            ixsRequired: required,
            count,
            fnDisplay: v=>{
                const ptName = Renderer.get().render(v.entry);

                const $ptExisting = $(`<div class="ml-1 ve-small ve-muted"></div>`);
                $ptsExisting[this.constructor._getLoadedTmpUid(v)] = $ptExisting;

                return $$`<div class="w-100 split-v-center">
						<div class="mr-2 ve-flex-v-center">${ptName}${$ptExisting}</div>
						<div class="${Parser.sourceJsonToColor(v.entity.source)} pr-1" title="${Parser.sourceJsonToFull(v.entity.source)}">${Parser.sourceJsonToAbv(v.entity.source)}</div>
					</div>`;
            }
            ,
        }, );

        const hkUpdatePtsExisting = ()=>{
            const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey("features", {
                ignore: this
            }) : null;

            this._optionsSet.forEach(v=>{
                const tmpUid = this.constructor._getLoadedTmpUid(v);

                if (!$ptsExisting[tmpUid])
                    return;

                let isExists = this._existingFeatureChecker && this._existingFeatureChecker.isExistingFeature(UtilEntityGeneric.getName(v.entity), v.page, v.source, v.hash);

                if (otherStates)
                    isExists = isExists || otherStates.some(arr=>arr.some(it=>it.page === v.page && it.hash === v.hash));

                $ptsExisting[tmpUid].title(isExists ? `Gained from Another Source` : "").html(isExists ? `(<i class="fas fa-fw fa-check"></i>)` : "").toggleClass("ml-1", isExists);
            }
            );
        }
        ;
        if (this._featureSourceTracker)
            this._featureSourceTracker.addHook(this, "pulseFeatures", hkUpdatePtsExisting);
        hkUpdatePtsExisting();

        if (this._featureSourceTracker) {
            const hkSetTrackerState = ()=>this._featureSourceTracker.setState(this, {
                features: this._getTrackableFeatures()
            });
            this._addHookBase(this._lastMeta.propPulse, hkSetTrackerState);
            hkSetTrackerState();
        }
    }

    _render_getSubCompTitle(entity) {
        const titleIntro = [entity.className, entity.subclassShortName ? `(${entity.subclassShortName})` : "", entity.level ? `Level ${entity.level}` : "", ].filter(Boolean).join(" ");
        const title = `${titleIntro}${titleIntro ? ": " : ""}${entity.name}`;
        return `${this._isModal ? "" : `<hr class="hr-2">`}<div class="mb-2 bold w-100">${title}</div>`;
    }

    _render_renderSubComp_chooseSystem(ix, $stgSubChoice, entity, type, sideData) {
        return this._render_renderSubComp_chooseSystemChooseFlags({
            ix,
            $stgSubChoice,
            entity,
            type,
            sideData,
            propChoose: "chooseSystem",
            propCompProp: "propChooseSystem",
            propIsRenderEntries: "isChooseSystemRenderEntries",
        });
    }

    _render_renderSubComp_chooseFlags(ix, $stgSubChoice, entity, type, sideData) {
        return this._render_renderSubComp_chooseSystemChooseFlags({
            ix,
            $stgSubChoice,
            entity,
            type,
            sideData,
            propChoose: "chooseFlags",
            propCompProp: "propChooseFlags",
            propIsRenderEntries: "isChooseFlagsRenderEntries",
        });
    }

    _render_renderSubComp_chooseSystemChooseFlags({ix, $stgSubChoice, entity, type, sideData, propChoose, propCompProp, propIsRenderEntries}) {
        const compProps = this._getProps(ix);

        const htmlDescription = sideData[propIsRenderEntries] ? Vetools.withUnpatchedDiceRendering(()=>`${(entity.entries || []).map(ent=>`<div>${Renderer.get().render(ent)}</div>`).join("")}`) : null;

        const choiceMeta = ComponentUiUtil.getMetaWrpMultipleChoice(this, compProps[propCompProp], {
            count: 1,
            fnDisplay: val=>val.name,
            values: sideData[propChoose],
        }, );

        this._lastSubMetas.push(choiceMeta);

        $$`<div class="ve-flex-col w-100">
			${htmlDescription}
			${choiceMeta.$ele}
		</div>`.appendTo($stgSubChoice);
    }

    _getDefaultState() {
        return {
            ixsChosen: [],
        };
    }

    static async pGetUserInput(opts) {
        const comp = new this({
            ...opts,
            featureSourceTracker: opts.featureSourceTracker || new Charactermancer_FeatureSourceTracker(),
            isModal: true,
        });
        if (await comp.pIsNoChoice()) {
            comp.render($(document.createElement("div")));
            return comp.pGetFormData();
        }

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            width: 640,
            height: Util.getMaxWindowHeight(),
            isAutoResize: true,
        });
    }

    static async pDoApplyProficiencyFormDataToActorUpdate(actor, actorUpdate, formData) {
        const formDataData = formData.data;
        if (!formDataData)
            return;

        const {DataConverter} = await Promise.resolve().then(function() {
            return DataConverter$1;
        });

        actorUpdate.system = actorUpdate.system || {};

        for (const formData of formDataData.formDatasSkillToolLanguageProficiencies || []) {
            DataConverter.doApplySkillFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "skills"),
                formData: formData,
                actorData: actorUpdate.system,
            });

            DataConverter.doApplyLanguageProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "languages"),
                formData,
                actorData: actorUpdate.system,
            });

            DataConverter.doApplyToolProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "tools"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasSkillProficiencies || []) {
            DataConverter.doApplySkillFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "skills"),
                formData: formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasLanguageProficiencies || []) {
            DataConverter.doApplyLanguageProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "languages"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasToolProficiencies || []) {
            DataConverter.doApplyToolProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "tools"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasWeaponProficiencies || []) {
            DataConverter.doApplyWeaponProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "weaponProf"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasArmorProficiencies || []) {
            DataConverter.doApplyArmorProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "armorProf"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasSavingThrowProficiencies || []) {
            DataConverter.doApplySavingThrowProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "abilities"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasDamageImmunities || []) {
            DataConverter.doApplyDamageImmunityFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "di"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasDamageResistances || []) {
            DataConverter.doApplyDamageResistanceFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "dr"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasDamageVulnerabilities || []) {
            DataConverter.doApplyDamageVulnerabilityFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "dv"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasConditionImmunities || []) {
            DataConverter.doApplyConditionImmunityFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "ci"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasExpertise || []) {
            DataConverter.doApplyExpertiseFormDataToActorUpdate({
                existingProfsActor: {
                    skillProficiencies: MiscUtil.get(actor, "_source", "system", "skills"),
                    toolProficiencies: MiscUtil.get(actor, "_source", "system", "tools"),
                },
                formData: formData,
                actorData: actorUpdate.system,
            });
        }
    }

    static async pDoApplyResourcesFormDataToActor({actor, formData}) {
        const formDataData = formData.data;

        if (!formDataData?.formDatasResources?.length)
            return;

        for (const formDataResources of formDataData.formDatasResources) {
            await Charactermancer_ResourceSelect.pApplyFormDataToActor(actor, formDataResources, );
        }
    }

    static async pDoApplySensesFormDataToActor({actor, actorUpdate, formData, configGroup}) {
        const formDataData = formData.data;
        if (!formDataData || !formDataData.formDatasSenses?.length)
            return;

        const {DataConverter} = await Promise.resolve().then(function() {
            return DataConverter$1;
        });

        actorUpdate.prototypeToken = actorUpdate.prototypeToken || {};
        actorUpdate.system = actorUpdate.system || {};

        for (const formData of formDataData.formDatasSenses || []) {
            DataConverter.doApplySensesFormDataToActorUpdate({
                existingSensesActor: MiscUtil.get(actor, "_source", "system", "attributes", "senses"),
                existingTokenActor: MiscUtil.get(actor, "_source", "prototypeToken"),
                formData: formData,
                actorData: actorUpdate.system,
                actorToken: actorUpdate.prototypeToken,
                configGroup,
            });
        }
    }

    static async pDoApplyAdditionalSpellsFormDataToActor({actor, formData, abilityAbv, parentAbilityAbv=null, taskRunner=null}) {
        const formDataData = formData.data;
        if (!formDataData || !formDataData.formDatasAdditionalSpells?.length)
            return;

        for (const formDataAdditionalSpells of formDataData.formDatasAdditionalSpells) {
            await Charactermancer_AdditionalSpellsSelect.pApplyFormDataToActor(actor, formDataAdditionalSpells, {
                taskRunner,
                abilityAbv,
                parentAbilityAbv,
            }, );
        }
    }
}
//#endregion

//#region CONSTS & SETTINGS

//#region SharedConsts
class SharedConsts {
    static MODULE_TITLE = "Plutonium";
    static MODULE_TITLE_FAKE = "SRD: Enhanced";
    static MODULE_ID = "plutonium";
    static MODULE_ID_FAKE = "srd5e";

    static PACK_NAME_CREATURES = "creatures";
    static PACK_NAME_SPELLS = "spells";
    static PACK_NAME_ITEMS = "items";

    static MODULE_LOCATION = `modules/${SharedConsts.MODULE_ID}`;

    static SYSTEM_ID_DND5E = "dnd5e";
}
//#endregion

//#region ConfigConsts
class ConfigConsts {
    static ["_flushCaches"]() {
      this._DEFAULT_CONFIG = null;
      this._DEFAULT_CONFIG_SORTED = null;
      this._DEFAULT_CONFIG_SORTED_FLAT = null;
    }
    static ['_IMPORTERS'] = {};
    static ["registerImporter"]({
      id: _0x17cd9e,
      name: _0x948c81
    }) {
      this._IMPORTERS[_0x17cd9e] = _0x948c81;
      this._flushCaches();
    }
    static ["_template_getImporterToggles"]() {
      return {
        'hiddenImporterIds': {
          'name': "Hidden Importers",
          'help': "Importers which should not be shown in the Import Wizard UI.",
          'default': {
            'background-features': true,
            'race-and-subrace-features': true
          },
          'type': 'multipleChoice',
          'choices': Object.entries(this._IMPORTERS).map(([_0x40fcfd, _0x286521]) => ({
            'name': _0x286521,
            'value': _0x40fcfd
          })).sort(({
            name: _0x5ca503
          }, {
            name: _0x44f71d
          }) => SortUtil.ascSortLower(_0x5ca503, _0x44f71d))
        }
      };
    }
    static ['_getModelBarAttributes'](_0x2c6d2c) {
      if (!_0x2c6d2c) {
        return [];
      }
      return Object.values(TokenDocument.implementation.getTrackedAttributeChoices(TokenDocument.implementation.getTrackedAttributes(_0x2c6d2c))).flat();
    }
    static ['_template_getEntityOwnership'](_0x1b27c6) {
      const _0x2971c8 = MiscUtil.copy(ConfigConsts._TEMPLATE_ENTITY_OWNERSHIP);
      _0x2971c8.values = Util.Fvtt.getOwnershipEnum();
      _0x2971c8.help = _0x1b27c6;
      return _0x2971c8;
    }
    static ["_template_getTokenSettings"]({
      actorType: _0x1701bd
    }) {
      return {
        'tokenNameDisplay': {
          'name': "Token Name Display Mode",
          'help': "The default Display Name mode for imported tokens.",
          'default': 0x14,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...Object.entries({
            ...CONST.TOKEN_DISPLAY_MODES
          }).sort(([, _0x11b4dd], [, _0x418ae3]) => SortUtil.ascSort(_0x11b4dd, _0x418ae3)).map(([_0x1c91ac, _0x536776]) => ({
            'value': _0x536776,
            'fnGetName': () => game.i18n.localize('TOKEN.DISPLAY_' + _0x1c91ac)
          }))]
        },
        'tokenDisposition': {
          'name': "Token Disposition",
          'help': "The default Token Disposition mode for imported tokens.",
          'default': -0x1,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...Object.entries(CONST.TOKEN_DISPOSITIONS).sort(([, _0x153b2c], [, _0x397446]) => SortUtil.ascSort(_0x153b2c, _0x397446)).map(([_0x2e1787, _0x29a452]) => ({
            'value': _0x29a452,
            'fnGetName': () => game.i18n.localize("TOKEN.DISPOSITION." + _0x2e1787)
          }))]
        },
        'tokenLockRotation': {
          'name': "Token Lock Rotation",
          'help': "The default Lock Rotation mode for imported tokens.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenIsAddVision': {
          'name': "Enable Token Vision",
          'help': "Enable vision for tokens.",
          'default': ConfigConsts.C_BOOL_ENABLED,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_BOOL_DISABLED,
            'name': "Disabled"
          }, {
            'value': ConfigConsts.C_BOOL_ENABLED,
            'name': 'Enabled'
          }]
        },
        'tokenSightRange': {
          'name': "Token Vision Range",
          'help': "How token Vision Range should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenSightVisionMode': {
          'name': "Token Vision Mode",
          'help': "How token Vision Mode should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenSightAngle': {
          'name': "Token Sight Angle",
          'help': "How token Sight Angle (Degrees) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenDetectionModes': {
          'name': "Token Detection Modes",
          'help': "How token Detection Modes should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenVisionSaturation': {
          'name': "Token Vision Saturation",
          'help': "How token vision Saturation should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenDimLight': {
          'name': "Token Dim Light Radius",
          'help': "How token Dim Light Radius (Distance) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenBrightLight': {
          'name': "Token Bright Light Radius",
          'help': "How token Bright Light Radius (Distance) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAngle': {
          'name': "Token Light Emission Angle",
          'help': "How token Light Emission (Angle) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightColor': {
          'name': "Token Light Color",
          'help': "How token Light Color should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAlpha': {
          'name': "Token Light Intensity",
          'help': "How token Color Intensity should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAnimationType': {
          'name': "Token Light Animation Type",
          'help': "How token Light Animation Type should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAnimationSpeed': {
          'name': "Token Light Animation Speed",
          'help': "How token Light Animation Speed should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAnimationIntensity': {
          'name': "Token Light Animation Intensity",
          'help': "How token Light Animation Intensity should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenBarDisplay': {
          'name': "Token Bar Display Mode",
          'help': "The default Display Bars mode for imported tokens.",
          'default': 0x28,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': 0x0,
            'name': "None"
          }, {
            'value': 0xa,
            'name': 'Control'
          }, {
            'value': 0x14,
            'name': "Owner Hover"
          }, {
            'value': 0x1e,
            'name': 'Hover'
          }, {
            'value': 0x28,
            'name': 'Owner'
          }, {
            'value': 0x32,
            'name': "Always"
          }]
        },
        'tokenBar1Attribute': {
          'name': "Token Bar 1 Attribute",
          'help': "The default token bar 1 attribute for imported tokens.",
          'default': "attributes.hp",
          'type': "enum",
          'values': () => [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...ConfigConsts._getModelBarAttributes(_0x1701bd)],
          'isNullable': true
        },
        'tokenBar2Attribute': {
          'name': "Token Bar 2 Attribute",
          'help': "The default token bar 2 attribute for imported tokens.",
          'default': null,
          'type': "enum",
          'values': () => [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...ConfigConsts._getModelBarAttributes(_0x1701bd)],
          'isNullable': true
        },
        'tokenScale': {
          'name': "Token Scale",
          'help': "The default token scale for imported tokens.",
          'default': null,
          'type': "number",
          'placeholder': "(Use default)",
          'min': 0.2,
          'max': 0x3,
          'isNullable': true
        },
        'isTokenMetric': {
          'name': "Convert Token Vision Ranges to Metric",
          'help': "Whether or not token vision range units should be converted to an approximate metric equivalent (5 feet ≈ 1.5 metres).",
          'default': false,
          'type': "boolean"
        }
      };
    }
    static ["_template_getSceneImportSettings"]() {
      return {
        'scenePadding': {
          'name': "Scene Padding",
          'help': "The amount of scene padding to apply when creating a scene.",
          'default': 0x0,
          'type': "number",
          'min': 0x0,
          'max': 0.5
        },
        'sceneBackgroundColor': {
          'name': "Scene Background Color",
          'help': "The background color to apply when creating a scene.",
          'default': "#222222",
          'type': "color"
        },
        'isSceneTokenVision': {
          'name': "Scene Token Vision",
          'help': "Whether or not token vision should be enabled for a created scene.",
          'default': true,
          'type': "boolean"
        },
        'isSceneFogExploration': {
          'name': "Scene Fog Exploration",
          'help': "Whether or not fog exploration should be enabled for a created scene.",
          'default': true,
          'type': "boolean"
        },
        'isSceneAddToNavigation': {
          'name': "Add Scenes to Navigation",
          'help': "Whether or not a created scene should be added to the navigation bar.",
          'default': false,
          'type': "boolean"
        },
        'isSceneGenerateThumbnail': {
          'name': "Generate Scene Thumbnails",
          'help': "Whether or not a thumbnail should be generated for a created scene. Note that this greatly slows down the scene creation process.",
          'default': true,
          'type': "boolean"
        },
        'isSceneGridMetric': {
          'name': "Convert Scene Grid Distances to Metric",
          'help': "Whether or not scene grid distances should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + "; " + ConfigConsts._DISP_METRIC_MILES + ').',
          'default': false,
          'type': "boolean"
        }
      };
    }
    static ["_template_getActiveEffectsDisabledTransferSettings"]({
      name: _0x535a83
    }) {
      return {
        'setEffectDisabled': {
          'name': "Override Effect &quot;Disabled&quot; Value",
          'help': "If set, overrides the \"Disabled\" value present on any effects tied to imported " + _0x535a83 + '.',
          'type': 'enum',
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'compatibilityModeValues': {
            [UtilCompat.MODULE_MIDI_QOL]: {
              'value': ConfigConsts.C_USE_PLUT_VALUE,
              'name': "Allow importer to set"
            }
          },
          'values': [{
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }, {
            'value': ConfigConsts.C_BOOL_DISABLED,
            'name': "Set to \"False\""
          }, {
            'value': ConfigConsts.C_BOOL_ENABLED,
            'name': "Set to \"True\""
          }]
        },
        'setEffectTransfer': {
          'name': "Override Effect &quot;Transfer&quot; Value",
          'help': "If set, overrides the \"Transfer to Actor\" value present on any effects tied to imported " + _0x535a83 + '.',
          'type': 'enum',
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'compatibilityModeValues': {
            [UtilCompat.MODULE_MIDI_QOL]: {
              'value': ConfigConsts.C_USE_PLUT_VALUE,
              'name': "Allow importer to set"
            }
          },
          'values': [{
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }, {
            'value': ConfigConsts.C_BOOL_DISABLED,
            'name': "Set to \"False\""
          }, {
            'value': ConfigConsts.C_BOOL_ENABLED,
            'name': "Set to \"True\""
          }]
        }
      };
    }
    static ["_template_getMinimumRole"]({
      name: _0x2cb847,
      help: _0x713a
    }) {
      const _0xdadcbd = MiscUtil.copy(ConfigConsts._TEMPALTE_MINIMUM_ROLE);
      _0xdadcbd.values = Util.Fvtt.getMinimumRolesEnum();
      _0xdadcbd.name = _0x2cb847;
      _0xdadcbd.help = _0x713a;
      return _0xdadcbd;
    }
    static ['_template_getModuleFauxCompendiumIndexSettings']({
      moduleName: _0x5afcb7
    }) {
      return {
        'isEnabled': {
          'name': "Enabled",
          'help': "If enabled, and the " + _0x5afcb7 + " module is active, Plutonium content will be indexed by " + _0x5afcb7 + '.',
          'default': true,
          'type': "boolean",
          'isReloadRequired': true
        },
        'isFilterSourcesUa': {
          'name': "Exclude UA/etc.",
          'help': "If Unearthed Arcana and other unofficial source content should be excluded from the index.",
          'default': true,
          'type': "boolean",
          'isReloadRequired': true
        }
      };
    }
    static ["_template_getActorImportOverwriteSettings"]() {
      return {
        'isDisableActorOverwriteWarning': {
          'name': "Disable Actor Overwrite Warning",
          'help': "Disable the warning confirmation dialogue shown when importing to an existing actor.",
          'default': false,
          'type': "boolean",
          'isPlayerEditable': true
        }
      };
    }
    static ["_template_getTargetTemplatePrompt"]({
      namePlural: _0x1f80cf
    }) {
      return {
        'isTargetTemplatePrompt': {
          'name': "Enable &quot;Template Prompt&quot;s",
          'help': "If enabled, the \"Template Prompt\" option will be set on imported " + _0x1f80cf + '.',
          'default': true,
          'type': "boolean",
          'isPlayerEditable': true
        }
      };
    }
    static ["_DEFAULT_CONFIG"] = null;
    static ["getDefaultConfig_"]() {
      return this._DEFAULT_CONFIG = this._DEFAULT_CONFIG || {
        'ui': {
          'name': 'UI',
          'settings': {
            'isStreamerMode': {
              'name': "Streamer Mode",
              'help': "Remove identifiable 5etools/Plutonium references from the UI, and replaces them with \"SRD Enhanced.\"",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true,
              'isPlayerEditable': true
            },
            'isShowPopout': {
              'name': "Enable Sheet Popout Buttons",
              'help': "Add a \"Popout\" button to sheet headers, which opens the sheet as a popup browser window.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isCompactWindowBar': {
              'name': "Compact Header Buttons",
              'help': "Re-style header buttons to better support the compact, no-text buttons used by Plutonium.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactDirectoryButtons': {
              'name': "Compact Directory Buttons",
              'help': "Reduce the height of \"Create X\"/\"Create Folder\" buttons in the directory, to offset the additional space requirements of Plutonium's UI.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactChat': {
              'name': "Compact Chat",
              'help': "Make various tweaks to the appearance of chat, in order to fit more on-screen. Hold down SHIFT while hovering over a message to expand it, revealing its header and delete button.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactScenes': {
              'name': "Compact Scenes Directory",
              'help': "Reduce the height of scene thumbnails in the Scenes Directory, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactActors': {
              'name': "Compact Actors Directory",
              'help': "Reduce the height of Actors Directory directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactItems': {
              'name': "Compact Items Directory",
              'help': "Reduce the height of Items Directory directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactJournal': {
              'name': "Compact Journal Entries",
              'help': "Reduce the height of Journal Entries directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactTables': {
              'name': "Compact Rollable Tables",
              'help': "Reduce the height of Rollable Tables directory items, to fit more on-screen.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isCompactCards': {
              'name': "Compact Card Stacks",
              'help': "Reduce the height of Card Stacks directory items, to fit more on-screen.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isCompactCompendiums': {
              'name': "Compact Compendium Packs",
              'help': "Reduce the height of Compendium Packs directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactMacros': {
              'name': "Compact Macros",
              'help': "Reduce the height of Macro directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isHidePlutoniumDirectoryButtons': {
              'name': "Hide Directory Buttons",
              'help': "Hide the Plutonium directory buttons.",
              'default': false,
              'type': 'boolean'
            },
            'isNameTabFromScene': {
              'name': "Prepend Active Scene Name to Browser Tab Name",
              'help': "Sets the browser tab name to be that of the currently-active scene.",
              'default': true,
              'type': 'boolean'
            },
            'tabNameSuffix': {
              'name': "Tab Name Suffix",
              'help': "Requires the \"Name Browser Tab After Active Scene\" option to be enabled. A custom name suffix to append to the scene name displayed in the tab (separated by a Foundry-style bullet character).",
              'default': null,
              'isNullable': true,
              'type': "string"
            },
            'isDisplayBackendStatus': {
              'name': "Display Detected Backend",
              'help': "Adds a cool green hacker tint to the Foundry \"anvil\" logo in the top-left corner of the screen if Plutonium's backend is detected.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isExpandActiveEffectConfig': {
              'name': "Enhance Active Effect Config UI",
              'help': "Adds a list of potential active effect attribute keys to the Configure Active Effect window's \"Effects\" tab, and a field for configuring priority.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_DAE]: false
              }
            },
            'isAddDeleteToSceneNavOptions': {
              'name': "Add \"Delete\" to Navbar Scene Context Menu",
              'help': "Adds a \"Delete\" option to the context menu found when right-clicking a scene in the navigation bar. Note that this does not include the currently-active scene.",
              'default': true,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'isHideGmOnlyConfig': {
              'name': "Hide GM-Only Config",
              'help': "If enabled, a player viewing the config will see only the limited subset of settings they are allowed to modify. If disabled, a player viewing the config will see all settings, regardless of whether or not they can modify those settings.",
              'default': true,
              'type': 'boolean'
            },
            'isDisableLargeImportWarning': {
              'name': "Disable Large Import Warning",
              'help': "Disable the warning confirmation dialogue shown when importing a large number of entities.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          },
          'settingsHacks': {
            'isFastAnimations': {
              'name': "Fast Animations",
              'help': "Increase the speed of various UI animations.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isFastTooltips': {
              'name': "Fast Tooltips",
              'help': "Increase the speed of tooltip animations, and reduce the delay before tooltips appear.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isFixEscapeKey': {
              'name': "Fix ESC Key",
              'help': "Bind the \"Escape\" key to (in this order): de-select active input fields; de-select selected canvas elements; close context menus; close individual windows in most-recently-active-first order; toggle the main menu.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isAddOpenMainMenuButtonToSettings': {
              'name': "Add \"Open Game Menu\" Button if &quot;Fix ESC Key&quot; Is Enabled",
              'help': "Add an alternate \"Open Game Menu\" button to the Settings tab if the \"Fix ESC Key\" Config option is enabled. This allows you to quickly open the main menu without first having to close all open windows.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isFixDrawingFreehandMinDistance': {
              'name': "Fix Freehand Drawing Minimum Distance",
              'help': "Reduce the minimum mouse movement distance required to start a freehand drawing.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isEnableIncreasedFolderDepth': {
              'name': "Render >3 Levels of Folder Nesting",
              'help': "If enabled, Foundry's default folder nesting limit (of 3) will be bypassed, for the purpose of rendering directories. Note that this does not necessarily allow you to create additionally-nested folders without using the game API.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_BETTER_ROLLTABLES]: false
              }
            },
            'isEnableFolderNameWrap': {
              'name': "Wrap Long Folder Names",
              'help': "Wrap long folder names over multiple lines, instead of clipping the name.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isEnableSubPopouts': {
              'name': "Allow Popout Chaining",
              'help': "Automatically pop out apps opened from within popped-out apps. If disabled, apps opened from within popped-out apps will appear in the main window, instead.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isSuppressMissingRollDataNotifications': {
              'name': "Suppress &quot;Missing Roll Data&quot; Notifications",
              'help': "If enabled, notification warning  messages of the form \"The attribute <X> was not present in the provided roll data.\" will be suppressed, and logged as console warnings instead.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isLazyActorAndItemRendering': {
              'name': "Minimize Actor/Item Re-Renders",
              'help': "If enabled, actor/item sheet re-rendering will be skipped where possible. This may reduce UI flickering, and may reduce unexpected input deselection when tabbing or clicking through fields. It may also horribly break your game, and is not expected to work with anything except default dnd5e sheets. Use with caution.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true,
              'isReloadRequired': true
            },
            'isAlwaysResizableApps': {
              'name': "Default Resizeable Applications",
              'help': "If enabled, applications will be resizeable by default. Note that specific applications may still override this.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          }
        },
        'tokens': {
          'name': 'Tokens',
          'settings': {
            'isDisplayDamageDealt': {
              'name': "Display Missing Health",
              'help': "This allows players to see \"damage dealt\" to a token, without revealing the token's total health. If enabled, each token's missing health is displayed as a number in the bottom-right corner of the token.",
              'default': false,
              'type': "boolean"
            },
            'damageDealtBloodiedThreshold': {
              'name': "Display Missing Health &quot;Wounded&quot; Threshold",
              'help': "The health-loss threshold at which the Missing Health text turns red.",
              'default': 0.5,
              'type': "percentage",
              'min': 0x0,
              'max': 0x1
            },
            'isDamageDealtBelowToken': {
              'name': "Missing Health Below Token",
              'help': "If the Missing Health text should be displayed beneath a token, rather than as an overlay.",
              'default': false,
              'type': 'boolean'
            },
            'nameplateFontSizeMultiplier': {
              'name': "Font Size Multiplier",
              'help': "A multiplier which is applied to token nameplate/tooltip font size, e.g. a value of \"0.5\" will decrease token nameplate/tooltip font size by half.",
              'default': null,
              'type': "number",
              'placeholder': "(Use default)",
              'min': 0.1,
              'max': 0xa,
              'isNullable': true
            },
            'isAllowNameplateFontWrap': {
              'name': "Allow Text Wrap",
              'help': "If enabled, token nameplate/tooltip text will wrap.",
              'default': ConfigConsts.C_USE_GAME_DEFAULT,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_USE_GAME_DEFAULT,
                'name': "Use Foundry default"
              }, {
                'value': false,
                'name': "Disabled"
              }, {
                'value': true,
                'name': 'Enabled'
              }]
            },
            'nameplateFontWrapWidthMultiplier': {
              'name': "Text Wrap Max Width Multiplier",
              'help': "A multiplier which is applied to token nameplate/tooltip text wrapping maximum size, e.g. a value of \"0.5\" will force token nameplates/tooltips to wrap at half their usual length. The base value to which this multiplier is applied is: \"2.5 × token width\".",
              'default': null,
              'type': "number",
              'placeholder': "(Use default)",
              'min': 0.1,
              'max': 0xa,
              'isNullable': true
            },
            'isNameplateOnToken': {
              'name': "Move Token Name Onto Token",
              'help': "If a token's name should be displayed on the token, rather than below it.",
              'default': false,
              'type': "boolean"
            },
            'npcHpRollMode': {
              'name': "NPC HP Roll Mode",
              'help': "Determines whether or not token HP, for NPC tokens which are not linked to their actor's data, should be rolled upon token creation. If a mode other than \"None\" is selected, and the token has a valid HP dice formula, the token will roll for HP. For example, a Goblin (7 HP; formula is 2d6) could be created with anywhere between 2 and 12 HP (inclusive).",
              'default': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE,
              'type': 'enum',
              'values': [{
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE,
                'name': "None",
                'help': "Do not roll NPC token health."
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_STANDARD,
                'name': "Standard Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_GM,
                'name': "GM Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_BLIND,
                'name': "Blind Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_SELF,
                'name': "Self Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_HIDDEN,
                'name': "Hidden Roll",
                'help': "Roll NPC token health, but do not post the result to chat."
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MIN,
                'name': "Minimum Value",
                'help': "Use the minimum possible roll value."
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MAX,
                'name': "Maximum Value",
                'help': "Use the maximum possible roll value."
              }]
            },
            'isDisableAnimations': {
              'name': "Disable Animations",
              'help': "Disable token animations.",
              'default': false,
              'type': "boolean"
            },
            'animationSpeedMultiplier': {
              'name': "Animation Speed",
              'help': "Multiplies token animation movement speed by the factor provided.",
              'default': null,
              'type': "number",
              'isNullable': true,
              'min': 0.1,
              'max': 0xa
            }
          },
          'settingsAdvanced': {
            'missingHealthAttribute': {
              'name': "Health Attribute",
              'help': "The sheet attribute used to fetch current/max health when the \"Display Missing Health\" option is enabled.",
              'default': "attributes.hp",
              'type': "string",
              'additionalStyleClasses': "code"
            }
          },
          'settingsHacks': {
            'isIgnoreDisableAnimationsForWaypointMovement': {
              'name': "Avoid Disabling Animations for Ruler Movement",
              'help': "Suppresses the \"Disable Animations\" option for a token being moved via ruler waypoints (i.e. when CTRL-dragging from a token and pressing SPACE). Note that dismissing the ruler during the move will end this suppression.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'import': {
          'name': "Import",
          'settings': {
            'isAddSourceToName': {
              'name': "Add Source to Names",
              'help': "If the source of each imported entry (e.g. \"MM\" for Monster Manual) should be appended to the name of the entry.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isRenderLinksAsTags': {
              'name': "Render Links as &quot;@tag&quot;s",
              'help': "If links found in description text should be rendered as Plutonium-specific @tag syntax, e.g. a link to \"goblin\" would be rendered as \"@creature[goblin|mm]\". (By default, a link to the 5etools page will be rendered instead.)",
              'default': true,
              'type': 'boolean'
            },
            'isRendererLinksDisabled': {
              'name': "Disable 5etools Links",
              'help': "Prevents links to other 5etools content from being added to the text of imported 5etools content.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isRendererDiceDisabled': {
              'name': "Render Dice as Plain Text",
              'help': "Forces dice expressions, usually rendered as \"[[/r XdY + Z ...]]\", to be rendered as plain text when importing 5etools content.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isRenderCustomDiceEnrichers': {
              'name': "Render Dice as Custom Enrichers",
              'help': "If enabled, importers will make use of dnd5e-specific custom enrichers when rendering dice. For example, damage rolls may be rendered as \"[[/damage ...]]\" instead of \"[[/r ...]]\", changing the on-click behaviour.",
              'default': true,
              'type': 'boolean'
            },
            'deduplicationMode': {
              'name': "Duplicate Handling Mode",
              'help': "Determines what action is taken when importing duplicate content to a directory or compendium. An entity is considered a duplicate if and only if its name and source match an existing entity. Note that this does not function when importing to actor sheets.",
              'default': ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE,
                'name': "None",
                'help': "No deduplication is done."
              }, {
                'value': ConfigConsts.C_IMPORT_DEDUPE_MODE_SKIP,
                'name': "Skip duplicates",
                'help': "If a duplicate is found for a would-be imported entity, that entity is not imported."
              }, {
                'value': ConfigConsts.C_IMPORT_DEDUPE_MODE_OVERWRITE,
                'name': "Update existing",
                'help': "If a duplicate is found for a would-be import entity, the existing entity is updated."
              }]
            },
            'isDuplicateHandlingMaintainImage': {
              'name': "Maintain Images when Overwriting Duplicates",
              'help': "If enabled, sheet and token images will be maintained when overwriting an existing document in \"Update Existing\" Duplicate Handling Mode.",
              'default': false,
              'type': 'boolean'
            },
            /* 'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Import",
              'help': "\"Import\" buttons will be hidden for any user with a role less than the chosen role."
            }), */
            'dragDropMode': {
              'name': "Use Importer when Drag-Dropping Items to Actors",
              'help': "Some Foundry items (backgrounds, races, spells, items, etc.), when imported via Plutonium and later drag-dropped to an actor sheet, have special handling allowing for greater functionality (such as populating skills and features). This allows you to control whether or not that special handling is used, rather than the baseline Foundry drag-drop. Note that if you modify an item, the changes will not be reflected in the version imported to the sheet by Plutonium.",
              'default': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_NEVER,
                'name': "Never"
              }, {
                'value': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT,
                'name': "Prompt"
              }, {
                'value': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_ALWAYS,
                'name': "Always"
              }],
              'isPlayerEditable': true
            },
            'isUseOtherFormulaFieldForSaveHalvesDamage': {
              'name': "Treat &quot;Save Halves&quot; Additional Attack Damage as &quot;Other Formula&quot;",
              'help': "This moves extra attack damage rolls (for example, the poison damage done by a Giant Spider's bite) to the \"Other Formula\" dice field, which can improve compatibility with some modules.",
              'default': false,
              'type': 'boolean',
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isUseOtherFormulaFieldForOtherDamage': {
              'name': "Treat &quot;Alternate&quot; Attack Damage as &quot;Other Formula&quot;",
              'help': "This moves alternate non-versatile attack damage rolls (for example, Egg Hunter Hatchling's &quot;Egg Tooth&quot; damage when targeting an object) to the \"Other Formula\" dice field, which can improve compatibility with some modules.",
              'default': false,
              'type': 'boolean',
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isGlobalMetricDistance': {
              'name': "Prefer Metric Distance/Speed (Where Available)",
              'help': "If enabled, metric distance/speed units will be preferred, where the importer supports them. Enabling this option effectively overrides all other metric distance/speed options, causing the importer to treat each as though it was enabled.",
              'default': false,
              'type': 'boolean'
            },
            'isGlobalMetricWeight': {
              'name': "Prefer Metric Weight (Where Available)",
              'help': "If enabled, metric weight units will be preferred, where the importer supports them. Enabling this option effectively overrides all other metric weight options, causing the importer to treat each as though it was enabled.",
              'default': false,
              'type': "boolean"
            },
            'isShowVariantsInLists': {
              'name': "Show Variants/Versions",
              'help': "If variants/versions of base entries should be shown in list views (with grayed-out names).",
              'default': true,
              'type': "boolean"
            },
            'isSaveImagesToServer': {
              'name': "Save Imported Images to Server",
              'help': "If images referenced in imported content should be saved to your server files, rather than referenced from an external server.",
              'default': false,
              'type': "boolean"
            },
            'isSaveTokensToServer': {
              'name': "Save Imported Tokens to Server",
              'help': "If tokens for imported actors should be saved to your server files, rather than referenced from an external server.",
              'default': true,
              'type': "boolean"
            },
            'localImageDirectoryPath': {
              'name': "Image/Token Directory",
              'help': "The sub-directory of the \"User Data\" directory where imported images/tokens will be saved to when using the \"Save Imported Images to Server\" option or the \"Save Imported Tokens to Server\" option. If the \"Use Local Images\" option is enabled, images will be loaded from this directory by default.",
              'default': "assets/" + SharedConsts.MODULE_ID_FAKE,
              'type': "string",
              'additionalStyleClasses': 'code'
            },
            'isPreferFoundryImages': {
              'name': "Prefer Foundry/System Images",
              'help': "If enabled, portraits for actors and images for items will be sourced from built-in compendiums first, then Plutonium second. If disabled, portraits/images will be sourced from Plutonium first, then built-in compendiums second.",
              'default': false,
              'type': "boolean"
            },
            'isPreferFoundryTokens': {
              'name': "Prefer Foundry/System Tokens",
              'help': "If enabled, tokens will be sourced from built-in compendiums first, then Plutonium second. If disabled, tokens will be sourced from Plutonium first, then built-in compendiums second.",
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getImporterToggles(),
            'isTreatJournalEntriesAsFolders': {
              'name': "Treat Journal Entries as Folders",
              'help': "If enabled, Journal Entries are treated as an additional folder level for the purpose of organising imports, etc.",
              'default': true,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isUseLocalImages': {
              'name': "Use Local Images",
              'help': "If enabled, images will be sourced from the \"Image/Token Directory\" directory, defined above.",
              'default': false,
              'type': 'boolean'
            },
            'isStrictMatching': {
              'name': "Use Strict Entity Matching",
              'help': "If enabled, any Plutonium feature which searches for existing data (for example, the class importer attempting to find existing class levels in a given class) will match by name and source. If disabled, only name is used.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'tempFolderName': {
              'name': "Temp Folder Name",
              'help': "The name of a temporary folder created/deleted by some operations. Note that the importer will delete this folder regardless of its contents, as anything contained within it is assumed to be a temporary entity created by the importer.",
              'type': 'string',
              'default': "Temp"
            },
            'isAutoAddAdditionalFonts': {
              'name': "Automatically Add Extra Fonts",
              'help': "If enabled, and you import content which requires additional fonts, these fonts will be added to your game's \"Additional Fonts\" setting.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importCreature': {
          'name': "Import (Creatures)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported creature."),
            'isImportBio': {
              'name': "Import Fluff to Biography",
              'help': "If enabled, any fluff text which is available for a creature will be imported into that creature's biography.",
              'default': true,
              'type': "boolean"
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Biography",
              'help': "If enabled, any fluff image which is available for a creature will be imported into that creature's biography.",
              'default': false,
              'type': 'boolean'
            },
            'isImportBioVariants': {
              'name': "Include Variants in Biography",
              'help': "If enabled, any inset variant boxes associated with a creature will be imported into that creature's biography.",
              'default': true,
              'type': "boolean"
            },
            'isImportVariantsAsFeatures': {
              'name': "Import Variants as Features",
              'help': "If enabled, any inset variant boxes associated with a creature will be imported into that creature's features.",
              'default': false,
              'type': "boolean"
            },
           /*  ...ConfigConsts._template_getTokenSettings({
              'actorType': "npc"
            }), */
            'itemWeightAndValueSizeScaling': {
              'name': "Item Weight & Value Scaling",
              'help': "The method by which to scale the weights and values of non-standard-sizes items carried by creatures.",
              'default': 0x1,
              'type': 'enum',
              'values': [{
                'value': 0x1,
                'name': "No scaling"
              }, {
                'value': 0x2,
                'name': "\"Barding\" scaling (multiplicative)",
                'help': "Based on the rules for calculating the weight and cost of barding, as presented in the Player's Handbook (p. 155)."
              }, {
                'value': 0x3,
                'name': "\"Gurt's Greataxe\" scaling (exponential)",
                'help': "Based on the giant-size greateaxe of the same name found in Storm King's Thunder (p. 234)."
              }]
            },
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not creature speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            },
            'spellcastingPrimaryTraitMode': {
              'name': "Spellcasting Primary Trait Selection Method",
              'help': "The method by which a primary spellcasting trait (i.e., the spellcasting trait used to set spellcasting ability, spell DC, and spell attack bonus) is selected if a creature has multiple spellcasting traits with associated ability scores.",
              'default': 0x1,
              'type': 'enum',
              'values': [{
                'value': 0x1,
                'name': "Highest spell count",
                'help': "Use whichever spellcasting trait has the most spells listed."
              }, {
                'value': 0x2,
                'name': "Highest ability score",
                'help': "Use whichever spellcasting trait has the highest associated ability score. Note that this may prefer innate spellcasting traits over spellcasting class levels."
              }]
            },
            'nameTags': {
              'name': "Add Tag Suffixes to Names",
              'help': "Add tags to an imported creature's name, to allow easier searching (especially within compendiums).",
              'default': {
                [ConfigConsts.C_CREATURE_NAMETAGS_CR]: false,
                [ConfigConsts.C_CREATURE_NAMETAGS_TYPE]: false,
                [ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS]: false
              },
              'type': 'multipleChoice',
              'choices': [{
                'value': ConfigConsts.C_CREATURE_NAMETAGS_CR,
                'name': "Add [CR] tag"
              }, {
                'value': ConfigConsts.C_CREATURE_NAMETAGS_TYPE,
                'name': "Add [type] tag"
              }, {
                'value': ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS,
                'name': "Add [type (with tags)] tag"
              }]
            },
            'isAddSoundEffect': {
              'name': "MLD: Add Audio as Sound Effect",
              'help': "If, when the Monk's Little Details module is active, an imported creature should have its sound effect set, where an audio clip is available (for official data, this will usually be an audio clip of the creature's name being pronounced).",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Creature Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CREATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums (Features)",
              'help': "A comma-separated list of compendiums that the Creature Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CREATURE_FEATURES.join(", "),
              'type': 'string',
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'isUseTokenImageAsPortrait': {
              'name': "Use Token Image as Portrait",
              'help': "If enabled, a creature's token image will be preferred over its portrait image when populating its sheet portrait during import.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getActorImportOverwriteSettings(),
            'isAddFakeClassToCharacter': {
              'name': "Add Class to Creatures Imported as Player Characters",
              'help': "If enabled, when importing a creature as a Player Character (\"character\"-type actor) a class item will be added to the actor's sheet, in order to set proficiency bonus and spellcasting levels.",
              'default': true,
              'type': 'boolean'
            },
            'isUseStaticAc': {
              'name': "Use Static AC Values",
              'help': "If enabled, creature AC will be imported as a static number (rather than relying on the sheet's formula calculation), and creature armor will be imported as unequipped.",
              'default': false,
              'type': "boolean"
            },
            'isUseCustomNaturalAc': {
              'name': "Use Custom Natural Armor Formula",
              'help': "If enabled, creatures with natural armor will have their armor formula broken down as \"@attributes.ac.armor + @attributes.ac.dex + <naturalBonus>\", allowing any later Dexterity score changes to be reflected in the creatures AC.",
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsHacks': {
            'isUsePathfinderTokenPackBestiariesImages': {
              'name': "Use &quot;Pathfinder Token Pack: Bestiaries&quot; Tokens/Portraits",
              'help': "If enabled, and the \"Pathfinder Token Pack: Bestiaries\" module is installed and enabled, the importer will attempt to use token and portrait art from the \"Pathfinder Token Pack: Bestiaries\" module.",
              'default': false,
              'type': "boolean"
            }
          }
        },
        'importCreatureFeature': {
          'name': "Import (Creature Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported creature feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "creature features"
            }), */
            'isSecretWrapAttacks': {
              'name': "&quot;Secret&quot; Attack Descriptions",
              'help': "If enabled, creature attack descriptions will be wrapped in \"Secret\" blocks, which are not shown when rolling.",
              'default': false,
              'type': "boolean"
            },
            'isScaleToTargetActor': {
              'name': "Scale to Target Actor CR",
              'help': "If enabled, creature features imported to existing NPC actors will be automatically scaled (altering to-hit bonuses, damage rolls, DCs, etc.) based on the difference between the original creature's CR and the target actor's CR.",
              'default': true,
              'type': 'boolean'
            },
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not creature feature range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "creature features"
            }),
            'isSplitMeleeRangedAttack': {
              'name': "Split &quot;Melee or Ranged Attack&quot; Actions",
              'help': "If enabled, the importer will create two sheet items per \"Melee or Ranged Attack\" action, each with the appropriate range set.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isSplitConditionalDamageAttack': {
              'name': "Split Conditional Damage Actions",
              'help': "If enabled, the importer will create two sheet items (\"Base\" and \"Full\") per \"... plus <x> damage if <y>\" action, where the \"base\" item does not include the conditional damage, and the \"full\" item does include the conditional damage.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isPreferFlatSavingThrows': {
              'name': "Prefer Flat Saving Throws",
              'help': "If enabled, a saving throw for a sheet item will always have \"flat\" scaling, with the flat DC value set to match the number in the creature's stat block. If disabled, a sheet item's saving throw scaling may be set as an ability score, provided that doing so produces the same value for the DC as is listed in the creature's stat block.",
              'default': false,
              'type': "boolean"
            }
          }
        },
        'importVehicle': {
          'name': "Import (Vehicles)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported vehicle."),
            ...ConfigConsts._template_getTokenSettings({
              'actorType': "vehicle"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not vehicle speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + "; " + ConfigConsts._DISP_METRIC_MILES + ').',
              'default': false,
              'type': "boolean"
            },
            'isImportBio': {
              'name': "Import Fluff to Description",
              'help': "If enabled, any fluff text which is available for a vehicle will be imported into that vehicle's description.",
              'default': true,
              'type': 'boolean'
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Description",
              'help': "If enabled, any fluff image which is available for a vehicle will be imported into that vehicle's description.",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the vehicle importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': '',
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'isUseTokenImageAsPortrait': {
              'name': "Use Token Image as Portrait",
              'help': "If enabled, a vehicle's token image will be preferred over its portrait image when populating its sheet portrait during import.",
              'default': false,
              'type': 'boolean'
            },
            ...ConfigConsts._template_getActorImportOverwriteSettings(),
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': 'vehicles'
            })
          }
        },
        'importVehicleUpgrade': {
          'name': "Import (Vehicle Upgrades)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported vehicle upgrades."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "vehicle upgrades"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not vehicle upgrade speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "vehicle upgrades"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a vehicle upgrade's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importObject': {
          'name': "Import (Objects)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported object."),
            ...ConfigConsts._template_getTokenSettings({
              'actorType': 'vehicle'
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not object speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            },
            'isImportBio': {
              'name': "Import Fluff to Description",
              'help': "If enabled, any fluff text which is available for an object will be imported into that object's description.",
              'default': true,
              'type': "boolean"
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Description",
              'help': "If enabled, any fluff image which is available for an object will be imported into that object's description.",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'isUseTokenImageAsPortrait': {
              'name': "Use Token Image as Portrait",
              'help': "If enabled, an object's token image will be preferred over its portrait image when populating its sheet portrait during import.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getActorImportOverwriteSettings()
          }
        },
        'importObjectFeature': {
          'name': "Import (Object Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported object feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "object features"
            }), */
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not object feature range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "object features"
            })
          }
        },
        'importFeat': {
          'name': "Import (Feats)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported feat."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': 'feats'
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not feat speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "feats"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a feat's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importBackground': {
          'name': "Import (Backgrounds)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported background.")
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums (Backgrounds)",
              'help': "A comma-separated list of compendiums that the background importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums (Features)",
              'help': "A comma-separated list of compendiums that the background importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "backgrounds"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a background's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importBackgroundFeature': {
          'name': "Import (Background Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported background feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "background features"
            }) */
          }
        },
        'importClass': {
          'name': "Import (Classes & Subclasses)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported class or subclass."),
            'isAddUnarmedStrike': {
              'name': "Add Unarmed Strike",
              'help': "If enabled, importing a class to an actor will create an \"Unarmed Strike\" weapon, unless one already exists.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isImportClassTable': {
              'name': "Import Class Table to Description",
              'help': "If enabled, a class's table will be imported as part of the class item's description.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isAddLevelUpButton': {
              'name': "Add &quot;Level Up&quot; Button to Character Sheets",
              'help': "If enabled, a \"Level Up\" button will be displayed in the top-right corner of a character's sheet (assuming the default dnd5e sheet is used).",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isSetXp': {
              'name': "Set Minimum Actor XP on Class Import",
              'help': "If enabled, during class import, actor XP will be set to the minimum XP value required for the actor's new level, if the actor's current XP is insufficient for them to reach their new level.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'hpIncreaseMode': {
              'name': "Hit Points Increase Mode",
              'help': "Determines how Hit Points are calculated when using the Class Importer to level up. If left unspecified, a user will be prompted to choose the mode each time their Hit Points are increased by the Class Importer.",
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE]
              }],
              'default': null,
              'isNullable': true
            },
            'hpIncreaseModeCustomRollFormula': {
              'name': "Hit Points Increase Custom Roll Formula",
              'help': "A custom roll formula to be used when gaining HP on level up. Used if either the \"Hit Points Increase Mode\" option is set to \"" + ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM] + "\", or if a player chooses \"" + ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM] + "\" when prompted to select their Hit Points Increase Mode. Use \"@hd.faces\" for the type of dice (i.e., the \"8\" in \"1d8\"), and \"@hd.number\" for \"number of dice\" (i.e., the \"1\" in \"1d8\"). Note that backticks (`) around an expression will also be replaced so \"`@hd.number`d`@hd.faces`\" will produce e.g. \"1d8\", should you need to avoid using brackets.",
              'placeholder': "(@hd.number)d(@hd.faces)",
              'type': "string",
              'additionalStyleClasses': "code",
              'default': null,
              'isNullable': true
            }
          },
          'settingsAdvanced': {
            'isDisplayOnLevelZeroCharacters': {
              'name': "Display &quot;Level Up&quot; Button on New Characters",
              'help': "If enabled, the \"Level Up\" button will be displayed on character actors with no levels.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isLevelUpButtonDisabledUntilEnoughExperience': {
              'name': "Disable the &quot;Level Up&quot; Button Until Character Has Enough XP",
              'help': "If enabled, the \"Level Up\" button will be disabled (though still visible) on characters who do not have sufficient XP to level up.",
              'default': true,
              'type': 'boolean'
            },
            'isLegacyLevelUpButton': {
              'name': "Prefer legacy &quot;Level Up&quot; Button",
              'help': "If disabled, the \"Level Up\" button will attempt to open the Charactermancer, a Patron-only feature which requires you to log in. If enabled, a dialogue of options will be presented, via which the Class Importer can be directly invoked.",
              'default': true,
              'type': "boolean"
            },
            'additionalDataCompendiumClasses': {
              'name': "Additional Data Compendiums (Classes)",
              'help': "A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CLASSES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumSubclasses': {
              'name': "Additional Data Compendiums (Subclasses)",
              'help': "A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_SUBCLASSES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums (Features)",
              'help': "A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CLASS_FEATURES.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "class"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a class's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            },
            'isUseDefaultSubclassImage': {
              'name': "Subclass Default Image Fallback",
              'help': "If enabled, when importing a subclass which has no well-defined image, use a default image based on class. If disabled, a generic black and white image will be used as a fallback instead.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isHideSubclassRows': {
              'name': "Hide Subclasses in Class Importer",
              'help': "If enabled, the class/subclass list in the Class Importer will only show classes.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            }
          }
        },
        'importClassSubclassFeature': {
          'name': "Import (Class & Sub. Features)",
          'help': "Import (Class & Subclass Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported class/subclass feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "class/subclass features"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not class/subclass feature speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "class features"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a class/subclass feature's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importItem': {
          'name': "Import (Items)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported item."),
            'isAddActiveEffects': {
              'name': "Populate Active Effects",
              'help': "If items should have active effects created during import.",
              'default': true,
              'type': 'boolean'
            },
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not item range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            },
            'isMetricWeight': {
              'name': "Convert Item Weights to Metric",
              'help': "Whether or not item weight units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_POUNDS + ').',
              'default': false,
              'type': 'boolean'
            },
            'inventoryStackingMode': {
              'name': "Inventory Stacking Mode",
              'help': "If imported items should \"stack\" with existing items when imported to an actor's inventory. If stacking is allowed, the importer will check for an existing item when importing an item to an actor's sheet. If the item already exists, the importer will increase the quantity of that item in the actor's inventory, rather than create a new copy of the item in the actor's inventory.",
              'default': ConfigConsts.C_ITEM_ATTUNEMENT_SMART,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_NEVER,
                'name': "Never Stack"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_SMART,
                'name': "Sometimes Stack (e.g. consumables, throwables)"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_ALWAYS,
                'name': "Always Stack"
              }]
            },
            'isSplitPacksActor': {
              'name': "Import Packs to Actors as Constituent Items",
              'help': "If \"pack\" items (explorer's pack, dungeoneer's pack) should be broken down and imported as their constituent items when importing to an actor's items.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isSplitAtomicPacksActor': {
              'name': "Import Item Stacks to Actors as Constituent Items",
              'help': "If an item which is formed of multiple constituent items of the same type, such as \"Bag of Ball Bearings (1,000)\", should be split up into its constituent items (a \"Ball Bearing\" item with its sheet quantity set to 1,000, in this example).",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'throwables': {
              'name': "Throwing Items",
              'help': "A list of items which are imported with their usage set to deplete their own quantity when used.",
              'default': ["Handaxe", "Javelin", "Light Hammer", "Dart", 'Net'],
              'type': 'arrayStringShort',
              'isPlayerEditable': true
            },
            'altAbilityScoreByClass': {
              'name': "Alt Ability Scores by Class",
              'help': "A list of <class>-<item>-<score> mappings, an entry in which, when importing an item, will change the default ability score used by an item for a member of that class.",
              'default': ['monk:club:dex', "monk:dagger:dex", 'monk:handaxe:dex', "monk:javelin:dex", "monk:light hammer:dex", "monk:mace:dex", "monk:quarterstaff:dex", 'monk:shortsword:dex', 'monk:sickle:dex', "monk:spear:dex"],
              'type': "arrayStringShort",
              'isPlayerEditable': true
            },
            'attunementType': {
              'name': "Attunement when Importing to Directory/Compendium",
              'help': "The attunement type to use when importing an item which can be attuned.",
              'default': ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
              'type': 'enum',
              'values': [{
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_NONE,
                'name': "None"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
                'name': "Attunement required"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
                'name': "Attuned"
              }]
            },
            'attunementTypeActor': {
              'name': "Attunement when Importing to Actors",
              'help': "The attunement type to use when importing an item which can be attuned.",
              'default': ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_NONE,
                'name': "None"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
                'name': "Attunement required"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
                'name': "Attuned"
              }]
            },
            'isImportDescriptionHeader': {
              'name': "Include Damage, Properties, Rarity, and Attunement in Description",
              'help': "If enabled, an imported item's description will include text generated from its rarity, attunement requirements, damage, and other properties.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isUseOtherFormulaFieldForExtraDamage': {
              'name': "Treat Extra Damage as &quot;Other Formula&quot;",
              'help': "This moves extra damage rolls to the \"Other Formula\" dice field, which can improve compatibility with some modules.",
              'default': false,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Item Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_ITEMS.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            'replacementDataCompendium': {
              'name': "Replacement Data Compendiums",
              'help': "A comma-separated list of compendiums that the Item Importer will attempt to pull items from, rather than using the data Plutonium would otherwise generate. This is useful when the Item Importer is used by other importers, e.g. when the Creature Importer is adding items to newly-created actors.",
              'default': '',
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "items"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, an item's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importPsionic': {
          'name': "Import (Psionics)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported psionic."),
            'psiPointsResource': {
              'name': "Psi Points Resource",
              'help': "The resource consumed by psionics.",
              'default': "resources.primary",
              'type': "enum",
              'values': [{
                'value': "resources.primary"
              }, {
                'value': 'resources.secondary'
              }, {
                'value': "resources.tertiary"
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM,
                'name': "\"Psi Points\" sheet item"
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM,
                'name': "Custom (see below)"
              }],
              'isPlayerEditable': true
            },
            'psiPointsResourceCustom': {
              'name': "Psi Points Custom Resource",
              'help': "The name of the custom resource to use if \"Custom\" is selected for \"Psi Points Resource\", above. This supports modules that expand the number of available sheet resources, such as \"5e-Sheet Resources Plus\" (which adds e.g. \"resources.fourth\", \"resources.fifth\", ...).",
              'type': 'string',
              'additionalStyleClasses': 'code',
              'default': null,
              'isNullable': true,
              'isPlayerEditable': true
            },
            'isImportAsSpell': {
              'name': "Import as Spells",
              'help': "If enabled, psionics will be imported as spells, rather than features.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "psionics"
            })
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': 'psionic'
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a psionic's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importRace': {
          'name': "Import (Races)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported race."),
           /*  ...ConfigConsts._template_getTokenSettings({
              'actorType': "character"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not race speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the race importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "races"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a race's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importRaceFeature': {
          'name': "Import (Race Features)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported race feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "race features"
            }) */
          },
          'settingsAdvanced': {
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the race feature importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "race features"
            })
          }
        },
        'importTable': {
          'name': "Import (Table)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported table.")
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Table Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_TABLES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': 'code',
              'isNullable': true
            }
          }
        },
        'importSpell': {
          'name': "Import (Spells)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported spell."),
            'prepareActorSpells': {
              'name': "Prepare Actor Spells",
              'help': "Whether or not spells that are imported to actor sheets should be prepared by default.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'prepareSpellItems': {
              'name': "Prepare Spell Items",
              'help': "Whether or not spells that are imported to the items directory should be prepared by default.",
              'default': false,
              'type': 'boolean'
            },
            'actorSpellPreparationMode': {
              'name': "Actor Spell Preparation Mode",
              'help': "The default spell preparation mode for spells imported to actor sheets.",
              'default': "prepared",
              'type': "enum",
              'values': [{
                'value': '',
                'name': "(None)"
              }, {
                'value': "always",
                'name': "Always Prepared"
              }, {
                'value': "prepared",
                'name': "Prepared"
              }, {
                'value': "innate",
                'name': "Innate Spellcasting"
              }, {
                'value': "pact",
                'name': "Pact Magic"
              }],
              'isPlayerEditable': true
            },
            'isAutoDetectActorSpellPreparationMode': {
              'name': "Auto-Detect Actor Spell Preparation Mode",
              'help': "If enabled, the default spell preparation mode for spells imported to actor sheets (as defined by \"Actor Spell Preparation Mode\") may be automatically overridden, e.g. \"pact magic\" is automatically used when importing to a warlock.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'spellItemPreparationMode': {
              'name': "Spell Item Preparation Mode",
              'help': "The default spell preparation mode for spells imported to the items directory.",
              'default': "prepared",
              'type': "enum",
              'values': [{
                'value': '',
                'name': '(None)'
              }, {
                'value': "always",
                'name': "Always Prepared"
              }, {
                'value': "prepared",
                'name': "Prepared"
              }, {
                'value': 'innate',
                'name': "Innate Spellcasting"
              }, {
                'value': "pact",
                'name': "Pact Magic"
              }]
            },
            'spellPointsMode': {
              'name': "Use Spell Points",
              'help': "If enabled, imported spells which would use spell slots will instead be marked as \"at will\" and set to consume an a sheet or feature resource. (The \"Spell Points\" variant rule can be found in the DMG, page 288.)",
              'default': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
              'type': 'enum',
              'values': [{
                'name': "Disabled",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED
              }, {
                'name': 'Enabled',
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED
              }, {
                'name': "Enabled, and Use 99 Slots",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS,
                'help': "If enabled, an imported spells will retain its \"Spell Preparation Mode\" in addition to consuming a \"Spell Points\" sheet/feature resource. This improves compatibility with many sheets and modules. To allow \"unlimited\" spellcasting at each spell level, a character's spell slots for each level will be set to 99."
              }],
              'isPlayerEditable': true
            },
            'spellPointsResource': {
              'name': "Spell Points Resource",
              'help': "The resource consumed by spells imported with \"Use Spell Points\" enabled.",
              'default': "resources.primary.value",
              'type': "enum",
              'values': [{
                'value': "resources.primary"
              }, {
                'value': 'resources.secondary'
              }, {
                'value': 'resources.tertiary'
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM,
                'name': "\"Spell Points\" sheet item"
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM,
                'name': "Custom (see below)"
              }],
              'isPlayerEditable': true
            },
            'spellPointsResourceCustom': {
              'name': "Spell Points Custom Resource",
              'help': "The name of the custom resource to use if \"Custom\" is selected for \"Spell Points Resource\", above. This supports modules that expand the number of available sheet resources, such as \"5e-Sheet Resources Plus\" (which adds e.g. \"resources.fourth\", \"resources.fifth\", ...).",
              'type': 'string',
              'additionalStyleClasses': "code",
              'default': null,
              'isNullable': true,
              'isPlayerEditable': true
            },
            'isIncludeClassesInDescription': {
              'name': "Include Caster Classes in Spell Description",
              'help': "If enabled, an imported spell's description will include the list of classes which have the spell on their spell list.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': 'spells'
            }),
            'isMetricDistance': {
              'name': "Convert Ranges and Areas to Metric",
              'help': "Whether or not spell range/area units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + "; " + ConfigConsts._DISP_METRIC_MILES + ').',
              'default': false,
              'type': "boolean"
            },
            'isFilterOnOpen': {
              'name': "Apply Class Filter when Opening on Actor",
              'help': "If enabled, and the importer is opened from an actor, the spell list will be filtered according to that actor's current class(es).",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Spell Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_SPELLS.join(", "),
              'type': 'string',
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'replacementDataCompendium': {
              'name': "Replacement Data Compendiums",
              'help': "A comma-separated list of compendiums that the Spell Importer will attempt to pull spells from, rather than using the data Plutonium would otherwise generate. This is useful when the Spell Importer is used by other importers, e.g. when the Creature Importer is adding spells to newly-created actors.",
              'default': '',
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': 'spells'
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a spell's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            },
            'isUseCustomSrdIcons': {
              'name': "Use Custom Icons for SRD Spells",
              'help': "If enabled, imported SRD spells will use an alternate icon set, as curated by the community.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isUseDefaultSchoolImage': {
              'name': "School Default Image Fallback",
              'help': "If enabled, when importing a spell which has no well-defined image, use a default image based on the school of the spell. If disabled, a generic black and white image will be used as a fallback instead.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'spellPointsModeNpc': {
              'name': "Use Spell Points (NPCs)",
              'help': "If enabled, a spell imported to an NPC which would use spell slots will instead be marked as \"at will\" and set to consume an a sheet or feature resource. (The \"Spell Points\" variant rule can be found in the DMG, page 288.)",
              'default': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
              'type': "enum",
              'values': [{
                'name': "Disabled",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED
              }, {
                'name': "Enabled",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED
              }, {
                'name': "Enabled, but Use 99 Slots",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS,
                'help': "If enabled, imported spells will retain their \"prepared\"/etc. types in addition to consuming a \"Spell Points\" sheet/feature resource. This allows easier organisation of spells, and better compatibility with many modules. To allow \"unlimited\" spellcasting at each spell level, a character's spell slots for each level will be set to 99."
              }]
            }
          }
        },
        'importRule': {
          'name': "Import (Rules)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported rule.")
          }
        },
        'importLanguage': {
          'name': "Import (Languages)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported language.")
          }
        },
        'importOptionalFeature': {
          'name': "Import (Options & Features)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported option/feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "optional features"
            }),
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not optional feature speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the optional feature importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_OPTIONAL_FEATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "optional features"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, an optional feature's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importConditionDisease': {
          'name': "Import (Conditions & Diseases)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported condition/diseases.")
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "conditions/diseases"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a condition/disease's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importCultBoon': {
          'name': "Import (Cults & Supernatural Boons)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported cult/boon.")
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "cults/boons"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a cult/boon's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importAction': {
          'name': "Import (Actions)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported action.")
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "actions"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a action's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importReward': {
          'name': "Import (Gifts & Rewards)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported supernatural gift/reward."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "supernatural gift/rewards"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not gift/reward speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "gift/rewards"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a supernatural gift/reward's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importCharCreationOption': {
          'name': "Import (Char. Creation Options)",
          'help': "Import (Character Creation Options)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported character creation option."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "character creation options"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not character creation option speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "character creation options"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a character creation option's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importDeity': {
          'name': "Import (Deities)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported deity.")
          }
        },
        'importRecipe': {
          'name': "Import (Recipes)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported recipe.")
          }
        },
        'importTrap': {
          'name': "Import (Traps)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported trap."),
            ...ConfigConsts._template_getTokenSettings({
              'actorType': "npc"
            }), */
            'isImportBio': {
              'name': "Import Fluff to Description",
              'help': "If enabled, any fluff text which is available for a trap will be imported into that trap's description.",
              'default': true,
              'type': 'boolean'
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Description",
              'help': "If enabled, any fluff image which is available for a trap will be imported into that trap's description.",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActorImportOverwriteSettings()
          }
        },
        'importTrapFeature': {
          'name': "Import (Trap Features)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported trap feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "trap features"
            }), */
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not trap feature range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "trap features"
            })
          }
        },
        'importHazard': {
          'name': "Import (Hazards)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported hazard.")
          }
        },
        'importAdventure': {
          'name': "Import (Adventures)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported adventure."),
            'isUseModdedInstaller': {
              'name': "Use Modded Package Installer",
              'help': "If the modded Plutonium backend is installed, adventure packages (modules/worlds) will be installed, automatically, using the mod, rather than providing you with a list of links to copy-paste into Foundry's \"Setup\".",
              'type': 'boolean',
              'default': false
            },
            'isUseLegacyImporter': {
              'name': "Enable Legacy Package Importer",
              'help': "If Plutonium should allow adventure packages (modules/worlds) to be imported directly, rather than providing references for the user to investigate themselves.",
              'type': "boolean",
              'default': false,
              'unlockCode': "unlock"
            },
            'indexUrl': {
              'name': "Package Index URL",
              'help': "The URL of the index file from which world/module package metadata is loaded.",
              'type': 'url',
              'default': "https://raw.githubusercontent.com/DMsGuild201/Foundry_Resources/master/worlds/index.json",
              'additionalStyleClasses': 'code',
              'isReloadRequired': true
            }
          }
        },
        'importBook': {
          'name': "Import (Books)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported book.")
          }
        },
        'importMap': {
          'name': "Import (Maps)",
          'settings': {
            //...ConfigConsts._template_getSceneImportSettings()
          }
        },
        'importDeck': {
          'name': "Import (Decks)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported deck.")
          }
        },
        'actor': {
          'name': 'Actors',
          'settings': {
            'isRefreshOtherOwnedSheets': {
              'name': "Refresh Sheets using &quot;@" + SharedConsts.MODULE_ID_FAKE + ".userchar&quot; when Updating Player Character",
              'help': "Player only. If enabled, when you update your character, the sheets of other actors you control which use \"@" + SharedConsts.MODULE_ID_FAKE + ".userchar. ...\" attributes will be automatically refreshed to reflect any changes made to your character. If disabled, you may notice a \"lag\" between updating your character and seeing the changes reflected in other sheets (a refresh can be forced manually by editing any field on the other sheet, or refreshing your browser tab).",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            }
          },
          'settingsAdvanced': {
            'isAddRollDataItemsFeat': {
              'name': "Add &quot;@items&quot; to Roll Data (Features)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isAddRollDataItemsItem': {
              'name': "Add &quot;@items&quot; to Roll Data (Inventory)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': 'boolean'
            },
            'isAddRollDataItemsSpell': {
              'name': "Add &quot;@items&quot; to Roll Data (Spells)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': "boolean"
            },
            'isAddRollDataItemsOther': {
              'name': "Add &quot;@items&quot; to Roll Data (Other)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsHacks': {
            'isAutoMultiattack': {
              'name': "Auto-Roll Multiattacks",
              'help': "Attempt to detect and automatically roll components of a creature's \"Multiattack\" sheet item on activation.",
              'default': false,
              'type': "boolean"
            },
            'autoMultiattackDelay': {
              'name': "Time Between Multiattack Rolls (ms)",
              'help': "A number of milliseconds to wait between each roll of a multiattack when using the \"Auto-Roll Multiattacks\" option. A value of 2000-2500 is recommended when using the \"Automated Animations\" module.",
              'default': null,
              'type': 'number',
              'min': 0x0,
              'isNullable': true
            },
            'isUseExtendedActiveEffectsParser': {
              'name': "Support Variables in Active Effect Values",
              'help': "Allows the use of roll syntax, and notably variables (such as \"@abilities.dex.mod\"), in active effect values.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_DAE]: false,
                [UtilCompat.MODULE_ROLLDATA_AWARE_ACTIVE_EFFECTS]: false
              }
            }
          }
        },
        'item': {
          'name': "Items",
          'settingsHacks': {
            'isSuppressAdvancementsOnImportedDrop': {
              'name': "Suppress Advancements During Drop Flow",
              'help': "If enabled, dropping a Plutonium-imported item to a sheet will briefly disable the default advancement workflow, potentially allowing Plutonium's importer to run instead.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'rivet': {
          'name': "Rivet",
          'settings': {
            'targetDocumentId': {
              'name': "Target Document",
              'help': "The ID of an actor or compendium to which Rivet content should be imported.",
              'default': '',
              'type': "string",
              'additionalStyleClasses': "code",
              'isPlayerEditable': true
            },
            'isDisplayStatus': {
              'name': "Display Extension Detected",
              'help': "Adds a \"paper plane\" icon to the Foundry \"anvil\" logo in the top-left corner of the screen if Rivet is detected.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            /* 'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level",
              'help': "Rivet will cease to function for any user user with a role less than the chosen role. Directory \"Set as Rivet Target\" context menu option will also be hidden for any user with a role less than the chosen role."
            }) */
          }
        },
        'artBrowser': {
          'name': "Art Browser",
          'settings': {
            'importImagesAs': {
              'name': "Drag-Drop Images As",
              'help': "The type of canvas object that should be created when drag-dropping images from the art browser to the canvas.",
              'default': ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
                'name': 'Tokens'
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_TILE,
                'name': "Tiles"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_NOTE,
                'name': "Journal notes"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_SCENE,
                'name': "Scenes"
              }]
            },
            'dropAnchor': {
              'name': "Drag-Drop Position Anchor",
              'help': "The origin point of the image used for the purpose of dropping it to the canvas. \"Center\" will place the center of the image at the drop position, whereas \"Top-Left Corner\" will place the top-left corner of the image at the drop position.",
              'default': 0x0,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ART_DROP_ANCHOR_CENTER,
                'name': "Center"
              }, {
                'value': ConfigConsts.C_ART_DROP_ANCHOR_TOP_LEFT,
                'name': "Top-Left Corner"
              }]
            },
            'scale': {
              'name': "Tile/Scene Scaling",
              'help': "A factor by which to scale placed tiles, and by which to scale scene backgrounds.",
              'default': 0x1,
              'type': 'number',
              'min': 0.01,
              'max': 0x64
            },
            ...ConfigConsts._template_getSceneImportSettings(),
            'tokenSize': {
              'name': "Token Size",
              'help': "The default size of placed tokens.",
              'default': 0x1,
              'type': "enum",
              'values': [{
                'value': 0x1,
                'name': "Medium or smaller"
              }, {
                'value': 0x2,
                'name': 'Large'
              }, {
                'value': 0x3,
                'name': "Huge"
              }, {
                'value': 0x4,
                'name': "Gargantuan or larger"
              }]
            },
            'isSwitchToCreatedScene': {
              'name': "Activate Scenes on Creation",
              'help': "If enabled, a scene will be activated upon creation (by drag-dropping an image to the canvas).",
              'default': true,
              'type': "boolean"
            },
            'isDisplaySheetCreatedScene': {
              'name': "Display Scene Sheets on Creation",
              'help': "If enabled, the \"sheet\" (i.e., configuration UI) for a scene will be shown upon creation (by drag-dropping an image to the canvas).",
              'default': true,
              'type': 'boolean'
            },
            'artDirectoryPath': {
              'name': "User Art Directory",
              'help': "The sub-directory of the \"User Data\" directory where downloaded images and image packs will be saved.",
              'default': "assets/art",
              'type': 'string',
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'buttonDisplay': {
              'name': "Add Button To",
              'help': "The place(s) where the Art Browser button should be visible.",
              'default': {
                [ConfigConsts.C_ART_IMAGE_MODE_TOKEN]: false,
                [ConfigConsts.C_ART_IMAGE_MODE_TILE]: true,
                [ConfigConsts.C_ART_IMAGE_MODE_NOTE]: false,
                [ConfigConsts.C_ART_IMAGE_MODE_SCENE]: true
              },
              'type': "multipleChoice",
              'choices': [{
                'value': ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
                'name': "Token scene controls"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_TILE,
                'name': "Tile scene controls"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_NOTE,
                'name': "Note scene controls"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_SCENE,
                'name': "Scene controls"
              }]
            },
            'imageSaveMode': {
              'name': "Image Saving Mode",
              'help': "How images should be saved to the server. If \"Default\" is selected, an imported image will only be saved if it cannot be referenced via URL. If \"Always\" is selected, an imported image will be saved to the server, regardless of whether or not it can be referenced via URL. If \"Never\" is selected, an imported image will only be referenced by URL; if it cannot be referenced via URL, the import will fail. Note that saving images requires the Plutonium backend mod to be installed.",
              'default': ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT,
                'name': "Default"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_SAVE_MODE__ALWAYS,
                'name': 'Always'
              }, {
                'value': ConfigConsts.C_ART_IMAGE_SAVE_MODE__NEVER,
                'name': "Never"
              }]
            }
          },
          'settingsAdvanced': {
            'isSwitchLayerOnDrop': {
              'name': "Switch to Layer on Drop",
              'help': "If, when dropping an image into a given layer, the canvas should switch to that layer.",
              'default': true,
              'type': "boolean"
            },
            'isShowMissingBackendWarning': {
              'name': "Show &quot;Missing Backend&quot; Warning",
              'help': "If enabled, and the Plutonium backend mod is not installed, a warning will be shown in the Art Browser.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'journalEntries': {
          'name': "Journal Entries",
          'settings': {
            'isAutoExpandJournalEmbeds': {
              'name': "Auto-Expand Page Embeds",
              'help': "If enabled, journal pages embedded using \"@EmbedUUID[JournalEntry. ... JournalEntryPage. ...]{...}\" will be expanded by default.",
              'default': true,
              'type': "boolean"
            },
            'isEnableNoteHeaderAnchor': {
              'name': "Allow &quot;Header Anchors&quot; in Notes",
              'help': "If enabled, a \"Header Anchor\" may be specified when creating or editing a map note. When opening a journal entry via a map note with a Header Anchor set, the journal entry will scroll to that header.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'tools': {
          'name': "Tools",
          'settings': {
            'isDeduplicateIgnoreType': {
              'name': "Ignore Types When Deduplicating",
              'help': "If enabled, the Collection Deduplicator will ignore entity types, treating e.g. a PC sheet and an NPC sheet with the same name as a set of duplicates.",
              'default': false,
              'type': "boolean"
            },
           /*  'minimumRolePolymorph': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Polymorph Tool",
              'help': "Actor \"Polymorph\" buttons will be hidden for any user with a role less than the chosen role."
            }),
            'minimumRoleActorTools': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Other Actor Tools",
              'help': "Actor \"Feature/Spell Cleaner,\" \"Prepared Spell Mass-Toggler,\" etc. buttons will be hidden for any user with a role less than the chosen role."
            }),
            'minimumRoleTableTools': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Other Table Tools",
              'help': "Table \"Row Cleaner\" button will be hidden for any user with a role less than the chosen role."
            }), */
            'isAddClearFlagsContextMenu': {
              'name': "Add &quot;Clear Flags&quot; Context Option",
              'help': "If enabled a \"Clear Flags\" option will be added to directory document context menus. This option will clear all \"plutonium\" flags from a document, and the document's embedded documents. Note that this will negatively impact Plutonium functionality for the document.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            }
          }
        },
        'text': {
          'name': "Text and Tags",
          'settings': {
            'isEnableHoverForLinkTags': {
              'name': "Enable Hover Popups for &quot;@tag&quot; Links",
              'help': "If links rendered from @tag syntax should display popups when hovered.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isAutoRollActorItemTags': {
              'name': "Roll Items Linked by @UUID[Actor.Item.] on Click",
              'help': "If enabled, clicking a rendered @UUID[Actor. ... Item. ...] tag will roll the linked embedded item. If disabled, or on SHIFT-click, the default action (opening the item's sheet) is taken.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isJumpToFolderTags': {
              'name': "Show Folder Linked by @UUID[Folder.] on Click",
              'help': "If enabled, clicking a rendered @UUID[Folder. ...] tag will switch to that folder's tab and scroll the folder into view. If disabled, or on SHIFT-click, the default action (opening the folder's sheet) is taken.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isShowLinkParent': {
              'name': "Show Parent Icon/Name For Child @UUIDs",
              'help': "If enabled, a rendered @UUID[<parentDocumentName>.<parentId>.<documentName>.<documentId>] tag will display the icon of the parent document type and the name of the parent document, in addition to the usual icon of the document type and the name of the document.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          }
        },
        'misc': {
          'name': "Miscellaneous",
          'settings': {
            'isSkipAddonAutomationCheck': {
              'name': "Skip Addon: Automation Check",
              'help': "Avoid posting to chat if the Addon: Automation companion model is not installed.",
              'default': false,
              'type': "boolean"
            },
            'isSkipBackendCheck': {
              'name': "Skip Backend Check",
              'help': "Avoid sending a network request during module initialisation to check if the modded Plutonium backend is installed.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          },
          'settingsAdvanced': {
            'baseSiteUrl': {
              'name': "Master of Ceremonies Server URL",
              'help': "The root server URL for the Mater of Ceremonies app, used to verify and unlock Patron benefits.",
              'type': 'url',
              'default': "https://plutonium.giddy.cyou",
              'isNullable': true,
              'isReloadRequired': true,
              'unlockCode': 'unlock'
            },
            'backendEndpoint': {
              'name': "Custom Backend Endpoint",
              'help': "The API endpoint used to make calls to the modded Plutonium backend, if available. Note that this API is considered \"internal,\" and is therefore undocumented, and may change on a per-version basis.",
              'default': null,
              'placeholder': "(Use default)",
              'type': "url",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'isPatchFromUuid': {
              'name': "Patch <code>fromUuid</code>",
              'help': "Patch the built-in Foundry function \"fromUuid\" to allow Plutonium-specific UUIDs to be processed. This improves compatibility with some modules.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'equipmentShop': {
          'name': "Equipment Shop",
          'settings': {
            'priceMultiplier': {
              'name': "Price Multiplier",
              'help': "A factor by which the prices in the equipment shop are multiplied.",
              'default': 0x1,
              'type': 'percentage',
              'min': 0.0001
            },
            'startingGold': {
              'name': "Class Starting Gold",
              'help': "A starting gold amount to use instead of a class's starting gold, when using the equipment shop during class creation.",
              'default': null,
              'type': "number",
              'isNullable': true
            },
           /*  'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level",
              'help': "\"Equipment Shop\" button will be hidden for any user with a role less than the chosen role."
            }) */
          }
        },
        'currency': {
          'name': 'Currency',
          'settingsAdvanced': {
            'isNpcUseCurrencySheetItems': {
              'name': "Import Currency as Sheet Item for NPCs",
              'help': "If enabled, the currency component of loot drag-dropped to an NPC sheet will be added as a sheet item. If disabled, it will be added as \"currency\" data instead, which the default " + SharedConsts.SYSTEM_ID_DND5E + " sheet does not display.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'dataSources': {
          'name': "Data Sources",
          'btnsAdditional': [{
            'name': "World Data Source Selector",
            'icon': "fas fa-fw fa-globe-africa",
            'onClick': async () => {
              const {
                WorldDataSourceSelector: _0x3787e7
              } = await Promise.resolve().then(function () {
                return WorldDataSourceSelector$1;
              });
              _0x3787e7.pHandleButtonClick().then(null);
            }
          }, {
            'name': "World Content Blocklist",
            'icon': "fas fa-fw fa-ban",
            'onClick': async () => {
              const {
                WorldContentBlocklistSourceSelector: _0x2b04fc
              } = await Promise.resolve().then(function () {
                return WorldContentBlocklist$1;
              });
              _0x2b04fc.pHandleButtonClick().then(null);
            }
          }],
          'settings': {
            'isPlayerEnableSourceSelection': {
              'name': "Enable Data Source Filtering for Players",
              'help': "Whether or not " + ConfigConsts._STR_DATA_SOURCES + " are filtered down to only those chosen in the \"World Data Source Selector\" application. Applies to players only.",
              'default': false,
              'type': 'boolean',
              'isReloadRequired': true
            },
            'isGmEnableSourceSelection': {
              'name': "Enable Data Source Filtering for GMs",
              'help': "Whether or not " + ConfigConsts._STR_DATA_SOURCES + " are filtered down to only those chosen in the \"World Data Source Selector\" application. Applies to GMs only.",
              'default': false,
              'type': 'boolean',
              'isReloadRequired': true
            },
            'isPlayerForceSelectAllowedSources': {
              'name': "Force Select All for Players",
              'help': "Whether or not all available " + ConfigConsts._STR_DATA_SOURCES + " are forcibly selected for players. Note that this can seriously degrade performance for players if data source filtering is not also enabled.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isGmForceSelectAllowedSources': {
              'name': "Force Select All for GMs",
              'help': "Whether or not all available " + ConfigConsts._STR_DATA_SOURCES + " are forcibly selected for GMs. Note that this can seriously degrade performance for GMs if data source filtering is not also enabled.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isLoadLocalPrereleaseIndex': {
              'name': "Load Local Prerelease Content",
              'help': "If enabled, the directory specified by the \"Local Prerelease Content Directory\" option will be read, and its contents added to the list of available sources.",
              'default': false,
              'type': "boolean"
            },
            'localPrereleaseDirectoryPath': {
              'name': "Local Prerelease Content Directory",
              'help': "The sub-directory of the \"User Data\" directory from which prerelease content should be automatically loaded if the \"Load Local Prerelease\" option is enabled.",
              'default': "assets/prerelease",
              'type': "string",
              'additionalStyleClasses': "code"
            },
            'isUseLocalPrereleaseIndexJson': {
              'name': "Use <code>index.json</code> for Local Prerelease Content",
              'help': "If, rather than read the local prerelease content directory directly, an \"index.json\" file should be read when loading local prerelease content. This file should be of the form: {\"toImport\": [ ... list of filenames ... ]}. Note that this is required if players do not have \"Use File Browser\" permissions.",
              'default': false,
              'type': "boolean"
            },
            'localPrerelease': {
              'name': "Additional Prerelease Files",
              'help': "Prerelease files which should be automatically loaded and added to the list of available sources.",
              'default': [],
              'type': "arrayStringShort",
              'isCaseSensitive': true
            },
            'isLoadLocalHomebrewIndex': {
              'name': "Load Local Homebrew",
              'help': "If enabled, the directory specified by the \"Local Homebrew Directory\" option will be read, and its contents added to the list of available sources.",
              'default': false,
              'type': "boolean"
            },
            'localHomebrewDirectoryPath': {
              'name': "Local Homebrew Directory",
              'help': "The sub-directory of the \"User Data\" directory from which homebrew should be automatically loaded if the \"Load Local Homebrew\" option is enabled.",
              'default': "assets/homebrew",
              'type': "string",
              'additionalStyleClasses': "code"
            },
            'isUseLocalHomebrewIndexJson': {
              'name': "Use <code>index.json</code> for Local Homebrew",
              'help': "If, rather than read the local homebrew directory directly, an \"index.json\" file should be read when loading local homebrew. This file should be of the form: {\"toImport\": [ ... list of filenames ... ]}. Note that this is required if players do not have \"Use File Browser\" permissions.",
              'default': false,
              'type': "boolean"
            },
            'localHomebrew': {
              'name': "Additional Homebrew Files",
              'help': "Homebrew files which should be automatically loaded and added to the list of available sources.",
              'default': [],
              'type': "arrayStringShort",
              'isCaseSensitive': true
            }
          },
          'settingsAdvanced': {
            'tooManySourcesWarningThreshold': {
              'name': "Auto-Selected Source Count Warning Threshold",
              'help': "If set, a warning will be shown when auto-selecting a number of sources greater than this value, which usually occurs if a \"Force Select All...\" option is set, without also \"Enabl[ing] Data Source Filtering.\"",
              'default': 0x32,
              'type': "integer",
              'isNullable': true
            },
            'baseSiteUrl': {
              'name': "Base Site URL",
              'help': "The root server URL from which to load data and source images, and to link in rendered text. Note that, where possible, the module will use its own built-in data files, rather than call out to a remote server.",
              'type': "url",
              'additionalStyleClasses': "code",
              'default': null,
              'isNullable': true,
              'isReloadRequired': true
            },
            'isNoLocalData': {
              'name': "Avoid Loading Local Data",
              'help': "If enabled, any data which would normally be loaded from the module's local copies is instead loaded from the sites URL (which may be customised by editing the \"Base Site Url\" config option).",
              'default': false,
              'type': "boolean"
            },
            'isNoPrereleaseBrewIndexes': {
              'name': "Avoid Loading Prerelease/Homebrew Indexes on Startup",
              'help': "If enabled, prerelease/homebrew repository indexes won't be loaded during initial module load. This will effectively prevent any prerelease/homebrew sources from appearing in source listings. Note that these indexes are loaded in the background/asynchronously during normal operation, so should not negatively impact game load times, unless you have a particularly terrible internet connection.",
              'default': false,
              'type': "boolean"
            },
            'basePrereleaseUrl': {
              'name': "Base Prerelease Repository URL",
              'help': "The root GitHub repository URL from which to load data and source images, and to link in rendered text, when importing prerelease content. URLs should be of the form \"https://raw.githubusercontent.com/[username]/[repository name]/master\".",
              'type': "url",
              'additionalStyleClasses': 'code',
              'default': null,
              'isNullable': true,
              'isReloadRequired': true
            },
            'baseBrewUrl': {
              'name': "Base Homebrew Repository URL",
              'help': "The root GitHub repository URL from which to load data and source images, and to link in rendered text, when importing homebrew content. URLs should be of the form \"https://raw.githubusercontent.com/[username]/[repository name]/master\".",
              'type': "url",
              'additionalStyleClasses': 'code',
              'default': null,
              'isNullable': true,
              'isReloadRequired': true
            }
          }
        },
        /* 'integrationQuickInsert': {
          'name': "Integrations (Quick Insert)",
          'settings': {
            ...ConfigConsts._template_getModuleFauxCompendiumIndexSettings({
              'moduleName': "Quick Insert"
            }),
            'pagesHidden': {
              'name': "Hidden Categories",
              'help': "Categories of entity which should not be indexed.",
              'default': ConfigConsts._QUICK_INSERT_PAGE_METAS.mergeMap(({
                page: _0x25cba7
              }) => ({
                [_0x25cba7]: _0x25cba7 === UrlUtil.PG_RECIPES
              })),
              'type': "multipleChoice",
              'choices': ConfigConsts._QUICK_INSERT_PAGE_METAS.map(({
                page: _0x365d30,
                displayPage: _0x31cbd1
              }) => ({
                'value': _0x365d30,
                'name': _0x31cbd1
              }))
            },
            'isDisplaySource': {
              'name': "Display Sources",
              'help': "If enabled, a source abbreviation will be displayed on each result. If disabled, the module name will be shown instead.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'integrationFoundrySummons': {
          'name': "Integrations (Foundry Summons)",
          'settings': {
            ...ConfigConsts._template_getModuleFauxCompendiumIndexSettings({
              'moduleName': "Foundry Summons"
            })
          }
        },
        'integrationBabele': {
          'name': "Integrations (Babele)",
          'settings': {
            'isEnabled': {
              'name': "Enabled",
              'help': "If enabled, and the Babele module is active, Plutonium will attempt to translate parts of imported content.",
              'default': true,
              'type': "boolean"
            },
            'isUseTranslatedDescriptions': {
              'name': "Use Translated Descriptions",
              'help': "If enabled, and a translated description is found for a document during import, that description will be used instead of the Plutonium default. Note that this may result in embedded functionality (for example, links between documents) being removed.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'integrationThreeDiCanvas': {
          'name': "Integrations (3D Canvas)",
          'settings': {
            'isSetThreeDiModels': {
              'name': "Allow Importer to Set 3D Models",
              'help': "If enabled, and the 3D Canvas, 3D Canvas Mapmaking Pack, and 3D Canvas Token Collection modules are active, Plutonium will attempt to set the \"3D Model\" field on imported tokens.",
              'default': true,
              'type': 'boolean',
              'isReloadRequired': true
            }
          }
        }, */
        'charactermancer': {
          'name': "Charactermancer",
          'settings': {
           /*  'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level",
              'help': "Actor \"Charactermancer\" buttons will be hidden for any user with a role less than the chosen role."
            }) */
          }
        }
      };
    }
    static ["_DEFAULT_CONFIG_SORTED"] = null;
    static ["getDefaultConfigSorted_"]() {
      return this._DEFAULT_CONFIG_SORTED = this._DEFAULT_CONFIG_SORTED || Object.entries(this.getDefaultConfig_()).sort(([, _0xb7c8c5], [, _0x343b25]) => SortUtil.ascSortLower(_0xb7c8c5.name, _0x343b25.name));
    }
    static ["_DEFAULT_CONFIG_SORTED_FLAT"] = null;
    static ["getDefaultConfigSortedFlat_"]() {
      if (this._DEFAULT_CONFIG_SORTED_FLAT) {
        return this._DEFAULT_CONFIG_SORTED_FLAT;
      }
      return this._DEFAULT_CONFIG_SORTED_FLAT = this._DEFAULT_CONFIG_SORTED_FLAT || this.getDefaultConfigSorted_().map(([_0x102f4b, _0x540fe5]) => {
        const _0x417b84 = {};
        this._KEYS_SETTINGS_METAS.forEach(_0x48a0c5 => {
          Object.entries(_0x540fe5[_0x48a0c5] || {}).forEach(([_0x70d0f8, _0x41ed31]) => {
            _0x417b84[_0x70d0f8] = _0x41ed31;
          });
        });
        return [_0x102f4b, _0x417b84];
      });
    }
    static ["getCompendiumPaths"]() {
      const _0x525cb1 = [];
      Object.entries(this.getDefaultConfig_()).forEach(([_0x3661aa, _0x57ce92]) => {
        this._KEYS_SETTINGS_METAS.forEach(_0x435517 => {
          if (!_0x57ce92[_0x435517]) {
            return;
          }
          Object.entries(_0x57ce92[_0x435517]).forEach(([_0x57b4d8, _0x1b0cb0]) => {
            if (_0x1b0cb0.typeSub !== "compendiums") {
              return;
            }
            _0x525cb1.push([_0x3661aa, _0x57b4d8]);
          });
        });
      });
      return _0x525cb1;
    }
  }
  ConfigConsts._STR_DATA_SOURCES = "\"data sources\" (e.g. those displayed in the Import Wizard)";
  ConfigConsts._KEYS_SETTINGS_METAS = ["settings", "settingsHacks", "settingsAdvanced"];
  ConfigConsts._TEMPLATE_ENTITY_OWNERSHIP = {
    'name': "Default Ownership",
    'default': 0x0,
    'type': "enum"
  };
  ConfigConsts._TEMPALTE_MINIMUM_ROLE = {
    'default': 0x0,
    'type': "enum",
    'isReloadRequired': true
  };
  ConfigConsts._DISP_METRIC_POUNDS = "1 pound ≈ 0.5 kilograms";
  ConfigConsts._DISP_METRIC_FEET = "5 feet ≈ 1.5 metres";
  ConfigConsts._DISP_METRIC_MILES = "1 mile ≈ 1.6 kilometres";
  ConfigConsts.SRD_COMPENDIUMS_CREATURES = [SharedConsts.SYSTEM_ID_DND5E + ".monsters"];
  ConfigConsts.SRD_COMPENDIUMS_CREATURE_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".monsterfeatures"];
  ConfigConsts.SRD_COMPENDIUMS_CLASSES = [SharedConsts.SYSTEM_ID_DND5E + ".classes"];
  ConfigConsts.SRD_COMPENDIUMS_SUBCLASSES = [SharedConsts.SYSTEM_ID_DND5E + ".subclasses"];
  ConfigConsts.SRD_COMPENDIUMS_CLASS_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".classfeatures"];
  ConfigConsts.SRD_COMPENDIUMS_ITEMS = [SharedConsts.SYSTEM_ID_DND5E + '.items', SharedConsts.SYSTEM_ID_DND5E + ".tradegoods"];
  ConfigConsts.SRD_COMPENDIUMS_SPELLS = [SharedConsts.SYSTEM_ID_DND5E + '.spells'];
  ConfigConsts.SRD_COMPENDIUMS_OPTIONAL_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".classfeatures"];
  ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".races"];
  ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".backgrounds"];
  ConfigConsts.SRD_COMPENDIUMS_TABLES = [SharedConsts.SYSTEM_ID_DND5E + ".tables"];
  /* ConfigConsts._QUICK_INSERT_PAGE_METAS = [...new Set(Renderer.tag.TAGS.filter(_0x244883 => _0x244883.page).map(_0x2e0a71 => _0x2e0a71.page).filter(_0x5b9350 => ![UrlUtil.PG_QUICKREF, "skill", "sense", "card", 'legroup'].includes(_0x5b9350)))].map(_0x207d8d => {
    let _0x1333af = UrlUtil.pageToDisplayPage(_0x207d8d);
    if (_0x1333af === _0x207d8d) {
      _0x1333af = Parser.getPropDisplayName(_0x207d8d);
    }
    return {
      'page': _0x207d8d,
      'displayPage': _0x1333af
    };
  }).sort(({
    displayPage: _0xb12442
  }, {
    displayPage: _0xb84237
  }) => SortUtil.ascSortLower(_0xb12442, _0xb84237)); */
  ConfigConsts.C_ART_IMAGE_MODE_TOKEN = 0x0;
  ConfigConsts.C_ART_IMAGE_MODE_TILE = 0x1;
  ConfigConsts.C_ART_IMAGE_MODE_NOTE = 0x2;
  ConfigConsts.C_ART_IMAGE_MODE_SCENE = 0x3;
  ConfigConsts.C_ART_DROP_ANCHOR_CENTER = 0x0;
  ConfigConsts.C_ART_DROP_ANCHOR_TOP_LEFT = 0x1;
  ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT = 0x0;
  ConfigConsts.C_ART_IMAGE_SAVE_MODE__ALWAYS = 0x1;
  ConfigConsts.C_ART_IMAGE_SAVE_MODE__NEVER = 0x2;
  ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE = 0x0;
  ConfigConsts.C_IMPORT_DEDUPE_MODE_SKIP = 0x1;
  ConfigConsts.C_IMPORT_DEDUPE_MODE_OVERWRITE = 0x2;
  ConfigConsts.C_IMPORT_DRAG_DROP_MODE_NEVER = 0x0;
  ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT = 0x1;
  ConfigConsts.C_IMPORT_DRAG_DROP_MODE_ALWAYS = 0x2;
  ConfigConsts.C_CREATURE_NAMETAGS_CR = 0x0;
  ConfigConsts.C_CREATURE_NAMETAGS_TYPE = 0x1;
  ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS = 0x2;
  ConfigConsts.C_SPELL_POINTS_MODE__DISABLED = 0x0;
  ConfigConsts.C_SPELL_POINTS_MODE__ENABLED = 0x1;
  ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS = 0x2;
  ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM = "sheetItem";
  ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM = "attributeCustom";
  ConfigConsts.C_ITEM_ATTUNEMENT_NONE = 0x0;
  ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED = 0x1;
  ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED = 0x2;
  ConfigConsts.C_ITEM_ATTUNEMENT_NEVER = 0x0;
  ConfigConsts.C_ITEM_ATTUNEMENT_SMART = 0x1;
  ConfigConsts.C_ITEM_ATTUNEMENT_ALWAYS = 0x2;
  ConfigConsts.C_USE_GAME_DEFAULT = 'VE_USE_GAME_DEFAULT';
  ConfigConsts.C_USE_PLUT_VALUE = "VE_USE_MODULE_VALUE";
  ConfigConsts.C_BOOL_DISABLED = 0x0;
  ConfigConsts.C_BOOL_ENABLED = 0x1;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE = 0x0;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_STANDARD = 0x1;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_GM = 0x2;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_BLIND = 0x3;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_SELF = 0x4;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_HIDDEN = 0x5;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MIN = 0x6;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MAX = 0x7;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE = 0x0;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN = 0x1;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX = 0x2;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL = 0x3;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM = 0x4;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE = 0x5;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES = {
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE]: "Take Average",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN]: "Minimum Value",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX]: "Maximum Value",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL]: "Roll",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM]: "Roll (Custom Formula)",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE]: "Do Not Increase HP"
  };
//#endregion

//#region Consts
class Consts {
    static RUN_TIME = `${Date.now()}`;
    static FLAG_IFRAME_URL = "iframe_url";

    static TERMS_COUNT = [{
        tokens: ["once"],
        count: 1
    }, {
        tokens: ["twice"],
        count: 2
    }, {
        tokens: ["thrice"],
        count: 3
    }, {
        tokens: ["three", " ", "times"],
        count: 3
    }, {
        tokens: ["four", " ", "times"],
        count: 4
    }, ];

    static Z_INDEX_MAX_FOUNDRY = 9999;

    static ACTOR_TEMP_NAME = "Importing...";

    static CHAR_MAX_LEVEL = 20;

    static RE_ID_STR = `[A-Za-z0-9]{16}`;
    static RE_ID = new RegExp(`^${this.RE_ID_STR}$`);

    static FLAG_IS_DEV_CLEANUP = "isDevCleanup";

    static USER_DATA_TRACKING_KEYS__ACTOR = ["system.details.biography.value",
    "system.attributes.hp.value", "system.attributes.death.success", "system.attributes.death.failure", "system.attributes.exhaustion", "system.attributes.inspiration",
    "system.details.xp.value",
    "system.resources.primary.value", "system.resources.secondary.value", "system.resources.tertiary.value", "system.resources.legact.value", "system.resources.legres.value", "system.resources.lair.value",
    "system.currency.cp", "system.currency.sp", "system.currency.ep", "system.currency.gp", "system.currency.pp", ];
}
//#endregion
//#region Config
class Config {
    
    static ["_IS_INIT"] = false;
    static ["_IS_INIT_SAVE_REQUIRED"] = false;
    static get ['backendEndpoint']() {
      const _0xa1e040 = Config.get("misc", "backendEndpoint");
      if (_0xa1e040) {
        return _0xa1e040;
      }
      return ROUTE_PREFIX ? '/' + ROUTE_PREFIX + "/api/plutonium" : "/api/plutonium";
    }
    static get ["isInit"]() {
      return this._IS_INIT;
    }
    static ["prePreInit"]() {
      this._preInit_doLoadConfig();
    }
    static ["_preInit_getLoadedConfig"]() {
      let _0x4eb887 = UtilGameSettings.getSafe(SharedConsts.MODULE_ID, Config._SETTINGS_KEY);
      if (_0x4eb887 == null || !Object.keys(_0x4eb887).length) {
        return {
          'isLoaded': false,
          'config': Config._getDefaultGmConfig()
        };
      }
      return {
        'isLoaded': true,
        'config': ConfigMigration.getMigrated({
          'config': _0x4eb887
        })
      };
    }
    static ['_preInit_doLoadConfig']() {
      this._pPrePreInit_registerSettings();
      const {
        isLoaded: _0xa6ae2f,
        config: _0x2491d4
      } = this._preInit_getLoadedConfig();
      Config._CONFIG = _0x2491d4;
      if (_0xa6ae2f) {
        const _0x4150fc = this._populateMissingConfigValues(Config._CONFIG, {
          'isPlayer': false
        });
        this._IS_INIT_SAVE_REQUIRED = this._IS_INIT_SAVE_REQUIRED || _0x4150fc;
      }
      game.socket.on(this._SOCKET_ID, _0x11513f => {
        switch (_0x11513f.type) {
          case "config.update":
            {
              const _0x2829e6 = _0x11513f.config;
              const _0x218c03 = MiscUtil.copy(Config._CONFIG);
              Object.assign(Config._CONFIG, _0x2829e6);
              if (!UtilPrePreInit.isGM()) {
                ConfigApp.handleGmConfigUpdate(_0x2829e6);
              }
              UtilHooks.callAll(UtilHooks.HK_CONFIG_UPDATE, {
                'previous': _0x218c03,
                'current': MiscUtil.copy(Config._CONFIG)
              });
              break;
            }
        }
      });
      if (!UtilPrePreInit.isGM()) {
        const _0x2f835b = GameStorage.getClient(Config._CLIENT_SETTINGS_KEY);
        if (_0x2f835b == null) {
          Config._CONFIG_PLAYER = Config._getDefaultPlayerConfig();
        } else {
          Config._CONFIG_PLAYER = _0x2f835b;
          const _0x2803d0 = this._populateMissingConfigValues(Config._CONFIG_PLAYER, {
            'isPlayer': true
          });
          this._IS_INIT_SAVE_REQUIRED = this._IS_INIT_SAVE_REQUIRED || _0x2803d0;
        }
      }
      this._pInit_initCompatibilityTempOverrides();
      this._IS_INIT = true;
    }
    static ['_COMPATIBILITY_TEMP_OVERRIDES'] = null;
    static ["_pInit_initCompatibilityTempOverrides"]() {
      ConfigConsts.getDefaultConfigSortedFlat_().forEach(([_0x5f00ec, _0x5379fb]) => {
        Object.entries(_0x5379fb).forEach(([_0x20a13a, _0x3eecc1]) => {
          if (!_0x3eecc1.compatibilityModeValues) {
            return;
          }
          Object.entries(_0x3eecc1.compatibilityModeValues).find(([_0x25d591, _0x5ef870]) => {
            const _0x540a72 = _0x3eecc1.type === "enum" ? ConfigUtilsSettings.getEnumValueValue(_0x5ef870) : _0x5ef870;
            const _0x2883d8 = _0x3eecc1.type === "enum" ? _0x5ef870.name || _0x540a72 : _0x540a72;
            if (!UtilCompat.isModuleActive(_0x25d591)) {
              return false;
            }
            const _0x4a4aec = Config.get(_0x5f00ec, _0x20a13a);
            const _0x486d1b = !CollectionUtil.deepEquals(_0x540a72, _0x4a4aec);
            Config.setTemp(_0x5f00ec, _0x20a13a, _0x540a72, {
              'isSkipPermissionCheck': true
            });
            if (_0x486d1b) {
              const {
                displayGroup: _0x314d1c,
                displayKey: _0x4cabc2
              } = Config._getDisplayLabels(_0x5f00ec, _0x20a13a);
              const _0x5d4132 = _0x4a4aec != null ? JSON.stringify(_0x4a4aec) : _0x4a4aec;
              const _0x4fb80d = _0x2883d8 != null ? JSON.stringify(_0x2883d8) : _0x2883d8;
              this._COMPATIBILITY_TEMP_OVERRIDES = this._COMPATIBILITY_TEMP_OVERRIDES || {};
              MiscUtil.set(this._COMPATIBILITY_TEMP_OVERRIDES, _0x5f00ec, _0x20a13a, {
                'value': _0x540a72,
                'message': "\"" + _0x314d1c + " -&gt; " + _0x4cabc2 + "\" value `" + _0x5d4132 + "` has compatibility issues with module \"" + game.modules.get(_0x25d591).title + "\" (must be set to `" + _0x4fb80d + '`)'
              });
              console.warn(...LGT, game.modules.get(_0x25d591).title + " detected! Setting compatibility config: " + _0x5f00ec + '.' + _0x20a13a + " = " + _0x4fb80d + " (was " + _0x5d4132 + "). If you encounter unexpected issues, consider disabling either module.");
            }
          });
        });
      });
    }
    static ["_hasCompatibilityWarnings"]() {
      return this._COMPATIBILITY_TEMP_OVERRIDES != null;
    }
    static ["_getCompatibilityWarnings"]() {
      if (!this._COMPATIBILITY_TEMP_OVERRIDES) {
        return '';
      }
      const _0x35b741 = Object.values(this._COMPATIBILITY_TEMP_OVERRIDES).map(_0x152dda => Object.values(_0x152dda).map(_0x120f14 => _0x120f14.message)).flat().map(_0xcf5598 => " - " + _0xcf5598).join("\n");
      return "Click to resolve config module compatibility issues. Issues detected:\n" + _0x35b741 + '.';
    }
    static ["_doResolveCompatibility"]() {
      Object.entries(this._COMPATIBILITY_TEMP_OVERRIDES).forEach(([_0xf82a5d, _0x3d417f]) => {
        Object.entries(_0x3d417f).forEach(([_0x10d0e6, _0x5141bd]) => {
          Config.set(_0xf82a5d, _0x10d0e6, _0x5141bd.value);
        });
      });
      this._COMPATIBILITY_TEMP_OVERRIDES = null;
    }
    static ['_pPrePreInit_registerSettings']() {
      game.settings.register(SharedConsts.MODULE_ID, Config._SETTINGS_KEY, {
        'name': 'Config',
        'default': {},
        'type': Object,
        'scope': "world",
        'onChange': _0x2cf485 => {}
      });
    }
    static ["pOpen"]({
      evt = null,
      initialVisibleGroup = null
    } = {}) {
      return ConfigApp.pOpen({
        'evt': evt,
        'initialVisibleGroup': initialVisibleGroup,
        'backend': this
      });
    }
    static ["_populateMissingConfigValues"](_0x269be7, _0x40a182) {
      _0x40a182 = _0x40a182 || {};
      const _0x5ddf60 = !!_0x40a182.isPlayer;
      let _0x811367 = false;
      Object.entries(this._getDefaultConfig({
        'isPlayer': _0x5ddf60
      })).forEach(([_0x159930, _0x40e344]) => {
        if (!_0x269be7[_0x159930]) {
          _0x269be7[_0x159930] = _0x40e344;
          _0x811367 = true;
        } else {
          Object.entries(_0x40e344).forEach(([_0xfb319f, _0x2cb8c5]) => {
            if (_0x269be7[_0x159930][_0xfb319f] === undefined) {
              _0x269be7[_0x159930][_0xfb319f] = _0x2cb8c5;
              _0x811367 = true;
            }
          });
        }
      });
      return _0x811367;
    }
    static async ["pInit"]() {
      if (this._IS_INIT_SAVE_REQUIRED) {
        Config._saveConfigDebounced();
      }
      this._IS_INIT_SAVE_REQUIRED = false;
    }
    static ["_getDefaultGmConfig"]() {
      return this._getDefaultConfig({
        'isPlayer': false
      });
    }
    static ["_getDefaultPlayerConfig"]() {
      return this._getDefaultConfig({
        'isPlayer': true
      });
    }
    static ["_getDefaultConfig"](_0x3ef533) {
      _0x3ef533 = _0x3ef533 || {};
      const _0x3a1d8e = _0x3ef533.isPlayer;
      const _0x1f778c = MiscUtil.copy(ConfigConsts.getDefaultConfigSorted_());
      const _0x39f69c = {};
      _0x1f778c.forEach(([_0x1e3fbb, _0x120dfe]) => {
        const _0x5a892a = _0x39f69c[_0x1e3fbb] = {};
        const _0x2a5160 = _0x1fa78d => Object.entries(_0x1fa78d).forEach(([_0x249b71, _0x38a295]) => {
          if (_0x3a1d8e) {
            if (_0x38a295.isPlayerEditable) {
              _0x5a892a[_0x249b71] = null;
            }
          } else {
            _0x5a892a[_0x249b71] = _0x38a295["default"];
          }
        });
        if (_0x120dfe.settings) {
          _0x2a5160(_0x120dfe.settings);
        }
        if (_0x120dfe.settingsAdvanced) {
          _0x2a5160(_0x120dfe.settingsAdvanced);
        }
        if (_0x120dfe.settingsHacks) {
          _0x2a5160(_0x120dfe.settingsHacks);
        }
      });
      _0x39f69c.version = ConfigMigration.CURRENT_VERSION;
      return _0x39f69c;
    }
    static ['set'](_0x4f9d2a, _0x1112ce, _0xc4fc91) {
      if (!this._isCanSetConfig(_0x4f9d2a, _0x1112ce)) {
        return;
      }
      const _0x122bb6 = Config.get(_0x4f9d2a, _0x1112ce);
      const _0x5ededb = UtilPrePreInit.isGM() ? Config._CONFIG : Config._CONFIG_PLAYER;
      (_0x5ededb[_0x4f9d2a] = _0x5ededb[_0x4f9d2a] || {})[_0x1112ce] = _0xc4fc91;
      Config._saveConfigDebounced();
      this._fireConfigUpdateHook(_0x4f9d2a, _0x1112ce, _0x122bb6, _0xc4fc91);
    }
    static ['setTemp'](_0x43e89c, _0x14b600, _0x30dc13, {
      isSkipPermissionCheck = false
    } = {}) {
      if (!isSkipPermissionCheck && !this._isCanSetConfig(_0x43e89c, _0x14b600)) {
        return;
      }
      const _0x10d336 = Config.get(_0x43e89c, _0x14b600);
      (Config._CONFIG_TEMP[_0x43e89c] = Config._CONFIG_TEMP[_0x43e89c] || {})[_0x14b600] = _0x30dc13;
      this._fireConfigUpdateHook(_0x43e89c, _0x14b600, _0x10d336, _0x30dc13);
    }
    static ["setRivetTargetDocument"]({
      actor: _0x7aa906,
      pack: _0x11cb33
    } = {}) {
      if (_0x7aa906 && _0x11cb33) {
        throw new Error("Only one of \"actor\" or \"pack\" may be specified!");
      }
      if (!_0x7aa906 && !_0x11cb33) {
        ui.notifications.info("Cleared Rivet import target. Rivet will now import to an appropriate directory.");
        Config.set("rivet", "targetDocumentId", null);
        return;
      }
      if (_0x7aa906) {
        const _0x4dae8a = _0x7aa906.isToken ? _0x7aa906.uuid : _0x7aa906.id;
        if (Config.get("rivet", "targetDocumentId") === _0x4dae8a) {
          Config.set("rivet", "targetDocumentId", null);
          ui.notifications.warn("Cleared Rivet import target. Rivet will now import to an appropriate directory.");
          return;
        }
        Config.set("rivet", 'targetDocumentId', _0x4dae8a);
        ui.notifications.info("Set Rivet import target. Rivet will now import to Actor \"" + _0x7aa906.name + "\" (" + _0x4dae8a + "). This can be changed in the Config.");
        return;
      }
      if (_0x11cb33) {
        const _0xef065a = 'Compendium.' + _0x11cb33.metadata.id;
        if (Config.get('rivet', 'targetDocumentId') === _0xef065a) {
          Config.set("rivet", "targetDocumentId", null);
          ui.notifications.warn("Cleared Rivet import target. Rivet will now import to an appropriate directory.");
          return;
        }
        Config.set('rivet', "targetDocumentId", _0xef065a);
        ui.notifications.info("Set Rivet import target. Rivet will now import to Compendium \"" + _0x11cb33.metadata.label + "\" (" + _0x11cb33.metadata.id + "). This can be changed in the Config.");
      }
    }
    static ["_fireConfigUpdateHook"](_0x374034, _0xb156d3, _0x305b29, _0xea010c) {
      UtilHooks.callAll(UtilHooks.HK_CONFIG_UPDATE, {
        'previous': {
          [_0x374034]: {
            [_0xb156d3]: _0x305b29
          }
        },
        'current': {
          [_0x374034]: {
            [_0xb156d3]: _0xea010c
          }
        }
      });
    }
    static ["_isCanSetConfig"](_0x347dfb, _0x3965df) {
      return UtilPrePreInit.isGM() || ConfigUtilsSettings.isPlayerEditable(_0x347dfb, _0x3965df);
    }
    static ["_LOCK_SAVE_CONFIG"] = new VeLock({
      'name': "save config"
    });
    static async ["_pSaveConfig"]() {
      try {
        await this._LOCK_SAVE_CONFIG.pLock();
        await this._pSaveConfig_();
      } finally {
        this._LOCK_SAVE_CONFIG.unlock();
      }
    }
    static async ["_pSaveConfig_"]() {
      if (!UtilPrePreInit.isGM()) {
        await GameStorage.pSetClient(Config._CLIENT_SETTINGS_KEY, MiscUtil.copy(Config._CONFIG_PLAYER));
        return;
      }
      await game.settings.set(SharedConsts.MODULE_ID, Config._SETTINGS_KEY, MiscUtil.copy(Config._CONFIG));
      const _0x473106 = {
        'type': "config.update",
        'config': MiscUtil.copy(this._CONFIG)
      };
      game.socket.emit(Config._SOCKET_ID, _0x473106);
    }
    static ["_saveConfigDebounced"] = MiscUtil.throttle(Config._pSaveConfig, 0x64);
    static get(_0x1f916e, _0x501497, {isIgnorePlayer = false} = {}) {
      if (Config._CONFIG_TEMP[_0x1f916e]?.[_0x501497] !== undefined) {
        return Config._CONFIG_TEMP[_0x1f916e][_0x501497];
      }
      if (!UtilPrePreInit.isGM() && ConfigUtilsSettings.isPlayerEditable(_0x1f916e, _0x501497) && !isIgnorePlayer) {
        const _0x15b827 = (Config._CONFIG_PLAYER[_0x1f916e] || {})[_0x501497];
        if (ConfigUtilsSettings.isNullable(_0x1f916e, _0x501497) && _0x15b827 === null || _0x15b827 != null) {
          return this._get_getValidValue(_0x1f916e, _0x501497, _0x15b827);
        }
      }
      const _0x470979 = (Config._CONFIG[_0x1f916e] || {})[_0x501497];
      return this._get_getValidValue(_0x1f916e, _0x501497, _0x470979);
    }
    static ["_get_getValidValue"](_0x2319bc, _0x734aa3, _0x56c713) {
      const _0x14e622 = ConfigConsts.getDefaultConfigSortedFlat_().find(([_0x35aa58]) => _0x35aa58 === _0x2319bc)[0x1][_0x734aa3];
      if (_0x14e622.type !== "enum") {
        return _0x56c713;
      }
      if (_0x14e622.isNullable && _0x56c713 == null) {
        return _0x56c713;
      }
      const _0x4bd728 = ConfigUtilsSettings.getEnumValues(_0x14e622);
      if (_0x56c713 == null || !_0x4bd728.some(_0x472e97 => (_0x472e97.value ?? _0x472e97) === _0x56c713)) {
        return _0x14e622["default"] ?? _0x4bd728[0x0].value ?? _0x4bd728[0x0];
      }
      return _0x56c713;
    }
    static ["_getDisplayLabels"](_0x288279, _0xf85c74) {
      const _0x6262b3 = ConfigConsts.getDefaultConfig_();
      const _0x5cebfe = _0x6262b3[_0x288279]?.["name"];
      const _0x956382 = _0x6262b3[_0x288279]?.["settings"]?.[_0xf85c74]?.['name'] || _0x6262b3[_0x288279]?.['settingsAdvanced']?.[_0xf85c74]?.["name"] || _0x6262b3[_0x288279]?.['settingsHacks']?.[_0xf85c74]?.['name'];
      return {
        'displayGroup': _0x5cebfe,
        'displayKey': _0x956382
      };
    }
    static ['has'](_0x23c99c, _0x413db8) {
      return !!ConfigConsts.getDefaultConfigSortedFlat_().find(([_0x24a9a0]) => _0x24a9a0 === _0x23c99c)?.[0x1]?.[_0x413db8];
    }
    static ["getSafe"](_0x48e921, _0x55bcb1) {
      try {
        return this.get(_0x48e921, _0x55bcb1);
      } catch (_0x3f1440) {
        return undefined;
      }
    }
    static ["handleFailedInitConfigApplication"](_0x26ed85, _0x525fb9, _0x1a25c6) {
      const {
        displayGroup: _0x576794,
        displayKey: _0x1c32ad
      } = Config._getDisplayLabels(_0x26ed85, _0x525fb9);
      ui.notifications.error("Failed to apply Config \"" + _0x1c32ad + "\" -> \"" + _0x576794 + "\" during initial load! " + VeCt.STR_SEE_CONSOLE);
      if (_0x1a25c6) {
        console.error(...LGT, _0x1a25c6);
      }
    }
    static ["isUseMetricDistance"]({
      configGroup: _0x4095b3,
      configKey = "isMetricDistance"
    }) {
      return Config.get("import", "isGlobalMetricDistance") || Config.has(_0x4095b3, configKey) && Config.get(_0x4095b3, configKey);
    }
    static ["isUseMetricWeight"]({
      configGroup: _0x335df5,
      configKey = "isMetricWeight"
    }) {
      if (UtilGameSettings.getSafe(game.system.id, "metricWeightUnits")) {
        return true;
      }
      return Config.get('import', "isGlobalMetricWeight") || Config.has(_0x335df5, configKey) && Config.get(_0x335df5, configKey);
    }
    static ["getMetricNumberDistance"]({
      configGroup: _0x287496,
      originalValue: _0x2525c8,
      originalUnit: _0x15cbf9,
      configKey = "isMetricDistance",
      toFixed: _0x4780c3
    }) {
      return this._getMetricNumber({
        'configGroup': _0x287496,
        'originalValue': _0x2525c8,
        'originalUnit': _0x15cbf9,
        'configKey': configKey,
        'fnIsUse': Config.isUseMetricDistance.bind(Config),
        'toFixed': _0x4780c3
      });
    }
    static ['getMetricNumberWeight']({
      configGroup: _0x472563,
      originalValue: _0x3bcac6,
      originalUnit: _0x2715b2,
      configKey = "isMetricWeight",
      toFixed: _0x371dc8
    }) {
      return this._getMetricNumber({
        'configGroup': _0x472563,
        'originalValue': _0x3bcac6,
        'originalUnit': _0x2715b2,
        'configKey': configKey,
        'fnIsUse': Config.isUseMetricWeight.bind(Config),
        'toFixed': _0x371dc8
      });
    }
    static ["_getMetricNumber"]({
      configGroup: _0x3f59a7,
      originalValue: _0xb3e2df,
      originalUnit: _0x48ea42,
      configKey: _0x3f6086,
      fnIsUse: _0x4e4c24,
      toFixed: _0x13e977
    }) {
      if (!_0x4e4c24({
        'configGroup': _0x3f59a7,
        'configKey': _0x3f6086
      })) {
        if (_0x13e977) {
          return NumberUtil.toFixedNumber(_0xb3e2df, _0x13e977);
        }
        return _0xb3e2df;
      }
      return Parser.metric.getMetricNumber({
        'originalValue': _0xb3e2df,
        'originalUnit': _0x48ea42,
        'toFixed': _0x13e977 ?? 0x3
      });
    }
    static ['getMetricUnitDistance']({
      configGroup: _0x293bb4,
      originalUnit: _0x3ed5b6,
      configKey = "isMetricDistance",
      isShortForm = true,
      isPlural = false
    }) {
      return this._getMetricUnit({
        'configGroup': _0x293bb4,
        'originalUnit': _0x3ed5b6,
        'configKey': configKey,
        'isShortForm': isShortForm,
        'isPlural': isPlural,
        'fnIsUse': Config.isUseMetricDistance.bind(Config)
      });
    }
    static ["getMetricUnitWeight"]({
      configGroup: _0x486606,
      originalUnit: _0x50698d,
      configKey = "isMetricWeight",
      isShortForm = true,
      isPlural = false
    }) {
      return this._getMetricUnit({
        'configGroup': _0x486606,
        'originalUnit': _0x50698d,
        'configKey': configKey,
        'isShortForm': isShortForm,
        'isPlural': isPlural,
        'fnIsUse': Config.isUseMetricWeight.bind(Config)
      });
    }
    static ["_getMetricUnit"]({
      configGroup: _0x50bdc7,
      originalUnit: _0x5f0dc8,
      configKey: _0x4280fe,
      isShortForm: _0x45e3bf,
      isPlural: _0x44cab6,
      fnIsUse: _0x2933c2
    }) {
      if (!_0x2933c2({
        'configGroup': _0x50bdc7,
        'configKey': _0x4280fe
      })) {
        if (!_0x45e3bf) {
          return _0x5f0dc8;
        }
        switch (_0x5f0dc8) {
          case Parser.UNT_FEET:
            return 'ft';
          case Parser.UNT_YARDS:
            return 'yd';
          case Parser.UNT_MILES:
            return 'mi';
          default:
            return _0x5f0dc8;
        }
      }
      return Parser.metric.getMetricUnit({
        'originalUnit': _0x5f0dc8,
        'isShortForm': _0x45e3bf,
        'isPlural': _0x44cab6
      });
    }
    static ["getSpellPointsKey"]({
      actorType: _0x34101f
    }) {
      return _0x34101f === 'character' ? "spellPointsMode" : "spellPointsModeNpc";
    }
    static ["getSpellPointsResource"]({
      isValueKey = false,
      isMaxKey = false
    } = {}) {
      return this._getSpellPsiPointsResource({
        'configGroup': "importSpell",
        'configKey': "spellPointsResource",
        'configKeyCustom': "spellPointsResourceCustom",
        'isValueKey': isValueKey,
        'isMaxKey': isMaxKey
      });
    }
    static ["getPsiPointsResource"]({
      isValueKey = false,
      isMaxKey = false
    } = {}) {
      return this._getSpellPsiPointsResource({
        'configGroup': "importPsionic",
        'configKey': "psiPointsResource",
        'configKeyCustom': "psiPointsResourceCustom",
        'isValueKey': isValueKey,
        'isMaxKey': isMaxKey
      });
    }
    static ["_getSpellPsiPointsResource"]({
      configGroup: _0x5ff393,
      configKey: _0x61a78,
      configKeyCustom: _0x27b383,
      isValueKey = false,
      isMaxKey = false
    } = {}) {
      if (Config.get(_0x5ff393, _0x61a78) === ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM) {
        return ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM;
      }
      if (isValueKey && isMaxKey) {
        throw new Error("Only one of \"isValue\" and \"isMax\" may be specified!");
      }
      const _0x265e6e = Config.get(_0x5ff393, _0x61a78) === ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM ? Config.get(_0x5ff393, _0x27b383) : Config.get(_0x5ff393, _0x61a78);
      return isValueKey ? _0x265e6e + ".value" : isMaxKey ? _0x265e6e + ".max" : _0x265e6e;
    }
}
Config._SETTINGS_KEY = "config";
Config._CLIENT_SETTINGS_KEY = SharedConsts.MODULE_ID + '_config';
Config._SOCKET_ID = "module." + SharedConsts.MODULE_ID;
Config._CONFIG = {};
Config._CONFIG_PLAYER = {};
Config._CONFIG_TEMP = {};
//#endregion



//#endregion

//#region FILTERS

//#region FilterBox
//TEMP ProxyBase seems to just be a MixedProxyBase
class FilterBox extends ProxyBase
//extends ProxyBase
{
    static TITLE_BTN_RESET = "Reset filters. SHIFT to reset everything.";

    static selectFirstVisible(entryList) {
        if (Hist.lastLoadedId == null && !Hist.initialLoad) {
            Hist._freshLoad();
        }

    }

    constructor(opts) {
        super();

        this._$iptSearch = opts.$iptSearch;
        this._$wrpFormTop = opts.$wrpFormTop;
        this._$btnReset = opts.$btnReset;
        this._$btnOpen = opts.$btnOpen;
        this._$wrpMiniPills = opts.$wrpMiniPills;
        this._$btnToggleSummaryHidden = opts.$btnToggleSummaryHidden;
        this._filters = opts.filters;
        this._isCompact = opts.isCompact;
        this._namespace = opts.namespace;

        this._doSaveStateThrottled = MiscUtil.throttle(()=>this._pDoSaveState(), 50);
        this.__meta = this._getDefaultMeta();
        if (this._isCompact)
            this.__meta.isSummaryHidden = true;

        this._meta = this._getProxy("meta", this.__meta);
        this.__minisHidden = {};
        this._minisHidden = this._getProxy("minisHidden", this.__minisHidden);
        this.__combineAs = {};
        this._combineAs = this._getProxy("combineAs", this.__combineAs);
        this._modalMeta = null;
        this._isRendered = false;

        this._cachedState = null;

        this._compSearch = BaseComponent.fromObject({
            search: ""
        });
        this._metaIptSearch = null;

        this._filters.forEach(f=>f.filterBox = this);

        this._eventListeners = {};
    }

    get filters() {
        return this._filters;
    }

    teardown() {
        this._filters.forEach(f=>f._doTeardown());
        if (this._modalMeta)
            this._modalMeta.doTeardown();
    }

    on(identifier, fn) {
        const [eventName,namespace] = identifier.split(".");
        (this._eventListeners[eventName] = this._eventListeners[eventName] || []).push({
            namespace,
            fn
        });
        return this;
    }

    off(identifier, fn=null) {
        const [eventName,namespace] = identifier.split(".");
        this._eventListeners[eventName] = (this._eventListeners[eventName] || []).filter(it=>{
            if (fn != null)
                return it.namespace !== namespace || it.fn !== fn;
            return it.namespace !== namespace;
        }
        );
        if (!this._eventListeners[eventName].length)
            delete this._eventListeners[eventName];
        return this;
    }

    fireChangeEvent() {
        this._doSaveStateThrottled();
        this.fireEvent(FilterBox.EVNT_VALCHANGE);
    }

    fireEvent(eventName) {
        (this._eventListeners[eventName] || []).forEach(it=>it.fn());
    }

    _getNamespacedStorageKey() {
        return `${FilterBox._STORAGE_KEY}${this._namespace ? `.${this._namespace}` : ""}`;
    }
    getNamespacedHashKey(k) {
        return `${k || "_".repeat(FilterUtil.SUB_HASH_PREFIX_LENGTH)}${this._namespace ? `.${this._namespace}` : ""}`;
    }

    async pGetStoredActiveSources() {
        const stored = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
        if (stored) {
            const sourceFilterData = stored.filters[FilterBox.SOURCE_HEADER];
            if (sourceFilterData) {
                const state = sourceFilterData.state;
                const blue = [];
                const white = [];
                Object.entries(state).forEach(([src,mode])=>{
                    if (mode === 1)
                        blue.push(src);
                    else if (mode !== -1)
                        white.push(src);
                }
                );
                if (blue.length)
                    return blue;
                else
                    return white;
            }
        }
        return null;
    }

    registerMinisHiddenHook(prop, hook) {
        this._addHook("minisHidden", prop, hook);
    }

    isMinisHidden(header) {
        return !!this._minisHidden[header];
    }

    async pDoLoadState() {
        const toLoad = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
        if (toLoad == null)
            return;
        this._setStateFromLoaded(toLoad, {
            isUserSavedState: true
        });
    }

    _setStateFromLoaded(state, {isUserSavedState=false}={}) {
        state.box = state.box || {};
        this._proxyAssign("meta", "_meta", "__meta", state.box.meta || {}, true);
        this._proxyAssign("minisHidden", "_minisHidden", "__minisHidden", state.box.minisHidden || {}, true);
        this._proxyAssign("combineAs", "_combineAs", "__combineAs", state.box.combineAs || {}, true);
        this._filters.forEach(it=>it.setStateFromLoaded(state.filters, {
            isUserSavedState
        }));
    }

    _getSaveableState() {
        const filterOut = {};
        this._filters.forEach(it=>Object.assign(filterOut, it.getSaveableState()));
        return {
            box: {
                meta: {
                    ...this.__meta
                },
                minisHidden: {
                    ...this.__minisHidden
                },
                combineAs: {
                    ...this.__combineAs
                },
            },
            filters: filterOut,
        };
    }

    async _pDoSaveState() {
        await StorageUtil.pSetForPage(this._getNamespacedStorageKey(), this._getSaveableState());
    }

    trimState_() {
        this._filters.forEach(f=>f.trimState_());
    }

    render() {
        if (this._isRendered) {
            this._filters.map(f=>f.update());
            return;
        }
        this._isRendered = true;

        if (this._$wrpFormTop || this._$wrpMiniPills) {
            if (!this._$wrpMiniPills) {
                this._$wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`).insertAfter(this._$wrpFormTop);
            } else {
                this._$wrpMiniPills.addClass("fltr__mini-view");
            }
        }

        if (this._$btnReset) {
            this._$btnReset.title(FilterBox.TITLE_BTN_RESET).click((evt)=>this.reset(evt.shiftKey));
        }

        if (this._$wrpFormTop || this._$btnToggleSummaryHidden) {
            if (!this._$btnToggleSummaryHidden) {
                this._$btnToggleSummaryHidden = $(`<button class="btn btn-default ${this._isCompact ? "p-2" : ""}" title="Toggle Filter Summary"><span class="glyphicon glyphicon-resize-small"></span></button>`).prependTo(this._$wrpFormTop);
            } else if (!this._$btnToggleSummaryHidden.parent().length) {
                this._$btnToggleSummaryHidden.prependTo(this._$wrpFormTop);
            }
            this._$btnToggleSummaryHidden.click(()=>{
                this._meta.isSummaryHidden = !this._meta.isSummaryHidden;
                this._doSaveStateThrottled();
            }
            );
            const summaryHiddenHook = ()=>{
                this._$btnToggleSummaryHidden.toggleClass("active", !!this._meta.isSummaryHidden);
                this._$wrpMiniPills.toggleClass("ve-hidden", !!this._meta.isSummaryHidden);
            }
            ;
            this._addHook("meta", "isSummaryHidden", summaryHiddenHook);
            summaryHiddenHook();
        }

        if (this._$wrpFormTop || this._$btnOpen) {
            if (!this._$btnOpen) {
                this._$btnOpen = $(`<button class="btn btn-default ${this._isCompact ? "px-2" : ""}">Filter</button>`).prependTo(this._$wrpFormTop);
            } else if (!this._$btnOpen.parent().length) {
                this._$btnOpen.prependTo(this._$wrpFormTop);
            }
            this._$btnOpen.click(()=>this.show());
        }

        const sourceFilter = this._filters.find(it=>it.header === FilterBox.SOURCE_HEADER);
        if (sourceFilter) {
            const selFnAlt = (val)=>!SourceUtil.isNonstandardSource(val) && !PrereleaseUtil.hasSourceJson(val) && !BrewUtil2.hasSourceJson(val);
            const hkSelFn = ()=>{
                if (this._meta.isBrewDefaultHidden)
                    sourceFilter.setTempFnSel(selFnAlt);
                else
                    sourceFilter.setTempFnSel(null);
                sourceFilter.updateMiniPillClasses();
            }
            ;
            this._addHook("meta", "isBrewDefaultHidden", hkSelFn);
            hkSelFn();
        }

        if (this._$wrpMiniPills)
            this._filters.map((f,i)=>f.$renderMinis({
                filterBox: this,
                isFirst: i === 0,
                $wrpMini: this._$wrpMiniPills
            }));
    }

    async _render_pRenderModal() {
        this._isModalRendered = true;

        this._modalMeta = await UiUtil.pGetShowModal({
            isHeight100: true,
            isWidth100: true,
            isUncappedHeight: true,
            isIndestructible: true,
            isClosed: true,
            isEmpty: true,
            title: "Filter",
            cbClose: (isDataEntered)=>this._pHandleHide(!isDataEntered),
        });

        const $children = this._filters.map((f,i)=>f.$render({
            filterBox: this,
            isFirst: i === 0,
            $wrpMini: this._$wrpMiniPills
        }));

        this._metaIptSearch = ComponentUiUtil.$getIptStr(this._compSearch, "search", {
            decorationRight: "clear",
            asMeta: true,
            html: `<input class="form-control input-xs" placeholder="Search...">`
        }, );
        this._compSearch._addHookBase("search", ()=>{
            const searchTerm = this._compSearch._state.search.toLowerCase();
            this._filters.forEach(f=>f.handleSearch(searchTerm));
        }
        );

        const $btnShowAllFilters = $(`<button class="btn btn-xs btn-default">Show All</button>`).click(()=>this.showAllFilters());
        const $btnHideAllFilters = $(`<button class="btn btn-xs btn-default">Hide All</button>`).click(()=>this.hideAllFilters());

        const $btnReset = $(`<button class="btn btn-xs btn-default mr-3" title="${FilterBox.TITLE_BTN_RESET}">Reset</button>`).click(evt=>this.reset(evt.shiftKey));

        const $btnSettings = $(`<button class="btn btn-xs btn-default mr-3"><span class="glyphicon glyphicon-cog"></span></button>`).click(()=>this._pOpenSettingsModal());

        const $btnSaveAlt = $(`<button class="btn btn-xs btn-primary" title="Save"><span class="glyphicon glyphicon-ok"></span></button>`).click(()=>this._modalMeta.doClose(true));

        const $wrpBtnCombineFilters = $(`<div class="btn-group mr-3"></div>`);
        const $btnCombineFilterSettings = $(`<button class="btn btn-xs btn-default"><span class="glyphicon glyphicon-cog"></span></button>`).click(()=>this._pOpenCombineAsModal());

        const btnCombineFiltersAs = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default`,
            click: ()=>this._meta.modeCombineFilters = FilterBox._COMBINE_MODES.getNext(this._meta.modeCombineFilters),
            title: `"AND" requires every filter to match. "OR" requires any filter to match. "Custom" allows you to specify a combination (every "AND" filter must match; only one "OR" filter must match) .`,
        }).appendTo($wrpBtnCombineFilters[0]);

        const hook = ()=>{
            btnCombineFiltersAs.innerText = this._meta.modeCombineFilters === "custom" ? this._meta.modeCombineFilters.uppercaseFirst() : this._meta.modeCombineFilters.toUpperCase();
            if (this._meta.modeCombineFilters === "custom")
                $wrpBtnCombineFilters.append($btnCombineFilterSettings);
            else
                $btnCombineFilterSettings.detach();
            this._doSaveStateThrottled();
        }
        ;
        this._addHook("meta", "modeCombineFilters", hook);
        hook();

        const $btnSave = $(`<button class="btn btn-primary fltr__btn-close mr-2">Save</button>`).click(()=>this._modalMeta.doClose(true));

        const $btnCancel = $(`<button class="btn btn-default fltr__btn-close">Cancel</button>`).click(()=>this._modalMeta.doClose(false));

        $$(this._modalMeta.$modal)`<div class="split mb-2 mt-2 ve-flex-v-center mobile__ve-flex-col">
			<div class="ve-flex-v-baseline mobile__ve-flex-col">
				<h4 class="m-0 mr-2 mobile__mb-2">Filters</h4>
				${this._metaIptSearch.$wrp.addClass("mobile__mb-2")}
			</div>
			<div class="ve-flex-v-center mobile__ve-flex-col">
				<div class="ve-flex-v-center mobile__m-1">
					<div class="mr-2">Combine as</div>
					${$wrpBtnCombineFilters}
				</div>
				<div class="ve-flex-v-center mobile__m-1">
					<div class="btn-group mr-2 ve-flex-h-center">
						${$btnShowAllFilters}
						${$btnHideAllFilters}
					</div>
					${$btnReset}
					${$btnSettings}
					${$btnSaveAlt}
				</div>
			</div>
		</div>
		<hr class="w-100 m-0 mb-2">

		<hr class="mt-1 mb-1">
		<div class="ui-modal__scroller smooth-scroll px-1">
			${$children}
		</div>
		<hr class="my-1 w-100">
		<div class="w-100 ve-flex-vh-center my-1">${$btnSave}${$btnCancel}</div>`;
    }

    async _pOpenSettingsModal() {
        const {$modalInner} = await UiUtil.pGetShowModal({
            title: "Settings"
        });

        UiUtil.$getAddModalRowCb($modalInner, "Deselect Homebrew Sources by Default", this._meta, "isBrewDefaultHidden");

        UiUtil.addModalSep($modalInner);

        UiUtil.$getAddModalRowHeader($modalInner, "Hide summary for filter...", {
            helpText: "The summary is the small red and blue button panel which appear below the search bar."
        });
        this._filters.forEach(f=>UiUtil.$getAddModalRowCb($modalInner, f.header, this._minisHidden, f.header));

        UiUtil.addModalSep($modalInner);

        const $rowResetAlwaysSave = UiUtil.$getAddModalRow($modalInner, "div").addClass("pr-2");
        $rowResetAlwaysSave.append(`<span>Always Save on Close</span>`);
        $(`<button class="btn btn-xs btn-default">Reset</button>`).appendTo($rowResetAlwaysSave).click(async()=>{
            await StorageUtil.pRemove(FilterBox._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED);
            JqueryUtil.doToast("Saved!");
        }
        );
    }

    async _pOpenCombineAsModal() {
        const {$modalInner} = await UiUtil.pGetShowModal({
            title: "Filter Combination Logic"
        });
        const $btnReset = $(`<button class="btn btn-xs btn-default">Reset</button>`).click(()=>{
            Object.keys(this._combineAs).forEach(k=>this._combineAs[k] = "and");
            $sels.forEach($sel=>$sel.val("0"));
        }
        );
        UiUtil.$getAddModalRowHeader($modalInner, "Combine filters as...", {
            $eleRhs: $btnReset
        });
        const $sels = this._filters.map(f=>UiUtil.$getAddModalRowSel($modalInner, f.header, this._combineAs, f.header, ["and", "or"], {
            fnDisplay: (it)=>it.toUpperCase()
        }));
    }

    getValues({nxtStateOuter=null}={}) {
        const outObj = {};
        this._filters.forEach(f=>Object.assign(outObj, f.getValues({
            nxtState: nxtStateOuter?.filters
        })));
        return outObj;
    }

    addEventListener(type, listener) {
        (this._$wrpFormTop ? this._$wrpFormTop[0] : this._$btnOpen[0]).addEventListener(type, listener);
    }

    _mutNextState_reset_meta({tgt}) {
        Object.assign(tgt, this._getDefaultMeta());
    }

    _mutNextState_minisHidden({tgt}) {
        Object.assign(tgt, this._getDefaultMinisHidden(tgt));
    }

    _mutNextState_combineAs({tgt}) {
        Object.assign(tgt, this._getDefaultCombineAs(tgt));
    }

    _reset_meta() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_reset_meta({
            tgt: nxtBoxState.meta
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    _reset_minisHidden() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_minisHidden({
            tgt: nxtBoxState.minisHidden
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    _reset_combineAs() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_combineAs({
            tgt: nxtBoxState.combineAs
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    reset(isResetAll) {
        this._filters.forEach(f=>f.reset({
            isResetAll
        }));
        if (isResetAll) {
            this._reset_meta();
            this._reset_minisHidden();
            this._reset_combineAs();
        }
        this.render();
        this.fireChangeEvent();
    }

    async show() {
        if (!this._isModalRendered)
            await this._render_pRenderModal();
        this._cachedState = this._getSaveableState();
        this._modalMeta.doOpen();
        if (this._metaIptSearch?.$ipt)
            this._metaIptSearch.$ipt.focus();
    }

    async _pHandleHide(isCancel=false) {
        if (this._cachedState && isCancel) {
            const curState = this._getSaveableState();
            const hasChanges = !CollectionUtil.deepEquals(curState, this._cachedState);

            if (hasChanges) {
                const isSave = await InputUiUtil.pGetUserBoolean({
                    title: "Unsaved Changes",
                    textYesRemember: "Always Save",
                    textYes: "Save",
                    textNo: "Discard",
                    storageKey: FilterBox._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED,
                    isGlobal: true,
                });
                if (isSave) {
                    this._cachedState = null;
                    this.fireChangeEvent();
                    return;
                } else
                    this._setStateFromLoaded(this._cachedState, {
                        isUserSavedState: true
                    });
            }
        } else {
            this.fireChangeEvent();
        }

        this._cachedState = null;
    }

    showAllFilters() {
        this._filters.forEach(f=>f.show());
    }

    hideAllFilters() {
        this._filters.forEach(f=>f.hide());
    }

    unpackSubHashes(subHashes, {force=false}={}) {
        const unpacked = {};
        subHashes.forEach(s=>{
            const unpackedPart = UrlUtil.unpackSubHash(s, true);
            if (Object.keys(unpackedPart).length > 1)
                throw new Error(`Multiple keys in subhash!`);
            const k = Object.keys(unpackedPart)[0];
            unpackedPart[k] = {
                clean: unpackedPart[k],
                raw: s
            };
            Object.assign(unpacked, unpackedPart);
        }
        );

        const urlHeaderToFilter = {};
        this._filters.forEach(f=>{
            const childFilters = f.getChildFilters();
            if (childFilters.length)
                childFilters.forEach(f=>urlHeaderToFilter[f.header.toLowerCase()] = f);
            urlHeaderToFilter[f.header.toLowerCase()] = f;
        }
        );

        const urlHeadersUpdated = new Set();
        const subHashesConsumed = new Set();
        let filterInitialSearch;

        const filterBoxState = {};
        const statePerFilter = {};
        const prefixLen = this.getNamespacedHashKey().length;
        Object.entries(unpacked).forEach(([hashKey,data])=>{
            const rawPrefix = hashKey.substring(0, prefixLen);
            const prefix = rawPrefix.substring(0, FilterUtil.SUB_HASH_PREFIX_LENGTH);

            const urlHeader = hashKey.substring(prefixLen);

            if (FilterUtil.SUB_HASH_PREFIXES.has(prefix) && urlHeaderToFilter[urlHeader]) {
                (statePerFilter[urlHeader] = statePerFilter[urlHeader] || {})[prefix] = data.clean;
                urlHeadersUpdated.add(urlHeader);
                subHashesConsumed.add(data.raw);
                return;
            }

            if (Object.values(FilterBox._SUB_HASH_PREFIXES).includes(prefix)) {
                if (prefix === VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX)
                    filterInitialSearch = data.clean[0];
                else
                    filterBoxState[prefix] = data.clean;
                subHashesConsumed.add(data.raw);
                return;
            }

            if (FilterUtil.SUB_HASH_PREFIXES.has(prefix))
                throw new Error(`Could not find filter with header ${urlHeader} for subhash ${data.raw}`);
        }
        );

        if (!subHashesConsumed.size && !force)
            return null;

        return {
            urlHeaderToFilter,
            filterBoxState,
            statePerFilter,
            urlHeadersUpdated,
            unpacked,
            subHashesConsumed,
            filterInitialSearch,
        };
    }

    setFromSubHashes(subHashes, {force=false, $iptSearch=null}={}) {
        const unpackedSubhashes = this.unpackSubHashes(subHashes, {
            force
        });

        if (unpackedSubhashes == null)
            return subHashes;

        const {unpacked, subHashesConsumed, filterInitialSearch, } = unpackedSubhashes;

        const {box: nxtStateBox, filters: nxtStatesFilters} = this.getNextStateFromSubHashes({
            unpackedSubhashes
        });

        this._setBoxStateFromNextBoxState(nxtStateBox);

        this._filters.flatMap(f=>[f, ...f.getChildFilters(), ]).filter(filter=>nxtStatesFilters[filter.header]).forEach(filter=>filter.setStateFromNextState(nxtStatesFilters));

        if (filterInitialSearch && ($iptSearch || this._$iptSearch))
            ($iptSearch || this._$iptSearch).val(filterInitialSearch).change().keydown().keyup().trigger("instantKeyup");

        const [link] = Hist.getHashParts();

        const outSub = [];
        Object.values(unpacked).filter(v=>!subHashesConsumed.has(v.raw)).forEach(v=>outSub.push(v.raw));

        Hist.setSuppressHistory(true);
        Hist.replaceHistoryHash(`${link}${outSub.length ? `${HASH_PART_SEP}${outSub.join(HASH_PART_SEP)}` : ""}`);

        this.fireChangeEvent();
        Hist.hashChange({
            isBlankFilterLoad: true
        });
        return outSub;
    }

    getNextStateFromSubHashes({unpackedSubhashes}) {
        const {urlHeaderToFilter, filterBoxState, statePerFilter, urlHeadersUpdated, } = unpackedSubhashes;

        const nxtStateBox = this._getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState);

        const nxtStateFilters = {};

        Object.entries(statePerFilter).forEach(([urlHeader,state])=>{
            const filter = urlHeaderToFilter[urlHeader];
            Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(state));
        }
        );

        Object.keys(urlHeaderToFilter).filter(k=>!urlHeadersUpdated.has(k)).forEach(k=>{
            const filter = urlHeaderToFilter[k];
            Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(null));
        }
        );

        return {
            box: nxtStateBox,
            filters: nxtStateFilters
        };
    }

    _getNextBoxState_base() {
        return {
            meta: MiscUtil.copyFast(this.__meta),
            minisHidden: MiscUtil.copyFast(this.__minisHidden),
            combineAs: MiscUtil.copyFast(this.__combineAs),
        };
    }

    _getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState) {
        const nxtBoxState = this._getNextBoxState_base();

        let hasMeta = false;
        let hasMinisHidden = false;
        let hasCombineAs = false;

        Object.entries(filterBoxState).forEach(([k,vals])=>{
            const mappedK = this.getNamespacedHashKey(Parser._parse_bToA(FilterBox._SUB_HASH_PREFIXES, k));
            switch (mappedK) {
            case "meta":
                {
                    hasMeta = true;
                    const data = vals.map(v=>UrlUtil.mini.decompress(v));
                    Object.keys(this._getDefaultMeta()).forEach((k,i)=>nxtBoxState.meta[k] = data[i]);
                    break;
                }
            case "minisHidden":
                {
                    hasMinisHidden = true;
                    Object.keys(nxtBoxState.minisHidden).forEach(k=>nxtBoxState.minisHidden[k] = false);
                    vals.forEach(v=>{
                        const [urlHeader,isHidden] = v.split("=");
                        const filter = urlHeaderToFilter[urlHeader];
                        if (!filter)
                            throw new Error(`Could not find filter with name "${urlHeader}"`);
                        nxtBoxState.minisHidden[filter.header] = !!Number(isHidden);
                    }
                    );
                    break;
                }
            case "combineAs":
                {
                    hasCombineAs = true;
                    Object.keys(nxtBoxState.combineAs).forEach(k=>nxtBoxState.combineAs[k] = "and");
                    vals.forEach(v=>{
                        const [urlHeader,ixCombineMode] = v.split("=");
                        const filter = urlHeaderToFilter[urlHeader];
                        if (!filter)
                            throw new Error(`Could not find filter with name "${urlHeader}"`);
                        nxtBoxState.combineAs[filter.header] = FilterBox._COMBINE_MODES[ixCombineMode] || FilterBox._COMBINE_MODES[0];
                    }
                    );
                    break;
                }
            }
        }
        );

        if (!hasMeta)
            this._mutNextState_reset_meta({
                tgt: nxtBoxState.meta
            });
        if (!hasMinisHidden)
            this._mutNextState_minisHidden({
                tgt: nxtBoxState.minisHidden
            });
        if (!hasCombineAs)
            this._mutNextState_combineAs({
                tgt: nxtBoxState.combineAs
            });

        return nxtBoxState;
    }

    _setBoxStateFromNextBoxState(nxtBoxState) {
        this._proxyAssignSimple("meta", nxtBoxState.meta, true);
        this._proxyAssignSimple("minisHidden", nxtBoxState.minisHidden, true);
        this._proxyAssignSimple("combineAs", nxtBoxState.combineAs, true);
    }

    getSubHashes(opts) {
        opts = opts || {};
        const out = [];
        const boxSubHashes = this.getBoxSubHashes();
        if (boxSubHashes)
            out.push(boxSubHashes);
        out.push(...this._filters.map(f=>f.getSubHashes()).filter(Boolean));
        if (opts.isAddSearchTerm && this._$iptSearch) {
            const searchTerm = UrlUtil.encodeForHash(this._$iptSearch.val().trim());
            if (searchTerm)
                out.push(UrlUtil.packSubHash(this._getSubhashPrefix("search"), [searchTerm]));
        }
        return out.flat();
    }

    getBoxSubHashes() {
        const out = [];

        const defaultMeta = this._getDefaultMeta();

        const anyNotDefault = Object.keys(defaultMeta).find(k=>this._meta[k] !== defaultMeta[k]);
        if (anyNotDefault) {
            const serMeta = Object.keys(defaultMeta).map(k=>UrlUtil.mini.compress(this._meta[k] === undefined ? defaultMeta[k] : this._meta[k]));
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("meta"), serMeta));
        }

        const setMinisHidden = Object.entries(this._minisHidden).filter(([k,v])=>!!v).map(([k])=>`${k.toUrlified()}=1`);
        if (setMinisHidden.length) {
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("minisHidden"), setMinisHidden));
        }

        const setCombineAs = Object.entries(this._combineAs).filter(([k,v])=>v !== FilterBox._COMBINE_MODES[0]).map(([k,v])=>`${k.toUrlified()}=${FilterBox._COMBINE_MODES.indexOf(v)}`);
        if (setCombineAs.length) {
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("combineAs"), setCombineAs));
        }

        return out.length ? out : null;
    }

    getFilterTag({isAddSearchTerm=false}={}) {
        const parts = this._filters.map(f=>f.getFilterTagPart()).filter(Boolean);
        if (isAddSearchTerm && this._$iptSearch) {
            const term = this._$iptSearch.val().trim();
            if (term)
                parts.push(`search=${term}`);
        }
        return `{@filter |${UrlUtil.getCurrentPage().replace(/\.html$/, "")}|${parts.join("|")}}`;
    }

    getDisplayState({nxtStateOuter=null}={}) {
        return this._filters.map(filter=>filter.getDisplayStatePart({
            nxtState: nxtStateOuter?.filters
        })).filter(Boolean).join("; ");
    }

    /**
     * Each of the objects inside 'values' will be matched with the header of any of this FilterBox's sub-filters.
     * You can get the headers of the sub-filters by looping through .filters and checking their 'header' property.
     * Each filter that matches their header with the object's name will have all of their filters set to 0 (false / do not let through).
     * The filter will then write values from the object (like Sources in this example).
     * Once complete, a change event will be fired.
     * @param {any} values example: {Source: {PHB: 1, XGE: 0}}
     */
    setFromValues(values) {
        this._filters.forEach(it=>it.setFromValues(values));
        this.fireChangeEvent();
    }

    toDisplay(boxState, ...entryVals) {
        return this._toDisplay(boxState, this._filters, entryVals);
    }

    toDisplayByFilters(boxState, ...filterToValueTuples) {
        return this._toDisplay(boxState, filterToValueTuples.map(it=>it.filter), filterToValueTuples.map(it=>it.value), );
    }

    _toDisplay(boxState, filters, entryVals) {
        switch (this._meta.modeCombineFilters) {
        case "and":
            return this._toDisplay_isAndDisplay(boxState, filters, entryVals);
        case "or":
            return this._toDisplay_isOrDisplay(boxState, filters, entryVals);
        case "custom":
            {
                if (entryVals.length !== filters.length)
                    throw new Error(`Number of filters and number of values did not match!`);

                const andFilters = [];
                const andValues = [];
                const orFilters = [];
                const orValues = [];

                for (let i = 0; i < filters.length; ++i) {
                    const f = filters[i];
                    if (!this._combineAs[f.header] || this._combineAs[f.header] === "and") {
                        andFilters.push(f);
                        andValues.push(entryVals[i]);
                    } else {
                        orFilters.push(f);
                        orValues.push(entryVals[i]);
                    }
                }

                return this._toDisplay_isAndDisplay(boxState, andFilters, andValues) && this._toDisplay_isOrDisplay(boxState, orFilters, orValues);
            }
        default:
            throw new Error(`Unhandled combining mode "${this._meta.modeCombineFilters}"`);
        }
    }

    _toDisplay_isAndDisplay(boxState, filters, vals) {
        return filters.map((f,i)=>f.toDisplay(boxState, vals[i])).every(it=>it);
    }

    _toDisplay_isOrDisplay(boxState, filters, vals) {
        const res = filters.map((f,i)=>{
            if (!f.isActive(boxState))
                return null;
            return f.toDisplay(boxState, vals[i]);
        }
        ).filter(it=>it != null);
        return res.length === 0 || res.find(it=>it);
    }

    _getSubhashPrefix(prop) {
        if (FilterBox._SUB_HASH_PREFIXES[prop])
            return this.getNamespacedHashKey(FilterBox._SUB_HASH_PREFIXES[prop]);
        throw new Error(`Unknown property "${prop}"`);
    }

    _getDefaultMeta() {
        const out = MiscUtil.copy(FilterBox._DEFAULT_META);
        if (this._isCompact)
            out.isSummaryHidden = true;
        return out;
    }

    _getDefaultMinisHidden(minisHidden) {
        if (!minisHidden)
            throw new Error(`Missing "minisHidden" argument!`);
        return Object.keys(minisHidden).mergeMap(k=>({
            [k]: false
        }));
    }

    _getDefaultCombineAs(combineAs) {
        if (!combineAs)
            throw new Error(`Missing "combineAs" argument!`);
        return Object.keys(combineAs).mergeMap(k=>({
            [k]: "and"
        }));
    }
};
FilterBox.EVNT_VALCHANGE = "valchange";
FilterBox.SOURCE_HEADER = "Source";
FilterBox._PILL_STATES = ["ignore", "yes", "no"];
FilterBox._COMBINE_MODES = ["and", "or", "custom"];
FilterBox._STORAGE_KEY = "filterBoxState";
FilterBox._DEFAULT_META = {
    modeCombineFilters: "and",
    isSummaryHidden: false,
    isBrewDefaultHidden: false,
};
FilterBox._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED = "filterAlwaysSaveUnchanged";

FilterBox._SUB_HASH_BOX_META_PREFIX = "fbmt";
FilterBox._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX = "fbmh";
FilterBox._SUB_HASH_BOX_COMBINE_AS_PREFIX = "fbca";
FilterBox._SUB_HASH_PREFIXES = {
    meta: FilterBox._SUB_HASH_BOX_META_PREFIX,
    minisHidden: FilterBox._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX,
    combineAs: FilterBox._SUB_HASH_BOX_COMBINE_AS_PREFIX,
    search: VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX,
};
//#endregion

//#region FilterItem
let FilterItem$1 = class FilterItem {
    constructor(options) {
        this.item = options.item;
        this.pFnChange = options.pFnChange;
        this.group = options.group;
        this.nest = options.nest;
        this.nestHidden = options.nestHidden;
        this.isIgnoreRed = options.isIgnoreRed;
        this.userData = options.userData;

        this.rendered = null;
        this.searchText = null;
    }
};

globalThis.FilterItem = FilterItem$1;
//#endregion

//#region Filter & FilterBase
class FilterBase extends BaseComponent {
    constructor(opts) {
        super();
        this._filterBox = null;

        this.header = opts.header;
        this._headerHelp = opts.headerHelp;

        this.__meta = {
            ...this.getDefaultMeta()
        };
        this._meta = this._getProxy("meta", this.__meta);

        this._hasUserSavedState = false;
    }

    _getRenderedHeader() {
        return `<span ${this._headerHelp ? `title="${this._headerHelp.escapeQuotes()}" class="help-subtle"` : ""}>${this.header}</span>`;
    }

    set filterBox(it) {
        this._filterBox = it;
    }

    show() {
        this._meta.isHidden = false;
    }

    hide() {
        this._meta.isHidden = true;
    }

    getBaseSaveableState() {
        return {
            meta: {
                ...this.__meta
            }
        };
    }

    _getNextState_base() {
        return {
            [this.header]: {
                state: MiscUtil.copyFast(this.__state),
                meta: MiscUtil.copyFast(this.__meta),
            },
        };
    }

    setStateFromNextState(nxtState) {
        this._proxyAssignSimple("state", nxtState[this.header].state, true);
        this._proxyAssignSimple("meta", nxtState[this.header].meta, true);
    }

    reset({isResetAll=false}={}) {
        const nxtState = this._getNextState_base();
        this._mutNextState_reset(nxtState, {
            isResetAll
        });
        this.setStateFromNextState(nxtState);
    }

    _mutNextState_resetBase(nxtState, {isResetAll=false}={}) {
        Object.assign(nxtState[this.header].meta, MiscUtil.copy(this.getDefaultMeta()));
    }

    getMetaSubHashes() {
        const compressedMeta = this._getCompressedMeta();
        if (!compressedMeta)
            return null;
        return [UrlUtil.packSubHash(this.getSubHashPrefix("meta", this.header), compressedMeta)];
    }

    _mutNextState_meta_fromSubHashState(nxtState, subHashState) {
        const hasMeta = this._mutNextState_meta_fromSubHashState_mutGetHasMeta(nxtState, subHashState, this.getDefaultMeta());
        if (!hasMeta)
            this._mutNextState_resetBase(nxtState);
    }

    _mutNextState_meta_fromSubHashState_mutGetHasMeta(nxtState, state, defaultMeta) {
        let hasMeta = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            if (prop !== "meta")
                return;

            hasMeta = true;
            const data = vals.map(v=>UrlUtil.mini.decompress(v));
            Object.keys(defaultMeta).forEach((k,i)=>{
                if (data[i] !== undefined)
                    nxtState[this.header].meta[k] = data[i];
                else
                    nxtState[this.header].meta[k] = defaultMeta[k];
            }
            );
        }
        );

        return hasMeta;
    }

    setBaseStateFromLoaded(toLoad) {
        Object.assign(this._meta, toLoad.meta);
    }

    getSubHashPrefix(prop, header) {
        if (FilterBase._SUB_HASH_PREFIXES[prop]) {
            const prefix = this._filterBox.getNamespacedHashKey(FilterBase._SUB_HASH_PREFIXES[prop]);
            return `${prefix}${header.toUrlified()}`;
        }
        throw new Error(`Unknown property "${prop}"`);
    }

    static getProp(prefix) {
        return Parser._parse_bToA(FilterBase._SUB_HASH_PREFIXES, prefix);
    }

    _getBtnMobToggleControls(wrpControls) {
        const btnMobToggleControls = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default mobile__visible ml-auto px-3 mr-2`,
            html: `<span class="glyphicon glyphicon-option-vertical"></span>`,
            click: ()=>this._meta.isMobileHeaderHidden = !this._meta.isMobileHeaderHidden,
        });
        const hkMobHeaderHidden = ()=>{
            btnMobToggleControls.toggleClass("active", !this._meta.isMobileHeaderHidden);
            wrpControls.toggleClass("mobile__hidden", !!this._meta.isMobileHeaderHidden);
        }
        ;
        this._addHook("meta", "isMobileHeaderHidden", hkMobHeaderHidden);
        hkMobHeaderHidden();

        return btnMobToggleControls;
    }

    getChildFilters() {
        return [];
    }
    getDefaultMeta() {
        return {
            ...FilterBase._DEFAULT_META
        };
    }

    isActive(vals) {
        vals = vals || this.getValues();
        return vals[this.header]._isActive;
    }

    _getCompressedMeta({isStripUiKeys=false}={}) {
        const defaultMeta = this.getDefaultMeta();
        const isAnyNotDefault = Object.keys(defaultMeta).some(k=>this._meta[k] !== defaultMeta[k]);
        if (!isAnyNotDefault)
            return null;

        let keys = Object.keys(defaultMeta);

        if (isStripUiKeys) {
            const popCount = Object.keys(FilterBase._DEFAULT_META).length;
            if (popCount)
                keys = keys.slice(0, -popCount);
        }

        while (keys.length && defaultMeta[keys.last()] === this._meta[keys.last()])
            keys.pop();

        return keys.map(k=>UrlUtil.mini.compress(this._meta[k] === undefined ? defaultMeta[k] : this._meta[k]));
    }

    $render() {
        throw new Error(`Unimplemented!`);
    }
    $renderMinis() {
        throw new Error(`Unimplemented!`);
    }
    getValues({nxtState=null}={}) {
        throw new Error(`Unimplemented!`);
    }
    _mutNextState_reset() {
        throw new Error(`Unimplemented!`);
    }
    update() {
        throw new Error(`Unimplemented!`);
    }
    toDisplay() {
        throw new Error(`Unimplemented!`);
    }
    addItem() {
        throw new Error(`Unimplemented!`);
    }
    getSaveableState() {
        throw new Error(`Unimplemented!`);
    }
    setStateFromLoaded() {
        throw new Error(`Unimplemented!`);
    }
    getSubHashes() {
        throw new Error(`Unimplemented!`);
    }
    getNextStateFromSubhashState() {
        throw new Error(`Unimplemented!`);
    }
    setFromValues() {
        throw new Error(`Unimplemented!`);
    }
    handleSearch() {
        throw new Error(`Unimplemented`);
    }
    getFilterTagPart() {
        throw new Error(`Unimplemented`);
    }
    getDisplayStatePart({nxtState=null}={}) {
        throw new Error(`Unimplemented`);
    }
    _doTeardown() {}
    trimState_() {}
}
FilterBase._DEFAULT_META = {
    isHidden: false,
    isMobileHeaderHidden: true,
};
FilterBase._SUB_HASH_STATE_PREFIX = "flst";
FilterBase._SUB_HASH_META_PREFIX = "flmt";
FilterBase._SUB_HASH_NESTS_HIDDEN_PREFIX = "flnh";
FilterBase._SUB_HASH_OPTIONS_PREFIX = "flop";
FilterBase._SUB_HASH_PREFIXES = {
    state: FilterBase._SUB_HASH_STATE_PREFIX,
    meta: FilterBase._SUB_HASH_META_PREFIX,
    nestsHidden: FilterBase._SUB_HASH_NESTS_HIDDEN_PREFIX,
    options: FilterBase._SUB_HASH_OPTIONS_PREFIX,
};

class Filter extends FilterBase {
    
    constructor(opts) {
        super(opts);
        this._items = Filter._getAsFilterItems(opts.items || []);
        this.__itemsSet = new Set(this._items.map(it=>it.item));
        this._nests = opts.nests;
        this._displayFn = opts.displayFn;
        this._displayFnMini = opts.displayFnMini;
        this._displayFnTitle = opts.displayFnTitle;
        this._selFn = opts.selFn;
        this._selFnCache = null;
        this._deselFn = opts.deselFn;
        this._itemSortFn = opts.itemSortFn === undefined ? SortUtil.ascSort : opts.itemSortFn;
        this._itemSortFnMini = opts.itemSortFnMini;
        this._groupFn = opts.groupFn;
        this._minimalUi = opts.minimalUi;
        this._umbrellaItems = Filter._getAsFilterItems(opts.umbrellaItems);
        this._umbrellaExcludes = Filter._getAsFilterItems(opts.umbrellaExcludes);
        this._isSortByDisplayItems = !!opts.isSortByDisplayItems;
        this._isReprintedFilter = !!opts.isMiscFilter && this._items.some(it=>it.item === "Reprinted");
        this._isSrdFilter = !!opts.isMiscFilter && this._items.some(it=>it.item === "SRD");
        this._isBasicRulesFilter = !!opts.isMiscFilter && this._items.some(it=>it.item === "Basic Rules");

        Filter._validateItemNests(this._items, this._nests);

        this._filterBox = null;
        this._items.forEach(it=>this._defaultItemState(it, {
            isForce: true
        }));
        this.__$wrpFilter = null;
        this.__wrpPills = null;
        this.__wrpMiniPills = null;
        this.__$wrpNestHeadInner = null;
        this._updateNestSummary = null;
        this.__nestsHidden = {};
        this._nestsHidden = this._getProxy("nestsHidden", this.__nestsHidden);
        this._isNestsDirty = false;
        this._isItemsDirty = false;
        this._pillGroupsMeta = {};
    }

    get isReprintedFilter() {
        return this._isReprintedFilter;
    }
    get isSrdFilter() {
        return this._isSrdFilter;
    }
    get isBasicRulesFilter() {
        return this._isBasicRulesFilter;
    }

    getSaveableState() {
        return {
            [this.header]: {
                ...this.getBaseSaveableState(),
                state: {
                    ...this.__state
                },
                nestsHidden: {
                    ...this.__nestsHidden
                },
            },
        };
    }

    setStateFromLoaded(filterState, {isUserSavedState=false}={}) {
        if (!filterState?.[this.header])
            return;

        const toLoad = filterState[this.header];
        this._hasUserSavedState = this._hasUserSavedState || isUserSavedState;
        this.setBaseStateFromLoaded(toLoad);
        Object.assign(this._state, toLoad.state);
        Object.assign(this._nestsHidden, toLoad.nestsHidden);
    }

    _getStateNotDefault({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        return Object.entries(state).filter(([k,v])=>{
            if (k.startsWith("_"))
                return false;
            const defState = this._getDefaultState(k);
            return defState !== v;
        }
        );
    }

    getSubHashes() {
        const out = [];

        const baseMeta = this.getMetaSubHashes();
        if (baseMeta)
            out.push(...baseMeta);

        const areNotDefaultState = this._getStateNotDefault();
        if (areNotDefaultState.length) {
            const serPillStates = areNotDefaultState.map(([k,v])=>`${k.toUrlified()}=${v}`);
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serPillStates));
        }

        const areNotDefaultNestsHidden = Object.entries(this._nestsHidden).filter(([k,v])=>this._nests[k] && !(this._nests[k].isHidden === v));
        if (areNotDefaultNestsHidden.length) {
            const nestsHidden = areNotDefaultNestsHidden.map(([k])=>`${k.toUrlified()}=1`);
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("nestsHidden", this.header), nestsHidden));
        }

        if (!out.length)
            return null;

        out.push(UrlUtil.packSubHash(this.getSubHashPrefix("options", this.header), ["extend"]));
        return out;
    }

    getFilterTagPart() {
        const areNotDefaultState = this._getStateNotDefault();
        const compressedMeta = this._getCompressedMeta({
            isStripUiKeys: true
        });

        if (!areNotDefaultState.length && !compressedMeta)
            return null;

        const pt = Object.entries(this._state).filter(([k])=>!k.startsWith("_")).filter(([,v])=>v).map(([k,v])=>`${v === 2 ? "!" : ""}${k}`).join(";").toLowerCase();

        return [this.header.toLowerCase(), pt, compressedMeta ? compressedMeta.join(HASH_SUB_LIST_SEP) : null, ].filter(it=>it != null).join("=");
    }

    getDisplayStatePart({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        const areNotDefaultState = this._getStateNotDefault({
            nxtState
        });

        if (!areNotDefaultState.length)
            return null;

        const ptState = Object.entries(state).filter(([k])=>!k.startsWith("_")).filter(([,v])=>v).map(([k,v])=>{
            const item = this._items.find(item=>`${item.item}` === k);
            if (!item)
                return null;
            return `${v === 2 ? "not " : ""}${this._displayFn ? this._displayFn(item.item, item) : item.item}`;
        }
        ).filter(Boolean).join(", ");

        if (!ptState)
            return null;

        return `${this.header}: ${ptState}`;
    }

    _getOptionsFromSubHashState(state) {
        const opts = {};
        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            switch (prop) {
            case "options":
                {
                    vals.forEach(val=>{
                        switch (val) {
                        case "extend":
                            {
                                opts.isExtendDefaultState = true;
                            }
                        }
                    }
                    );
                }
            }
        }
        );
        return new FilterTransientOptions(opts);
    }

    setStateFromNextState(nxtState) {
        super.setStateFromNextState(nxtState);
        this._proxyAssignSimple("nestsHidden", nxtState[this.header].nestsHidden, true);
    }

    getNextStateFromSubhashState(state) {
        const nxtState = this._getNextState_base();

        if (state == null) {
            this._mutNextState_reset(nxtState);
            return nxtState;
        }

        this._mutNextState_meta_fromSubHashState(nxtState, state);
        const transientOptions = this._getOptionsFromSubHashState(state);

        let hasState = false;
        let hasNestsHidden = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            switch (prop) {
            case "state":
                {
                    hasState = true;
                    if (transientOptions.isExtendDefaultState) {
                        Object.keys(nxtState[this.header].state).forEach(k=>nxtState[this.header].state[k] = this._getDefaultState(k));
                    } else {
                        Object.keys(nxtState[this.header].state).forEach(k=>nxtState[this.header].state[k] = 0);
                    }

                    vals.forEach(v=>{
                        const [statePropLower,state] = v.split("=");
                        const stateProp = Object.keys(nxtState[this.header].state).find(k=>k.toLowerCase() === statePropLower);
                        if (stateProp)
                            nxtState[this.header].state[stateProp] = Number(state);
                    }
                    );
                    break;
                }
            case "nestsHidden":
                {
                    hasNestsHidden = true;
                    Object.keys(nxtState[this.header].nestsHidden).forEach(k=>{
                        const nestKey = Object.keys(this._nests).find(it=>k.toLowerCase() === it.toLowerCase());
                        nxtState[this.header].nestsHidden[k] = this._nests[nestKey] && this._nests[nestKey].isHidden;
                    }
                    );
                    vals.forEach(v=>{
                        const [nestNameLower,state] = v.split("=");
                        const nestName = Object.keys(nxtState[this.header].nestsHidden).find(k=>k.toLowerCase() === nestNameLower);
                        if (nestName)
                            nxtState[this.header].nestsHidden[nestName] = !!Number(state);
                    }
                    );
                    break;
                }
            }
        }
        );

        if (!hasState)
            this._mutNextState_reset(nxtState);
        if (!hasNestsHidden && this._nests)
            this._mutNextState_resetNestsHidden({
                tgt: nxtState[this.header].nestsHidden
            });

        return nxtState;
    }

    /** Disable all our own values and set them according to what values[this.header] says */
    setFromValues(values) {
        if (values[this.header]) {
            Object.keys(this._state).forEach(k=>this._state[k] = 0);
            Object.assign(this._state, values[this.header]);
        }
    }

    setValue(k, v) {
        this._state[k] = v;
    }

    _mutNextState_resetNestsHidden({tgt}) {
        if (!this._nests)
            return;
        Object.entries(this._nests).forEach(([nestName,nestMeta])=>tgt[nestName] = !!nestMeta.isHidden);
    }

    _defaultItemState(item, {isForce=false}={}) {
        if (!isForce && this._hasUserSavedState)
            return this._state[item.item] = 0;

        this._state[item.item] = this._getDefaultState(item.item);
    }

    _getDefaultState(k) {
        return this._deselFn && this._deselFn(k) ? 2 : this._selFn && this._selFn(k) ? 1 : 0;
    }

    _getDisplayText(item) {
        return this._displayFn ? this._displayFn(item.item, item) : item.item;
    }

    _getDisplayTextMini(item) {
        return this._displayFnMini ? this._displayFnMini(item.item, item) : this._getDisplayText(item);
    }

    _getPill(item) {
        const displayText = this._getDisplayText(item);

        const btnPill = e_({
            tag: "div",
            clazz: "fltr__pill",
            html: displayText,
            click: evt=>this._getPill_handleClick({
                evt,
                item
            }),
            contextmenu: evt=>this._getPill_handleContextmenu({
                evt,
                item
            }),
        });

        this._getPill_bindHookState({
            btnPill,
            item
        });

        item.searchText = displayText.toLowerCase();

        return btnPill;
    }

    _getPill_handleClick({evt, item}) {
        if (evt.shiftKey) {
            this._doSetPillsClear();
        }

        if (++this._state[item.item] > 2)
            this._state[item.item] = 0;
    }

    _getPill_handleContextmenu({evt, item}) {
        evt.preventDefault();

        if (evt.shiftKey) {
            this._doSetPillsClear();
        }

        if (--this._state[item.item] < 0)
            this._state[item.item] = 2;
    }

    _getPill_bindHookState({btnPill, item}) {
        this._addHook("state", item.item, ()=>{
            const val = FilterBox._PILL_STATES[this._state[item.item]];
            btnPill.attr("state", val);
        }
        )();
    }

    setTempFnSel(tempFnSel) {
        this._selFnCache = this._selFnCache || this._selFn;
        if (tempFnSel)
            this._selFn = tempFnSel;
        else
            this._selFn = this._selFnCache;
    }

    updateMiniPillClasses() {
        this._items.filter(it=>it.btnMini).forEach(it=>{
            const isDefaultDesel = this._deselFn && this._deselFn(it.item);
            const isDefaultSel = this._selFn && this._selFn(it.item);
            it.btnMini.toggleClass("fltr__mini-pill--default-desel", isDefaultDesel).toggleClass("fltr__mini-pill--default-sel", isDefaultSel);
        }
        );
    }

    _getBtnMini(item) {
        const toDisplay = this._getDisplayTextMini(item);

        const btnMini = e_({
            tag: "div",
            clazz: `fltr__mini-pill ${this._filterBox.isMinisHidden(this.header) ? "ve-hidden" : ""} ${this._deselFn && this._deselFn(item.item) ? "fltr__mini-pill--default-desel" : ""} ${this._selFn && this._selFn(item.item) ? "fltr__mini-pill--default-sel" : ""}`,
            html: toDisplay,
            title: `${this._displayFnTitle ? `${this._displayFnTitle(item.item, item)} (` : ""}Filter: ${this.header}${this._displayFnTitle ? ")" : ""}`,
            click: ()=>{
                this._state[item.item] = 0;
                this._filterBox.fireChangeEvent();
            }
            ,
        }).attr("state", FilterBox._PILL_STATES[this._state[item.item]]);

        const hook = ()=>{
            const val = FilterBox._PILL_STATES[this._state[item.item]];
            btnMini.attr("state", val);
            if (item.pFnChange)
                item.pFnChange(item.item, val);
        }
        ;
        this._addHook("state", item.item, hook);

        const hideHook = ()=>btnMini.toggleClass("ve-hidden", this._filterBox.isMinisHidden(this.header));
        this._filterBox.registerMinisHiddenHook(this.header, hideHook);

        return btnMini;
    }

    _doSetPillsAll() {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: 1
        })), true, );
    }

    _doSetPillsClear() {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: 0
        })), true, );
    }

    _doSetPillsNone() {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: 2
        })), true, );
    }

    _doSetPinsDefault() {
        this.reset();
    }

    _getHeaderControls(opts) {
        const btnAll = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--all w-100`,
            click: ()=>this._doSetPillsAll(),
            html: "All",
        });
        const btnClear = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--clear w-100`,
            click: ()=>this._doSetPillsClear(),
            html: "Clear",
        });
        const btnNone = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--none w-100`,
            click: ()=>this._doSetPillsNone(),
            html: "None",
        });
        const btnDefault = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} w-100`,
            click: ()=>this._doSetPinsDefault(),
            html: "Default",
        });

        const wrpStateBtnsOuter = e_({
            tag: "div",
            clazz: "ve-flex-v-center fltr__h-wrp-state-btns-outer",
            children: [e_({
                tag: "div",
                clazz: "btn-group ve-flex-v-center w-100",
                children: [btnAll, btnClear, btnNone, btnDefault, ],
            }), ],
        });
        this._getHeaderControls_addExtraStateBtns(opts, wrpStateBtnsOuter);

        const wrpSummary = e_({
            tag: "div",
            clazz: "ve-flex-vh-center ve-hidden"
        });

        const btnCombineBlue = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn-logic--blue fltr__h-btn-logic w-100`,
            click: ()=>this._meta.combineBlue = Filter._getNextCombineMode(this._meta.combineBlue),
            title: `Blue match mode for this filter. "AND" requires all blues to match, "OR" requires at least one blue to match, "XOR" requires exactly one blue to match.`,
        });
        const hookCombineBlue = ()=>e_({
            ele: btnCombineBlue,
            text: `${this._meta.combineBlue}`.toUpperCase()
        });
        this._addHook("meta", "combineBlue", hookCombineBlue);
        hookCombineBlue();

        const btnCombineRed = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn-logic--red fltr__h-btn-logic w-100`,
            click: ()=>this._meta.combineRed = Filter._getNextCombineMode(this._meta.combineRed),
            title: `Red match mode for this filter. "AND" requires all reds to match, "OR" requires at least one red to match, "XOR" requires exactly one red to match.`,
        });
        const hookCombineRed = ()=>e_({
            ele: btnCombineRed,
            text: `${this._meta.combineRed}`.toUpperCase()
        });
        this._addHook("meta", "combineRed", hookCombineRed);
        hookCombineRed();

        const btnShowHide = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} ml-2`,
            click: ()=>this._meta.isHidden = !this._meta.isHidden,
            html: "Hide",
        });
        const hookShowHide = ()=>{
            e_({
                ele: btnShowHide
            }).toggleClass("active", this._meta.isHidden);
            wrpStateBtnsOuter.toggleVe(!this._meta.isHidden);

            const cur = this.getValues()[this.header];

            const htmlSummary = [cur._totals.yes ? `<span class="fltr__summary_item fltr__summary_item--include" title="${cur._totals.yes} hidden &quot;required&quot; tags">${cur._totals.yes}</span>` : null, cur._totals.yes && cur._totals.no ? `<span class="fltr__summary_item_spacer"></span>` : null, cur._totals.no ? `<span class="fltr__summary_item fltr__summary_item--exclude" title="${cur._totals.no} hidden &quot;excluded&quot; tags">${cur._totals.no}</span>` : null, ].filter(Boolean).join("");
            e_({
                ele: wrpSummary,
                html: htmlSummary
            }).toggleVe(this._meta.isHidden);
        }
        ;
        this._addHook("meta", "isHidden", hookShowHide);
        hookShowHide();

        return e_({
            tag: "div",
            clazz: `ve-flex-v-center fltr__h-wrp-btns-outer`,
            children: [wrpSummary, wrpStateBtnsOuter, e_({
                tag: "span",
                clazz: `btn-group ml-2 ve-flex-v-center`,
                children: [btnCombineBlue, btnCombineRed]
            }), btnShowHide, ],
        });
    }

    _getHeaderControls_addExtraStateBtns() {}

    $render(opts) {
        this._filterBox = opts.filterBox;
        this.__wrpMiniPills = opts.$wrpMini ? e_({
            ele: opts.$wrpMini[0]
        }) : null;

        const wrpControls = this._getHeaderControls(opts);

        if (this._nests) {
            const wrpNestHead = e_({
                tag: "div",
                clazz: "fltr__wrp-pills--sub"
            }).appendTo(this.__wrpPills);
            this.__$wrpNestHeadInner = e_({
                tag: "div",
                clazz: "ve-flex ve-flex-wrap fltr__container-pills"
            }).appendTo(wrpNestHead);

            const wrpNestHeadSummary = e_({
                tag: "div",
                clazz: "fltr__summary_nest"
            }).appendTo(wrpNestHead);

            this._updateNestSummary = ()=>{
                const stats = {
                    high: 0,
                    low: 0
                };
                this._items.filter(it=>this._state[it.item] && this._nestsHidden[it.nest]).forEach(it=>{
                    const key = this._state[it.item] === 1 ? "high" : "low";
                    stats[key]++;
                }
                );

                wrpNestHeadSummary.empty();

                if (stats.high) {
                    e_({
                        tag: "span",
                        clazz: "fltr__summary_item fltr__summary_item--include",
                        text: stats.high,
                        title: `${stats.high} hidden "required" tag${stats.high === 1 ? "" : "s"}`,
                    }).appendTo(wrpNestHeadSummary);
                }

                if (stats.high && stats.low)
                    e_({
                        tag: "span",
                        clazz: "fltr__summary_item_spacer"
                    }).appendTo(wrpNestHeadSummary);

                if (stats.low) {
                    e_({
                        tag: "span",
                        clazz: "fltr__summary_item fltr__summary_item--exclude",
                        text: stats.low,
                        title: `${stats.low} hidden "excluded" tag${stats.low === 1 ? "" : "s"}`,
                    }).appendTo(wrpNestHeadSummary);
                }
            }
            ;

            this._doRenderNests();
        }

        this._doRenderPills();

        const btnMobToggleControls = this._getBtnMobToggleControls(wrpControls);

        this.__$wrpFilter = $$`<div>
			${opts.isFirst ? "" : `<div class="fltr__dropdown-divider ${opts.isMulti ? "fltr__dropdown-divider--indented" : ""} mb-1"></div>`}
			<div class="split fltr__h ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
				<div class="fltr__h-text ve-flex-h-center mobile__w-100">
					${opts.isMulti ? `<span class="mr-2">\u2012</span>` : ""}
					${this._getRenderedHeader()}
					${btnMobToggleControls}
				</div>
				${wrpControls}
			</div>
			${this.__wrpPills}
		</div>`;

        this._doToggleDisplay();

        return this.__$wrpFilter;
    }

    $renderMinis(opts) {
        if (!opts.$wrpMini)
            return;

        this._filterBox = opts.filterBox;
        this.__wrpMiniPills = e_({
            ele: opts.$wrpMini[0]
        });

        this._renderMinis_initWrpPills();

        this._doRenderMiniPills();
    }

    _renderMinis_initWrpPills() {
        this.__wrpPills = e_({
            tag: "div",
            clazz: `fltr__wrp-pills ${this._groupFn ? "fltr__wrp-subs" : "fltr__container-pills"}`
        });
        const hook = ()=>this.__wrpPills.toggleVe(!this._meta.isHidden);
        this._addHook("meta", "isHidden", hook);
        hook();
    }

    getValues({nxtState=null}={}) {
        const state = MiscUtil.copy(nxtState?.[this.header]?.state || this.__state);
        const meta = nxtState?.[this.header]?.meta || this.__meta;

        Object.keys(state).filter(k=>!this._items.some(it=>`${it.item}` === k)).forEach(k=>delete state[k]);
        const out = {
            ...state
        };

        out._isActive = Object.values(state).some(Boolean);
        out._totals = {
            yes: 0,
            no: 0,
            ignored: 0
        };
        Object.values(state).forEach(v=>{
            const totalKey = v === 0 ? "ignored" : v === 1 ? "yes" : "no";
            out._totals[totalKey]++;
        }
        );
        out._combineBlue = meta.combineBlue;
        out._combineRed = meta.combineRed;
        return {
            [this.header]: out
        };
    }

    _getNextState_base() {
        return {
            [this.header]: {
                ...super._getNextState_base()[this.header],
                nestsHidden: MiscUtil.copyFast(this.__nestsHidden),
            },
        };
    }

    _mutNextState_reset(nxtState, {isResetAll=false}={}) {
        if (isResetAll) {
            this._mutNextState_resetBase(nxtState);
            this._mutNextState_resetNestsHidden({
                tgt: nxtState[this.header].nestsHidden
            });
        } else {
            Object.assign(nxtState[this.header].meta, {
                combineBlue: Filter._DEFAULT_META.combineBlue,
                combineRed: Filter._DEFAULT_META.combineRed
            });
        }
        Object.keys(nxtState[this.header].state).forEach(k=>delete nxtState[this.header].state[k]);
        this._items.forEach(item=>nxtState[this.header].state[item.item] = this._getDefaultState(item.item));
    }

    _doRenderPills() {
        if (this._itemSortFn)
            this._items.sort(this._isSortByDisplayItems && this._displayFn ? (a,b)=>this._itemSortFn(this._displayFn(a.item, a), this._displayFn(b.item, b)) : this._itemSortFn);

        this._items.forEach(it=>{
            if (!it.rendered) {
                it.rendered = this._getPill(it);
                if (it.nest) {
                    const hook = ()=>it.rendered.toggleVe(!this._nestsHidden[it.nest]);
                    this._addHook("nestsHidden", it.nest, hook);
                    hook();
                }
            }

            if (this._groupFn) {
                const group = this._groupFn(it);
                this._doRenderPills_doRenderWrpGroup(group);
                this._pillGroupsMeta[group].wrpPills.append(it.rendered);
            } else
                it.rendered.appendTo(this.__wrpPills);
        }
        );
    }

    _doRenderPills_doRenderWrpGroup(group) {
        const existingMeta = this._pillGroupsMeta[group];
        if (existingMeta && !existingMeta.isAttached) {
            existingMeta.hrDivider.appendTo(this.__wrpPills);
            existingMeta.wrpPills.appendTo(this.__wrpPills);
            existingMeta.isAttached = true;
        }
        if (existingMeta)
            return;

        this._pillGroupsMeta[group] = {
            hrDivider: this._doRenderPills_doRenderWrpGroup_getHrDivider(group).appendTo(this.__wrpPills),
            wrpPills: this._doRenderPills_doRenderWrpGroup_getWrpPillsSub(group).appendTo(this.__wrpPills),
            isAttached: true,
        };

        Object.entries(this._pillGroupsMeta).sort((a,b)=>SortUtil.ascSortLower(a[0], b[0])).forEach(([groupKey,groupMeta],i)=>{
            groupMeta.hrDivider.appendTo(this.__wrpPills);
            groupMeta.hrDivider.toggleVe(!this._isGroupDividerHidden(groupKey, i));
            groupMeta.wrpPills.appendTo(this.__wrpPills);
        }
        );

        if (this._nests) {
            this._pillGroupsMeta[group].toggleDividerFromNestVisibility = ()=>{
                this._pillGroupsMeta[group].hrDivider.toggleVe(!this._isGroupDividerHidden(group));
            }
            ;

            Object.keys(this._nests).forEach(nestName=>{
                const hook = ()=>this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
                this._addHook("nestsHidden", nestName, hook);
                hook();
                this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
            }
            );
        }
    }

    _isGroupDividerHidden(group, ixSortedGroups) {
        if (!this._nests) {
            if (ixSortedGroups === undefined)
                return `${group}` === `${Object.keys(this._pillGroupsMeta).sort((a,b)=>SortUtil.ascSortLower(a, b))[0]}`;
            return ixSortedGroups === 0;
        }

        const groupItems = this._items.filter(it=>this._groupFn(it) === group);
        const hiddenGroupItems = groupItems.filter(it=>this._nestsHidden[it.nest]);
        return groupItems.length === hiddenGroupItems.length;
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider() {
        return e_({
            tag: "hr",
            clazz: `fltr__dropdown-divider--sub hr-2 mx-3`
        });
    }
    _doRenderPills_doRenderWrpGroup_getWrpPillsSub() {
        return e_({
            tag: "div",
            clazz: `fltr__wrp-pills--sub fltr__container-pills`
        });
    }

    _doRenderMiniPills() {
        const view = this._items.slice(0);
        if (this._itemSortFnMini || this._itemSortFn) {
            const fnSort = this._itemSortFnMini || this._itemSortFn;
            view.sort(this._isSortByDisplayItems && this._displayFn ? (a,b)=>fnSort(this._displayFn(a.item, a), this._displayFn(b.item, b)) : fnSort);
        }

        if (this.__wrpMiniPills) {
            view.forEach(it=>{
                (it.btnMini = it.btnMini || this._getBtnMini(it)).appendTo(this.__wrpMiniPills);
            }
            );
        }
    }

    _doToggleDisplay() {
        if (this.__$wrpFilter)
            this.__$wrpFilter.toggleClass("fltr__no-items", !this._items.length);
    }

    _doRenderNests() {
        Object.entries(this._nests).sort((a,b)=>SortUtil.ascSort(a[0], b[0])).forEach(([nestName,nestMeta])=>{
            if (nestMeta._$btnNest == null) {
                if (this._nestsHidden[nestName] == null)
                    this._nestsHidden[nestName] = !!nestMeta.isHidden;

                const $btnText = $(`<span>${nestName} [${this._nestsHidden[nestName] ? "+" : "\u2212"}]</span>`);
                nestMeta._$btnNest = $$`<div class="fltr__btn_nest">${$btnText}</div>`.click(()=>this._nestsHidden[nestName] = !this._nestsHidden[nestName]);

                const hook = ()=>{
                    $btnText.text(`${nestName} [${this._nestsHidden[nestName] ? "+" : "\u2212"}]`);

                    const stats = {
                        high: 0,
                        low: 0,
                        total: 0
                    };
                    this._items.filter(it=>it.nest === nestName).find(it=>{
                        const key = this._state[it.item] === 1 ? "high" : this._state[it.item] ? "low" : "ignored";
                        stats[key]++;
                        stats.total++;
                    }
                    );
                    const allHigh = stats.total === stats.high;
                    const allLow = stats.total === stats.low;
                    nestMeta._$btnNest.toggleClass("fltr__btn_nest--include-all", this._nestsHidden[nestName] && allHigh).toggleClass("fltr__btn_nest--exclude-all", this._nestsHidden[nestName] && allLow).toggleClass("fltr__btn_nest--include", this._nestsHidden[nestName] && !!(!allHigh && !allLow && stats.high && !stats.low)).toggleClass("fltr__btn_nest--exclude", this._nestsHidden[nestName] && !!(!allHigh && !allLow && !stats.high && stats.low)).toggleClass("fltr__btn_nest--both", this._nestsHidden[nestName] && !!(!allHigh && !allLow && stats.high && stats.low));

                    if (this._updateNestSummary)
                        this._updateNestSummary();
                }
                ;

                this._items.filter(it=>it.nest === nestName).find(it=>{
                    this._addHook("state", it.item, hook);
                }
                );

                this._addHook("nestsHidden", nestName, hook);
                hook();
            }
            nestMeta._$btnNest.appendTo(this.__$wrpNestHeadInner);
        }
        );

        if (this._updateNestSummary)
            this._updateNestSummary();
    }

    update() {
        if (this._isNestsDirty) {
            this._isNestsDirty = false;

            this._doRenderNests();
        }

        if (this._isItemsDirty) {
            this._isItemsDirty = false;

            this._doRenderPills();
        }

        this._doRenderMiniPills();
        this._doToggleDisplay();
    }

    /**
     * Adds an item to the filter
     * @param {any} item
     */
    addItem(item) {
        if (item == null)
            return;

        if (item instanceof Array) {
            const len = item.length;
            for (let i = 0; i < len; ++i)
                this.addItem(item[i]);
            return;
        }

        if (!this.__itemsSet.has(item.item || item)) {
            item = item instanceof FilterItem$1 ? item : new FilterItem$1({
                item
            });
            Filter._validateItemNest(item, this._nests);

            this._isItemsDirty = true;
            this._items.push(item);
            this.__itemsSet.add(item.item);
            if (this._state[item.item] == null)
                this._defaultItemState(item);
        }
    }

    static _isItemsEqual(item1, item2) {
        return (item1 instanceof FilterItem$1 ? item1.item : item1) === (item2 instanceof FilterItem$1 ? item2.item : item2);
    }

    removeItem(item) {
        const ixItem = this._items.findIndex(it=>Filter._isItemsEqual(it, item));
        if (~ixItem) {
            const item = this._items[ixItem];

            this._isItemsDirty = true;
            item.rendered.detach();
            item.btnMini.detach();
            this._items.splice(ixItem, 1);
        }
    }

    addNest(nestName, nestMeta) {
        if (!this._nests)
            throw new Error(`Filter was not nested!`);
        if (!this._nests[nestName]) {
            this._isNestsDirty = true;
            this._nests[nestName] = nestMeta;

            if (this._groupFn) {
                Object.keys(this._pillGroupsMeta).forEach(group=>{
                    const hook = ()=>this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
                    this._addHook("nestsHidden", nestName, hook);
                    hook();
                    this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
                }
                );
            }
        }
    }

    _toDisplay_getMappedEntryVal(entryVal) {
        if (!(entryVal instanceof Array))
            entryVal = [entryVal];
        entryVal = entryVal.map(it=>it instanceof FilterItem$1 ? it : new FilterItem$1({
            item: it
        }));
        return entryVal;
    }

    _toDisplay_getFilterState(boxState) {
        return boxState[this.header];
    }

    toDisplay(boxState, entryVal) {
        const filterState = this._toDisplay_getFilterState(boxState);
        if (!filterState)
            return true;

        const totals = filterState._totals;

        entryVal = this._toDisplay_getMappedEntryVal(entryVal);

        const isUmbrella = ()=>{
            if (this._umbrellaItems) {
                if (!entryVal)
                    return false;

                if (this._umbrellaExcludes && this._umbrellaExcludes.some(it=>filterState[it.item]))
                    return false;

                return this._umbrellaItems.some(u=>entryVal.includes(u.item)) && (this._umbrellaItems.some(u=>filterState[u.item] === 0) || this._umbrellaItems.some(u=>filterState[u.item] === 1));
            }
        }
        ;

        let hide = false;
        let display = false;

        switch (filterState._combineBlue) {
        case "or":
            {
                if (totals.yes === 0)
                    display = true;

                display = display || entryVal.some(fi=>filterState[fi.item] === 1 || isUmbrella());

                break;
            }
        case "xor":
            {
                if (totals.yes === 0)
                    display = true;

                display = display || entryVal.filter(fi=>filterState[fi.item] === 1 || isUmbrella()).length === 1;

                break;
            }
        case "and":
            {
                const totalYes = entryVal.filter(fi=>filterState[fi.item] === 1).length;
                display = !totals.yes || totals.yes === totalYes;

                break;
            }
        default:
            throw new Error(`Unhandled combine mode "${filterState._combineBlue}"`);
        }

        switch (filterState._combineRed) {
        case "or":
            {
                hide = hide || entryVal.filter(fi=>!fi.isIgnoreRed).some(fi=>filterState[fi.item] === 2);

                break;
            }
        case "xor":
            {
                hide = hide || entryVal.filter(fi=>!fi.isIgnoreRed).filter(fi=>filterState[fi.item] === 2).length === 1;

                break;
            }
        case "and":
            {
                const totalNo = entryVal.filter(fi=>!fi.isIgnoreRed).filter(fi=>filterState[fi.item] === 2).length;
                hide = totals.no && totals.no === totalNo;

                break;
            }
        default:
            throw new Error(`Unhandled combine mode "${filterState._combineRed}"`);
        }

        return display && !hide;
    }

    _doInvertPins() {
        const cur = MiscUtil.copy(this._state);
        Object.keys(this._state).forEach(k=>this._state[k] = cur[k] === 1 ? 0 : 1);
    }

    getDefaultMeta() {
        return {
            ...super.getDefaultMeta(),
            ...Filter._DEFAULT_META,
        };
    }

    handleSearch(searchTerm) {
        const isHeaderMatch = this.header.toLowerCase().includes(searchTerm);

        if (isHeaderMatch) {
            this._items.forEach(it=>{
                if (!it.rendered)
                    return;
                it.rendered.toggleClass("fltr__hidden--search", false);
            }
            );

            if (this.__$wrpFilter)
                this.__$wrpFilter.toggleClass("fltr__hidden--search", false);

            return true;
        }

        let visibleCount = 0;
        this._items.forEach(it=>{
            if (!it.rendered)
                return;
            const isVisible = it.searchText.includes(searchTerm);
            it.rendered.toggleClass("fltr__hidden--search", !isVisible);
            if (isVisible)
                visibleCount++;
        }
        );

        if (this.__$wrpFilter)
            this.__$wrpFilter.toggleClass("fltr__hidden--search", visibleCount === 0);

        return visibleCount !== 0;
    }

    static _getNextCombineMode(combineMode) {
        let ix = Filter._COMBINE_MODES.indexOf(combineMode);
        if (ix === -1)
            ix = (Filter._COMBINE_MODES.length - 1);
        if (++ix === Filter._COMBINE_MODES.length)
            ix = 0;
        return Filter._COMBINE_MODES[ix];
    }

    _doTeardown() {
        this._items.forEach(it=>{
            if (it.rendered)
                it.rendered.detach();
            if (it.btnMini)
                it.btnMini.detach();
        }
        );

        Object.values(this._nests || {}).filter(nestMeta=>nestMeta._$btnNest).forEach(nestMeta=>nestMeta._$btnNest.detach());

        Object.values(this._pillGroupsMeta || {}).forEach(it=>{
            it.hrDivider.detach();
            it.wrpPills.detach();
            it.isAttached = false;
        }
        );
    }

    static _getAsFilterItems(items) {
        return items ? items.map(it=>it instanceof FilterItem$1 ? it : new FilterItem$1({
            item: it
        })) : null;
    }

    static _validateItemNests(items, nests) {
        if (!nests)
            return;
        items = items.filter(it=>it.nest);
        const noNest = items.find(it=>!nests[it.nest]);
        if (noNest)
            throw new Error(`Filter does not have matching nest: "${noNest.item}" (call addNest first)`);
        const invalid = items.find(it=>!it.nest || !nests[it.nest]);
        if (invalid)
            throw new Error(`Invalid nest: "${invalid.item}"`);
    }

    static _validateItemNest(item, nests) {
        if (!nests || !item.nest)
            return;
        if (!nests[item.nest])
            throw new Error(`Filter does not have matching nest: "${item.item}" (call addNest first)`);
        if (!item.nest || !nests[item.nest])
            throw new Error(`Invalid nest: "${item.item}"`);
    }
};
Filter._DEFAULT_META = {
    combineBlue: "or",
    combineRed: "or",
};
Filter._COMBINE_MODES = ["or", "and", "xor"];
globalThis.Filter = Filter;

let FilterCommon$1 = class FilterCommon {
    static getDamageVulnerableFilter() {
        return this._getDamageResistVulnImmuneFilter({
            header: "Vulnerabilities",
            headerShort: "Vuln.",
        });
    }

    static getDamageResistFilter() {
        return this._getDamageResistVulnImmuneFilter({
            header: "Resistance",
            headerShort: "Res.",
        });
    }

    static getDamageImmuneFilter() {
        return this._getDamageResistVulnImmuneFilter({
            header: "Immunity",
            headerShort: "Imm.",
        });
    }

    static _getDamageResistVulnImmuneFilter({header, headerShort, }, ) {
        return new Filter({
            header: header,
            items: [...Parser.DMG_TYPES],
            displayFnMini: str=>`${headerShort} ${str.toTitleCase()}`,
            displayFnTitle: str=>`Damage ${header}: ${str.toTitleCase()}`,
            displayFn: StrUtil.uppercaseFirst,
        });
    }

    static _CONDS = ["blinded", "charmed", "deafened", "exhaustion", "frightened", "grappled", "incapacitated", "invisible", "paralyzed", "petrified", "poisoned", "prone", "restrained", "stunned", "unconscious", "disease", ];

    static getConditionImmuneFilter() {
        return new Filter({
            header: "Condition Immunity",
            items: this._CONDS,
            displayFnMini: str=>`Imm. ${str.toTitleCase()}`,
            displayFnTitle: str=>`Condition Immunity: ${str.toTitleCase()}`,
            displayFn: StrUtil.uppercaseFirst,
        });
    }

    static mutateForFilters_damageVulnResImmune_player(ent) {
        this.mutateForFilters_damageVuln_player(ent);
        this.mutateForFilters_damageRes_player(ent);
        this.mutateForFilters_damageImm_player(ent);
    }

    static mutateForFilters_damageVuln_player(ent) {
        if (!ent.vulnerable)
            return;

        const out = new Set();
        ent.vulnerable.forEach(it=>this._recurseResVulnImm(out, it));
        ent._fVuln = [...out];
    }

    static mutateForFilters_damageRes_player(ent) {
        if (!ent.resist)
            return;

        const out = new Set();
        ent.resist.forEach(it=>this._recurseResVulnImm(out, it));
        ent._fRes = [...out];
    }

    static mutateForFilters_damageImm_player(ent) {
        if (!ent.immune)
            return;

        const out = new Set();
        ent.immune.forEach(iti=>this._recurseResVulnImm(out, iti));
        ent._fImm = [...out];
    }

    static mutateForFilters_conditionImmune_player(ent) {
        if (!ent.conditionImmune)
            return;

        const out = new Set();
        ent.conditionImmune.forEach(it=>this._recurseResVulnImm(out, it));
        ent._fCondImm = [...out];
    }

    static _recurseResVulnImm(allSet, it) {
        if (typeof it === "string")
            return allSet.add(it);
        if (it.choose?.from)
            it.choose?.from.forEach(itSub=>this._recurseResVulnImm(allSet, itSub));
    }
};

globalThis.FilterCommon = FilterCommon$1;

let MultiFilter = class MultiFilter extends FilterBase {
    constructor(opts) {
        super(opts);
        this._filters = opts.filters;
        this._isAddDropdownToggle = !!opts.isAddDropdownToggle;

        Object.assign(this.__state, {
            ...MultiFilter._DETAULT_STATE,
            mode: opts.mode || MultiFilter._DETAULT_STATE.mode,
        }, );
        this._defaultState = MiscUtil.copy(this.__state);
        this._state = this._getProxy("state", this.__state);

        this.__$wrpFilter = null;
        this._$wrpChildren = null;
    }

    getChildFilters() {
        return [...this._filters, ...this._filters.map(f=>f.getChildFilters())].flat();
    }

    getSaveableState() {
        const out = {
            [this.header]: {
                ...this.getBaseSaveableState(),
                state: {
                    ...this.__state
                },
            },
        };
        this._filters.forEach(it=>Object.assign(out, it.getSaveableState()));
        return out;
    }

    setStateFromLoaded(filterState, {isUserSavedState=false}={}) {
        if (!filterState?.[this.header])
            return;

        const toLoad = filterState[this.header];
        this._hasUserSavedState = this._hasUserSavedState || isUserSavedState;
        this.setBaseStateFromLoaded(toLoad);
        Object.assign(this._state, toLoad.state);
        this._filters.forEach(it=>it.setStateFromLoaded(filterState, {
            isUserSavedState
        }));
    }

    getSubHashes() {
        const out = [];

        const baseMeta = this.getMetaSubHashes();
        if (baseMeta)
            out.push(...baseMeta);

        const anyNotDefault = this._getStateNotDefault();
        if (anyNotDefault.length) {
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), this._getCompressedState()));
        }

        this._filters.map(it=>it.getSubHashes()).filter(Boolean).forEach(it=>out.push(...it));
        return out.length ? out : null;
    }

    _getStateNotDefault() {
        return Object.entries(this._defaultState).filter(([k,v])=>this._state[k] !== v);
    }

    getFilterTagPart() {
        return [this._getFilterTagPart_self(), ...this._filters.map(it=>it.getFilterTagPart()).filter(Boolean), ].filter(it=>it != null).join("|");
    }

    _getFilterTagPart_self() {
        const areNotDefaultState = this._getStateNotDefault();
        if (!areNotDefaultState.length)
            return null;

        return `${this.header.toLowerCase()}=${this._getCompressedState().join(HASH_SUB_LIST_SEP)}`;
    }

    getDisplayStatePart({nxtState=null}={}) {
        return this._filters.map(it=>it.getDisplayStatePart({
            nxtState
        })).filter(Boolean).join(", ");
    }

    _getCompressedState() {
        return Object.keys(this._defaultState).map(k=>UrlUtil.mini.compress(this._state[k] === undefined ? this._defaultState[k] : this._state[k]));
    }

    setStateFromNextState(nxtState) {
        super.setStateFromNextState(nxtState);
    }

    getNextStateFromSubhashState(state) {
        const nxtState = this._getNextState_base();

        if (state == null) {
            this._mutNextState_reset_self(nxtState);
            return nxtState;
        }

        this._mutNextState_meta_fromSubHashState(nxtState, state);

        let hasState = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            if (prop === "state") {
                hasState = true;
                const data = vals.map(v=>UrlUtil.mini.decompress(v));
                Object.keys(this._defaultState).forEach((k,i)=>nxtState[this.header].state[k] = data[i]);
            }
        }
        );

        if (!hasState)
            this._mutNextState_reset_self(nxtState);

        return nxtState;
    }

    setFromValues(values) {
        this._filters.forEach(it=>it.setFromValues(values));
    }

    _getHeaderControls(opts) {
        const wrpSummary = e_({
            tag: "div",
            clazz: "fltr__summary_item",
        }).hideVe();

        const btnForceMobile = this._isAddDropdownToggle ? ComponentUiUtil.getBtnBool(this, "isUseDropdowns", {
            $ele: $(`<button class="btn btn-default btn-xs ml-2">Show as Dropdowns</button>`),
            stateName: "meta",
            stateProp: "_meta",
        }, ) : null;
        const hkChildrenDropdowns = ()=>{
            this._filters.filter(it=>it instanceof RangeFilter).forEach(it=>it.isUseDropdowns = this._meta.isUseDropdowns);
        }
        ;
        this._addHook("meta", "isUseDropdowns", hkChildrenDropdowns);
        hkChildrenDropdowns();

        const btnResetAll = e_({
            tag: "button",
            clazz: "btn btn-default btn-xs ml-2",
            text: "Reset All",
            click: ()=>this._filters.forEach(it=>it.reset()),
        });

        const wrpBtns = e_({
            tag: "div",
            clazz: "ve-flex",
            children: [btnForceMobile, btnResetAll].filter(Boolean)
        });
        this._getHeaderControls_addExtraStateBtns(opts, wrpBtns);

        const btnShowHide = e_({
            tag: "button",
            clazz: `btn btn-default btn-xs ml-2 ${this._meta.isHidden ? "active" : ""}`,
            text: "Hide",
            click: ()=>this._meta.isHidden = !this._meta.isHidden,
        });
        const wrpControls = e_({
            tag: "div",
            clazz: "ve-flex-v-center",
            children: [wrpSummary, wrpBtns, btnShowHide]
        });

        const hookShowHide = ()=>{
            wrpBtns.toggleVe(!this._meta.isHidden);
            btnShowHide.toggleClass("active", this._meta.isHidden);
            this._$wrpChildren.toggleVe(!this._meta.isHidden);
            wrpSummary.toggleVe(this._meta.isHidden);

            const numActive = this._filters.map(it=>it.getValues()[it.header]._isActive).filter(Boolean).length;
            if (numActive) {
                e_({
                    ele: wrpSummary,
                    title: `${numActive} hidden active filter${numActive === 1 ? "" : "s"}`,
                    text: `(${numActive})`
                });
            }
        }
        ;
        this._addHook("meta", "isHidden", hookShowHide);
        hookShowHide();

        return wrpControls;
    }

    _getHeaderControls_addExtraStateBtns(opts, wrpStateBtnsOuter) {}

    $render(opts) {
        const btnAndOr = e_({
            tag: "div",
            clazz: `fltr__group-comb-toggle ve-muted`,
            click: ()=>this._state.mode = this._state.mode === "and" ? "or" : "and",
            title: `"Group AND" requires all filters in this group to match. "Group OR" required any filter in this group to match.`,
        });

        const hookAndOr = ()=>btnAndOr.innerText = `(group ${this._state.mode.toUpperCase()})`;
        this._addHook("state", "mode", hookAndOr);
        hookAndOr();

        const $children = this._filters.map((it,i)=>it.$render({
            ...opts,
            isMulti: true,
            isFirst: i === 0
        }));
        this._$wrpChildren = $$`<div>${$children}</div>`;

        const wrpControls = this._getHeaderControls(opts);

        return this.__$wrpFilter = $$`<div class="ve-flex-col">
			${opts.isFirst ? "" : `<div class="fltr__dropdown-divider mb-1"></div>`}
			<div class="split fltr__h fltr__h--multi ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
				<div class="ve-flex-v-center">
					<div class="mr-2">${this._getRenderedHeader()}</div>
					${btnAndOr}
				</div>
				${wrpControls}
			</div>
			${this._$wrpChildren}
		</div>`;
    }

    $renderMinis(opts) {
        this._filters.map((it,i)=>it.$renderMinis({
            ...opts,
            isMulti: true,
            isFirst: i === 0
        }));
    }

    isActive(vals) {
        vals = vals || this.getValues();
        return this._filters.some(it=>it.isActive(vals));
    }

    getValues({nxtState=null}={}) {
        const out = {};
        this._filters.forEach(it=>Object.assign(out, it.getValues({
            nxtState
        })));
        return out;
    }

    _mutNextState_reset_self(nxtState) {
        Object.assign(nxtState[this.header].state, MiscUtil.copy(this._defaultState));
    }

    _mutNextState_reset(nxtState, {isResetAll=false}={}) {
        if (isResetAll)
            this._mutNextState_resetBase(nxtState, {
                isResetAll
            });
        this._mutNextState_reset_self(nxtState);
    }

    reset({isResetAll=false}={}) {
        super.reset({
            isResetAll
        });
        this._filters.forEach(it=>it.reset({
            isResetAll
        }));
    }

    update() {
        this._filters.forEach(it=>it.update());
    }

    toDisplay(boxState, entryValArr) {
        if (this._filters.length !== entryValArr.length)
            throw new Error("Number of filters and number of values did not match");

        const results = [];
        for (let i = this._filters.length - 1; i >= 0; --i) {
            const f = this._filters[i];
            if (f instanceof RangeFilter) {
                results.push(f.toDisplay(boxState, entryValArr[i]));
            } else {
                const totals = boxState[f.header]._totals;

                if (totals.yes === 0 && totals.no === 0)
                    results.push(null);
                else
                    results.push(f.toDisplay(boxState, entryValArr[i]));
            }
        }

        const resultsActive = results.filter(r=>r !== null);
        if (this._state.mode === "or") {
            if (!resultsActive.length)
                return true;
            return resultsActive.find(r=>r);
        } else {
            return resultsActive.filter(r=>r).length === resultsActive.length;
        }
    }

    addItem() {
        throw new Error(`Cannot add item to MultiFilter! Add the item to a child filter instead.`);
    }

    handleSearch(searchTerm) {
        const isHeaderMatch = this.header.toLowerCase().includes(searchTerm);

        if (isHeaderMatch) {
            if (this.__$wrpFilter)
                this.__$wrpFilter.toggleClass("fltr__hidden--search", false);
            this._filters.forEach(it=>it.handleSearch(""));
            return true;
        }

        const numVisible = this._filters.map(it=>it.handleSearch(searchTerm)).reduce((a,b)=>a + b, 0);
        if (!this.__$wrpFilter)
            return;
        this.__$wrpFilter.toggleClass("fltr__hidden--search", numVisible === 0);
    }
};
MultiFilter._DETAULT_STATE = {mode: "and",}
globalThis.MultiFilter = MultiFilter;

let RangeFilter = class RangeFilter extends FilterBase {
    constructor(opts) {
        super(opts);

        if (opts.labels && opts.min == null)
            opts.min = 0;
        if (opts.labels && opts.max == null)
            opts.max = opts.labels.length - 1;

        this._min = Number(opts.min || 0);
        this._max = Number(opts.max || 0);
        this._labels = opts.isLabelled ? opts.labels : null;
        this._isAllowGreater = !!opts.isAllowGreater;
        this._isRequireFullRangeMatch = !!opts.isRequireFullRangeMatch;
        this._sparseValues = opts.isSparse ? [] : null;
        this._suffix = opts.suffix;
        this._labelSortFn = opts.labelSortFn === undefined ? SortUtil.ascSort : opts.labelSortFn;
        this._labelDisplayFn = opts.labelDisplayFn;
        this._displayFn = opts.displayFn;
        this._displayFnTooltip = opts.displayFnTooltip;

        this._filterBox = null;
        Object.assign(this.__state, {
            min: this._min,
            max: this._max,
            curMin: this._min,
            curMax: this._max,
        }, );
        this.__$wrpFilter = null;
        this.__$wrpMini = null;
        this._slider = null;

        this._labelSearchCache = null;

        this._$btnMiniGt = null;
        this._$btnMiniLt = null;
        this._$btnMiniEq = null;

        this._seenMin = this._min;
        this._seenMax = this._max;
    }

    set isUseDropdowns(val) {
        this._meta.isUseDropdowns = !!val;
    }

    getSaveableState() {
        return {
            [this.header]: {
                ...this.getBaseSaveableState(),
                state: {
                    ...this.__state
                },
            },
        };
    }

    setStateFromLoaded(filterState, {isUserSavedState=false}={}) {
        if (!filterState?.[this.header])
            return;

        const toLoad = filterState[this.header];
        this._hasUserSavedState = this._hasUserSavedState || isUserSavedState;

        const tgt = (toLoad.state || {});

        if (tgt.max == null)
            tgt.max = this._max;
        else if (this._max > tgt.max) {
            if (tgt.max === tgt.curMax)
                tgt.curMax = this._max;
            tgt.max = this._max;
        }

        if (tgt.curMax == null)
            tgt.curMax = tgt.max;
        else if (tgt.curMax > tgt.max)
            tgt.curMax = tgt.max;

        if (tgt.min == null)
            tgt.min = this._min;
        else if (this._min < tgt.min) {
            if (tgt.min === tgt.curMin)
                tgt.curMin = this._min;
            tgt.min = this._min;
        }

        if (tgt.curMin == null)
            tgt.curMin = tgt.min;
        else if (tgt.curMin < tgt.min)
            tgt.curMin = tgt.min;

        this.setBaseStateFromLoaded(toLoad);

        Object.assign(this._state, toLoad.state);
    }

    trimState_() {
        if (this._seenMin <= this._state.min && this._seenMax >= this._state.max)
            return;

        const nxtState = {
            min: this._seenMin,
            curMin: this._seenMin,
            max: this._seenMax,
            curMax: this._seenMax
        };
        this._proxyAssignSimple("state", nxtState);
    }

    getSubHashes() {
        const out = [];

        const baseMeta = this.getMetaSubHashes();
        if (baseMeta)
            out.push(...baseMeta);

        const serSliderState = [this._state.min !== this._state.curMin ? `min=${this._state.curMin}` : null, this._state.max !== this._state.curMax ? `max=${this._state.curMax}` : null, ].filter(Boolean);
        if (serSliderState.length) {
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serSliderState));
        }

        return out.length ? out : null;
    }

    _isAtDefaultPosition({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;
        return state.min === state.curMin && state.max === state.curMax;
    }

    getFilterTagPart() {
        if (this._isAtDefaultPosition())
            return null;

        if (!this._labels) {
            if (this._state.curMin === this._state.curMax)
                return `${this.header}=[${this._state.curMin}]`;
            return `${this.header}=[${this._state.curMin};${this._state.curMax}]`;
        }

        if (this._state.curMin === this._state.curMax) {
            const label = this._labels[this._state.curMin];
            return `${this.header}=[&${label}]`;
        }

        const labelLow = this._labels[this._state.curMin];
        const labelHigh = this._labels[this._state.curMax];
        return `${this.header}=[&${labelLow};&${labelHigh}]`;
    }

    getDisplayStatePart({nxtState=null}={}) {
        if (this._isAtDefaultPosition({
            nxtState
        }))
            return null;

        const {summary} = this._getDisplaySummary({
            nxtState
        });

        return `${this.header}: ${summary}`;
    }

    getNextStateFromSubhashState(state) {
        const nxtState = this._getNextState_base();

        if (state == null) {
            this._mutNextState_reset(nxtState);
            return nxtState;
        }

        this._mutNextState_meta_fromSubHashState(nxtState, state);

        let hasState = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            if (prop === "state") {
                hasState = true;
                vals.forEach(v=>{
                    const [prop,val] = v.split("=");
                    if (val.startsWith("&") && !this._labels)
                        throw new Error(`Could not dereference label: "${val}"`);

                    let num;
                    if (val.startsWith("&")) {
                        const clean = val.replace("&", "").toLowerCase();
                        num = this._labels.findIndex(it=>String(it).toLowerCase() === clean);
                        if (!~num)
                            throw new Error(`Could not find index for label "${clean}"`);
                    } else
                        num = Number(val);

                    switch (prop) {
                    case "min":
                        if (num < nxtState[this.header].state.min)
                            nxtState[this.header].state.min = num;
                        nxtState[this.header].state.curMin = Math.max(nxtState[this.header].state.min, num);
                        break;
                    case "max":
                        if (num > nxtState[this.header].state.max)
                            nxtState[this.header].state.max = num;
                        nxtState[this.header].state.curMax = Math.min(nxtState[this.header].state.max, num);
                        break;
                    default:
                        throw new Error(`Unknown prop "${prop}"`);
                    }
                }
                );
            }
        }
        );

        if (!hasState)
            this._mutNextState_reset(nxtState);

        return nxtState;
    }

    setFromValues(values) {
        if (!values[this.header])
            return;

        const vals = values[this.header];

        if (vals.min != null)
            this._state.curMin = Math.max(this._state.min, vals.min);
        else
            this._state.curMin = this._state.min;

        if (vals.max != null)
            this._state.curMax = Math.max(this._state.max, vals.max);
        else
            this._state.curMax = this._state.max;
    }

    _$getHeaderControls() {
        const $btnForceMobile = ComponentUiUtil.$getBtnBool(this, "isUseDropdowns", {
            $ele: $(`<button class="btn btn-default btn-xs mr-2">Show as Dropdowns</button>`),
            stateName: "meta",
            stateProp: "_meta",
        }, );
        const $btnReset = $(`<button class="btn btn-default btn-xs">Reset</button>`).click(()=>this.reset());
        const $wrpBtns = $$`<div>${$btnForceMobile}${$btnReset}</div>`;

        const $wrpSummary = $(`<div class="ve-flex-v-center fltr__summary_item fltr__summary_item--include"></div>`).hideVe();

        const $btnShowHide = $(`<button class="btn btn-default btn-xs ml-2 ${this._meta.isHidden ? "active" : ""}">Hide</button>`).click(()=>this._meta.isHidden = !this._meta.isHidden);
        const hkIsHidden = ()=>{
            $btnShowHide.toggleClass("active", this._meta.isHidden);
            $wrpBtns.toggleVe(!this._meta.isHidden);
            $wrpSummary.toggleVe(this._meta.isHidden);

            const {summaryTitle, summary} = this._getDisplaySummary();
            $wrpSummary.title(summaryTitle).text(summary);
        }
        ;
        this._addHook("meta", "isHidden", hkIsHidden);
        hkIsHidden();

        return $$`
		<div class="ve-flex-v-center">
			${$wrpBtns}
			${$wrpSummary}
			${$btnShowHide}
		</div>`;
    }

    _getDisplaySummary({nxtState=null}={}) {
        const cur = this.getValues({
            nxtState
        })[this.header];

        const isRange = !cur.isMinVal && !cur.isMaxVal;
        const isCapped = !cur.isMinVal || !cur.isMaxVal;

        return {
            summaryTitle: isRange ? `Hidden range` : isCapped ? `Hidden limit` : "",
            summary: isRange ? `${this._getDisplayText(cur.min)}-${this._getDisplayText(cur.max)}` : !cur.isMinVal ? `≥ ${this._getDisplayText(cur.min)}` : !cur.isMaxVal ? `≤ ${this._getDisplayText(cur.max)}` : "",
        };
    }

    _getDisplayText(value, {isBeyondMax=false, isTooltip=false}={}) {
        value = `${this._labels ? this._labelDisplayFn ? this._labelDisplayFn(this._labels[value]) : this._labels[value] : (isTooltip && this._displayFnTooltip) ? this._displayFnTooltip(value) : this._displayFn ? this._displayFn(value) : value}${isBeyondMax ? "+" : ""}`;
        if (this._suffix)
            value += this._suffix;
        return value;
    }

    $render(opts) {
        this._filterBox = opts.filterBox;
        this.__$wrpMini = opts.$wrpMini;

        const $wrpControls = opts.isMulti ? null : this._$getHeaderControls();

        const $wrpSlider = $$`<div class="fltr__wrp-pills fltr__wrp-pills--flex"></div>`;
        const $wrpDropdowns = $$`<div class="fltr__wrp-pills fltr__wrp-pills--flex"></div>`;
        const hookHidden = ()=>{
            $wrpSlider.toggleVe(!this._meta.isHidden && !this._meta.isUseDropdowns);
            $wrpDropdowns.toggleVe(!this._meta.isHidden && !!this._meta.isUseDropdowns);
        }
        ;
        this._addHook("meta", "isHidden", hookHidden);
        this._addHook("meta", "isUseDropdowns", hookHidden);
        hookHidden();

        if (this._sparseValues?.length) {
            const sparseMin = this._sparseValues[0];
            if (this._state.min < sparseMin) {
                this._state.curMin = Math.max(this._state.curMin, sparseMin);
                this._state.min = sparseMin;
            }

            const sparseMax = this._sparseValues.last();
            if (this._state.max > sparseMax) {
                this._state.curMax = Math.min(this._state.curMax, sparseMax);
                this._state.max = sparseMax;
            }
        }

        const getSliderOpts = ()=>{
            const fnDisplay = (val,{isTooltip=false}={})=>{
                return this._getDisplayText(val, {
                    isBeyondMax: this._isAllowGreater && val === this._state.max,
                    isTooltip
                });
            }
            ;

            return {
                propMin: "min",
                propMax: "max",
                propCurMin: "curMin",
                propCurMax: "curMax",
                fnDisplay: (val)=>fnDisplay(val),
                fnDisplayTooltip: (val)=>fnDisplay(val, {
                    isTooltip: true
                }),
                sparseValues: this._sparseValues,
            };
        }
        ;

        const hkUpdateLabelSearchCache = ()=>{
            if (this._labels)
                return this._doUpdateLabelSearchCache();
            this._labelSearchCache = null;
        }
        ;
        this._addHook("state", "curMin", hkUpdateLabelSearchCache);
        this._addHook("state", "curMax", hkUpdateLabelSearchCache);
        hkUpdateLabelSearchCache();

        this._slider = new ComponentUiUtil.RangeSlider({
            comp: this,
            ...getSliderOpts()
        });
        $wrpSlider.append(this._slider.get());

        const selMin = e_({
            tag: "select",
            clazz: `form-control mr-2`,
            change: ()=>{
                const nxtMin = Number(selMin.val());
                const [min,max] = [nxtMin, this._state.curMax].sort(SortUtil.ascSort);
                this._state.curMin = min;
                this._state.curMax = max;
            }
            ,
        });
        const selMax = e_({
            tag: "select",
            clazz: `form-control`,
            change: ()=>{
                const nxMax = Number(selMax.val());
                const [min,max] = [this._state.curMin, nxMax].sort(SortUtil.ascSort);
                this._state.curMin = min;
                this._state.curMax = max;
            }
            ,
        });
        $$`<div class="ve-flex-v-center w-100 px-3 py-1">${selMin}${selMax}</div>`.appendTo($wrpDropdowns);

        const handleCurUpdate = ()=>{
            selMin.val(`${this._state.curMin}`);
            selMax.val(`${this._state.curMax}`);
        }
        ;

        const handleLimitUpdate = ()=>{
            this._doPopulateDropdown(selMin, this._state.curMin);
            this._doPopulateDropdown(selMax, this._state.curMax);
        }
        ;

        this._addHook("state", "min", handleLimitUpdate);
        this._addHook("state", "max", handleLimitUpdate);
        this._addHook("state", "curMin", handleCurUpdate);
        this._addHook("state", "curMax", handleCurUpdate);
        handleCurUpdate();
        handleLimitUpdate();

        if (opts.isMulti) {
            this._slider.get().classList.add("ve-grow");
            $wrpSlider.addClass("ve-grow");
            $wrpDropdowns.addClass("ve-grow");

            return this.__$wrpFilter = $$`<div class="ve-flex">
				<div class="fltr__range-inline-label mr-2">${this._getRenderedHeader()}</div>
				${$wrpSlider}
				${$wrpDropdowns}
			</div>`;
        } else {
            const btnMobToggleControls = this._getBtnMobToggleControls($wrpControls);

            return this.__$wrpFilter = $$`<div class="ve-flex-col">
				${opts.isFirst ? "" : `<div class="fltr__dropdown-divider mb-1"></div>`}
				<div class="split fltr__h ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
					<div class="fltr__h-text ve-flex-h-center">${this._getRenderedHeader()}${btnMobToggleControls}</div>
					${$wrpControls}
				</div>
				${$wrpSlider}
				${$wrpDropdowns}
			</div>`;
        }
    }

    $renderMinis(opts) {
        if (!opts.$wrpMini)
            return;

        this._filterBox = opts.filterBox;
        this.__$wrpMini = opts.$wrpMini;

        this._$btnMiniGt = this._$btnMiniGt || $(`<div class="fltr__mini-pill" state="ignore"></div>`).click(()=>{
            this._state.curMin = this._state.min;
            this._filterBox.fireChangeEvent();
        }
        );
        this._$btnMiniGt.appendTo(this.__$wrpMini);

        this._$btnMiniLt = this._$btnMiniLt || $(`<div class="fltr__mini-pill" state="ignore"></div>`).click(()=>{
            this._state.curMax = this._state.max;
            this._filterBox.fireChangeEvent();
        }
        );
        this._$btnMiniLt.appendTo(this.__$wrpMini);

        this._$btnMiniEq = this._$btnMiniEq || $(`<div class="fltr__mini-pill" state="ignore"></div>`).click(()=>{
            this._state.curMin = this._state.min;
            this._state.curMax = this._state.max;
            this._filterBox.fireChangeEvent();
        }
        );
        this._$btnMiniEq.appendTo(this.__$wrpMini);

        const hideHook = ()=>{
            const isHidden = this._filterBox.isMinisHidden(this.header);
            this._$btnMiniGt.toggleClass("ve-hidden", isHidden);
            this._$btnMiniLt.toggleClass("ve-hidden", isHidden);
            this._$btnMiniEq.toggleClass("ve-hidden", isHidden);
        }
        ;
        this._filterBox.registerMinisHiddenHook(this.header, hideHook);
        hideHook();

        const handleMiniUpdate = ()=>{
            if (this._state.curMin === this._state.curMax) {
                this._$btnMiniGt.attr("state", FilterBox._PILL_STATES[0]);
                this._$btnMiniLt.attr("state", FilterBox._PILL_STATES[0]);

                this._$btnMiniEq.attr("state", this._isAtDefaultPosition() ? FilterBox._PILL_STATES[0] : FilterBox._PILL_STATES[1]).text(`${this.header} = ${this._getDisplayText(this._state.curMin, {
                    isBeyondMax: this._isAllowGreater && this._state.curMin === this._state.max
                })}`);
            } else {
                if (this._state.min !== this._state.curMin) {
                    this._$btnMiniGt.attr("state", FilterBox._PILL_STATES[1]).text(`${this.header} ≥ ${this._getDisplayText(this._state.curMin)}`);
                } else
                    this._$btnMiniGt.attr("state", FilterBox._PILL_STATES[0]);

                if (this._state.max !== this._state.curMax) {
                    this._$btnMiniLt.attr("state", FilterBox._PILL_STATES[1]).text(`${this.header} ≤ ${this._getDisplayText(this._state.curMax)}`);
                } else
                    this._$btnMiniLt.attr("state", FilterBox._PILL_STATES[0]);

                this._$btnMiniEq.attr("state", FilterBox._PILL_STATES[0]);
            }
        }
        ;

        const handleCurUpdate = ()=>{
            handleMiniUpdate();
        }
        ;

        const handleLimitUpdate = ()=>{
            handleMiniUpdate();
        }
        ;

        this._addHook("state", "min", handleLimitUpdate);
        this._addHook("state", "max", handleLimitUpdate);
        this._addHook("state", "curMin", handleCurUpdate);
        this._addHook("state", "curMax", handleCurUpdate);
        handleCurUpdate();
        handleLimitUpdate();
    }

    _doPopulateDropdown(sel, curVal) {
        let tmp = "";
        for (let i = 0, len = this._state.max - this._state.min + 1; i < len; ++i) {
            const val = i + this._state.min;
            const label = `${this._getDisplayText(val)}`.qq();
            tmp += `<option value="${val}" ${curVal === val ? "selected" : ""}>${label}</option>`;
        }
        sel.innerHTML = tmp;
        return sel;
    }

    getValues({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        const out = {
            isMaxVal: state.max === state.curMax,
            isMinVal: state.min === state.curMin,
            max: state.curMax,
            min: state.curMin,
        };
        out._isActive = !(out.isMinVal && out.isMaxVal);
        return {
            [this.header]: out
        };
    }

    _mutNextState_reset(nxtState, {isResetAll=false}={}) {
        if (isResetAll)
            this._mutNextState_resetBase(nxtState, {
                isResetAll
            });
        nxtState[this.header].state.curMin = nxtState[this.header].state.min;
        nxtState[this.header].state.curMax = nxtState[this.header].state.max;
    }

    update() {
        if (!this.__$wrpMini)
            return;

        if (this._$btnMiniGt)
            this.__$wrpMini.append(this._$btnMiniGt);
        if (this._$btnMiniLt)
            this.__$wrpMini.append(this._$btnMiniLt);
        if (this._$btnMiniEq)
            this.__$wrpMini.append(this._$btnMiniEq);
    }

    toDisplay(boxState, entryVal) {
        const filterState = boxState[this.header];
        if (!filterState)
            return true;
        if (entryVal == null)
            return filterState.min === this._state.min && filterState.max === this._state.max;

        if (this._labels) {
            const slice = this._labels.slice(filterState.min, filterState.max + 1);

            if (this._isAllowGreater) {
                if (filterState.max === this._state.max && entryVal > this._labels[filterState.max])
                    return true;

                const sliceMin = Math.min(...slice);
                const sliceMax = Math.max(...slice);

                if (entryVal instanceof Array)
                    return entryVal.some(it=>it >= sliceMin && it <= sliceMax);
                return entryVal >= sliceMin && entryVal <= sliceMax;
            }

            if (entryVal instanceof Array)
                return entryVal.some(it=>slice.includes(it));
            return slice.includes(entryVal);
        } else {
            if (entryVal instanceof Array) {
                if (this._isRequireFullRangeMatch)
                    return filterState.min <= entryVal[0] && filterState.max >= entryVal.last();

                return entryVal.some(ev=>this._toDisplay_isToDisplayEntry(filterState, ev));
            }
            return this._toDisplay_isToDisplayEntry(filterState, entryVal);
        }
    }

    _toDisplay_isToDisplayEntry(filterState, ev) {
        const isGtMin = filterState.min <= ev;
        const isLtMax = filterState.max >= ev;
        if (this._isAllowGreater)
            return isGtMin && (isLtMax || filterState.max === this._state.max);
        return isGtMin && isLtMax;
    }

    addItem(item) {
        if (item == null)
            return;

        if (item instanceof Array) {
            const len = item.length;
            for (let i = 0; i < len; ++i)
                this.addItem(item[i]);
            return;
        }

        if (this._labels) {
            if (!this._labels.some(it=>it === item))
                this._labels.push(item);

            this._doUpdateLabelSearchCache();

            this._addItem_addNumber(this._labels.length - 1);
        } else {
            this._addItem_addNumber(item);
        }
    }

    _doUpdateLabelSearchCache() {
        this._labelSearchCache = [...new Array(Math.max(0, this._max - this._min))].map((_,i)=>i + this._min).map(val=>this._getDisplayText(val, {
            isBeyondMax: this._isAllowGreater && val === this._state.max,
            isTooltip: true
        })).join(" -- ").toLowerCase();
    }

    _addItem_addNumber(number) {
        if (number == null || isNaN(number))
            return;

        this._seenMin = Math.min(this._seenMin, number);
        this._seenMax = Math.max(this._seenMax, number);

        if (this._sparseValues && !this._sparseValues.includes(number)) {
            this._sparseValues.push(number);
            this._sparseValues.sort(SortUtil.ascSort);
        }

        if (number >= this._state.min && number <= this._state.max)
            return;
        if (this._state.min == null && this._state.max == null)
            this._state.min = this._state.max = number;
        else {
            const old = {
                ...this.__state
            };

            if (number < old.min)
                this._state.min = number;
            if (number > old.max)
                this._state.max = number;

            if (old.curMin === old.min)
                this._state.curMin = this._state.min;
            if (old.curMax === old.max)
                this._state.curMax = this._state.max;
        }
    }

    getDefaultMeta() {
        const out = {
            ...super.getDefaultMeta(),
            ...RangeFilter._DEFAULT_META,
        };
        if (Renderer.hover.isSmallScreen())
            out.isUseDropdowns = true;
        return out;
    }

    handleSearch(searchTerm) {
        if (this.__$wrpFilter == null)
            return;

        const isVisible = this.header.toLowerCase().includes(searchTerm) || (this._labelSearchCache != null ? this._labelSearchCache.includes(searchTerm) : [...new Array(this._state.max - this._state.min)].map((_,n)=>n + this._state.min).join(" -- ").includes(searchTerm));

        this.__$wrpFilter.toggleClass("fltr__hidden--search", !isVisible);

        return isVisible;
    }
};
RangeFilter._DEFAULT_META = {
    isUseDropdowns: false,
};
globalThis.RangeFilter = RangeFilter;
//#endregion

//#region SourceFilter
class SourceFilter extends Filter {

    constructor(opts) {
        opts = opts || {};

        opts.header = opts.header === undefined ? FilterBox.SOURCE_HEADER : opts.header;
        opts.displayFn = opts.displayFn === undefined ? item=>Parser.sourceJsonToFullCompactPrefix(item.item || item) : opts.displayFn;
        opts.displayFnMini = opts.displayFnMini === undefined ? SourceFilter._getDisplayHtmlMini.bind(SourceFilter) : opts.displayFnMini;
        opts.displayFnTitle = opts.displayFnTitle === undefined ? item=>Parser.sourceJsonToFull(item.item || item) : opts.displayFnTitle;
        opts.itemSortFnMini = opts.itemSortFnMini === undefined ? SourceFilter._SORT_ITEMS_MINI.bind(SourceFilter) : opts.itemSortFnMini;
        opts.itemSortFn = opts.itemSortFn === undefined ? (a,b)=>SortUtil.ascSortLower(Parser.sourceJsonToFull(a.item), Parser.sourceJsonToFull(b.item)) : opts.itemSortFn;
        opts.groupFn = opts.groupFn === undefined ? SourceUtil.getFilterGroup : opts.groupFn;
        opts.selFn = opts.selFn === undefined ? PageFilter.defaultSourceSelFn : opts.selFn;

        super(opts);

        this.__tmpState = { ixAdded: 0 };
        this._tmpState = this._getProxy("tmpState", this.__tmpState);
    }

    doSetPillsClear() {
        return this._doSetPillsClear();
    }

    /**
     * Add an item from the SourceFilter
     * @param {any} item
     */
    addItem(item) {
        const out = super.addItem(item);
        this._tmpState.ixAdded++;
        return out;
    }

    /**
     * Remove an item from the SourceFilter
     * @param {any} item
     */
    removeItem(item) {
        const out = super.removeItem(item);
        this._tmpState.ixAdded--;
        return out;
    }

    _getHeaderControls_addExtraStateBtns(opts, wrpStateBtnsOuter) {
        const btnSupplements = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection; CTRL to include UA/etc.`,
            html: `Core/Supplements`,
            click: evt=>this._doSetPinsSupplements({
                isIncludeUnofficial: EventUtil.isCtrlMetaKey(evt),
                isAdditive: evt.shiftKey
            }),
        });

        const btnAdventures = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection; CTRL to include UA`,
            html: `Adventures`,
            click: evt=>this._doSetPinsAdventures({
                isIncludeUnofficial: EventUtil.isCtrlMetaKey(evt),
                isAdditive: evt.shiftKey
            }),
        });

        const btnPartnered = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection`,
            html: `Partnered`,
            click: evt=>this._doSetPinsPartnered({
                isAdditive: evt.shiftKey
            }),
        });

        const btnHomebrew = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection`,
            html: `Homebrew`,
            click: evt=>this._doSetPinsHomebrew({
                isAdditive: evt.shiftKey
            }),
        });

        const hkIsButtonsActive = ()=>{
            const hasPartnered = Object.keys(this.__state).some(src=>SourceUtil.getFilterGroup(src) === SourceUtil.FILTER_GROUP_PARTNERED);
            btnPartnered.toggleClass("ve-hidden", !hasPartnered);

            const hasBrew = Object.keys(this.__state).some(src=>SourceUtil.getFilterGroup(src) === SourceUtil.FILTER_GROUP_HOMEBREW);
            btnHomebrew.toggleClass("ve-hidden", !hasBrew);
        }
        ;
        this._addHook("tmpState", "ixAdded", hkIsButtonsActive);
        hkIsButtonsActive();

        const actionSelectDisplayMode = new ContextUtil.ActionSelect({
            values: Object.keys(SourceFilter._PILL_DISPLAY_MODE_LABELS).map(Number),
            fnGetDisplayValue: val=>SourceFilter._PILL_DISPLAY_MODE_LABELS[val] || SourceFilter._PILL_DISPLAY_MODE_LABELS[0],
            fnOnChange: val=>this._meta.pillDisplayMode = val,
        });
        this._addHook("meta", "pillDisplayMode", ()=>{
            actionSelectDisplayMode.setValue(this._meta.pillDisplayMode);
        }
        )();

        const menu = ContextUtil.getMenu([new ContextUtil.Action("Select All Standard Sources",()=>this._doSetPinsStandard(),), new ContextUtil.Action("Select All Partnered Sources",()=>this._doSetPinsPartnered(),), new ContextUtil.Action("Select All Non-Standard Sources",()=>this._doSetPinsNonStandard(),), new ContextUtil.Action("Select All Homebrew Sources",()=>this._doSetPinsHomebrew(),), null, new ContextUtil.Action(`Select "Vanilla" Sources`,()=>this._doSetPinsVanilla(),{
            title: `Select a baseline set of sources suitable for any campaign.`
        },), new ContextUtil.Action("Select All Non-UA Sources",()=>this._doSetPinsNonUa(),), null, new ContextUtil.Action("Select SRD Sources",()=>this._doSetPinsSrd(),{
            title: `Select System Reference Document Sources.`
        },), new ContextUtil.Action("Select Basic Rules Sources",()=>this._doSetPinsBasicRules(),), null, new ContextUtil.Action("Invert Selection",()=>this._doInvertPins(),), null, actionSelectDisplayMode, ]);
        const btnBurger = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            html: `<span class="glyphicon glyphicon-option-vertical"></span>`,
            click: evt=>ContextUtil.pOpenMenu(evt, menu),
            title: "Other Options",
        });

        const btnOnlyPrimary = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            html: `Include References`,
            title: `Consider entities as belonging to every source they appear in (i.e. reprints) as well as their primary source`,
            click: ()=>this._meta.isIncludeOtherSources = !this._meta.isIncludeOtherSources,
        });
        const hkIsIncludeOtherSources = ()=>{
            btnOnlyPrimary.toggleClass("active", !!this._meta.isIncludeOtherSources);
        }
        ;
        hkIsIncludeOtherSources();
        this._addHook("meta", "isIncludeOtherSources", hkIsIncludeOtherSources);

        e_({
            tag: "div",
            clazz: `btn-group mr-2 w-100 ve-flex-v-center mobile__m-1 mobile__mb-2`,
            children: [btnSupplements, btnAdventures, btnPartnered, btnHomebrew, btnBurger, btnOnlyPrimary, ],
        }).prependTo(wrpStateBtnsOuter);
    }

    _doSetPinsStandard() {
        Object.keys(this._state).forEach(k=>this._state[k] = SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_STANDARD ? 1 : 0);
    }

    _doSetPinsPartnered({isAdditive=false}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_PARTNERED ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsNonStandard() {
        Object.keys(this._state).forEach(k=>this._state[k] = SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_NON_STANDARD ? 1 : 0);
    }

    _doSetPinsSupplements({isIncludeUnofficial=false, isAdditive=false}={}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.isCoreOrSupplement(k) && (isIncludeUnofficial || !SourceUtil.isNonstandardSource(k)) ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsAdventures({isIncludeUnofficial=false, isAdditive=false}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.isAdventure(k) && (isIncludeUnofficial || !SourceUtil.isNonstandardSource(k)) ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsHomebrew({isAdditive=false}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_HOMEBREW ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsVanilla() {
        Object.keys(this._state).forEach(k=>this._state[k] = Parser.SOURCES_VANILLA.has(k) ? 1 : 0);
    }

    _doSetPinsNonUa() {
        Object.keys(this._state).forEach(k=>this._state[k] = !SourceUtil.isPrereleaseSource(k) ? 1 : 0);
    }

    _doSetPinsSrd() {
        SourceFilter._SRD_SOURCES = SourceFilter._SRD_SOURCES || new Set([Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG]);

        Object.keys(this._state).forEach(k=>this._state[k] = SourceFilter._SRD_SOURCES.has(k) ? 1 : 0);

        const srdFilter = this._filterBox.filters.find(it=>it.isSrdFilter);
        if (srdFilter)
            srdFilter.setValue("SRD", 1);

        const basicRulesFilter = this._filterBox.filters.find(it=>it.isBasicRulesFilter);
        if (basicRulesFilter)
            basicRulesFilter.setValue("Basic Rules", 0);

        const reprintedFilter = this._filterBox.filters.find(it=>it.isReprintedFilter);
        if (reprintedFilter)
            reprintedFilter.setValue("Reprinted", 0);
    }

    _doSetPinsBasicRules() {
        SourceFilter._BASIC_RULES_SOURCES = SourceFilter._BASIC_RULES_SOURCES || new Set([Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG]);

        Object.keys(this._state).forEach(k=>this._state[k] = SourceFilter._BASIC_RULES_SOURCES.has(k) ? 1 : 0);

        const basicRulesFilter = this._filterBox.filters.find(it=>it.isBasicRulesFilter);
        if (basicRulesFilter)
            basicRulesFilter.setValue("Basic Rules", 1);

        const srdFilter = this._filterBox.filters.find(it=>it.isSrdFilter);
        if (srdFilter)
            srdFilter.setValue("SRD", 0);

        const reprintedFilter = this._filterBox.filters.find(it=>it.isReprintedFilter);
        if (reprintedFilter)
            reprintedFilter.setValue("Reprinted", 0);
    }

    static getCompleteFilterSources(ent) {
        if (!ent.otherSources)
            return ent.source;

        const otherSourcesFilt = ent.otherSources.filter(src=>!ExcludeUtil.isExcluded("*", "*", src.source, {
            isNoCount: true
        }));
        if (!otherSourcesFilt.length)
            return ent.source;

        return [ent.source].concat(otherSourcesFilt.map(src=>new SourceFilterItem({
            item: src.source,
            isIgnoreRed: true,
            isOtherSource: true
        })));
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider(group) {
        switch (group) {
        case SourceUtil.FILTER_GROUP_NON_STANDARD:
            return this._doRenderPills_doRenderWrpGroup_getHrDivider_groupNonStandard(group);
        case SourceUtil.FILTER_GROUP_HOMEBREW:
            return this._doRenderPills_doRenderWrpGroup_getHrDivider_groupBrew(group);
        default:
            return super._doRenderPills_doRenderWrpGroup_getHrDivider(group);
        }
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider_groupNonStandard(group) {
        let dates = [];
        const comp = BaseComponent.fromObject({
            min: 0,
            max: 0,
            curMin: 0,
            curMax: 0,
        });

        const wrpSlider = new ComponentUiUtil.RangeSlider({
            comp,
            propMin: "min",
            propMax: "max",
            propCurMin: "curMin",
            propCurMax: "curMax",
            fnDisplay: val=>dates[val]?.str,
        }).get();

        const wrpWrpSlider = e_({
            tag: "div",
            clazz: `"w-100 ve-flex pt-2 pb-5 mb-2 mt-1 fltr-src__wrp-slider`,
            children: [wrpSlider, ],
        }).hideVe();

        const btnCancel = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default px-1`,
            html: "Cancel",
            click: ()=>{
                grpBtnsInactive.showVe();
                wrpWrpSlider.hideVe();
                grpBtnsActive.hideVe();
            }
            ,
        });

        const btnConfirm = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default px-1`,
            html: "Confirm",
            click: ()=>{
                grpBtnsInactive.showVe();
                wrpWrpSlider.hideVe();
                grpBtnsActive.hideVe();

                const min = comp._state.curMin;
                const max = comp._state.curMax;

                const allowedDateSet = new Set(dates.slice(min, max + 1).map(it=>it.str));
                const nxtState = {};
                Object.keys(this._state).filter(k=>SourceUtil.isNonstandardSource(k)).forEach(k=>{
                    const sourceDate = Parser.sourceJsonToDate(k);
                    nxtState[k] = allowedDateSet.has(sourceDate) ? 1 : 0;
                }
                );
                this._proxyAssign("state", "_state", "__state", nxtState);
            }
            ,
        });

        const btnShowSlider = e_({
            tag: "button",
            clazz: `btn btn-xxs btn-default px-1`,
            html: "Select by Date",
            click: ()=>{
                grpBtnsInactive.hideVe();
                wrpWrpSlider.showVe();
                grpBtnsActive.showVe();

                dates = Object.keys(this._state).filter(it=>SourceUtil.isNonstandardSource(it)).map(it=>Parser.sourceJsonToDate(it)).filter(Boolean).unique().map(it=>({
                    str: it,
                    date: new Date(it)
                })).sort((a,b)=>SortUtil.ascSortDate(a.date, b.date)).reverse();

                comp._proxyAssignSimple("state", {
                    min: 0,
                    max: dates.length - 1,
                    curMin: 0,
                    curMax: dates.length - 1,
                }, );
            }
            ,
        });

        const btnClear = e_({
            tag: "button",
            clazz: `btn btn-xxs btn-default px-1`,
            html: "Clear",
            click: ()=>{
                const nxtState = {};
                Object.keys(this._state).filter(k=>SourceUtil.isNonstandardSource(k)).forEach(k=>nxtState[k] = 0);
                this._proxyAssign("state", "_state", "__state", nxtState);
            }
            ,
        });

        const grpBtnsActive = e_({
            tag: "div",
            clazz: `ve-flex-v-center btn-group`,
            children: [btnCancel, btnConfirm, ],
        }).hideVe();

        const grpBtnsInactive = e_({
            tag: "div",
            clazz: `ve-flex-v-center btn-group`,
            children: [btnClear, btnShowSlider, ],
        });

        return e_({
            tag: "div",
            clazz: `ve-flex-col w-100`,
            children: [super._doRenderPills_doRenderWrpGroup_getHrDivider(), e_({
                tag: "div",
                clazz: `mb-1 ve-flex-h-right`,
                children: [grpBtnsActive, grpBtnsInactive, ],
            }), wrpWrpSlider, ],
        });
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider_groupBrew(group) {
        const btnClear = e_({
            tag: "button",
            clazz: `btn btn-xxs btn-default px-1`,
            html: "Clear",
            click: ()=>{
                const nxtState = {};
                Object.keys(this._state).filter(k=>BrewUtil2.hasSourceJson(k)).forEach(k=>nxtState[k] = 0);
                this._proxyAssign("state", "_state", "__state", nxtState);
            }
            ,
        });

        return e_({
            tag: "div",
            clazz: `ve-flex-col w-100`,
            children: [super._doRenderPills_doRenderWrpGroup_getHrDivider(), e_({
                tag: "div",
                clazz: `mb-1 ve-flex-h-right`,
                children: [e_({
                    tag: "div",
                    clazz: `ve-flex-v-center btn-group`,
                    children: [btnClear, ],
                }), ],
            }), ],
        });
    }

    _toDisplay_getMappedEntryVal(entryVal) {
        entryVal = super._toDisplay_getMappedEntryVal(entryVal);
        if (!this._meta.isIncludeOtherSources)
            entryVal = entryVal.filter(it=>!it.isOtherSource);
        return entryVal;
    }

    _getPill(item) {
        const displayText = this._getDisplayText(item);
        const displayTextMini = this._getDisplayTextMini(item);

        const dispName = e_({
            tag: "span",
            html: displayText,
        });

        const spc = e_({
            tag: "span",
            clazz: "px-2 fltr-src__spc-pill",
            text: "|",
        });

        const dispAbbreviation = e_({
            tag: "span",
            html: displayTextMini,
        });

        const btnPill = e_({
            tag: "div",
            clazz: "fltr__pill",
            children: [dispAbbreviation, spc, dispName, ],
            click: evt=>this._getPill_handleClick({
                evt,
                item
            }),
            contextmenu: evt=>this._getPill_handleContextmenu({
                evt,
                item
            }),
        });

        this._getPill_bindHookState({
            btnPill,
            item
        });

        this._addHook("meta", "pillDisplayMode", ()=>{
            dispAbbreviation.toggleVe(this._meta.pillDisplayMode !== 0);
            spc.toggleVe(this._meta.pillDisplayMode === 2);
            dispName.toggleVe(this._meta.pillDisplayMode !== 1);
        }
        )();

        item.searchText = `${Parser.sourceJsonToAbv(item.item || item).toLowerCase()} -- ${displayText.toLowerCase()}`;

        return btnPill;
    }

    getSources() {
        const out = { all: [], };
        this._items.forEach(it=>{
            out.all.push(it.item);
            const group = this._groupFn(it);
            (out[group] ||= []).push(it.item);
        });
        return out;
    }

    getDefaultMeta() {
        return {
            ...super.getDefaultMeta(),
            ...SourceFilter._DEFAULT_META,
        };
    }

    static _SORT_ITEMS_MINI(a, b) {
        a = a.item ?? a;
        b = b.item ?? b;
        const valA = BrewUtil2.hasSourceJson(a) ? 2 : (SourceUtil.isNonstandardSource(a) || PrereleaseUtil.hasSourceJson(a)) ? 1 : 0;
        const valB = BrewUtil2.hasSourceJson(b) ? 2 : (SourceUtil.isNonstandardSource(b) || PrereleaseUtil.hasSourceJson(b)) ? 1 : 0;
        return SortUtil.ascSort(valA, valB) || SortUtil.ascSortLower(Parser.sourceJsonToFull(a), Parser.sourceJsonToFull(b));
    }

    static _getDisplayHtmlMini(item) {
        item = item.item || item;
        const isBrewSource = BrewUtil2.hasSourceJson(item);
        const isNonStandardSource = !isBrewSource && (SourceUtil.isNonstandardSource(item) || PrereleaseUtil.hasSourceJson(item));
        return `<span ${isBrewSource ? `title="(Homebrew)"` : isNonStandardSource ? `title="(UA/Etc.)"` : ""} class="glyphicon ${isBrewSource ? `glyphicon-glass` : isNonStandardSource ? `glyphicon-file` : `glyphicon-book`}"></span> ${Parser.sourceJsonToAbv(item)}`;
    }
};
SourceFilter._DEFAULT_META = {
    isIncludeOtherSources: false,
    pillDisplayMode: 0,
};
SourceFilter._PILL_DISPLAY_MODE_LABELS = {
    "0": "As Names",
    "1": "As Abbreviations",
    "2": "As Names Plus Abbreviations",
};
SourceFilter._SRD_SOURCES = null;
SourceFilter._BASIC_RULES_SOURCES = null;

class SourceFilterItem extends FilterItem {
    constructor(options) {
        super(options);
        this.isOtherSource = options.isOtherSource;
    }
}
//#endregion
//#region OptionsFilter
let OptionsFilter = class OptionsFilter extends FilterBase {
    constructor(opts) {
        super(opts);
        this._defaultState = opts.defaultState;
        this._displayFn = opts.displayFn;
        this._displayFnMini = opts.displayFnMini;

        Object.assign(this.__state, MiscUtil.copy(opts.defaultState), );

        this._filterBox = null;
        this.__$wrpMini = null;
    }

    getSaveableState() {
        return {
            [this.header]: {
                ...this.getBaseSaveableState(),
                state: {
                    ...this.__state
                },
            },
        };
    }

    setStateFromLoaded(filterState, {isUserSavedState=false}={}) {
        if (!filterState?.[this.header])
            return;

        const toLoad = filterState[this.header];
        this._hasUserSavedState = this._hasUserSavedState || isUserSavedState;

        this.setBaseStateFromLoaded(toLoad);

        const toAssign = {};
        Object.keys(this._defaultState).forEach(k=>{
            if (toLoad.state[k] == null)
                return;
            if (typeof toLoad.state[k] !== typeof this._defaultState[k])
                return;
            toAssign[k] = toLoad.state[k];
        }
        );

        Object.assign(this._state, toAssign);
    }

    _getStateNotDefault() {
        return Object.entries(this._state).filter(([k,v])=>this._defaultState[k] !== v);
    }

    getSubHashes() {
        const out = [];

        const baseMeta = this.getMetaSubHashes();
        if (baseMeta)
            out.push(...baseMeta);

        const serOptionState = [];
        Object.entries(this._defaultState).forEach(([k,vDefault])=>{
            if (this._state[k] !== vDefault)
                serOptionState.push(`${k.toLowerCase()}=${UrlUtil.mini.compress(this._state[k])}`);
        }
        );
        if (serOptionState.length) {
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serOptionState));
        }

        return out.length ? out : null;
    }

    getFilterTagPart() {
        const areNotDefaultState = this._getStateNotDefault();
        if (!areNotDefaultState.length)
            return null;

        const pt = areNotDefaultState.map(([k,v])=>`${v ? "" : "!"}${k}`).join(";").toLowerCase();

        return `${this.header.toLowerCase()}=::${pt}::`;
    }

    getDisplayStatePart({nxtState=null}={}) {
        return null;
    }

    getNextStateFromSubhashState(state) {
        const nxtState = this._getNextState_base();

        if (state == null) {
            this._mutNextState_reset(nxtState);
            return nxtState;
        }

        this._mutNextState_meta_fromSubHashState(nxtState, state);

        let hasState = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            if (prop !== "state")
                return;

            hasState = true;
            vals.forEach(v=>{
                const [prop,valCompressed] = v.split("=");
                const val = UrlUtil.mini.decompress(valCompressed);

                const casedProp = Object.keys(this._defaultState).find(k=>k.toLowerCase() === prop);
                if (!casedProp)
                    return;

                if (this._defaultState[casedProp] != null && typeof val === typeof this._defaultState[casedProp])
                    nxtState[this.header].state[casedProp] = val;
            }
            );
        }
        );

        if (!hasState)
            this._mutNextState_reset(nxtState);

        return nxtState;
    }

    setFromValues(values) {
        if (!values[this.header])
            return;
        const vals = values[this.header];
        Object.entries(vals).forEach(([k,v])=>{
            if (this._defaultState[k] && typeof this._defaultState[k] === typeof v)
                this._state[k] = v;
        }
        );
    }

    setValue(k, v) {
        this._state[k] = v;
    }

    $render(opts) {
        this._filterBox = opts.filterBox;
        this.__$wrpMini = opts.$wrpMini;

        const $wrpControls = opts.isMulti ? null : this._$getHeaderControls();

        const $btns = Object.keys(this._defaultState).map(k=>this._$render_$getPill(k));
        const $wrpButtons = $$`<div>${$btns}</div>`;

        if (opts.isMulti) {
            return this.__$wrpFilter = $$`<div class="ve-flex">
				<div class="fltr__range-inline-label mr-2">${this._getRenderedHeader()}</div>
				${$wrpButtons}
			</div>`;
        } else {
            return this.__$wrpFilter = $$`<div class="ve-flex-col">
				${opts.isFirst ? "" : `<div class="fltr__dropdown-divider mb-1"></div>`}
				<div class="split fltr__h ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
					<div class="fltr__h-text ve-flex-h-center">${this._getRenderedHeader()}</div>
					${$wrpControls}
				</div>
				${$wrpButtons}
			</div>`;
        }
    }

    $renderMinis(opts) {
        if (!opts.$wrpMini)
            return;

        this._filterBox = opts.filterBox;
        this.__$wrpMini = opts.$wrpMini;

        const $btnsMini = Object.keys(this._defaultState).map(k=>this._$render_$getMiniPill(k));
        $btnsMini.forEach($btn=>$btn.appendTo(this.__$wrpMini));
    }

    _$render_$getPill(key) {
        const displayText = this._displayFn(key);

        const $btnPill = $(`<div class="fltr__pill">${displayText}</div>`).click(()=>{
            this._state[key] = !this._state[key];
        }
        ).contextmenu((evt)=>{
            evt.preventDefault();
            this._state[key] = !this._state[key];
        }
        );
        const hook = ()=>{
            const val = FilterBox._PILL_STATES[this._state[key] ? 1 : 2];
            $btnPill.attr("state", val);
        }
        ;
        this._addHook("state", key, hook);
        hook();

        return $btnPill;
    }

    _$render_$getMiniPill(key) {
        const displayTextFull = this._displayFnMini ? this._displayFn(key) : null;
        const displayText = this._displayFnMini ? this._displayFnMini(key) : this._displayFn(key);

        const $btnMini = $(`<div class="fltr__mini-pill ${this._filterBox.isMinisHidden(this.header) ? "ve-hidden" : ""}" state="${FilterBox._PILL_STATES[this._defaultState[key] === this._state[key] ? 0 : this._state[key] ? 1 : 2]}">${displayText}</div>`).title(`${displayTextFull ? `${displayTextFull} (` : ""}Filter: ${this.header}${displayTextFull ? ")" : ""}`).click(()=>{
            this._state[key] = this._defaultState[key];
            this._filterBox.fireChangeEvent();
        }
        );

        const hook = ()=>$btnMini.attr("state", FilterBox._PILL_STATES[this._defaultState[key] === this._state[key] ? 0 : this._state[key] ? 1 : 2]);
        this._addHook("state", key, hook);

        const hideHook = ()=>$btnMini.toggleClass("ve-hidden", this._filterBox.isMinisHidden(this.header));
        this._filterBox.registerMinisHiddenHook(this.header, hideHook);

        return $btnMini;
    }

    _$getHeaderControls() {
        const $btnReset = $(`<button class="btn btn-default btn-xs">Reset</button>`).click(()=>this.reset());
        const $wrpBtns = $$`<div class="ve-flex-v-center">${$btnReset}</div>`;

        const $wrpSummary = $(`<div class="ve-flex-v-center fltr__summary_item fltr__summary_item--include"></div>`).hideVe();

        const $btnShowHide = $(`<button class="btn btn-default btn-xs ml-2 ${this._meta.isHidden ? "active" : ""}">Hide</button>`).click(()=>this._meta.isHidden = !this._meta.isHidden);
        const hkIsHidden = ()=>{
            $btnShowHide.toggleClass("active", this._meta.isHidden);
            $wrpBtns.toggleVe(!this._meta.isHidden);
            $wrpSummary.toggleVe(this._meta.isHidden);

            const cntNonDefault = Object.entries(this._defaultState).filter(([k,v])=>this._state[k] != null && this._state[k] !== v).length;

            $wrpSummary.title(`${cntNonDefault} non-default option${cntNonDefault === 1 ? "" : "s"} selected`).text(cntNonDefault);
        }
        ;
        this._addHook("meta", "isHidden", hkIsHidden);
        hkIsHidden();

        return $$`
		<div class="ve-flex-v-center">
			${$wrpBtns}
			${$wrpSummary}
			${$btnShowHide}
		</div>`;
    }

    getValues({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        const out = Object.entries(this._defaultState).mergeMap(([k,v])=>({
            [k]: state[k] == null ? v : state[k]
        }));
        out._isActive = Object.entries(this._defaultState).some(([k,v])=>state[k] != null && state[k] !== v);
        return {
            [this.header]: out,
        };
    }

    _mutNextState_reset(nxtState, {isResetAll=false}={}) {
        if (isResetAll)
            this._mutNextState_resetBase(nxtState, {
                isResetAll
            });
        Object.assign(nxtState[this.header].state, MiscUtil.copy(this._defaultState));
    }

    update() {}

    toDisplay(boxState, entryVal) {
        const filterState = boxState[this.header];
        if (!filterState)
            return true;
        if (entryVal == null)
            return true;
        return Object.entries(entryVal).every(([k,v])=>this._state[k] === v);
    }

    getDefaultMeta() {
        return {
            ...super.getDefaultMeta(),
            ...OptionsFilter._DEFAULT_META,
        };
    }

    handleSearch(searchTerm) {
        if (this.__$wrpFilter == null)
            return;

        const isVisible = this.header.toLowerCase().includes(searchTerm) || Object.keys(this._defaultState).map(it=>this._displayFn(it).toLowerCase()).some(it=>it.includes(searchTerm));

        this.__$wrpFilter.toggleClass("fltr__hidden--search", !isVisible);

        return isVisible;
    }
}
;
OptionsFilter._DEFAULT_META = {};
//#endregion
//#region AbilityScoreFilter
let AbilityScoreFilter = class AbilityScoreFilter extends FilterBase {
    static _MODIFIER_SORT_OFFSET = 10000;
    constructor(opts) {
        super(opts);

        this._items = [];
        this._isItemsDirty = false;
        this._itemsLookup = {};
        this._seenUids = {};

        this.__$wrpFilter = null;
        this.__wrpPills = null;
        this.__wrpPillsRows = {};
        this.__wrpMiniPills = null;

        this._maxMod = 2;
        this._minMod = 0;

        Parser.ABIL_ABVS.forEach(ab=>{
            const itemAnyIncrease = new AbilityScoreFilter.FilterItem({
                isAnyIncrease: true,
                ability: ab
            });
            const itemAnyDecrease = new AbilityScoreFilter.FilterItem({
                isAnyDecrease: true,
                ability: ab
            });
            this._items.push(itemAnyIncrease, itemAnyDecrease);
            this._itemsLookup[itemAnyIncrease.uid] = itemAnyIncrease;
            this._itemsLookup[itemAnyDecrease.uid] = itemAnyDecrease;
            if (this.__state[itemAnyIncrease.uid] == null)
                this.__state[itemAnyIncrease.uid] = 0;
            if (this.__state[itemAnyDecrease.uid] == null)
                this.__state[itemAnyDecrease.uid] = 0;
        }
        );

        for (let i = this._minMod; i <= this._maxMod; ++i) {
            if (i === 0)
                continue;
            Parser.ABIL_ABVS.forEach(ab=>{
                const item = new AbilityScoreFilter.FilterItem({
                    modifier: i,
                    ability: ab
                });
                this._items.push(item);
                this._itemsLookup[item.uid] = item;
                if (this.__state[item.uid] == null)
                    this.__state[item.uid] = 0;
            }
            );
        }
    }

    $render(opts) {
        this._filterBox = opts.filterBox;
        this.__wrpMiniPills = e_({
            ele: opts.$wrpMini[0]
        });

        const wrpControls = this._getHeaderControls(opts);

        this.__wrpPills = e_({
            tag: "div",
            clazz: `fltr__wrp-pills overflow-x-auto ve-flex-col w-100`
        });
        const hook = ()=>this.__wrpPills.toggleVe(!this._meta.isHidden);
        this._addHook("meta", "isHidden", hook);
        hook();

        this._doRenderPills();

        const btnMobToggleControls = Filter.prototype._getBtnMobToggleControls.bind(this)(wrpControls);

        this.__$wrpFilter = $$`<div>
			${opts.isFirst ? "" : `<div class="fltr__dropdown-divider ${opts.isMulti ? "fltr__dropdown-divider--indented" : ""} mb-1"></div>`}
			<div class="split fltr__h mb-1">
				<div class="ml-2 fltr__h-text ve-flex-h-center">${opts.isMulti ? `<span class="mr-2">\u2012</span>` : ""}${this._getRenderedHeader()}${btnMobToggleControls}</div>
				${wrpControls}
			</div>
			${this.__wrpPills}
		</div>`;

        this.update();
        return this.__$wrpFilter;
    }

    _getHeaderControls(opts) {
        const btnClear = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--clear w-100`,
            click: ()=>this._doSetPillsClear(),
            html: "Clear",
        });

        const wrpStateBtnsOuter = e_({
            tag: "div",
            clazz: "ve-flex-v-center fltr__h-wrp-state-btns-outer",
            children: [e_({
                tag: "div",
                clazz: "btn-group ve-flex-v-center w-100",
                children: [btnClear, ],
            }), ],
        });

        const wrpSummary = e_({
            tag: "div",
            clazz: "ve-flex-vh-center ve-hidden"
        });

        const btnShowHide = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} ml-2`,
            click: ()=>this._meta.isHidden = !this._meta.isHidden,
            html: "Hide",
        });
        const hookShowHide = ()=>{
            e_({
                ele: btnShowHide
            }).toggleClass("active", this._meta.isHidden);
            wrpStateBtnsOuter.toggleVe(!this._meta.isHidden);

            const cur = this.getValues()[this.header];

            const htmlSummary = [cur._totals?.yes ? `<span class="fltr__summary_item fltr__summary_item--include" title="${cur._totals.yes} hidden &quot;required&quot; tags">${cur._totals.yes}</span>` : null, ].filter(Boolean).join("");
            e_({
                ele: wrpSummary,
                html: htmlSummary
            }).toggleVe(this._meta.isHidden);
        }
        ;
        this._addHook("meta", "isHidden", hookShowHide);
        hookShowHide();

        return e_({
            tag: "div",
            clazz: `ve-flex-v-center fltr__h-wrp-btns-outer`,
            children: [wrpSummary, wrpStateBtnsOuter, btnShowHide, ],
        });
    }

    _doRenderPills() {
        this._items.sort(this.constructor._ascSortItems.bind(this.constructor));

        if (!this.__wrpPills)
            return;
        this._items.forEach(it=>{
            if (!it.rendered)
                it.rendered = this._getPill(it);
            if (!it.isAnyIncrease && !it.isAnyDecrease)
                it.rendered.toggleClass("fltr__pill--muted", !this._seenUids[it.uid]);

            if (!this.__wrpPillsRows[it.ability]) {
                this.__wrpPillsRows[it.ability] = {
                    row: e_({
                        tag: "div",
                        clazz: "ve-flex-v-center w-100 my-1",
                        children: [e_({
                            tag: "div",
                            clazz: "mr-3 text-right fltr__label-ability-score no-shrink no-grow",
                            text: Parser.attAbvToFull(it.ability),
                        }), ],
                    }).appendTo(this.__wrpPills),
                    searchText: Parser.attAbvToFull(it.ability).toLowerCase(),
                };
            }

            it.rendered.appendTo(this.__wrpPillsRows[it.ability].row);
        }
        );
    }

    _getPill(item) {
        const unsetRow = ()=>{
            const nxtState = {};
            for (let i = this._minMod; i <= this._maxMod; ++i) {
                if (!i || i === item.modifier)
                    continue;
                const siblingUid = AbilityScoreFilter.FilterItem.getUid_({
                    ability: item.ability,
                    modifier: i
                });
                nxtState[siblingUid] = 0;
            }

            if (!item.isAnyIncrease)
                nxtState[AbilityScoreFilter.FilterItem.getUid_({
                    ability: item.ability,
                    isAnyIncrease: true
                })] = 0;
            if (!item.isAnyDecrease)
                nxtState[AbilityScoreFilter.FilterItem.getUid_({
                    ability: item.ability,
                    isAnyDecrease: true
                })] = 0;

            this._proxyAssignSimple("state", nxtState);
        }
        ;

        const btnPill = e_({
            tag: "div",
            clazz: `fltr__pill fltr__pill--ability-bonus px-2`,
            html: item.getPillDisplayHtml(),
            click: evt=>{
                if (evt.shiftKey) {
                    const nxtState = {};
                    Object.keys(this._state).forEach(k=>nxtState[k] = 0);
                    this._proxyAssign("state", "_state", "__state", nxtState, true);
                }

                this._state[item.uid] = this._state[item.uid] ? 0 : 1;
                if (this._state[item.uid])
                    unsetRow();
            }
            ,
            contextmenu: (evt)=>{
                evt.preventDefault();

                this._state[item.uid] = this._state[item.uid] ? 0 : 1;
                if (this._state[item.uid])
                    unsetRow();
            }
            ,
        });

        const hook = ()=>{
            const val = FilterBox._PILL_STATES[this._state[item.uid] || 0];
            btnPill.attr("state", val);
        }
        ;
        this._addHook("state", item.uid, hook);
        hook();

        return btnPill;
    }

    _doRenderMiniPills() {
        this._items.slice(0).sort(this.constructor._ascSortMiniPills.bind(this.constructor)).forEach(it=>{
            (it.btnMini = it.btnMini || this._getBtnMini(it)).appendTo(this.__wrpMiniPills);
        }
        );
    }

    _getBtnMini(item) {
        const btnMini = e_({
            tag: "div",
            clazz: `fltr__mini-pill ${this._filterBox.isMinisHidden(this.header) ? "ve-hidden" : ""}`,
            text: item.getMiniPillDisplayText(),
            title: `Filter: ${this.header}`,
            click: ()=>{
                this._state[item.uid] = 0;
                this._filterBox.fireChangeEvent();
            }
            ,
        }).attr("state", FilterBox._PILL_STATES[this._state[item.uid] || 0]);

        const hook = ()=>btnMini.attr("state", FilterBox._PILL_STATES[this._state[item.uid] || 0]);
        this._addHook("state", item.uid, hook);

        const hideHook = ()=>btnMini.toggleClass("ve-hidden", this._filterBox.isMinisHidden(this.header));
        this._filterBox.registerMinisHiddenHook(this.header, hideHook);

        return btnMini;
    }

    static _ascSortItems(a, b) {
        return SortUtil.ascSort(Number(b.isAnyIncrease), Number(a.isAnyIncrease)) || SortUtil.ascSortAtts(a.ability, b.ability) || SortUtil.ascSort(b.modifier ? b.modifier + AbilityScoreFilter._MODIFIER_SORT_OFFSET : b.modifier, a.modifier ? a.modifier + AbilityScoreFilter._MODIFIER_SORT_OFFSET : a.modifier) || SortUtil.ascSort(Number(b.isAnyDecrease), Number(a.isAnyDecrease));
    }

    static _ascSortMiniPills(a, b) {
        return SortUtil.ascSort(Number(b.isAnyIncrease), Number(a.isAnyIncrease)) || SortUtil.ascSort(Number(b.isAnyDecrease), Number(a.isAnyDecrease)) || SortUtil.ascSort(b.modifier ? b.modifier + AbilityScoreFilter._MODIFIER_SORT_OFFSET : b.modifier, a.modifier ? a.modifier + AbilityScoreFilter._MODIFIER_SORT_OFFSET : a.modifier) || SortUtil.ascSortAtts(a.ability, b.ability);
    }

    $renderMinis(opts) {
        this._filterBox = opts.filterBox;
        this.__wrpMiniPills = e_({
            ele: opts.$wrpMini[0]
        });

        this._doRenderMiniPills();
    }

    getValues({nxtState=null}={}) {
        const out = {
            _totals: {
                yes: 0
            },
        };

        const state = nxtState?.[this.header]?.state || this.__state;

        Object.entries(state).filter(([,value])=>value).forEach(([uid])=>{
            out._totals.yes++;
            out[uid] = true;
        }
        );

        return {
            [this.header]: out
        };
    }

    _mutNextState_reset(nxtState, {isResetAll=false}={}) {
        Object.keys(nxtState[this.header].state).forEach(k=>delete nxtState[this.header].state[k]);
    }

    update() {
        if (this._isItemsDirty) {
            this._isItemsDirty = false;

            this._doRenderPills();
        }

        this._doRenderMiniPills();
    }

    _doSetPillsClear() {
        Object.keys(this._state).forEach(k=>{
            if (this._state[k] !== 0)
                this._state[k] = 0;
        }
        );
    }

    toDisplay(boxState, entryVal) {
        const filterState = boxState[this.header];
        if (!filterState)
            return true;

        const activeItems = Object.keys(filterState).filter(it=>!it.startsWith("_")).map(it=>this._itemsLookup[it]).filter(Boolean);

        if (!activeItems.length)
            return true;
        if ((!entryVal || !entryVal.length) && activeItems.length)
            return false;

        return entryVal.some(abilObject=>{
            const cpyAbilObject = MiscUtil.copy(abilObject);
            const vewActiveItems = [...activeItems];

            Parser.ABIL_ABVS.forEach(ab=>{
                if (!cpyAbilObject[ab] || !vewActiveItems.length)
                    return;

                const ixExact = vewActiveItems.findIndex(it=>it.ability === ab && it.modifier === cpyAbilObject[ab]);
                if (~ixExact)
                    return vewActiveItems.splice(ixExact, 1);
            }
            );
            if (!vewActiveItems.length)
                return true;

            if (cpyAbilObject.choose?.from) {
                const amount = cpyAbilObject.choose.amount || 1;
                const count = cpyAbilObject.choose.count || 1;

                for (let i = 0; i < count; ++i) {
                    if (!vewActiveItems.length)
                        break;

                    const ix = vewActiveItems.findIndex(it=>cpyAbilObject.choose.from.includes(it.ability) && amount === it.modifier);
                    if (~ix) {
                        const [cpyActiveItem] = vewActiveItems.splice(ix, 1);
                        cpyAbilObject.choose.from = cpyAbilObject.choose.from.filter(it=>it !== cpyActiveItem.ability);
                    }
                }
            } else if (cpyAbilObject.choose?.weighted?.weights && cpyAbilObject.choose?.weighted?.from) {
                cpyAbilObject.choose.weighted.weights.forEach(weight=>{
                    const ix = vewActiveItems.findIndex(it=>cpyAbilObject.choose.weighted.from.includes(it.ability) && weight === it.modifier);
                    if (~ix) {
                        const [cpyActiveItem] = vewActiveItems.splice(ix, 1);
                        cpyAbilObject.choose.weighted.from = cpyAbilObject.choose.weighted.from.filter(it=>it !== cpyActiveItem.ability);
                    }
                }
                );
            }
            if (!vewActiveItems.length)
                return true;

            Parser.ABIL_ABVS.forEach(ab=>{
                if (!cpyAbilObject[ab] || !vewActiveItems.length)
                    return;

                const ix = vewActiveItems.findIndex(it=>it.ability === ab && ((cpyAbilObject[ab] > 0 && it.isAnyIncrease) || (cpyAbilObject[ab] < 0 && it.isAnyDecrease)));
                if (~ix)
                    return vewActiveItems.splice(ix, 1);
            }
            );
            if (!vewActiveItems.length)
                return true;

            if (cpyAbilObject.choose?.from) {
                const amount = cpyAbilObject.choose.amount || 1;
                const count = cpyAbilObject.choose.count || 1;

                for (let i = 0; i < count; ++i) {
                    if (!vewActiveItems.length)
                        return true;

                    const ix = vewActiveItems.findIndex(it=>cpyAbilObject.choose.from.includes(it.ability) && ((amount > 0 && it.isAnyIncrease) || (amount < 0 && it.isAnyDecrease)));
                    if (~ix) {
                        const [cpyActiveItem] = vewActiveItems.splice(ix, 1);
                        cpyAbilObject.choose.from = cpyAbilObject.choose.from.filter(it=>it !== cpyActiveItem.ability);
                    }
                }
            } else if (cpyAbilObject.choose?.weighted?.weights && cpyAbilObject.choose?.weighted?.from) {
                cpyAbilObject.choose.weighted.weights.forEach(weight=>{
                    if (!vewActiveItems.length)
                        return;

                    const ix = vewActiveItems.findIndex(it=>cpyAbilObject.choose.weighted.from.includes(it.ability) && ((weight > 0 && it.isAnyIncrease) || (weight < 0 && it.isAnyDecrease)));
                    if (~ix) {
                        const [cpyActiveItem] = vewActiveItems.splice(ix, 1);
                        cpyAbilObject.choose.weighted.from = cpyAbilObject.choose.weighted.from.filter(it=>it !== cpyActiveItem.ability);
                    }
                }
                );
            }
            return !vewActiveItems.length;
        }
        );
    }

    addItem(abilArr) {
        if (!abilArr?.length)
            return;

        let nxtMaxMod = this._maxMod;
        let nxtMinMod = this._minMod;

        abilArr.forEach(abilObject=>{
            Parser.ABIL_ABVS.forEach(ab=>{
                if (abilObject[ab] != null) {
                    nxtMaxMod = Math.max(nxtMaxMod, abilObject[ab]);
                    nxtMinMod = Math.min(nxtMinMod, abilObject[ab]);

                    const uid = AbilityScoreFilter.FilterItem.getUid_({
                        ability: ab,
                        modifier: abilObject[ab]
                    });
                    if (!this._seenUids[uid])
                        this._isItemsDirty = true;
                    this._seenUids[uid] = true;
                }
            }
            );

            if (abilObject.choose?.from) {
                const amount = abilObject.choose.amount || 1;
                nxtMaxMod = Math.max(nxtMaxMod, amount);
                nxtMinMod = Math.min(nxtMinMod, amount);

                abilObject.choose.from.forEach(ab=>{
                    const uid = AbilityScoreFilter.FilterItem.getUid_({
                        ability: ab,
                        modifier: amount
                    });
                    if (!this._seenUids[uid])
                        this._isItemsDirty = true;
                    this._seenUids[uid] = true;
                }
                );
            }

            if (abilObject.choose?.weighted?.weights) {
                nxtMaxMod = Math.max(nxtMaxMod, ...abilObject.choose.weighted.weights);
                nxtMinMod = Math.min(nxtMinMod, ...abilObject.choose.weighted.weights);

                abilObject.choose.weighted.from.forEach(ab=>{
                    abilObject.choose.weighted.weights.forEach(weight=>{
                        const uid = AbilityScoreFilter.FilterItem.getUid_({
                            ability: ab,
                            modifier: weight
                        });
                        if (!this._seenUids[uid])
                            this._isItemsDirty = true;
                        this._seenUids[uid] = true;
                    }
                    );
                }
                );
            }
        }
        );

        if (nxtMaxMod > this._maxMod) {
            for (let i = this._maxMod + 1; i <= nxtMaxMod; ++i) {
                if (i === 0)
                    continue;
                Parser.ABIL_ABVS.forEach(ab=>{
                    const item = new AbilityScoreFilter.FilterItem({
                        modifier: i,
                        ability: ab
                    });
                    this._items.push(item);
                    this._itemsLookup[item.uid] = item;
                    if (this.__state[item.uid] == null)
                        this.__state[item.uid] = 0;
                }
                );
            }

            this._isItemsDirty = true;
            this._maxMod = nxtMaxMod;
        }

        if (nxtMinMod < this._minMod) {
            for (let i = nxtMinMod; i < this._minMod; ++i) {
                if (i === 0)
                    continue;
                Parser.ABIL_ABVS.forEach(ab=>{
                    const item = new AbilityScoreFilter.FilterItem({
                        modifier: i,
                        ability: ab
                    });
                    this._items.push(item);
                    this._itemsLookup[item.uid] = item;
                    if (this.__state[item.uid] == null)
                        this.__state[item.uid] = 0;
                }
                );
            }

            this._isItemsDirty = true;
            this._minMod = nxtMinMod;
        }
    }

    getSaveableState() {
        return {
            [this.header]: {
                ...this.getBaseSaveableState(),
                state: {
                    ...this.__state
                },
            },
        };
    }

    setStateFromLoaded(filterState, {isUserSavedState=false}={}) {
        if (!filterState?.[this.header])
            return;

        const toLoad = filterState[this.header];
        this._hasUserSavedState = this._hasUserSavedState || isUserSavedState;
        this.setBaseStateFromLoaded(toLoad);
        Object.assign(this._state, toLoad.state);
    }

    getSubHashes() {
        const out = [];

        const baseMeta = this.getMetaSubHashes();
        if (baseMeta)
            out.push(...baseMeta);

        const areNotDefaultState = Object.entries(this._state).filter(([k,v])=>{
            if (k.startsWith("_"))
                return false;
            return !!v;
        }
        );
        if (areNotDefaultState.length) {
            const serPillStates = areNotDefaultState.map(([k,v])=>`${k.toUrlified()}=${v}`);
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serPillStates));
        }

        if (!out.length)
            return null;

        return out;
    }

    getNextStateFromSubhashState(state) {
        const nxtState = this._getNextState_base();

        if (state == null) {
            this._mutNextState_reset(nxtState);
            return nxtState;
        }

        let hasState = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            switch (prop) {
            case "state":
                {
                    hasState = true;
                    Object.keys(nxtState[this.header].state).forEach(k=>nxtState[this.header].state[k] = 0);

                    vals.forEach(v=>{
                        const [statePropLower,state] = v.split("=");
                        const stateProp = Object.keys(nxtState[this.header].state).find(k=>k.toLowerCase() === statePropLower);
                        if (stateProp)
                            nxtState[this.header].state[stateProp] = Number(state) ? 1 : 0;
                    }
                    );
                    break;
                }
            }
        }
        );

        if (!hasState)
            this._mutNextState_reset(nxtState);

        return nxtState;
    }

    setFromValues(values) {
        if (!values[this.header])
            return;
        const nxtState = {};
        Object.keys(this._state).forEach(k=>nxtState[k] = 0);
        Object.assign(nxtState, values[this.header]);
    }

    handleSearch(searchTerm) {
        const isHeaderMatch = this.header.toLowerCase().includes(searchTerm);

        if (isHeaderMatch) {
            Object.values(this.__wrpPillsRows).forEach(meta=>meta.row.removeClass("fltr__hidden--search"));

            if (this.__$wrpFilter)
                this.__$wrpFilter.toggleClass("fltr__hidden--search", false);

            return true;
        }

        const isModNumber = /^[-+]\d*$/.test(searchTerm);

        let visibleCount = 0;
        Object.values(this.__wrpPillsRows).forEach(({row, searchText})=>{
            const isVisible = isModNumber || searchText.includes(searchTerm);
            row.toggleClass("fltr__hidden--search", !isVisible);
            if (isVisible)
                visibleCount++;
        }
        );

        if (this.__$wrpFilter)
            this.__$wrpFilter.toggleClass("fltr__hidden--search", visibleCount === 0);

        return visibleCount !== 0;
    }

    _doTeardown() {
        this._items.forEach(it=>{
            if (it.rendered)
                it.rendered.detach();
            if (it.btnMini)
                it.btnMini.detach();
        }
        );

        Object.values(this.__wrpPillsRows).forEach(meta=>meta.row.detach());
    }

    _getStateNotDefault() {
        return Object.entries(this._state).filter(([,v])=>!!v);
    }

    getFilterTagPart() {
        const areNotDefaultState = this._getStateNotDefault();
        const compressedMeta = this._getCompressedMeta({
            isStripUiKeys: true
        });

        if (!areNotDefaultState.length && !compressedMeta)
            return null;

        const pt = Object.entries(this._state).filter(([,v])=>!!v).map(([k,v])=>`${v === 2 ? "!" : ""}${k}`).join(";").toLowerCase();

        return [this.header.toLowerCase(), pt, compressedMeta ? compressedMeta.join(HASH_SUB_LIST_SEP) : null, ].filter(it=>it != null).join("=");
    }

    getDisplayStatePart({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        const areNotDefaultState = this._getStateNotDefault({
            nxtState
        });

        if (!areNotDefaultState.length)
            return null;

        const ptState = Object.entries(state).filter(([,v])=>!!v).map(([k,v])=>{
            const item = this._items.find(item=>item.uid === k);
            if (!item)
                return null;
            return `${v === 2 ? "not " : ""}${item.getMiniPillDisplayText()}`;
        }
        ).join(", ");

        return `${this.header}: ${ptState}`;
    }
};
globalThis.AbilityScoreFilter = AbilityScoreFilter;
AbilityScoreFilter.FilterItem = class {
    static getUid_({ability=null, isAnyIncrease=false, isAnyDecrease=false, modifier=null}) {
        return `${Parser.attAbvToFull(ability)} ${modifier != null ? UiUtil.intToBonus(modifier) : (isAnyIncrease ? `+any` : isAnyDecrease ? `-any` : "?")}`;
    }

    constructor({isAnyIncrease=false, isAnyDecrease=false, modifier=null, ability=null}) {
        if (isAnyIncrease && isAnyDecrease)
            throw new Error(`Invalid arguments!`);
        if ((isAnyIncrease || isAnyDecrease) && modifier != null)
            throw new Error(`Invalid arguments!`);

        this._ability = ability;
        this._modifier = modifier;
        this._isAnyIncrease = isAnyIncrease;
        this._isAnyDecrease = isAnyDecrease;
        this._uid = AbilityScoreFilter.FilterItem.getUid_({
            isAnyIncrease: this._isAnyIncrease,
            isAnyDecrease: this._isAnyDecrease,
            modifier: this._modifier,
            ability: this._ability,
        });
    }

    get ability() {
        return this._ability;
    }
    get modifier() {
        return this._modifier;
    }
    get isAnyIncrease() {
        return this._isAnyIncrease;
    }
    get isAnyDecrease() {
        return this._isAnyDecrease;
    }
    get uid() {
        return this._uid;
    }

    getMiniPillDisplayText() {
        if (this._isAnyIncrease)
            return `+Any ${Parser.attAbvToFull(this._ability)}`;
        if (this._isAnyDecrease)
            return `\u2012Any ${Parser.attAbvToFull(this._ability)}`;
        return `${UiUtil.intToBonus(this._modifier, {
            isPretty: true
        })} ${Parser.attAbvToFull(this._ability)}`;
    }

    getPillDisplayHtml() {
        if (this._isAnyIncrease)
            return `+Any`;
        if (this._isAnyDecrease)
            return `\u2012Any`;
        return UiUtil.intToBonus(this._modifier, {
            isPretty: true
        });
    }
};
//#endregion

//#region PageFilters
class PageFilter {
    
    constructor(opts) {
        opts = opts || {};
        this._sourceFilter = new SourceFilter(opts.sourceFilterOpts);
        this._filterBox = null;
    }

    get filterBox() { return this._filterBox; }
    get sourceFilter() { return this._sourceFilter; }

    mutateAndAddToFilters(entity, isExcluded, opts) {
        this.constructor.mutateForFilters(entity, opts);
        this.addToFilters(entity, isExcluded, opts);
    }

    static mutateForFilters(entity, opts) {
        throw new Error("Unimplemented!");
    }
    addToFilters(entity, isExcluded, opts) {
        throw new Error("Unimplemented!");
    }
    toDisplay(values, entity) {
        throw new Error("Unimplemented!");
    }
    async _pPopulateBoxOptions() {
        throw new Error("Unimplemented!");
    }

    async pInitFilterBox(opts) {
        opts = opts || {};
        await this._pPopulateBoxOptions(opts);
        this._filterBox = new FilterBox(opts);
        await this._filterBox.pDoLoadState();
        return this._filterBox;
    }

    trimState() {
        return this._filterBox.trimState_();
    }

    static _getClassFilterItem({className, classSource, isVariantClass, definedInSource}) {
        const nm = className.split("(")[0].trim();
        const variantSuffix = isVariantClass ? ` [${definedInSource ? Parser.sourceJsonToAbv(definedInSource) : "Unknown"}]` : "";
        const sourceSuffix = (SourceUtil.isNonstandardSource(classSource || Parser.SRC_PHB) || (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(classSource || Parser.SRC_PHB)) || (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(classSource || Parser.SRC_PHB))) ? ` (${Parser.sourceJsonToAbv(classSource)})` : "";
        const name = `${nm}${variantSuffix}${sourceSuffix}`;

        const opts = {
            item: name,
            userData: {
                group: SourceUtil.getFilterGroup(classSource || Parser.SRC_PHB),
            },
        };

        if (isVariantClass) {
            opts.nest = definedInSource ? Parser.sourceJsonToFull(definedInSource) : "Unknown";
            opts.userData.equivalentClassName = `${nm}${sourceSuffix}`;
            opts.userData.definedInSource = definedInSource;
        }

        return new FilterItem$1(opts);
    }

    static _getSubclassFilterItem({className, classSource, subclassShortName, subclassName, subclassSource, subSubclassName, isVariantClass, definedInSource}) {
        const group = SourceUtil.isSubclassReprinted(className, classSource, subclassShortName, subclassSource) || Parser.sourceJsonToFull(subclassSource).startsWith(Parser.UA_PREFIX) || Parser.sourceJsonToFull(subclassSource).startsWith(Parser.PS_PREFIX);

        const classFilterItem = this._getClassFilterItem({
            className: subclassShortName || subclassName,
            classSource: subclassSource,
        });

        return new FilterItem$1({
            item: `${className}: ${classFilterItem.item}${subSubclassName ? `, ${subSubclassName}` : ""}`,
            nest: className,
            userData: {
                group,
            },
        });
    }

    static _isReprinted({reprintedAs, tag, page, prop}) {
        return reprintedAs?.length && reprintedAs.some(it=>{
            const {name, source} = DataUtil.generic.unpackUid(it?.uid ?? it, tag);
            const hash = UrlUtil.URL_TO_HASH_BUILDER[page]({
                name,
                source
            });
            return !ExcludeUtil.isExcluded(hash, prop, source, {
                isNoCount: true
            });
        }
        );
    }

    static getListAliases(ent) {
        return (ent.alias || []).map(it=>`"${it}"`).join(",");
    }

    static defaultSourceSelFn(val) {
        return SourceUtil.getFilterGroup(val) === SourceUtil.FILTER_GROUP_STANDARD;
    }
};

//#region PageFilterClasses
class PageFilterClassesBase extends PageFilter {
    constructor() {
        super();

        this._miscFilter = new Filter({
            header: "Miscellaneous",
            items: ["Reprinted", "Sidekick", "SRD", "Basic Rules"],
            deselFn: (it)=>{
                return it === "Reprinted" || it === "Sidekick";
            }
            ,
            displayFnMini: it=>it === "Reprinted" ? "Repr." : it,
            displayFnTitle: it=>it === "Reprinted" ? it : "",
            isMiscFilter: true,
        });

        this._optionsFilter = new OptionsFilter({
            header: "Other/Text Options",
            defaultState: {
                isDisplayClassIfSubclassActive: false,
                isClassFeatureVariant: true,
            },
            displayFn: k=>{
                switch (k) {
                case "isClassFeatureVariant":
                    return "Class Feature Options/Variants";
                case "isDisplayClassIfSubclassActive":
                    return "Display Class if Any Subclass is Visible";
                default:
                    throw new Error(`Unhandled key "${k}"`);
                }
            }
            ,
            displayFnMini: k=>{
                switch (k) {
                case "isClassFeatureVariant":
                    return "C.F.O/V.";
                case "isDisplayClassIfSubclassActive":
                    return "Sc>C";
                default:
                    throw new Error(`Unhandled key "${k}"`);
                }
            }
            ,
        });
    }

    get optionsFilter() {
        return this._optionsFilter;
    }

    static mutateForFilters(cls) {
        cls.source = cls.source || Parser.SRC_PHB;
        cls.subclasses = cls.subclasses || [];

        cls._fSources = SourceFilter.getCompleteFilterSources(cls);

        cls._fSourceSubclass = [...new Set([cls.source, ...cls.subclasses.map(it=>[it.source, ...(it.otherSources || []).map(it=>it.source)]).flat(), ]), ];

        cls._fMisc = [];
        if (cls.isReprinted)
            cls._fMisc.push("Reprinted");
        if (cls.srd)
            cls._fMisc.push("SRD");
        if (cls.basicRules)
            cls._fMisc.push("Basic Rules");
        if (cls.isSidekick)
            cls._fMisc.push("Sidekick");

        cls.subclasses.forEach(sc=>{
            sc.source = sc.source || cls.source;
            sc.shortName = sc.shortName || sc.name;
            sc._fMisc = [];
            if (sc.srd)
                sc._fMisc.push("SRD");
            if (sc.basicRules)
                sc._fMisc.push("Basic Rules");
            if (sc.isReprinted)
                sc._fMisc.push("Reprinted");
        }
        );
    }

    _addEntrySourcesToFilter(entry) {
        this._addEntrySourcesToFilter_walk(entry);
    }

    _addEntrySourcesToFilter_walk = (obj)=>{
        if ((typeof obj !== "object") || obj == null)
            return;

        if (obj instanceof Array)
            return obj.forEach(this._addEntrySourcesToFilter_walk.bind(this));

        if (obj.source)
            this._sourceFilter.addItem(obj.source);
        if (obj.entries)
            this._addEntrySourcesToFilter_walk(obj.entries);
    }
    ;

    addToFilters(cls, isExcluded, opts) {
        if (isExcluded)
            return;
        opts = opts || {};
        const subclassExclusions = opts.subclassExclusions || {};

        this._sourceFilter.addItem(cls.source);

        if (cls.fluff)
            cls.fluff.forEach(it=>this._addEntrySourcesToFilter(it));
        cls.classFeatures.forEach(lvlFeatures=>lvlFeatures.forEach(feature=>this._addEntrySourcesToFilter(feature)));

        cls.subclasses.forEach(sc=>{
            const isScExcluded = (subclassExclusions[sc.source] || {})[sc.name] || false;
            if (!isScExcluded) {
                this._sourceFilter.addItem(sc.source);
                sc.subclassFeatures.forEach(lvlFeatures=>lvlFeatures.forEach(feature=>this._addEntrySourcesToFilter(feature)));
            }
        }
        );
    }

    async _pPopulateBoxOptions(opts) {
        opts.filters = [this._sourceFilter, this._miscFilter, this._optionsFilter, ];
        opts.isCompact = true;
    }

    isClassNaturallyDisplayed(values, cls) {
        return this._filterBox.toDisplay(values, ...this.constructor._getIsClassNaturallyDisplayedToDisplayParams(cls), );
    }

    static _getIsClassNaturallyDisplayedToDisplayParams(cls) {
        return [cls._fSources, cls._fMisc];
    }

    isAnySubclassDisplayed(values, cls) {
        return values[this._optionsFilter.header].isDisplayClassIfSubclassActive && (cls.subclasses || []).some(sc=>{
            if (this._filterBox.toDisplay(values, ...this.constructor._getIsSubclassDisplayedToDisplayParams(cls, sc), ))
                return true;

            return sc.otherSources?.length && sc.otherSources.some(src=>this._filterBox.toDisplay(values, ...this.constructor._getIsSubclassDisplayedToDisplayParams(cls, sc, src), ));
        }
        );
    }

    static _getIsSubclassDisplayedToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, null, ];
    }

    isSubclassVisible(f, cls, sc) {
        if (this.filterBox.toDisplay(f, ...this.constructor._getIsSubclassVisibleToDisplayParams(cls, sc), ))
            return true;

        if (!sc.otherSources?.length)
            return false;

        return sc.otherSources.some(src=>this.filterBox.toDisplay(f, ...this.constructor._getIsSubclassVisibleToDisplayParams(cls, sc, src.source), ));
    }

    static _getIsSubclassVisibleToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, null, ];
    }

    getActiveSource(values) {
        const sourceFilterValues = values[this._sourceFilter.header];
        if (!sourceFilterValues)
            return null;
        return Object.keys(sourceFilterValues).find(it=>this._sourceFilter.toDisplay(values, it));
    }

    toDisplay(values, it) {
        return this._filterBox.toDisplay(values, ...this._getToDisplayParams(values, it), );
    }

    _getToDisplayParams(values, cls) {
        return [this.isAnySubclassDisplayed(values, cls) ? cls._fSourceSubclass : (cls._fSources ?? cls.source), cls._fMisc, null, ];
    }
};

class PageFilterClasses extends PageFilterClassesBase {
    static _getClassSubclassLevelArray(it) {
        return it.classFeatures.map((_,i)=>i + 1);
    }

    constructor() {
        super();

        this._levelFilter = new RangeFilter({
            header: "Feature Level",
            min: 1,
            max: 20,
        });
    }

    get levelFilter() {
        return this._levelFilter;
    }

    static mutateForFilters(cls) {
        super.mutateForFilters(cls);

        cls._fLevelRange = this._getClassSubclassLevelArray(cls);
    }

    addToFilters(cls, isExcluded, opts) {
        super.addToFilters(cls, isExcluded, opts);

        if (isExcluded)
            return;

        this._levelFilter.addItem(cls._fLevelRange);
    }

    async _pPopulateBoxOptions(opts) {
        await super._pPopulateBoxOptions(opts);

        opts.filters = [this._sourceFilter, this._miscFilter, this._levelFilter, this._optionsFilter, ];
    }

    static _getIsClassNaturallyDisplayedToDisplayParams(cls) {
        return [cls._fSources, cls._fMisc, cls._fLevelRange];
    }

    static _getIsSubclassDisplayedToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, cls._fLevelRange];
    }

    static _getIsSubclassVisibleToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, cls._fLevelRange, null];
    }

    _getToDisplayParams(values, cls) {
        return [this.isAnySubclassDisplayed(values, cls) ? cls._fSourceSubclass : (cls._fSources ?? cls.source), cls._fMisc, cls._fLevelRange, ];
    }
};

class PageFilterClassesRaw extends PageFilterClassesBase {
    static _WALKER = null;
    static _IMPLS_SIDE_DATA = {};

    async _pPopulateBoxOptions(opts) {
        await super._pPopulateBoxOptions(opts);
        opts.isCompact = false;
    }


    /**
     * Add a class (and any attached class features and subclasses) to the filter
     * @param {Object} cls - the class object
     * @param {any} isExcluded - will return if true
     * @param {any} opts - only opts.subclassExclusions matters
     */
    addToFilters(cls, isExcluded, opts) {
        if (isExcluded)
            return;
        opts = opts || {};
        const subclassExclusions = opts.subclassExclusions || {};

        this._sourceFilter.addItem(cls.source);

        if (cls.fluff)
            cls.fluff.forEach(it=>this._addEntrySourcesToFilter(it));

        cls.classFeatures.forEach(feature=>feature.loadeds.forEach(ent=>this._addEntrySourcesToFilter(ent.entity)));

        cls.subclasses.forEach(sc=>{
            const isScExcluded = (subclassExclusions[sc.source] || {})[sc.name] || false;
            if (!isScExcluded) {
                this._sourceFilter.addItem(sc.source);
                sc.subclassFeatures.forEach(feature=>feature.loadeds.forEach(ent=>this._addEntrySourcesToFilter(ent.entity)));
            }
        }
        );
    }

    static async _pGetParentClass(sc) {
        let baseClass = (await DataUtil.class.loadRawJSON()).class.find(bc=>bc.name.toLowerCase() === sc.className.toLowerCase() && (bc.source.toLowerCase() || Parser.SRC_PHB) === sc.classSource.toLowerCase());

        baseClass = baseClass || await this._pGetParentClass_pPrerelease({sc});
        baseClass = baseClass || await this._pGetParentClass_pBrew({sc});

        return baseClass;
    }

    static async _pGetParentClass_pPrerelease({sc}) {
        await this._pGetParentClass_pPrereleaseBrew({
            sc,
            brewUtil: PrereleaseUtil
        });
    }

    static async _pGetParentClass_pBrew({sc}) {
        await this._pGetParentClass_pPrereleaseBrew({
            sc,
            brewUtil: BrewUtil2
        });
    }

    static async _pGetParentClass_pPrereleaseBrew({sc, brewUtil}) {
        const brew = await brewUtil.pGetBrewProcessed();
        return (brew.class || []).find(bc=>bc.name.toLowerCase() === sc.className.toLowerCase() && (bc.source.toLowerCase() || Parser.SRC_PHB) === sc.classSource.toLowerCase());
    }

    static async pPostLoad(data, {...opts}={}) {
        data = MiscUtil.copy(data);

        await PrereleaseUtil.pGetBrewProcessed();
        await BrewUtil2.pGetBrewProcessed();

        if (!data.class)
            data.class = [];

        if (data.subclass) {
            for (const sc of data.subclass) {
                if (!sc.className)
                    continue;
                sc.classSource = sc.classSource || Parser.SRC_PHB;

                let cls = data.class.find(it=>(it.name || "").toLowerCase() === sc.className.toLowerCase() && (it.source || Parser.SRC_PHB).toLowerCase() === sc.classSource.toLowerCase());

                if (!cls) {
                    cls = await this._pGetParentClass(sc);
                    if (cls) {
                        cls = MiscUtil.copy(cls);
                        cls.subclasses = [];
                        data.class.push(cls);
                    } else {
                        cls = {
                            name: sc.className,
                            source: sc.classSource
                        };
                        data.class.push(cls);
                    }
                }

                (cls.subclasses = cls.subclasses || []).push(sc);
            }

            delete data.subclass;
        }

        data.class.forEach(cls=>{
            cls.source = cls.source || Parser.SRC_PHB;

            cls.subclasses = cls.subclasses || [];

            cls.subclasses.forEach(sc=>{
                sc.name = sc.name || "(Unnamed subclass)";
                sc.source = sc.source || cls.source;
                sc.className = sc.className || cls.name;
                sc.classSource = sc.classSource || cls.source || Parser.SRC_PHB;
            }
            );

            cls.subclasses.sort((a,b)=>SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source || cls.source, b.source || cls.source));

            cls._cntStartingSkillChoices = (MiscUtil.get(cls, "startingProficiencies", "skills") || []).map(it=>it.choose ? (it.choose.count || 1) : 0).reduce((a,b)=>a + b, 0);

            cls._cntStartingSkillChoicesMutliclass = (MiscUtil.get(cls, "multiclassing", "proficienciesGained", "skills") || []).map(it=>it.choose ? (it.choose.count || 1) : 0).reduce((a,b)=>a + b, 0);
        }
        );
        data.class.sort((a,b)=>SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source));

        data.class.forEach(cls=>{
            cls.classFeatures = (cls.classFeatures || []).map(cf=>typeof cf === "string" ? {
                classFeature: cf
            } : cf);

            (cls.subclasses || []).forEach(sc=>{
                sc.subclassFeatures = (sc.subclassFeatures || []).map(cf=>typeof cf === "string" ? {
                    subclassFeature: cf
                } : cf);
            }
            );
        }
        );

        await this._pPreloadSideData();

        for (const cls of data.class) {
            await (cls.classFeatures || []).pSerialAwaitMap(cf=>this.pInitClassFeatureLoadeds({
                ...opts,
                classFeature: cf,
                className: cls.name
            }));

            if (cls.classFeatures)
                cls.classFeatures = cls.classFeatures.filter(it=>!it.isIgnored);

            for (const sc of cls.subclasses || []) {
                await (sc.subclassFeatures || []).pSerialAwaitMap(scf=>this.pInitSubclassFeatureLoadeds({
                    ...opts,
                    subclassFeature: scf,
                    className: cls.name,
                    subclassName: sc.name
                }));

                if (sc.subclassFeatures)
                    sc.subclassFeatures = sc.subclassFeatures.filter(it=>!it.isIgnored);
            }
        }

        return data;
    }

    static async pInitClassFeatureLoadeds({classFeature, className, ...opts}) {
        if (typeof classFeature !== "object")
            throw new Error(`Expected an object of the form {classFeature: "<UID>"}`);

        const unpacked = DataUtil.class.unpackUidClassFeature(classFeature.classFeature);

        classFeature.hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked);

        const {name, level, source} = unpacked;
        classFeature.name = name;
        classFeature.level = level;
        classFeature.source = source;

        const entityRoot = await DataLoader.pCacheAndGet("raw_classFeature", classFeature.source, classFeature.hash, {
            isCopy: true
        });
        const loadedRoot = {
            type: "classFeature",
            entity: entityRoot,
            page: "classFeature",
            source: classFeature.source,
            hash: classFeature.hash,
            className,
        };

        const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, "classFeature");
        if (isIgnored) {
            classFeature.isIgnored = true;
            return;
        }

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: "classFeature",
            ancestorMeta: {
                _ancestorClassName: className,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        classFeature.loadeds = [loadedRoot, ...subLoadeds];
    }

    static async pInitSubclassFeatureLoadeds({subclassFeature, className, subclassName, ...opts}) {
        if (typeof subclassFeature !== "object")
            throw new Error(`Expected an object of the form {subclassFeature: "<UID>"}`);

        const unpacked = DataUtil.class.unpackUidSubclassFeature(subclassFeature.subclassFeature);

        subclassFeature.hash = UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked);

        const {name, level, source} = unpacked;
        subclassFeature.name = name;
        subclassFeature.level = level;
        subclassFeature.source = source;

        const entityRoot = await DataLoader.pCacheAndGet("raw_subclassFeature", subclassFeature.source, subclassFeature.hash, {
            isCopy: true
        });
        const loadedRoot = {
            type: "subclassFeature",
            entity: entityRoot,
            page: "subclassFeature",
            source: subclassFeature.source,
            hash: subclassFeature.hash,
            className,
            subclassName,
        };

        const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, "subclassFeature");
        if (isIgnored) {
            subclassFeature.isIgnored = true;
            return;
        }

        if (entityRoot.isGainAtNextFeatureLevel) {
            subclassFeature.isGainAtNextFeatureLevel = true;
        }

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: "subclassFeature",
            ancestorMeta: {
                _ancestorClassName: className,
                _ancestorSubclassName: subclassName,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        subclassFeature.loadeds = [loadedRoot, ...subLoadeds];
    }

    static async pInitFeatLoadeds({feat, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: feat,
            prop: "feat",
            page: UrlUtil.PG_FEATS,
            propAncestorName: "_ancestorFeatName",
            raw,
        });
    }

    static async pInitOptionalFeatureLoadeds({optionalfeature, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: optionalfeature,
            prop: "optionalfeature",
            page: UrlUtil.PG_OPT_FEATURES,
            propAncestorName: "_ancestorOptionalfeatureName",
            raw,
        });
    }

    static async pInitRewardLoadeds({reward, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: reward,
            prop: "reward",
            page: UrlUtil.PG_REWARDS,
            propAncestorName: "_ancestorRewardName",
            raw,
        });
    }

    static async pInitCharCreationOptionLoadeds({charoption, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: charoption,
            prop: "charoption",
            page: UrlUtil.PG_CHAR_CREATION_OPTIONS,
            propAncestorName: "_ancestorCharoptionName",
            raw,
        });
    }

    static async pInitVehicleUpgradeLoadeds({vehicleUpgrade, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: vehicleUpgrade,
            prop: "vehicleUpgrade",
            page: UrlUtil.PG_VEHICLES,
            propAncestorName: "_ancestorVehicleUpgradeName",
            raw,
        });
    }

    static async _pInitGenericLoadeds({ent, prop, page, propAncestorName, raw, ...opts}) {
        if (typeof ent !== "object")
            throw new Error(`Expected an object of the form {${prop}: "<UID>"}`);

        const unpacked = DataUtil.generic.unpackUid(ent[prop]);

        ent.hash = UrlUtil.URL_TO_HASH_BUILDER[page](unpacked);

        const {name, source} = unpacked;
        ent.name = name;
        ent.source = source;

        const entityRoot = raw != null ? MiscUtil.copy(raw) : await DataLoader.pCacheAndGet(`raw_${prop}`, ent.source, ent.hash, {
            isCopy: true
        });
        const loadedRoot = {
            type: prop,
            entity: entityRoot,
            page,
            source: ent.source,
            hash: ent.hash,
        };

        const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, prop);
        if (isIgnored) {
            ent.isIgnored = true;
            return;
        }

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: prop,
            ancestorMeta: {
                [propAncestorName]: entityRoot.name,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        ent.loadeds = [loadedRoot, ...subLoadeds];
    }

    static async _pPreloadSideData() {
        await Promise.all(Object.values(PageFilterClassesRaw._IMPLS_SIDE_DATA).map(Impl=>Impl.pPreloadSideData()));
    }

    static async _pGetIgnoredAndApplySideData(entity, type) {
        if (!PageFilterClassesRaw._IMPLS_SIDE_DATA[type])
            throw new Error(`Unhandled type "${type}"`);

        const sideData = await PageFilterClassesRaw._IMPLS_SIDE_DATA[type].pGetSideLoaded(entity, {
            isSilent: true
        });

        if (!sideData)
            return false;
        if (sideData.isIgnored)
            return true;

        if (sideData.entries)
            entity.entries = MiscUtil.copy(sideData.entries);
        if (sideData.entryData)
            entity.entryData = MiscUtil.copy(sideData.entryData);

        return false;
    }

    static async _pLoadSubEntries(walker, entityRoot, {ancestorType, ancestorMeta, ...opts}) {
        const out = [];

        const pRecurse = async(parent,toWalk)=>{
            const references = [];
            const path = [];

            toWalk = walker.walk(toWalk, {
                array: (arr)=>{
                    arr = arr.map(it=>this._pLoadSubEntries_getMappedWalkerArrayEntry({
                        ...opts,
                        it,
                        path,
                        references
                    })).filter(Boolean);
                    return arr;
                }
                ,
                preObject: (obj)=>{
                    if (obj.type === "options") {
                        const parentName = (path.last() || {}).name ?? parent.name;

                        if (obj.count != null) {
                            const optionSetId = CryptUtil.uid();
                            obj.entries.forEach(ent=>{
                                ent._optionsMeta = {
                                    setId: optionSetId,
                                    count: obj.count,
                                    name: parentName,
                                };
                            }
                            );
                        }

                        if (parentName) {
                            obj.entries.forEach(ent=>{
                                if (typeof ent !== "object")
                                    return;
                                ent._displayNamePrefix = `${parentName}: `;
                            }
                            );
                        }
                    }

                    if (obj.name)
                        path.push(obj);
                }
                ,
                postObject: (obj)=>{
                    if (obj.name)
                        path.pop();
                }
                ,
            }, );

            for (const ent of references) {
                const isRequiredOption = !!MiscUtil.get(ent, "data", "isRequiredOption");
                switch (ent.type) {
                case "refClassFeature":
                    {
                        const unpacked = DataUtil.class.unpackUidClassFeature(ent.classFeature);
                        const {source} = unpacked;
                        const hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked);

                        let entity = await DataLoader.pCacheAndGet("raw_classFeature", source, hash, {
                            isCopy: true
                        });

                        if (!entity) {
                            this._handleReferenceError(`Failed to load "classFeature" reference "${ent.classFeature}" (not found)`);
                            continue;
                        }

                        if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER["classFeature"](toWalk) === hash) {
                            this._handleReferenceError(`Failed to load "classFeature" reference "${ent.classFeature}" (circular reference)`);
                            continue;
                        }

                        const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "classFeature");
                        if (isIgnored)
                            continue;

                        this.populateEntityTempData({
                            entity,
                            displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
                            ...ancestorMeta,
                        });

                        out.push({
                            type: "classFeature",
                            entry: `{@classFeature ${ent.classFeature}}`,
                            entity,
                            optionsMeta: ent._optionsMeta,
                            page: "classFeature",
                            source,
                            hash,
                            isRequiredOption,
                        });

                        entity = await pRecurse(entity, entity.entries);

                        break;
                    }
                case "refSubclassFeature":
                    {
                        const unpacked = DataUtil.class.unpackUidSubclassFeature(ent.subclassFeature);
                        const {source} = unpacked;
                        const hash = UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked);

                        let entity = await DataLoader.pCacheAndGet("raw_subclassFeature", source, hash, {
                            isCopy: true
                        });

                        if (!entity) {
                            this._handleReferenceError(`Failed to load "subclassFeature" reference "${ent.subclassFeature}" (not found)`);
                            continue;
                        }

                        if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](toWalk) === hash) {
                            this._handleReferenceError(`Failed to load "subclassFeature" reference "${ent.subclassFeature}" (circular reference)`);
                            continue;
                        }

                        const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "subclassFeature");
                        if (isIgnored)
                            continue;

                        this.populateEntityTempData({
                            entity,
                            displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
                            ...ancestorMeta,
                        });

                        out.push({
                            type: "subclassFeature",
                            entry: `{@subclassFeature ${ent.subclassFeature}}`,
                            entity,
                            optionsMeta: ent._optionsMeta,
                            page: "subclassFeature",
                            source,
                            hash,
                            isRequiredOption,
                        });

                        entity = await pRecurse(entity, entity.entries);

                        break;
                    }
                case "refOptionalfeature":
                    {
                        const unpacked = DataUtil.generic.unpackUid(ent.optionalfeature, "optfeature");
                        const page = UrlUtil.PG_OPT_FEATURES;
                        const {source} = unpacked;
                        const hash = UrlUtil.URL_TO_HASH_BUILDER[page](unpacked);

                        const entity = await DataLoader.pCacheAndGet(page, source, hash, {
                            isCopy: true
                        });

                        if (!entity) {
                            this._handleReferenceError(`Failed to load "optfeature" reference "${ent.optionalfeature}" (not found)`);
                            continue;
                        }

                        if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER[page](toWalk) === hash) {
                            this._handleReferenceError(`Failed to load "optfeature" reference "${ent.optionalfeature}" (circular reference)`);
                            continue;
                        }

                        const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "optionalfeature");
                        if (isIgnored)
                            continue;

                        this.populateEntityTempData({
                            entity,
                            ancestorType,
                            displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
                            ...ancestorMeta,
                            foundrySystem: {
                                requirements: entityRoot.className ? `${entityRoot.className} ${entityRoot.level}${entityRoot.subclassShortName ? ` (${entityRoot.subclassShortName})` : ""}` : null,
                            },
                        });

                        out.push({
                            type: "optionalfeature",
                            entry: `{@optfeature ${ent.optionalfeature}}`,
                            entity,
                            optionsMeta: ent._optionsMeta,
                            page,
                            source,
                            hash,
                            isRequiredOption,
                        });

                        break;
                    }
                default:
                    throw new Error(`Unhandled type "${ent.type}"`);
                }
            }

            return toWalk;
        }
        ;

        if (entityRoot.entries) //entityRoot.entryData is already set by this point
            entityRoot.entries = await pRecurse(entityRoot, entityRoot.entries);

        return {
            entityRoot,
            subLoadeds: out
        };
    }

    static _pLoadSubEntries_getMappedWalkerArrayEntry({it, path, references, ...opts}) {
        if (it.type !== "refClassFeature" && it.type !== "refSubclassFeature" && it.type !== "refOptionalfeature")
            return it;

        it.parentName = (path.last() || {}).name;
        references.push(it);

        return null;
    }

    static populateEntityTempData({entity, ancestorType, displayName, foundrySystem, ...others}, ) {
        if (ancestorType)
            entity._ancestorType = ancestorType;
        if (displayName)
            entity._displayName = displayName;
        if (foundrySystem)
            entity._foundrySystem = foundrySystem;
        Object.assign(entity, {
            ...others
        });
    }

    static _handleReferenceError(msg) {
        JqueryUtil.doToast({
            type: "danger",
            content: msg
        });
    }

    static _getPostLoadWalker() {
        PageFilterClassesRaw._WALKER = PageFilterClassesRaw._WALKER || MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
            isDepthFirst: true,
        });
        return PageFilterClassesRaw._WALKER;
    }

    static setImplSideData(prop, Impl) {
        PageFilterClassesRaw._IMPLS_SIDE_DATA[prop] = Impl;
    }
};
//#endregion

//#region PageFilterRaces
class PageFilterRaces extends PageFilter {
    

    constructor() {
        super();

        //Create sub-filters
        //sourcefilter is created by super

        this._sizeFilter = new Filter({
            header: "Size",
            displayFn: Parser.sizeAbvToFull,
            itemSortFn: PageFilterRaces.filterAscSortSize
        });
        this._asiFilter = new AbilityScoreFilter({
            header: "Ability Scores (Including Subrace)"
        });
        this._baseRaceFilter = new Filter({
            header: "Base Race"
        });
        this._speedFilter = new Filter({
            header: "Speed",
            items: ["Climb", "Fly", "Swim", "Walk (Fast)", "Walk", "Walk (Slow)"]
        });
        this._traitFilter = new Filter({
            header: "Traits",
            items: ["Amphibious", "Armor Proficiency", "Blindsight", "Darkvision", "Superior Darkvision", "Dragonmark", "Feat", "Improved Resting", "Monstrous Race", "Natural Armor", "Natural Weapon", "NPC Race", "Powerful Build", "Skill Proficiency", "Spellcasting", "Sunlight Sensitivity", "Tool Proficiency", "Uncommon Race", "Weapon Proficiency", ],
            deselFn: (it)=>{
                return it === "NPC Race";
            }
            ,
        });
        this._vulnerableFilter = FilterCommon.getDamageVulnerableFilter();
        this._resistFilter = FilterCommon.getDamageResistFilter();
        this._immuneFilter = FilterCommon.getDamageImmuneFilter();
        this._defenceFilter = new MultiFilter({
            header: "Damage",
            filters: [this._vulnerableFilter, this._resistFilter, this._immuneFilter]
        });
        this._conditionImmuneFilter = FilterCommon.getConditionImmuneFilter();
        this._languageFilter = new Filter({
            header: "Languages",
            items: ["Abyssal", "Celestial", "Choose", "Common", "Draconic", "Dwarvish", "Elvish", "Giant", "Gnomish", "Goblin", "Halfling", "Infernal", "Orc", "Other", "Primordial", "Sylvan", "Undercommon", ],
            umbrellaItems: ["Choose"],
        });
        this._creatureTypeFilter = new Filter({
            header: "Creature Type",
            items: Parser.MON_TYPES,
            displayFn: StrUtil.toTitleCase,
            itemSortFn: SortUtil.ascSortLower,
        });
        this._ageFilter = new RangeFilter({
            header: "Adult Age",
            isRequireFullRangeMatch: true,
            isSparse: true,
            displayFn: it=>`${it} y.o.`,
            displayFnTooltip: it=>`${it} year${it === 1 ? "" : "s"} old`,
        });
        this._miscFilter = new Filter({
            header: "Miscellaneous",
            items: ["Base Race", "Key Race", "Lineage", "Modified Copy", "Reprinted", "SRD", "Basic Rules", "Has Images", "Has Info"],
            isMiscFilter: true,
        });
    }

    static mutateForFilters(r) {
        r._fSize = r.size ? [...r.size] : [];
        if (r._fSize.length > 1)
            r._fSize.push("V");
        r._fSpeed = r.speed ? r.speed.walk ? [r.speed.climb ? "Climb" : null, r.speed.fly ? "Fly" : null, r.speed.swim ? "Swim" : null, PageFilterRaces.getSpeedRating(r.speed.walk)].filter(it=>it) : [PageFilterRaces.getSpeedRating(r.speed)] : [];
        r._fTraits = [r.darkvision === 120 ? "Superior Darkvision" : r.darkvision ? "Darkvision" : null, r.blindsight ? "Blindsight" : null, r.skillProficiencies ? "Skill Proficiency" : null, r.toolProficiencies ? "Tool Proficiency" : null, r.feats ? "Feat" : null, r.additionalSpells ? "Spellcasting" : null, r.armorProficiencies ? "Armor Proficiency" : null, r.weaponProficiencies ? "Weapon Proficiency" : null, ].filter(it=>it);
        r._fTraits.push(...(r.traitTags || []));
        r._fSources = SourceFilter.getCompleteFilterSources(r);
        r._fLangs = PageFilterRaces.getLanguageProficiencyTags(r.languageProficiencies);
        r._fCreatureTypes = r.creatureTypes ? r.creatureTypes.map(it=>it.choose || it).flat() : ["humanoid"];
        r._fMisc = [];
        if (r._isBaseRace)
            r._fMisc.push("Base Race");
        if (r._isBaseRace || !r._isSubRace)
            r._fMisc.push("Key Race");
        if (r._isCopy)
            r._fMisc.push("Modified Copy");
        if (r.srd)
            r._fMisc.push("SRD");
        if (r.basicRules)
            r._fMisc.push("Basic Rules");
        if (r.hasFluff || r.fluff?.entries)
            r._fMisc.push("Has Info");
        if (r.hasFluffImages || r.fluff?.images)
            r._fMisc.push("Has Images");
        if (r.lineage)
            r._fMisc.push("Lineage");
        if (this._isReprinted({
            reprintedAs: r.reprintedAs,
            tag: "race",
            prop: "race",
            page: UrlUtil.PG_RACES
        }))
            r._fMisc.push("Reprinted");

        const ability = r.ability ? Renderer.getAbilityData(r.ability, {
            isOnlyShort: true,
            isCurrentLineage: r.lineage === "VRGR"
        }) : {
            asTextShort: "None"
        };
        r._slAbility = ability.asTextShort;

        if (r.age?.mature != null && r.age?.max != null)
            r._fAge = [r.age.mature, r.age.max];
        else if (r.age?.mature != null)
            r._fAge = r.age.mature;
        else if (r.age?.max != null)
            r._fAge = r.age.max;

        FilterCommon.mutateForFilters_damageVulnResImmune_player(r);
        FilterCommon.mutateForFilters_conditionImmune_player(r);
    }

    /**
     * Add an race's filterable tags to the sub-filters (source filter, size filter, language filter, etc)
     * @param {any} r A race object
     * @param {Boolean} isExcluded if this is true, we return immediately
     */
    addToFilters(r, isExcluded) {
        if (isExcluded)
            return;

        this._sourceFilter.addItem(r._fSources);
        this._sizeFilter.addItem(r._fSize);
        this._asiFilter.addItem(r.ability);
        this._baseRaceFilter.addItem(r._baseName);
        this._creatureTypeFilter.addItem(r._fCreatureTypes);
        this._traitFilter.addItem(r._fTraits);
        this._vulnerableFilter.addItem(r._fVuln);
        this._resistFilter.addItem(r._fRes);
        this._immuneFilter.addItem(r._fImm);
        this._conditionImmuneFilter.addItem(r._fCondImm);
        this._ageFilter.addItem(r._fAge);
        this._languageFilter.addItem(r._fLangs);
    }

    async _pPopulateBoxOptions(opts) {
        opts.filters = [this._sourceFilter, this._asiFilter, this._sizeFilter, this._speedFilter, this._traitFilter, this._defenceFilter, this._conditionImmuneFilter, this._languageFilter, this._baseRaceFilter, this._creatureTypeFilter, this._miscFilter, this._ageFilter, ];
    }

    toDisplay(values, r) {
        return this._filterBox.toDisplay(values, r._fSources, r.ability, r._fSize, r._fSpeed, r._fTraits, [r._fVuln, r._fRes, r._fImm, ], r._fCondImm, r._fLangs, r._baseName, r._fCreatureTypes, r._fMisc, r._fAge, );
    }

    static getListAliases(race) {
        return (race.alias || []).map(it=>{
            const invertedName = PageFilterRaces.getInvertedName(it);
            return [`"${it}"`, invertedName ? `"${invertedName}"` : false].filter(Boolean);
        }
        ).flat().join(",");
    }

    static getInvertedName(name) {
        const bracketMatch = /^(.*?) \((.*?)\)$/.exec(name);
        return bracketMatch ? `${bracketMatch[2]} ${bracketMatch[1]}` : null;
    }

    static getLanguageProficiencyTags(lProfs) {
        if (!lProfs)
            return [];

        const outSet = new Set();
        lProfs.forEach(lProfGroup=>{
            Object.keys(lProfGroup).forEach(k=>{
                if (!["choose", "any", "anyStandard", "anyExotic"].includes(k))
                    outSet.add(k.toTitleCase());
                else
                    outSet.add("Choose");
            }
            );
        }
        );

        return [...outSet];
    }

    static getSpeedRating(speed) {
        return speed > 30 ? "Walk (Fast)" : speed < 30 ? "Walk (Slow)" : "Walk";
    }

    static filterAscSortSize(a, b) {
        a = a.item;
        b = b.item;

        return SortUtil.ascSort(toNum(a), toNum(b));

        function toNum(size) {
            switch (size) {
            case "M":
                return 0;
            case "S":
                return -1;
            case "V":
                return 1;
            }
        }
    }
};
//#endregion

//#region PageFilterBackgrounds
let PageFilterBackgrounds$1 = class PageFilterBackgrounds extends PageFilter {
    static _getToolDisplayText(tool) {
        if (tool === "anyTool")
            return "Any Tool";
        if (tool === "anyArtisansTool")
            return "Any Artisan's Tool";
        if (tool === "anyMusicalInstrument")
            return "Any Musical Instrument";
        return tool.toTitleCase();
    }

    constructor() {
        super();

        this._skillFilter = new Filter({
            header: "Skill Proficiencies",
            displayFn: StrUtil.toTitleCase
        });
        this._toolFilter = new Filter({
            header: "Tool Proficiencies",
            displayFn: PageFilterBackgrounds$1._getToolDisplayText.bind(PageFilterBackgrounds$1)
        });
        this._languageFilter = new Filter({
            header: "Language Proficiencies",
            displayFn: it=>it === "anyStandard" ? "Any Standard" : it === "anyExotic" ? "Any Exotic" : StrUtil.toTitleCase(it),
        });
        this._asiFilter = new AbilityScoreFilter({
            header: "Ability Scores"
        });
        this._otherBenefitsFilter = new Filter({
            header: "Other Benefits"
        });
        this._miscFilter = new Filter({
            header: "Miscellaneous",
            items: ["Has Info", "Has Images", "SRD", "Basic Rules"],
            isMiscFilter: true
        });
    }

    static mutateForFilters(bg) {
        bg._fSources = SourceFilter.getCompleteFilterSources(bg);

        const {summary: skillDisplay, collection: skills} = Renderer.generic.getSkillSummary({
            skillProfs: bg.skillProficiencies,
            skillToolLanguageProfs: bg.skillToolLanguageProficiencies,
            isShort: true,
        });
        bg._fSkills = skills;

        const {collection: tools} = Renderer.generic.getToolSummary({
            toolProfs: bg.toolProficiencies,
            skillToolLanguageProfs: bg.skillToolLanguageProficiencies,
            isShort: true,
        });
        bg._fTools = tools;

        const {collection: languages} = Renderer.generic.getLanguageSummary({
            languageProfs: bg.languageProficiencies,
            skillToolLanguageProfs: bg.skillToolLanguageProficiencies,
            isShort: true,
        });
        bg._fLangs = languages;

        bg._fMisc = [];
        if (bg.srd)
            bg._fMisc.push("SRD");
        if (bg.basicRules)
            bg._fMisc.push("Basic Rules");
        if (bg.hasFluff || bg.fluff?.entries)
            bg._fMisc.push("Has Info");
        if (bg.hasFluffImages || bg.fluff?.images)
            bg._fMisc.push("Has Images");
        bg._fOtherBenifits = [];
        if (bg.feats)
            bg._fOtherBenifits.push("Feat");
        if (bg.additionalSpells)
            bg._fOtherBenifits.push("Additional Spells");
        if (bg.armorProficiencies)
            bg._fOtherBenifits.push("Armor Proficiencies");
        if (bg.weaponProficiencies)
            bg._fOtherBenifits.push("Weapon Proficiencies");
        bg._skillDisplay = skillDisplay;
    }

    addToFilters(bg, isExcluded) {
        if (isExcluded)
            return;

        this._sourceFilter.addItem(bg._fSources);
        this._skillFilter.addItem(bg._fSkills);
        this._toolFilter.addItem(bg._fTools);
        this._languageFilter.addItem(bg._fLangs);
        this._asiFilter.addItem(bg.ability);
        this._otherBenefitsFilter.addItem(bg._fOtherBenifits);
    }

    async _pPopulateBoxOptions(opts) {
        opts.filters = [this._sourceFilter, this._skillFilter, this._toolFilter, this._languageFilter, this._asiFilter, this._otherBenefitsFilter, this._miscFilter, ];
    }

    toDisplay(values, bg) {
        return this._filterBox.toDisplay(values, bg._fSources, bg._fSkills, bg._fTools, bg._fLangs, bg.ability, bg._fOtherBenifits, bg._fMisc, );
    }
}
;
//#endregion

//#region PageFilterSpells
class PageFilterSpells extends PageFilter {
    static _META_ADD_CONC = "Concentration";
    static _META_ADD_V = "Verbal";
    static _META_ADD_S = "Somatic";
    static _META_ADD_M = "Material";
    static _META_ADD_R = "Royalty";
    static _META_ADD_M_COST = "Material with Cost";
    static _META_ADD_M_CONSUMED = "Material is Consumed";
    static _META_ADD_M_CONSUMED_OPTIONAL = "Material is Optionally Consumed";

    static F_RNG_POINT = "Point";
    static F_RNG_SELF_AREA = "Self (Area)";
    static F_RNG_SELF = "Self";
    static F_RNG_TOUCH = "Touch";
    static F_RNG_SPECIAL = "Special";

    static _META_FILTER_BASE_ITEMS = [this._META_ADD_CONC, this._META_ADD_V, this._META_ADD_S, this._META_ADD_M, this._META_ADD_R, this._META_ADD_M_COST, this._META_ADD_M_CONSUMED, this._META_ADD_M_CONSUMED_OPTIONAL, ...Object.keys(Parser.SP_MISC_TAG_TO_FULL), ];

    static INCHES_PER_FOOT = 12;
    static FEET_PER_YARD = 3;
    static FEET_PER_MILE = 5280;

    static sortSpells(a, b, o) {
        switch (o.sortBy) {
        case "name":
            return SortUtil.compareListNames(a, b);
        case "source":
        case "level":
        case "school":
        case "concentration":
        case "ritual":
            return SortUtil.ascSort(a.values[o.sortBy], b.values[o.sortBy]) || SortUtil.compareListNames(a, b);
        case "time":
            return SortUtil.ascSort(a.values.normalisedTime, b.values.normalisedTime) || SortUtil.compareListNames(a, b);
        case "range":
            return SortUtil.ascSort(a.values.normalisedRange, b.values.normalisedRange) || SortUtil.compareListNames(a, b);
        }
    }

    static sortMetaFilter(a, b) {
        const ixA = PageFilterSpells._META_FILTER_BASE_ITEMS.indexOf(a.item);
        const ixB = PageFilterSpells._META_FILTER_BASE_ITEMS.indexOf(b.item);

        if (~ixA && ~ixB)
            return ixA - ixB;
        if (~ixA)
            return -1;
        if (~ixB)
            return 1;
        return SortUtil.ascSortLower(a, b);
    }

    static getFilterAbilitySave(ability) {
        return `${ability.uppercaseFirst()} Save`;
    }
    static getFilterAbilityCheck(ability) {
        return `${ability.uppercaseFirst()} Check`;
    }

    static getMetaFilterObj(s) {
        const out = [];
        if (s.meta) {
            Object.entries(s.meta).filter(([_,v])=>v).sort(SortUtil.ascSort).forEach(([k])=>out.push(k.toTitleCase()));
        }
        if (s.duration.filter(d=>d.concentration).length) {
            out.push(PageFilterSpells._META_ADD_CONC);
            s._isConc = true;
        } else
            s._isConc = false;
        if (s.components && s.components.v)
            out.push(PageFilterSpells._META_ADD_V);
        if (s.components && s.components.s)
            out.push(PageFilterSpells._META_ADD_S);
        if (s.components && s.components.m)
            out.push(PageFilterSpells._META_ADD_M);
        if (s.components && s.components.r)
            out.push(PageFilterSpells._META_ADD_R);
        if (s.components && s.components.m && s.components.m.cost)
            out.push(PageFilterSpells._META_ADD_M_COST);
        if (s.components && s.components.m && s.components.m.consume) {
            if (s.components.m.consume === "optional")
                out.push(PageFilterSpells._META_ADD_M_CONSUMED_OPTIONAL);
            else
                out.push(PageFilterSpells._META_ADD_M_CONSUMED);
        }
        if (s.miscTags)
            out.push(...s.miscTags);
        if ((!s.miscTags || (s.miscTags && !s.miscTags.includes("PRM"))) && s.duration.filter(it=>it.type === "permanent").length)
            out.push("PRM");
        if ((!s.miscTags || (s.miscTags && !s.miscTags.includes("SCL"))) && s.entriesHigherLevel)
            out.push("SCL");
        if (s.srd)
            out.push("SRD");
        if (s.basicRules)
            out.push("Basic Rules");
        if (s.hasFluff || s.fluff?.entries)
            out.push("Has Info");
        if (s.hasFluffImages || s.fluff?.images)
            out.push("Has Images");
        return out;
    }

    static getFilterDuration(spell) {
        const fDur = spell.duration[0] || {
            type: "special"
        };
        switch (fDur.type) {
        case "instant":
            return "Instant";
        case "timed":
            {
                if (!fDur.duration)
                    return "Special";
                switch (fDur.duration.type) {
                case "turn":
                case "round":
                    return "1 Round";

                case "minute":
                    {
                        const amt = fDur.duration.amount || 0;
                        if (amt <= 1)
                            return "1 Minute";
                        if (amt <= 10)
                            return "10 Minutes";
                        if (amt <= 60)
                            return "1 Hour";
                        if (amt <= 8 * 60)
                            return "8 Hours";
                        return "24+ Hours";
                    }

                case "hour":
                    {
                        const amt = fDur.duration.amount || 0;
                        if (amt <= 1)
                            return "1 Hour";
                        if (amt <= 8)
                            return "8 Hours";
                        return "24+ Hours";
                    }

                case "week":
                case "day":
                case "year":
                    return "24+ Hours";
                default:
                    return "Special";
                }
            }
        case "permanent":
            return "Permanent";
        case "special":
        default:
            return "Special";
        }
    }

    static getNormalisedTime(time) {
        const firstTime = time[0];
        let multiplier = 1;
        let offset = 0;
        switch (firstTime.unit) {
        case Parser.SP_TM_B_ACTION:
            offset = 1;
            break;
        case Parser.SP_TM_REACTION:
            offset = 2;
            break;
        case Parser.SP_TM_ROUND:
            multiplier = 6;
            break;
        case Parser.SP_TM_MINS:
            multiplier = 60;
            break;
        case Parser.SP_TM_HRS:
            multiplier = 3600;
            break;
        }
        if (time.length > 1)
            offset += 0.5;
        return (multiplier * firstTime.number) + offset;
    }

    static getNormalisedRange(range) {
        const state = {
            multiplier: 1,
            distance: 0,
            offset: 0,
        };

        switch (range.type) {
        case Parser.RNG_SPECIAL:
            return 1000000000;
        case Parser.RNG_POINT:
            this._getNormalisedRange_getAdjustedForDistance({
                range,
                state
            });
            break;
        case Parser.RNG_LINE:
            state.offset = 1;
            this._getNormalisedRange_getAdjustedForDistance({
                range,
                state
            });
            break;
        case Parser.RNG_CONE:
            state.offset = 2;
            this._getNormalisedRange_getAdjustedForDistance({
                range,
                state
            });
            break;
        case Parser.RNG_RADIUS:
            state.offset = 3;
            this._getNormalisedRange_getAdjustedForDistance({
                range,
                state
            });
            break;
        case Parser.RNG_HEMISPHERE:
            state.offset = 4;
            this._getNormalisedRange_getAdjustedForDistance({
                range,
                state
            });
            break;
        case Parser.RNG_SPHERE:
            state.offset = 5;
            this._getNormalisedRange_getAdjustedForDistance({
                range,
                state
            });
            break;
        case Parser.RNG_CYLINDER:
            state.offset = 6;
            this._getNormalisedRange_getAdjustedForDistance({
                range,
                state
            });
            break;
        case Parser.RNG_CUBE:
            state.offset = 7;
            this._getNormalisedRange_getAdjustedForDistance({
                range,
                state
            });
            break;
        }

        return (state.multiplier * state.distance) + state.offset;
    }

    static _getNormalisedRange_getAdjustedForDistance({range, state}) {
        const dist = range.distance;
        switch (dist.type) {
        case Parser.UNT_FEET:
            state.multiplier = PageFilterSpells.INCHES_PER_FOOT;
            state.distance = dist.amount;
            break;
        case Parser.UNT_YARDS:
            state.multiplier = PageFilterSpells.INCHES_PER_FOOT * PageFilterSpells.FEET_PER_YARD;
            state.distance = dist.amount;
            break;
        case Parser.UNT_MILES:
            state.multiplier = PageFilterSpells.INCHES_PER_FOOT * PageFilterSpells.FEET_PER_MILE;
            state.distance = dist.amount;
            break;
        case Parser.RNG_SELF:
            state.distance = 0;
            break;
        case Parser.RNG_TOUCH:
            state.distance = 1;
            break;
        case Parser.RNG_SIGHT:
            state.multiplier = PageFilterSpells.INCHES_PER_FOOT * PageFilterSpells.FEET_PER_MILE;
            state.distance = 12;
            break;
        case Parser.RNG_UNLIMITED_SAME_PLANE:
            state.distance = 900000000;
            break;
        case Parser.RNG_UNLIMITED:
            state.distance = 900000001;
            break;
        default:
            {
                this._getNormalisedRange_getAdjustedForDistance_prereleaseBrew({
                    range,
                    state,
                    brewUtil: PrereleaseUtil
                }) || this._getNormalisedRange_getAdjustedForDistance_prereleaseBrew({
                    range,
                    state,
                    brewUtil: BrewUtil2
                });
            }
        }
    }

    static _getNormalisedRange_getAdjustedForDistance_prereleaseBrew({range, state, brewUtil}) {
        const dist = range.distance;
        const fromBrew = brewUtil.getMetaLookup("spellDistanceUnits")?.[dist.type];
        if (!fromBrew)
            return false;

        const ftPerUnit = fromBrew.feetPerUnit;
        if (ftPerUnit != null) {
            state.multiplier = PageFilterSpells.INCHES_PER_FOOT * ftPerUnit;
            state.distance = dist.amount;
        } else {
            state.distance = 910000000;
        }

        return true;
    }

    static getRangeType(range) {
        switch (range.type) {
        case Parser.RNG_SPECIAL:
            return PageFilterSpells.F_RNG_SPECIAL;
        case Parser.RNG_POINT:
            switch (range.distance.type) {
            case Parser.RNG_SELF:
                return PageFilterSpells.F_RNG_SELF;
            case Parser.RNG_TOUCH:
                return PageFilterSpells.F_RNG_TOUCH;
            default:
                return PageFilterSpells.F_RNG_POINT;
            }
        case Parser.RNG_LINE:
        case Parser.RNG_CONE:
        case Parser.RNG_RADIUS:
        case Parser.RNG_HEMISPHERE:
        case Parser.RNG_SPHERE:
        case Parser.RNG_CYLINDER:
        case Parser.RNG_CUBE:
            return PageFilterSpells.F_RNG_SELF_AREA;
        }
    }

    static getTblTimeStr(time) {
        return (time.number === 1 && Parser.SP_TIME_SINGLETONS.includes(time.unit)) ? `${time.unit.uppercaseFirst()}` : `${time.number ? `${time.number} ` : ""}${Parser.spTimeUnitToShort(time.unit).uppercaseFirst()}`;
    }

    static getTblLevelStr(spell) {
        return `${Parser.spLevelToFull(spell.level)}${spell.meta && spell.meta.ritual ? " (rit.)" : ""}${spell.meta && spell.meta.technomagic ? " (tec.)" : ""}`;
    }

    static getRaceFilterItem(r) {
        const addSuffix = (r.source === Parser.SRC_DMG || SourceUtil.isNonstandardSource(r.source || Parser.SRC_PHB) || (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(r.source || Parser.SRC_PHB)) || (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(r.source || Parser.SRC_PHB))) && !r.name.includes(Parser.sourceJsonToAbv(r.source));
        const name = `${r.name}${addSuffix ? ` (${Parser.sourceJsonToAbv(r.source)})` : ""}`;
        const opts = {
            item: name,
            userData: {
                group: SourceUtil.getFilterGroup(r.source || Parser.SRC_PHB),
            },
        };
        if (r.baseName)
            opts.nest = r.baseName;
        else
            opts.nest = "(No Subraces)";
        return new FilterItem(opts);
    }

    constructor() {
        super();

        this._classFilter = new Filter({
            header: "Class",
            groupFn: it=>it.userData.group,
        });
        this._subclassFilter = new Filter({
            header: "Subclass",
            nests: {},
            groupFn: it=>it.userData.group,
        });
        this._levelFilter = new Filter({
            header: "Level",
            items: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ],
            displayFn: (lvl)=>Parser.spLevelToFullLevelText(lvl, {
                isPluralCantrips: false
            }),
        });
        this._variantClassFilter = new VariantClassFilter();
        this._classAndSubclassFilter = new MultiFilterClasses({
            classFilter: this._classFilter,
            subclassFilter: this._subclassFilter,
            variantClassFilter: this._variantClassFilter,
        });
        this._raceFilter = new Filter({
            header: "Race",
            nests: {},
            groupFn: it=>it.userData.group,
        });
        this._backgroundFilter = new SearchableFilter({
            header: "Background"
        });
        this._featFilter = new SearchableFilter({
            header: "Feat"
        });
        this._optionalfeaturesFilter = new SearchableFilter({
            header: "Other Option/Feature"
        });
        this._metaFilter = new Filter({
            header: "Components & Miscellaneous",
            items: [...PageFilterSpells._META_FILTER_BASE_ITEMS, "Ritual", "SRD", "Basic Rules", "Has Images", "Has Token"],
            itemSortFn: PageFilterSpells.sortMetaFilter,
            isMiscFilter: true,
            displayFn: it=>Parser.spMiscTagToFull(it),
        });
        this._groupFilter = new Filter({
            header: "Group"
        });
        this._schoolFilter = new Filter({
            header: "School",
            items: [...Parser.SKL_ABVS],
            displayFn: Parser.spSchoolAbvToFull,
            itemSortFn: (a,b)=>SortUtil.ascSortLower(Parser.spSchoolAbvToFull(a.item), Parser.spSchoolAbvToFull(b.item)),
        });
        this._subSchoolFilter = new Filter({
            header: "Subschool",
            items: [],
            displayFn: it=>Parser.spSchoolAbvToFull(it).toTitleCase(),
            itemSortFn: (a,b)=>SortUtil.ascSortLower(Parser.spSchoolAbvToFull(a.item), Parser.spSchoolAbvToFull(b.item)),
        });
        this._damageFilter = new Filter({
            header: "Damage Type",
            items: MiscUtil.copy(Parser.DMG_TYPES),
            displayFn: StrUtil.uppercaseFirst,
        });
        this._conditionFilter = new Filter({
            header: "Conditions Inflicted",
            items: [...Parser.CONDITIONS],
            displayFn: uid=>uid.split("|")[0].toTitleCase(),
        });
        this._spellAttackFilter = new Filter({
            header: "Spell Attack",
            items: ["M", "R", "O"],
            displayFn: Parser.spAttackTypeToFull,
            itemSortFn: null,
        });
        this._saveFilter = new Filter({
            header: "Saving Throw",
            items: ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"],
            displayFn: PageFilterSpells.getFilterAbilitySave,
            itemSortFn: null,
        });
        this._checkFilter = new Filter({
            header: "Ability Check",
            items: ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"],
            displayFn: PageFilterSpells.getFilterAbilityCheck,
            itemSortFn: null,
        });
        this._timeFilter = new Filter({
            header: "Cast Time",
            items: [Parser.SP_TM_ACTION, Parser.SP_TM_B_ACTION, Parser.SP_TM_REACTION, Parser.SP_TM_ROUND, Parser.SP_TM_MINS, Parser.SP_TM_HRS, ],
            displayFn: Parser.spTimeUnitToFull,
            itemSortFn: null,
        });
        this._durationFilter = new RangeFilter({
            header: "Duration",
            isLabelled: true,
            labelSortFn: null,
            labels: ["Instant", "1 Round", "1 Minute", "10 Minutes", "1 Hour", "8 Hours", "24+ Hours", "Permanent", "Special"],
        });
        this._rangeFilter = new Filter({
            header: "Range",
            items: [PageFilterSpells.F_RNG_SELF, PageFilterSpells.F_RNG_TOUCH, PageFilterSpells.F_RNG_POINT, PageFilterSpells.F_RNG_SELF_AREA, PageFilterSpells.F_RNG_SPECIAL, ],
            itemSortFn: null,
        });
        this._areaTypeFilter = new Filter({
            header: "Area Style",
            items: ["ST", "MT", "R", "N", "C", "Y", "H", "L", "S", "Q", "W"],
            displayFn: Parser.spAreaTypeToFull,
            itemSortFn: null,
        });
        this._affectsCreatureTypeFilter = new Filter({
            header: "Affects Creature Types",
            items: [...Parser.MON_TYPES],
            displayFn: StrUtil.toTitleCase,
        });
    }

    static mutateForFilters(s) {
        Renderer.spell.initBrewSources(s);

        s._normalisedTime = PageFilterSpells.getNormalisedTime(s.time);
        s._normalisedRange = PageFilterSpells.getNormalisedRange(s.range);

        s._fSources = SourceFilter.getCompleteFilterSources(s);
        s._fMeta = PageFilterSpells.getMetaFilterObj(s);
        s._fClasses = Renderer.spell.getCombinedClasses(s, "fromClassList").map(c=>{
            return this._getClassFilterItem({
                className: c.name,
                definedInSource: c.definedInSource,
                classSource: c.source,
                isVariantClass: false,
            });
        }
        );
        s._fSubclasses = Renderer.spell.getCombinedClasses(s, "fromSubclass").map(c=>{
            return this._getSubclassFilterItem({
                className: c.class.name,
                classSource: c.class.source,
                subclassName: c.subclass.name,
                subclassShortName: c.subclass.shortName,
                subclassSource: c.subclass.source,
                subSubclassName: c.subclass.subSubclass,
            });
        }
        );
        s._fVariantClasses = Renderer.spell.getCombinedClasses(s, "fromClassListVariant").map(c=>{
            return this._getClassFilterItem({
                className: c.name,
                definedInSource: c.definedInSource,
                classSource: c.source,
                isVariantClass: true,
            });
        }
        );
        s._fClassesAndVariantClasses = [...s._fClasses, ...s._fVariantClasses.map(it=>(it.userData.definedInSource && !SourceUtil.isNonstandardSource(it.userData.definedInSource)) ? new FilterItem({
            item: it.userData.equivalentClassName
        }) : null).filter(Boolean).filter(it=>!s._fClasses.some(itCls=>itCls.item === it.item)), ];
        s._fRaces = Renderer.spell.getCombinedGeneric(s, {
            propSpell: "races",
            prop: "race"
        }).map(PageFilterSpells.getRaceFilterItem);
        s._fBackgrounds = Renderer.spell.getCombinedGeneric(s, {
            propSpell: "backgrounds",
            prop: "background"
        }).map(it=>it.name);
        s._fFeats = Renderer.spell.getCombinedGeneric(s, {
            propSpell: "feats",
            prop: "feat"
        }).map(it=>it.name);
        s._fOptionalfeatures = Renderer.spell.getCombinedGeneric(s, {
            propSpell: "optionalfeatures",
            prop: "optionalfeature"
        }).map(it=>it.name);
        s._fGroups = Renderer.spell.getCombinedGeneric(s, {
            propSpell: "groups"
        }).map(it=>it.name);
        s._fTimeType = s.time.map(t=>t.unit);
        s._fDurationType = PageFilterSpells.getFilterDuration(s);
        s._fRangeType = PageFilterSpells.getRangeType(s.range);

        s._fAreaTags = [...(s.areaTags || [])];
        if (s.range.type === "line" && !s._fAreaTags.includes("L"))
            s._fAreaTags.push("L");

        s._fAffectsCreatureType = s.affectsCreatureType || [...Parser.MON_TYPES];
    }

    static unmutateForFilters(s) {
        Renderer.spell.uninitBrewSources(s);

        delete s._normalisedTime;
        delete s._normalisedRange;

        Object.keys(s).filter(it=>it.startsWith("_f")).forEach(it=>delete s[it]);
    }

    addToFilters(s, isExcluded) {
        if (isExcluded)
            return;

        if (s.level > 9)
            this._levelFilter.addItem(s.level);
        this._groupFilter.addItem(s._fGroups);
        this._schoolFilter.addItem(s.school);
        this._sourceFilter.addItem(s._fSources);
        this._metaFilter.addItem(s._fMeta);
        this._backgroundFilter.addItem(s._fBackgrounds);
        this._featFilter.addItem(s._fFeats);
        this._optionalfeaturesFilter.addItem(s._fOptionalfeatures);
        s._fClasses.forEach(c=>this._classFilter.addItem(c));
        s._fSubclasses.forEach(sc=>{
            this._subclassFilter.addNest(sc.nest, {
                isHidden: true
            });
            this._subclassFilter.addItem(sc);
        }
        );
        s._fRaces.forEach(r=>{
            if (r.nest)
                this._raceFilter.addNest(r.nest, {
                    isHidden: true
                });
            this._raceFilter.addItem(r);
        }
        );
        s._fVariantClasses.forEach(c=>{
            this._variantClassFilter.addNest(c.nest, {
                isHidden: true
            });
            this._variantClassFilter.addItem(c);
        }
        );
        this._subSchoolFilter.addItem(s.subschools);
        this._conditionFilter.addItem(s.conditionInflict);
        this._affectsCreatureTypeFilter.addItem(s.affectsCreatureType);
    }

    async _pPopulateBoxOptions(opts) {
        await SourceUtil.pInitSubclassReprintLookup();

        opts.filters = [this._sourceFilter, this._levelFilter, this._classAndSubclassFilter, this._raceFilter, this._backgroundFilter, this._featFilter, this._optionalfeaturesFilter, this._metaFilter, this._groupFilter, this._schoolFilter, this._subSchoolFilter, this._damageFilter, this._conditionFilter, this._spellAttackFilter, this._saveFilter, this._checkFilter, this._timeFilter, this._durationFilter, this._rangeFilter, this._areaTypeFilter, this._affectsCreatureTypeFilter, ];
    }

    toDisplay(values, s) {
        return this._filterBox.toDisplay(values, s._fSources, s.level, [this._classAndSubclassFilter.isVariantSplit ? s._fClasses : s._fClassesAndVariantClasses, s._fSubclasses, this._classAndSubclassFilter.isVariantSplit ? s._fVariantClasses : null, ], s._fRaces, s._fBackgrounds, s._fFeats, s._fOptionalfeatures, s._fMeta, s._fGroups, s.school, s.subschools, s.damageInflict, s.conditionInflict, s.spellAttack, s.savingThrow, s.abilityCheck, s._fTimeType, s._fDurationType, s._fRangeType, s._fAreaTags, s._fAffectsCreatureType, );
    }
}
//#endregion

//#region PageFilterFeats
let PageFilterFeats$1 = class PageFilterFeats extends PageFilter {
    static _PREREQ_KEY_TO_FULL = {
        "other": "Special",
        "spellcasting2020": "Spellcasting",
        "spellcastingFeature": "Spellcasting",
        "spellcastingPrepared": "Spellcasting",
    };

    constructor() {
        super();

        this._asiFilter = new Filter({
            header: "Ability Bonus",
            items: ["str", "dex", "con", "int", "wis", "cha", ],
            displayFn: Parser.attAbvToFull,
            itemSortFn: null,
        });
        this._categoryFilter = new Filter({
            header: "Category",
            displayFn: StrUtil.toTitleCase,
        });
        this._otherPrereqFilter = new Filter({
            header: "Other",
            items: ["Ability", "Race", "Psionics", "Proficiency", "Special", "Spellcasting"],
        });
        this._levelFilter = new Filter({
            header: "Level",
            itemSortFn: SortUtil.ascSortNumericalSuffix,
        });
        this._prerequisiteFilter = new MultiFilter({
            header: "Prerequisite",
            filters: [this._otherPrereqFilter, this._levelFilter]
        });
        this._benefitsFilter = new Filter({
            header: "Benefits",
            items: ["Armor Proficiency", "Language Proficiency", "Skill Proficiency", "Spellcasting", "Tool Proficiency", "Weapon Proficiency", ],
        });
        this._vulnerableFilter = FilterCommon.getDamageVulnerableFilter();
        this._resistFilter = FilterCommon.getDamageResistFilter();
        this._immuneFilter = FilterCommon.getDamageImmuneFilter();
        this._defenceFilter = new MultiFilter({
            header: "Damage",
            filters: [this._vulnerableFilter, this._resistFilter, this._immuneFilter]
        });
        this._conditionImmuneFilter = FilterCommon.getConditionImmuneFilter();
        this._miscFilter = new Filter({
            header: "Miscellaneous",
            items: ["Has Info", "Has Images", "SRD", "Basic Rules"],
            isMiscFilter: true
        });
    }

    static mutateForFilters(feat) {
        const ability = Renderer.getAbilityData(feat.ability);
        feat._fAbility = ability.asCollection.filter(a=>!ability.areNegative.includes(a));
        const prereqText = Renderer.utils.prerequisite.getHtml(feat.prerequisite, {
            isListMode: true
        }) || VeCt.STR_NONE;

        feat._fPrereqOther = [...new Set((feat.prerequisite || []).flatMap(it=>Object.keys(it)))].map(it=>(this._PREREQ_KEY_TO_FULL[it] || it).uppercaseFirst());
        if (feat.prerequisite)
            feat._fPrereqLevel = feat.prerequisite.filter(it=>it.level != null).map(it=>`Level ${it.level.level ?? it.level}`);
        feat._fBenifits = [feat.resist ? "Damage Resistance" : null, feat.immune ? "Damage Immunity" : null, feat.conditionImmune ? "Condition Immunity" : null, feat.skillProficiencies ? "Skill Proficiency" : null, feat.additionalSpells ? "Spellcasting" : null, feat.armorProficiencies ? "Armor Proficiency" : null, feat.weaponProficiencies ? "Weapon Proficiency" : null, feat.toolProficiencies ? "Tool Proficiency" : null, feat.languageProficiencies ? "Language Proficiency" : null, ].filter(it=>it);
        if (feat.skillToolLanguageProficiencies?.length) {
            if (feat.skillToolLanguageProficiencies.some(it=>(it.choose || []).some(x=>x.from || [].includes("anySkill"))))
                feat._fBenifits.push("Skill Proficiency");
            if (feat.skillToolLanguageProficiencies.some(it=>(it.choose || []).some(x=>x.from || [].includes("anyTool"))))
                feat._fBenifits.push("Tool Proficiency");
            if (feat.skillToolLanguageProficiencies.some(it=>(it.choose || []).some(x=>x.from || [].includes("anyLanguage"))))
                feat._fBenifits.push("Language Proficiency");
        }
        feat._fMisc = feat.srd ? ["SRD"] : [];
        if (feat.basicRules)
            feat._fMisc.push("Basic Rules");
        if (feat.hasFluff || feat.fluff?.entries)
            feat._fMisc.push("Has Info");
        if (feat.hasFluffImages || feat.fluff?.images)
            feat._fMisc.push("Has Images");
        if (feat.repeatable != null)
            feat._fMisc.push(feat.repeatable ? "Repeatable" : "Not Repeatable");

        feat._slAbility = ability.asText || VeCt.STR_NONE;
        feat._slPrereq = prereqText;

        FilterCommon.mutateForFilters_damageVulnResImmune_player(feat);
        FilterCommon.mutateForFilters_conditionImmune_player(feat);
    }

    addToFilters(feat, isExcluded) {
        if (isExcluded)
            return;

        this._sourceFilter.addItem(feat.source);
        this._categoryFilter.addItem(feat.category);
        if (feat.prerequisite)
            this._levelFilter.addItem(feat._fPrereqLevel);
        this._vulnerableFilter.addItem(feat._fVuln);
        this._resistFilter.addItem(feat._fRes);
        this._immuneFilter.addItem(feat._fImm);
        this._conditionImmuneFilter.addItem(feat._fCondImm);
        this._benefitsFilter.addItem(feat._fBenifits);
        this._miscFilter.addItem(feat._fMisc);
    }

    async _pPopulateBoxOptions(opts) {
        opts.filters = [this._sourceFilter, this._asiFilter, this._categoryFilter, this._prerequisiteFilter, this._benefitsFilter, this._defenceFilter, this._conditionImmuneFilter, this._miscFilter, ];
    }

    toDisplay(values, ft) {
        return this._filterBox.toDisplay(values, ft.source, ft._fAbility, ft.category, [ft._fPrereqOther, ft._fPrereqLevel, ], ft._fBenifits, [ft._fVuln, ft._fRes, ft._fImm, ], ft._fCondImm, ft._fMisc, );
    }
}
;
//#endregion

//#region PageFilterEquipment
let PageFilterEquipment$1 = class PageFilterEquipment extends PageFilter {
    static _MISC_FILTER_ITEMS = ["Item Group", "Bundle", "SRD", "Basic Rules", "Has Images", "Has Info", "Reprinted", ];

    static _RE_FOUNDRY_ATTR = /(?:[-+*/]\s*)?@[a-z0-9.]+/gi;
    static _RE_DAMAGE_DICE_JUNK = /[^-+*/0-9d]/gi;
    static _RE_DAMAGE_DICE_D = /d/gi;

    static _getSortableDamageTerm(t) {
        try {
            return eval(`${t}`.replace(this._RE_FOUNDRY_ATTR, "").replace(this._RE_DAMAGE_DICE_JUNK, "").replace(this._RE_DAMAGE_DICE_D, "*"), );
        } catch (ignored) {
            return Number.MAX_SAFE_INTEGER;
        }
    }

    static _sortDamageDice(a, b) {
        return this._getSortableDamageTerm(a.item) - this._getSortableDamageTerm(b.item);
    }

    static _getMasteryDisplay(mastery) {
        const {name, source} = DataUtil.proxy.unpackUid("itemMastery", mastery, "itemMastery");
        if (SourceUtil.isSiteSource(source))
            return name.toTitleCase();
        return `${name.toTitleCase()} (${Parser.sourceJsonToAbv(source)})`;
    }

    constructor({filterOpts=null}={}) {
        super();

        this._typeFilter = new Filter({
            header: "Type",
            deselFn: (it)=>PageFilterItems$1._DEFAULT_HIDDEN_TYPES.has(it),
            displayFn: StrUtil.toTitleCase,
        });
        this._propertyFilter = new Filter({
            header: "Property",
            displayFn: StrUtil.toTitleCase
        });
        this._categoryFilter = new Filter({
            header: "Category",
            items: ["Basic", "Generic Variant", "Specific Variant", "Other"],
            deselFn: (it)=>it === "Specific Variant",
            itemSortFn: null,
            ...(filterOpts?.["Category"] || {}),
        });
        this._costFilter = new RangeFilter({
            header: "Cost",
            isLabelled: true,
            isAllowGreater: true,
            labelSortFn: null,
            labels: [0, ...[...new Array(9)].map((_,i)=>i + 1), ...[...new Array(9)].map((_,i)=>10 * (i + 1)), ...[...new Array(100)].map((_,i)=>100 * (i + 1)), ],
            labelDisplayFn: it=>!it ? "None" : Parser.getDisplayCurrency(CurrencyUtil.doSimplifyCoins({
                cp: it
            })),
        });
        this._weightFilter = new RangeFilter({
            header: "Weight",
            min: 0,
            max: 100,
            isAllowGreater: true,
            suffix: " lb."
        });
        this._focusFilter = new Filter({
            header: "Spellcasting Focus",
            items: [...Parser.ITEM_SPELLCASTING_FOCUS_CLASSES]
        });
        this._damageTypeFilter = new Filter({
            header: "Weapon Damage Type",
            displayFn: it=>Parser.dmgTypeToFull(it).uppercaseFirst(),
            itemSortFn: (a,b)=>SortUtil.ascSortLower(Parser.dmgTypeToFull(a), Parser.dmgTypeToFull(b))
        });
        this._damageDiceFilter = new Filter({
            header: "Weapon Damage Dice",
            items: ["1", "1d4", "1d6", "1d8", "1d10", "1d12", "2d6"],
            itemSortFn: (a,b)=>PageFilterEquipment$1._sortDamageDice(a, b)
        });
        this._miscFilter = new Filter({
            header: "Miscellaneous",
            items: [...PageFilterEquipment$1._MISC_FILTER_ITEMS, ...Object.values(Parser.ITEM_MISC_TAG_TO_FULL)],
            isMiscFilter: true,
        });
        this._poisonTypeFilter = new Filter({
            header: "Poison Type",
            items: ["ingested", "injury", "inhaled", "contact"],
            displayFn: StrUtil.toTitleCase
        });
        this._masteryFilter = new Filter({
            header: "Mastery",
            displayFn: this.constructor._getMasteryDisplay.bind(this)
        });
    }

    static mutateForFilters(item) {
        item._fSources = SourceFilter.getCompleteFilterSources(item);

        item._fProperties = item.property ? item.property.map(p=>Renderer.item.getProperty(p).name).filter(n=>n) : [];

        item._fMisc = [];
        if (item._isItemGroup)
            item._fMisc.push("Item Group");
        if (item.packContents)
            item._fMisc.push("Bundle");
        if (item.srd)
            item._fMisc.push("SRD");
        if (item.basicRules)
            item._fMisc.push("Basic Rules");
        if (item.hasFluff || item.fluff?.entries)
            item._fMisc.push("Has Info");
        if (item.hasFluffImages || item.fluff?.images)
            item._fMisc.push("Has Images");
        if (item.miscTags)
            item._fMisc.push(...item.miscTags.map(Parser.itemMiscTagToFull));
        if (this._isReprinted({
            reprintedAs: item.reprintedAs,
            tag: "item",
            prop: "item",
            page: UrlUtil.PG_ITEMS
        }))
            item._fMisc.push("Reprinted");

        if (item.focus || item.name === "Thieves' Tools" || item.type === "INS" || item.type === "SCF" || item.type === "AT") {
            item._fFocus = item.focus ? item.focus === true ? [...Parser.ITEM_SPELLCASTING_FOCUS_CLASSES] : [...item.focus] : [];
            if ((item.name === "Thieves' Tools" || item.type === "AT") && !item._fFocus.includes("Artificer"))
                item._fFocus.push("Artificer");
            if (item.type === "INS" && !item._fFocus.includes("Bard"))
                item._fFocus.push("Bard");
            if (item.type === "SCF") {
                switch (item.scfType) {
                case "arcane":
                    {
                        if (!item._fFocus.includes("Sorcerer"))
                            item._fFocus.push("Sorcerer");
                        if (!item._fFocus.includes("Warlock"))
                            item._fFocus.push("Warlock");
                        if (!item._fFocus.includes("Wizard"))
                            item._fFocus.push("Wizard");
                        break;
                    }
                case "druid":
                    {
                        if (!item._fFocus.includes("Druid"))
                            item._fFocus.push("Druid");
                        break;
                    }
                case "holy":
                    if (!item._fFocus.includes("Cleric"))
                        item._fFocus.push("Cleric");
                    if (!item._fFocus.includes("Paladin"))
                        item._fFocus.push("Paladin");
                    break;
                }
            }
        }

        item._fValue = Math.round(item.value || 0);

        item._fDamageDice = [];
        if (item.dmg1)
            item._fDamageDice.push(item.dmg1);
        if (item.dmg2)
            item._fDamageDice.push(item.dmg2);

        item._fMastery = item.mastery ? item.mastery.map(it=>{
            const {name, source} = DataUtil.proxy.unpackUid("itemMastery", it, "itemMastery", {
                isLower: true
            });
            return [name, source].join("|");
        }
        ) : null;
    }

    addToFilters(item, isExcluded) {
        if (isExcluded)
            return;

        this._sourceFilter.addItem(item._fSources);
        this._typeFilter.addItem(item._typeListText);
        this._propertyFilter.addItem(item._fProperties);
        this._damageTypeFilter.addItem(item.dmgType);
        this._damageDiceFilter.addItem(item._fDamageDice);
        this._poisonTypeFilter.addItem(item.poisonTypes);
        this._miscFilter.addItem(item._fMisc);
        this._masteryFilter.addItem(item._fMastery);
    }

    async _pPopulateBoxOptions(opts) {
        opts.filters = [this._sourceFilter, this._typeFilter, this._propertyFilter, this._categoryFilter, this._costFilter, this._weightFilter, this._focusFilter, this._damageTypeFilter, this._damageDiceFilter, this._miscFilter, this._poisonTypeFilter, this._masteryFilter, ];
    }

    toDisplay(values, it) {
        return this._filterBox.toDisplay(values, it._fSources, it._typeListText, it._fProperties, it._category, it._fValue, it.weight, it._fFocus, it.dmgType, it._fDamageDice, it._fMisc, it.poisonTypes, it._fMastery, );
    }
};
//#endregion

//#region PageFilterItems
let PageFilterItems$1 = class PageFilterItems extends PageFilterEquipment$1 {
    static _DEFAULT_HIDDEN_TYPES = new Set(["treasure", "futuristic", "modern", "renaissance"]);
    static _FILTER_BASE_ITEMS_ATTUNEMENT = ["Requires Attunement", "Requires Attunement By...", "Attunement Optional", VeCt.STR_NO_ATTUNEMENT];

    static sortItems(a, b, o) {
        if (o.sortBy === "name")
            return SortUtil.compareListNames(a, b);
        else if (o.sortBy === "type")
            return SortUtil.ascSortLower(a.values.type, b.values.type) || SortUtil.compareListNames(a, b);
        else if (o.sortBy === "source")
            return SortUtil.ascSortLower(a.values.source, b.values.source) || SortUtil.compareListNames(a, b);
        else if (o.sortBy === "rarity")
            return SortUtil.ascSortItemRarity(a.values.rarity, b.values.rarity) || SortUtil.compareListNames(a, b);
        else if (o.sortBy === "attunement")
            return SortUtil.ascSort(a.values.attunement, b.values.attunement) || SortUtil.compareListNames(a, b);
        else if (o.sortBy === "count")
            return SortUtil.ascSort(a.data.count, b.data.count) || SortUtil.compareListNames(a, b);
        else if (o.sortBy === "weight")
            return SortUtil.ascSort(a.values.weight, b.values.weight) || SortUtil.compareListNames(a, b);
        else if (o.sortBy === "cost")
            return SortUtil.ascSort(a.values.cost, b.values.cost) || SortUtil.compareListNames(a, b);
        else
            return 0;
    }

    static _getBaseItemDisplay(baseItem) {
        if (!baseItem)
            return null;
        let[name,source] = baseItem.split("__");
        name = name.toTitleCase();
        source = source || Parser.SRC_DMG;
        if (source.toLowerCase() === Parser.SRC_PHB.toLowerCase())
            return name;
        return `${name} (${Parser.sourceJsonToAbv(source)})`;
    }

    static _sortAttunementFilter(a, b) {
        const ixA = PageFilterItems$1._FILTER_BASE_ITEMS_ATTUNEMENT.indexOf(a.item);
        const ixB = PageFilterItems$1._FILTER_BASE_ITEMS_ATTUNEMENT.indexOf(b.item);

        if (~ixA && ~ixB)
            return ixA - ixB;
        if (~ixA)
            return -1;
        if (~ixB)
            return 1;
        return SortUtil.ascSortLower(a, b);
    }

    static _getAttunementFilterItems(item) {
        const out = item._attunementCategory ? [item._attunementCategory] : [];

        if (!item.reqAttuneTags && !item.reqAttuneAltTags)
            return out;

        [...item.reqAttuneTags || [], ...item.reqAttuneAltTags || []].forEach(tagSet=>{
            Object.entries(tagSet).forEach(([prop,val])=>{
                switch (prop) {
                case "background":
                    out.push(`Background: ${val.split("|")[0].toTitleCase()}`);
                    break;
                case "languageProficiency":
                    out.push(`Language Proficiency: ${val.toTitleCase()}`);
                    break;
                case "skillProficiency":
                    out.push(`Skill Proficiency: ${val.toTitleCase()}`);
                    break;
                case "race":
                    out.push(`Race: ${val.split("|")[0].toTitleCase()}`);
                    break;
                case "creatureType":
                    out.push(`Creature Type: ${val.toTitleCase()}`);
                    break;
                case "size":
                    out.push(`Size: ${Parser.sizeAbvToFull(val)}`.toTitleCase());
                    break;
                case "class":
                    out.push(`Class: ${val.split("|")[0].toTitleCase()}`);
                    break;
                case "alignment":
                    out.push(`Alignment: ${Parser.alignmentListToFull(val).toTitleCase()}`);
                    break;

                case "str":
                case "dex":
                case "con":
                case "int":
                case "wis":
                case "cha":
                    out.push(`${Parser.attAbvToFull(prop)}: ${val} or Higher`);
                    break;

                case "spellcasting":
                    out.push("Spellcaster");
                    break;
                case "psionics":
                    out.push("Psionics");
                    break;
                }
            }
            );
        }
        );

        return out;
    }

    constructor(opts) {
        super(opts);

        this._tierFilter = new Filter({
            header: "Tier",
            items: ["none", "minor", "major"],
            itemSortFn: null,
            displayFn: StrUtil.toTitleCase
        });
        this._attachedSpellsFilter = new SearchableFilter({
            header: "Attached Spells",
            displayFn: (it)=>it.split("|")[0].toTitleCase(),
            itemSortFn: SortUtil.ascSortLower
        });
        this._lootTableFilter = new Filter({
            header: "Found On",
            items: ["Magic Item Table A", "Magic Item Table B", "Magic Item Table C", "Magic Item Table D", "Magic Item Table E", "Magic Item Table F", "Magic Item Table G", "Magic Item Table H", "Magic Item Table I"],
            displayFn: it=>{
                const [name,sourceJson] = it.split("|");
                return `${name}${sourceJson ? ` (${Parser.sourceJsonToAbv(sourceJson)})` : ""}`;
            }
            ,
        });
        this._rarityFilter = new Filter({
            header: "Rarity",
            items: [...Parser.ITEM_RARITIES],
            itemSortFn: null,
            displayFn: StrUtil.toTitleCase,
        });
        this._attunementFilter = new Filter({
            header: "Attunement",
            items: [...PageFilterItems$1._FILTER_BASE_ITEMS_ATTUNEMENT],
            itemSortFn: PageFilterItems$1._sortAttunementFilter
        });
        this._bonusFilter = new Filter({
            header: "Bonus",
            items: ["Armor Class", "Proficiency Bonus", "Spell Attacks", "Spell Save DC", "Saving Throws", ...([...new Array(4)]).map((_,i)=>`Weapon Attack and Damage Rolls${i ? ` (+${i})` : ""}`), ...([...new Array(4)]).map((_,i)=>`Weapon Attack Rolls${i ? ` (+${i})` : ""}`), ...([...new Array(4)]).map((_,i)=>`Weapon Damage Rolls${i ? ` (+${i})` : ""}`), ],
            itemSortFn: null,
        });
        this._rechargeTypeFilter = new Filter({
            header: "Recharge Type",
            displayFn: Parser.itemRechargeToFull
        });
        this._miscFilter = new Filter({
            header: "Miscellaneous",
            items: ["Ability Score Adjustment", "Charges", "Cursed", "Grants Language", "Grants Proficiency", "Magic", "Mundane", "Sentient", "Speed Adjustment", ...PageFilterEquipment$1._MISC_FILTER_ITEMS],
            isMiscFilter: true
        });
        this._baseSourceFilter = new SourceFilter({
            header: "Base Source",
            selFn: null
        });
        this._baseItemFilter = new Filter({
            header: "Base Item",
            displayFn: this.constructor._getBaseItemDisplay.bind(this.constructor)
        });
        this._optionalfeaturesFilter = new Filter({
            header: "Feature",
            displayFn: (it)=>{
                const [name,source] = it.split("|");
                if (!source)
                    return name.toTitleCase();
                const sourceJson = Parser.sourceJsonToJson(source);
                if (!SourceUtil.isNonstandardSourceWotc(sourceJson))
                    return name.toTitleCase();
                return `${name.toTitleCase()} (${Parser.sourceJsonToAbv(sourceJson)})`;
            }
            ,
            itemSortFn: SortUtil.ascSortLower,
        });
    }

    static mutateForFilters(item) {
        super.mutateForFilters(item);

        item._fTier = [item.tier ? item.tier : "none"];

        if (item.curse)
            item._fMisc.push("Cursed");
        const isMundane = Renderer.item.isMundane(item);
        item._fMisc.push(isMundane ? "Mundane" : "Magic");
        item._fIsMundane = isMundane;
        if (item.ability)
            item._fMisc.push("Ability Score Adjustment");
        if (item.modifySpeed)
            item._fMisc.push("Speed Adjustment");
        if (item.charges)
            item._fMisc.push("Charges");
        if (item.sentient)
            item._fMisc.push("Sentient");
        if (item.grantsProficiency)
            item._fMisc.push("Grants Proficiency");
        if (item.grantsLanguage)
            item._fMisc.push("Grants Language");
        if (item.critThreshold)
            item._fMisc.push("Expanded Critical Range");

        const fBaseItemSelf = item._isBaseItem ? `${item.name}__${item.source}`.toLowerCase() : null;
        item._fBaseItem = [item.baseItem ? (item.baseItem.includes("|") ? item.baseItem.replace("|", "__") : `${item.baseItem}__${Parser.SRC_DMG}`).toLowerCase() : null, item._baseName ? `${item._baseName}__${item._baseSource || item.source}`.toLowerCase() : null, ].filter(Boolean);
        item._fBaseItemAll = fBaseItemSelf ? [fBaseItemSelf, ...item._fBaseItem] : item._fBaseItem;

        item._fBonus = [];
        if (item.bonusAc)
            item._fBonus.push("Armor Class");
        this._mutateForFilters_bonusWeapon({
            prop: "bonusWeapon",
            item,
            text: "Weapon Attack and Damage Rolls"
        });
        this._mutateForFilters_bonusWeapon({
            prop: "bonusWeaponAttack",
            item,
            text: "Weapon Attack Rolls"
        });
        this._mutateForFilters_bonusWeapon({
            prop: "bonusWeaponDamage",
            item,
            text: "Weapon Damage Rolls"
        });
        if (item.bonusWeaponCritDamage)
            item._fBonus.push("Weapon Critical Damage");
        if (item.bonusSpellAttack)
            item._fBonus.push("Spell Attacks");
        if (item.bonusSpellSaveDc)
            item._fBonus.push("Spell Save DC");
        if (item.bonusSavingThrow)
            item._fBonus.push("Saving Throws");
        if (item.bonusProficiencyBonus)
            item._fBonus.push("Proficiency Bonus");

        item._fAttunement = this._getAttunementFilterItems(item);
    }

    static _mutateForFilters_bonusWeapon({prop, item, text}) {
        if (!item[prop])
            return;
        item._fBonus.push(text);
        switch (item[prop]) {
        case "+1":
        case "+2":
        case "+3":
            item._fBonus.push(`${text} (${item[prop]})`);
            break;
        }
    }

    addToFilters(item, isExcluded) {
        if (isExcluded)
            return;

        super.addToFilters(item, isExcluded);

        this._sourceFilter.addItem(item.source);
        this._tierFilter.addItem(item._fTier);
        this._attachedSpellsFilter.addItem(item.attachedSpells);
        this._lootTableFilter.addItem(item.lootTables);
        this._baseItemFilter.addItem(item._fBaseItem);
        this._baseSourceFilter.addItem(item._baseSource);
        this._attunementFilter.addItem(item._fAttunement);
        this._rechargeTypeFilter.addItem(item.recharge);
        this._optionalfeaturesFilter.addItem(item.optionalfeatures);
    }

    async _pPopulateBoxOptions(opts) {
        await super._pPopulateBoxOptions(opts);

        opts.filters = [this._sourceFilter, this._typeFilter, this._tierFilter, this._rarityFilter, this._propertyFilter, this._attunementFilter, this._categoryFilter, this._costFilter, this._weightFilter, this._focusFilter, this._damageTypeFilter, this._damageDiceFilter, this._bonusFilter, this._miscFilter, this._rechargeTypeFilter, this._poisonTypeFilter, this._masteryFilter, this._lootTableFilter, this._baseItemFilter, this._baseSourceFilter, this._optionalfeaturesFilter, this._attachedSpellsFilter, ];
    }

    toDisplay(values, it) {
        return this._filterBox.toDisplay(values, it._fSources, it._typeListText, it._fTier, it.rarity, it._fProperties, it._fAttunement, it._category, it._fValue, it.weight, it._fFocus, it.dmgType, it._fDamageDice, it._fBonus, it._fMisc, it.recharge, it.poisonTypes, it._fMastery, it.lootTables, it._fBaseItemAll, it._baseSource, it.optionalfeatures, it.attachedSpells, );
    }
}
;
//#endregion

class VariantClassFilter extends Filter {
    constructor(opts) {
        super({
            header: "Optional/Variant Class",
            nests: {},
            groupFn: it=>it.userData.group,
            ...opts,
        });

        this._parent = null;
    }

    set parent(multiFilterClasses) {
        this._parent = multiFilterClasses;
    }

    handleVariantSplit(isVariantSplit) {
        this.__$wrpFilter.toggleVe(isVariantSplit);
    }
}
class MultiFilterClasses extends MultiFilter {
    constructor(opts) {
        super({
            header: "Classes",
            mode: "or",
            filters: [opts.classFilter, opts.subclassFilter, opts.variantClassFilter],
            ...opts
        });

        this._classFilter = opts.classFilter;
        this._subclassFilter = opts.subclassFilter;
        this._variantClassFilter = opts.variantClassFilter;

        this._variantClassFilter.parent = this;
    }

    get classFilter_() {
        return this._classFilter;
    }
    get isVariantSplit() {
        return this._meta.isVariantSplit;
    }

    $render(opts) {
        const $out = super.$render(opts);

        const hkVariantSplit = ()=>this._variantClassFilter.handleVariantSplit(this._meta.isVariantSplit);
        this._addHook("meta", "isVariantSplit", hkVariantSplit);
        hkVariantSplit();

        return $out;
    }

    _getHeaderControls_addExtraStateBtns(opts, wrpStateBtnsOuter) {
        const btnToggleVariantSplit = ComponentUiUtil.getBtnBool(this, "isVariantSplit", {
            ele: e_({
                tag: "button",
                clazz: "btn btn-default btn-xs",
                text: "Include Variants"
            }),
            isInverted: true,
            stateName: "meta",
            stateProp: "_meta",
            title: `If "Optional/Variant Class" spell lists should be treated as part of the "Class" filter.`,
        }, );

        e_({
            tag: "div",
            clazz: `btn-group w-100 ve-flex-v-center mobile__m-1 mobile__mb-2`,
            children: [btnToggleVariantSplit, ],
        }).prependTo(wrpStateBtnsOuter);
    }

    getDefaultMeta() {
        return {
            ...MultiFilterClasses._DEFAULT_META,
            ...super.getDefaultMeta()
        };
    }
}
MultiFilterClasses._DEFAULT_META = {
    isVariantSplit: false,
};
class SearchableFilter extends Filter {
    constructor(opts) {
        super(opts);

        this._compSearch = BaseComponent.fromObject({
            search: "",
            searchTermParent: "",
        });
    }

    handleSearch(searchTerm) {
        const out = super.handleSearch(searchTerm);

        this._compSearch._state.searchTermParent = searchTerm;

        return out;
    }

    _getPill(item) {
        const btnPill = super._getPill(item);

        const hkIsVisible = ()=>{
            if (this._compSearch._state.searchTermParent)
                return btnPill.toggleClass("fltr__hidden--inactive", false);

            btnPill.toggleClass("fltr__hidden--inactive", this._state[item.item] === 0);
        }
        ;
        this._addHook("state", item.item, hkIsVisible);
        this._compSearch._addHookBase("searchTermParent", hkIsVisible);
        hkIsVisible();

        return btnPill;
    }

    _getPill_handleClick({evt, item}) {
        if (this._compSearch._state.searchTermParent)
            return super._getPill_handleClick({
                evt,
                item
            });

        this._state[item.item] = 0;
    }

    _getPill_handleContextmenu({evt, item}) {
        if (this._compSearch._state.searchTermParent)
            return super._getPill_handleContextmenu({
                evt,
                item
            });

        evt.preventDefault();
        this._state[item.item] = 0;
    }

    _$render_getRowBtn({fnsCleanup, $iptSearch, item, subtype, state}) {
        const handleClick = evt=>{
            evt.stopPropagation();
            evt.preventDefault();

            $iptSearch.focus();

            if (evt.shiftKey) {
                this._doSetPillsClear();
            }

            if (this._state[item.item] === state)
                this._state[item.item] = 0;
            else
                this._state[item.item] = state;
        }
        ;

        const btn = e_({
            tag: "div",
            clazz: `no-shrink clickable fltr-search__btn-activate fltr-search__btn-activate--${subtype} ve-flex-vh-center`,
            click: evt=>handleClick(evt),
            contextmenu: evt=>handleClick(evt),
            mousedown: evt=>{
                evt.stopPropagation();
                evt.preventDefault();
            }
            ,
        });

        const hkIsActive = ()=>{
            btn.innerText = this._state[item.item] === state ? "×" : "";
        }
        ;
        this._addHookBase(item.item, hkIsActive);
        hkIsActive();
        fnsCleanup.push(()=>this._removeHookBase(item.item, hkIsActive));

        return btn;
    }

    $render(opts) {
        const $out = super.$render(opts);

        const $iptSearch = ComponentUiUtil.$getIptStr(this._compSearch, "search", {
            html: `<input class="form-control form-control--minimal input-xs" placeholder="Search...">`,
        }, );

        const wrpValues = e_({
            tag: "div",
            clazz: "overflow-y-auto bt-0 absolute fltr-search__wrp-values",
        });

        const fnsCleanup = [];
        const rowMetas = [];

        this._$render_bindSearchHandler_keydown({
            $iptSearch,
            fnsCleanup,
            rowMetas
        });
        this._$render_bindSearchHandler_focus({
            $iptSearch,
            fnsCleanup,
            rowMetas,
            wrpValues
        });
        this._$render_bindSearchHandler_blur({
            $iptSearch
        });

        const $wrp = $$`<div class="fltr-search__wrp-search ve-flex-col relative mt-1 mx-2p mb-1">
			${$iptSearch}
			${wrpValues}
		</div>`.prependTo(this.__wrpPills);

        const hkParentSearch = ()=>{
            $wrp.toggleVe(!this._compSearch._state.searchTermParent);
        }
        ;
        this._compSearch._addHookBase("searchTermParent", hkParentSearch);
        hkParentSearch();

        return $out;
    }

    _$render_bindSearchHandler_keydown({$iptSearch, rowMetas}) {
        $iptSearch.on("keydown", evt=>{
            switch (evt.key) {
            case "Escape":
                evt.stopPropagation();
                return $iptSearch.blur();

            case "ArrowDown":
                {
                    evt.preventDefault();
                    const visibleRowMetas = rowMetas.filter(it=>it.isVisible);
                    if (!visibleRowMetas.length)
                        return;
                    visibleRowMetas[0].row.focus();
                    break;
                }

            case "Enter":
                {
                    const visibleRowMetas = rowMetas.filter(it=>it.isVisible);
                    if (!visibleRowMetas.length)
                        return;
                    if (evt.shiftKey)
                        this._doSetPillsClear();
                    this._state[visibleRowMetas[0].item.item] = (EventUtil.isCtrlMetaKey(evt)) ? 2 : 1;
                    $iptSearch.blur();
                    break;
                }
            }
        }
        );
    }

    _$render_bindSearchHandler_focus({$iptSearch, fnsCleanup, rowMetas, wrpValues}) {
        $iptSearch.on("focus", ()=>{
            fnsCleanup.splice(0, fnsCleanup.length).forEach(fn=>fn());

            rowMetas.splice(0, rowMetas.length);

            wrpValues.innerHTML = "";

            rowMetas.push(...this._items.map(item=>this._$render_bindSearchHandler_focus_getRowMeta({
                $iptSearch,
                fnsCleanup,
                rowMetas,
                wrpValues,
                item
            })), );

            this._$render_bindSearchHandler_focus_addHookSearch({
                rowMetas,
                fnsCleanup
            });

            wrpValues.scrollIntoView({
                block: "nearest",
                inline: "nearest"
            });
        }
        );
    }

    _$render_bindSearchHandler_focus_getRowMeta({$iptSearch, fnsCleanup, rowMetas, wrpValues, item}) {
        const dispName = this._getDisplayText(item);

        const eleName = e_({
            tag: "div",
            clazz: "fltr-search__disp-name ml-2",
        });

        const btnBlue = this._$render_getRowBtn({
            fnsCleanup,
            $iptSearch,
            item,
            subtype: "yes",
            state: 1,
        });
        btnBlue.addClass("br-0");
        btnBlue.addClass("btr-0");
        btnBlue.addClass("bbr-0");

        const btnRed = this._$render_getRowBtn({
            fnsCleanup,
            $iptSearch,
            item,
            subtype: "no",
            state: 2,
        });
        btnRed.addClass("bl-0");
        btnRed.addClass("btl-0");
        btnRed.addClass("bbl-0");

        const row = e_({
            tag: "div",
            clazz: "py-1p px-2 ve-flex-v-center fltr-search__wrp-row",
            children: [btnBlue, btnRed, eleName, ],
            attrs: {
                tabindex: "0",
            },
            keydown: evt=>{
                switch (evt.key) {
                case "Escape":
                    evt.stopPropagation();
                    return row.blur();

                case "ArrowDown":
                    {
                        evt.preventDefault();
                        const visibleRowMetas = rowMetas.filter(it=>it.isVisible);
                        if (!visibleRowMetas.length)
                            return;
                        const ixCur = visibleRowMetas.indexOf(out);
                        const nxt = visibleRowMetas[ixCur + 1];
                        if (nxt)
                            nxt.row.focus();
                        break;
                    }

                case "ArrowUp":
                    {
                        evt.preventDefault();
                        const visibleRowMetas = rowMetas.filter(it=>it.isVisible);
                        if (!visibleRowMetas.length)
                            return;
                        const ixCur = visibleRowMetas.indexOf(out);
                        const prev = visibleRowMetas[ixCur - 1];
                        if (prev)
                            return prev.row.focus();
                        $iptSearch.focus();
                        break;
                    }

                case "Enter":
                    {
                        if (evt.shiftKey)
                            this._doSetPillsClear();
                        this._state[item.item] = (EventUtil.isCtrlMetaKey(evt)) ? 2 : 1;
                        row.blur();
                        break;
                    }
                }
            }
            ,
        });

        wrpValues.appendChild(row);

        const out = {
            isVisible: true,
            item,
            row,
            dispName,
            eleName,
        };

        return out;
    }

    _$render_bindSearchHandler_focus_addHookSearch({rowMetas, fnsCleanup}) {
        const hkSearch = ()=>{
            const searchTerm = this._compSearch._state.search.toLowerCase();

            rowMetas.forEach(({item, row})=>{
                row.isVisible = item.searchText.includes(searchTerm);
                row.toggleVe(row.isVisible);
            }
            );

            if (!this._compSearch._state.search) {
                rowMetas.forEach(({dispName, eleName})=>eleName.textContent = dispName);
                return;
            }

            const re = new RegExp(this._compSearch._state.search.qq().escapeRegexp(),"gi");

            rowMetas.forEach(({dispName, eleName})=>{
                eleName.innerHTML = dispName.qq().replace(re, (...m)=>`<u>${m[0]}</u>`);
            }
            );
        }
        ;
        this._compSearch._addHookBase("search", hkSearch);
        hkSearch();
        fnsCleanup.push(()=>this._compSearch._removeHookBase("search", hkSearch));
    }

    _$render_bindSearchHandler_blur({$iptSearch}) {
        $iptSearch.on("blur", ()=>{
            this._compSearch._state.search = "";
        }
        );
    }
}

//#endregion

//#region Modals    

//#region ModalFilter
class ModalFilter {
    static _$getFilterColumnHeaders(btnMeta) {
        return btnMeta.map((it,i)=>$(`<button class="col-${it.width} ${i === 0 ? "pl-0" : i === btnMeta.length ? "pr-0" : ""} ${it.disabled ? "" : "sort"} btn btn-default btn-xs" ${it.disabled ? "" : `data-sort="${it.sort}"`} ${it.title ? `title="${it.title}"` : ""} ${it.disabled ? "disabled" : ""}>${it.text}</button>`));
    }

    constructor(opts) {
        this._modalTitle = opts.modalTitle;
        this._fnSort = opts.fnSort;
        this._pageFilter = opts.pageFilter;
        this._namespace = opts.namespace;
        this._allData = opts.allData || null; //This is all data (classes, races, etc) that we are provided
        this._isRadio = !!opts.isRadio;

        this._list = null;
        this._filterCache = null;
    }

    /**
     * @returns {PageFilter}
     */
    get pageFilter() {return this._pageFilter;}
    get allData() { return this._allData;}

    _$getWrpList() {
        return $(`<div class="list ui-list__wrp overflow-x-hidden overflow-y-auto h-100 min-h-0"></div>`);
    }

    _$getColumnHeaderPreviewAll(opts) {
        return $(`<button class="btn btn-default btn-xs ${opts.isBuildUi ? "col-1" : "col-0-5"}">${ListUiUtil.HTML_GLYPHICON_EXPAND}</button>`);
    }

    async pPopulateWrapper($wrp, opts) {
        opts = opts || {};

        await this._pInit();

        const $ovlLoading = $(`<div class="w-100 h-100 ve-flex-vh-center"><i class="dnd-font ve-muted">Loading...</i></div>`).appendTo($wrp);

        const $iptSearch = (opts.$iptSearch || $(`<input class="form-control lst__search lst__search--no-border-h h-100" type="search" placeholder="Search...">`)).disableSpellcheck();
        const $btnReset = opts.$btnReset || $(`<button class="btn btn-default">Reset</button>`);
        const $dispNumVisible = $(`<div class="lst__wrp-search-visible no-events ve-flex-vh-center"></div>`);

        const $wrpIptSearch = $$`<div class="w-100 relative">
			${$iptSearch}
			<div class="lst__wrp-search-glass no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>
			${$dispNumVisible}
		</div>`;

        const $wrpFormTop = $$`<div class="ve-flex input-group btn-group w-100 lst__form-top">${$wrpIptSearch}${$btnReset}</div>`;

        const $wrpFormBottom = opts.$wrpMiniPills || $(`<div class="w-100"></div>`);

        const $wrpFormHeaders = $(`<div class="input-group input-group--bottom ve-flex no-shrink"></div>`);
        const $cbSelAll = opts.isBuildUi || this._isRadio ? null : $(`<input type="checkbox">`);
        const $btnSendAllToRight = opts.isBuildUi ? $(`<button class="btn btn-xxs btn-default col-1" title="Add All"><span class="glyphicon glyphicon-arrow-right"></span></button>`) : null;

        if (!opts.isBuildUi) {
            if (this._isRadio)
                $wrpFormHeaders.append(`<label class="btn btn-default btn-xs col-0-5 ve-flex-vh-center" disabled></label>`);
            else
                $$`<label class="btn btn-default btn-xs col-0-5 ve-flex-vh-center">${$cbSelAll}</label>`.appendTo($wrpFormHeaders);
        }

        const $btnTogglePreviewAll = this._$getColumnHeaderPreviewAll(opts).appendTo($wrpFormHeaders);

        this._$getColumnHeaders().forEach($ele=>$wrpFormHeaders.append($ele));
        if (opts.isBuildUi)
            $btnSendAllToRight.appendTo($wrpFormHeaders);

        const $wrpForm = $$`<div class="ve-flex-col w-100 mb-1">${$wrpFormTop}${$wrpFormBottom}${$wrpFormHeaders}</div>`;
        const $wrpList = this._$getWrpList();

        const $btnConfirm = opts.isBuildUi ? null : $(`<button class="btn btn-default">Confirm</button>`);

        this._list = new List({
            $iptSearch,
            $wrpList,
            fnSort: this._fnSort,
        });
        const listSelectClickHandler = new ListSelectClickHandler({
            list: this._list
        });

        if (!opts.isBuildUi && !this._isRadio)
            listSelectClickHandler.bindSelectAllCheckbox($cbSelAll);
        ListUiUtil.bindPreviewAllButton($btnTogglePreviewAll, this._list);
        SortUtil.initBtnSortHandlers($wrpFormHeaders, this._list);
        this._list.on("updated", ()=>$dispNumVisible.html(`${this._list.visibleItems.length}/${this._list.items.length}`));

        this._allData = this._allData || await this._pLoadAllData();

        await this._pageFilter.pInitFilterBox({
            $wrpFormTop,
            $btnReset,
            $wrpMiniPills: $wrpFormBottom,
            namespace: this._namespace,
            $btnOpen: opts.$btnOpen,
            $btnToggleSummaryHidden: opts.$btnToggleSummaryHidden,
        });

        this._allData.forEach((it,i)=>{
            this._pageFilter.mutateAndAddToFilters(it);
            const filterListItem = this._getListItem(this._pageFilter, it, i);
            this._list.addItem(filterListItem);
            if (!opts.isBuildUi) {
                if (this._isRadio)
                    filterListItem.ele.addEventListener("click", evt=>listSelectClickHandler.handleSelectClickRadio(filterListItem, evt));
                else
                    filterListItem.ele.addEventListener("click", evt=>listSelectClickHandler.handleSelectClick(filterListItem, evt));
            }
        }
        );

        this._list.init();
        this._list.update();

        const handleFilterChange = ()=>{
            const f = this._pageFilter.filterBox.getValues();
            this._list.filter(li=>this._isListItemMatchingFilter(f, li));
        }
        ;

        this._pageFilter.trimState();

        this._pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, handleFilterChange);
        this._pageFilter.filterBox.render();
        handleFilterChange();

        $ovlLoading.remove();

        const $wrpInner = $$`<div class="ve-flex-col h-100">
			${$wrpForm}
			${$wrpList}
			${opts.isBuildUi ? null : $$`<hr class="hr-1"><div class="ve-flex-vh-center">${$btnConfirm}</div>`}
		</div>`.appendTo($wrp.empty());

        return {
            $wrpIptSearch,
            $iptSearch,
            $wrpInner,
            $btnConfirm,
            pageFilter: this._pageFilter,
            list: this._list,
            $cbSelAll,
            $btnSendAllToRight,
        };
    }

    _isListItemMatchingFilter(f, li) {
        return this._isEntityItemMatchingFilter(f, this._allData[li.ix]);
    }
    _isEntityItemMatchingFilter(f, it) {
        return this._pageFilter.toDisplay(f, it);
    }

    async pPopulateHiddenWrapper() {
        await this._pInit();

        this._allData = this._allData || await this._pLoadAllData();

        await this._pageFilter.pInitFilterBox({
            namespace: this._namespace
        });

        this._allData.forEach(it=>{
            this._pageFilter.mutateAndAddToFilters(it);
        }
        );

        this._pageFilter.trimState();
    }

    handleHiddenOpenButtonClick() {
        this._pageFilter.filterBox.show();
    }

    handleHiddenResetButtonClick(evt) {
        this._pageFilter.filterBox.reset(evt.shiftKey);
    }

    _getStateFromFilterExpression(filterExpression) {
        const filterSubhashMeta = Renderer.getFilterSubhashes(Renderer.splitTagByPipe(filterExpression), this._namespace);
        const subhashes = filterSubhashMeta.subhashes.map(it=>`${it.key}${HASH_SUB_KV_SEP}${it.value}`);
        const unpackedSubhashes = this.pageFilter.filterBox.unpackSubHashes(subhashes, {
            force: true
        });
        return this.pageFilter.filterBox.getNextStateFromSubHashes({
            unpackedSubhashes
        });
    }

    getItemsMatchingFilterExpression({filterExpression}) {
        const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);

        const f = this._pageFilter.filterBox.getValues({
            nxtStateOuter
        });
        const filteredItems = this._filterCache.list.getFilteredItems({
            items: this._filterCache.list.items,
            fnFilter: li=>this._isListItemMatchingFilter(f, li),
        });

        return this._filterCache.list.getSortedItems({
            items: filteredItems
        });
    }

    getEntitiesMatchingFilterExpression({filterExpression}) {
        const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);

        const f = this._pageFilter.filterBox.getValues({
            nxtStateOuter
        });
        return this._allData.filter(this._isEntityItemMatchingFilter.bind(this, f));
    }

    getRenderedFilterExpression({filterExpression}) {
        const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);
        return this.pageFilter.filterBox.getDisplayState({
            nxtStateOuter
        });
    }

    async pGetUserSelection({filterExpression=null}={}) {
        return new Promise(async resolve=>{
            const {$modalInner, doClose} = await this._pGetShowModal(resolve);

            await this.pPreloadHidden($modalInner);

            this._doApplyFilterExpression(filterExpression);

            this._filterCache.$btnConfirm.off("click").click(async()=>{
                const checked = this._filterCache.list.visibleItems.filter(it=>it.data.cbSel.checked);
                resolve(checked);

                doClose(true);

                if (this._filterCache.$cbSelAll)
                    this._filterCache.$cbSelAll.prop("checked", false);
                this._filterCache.list.items.forEach(it=>{
                    if (it.data.cbSel)
                        it.data.cbSel.checked = false;
                    it.ele.classList.remove("list-multi-selected");
                }
                );
            }
            );

            await UiUtil.pDoForceFocus(this._filterCache.$iptSearch[0]);
        }
        );
    }

    async _pGetShowModal(resolve) {
        const {$modalInner, doClose} = await UiUtil.pGetShowModal({
            isHeight100: true,
            isWidth100: true,
            title: `Filter/Search for ${this._modalTitle}`,
            cbClose: (isDataEntered)=>{
                this._filterCache.$wrpModalInner.detach();
                if (!isDataEntered)
                    resolve([]);
            },
            isUncappedHeight: true,
        });

        return { $modalInner, doClose };
    }

    _doApplyFilterExpression(filterExpression) {
        if (!filterExpression)
            return;

        const filterSubhashMeta = Renderer.getFilterSubhashes(Renderer.splitTagByPipe(filterExpression), this._namespace);
        const subhashes = filterSubhashMeta.subhashes.map(it=>`${it.key}${HASH_SUB_KV_SEP}${it.value}`);
        this.pageFilter.filterBox.setFromSubHashes(subhashes, {
            force: true, $iptSearch: this._filterCache.$iptSearch
        });
    }

    _getNameStyle() {return `bold`;}

    async pPreloadHidden($modalInner) {
        $modalInner = $modalInner || $(`<div></div>`);

        if (this._filterCache) {
            this._filterCache.$wrpModalInner.appendTo($modalInner);
        }
        else {
            const meta = await this.pPopulateWrapper($modalInner);
            const {$iptSearch, $btnConfirm, pageFilter, list, $cbSelAll} = meta;
            const $wrpModalInner = meta.$wrpInner;

            this._filterCache = {
                $iptSearch,
                $wrpModalInner,
                $btnConfirm,
                pageFilter,
                list,
                $cbSelAll
            };
        }
    }

    _$getColumnHeaders() {
        throw new Error(`Unimplemented!`);
    }
    /**Blank init function that can be overridden */
    async _pInit() {}
    async _pLoadAllData() {
        throw new Error(`Unimplemented!`);
    }
    async _getListItem() {
        throw new Error(`Unimplemented!`);
    }
}
class ModalFilterClasses extends ModalFilter {

    constructor(opts) {
        opts = opts || {};

        super({
            ...opts,
            modalTitle: "Class and Subclass",
            pageFilter: new PageFilterClassesRaw(),
            fnSort: ModalFilterClasses.fnSort,
        });

        this._pLoadingAllData = null;

        this._ixPrevSelectedClass = null;
        this._isClassDisabled = false;
        this._isSubclassDisabled = false;
    }
    
    /**
     * The PageFilter
     * @returns {PageFilterClassesRaw}
     */
    get pageFilter() {return this._pageFilter;}

    static fnSort(a, b, opts) {
        const out = SortUtil.listSort(a, b, opts);

        if (opts.sortDir === "desc" && a.data.ixClass === b.data.ixClass && (a.data.ixSubclass != null || b.data.ixSubclass != null)) {
            return a.data.ixSubclass != null ? -1 : 1;
        }

        return out;
    }


    /**
     * Description
     * @param {{className: String, classSource:String, subclassName:String, subclassSource:string}} classSubclassMeta
     * @returns {{class:Object, subclass:Object}}
     */
    async pGetSelection(classSubclassMeta) {
        const {className, classSource, subclassName, subclassSource} = classSubclassMeta;

        const allData = this._allData || await this._pLoadAllData();

        const cls = allData.find(it=>it.name === className && it.source === classSource);
        if (!cls)
            throw new Error(`Could not find class with name "${className}" and source "${classSource}"`);

        const out = {class: cls, };

        if (subclassName && subclassSource) {
            const sc = cls.subclasses.find(it=>it.name === subclassName && it.source === subclassSource);
            if (!sc)
                throw new Error(`Could not find subclass with name "${subclassName}" and source "${subclassSource}" on class with name "${className}" and source "${classSource}"`);

            out.subclass = sc;
        }

        return out;
    }

    async pGetUserSelection({filterExpression=null, selectedClass=null, selectedSubclass=null, isClassDisabled=false, isSubclassDisabled=false}={}) {
        return new Promise(async resolve=>{
            const {$modalInner, doClose} = await this._pGetShowModal(resolve);

            await this.pPreloadHidden($modalInner);

            this._doApplyFilterExpression(filterExpression);

            this._filterCache.$btnConfirm.off("click").click(async()=>{
                const checked = this._filterCache.list.items.filter(it=>it.data.tglSel.classList.contains("active"));
                const out = {};
                checked.forEach(it=>{
                    if (it.data.ixSubclass == null)
                        out.class = this._filterCache.allData[it.data.ixClass];
                    else
                        out.subclass = this._filterCache.allData[it.data.ixClass].subclasses[it.data.ixSubclass];
                }
                );
                resolve(MiscUtil.copy(out));

                doClose(true);

                ModalFilterClasses$1._doListDeselectAll(this._filterCache.list);
            }
            );

            this._ixPrevSelectedClass = selectedClass != null ? this._filterCache.allData.findIndex(it=>it.name === selectedClass.name && it.source === selectedClass.source) : null;
            this._isClassDisabled = isClassDisabled;
            this._isSubclassDisabled = isSubclassDisabled;
            this._filterCache.list.items.forEach(li=>{
                const isScLi = li.data.ixSubclass != null;
                if (isScLi) {
                    li.data.tglSel.classList.toggle("disabled", this._isSubclassDisabled || (this._isClassDisabled && li.data.ixClass !== this._ixPrevSelectedClass));
                } else {
                    li.data.tglSel.classList.toggle("disabled", this._isClassDisabled);
                }
            }
            );

            if (selectedClass != null) {
                const ixSubclass = ~this._ixPrevSelectedClass && selectedSubclass != null ? this._filterCache.allData[this._ixPrevSelectedClass].subclasses.findIndex(it=>it.name === selectedSubclass.name && it.source === selectedSubclass.source) : -1;

                if (~this._ixPrevSelectedClass) {
                    ModalFilterClasses$1._doListDeselectAll(this._filterCache.list);

                    const clsItem = this._filterCache.list.items.find(it=>it.data.ixClass === this._ixPrevSelectedClass && it.data.ixSubclass == null);
                    if (clsItem) {
                        clsItem.data.tglSel.classList.add("active");
                        clsItem.ele.classList.add("list-multi-selected");
                    }

                    if (~ixSubclass && clsItem) {
                        const scItem = this._filterCache.list.items.find(it=>it.data.ixClass === this._ixPrevSelectedClass && it.data.ixSubclass === ixSubclass);
                        scItem.data.tglSel.classList.add("active");
                        scItem.ele.classList.add("list-multi-selected");
                    }
                }

                this._filterCache.list.setFnSearch((li,searchTerm)=>{
                    if (li.data.ixClass !== this._ixPrevSelectedClass)
                        return false;
                    return List.isVisibleDefaultSearch(li, searchTerm);
                }
                );
            } else {
                this._filterCache.list.setFnSearch(null);
            }

            this._filterCache.list.update();

            await UiUtil.pDoForceFocus(this._filterCache.$iptSearch[0]);
        }
        );
    }

    /**Called by ActorCharactermancerClass before the first render*/
    async pPreloadHidden($modalInner) {
        $modalInner = $modalInner || $(`<div></div>`);

        if (this._filterCache) {
            this._filterCache.$wrpModalInner.appendTo($modalInner);
        }
        else {
            await this._pInit();

            //Loading text
            const $ovlLoading = $(`<div class="w-100 h-100 ve-flex-vh-center"><i class="dnd-font ve-muted">Loading...</i></div>`).appendTo($modalInner);

            const $iptSearch = $(`<input class="form-control h-100" type="search" placeholder="Search...">`);
            const $btnReset = $(`<button class="btn btn-default">Reset</button>`);
            const $wrpFormTop = $$`<div class="ve-flex input-group btn-group w-100 lst__form-top">${$iptSearch}${$btnReset}</div>`;

            const $wrpFormBottom = $(`<div class="w-100"></div>`);

            const $wrpFormHeaders = $(`<div class="input-group input-group--bottom ve-flex no-shrink">
				<div class="btn btn-default disabled col-1 pl-0"></div>
				<button class="col-9 sort btn btn-default btn-xs" data-sort="name">Name</button>
				<button class="col-2 pr-0 sort btn btn-default btn-xs ve-grow" data-sort="source">Source</button>
			</div>`);

            const $wrpForm = $$`<div class="ve-flex-col w-100 mb-2">${$wrpFormTop}${$wrpFormBottom}${$wrpFormHeaders}</div>`;
            const $wrpList = this._$getWrpList();

            const $btnConfirm = $(`<button class="btn btn-default">Confirm</button>`);

            const list = new List({ $iptSearch, $wrpList, fnSort: this._fnSort, });

            SortUtil.initBtnSortHandlers($wrpFormHeaders, list);

            //allData is probably already set
            const allData = this._allData || await this._pLoadAllData();
            const pageFilter = this._pageFilter;

            await pageFilter.pInitFilterBox({ $wrpFormTop, $btnReset, $wrpMiniPills: $wrpFormBottom, namespace: this._namespace, });

            allData.forEach((it,i)=>{
                pageFilter.mutateAndAddToFilters(it);
                const filterListItems = this._getListItems(pageFilter, it, i);
                filterListItems.forEach(li=>{
                    list.addItem(li);
                    li.ele.addEventListener("click", evt=>{
                        const isScLi = li.data.ixSubclass != null;

                        if (isScLi) {
                            if (this._isSubclassDisabled)
                                return;
                            if (this._isClassDisabled && li.data.ixClass !== this._ixPrevSelectedClass)
                                return;
                        } else {
                            if (this._isClassDisabled)
                                return;
                        }

                        this._handleSelectClick({
                            list,
                            filterListItems,
                            filterListItem: li,
                            evt,
                        });
                    }
                    );
                }
                );
            }
            );

            list.init();
            list.update();

            //Wrapper to a function to be called when the filter changes
            const handleFilterChange = ()=>{
                return this.constructor.handleFilterChange({ pageFilter, list, allData });
            };

            pageFilter.trimState();

            pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, handleFilterChange);
            pageFilter.filterBox.render(); //Render the filterbox already
            handleFilterChange(); //Lets call that filter function right away

            $ovlLoading.remove();

            const $wrpModalInner = $$`<div class="ve-flex-col h-100">
				${$wrpForm}
				${$wrpList}
				<div class="ve-flex-vh-center">${$btnConfirm}</div>
			</div>`.appendTo($modalInner);

            this._filterCache = {
                $wrpModalInner,
                $btnConfirm,
                pageFilter,
                list,
                allData,
                $iptSearch
            };
        }
    }

    /**Called when the filter changes */
    static handleFilterChange({pageFilter, list, allData}) {
        //Get the values from the filterbox
        const f = pageFilter.filterBox.getValues();
        if(!f.Source?._combineBlue){console.error("Combine blue is not set!");
        console.log(pageFilter.filterBox);
        if(!pageFilter.filterBox._filters[0].__meta.combineBlue){
            console.error("Source filter does not have combineBlue!");
        }
    }

        list.filter(li=>{
            const cls = allData[li.data.ixClass];

            if (li.data.ixSubclass != null) {
                const sc = cls.subclasses[li.data.ixSubclass];
                if (!pageFilter.toDisplay(f, cls, [], null, )){return false;}

                return pageFilter.filterBox.toDisplay(f, sc.source, sc._fMisc, null, );
            }

            return pageFilter.toDisplay(f, cls, [], null);
        });
    }

    static _doListDeselectAll(list, {isSubclassItemsOnly=false}={}) {
        list.items.forEach(it=>{
            if (isSubclassItemsOnly && it.data.ixSubclass == null)
                return;

            if (it.data.tglSel)
                it.data.tglSel.classList.remove("active");
            it.ele.classList.remove("list-multi-selected");
        }
        );
    }

    _handleSelectClick({list, filterListItems, filterListItem, evt}) {
        evt.preventDefault();
        evt.stopPropagation();

        const isScLi = filterListItem.data.ixSubclass != null;

        if (this._isClassDisabled && this._ixPrevSelectedClass != null && isScLi) {
            if (!filterListItem.data.tglSel.classList.contains("active"))
                this.constructor._doListDeselectAll(list, {
                    isSubclassItemsOnly: true
                });
            filterListItem.data.tglSel.classList.toggle("active");
            filterListItem.ele.classList.toggle("list-multi-selected");
            return;
        }

        if (filterListItem.data.tglSel.classList.contains("active")) {
            this.constructor._doListDeselectAll(list);
            return;
        }

        this.constructor._doListDeselectAll(list);

        if (isScLi) {
            const classItem = filterListItems[0];
            classItem.data.tglSel.classList.add("active");
            classItem.ele.classList.add("list-multi-selected");
        }

        filterListItem.data.tglSel.classList.add("active");
        filterListItem.ele.classList.add("list-multi-selected");
    }

    async _pLoadAllData() {
        this._pLoadingAllData = this._pLoadingAllData || (async()=>{
            const [data,prerelease,brew] = await Promise.all([MiscUtil.copy(await DataUtil.class.loadRawJSON()),
                PrereleaseUtil.pGetBrewProcessed(), BrewUtil2.pGetBrewProcessed(), ]);

            this._pLoadAllData_mutAddPrereleaseBrew({
                data, brew: prerelease, brewUtil: PrereleaseUtil
            });
            this._pLoadAllData_mutAddPrereleaseBrew({
                data, brew: brew, brewUtil: BrewUtil2
            });

            this._allData = (await PageFilterClassesRaw.pPostLoad(data)).class;
        })();

        await this._pLoadingAllData;
        return this._allData;
    }

    _pLoadAllData_mutAddPrereleaseBrew({data, brew, brewUtil}) {
        const clsProps = brewUtil.getPageProps({
            page: UrlUtil.PG_CLASSES
        });

        if (!clsProps.includes("*")) {
            clsProps.forEach(prop=>data[prop] = [...(data[prop] || []), ...MiscUtil.copy(brew[prop] || [])]);
            return;
        }

        Object.entries(brew).filter(([,brewVal])=>brewVal instanceof Array).forEach(([prop,brewArr])=>data[prop] = [...(data[prop] || []), ...MiscUtil.copy(brewArr)]);
    }

    _getListItems(pageFilter, cls, clsI) {
        return [this._getListItems_getClassItem(pageFilter, cls, clsI), ...cls.subclasses.map((sc,scI)=>this._getListItems_getSubclassItem(pageFilter, cls, clsI, sc, scI)), ];
    }

    _getListItems_getClassItem(pageFilter, cls, clsI) {
        const eleLabel = document.createElement("label");
        eleLabel.className = `w-100 ve-flex lst--border veapp__list-row no-select lst__wrp-cells`;

        const source = Parser.sourceJsonToAbv(cls.source);

        eleLabel.innerHTML = `<div class="col-1 pl-0 ve-flex-vh-center"><div class="fltr-cls__tgl"></div></div>
		<div class="bold col-9 ${cls._versionBase_isVersion ? "italic" : ""}">${cls._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${cls.name}</div>
		<div class="col-2 pr-0 ve-text-center ${Parser.sourceJsonToColor(cls.source)}" title="${Parser.sourceJsonToFull(cls.source)}" ${Parser.sourceJsonToStyle(cls.source)}>${source}</div>`;

        return new ListItem(clsI,eleLabel,`${cls.name} -- ${cls.source}`,{
            source: `${source} -- ${cls.name}`,
        },{
            ixClass: clsI,
            tglSel: eleLabel.firstElementChild.firstElementChild,
        },);
    }

    _getListItems_getSubclassItem(pageFilter, cls, clsI, sc, scI) {
        const eleLabel = document.createElement("label");
        eleLabel.className = `w-100 ve-flex lst--border veapp__list-row no-select lst__wrp-cells`;

        const source = Parser.sourceJsonToAbv(sc.source);

        eleLabel.innerHTML = `<div class="col-1 pl-0 ve-flex-vh-center"><div class="fltr-cls__tgl"></div></div>
		<div class="col-9 pl-1 ve-flex-v-center ${sc._versionBase_isVersion ? "italic" : ""}">${sc._versionBase_isVersion ? `<span class="px-3"></span>` : ""}<span class="mx-3">\u2014</span> ${sc.name}</div>
		<div class="col-2 pr-0 ve-text-center ${Parser.sourceJsonToColor(sc.source)}" title="${Parser.sourceJsonToFull(sc.source)}" ${Parser.sourceJsonToStyle(sc.source)}>${source}</div>`;

        return new ListItem(`${clsI}--${scI}`,eleLabel,`${cls.name} -- ${cls.source} -- ${sc.name} -- ${sc.source}`,{
            source: `${cls.source} -- ${cls.name} -- ${source} -- ${sc.name}`,
        },{
            ixClass: clsI,
            ixSubclass: scI,
            tglSel: eleLabel.firstElementChild.firstElementChild,
        },);
    }
}
globalThis.ModalFilterClasses$1 = ModalFilterClasses;

class ModalFilterRaces extends ModalFilter {
    constructor(opts) {
        opts = opts || {};
        super({
            ...opts, //pass on allData to super
            modalTitle: `Race${opts.isRadio ? "" : "s"}`,
            pageFilter: new PageFilterRaces(), //Create a pass filter that handles only races
        });
    }

     /**
     * The PageFilter
     * @returns {PageFilterRaces}
     */
     get pageFilter() {return this._pageFilter;}

    _$getColumnHeaders() {
        const btnMeta = [{
            sort: "name",
            text: "Name",
            width: "4"
        }, {
            sort: "ability",
            text: "Ability",
            width: "4"
        }, {
            sort: "size",
            text: "Size",
            width: "2"
        }, {
            sort: "source",
            text: "Source",
            width: "1"
        }, ];
        return ModalFilter._$getFilterColumnHeaders(btnMeta);
    }

    async _pLoadAllData() {
        return [...await DataUtil.race.loadJSON(), ...((await DataUtil.race.loadPrerelease({
            isAddBaseRaces: false
        })).race || []), ...((await DataUtil.race.loadBrew({
            isAddBaseRaces: false
        })).race || []), ];
    }

    _getListItem(pageFilter, race, rI) {
        const eleRow = document.createElement("div");
        eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

        const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES](race);
        const ability = race.ability ? Renderer.getAbilityData(race.ability) : {
            asTextShort: "None"
        };
        const size = (race.size || [Parser.SZ_VARIES]).map(sz=>Parser.sizeAbvToFull(sz)).join("/");
        const source = Parser.sourceJsonToAbv(race.source);

        eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-4 ${race._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${race._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${race.name}</div>
			<div class="col-4">${ability.asTextShort}</div>
			<div class="col-2 ve-text-center">${size}</div>
			<div class="col-1 pr-0 ve-text-center ${Parser.sourceJsonToColor(race.source)}" title="${Parser.sourceJsonToFull(race.source)}" ${Parser.sourceJsonToStyle(race.source)}>${source}</div>
		</div>`;

        const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

        const listItem = new ListItem(rI,eleRow,race.name,{
            hash,
            source,
            sourceJson: race.source,
            ability: ability.asTextShort,
            size,
            cleanName: PageFilterRaces.getInvertedName(race.name) || "",
            alias: PageFilterRaces.getListAliases(race),
        },{
            cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
            btnShowHidePreview,
        },);

        ListUiUtil.bindPreviewButton(UrlUtil.PG_RACES, this._allData, listItem, btnShowHidePreview);

        return listItem;
    }
}
class ModalFilterBackgrounds extends ModalFilter {
    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Background${opts.isRadio ? "" : "s"}`,
            pageFilter: new PageFilterBackgrounds$1(),
        });
    }

    _$getColumnHeaders() {
        const btnMeta = [{
            sort: "name",
            text: "Name",
            width: "4"
        }, {
            sort: "skills",
            text: "Skills",
            width: "6"
        }, {
            sort: "source",
            text: "Source",
            width: "1"
        }, ];
        return ModalFilter._$getFilterColumnHeaders(btnMeta);
    }

    async _pLoadAllData() {
        return [...(await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/backgrounds.json`)).background, ...((await PrereleaseUtil.pGetBrewProcessed()).background || []), ...((await BrewUtil2.pGetBrewProcessed()).background || []), ];
    }

    _getListItem(pageFilter, bg, bgI) {
        const eleRow = document.createElement("div");
        eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

        const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS](bg);
        const source = Parser.sourceJsonToAbv(bg.source);

        eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-4 ${bg._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${bg._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${bg.name}</div>
			<div class="col-6">${bg._skillDisplay}</div>
			<div class="col-1 pr-0 ve-text-center ${Parser.sourceJsonToColor(bg.source)}" title="${Parser.sourceJsonToFull(bg.source)}" ${Parser.sourceJsonToStyle(bg.source)}>${source}</div>
		</div>`;

        const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

        const listItem = new ListItem(bgI,eleRow,bg.name,{
            hash,
            source,
            sourceJson: bg.source,
            skills: bg._skillDisplay,
        },{
            cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
            btnShowHidePreview,
        },);

        ListUiUtil.bindPreviewButton(UrlUtil.PG_BACKGROUNDS, this._allData, listItem, btnShowHidePreview);

        return listItem;
    }
}
class ModalFilterFeats extends ModalFilter {
    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Feat${opts.isRadio ? "" : "s"}`,
            pageFilter: new PageFilterFeats$1(),
        });
    }

    _$getColumnHeaders() {
        const btnMeta = [{
            sort: "name",
            text: "Name",
            width: "4"
        }, {
            sort: "ability",
            text: "Ability",
            width: "3"
        }, {
            sort: "prerequisite",
            text: "Prerequisite",
            width: "3"
        }, {
            sort: "source",
            text: "Source",
            width: "1"
        }, ];
        return ModalFilter._$getFilterColumnHeaders(btnMeta);
    }

    async _pLoadAllData() {
        return [...(await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/feats.json`)).feat, ...((await PrereleaseUtil.pGetBrewProcessed()).feat || []), ...((await BrewUtil2.pGetBrewProcessed()).feat || []), ];
    }

    _getListItem(pageFilter, feat, ftI) {
        const eleRow = document.createElement("div");
        eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

        const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS](feat);
        const source = Parser.sourceJsonToAbv(feat.source);

        eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-4 ${feat._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${feat._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${feat.name}</div>
			<span class="col-3 ${feat._slAbility === VeCt.STR_NONE ? "italic" : ""}">${feat._slAbility}</span>
				<span class="col-3 ${feat._slPrereq === VeCt.STR_NONE ? "italic" : ""}">${feat._slPrereq}</span>
			<div class="col-1 pr-0 ve-text-center ${Parser.sourceJsonToColor(feat.source)}" title="${Parser.sourceJsonToFull(feat.source)}" ${Parser.sourceJsonToStyle(feat.source)}>${source}</div>
		</div>`;

        const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

        const listItem = new ListItem(ftI,eleRow,feat.name,{
            hash,
            source,
            sourceJson: feat.source,
            ability: feat._slAbility,
            prerequisite: feat._slPrereq,
        },{
            cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
            btnShowHidePreview,
        },);

        ListUiUtil.bindPreviewButton(UrlUtil.PG_FEATS, this._allData, listItem, btnShowHidePreview);

        return listItem;
    }
}
class ModalFilterItems extends ModalFilter {
    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Item${opts.isRadio ? "" : "s"}`,
            pageFilter: new PageFilterItems$1(opts?.pageFilterOpts),
        });
    }

    _$getColumnHeaders() {
        const btnMeta = [{
            sort: "name",
            text: "Name",
            width: "4"
        }, {
            sort: "type",
            text: "Type",
            width: "6"
        }, {
            sort: "source",
            text: "Source",
            width: "1"
        }, ];
        return ModalFilter._$getFilterColumnHeaders(btnMeta);
    }

    async _pInit() {
        await Renderer.item.pPopulatePropertyAndTypeReference();
    }

    async _pLoadAllData() {
        return [...(await Renderer.item.pBuildList()), ...(await Renderer.item.pGetItemsFromPrerelease()), ...(await Renderer.item.pGetItemsFromBrew()), ];
    }

    _getListItem(pageFilter, item, itI) {
        if (item.noDisplay)
            return null;

        Renderer.item.enhanceItem(item);
        pageFilter.mutateAndAddToFilters(item);

        const eleRow = document.createElement("div");
        eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

        const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS](item);
        const source = Parser.sourceJsonToAbv(item.source);
        const type = item._typeListText.join(", ");

        eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-5 ${item._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${item._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${item.name}</div>
			<div class="col-5">${type.uppercaseFirst()}</div>
			<div class="col-1 ve-text-center ${Parser.sourceJsonToColor(item.source)} pr-0" title="${Parser.sourceJsonToFull(item.source)}" ${Parser.sourceJsonToStyle(item.source)}>${source}</div>
		</div>`;

        const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

        const listItem = new ListItem(itI,eleRow,item.name,{
            hash,
            source,
            sourceJson: item.source,
            type,
        },{
            cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
            btnShowHidePreview,
        },);

        ListUiUtil.bindPreviewButton(UrlUtil.PG_ITEMS, this._allData, listItem, btnShowHidePreview);

        return listItem;
    }
}
class ModalFilterSpells extends ModalFilter {
    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Spell${opts.isRadio ? "" : "s"}`,
            pageFilter: new PageFilterSpells(),
            fnSort: PageFilterSpells.sortSpells,
        });
    }

    _$getColumnHeaders() {
        const btnMeta = [{
            sort: "name",
            text: "Name",
            width: "3"
        }, {
            sort: "level",
            text: "Level",
            width: "1-5"
        }, {
            sort: "time",
            text: "Time",
            width: "2"
        }, {
            sort: "school",
            text: "School",
            width: "1"
        }, {
            sort: "concentration",
            text: "C.",
            title: "Concentration",
            width: "0-5"
        }, {
            sort: "range",
            text: "Range",
            width: "2"
        }, {
            sort: "source",
            text: "Source",
            width: "1"
        }, ];
        return ModalFilter._$getFilterColumnHeaders(btnMeta);
    }

    async _pInit() {
        if (typeof PrereleaseUtil !== "undefined")
            Renderer.spell.populatePrereleaseLookup(await PrereleaseUtil.pGetBrewProcessed());
        if (typeof BrewUtil2 !== "undefined")
            Renderer.spell.populateBrewLookup(await BrewUtil2.pGetBrewProcessed());
    }

    async _pLoadAllData() {
        return [...(await DataUtil.spell.pLoadAll()), ...((await PrereleaseUtil.pGetBrewProcessed()).spell || []), ...((await BrewUtil2.pGetBrewProcessed()).spell || []), ];
    }

    _getListItem(pageFilter, spell, spI) {
        const eleRow = document.createElement("div");
        eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

        const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS](spell);
        const source = Parser.sourceJsonToAbv(spell.source);
        const levelText = PageFilterSpells.getTblLevelStr(spell);
        const time = PageFilterSpells.getTblTimeStr(spell.time[0]);
        const school = Parser.spSchoolAndSubschoolsAbvsShort(spell.school, spell.subschools);
        const concentration = spell._isConc ? "×" : "";
        const range = Parser.spRangeToFull(spell.range);

        eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-3 ${spell._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${spell._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${spell.name}</div>
			<div class="col-1-5 ve-text-center">${levelText}</div>
			<div class="col-2 ve-text-center">${time}</div>
			<div class="col-1 sp__school-${spell.school} ve-text-center" title="${Parser.spSchoolAndSubschoolsAbvsToFull(spell.school, spell.subschools)}" ${Parser.spSchoolAbvToStyle(spell.school)}>${school}</div>
			<div class="col-0-5 ve-text-center" title="Concentration">${concentration}</div>
			<div class="col-2 text-right">${range}</div>
			<div class="col-1 pr-0 ve-text-center ${Parser.sourceJsonToColor(spell.source)}" title="${Parser.sourceJsonToFull(spell.source)}" ${Parser.sourceJsonToStyle(spell.source)}>${source}</div>
		</div>`;

        const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

        const listItem = new ListItem(spI,eleRow,spell.name,{
            hash,
            source,
            sourceJson: spell.source,
            level: spell.level,
            time,
            school: Parser.spSchoolAbvToFull(spell.school),
            classes: Parser.spClassesToFull(spell, {isTextOnly: true}),
            concentration,
            normalisedTime: spell._normalisedTime,
            normalisedRange: spell._normalisedRange,
        },{
            cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
            btnShowHidePreview,
        },);

        ListUiUtil.bindPreviewButton(UrlUtil.PG_SPELLS, this._allData, listItem, btnShowHidePreview);

        return listItem;
    }
}

Charactermancer_StartingEquipment.ModalFilterEquipment = class extends ModalFilter {
    static _$getFilterColumnHeaders(btnMeta) {
        return super._$getFilterColumnHeaders(btnMeta).map($btn=>$btn.addClass(`btn-5et`));
    }

    constructor(compStartingEquipment) {
        super({
            pageFilter: new PageFilterEquipment(),
            namespace: "ImportListCharacter_modalFilterEquipment",
        });
        this._compParent = compStartingEquipment;
    }

    _$getColumnHeaders() {
        const btnMeta = [{
            sort: "name",
            text: "Name",
            width: "3-2"
        }, {
            sort: "type",
            text: "Type",
            width: "3-2"
        }, {
            sort: "cost",
            text: "Cost",
            width: "1-8"
        }, {
            sort: "source",
            text: "Source",
            width: "1-8"
        }, ];
        return this.constructor._$getFilterColumnHeaders(btnMeta);
    }

    async _pLoadAllData() {
        return [];
    }

    _$getWrpList() {
        return $(`<div class="veapp__list mb-1 h-100 min-h-0"></div>`);
    }

    _$getColumnHeaderPreviewAll(opts) {
        return super._$getColumnHeaderPreviewAll(opts).addClass(["btn-5et", "ve-muted"]);
    }

    _getListItem(pageFilter, item, itI) {
        if (item.noDisplay)
            return null;

        Renderer.item.enhanceItem(item);
        pageFilter.mutateAndAddToFilters(item);

        const eleRow = document.createElement("div");
        eleRow.className = "px-0 w-100 veapp__list-row ve-flex-col no-shrink";

        const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS](item);
        const source = Parser.sourceJsonToAbv(item.source);
        const type = item._typeListText.join(", ");

        eleRow.innerHTML = `<div class="w-100 veapp__list-row-hoverable ve-flex-v-center">
			<div class="col-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline" title="Toggle Preview (SHIFT to Toggle Info Preview)">${ListUiUtil.HTML_GLYPHICON_EXPAND}</div>
			</div>

			<span class="col-3-2">${item.name}</span>
			<span class="col-3-2">${item._typeListText.join(", ").toTitleCase()}</span>
			<span class="col-1-8 text-right px-1">${Parser.itemValueToFullMultiCurrency(item, {
            isShortForm: true,
            multiplier: Config.get("equipmentShop", "priceMultiplier")
        }).replace(/ +/g, "\u00A0")}</span>
			<span class="col-1-8 ve-text-center ${Parser.sourceJsonToColor(item.source)} pr-0" title="${Parser.sourceJsonToFull(item.source)}" ${Parser.sourceJsonToStyle(item.source)}>${source}</span>
			<div class="col-1 ve-flex-vh-center"><button class="btn btn-xxs btn-default btn-5et" title="Add (SHIFT to add 5; CTRL to ignore price)"><span class="glyphicon glyphicon-arrow-right"></span></button></div>
		</div>`;

        const btnShowHidePreview = eleRow.firstElementChild.firstElementChild.firstElementChild;
        btnShowHidePreview.addEventListener("click", evt=>{
            evt.stopPropagation();
            evt.preventDefault();

            const elePreviewWrp = ListUiUtil.getOrAddListItemPreviewLazy(listItem);

            ListUiUtil.handleClickBtnShowHideListPreview(evt, UrlUtil.PG_ITEMS, item, btnShowHidePreview, elePreviewWrp, );
        }
        );

        const listItem = new ListItem(itI,eleRow,item.name,{
            hash,
            source,
            sourceJson: item.source,
            cost: (item.value || 0) * Config.get("equipmentShop", "priceMultiplier"),
            type,
        },{
            btnSendToRight: eleRow.firstElementChild.lastElementChild.lastElementChild,
            btnShowHidePreview,
        },);

        return listItem;
    }

    setDataList(allData) {
        this._list.removeAllItems();

        this._allData = (allData?.item || []).filter(it=>it.value != null && it.type !== "$");

        this._allData.forEach((it,i)=>{
            this._pageFilter.mutateAndAddToFilters(it);
            const filterListItem = this._getListItem(this._pageFilter, it, i);
            this._list.addItem(filterListItem);
            const itemUid = `${it.name}|${it.source}`;
            filterListItem.data.btnSendToRight.addEventListener("click", evt=>{
                const isIgnoreCost = evt.ctrlKey;
                if (evt.shiftKey)
                    this._compParent.addBoughtItem(itemUid, {
                        quantity: 5,
                        isIgnoreCost
                    });
                else
                    this._compParent.addBoughtItem(itemUid, {
                        isIgnoreCost
                    });
            }
            );
        }
        );

        this._pageFilter.sourceFilter.setFromValues({
            "Source": {}
        });

        this._pageFilter.filterBox.render();
        this._list.update();
    }
};



class MixedModalFilterFvtt //extends Cls
{
    constructor(...args) {
        //super(...args);

        this._prevApp = null;
    }

    _getNameStyle() {
        return "";
    }

    _getShowModal(resolve) {
        if (this._prevApp)
            this._prevApp.close();

        const self = this;

        const app = new class TempApplication extends Application {
            constructor() {
                super({
                    title: `Filter/Search for ${self._modalTitle}`,
                    template: `${SharedConsts.MODULE_LOCATION}/template/_Generic.hbs`,
                    width: Util.getMaxWindowWidth(900),
                    height: Util.getMaxWindowHeight(),
                    resizable: true,
                });

                this._$wrpHtmlInner = $(`<div class="ve-flex-col w-100 h-100"></div>`);
            }

            get $modalInner() {
                return this._$wrpHtmlInner;
            }

            async close(...args) {
                self._filterCache.$wrpModalInner.detach();
                await super.close(...args);
                resolve([]);
            }

            activateListeners($html) {
                this._$wrpHtmlInner.appendTo($html);
            }
        }
        ();

        app.render(true);
        this._prevApp = app;

        return {
            $modalInner: app.$modalInner,
            doClose: app.close.bind(app)
        };
    }

    getDataFromSelected(selected) {
        return this._allData[selected.ix];
    }
}
//Cls is an input class we choose to extend
function MixinModalFilterFvtt(Cls) {
    class MixedModalFilterFvtt extends Cls {
        constructor(...args) {
            super(...args);

            this._prevApp = null;
        }

        _getNameStyle() {return "";}

        _getShowModal(resolve) {
            if (this._prevApp)
                this._prevApp.close();

            const self = this;

            const app = new class TempApplication extends Application {
                constructor() {
                    super({
                        title: `Filter/Search for ${self._modalTitle}`,
                        template: `${SharedConsts.MODULE_LOCATION}/template/_Generic.hbs`,
                        width: Util.getMaxWindowWidth(900),
                        height: Util.getMaxWindowHeight(),
                        resizable: true,
                    });

                    this._$wrpHtmlInner = $(`<div class="ve-flex-col w-100 h-100"></div>`);
                }

                get $modalInner() { return this._$wrpHtmlInner; }

                async close(...args) {
                    self._filterCache.$wrpModalInner.detach();
                    await super.close(...args);
                    resolve([]);
                }

                activateListeners($html) {
                    this._$wrpHtmlInner.appendTo($html);
                }
            }
            ();

            app.render(true);
            this._prevApp = app;

            return {
                $modalInner: app.$modalInner,
                doClose: app.close.bind(app)
            };
        }

        getDataFromSelected(selected) { return this._allData[selected.ix]; }
    }
    return MixedModalFilterFvtt;
}
class ModalFilterBackgroundsFvtt extends MixinModalFilterFvtt(ModalFilterBackgrounds) {
}

class ModalFilterClassesFvtt extends MixinModalFilterFvtt(ModalFilterClasses) {
}

class ModalFilterFeatsFvtt extends MixinModalFilterFvtt(ModalFilterFeats) {
}

class ModalFilterRacesFvtt extends MixinModalFilterFvtt(ModalFilterRaces) {
}

class ModalFilterSpellsFvtt extends MixinModalFilterFvtt(ModalFilterSpells) {
}

class ModalFilterItemsFvtt extends MixinModalFilterFvtt(ModalFilterItems) {
}
//#endregion
//#endregion


//#endregion

//#region BREW UTIL
class _BrewUtil2Base {
    _STORAGE_KEY_LEGACY;
    _STORAGE_KEY_LEGACY_META;

    _STORAGE_KEY;
    _STORAGE_KEY_META;

    _STORAGE_KEY_CUSTOM_URL;
    _STORAGE_KEY_MIGRATION_VERSION;

    _VERSION;

    _PATH_LOCAL_DIR;
    _PATH_LOCAL_INDEX;

    IS_EDITABLE;
    PAGE_MANAGE;
    URL_REPO_DEFAULT;
    DISPLAY_NAME;
    DISPLAY_NAME_PLURAL;
    DEFAULT_AUTHOR;
    STYLE_BTN;

    _LOCK = new VeLock({
        name: this.constructor.name
    });

    _cache_iteration = 0;
    _cache_brewsProc = null;
    _cache_metas = null;
    _cache_brews = null;
    _cache_brewsLocal = null;

    _isDirty = false;

    _brewsTemp = [];
    _addLazy_brewsTemp = [];

    _storage = StorageUtil;

    _pActiveInit = null;

    pInit() {
        this._pActiveInit ||= (async()=>{
            await this._pGetBrew_pGetLocalBrew();

            this._pInit_doBindDragDrop();
            this._pInit_pDoLoadFonts().then(null);
        }
        )();
        return this._pActiveInit;
    }

    _pInit_doBindDragDrop() {
        throw new Error("Unimplemented!");
    }

    async _pInit_pDoLoadFonts() {
        const fontFaces = Object.entries((this._getBrewMetas() || []).map(({_meta})=>_meta?.fonts || {}).mergeMap(it=>it), ).map(([family,fontUrl])=>new FontFace(family,`url("${fontUrl}")`));

        const results = await Promise.allSettled(fontFaces.map(async fontFace=>{
            await fontFace.load();
            return document.fonts.add(fontFace);
        }
        ), );

        const errors = results.filter(({status})=>status === "rejected").map(({reason},i)=>({
            message: `Font "${fontFaces[i].family}" failed to load!`,
            reason
        }));
        if (errors.length) {
            errors.forEach(({message})=>JqueryUtil.doToast({
                type: "danger",
                content: message
            }));
            setTimeout(()=>{
                throw new Error(errors.map(({message, reason})=>[message, reason].join("\n")).join("\n\n"));
            }
            );
        }

        return document.fonts.ready;
    }

    async pGetCustomUrl() {
        return this._storage.pGet(this._STORAGE_KEY_CUSTOM_URL);
    }

    async pSetCustomUrl(val) {
        return !val ? this._storage.pRemove(this._STORAGE_KEY_CUSTOM_URL) : this._storage.pSet(this._STORAGE_KEY_CUSTOM_URL, val);
    }

    isReloadRequired() {
        return this._isDirty;
    }

    _getBrewMetas() {
        return [...(this._storage.syncGet(this._STORAGE_KEY_META) || []), ...(this._cache_brewsLocal || []).map(brew=>this._getBrewDocReduced(brew)), ];
    }

    _setBrewMetas(val) {
        this._cache_metas = null;
        return this._storage.syncSet(this._STORAGE_KEY_META, val);
    }

    async pGetBrewProcessed() {
        if (this._cache_brewsProc)
            return this._cache_brewsProc;
        try {
            const lockToken = await this._LOCK.pLock();
            await this._pGetBrewProcessed_({
                lockToken
            });
        } catch (e) {
            setTimeout(()=>{
                throw e;
            }
            );
        } finally {
            this._LOCK.unlock();
        }
        return this._cache_brewsProc;
    }

    async _pGetBrewProcessed_({lockToken}) {
        const cpyBrews = MiscUtil.copyFast([...await this.pGetBrew({
            lockToken
        }), ...this._brewsTemp, ]);
        if (!cpyBrews.length)
            return this._cache_brewsProc = {};

        await this._pGetBrewProcessed_pDoBlocklistExtension({
            cpyBrews
        });

        const cpyBrewsLoaded = await cpyBrews.pSerialAwaitMap(async({head, body})=>{
            const cpyBrew = await DataUtil.pDoMetaMerge(head.url || head.docIdLocal, body, {
                isSkipMetaMergeCache: true
            });
            this._pGetBrewProcessed_mutDiagnostics({
                head,
                cpyBrew
            });
            return cpyBrew;
        }
        );

        this._cache_brewsProc = this._pGetBrewProcessed_getMergedOutput({
            cpyBrewsLoaded
        });
        return this._cache_brewsProc;
    }

    async _pGetBrewProcessed_pDoBlocklistExtension({cpyBrews}) {
        for (const {body} of cpyBrews) {
            if (!body?.blocklist?.length || !(body.blocklist instanceof Array))
                continue;
            await ExcludeUtil.pExtendList(body.blocklist);
        }
    }

    _pGetBrewProcessed_mutDiagnostics({head, cpyBrew}) {
        if (!head.filename)
            return;

        for (const arr of Object.values(cpyBrew)) {
            if (!(arr instanceof Array))
                continue;
            for (const ent of arr) {
                if (!("__prop"in ent))
                    break;
                ent.__diagnostic = {
                    filename: head.filename
                };
            }
        }
    }

    _pGetBrewProcessed_getMergedOutput({cpyBrewsLoaded}) {
        return BrewDoc.mergeObjects(undefined, ...cpyBrewsLoaded);
    }

    getBrewProcessedFromCache(prop) {
        return this._cache_brewsProc?.[prop] || [];
    }

    async pGetBrew({lockToken}={}) {
        if (this._cache_brews)
            return this._cache_brews;

        try {
            lockToken = await this._LOCK.pLock({
                token: lockToken
            });

            const out = [...(await this._pGetBrewRaw({
                lockToken
            })), ...(await this._pGetBrew_pGetLocalBrew({
                lockToken
            })), ];

            return this._cache_brews = out.filter(brew=>brew?.body?._meta?.sources?.length);
        } finally {
            this._LOCK.unlock();
        }
    }

    async pGetBrewBySource(source, {lockToken}={}) {
        const brews = await this.pGetBrew({
            lockToken
        });
        return brews.find(brew=>brew?.body?._meta?.sources?.some(src=>src?.json === source));
    }

    async _pGetBrew_pGetLocalBrew({lockToken}={}) {
        if (this._cache_brewsLocal)
            return this._cache_brewsLocal;
        if (IS_VTT || IS_DEPLOYED || typeof window === "undefined")
            return this._cache_brewsLocal = [];

        try {
            await this._LOCK.pLock({
                token: lockToken
            });
            return (await this._pGetBrew_pGetLocalBrew_());
        } finally {
            this._LOCK.unlock();
        }
    }

    async _pGetBrew_pGetLocalBrew_() {
        const indexLocal = await DataUtil.loadJSON(`${Renderer.get().baseUrl}${this._PATH_LOCAL_INDEX}`);
        if (!indexLocal?.toImport?.length)
            return this._cache_brewsLocal = [];

        const brewDocs = (await indexLocal.toImport.pMap(async name=>{
            name = `${name}`.trim();
            const url = /^https?:\/\//.test(name) ? name : `${Renderer.get().baseUrl}${this._PATH_LOCAL_DIR}/${name}`;
            const filename = UrlUtil.getFilename(url);
            try {
                const json = await DataUtil.loadRawJSON(url);
                return this._getBrewDoc({
                    json,
                    url,
                    filename,
                    isLocal: true
                });
            } catch (e) {
                JqueryUtil.doToast({
                    type: "danger",
                    content: `Failed to load local homebrew from URL "${url}"! ${VeCt.STR_SEE_CONSOLE}`
                });
                setTimeout(()=>{
                    throw e;
                }
                );
                return null;
            }
        }
        )).filter(Boolean);

        return this._cache_brewsLocal = brewDocs;
    }

    async _pGetBrewRaw({lockToken}={}) {
        try {
            await this._LOCK.pLock({
                token: lockToken
            });
            return (await this._pGetBrewRaw_());
        } finally {
            this._LOCK.unlock();
        }
    }

    async _pGetBrewRaw_() {
        const brewRaw = (await this._storage.pGet(this._STORAGE_KEY)) || [];

        if (brewRaw.length)
            return brewRaw;

        const {version, existingMeta, existingBrew} = await this._pGetMigrationInfo();

        if (version === this._VERSION)
            return brewRaw;

        if (!existingMeta || !existingBrew) {
            await this._storage.pSet(this._STORAGE_KEY_MIGRATION_VERSION, this._VERSION);
            return brewRaw;
        }

        const brewEditable = this._getNewEditableBrewDoc();

        const cpyBrewEditableDoc = BrewDoc.fromObject(brewEditable, {
            isCopy: true
        }).mutMerge({
            json: {
                _meta: existingMeta || {},
                ...existingBrew,
            },
        });

        await this._pSetBrew_({
            val: [cpyBrewEditableDoc],
            isInitialMigration: true
        });

        await this._storage.pSet(this._STORAGE_KEY_MIGRATION_VERSION, this._VERSION);

        JqueryUtil.doToast(`Migrated ${this.DISPLAY_NAME} from version ${version} to version ${this._VERSION}!`);

        return this._storage.pGet(this._STORAGE_KEY);
    }

    _getNewEditableBrewDoc() {
        const json = {
            _meta: {
                sources: []
            }
        };
        return this._getBrewDoc({
            json,
            isEditable: true
        });
    }

    async _pGetMigrationInfo() {
        if (!this._STORAGE_KEY_LEGACY && !this._STORAGE_KEY_LEGACY_META)
            return {
                version: this._VERSION,
                existingBrew: null,
                existingMeta: null
            };

        const version = await this._storage.pGet(this._STORAGE_KEY_MIGRATION_VERSION);

        if (version === this._VERSION)
            return {
                version
            };

        const existingBrew = await this._storage.pGet(this._STORAGE_KEY_LEGACY);
        const existingMeta = await this._storage.syncGet(this._STORAGE_KEY_LEGACY_META);

        return {
            version: version ?? 1,
            existingBrew,
            existingMeta,
        };
    }

    getCacheIteration() {
        return this._cache_iteration;
    }

    async pSetBrew(val, {lockToken}={}) {
        try {
            await this._LOCK.pLock({
                token: lockToken
            });
            await this._pSetBrew_({
                val
            });
        } finally {
            this._LOCK.unlock();
        }
    }

    async _pSetBrew_({val, isInitialMigration}) {
        this._mutBrewsForSet(val);

        if (!isInitialMigration) {
            if (this._cache_brewsProc)
                this._cache_iteration++;
            this._cache_brews = null;
            this._cache_brewsProc = null;
        }
        await this._storage.pSet(this._STORAGE_KEY, val);

        if (!isInitialMigration)
            this._isDirty = true;
    }

    _mutBrewsForSet(val) {
        if (!(val instanceof Array))
            throw new Error(`${this.DISPLAY_NAME.uppercaseFirst()} array must be an array!`);

        this._setBrewMetas(val.map(brew=>this._getBrewDocReduced(brew)));
    }

    _getBrewId(brew) {
        if (brew.head.url)
            return brew.head.url;
        if (brew.body._meta?.sources?.length)
            return brew.body._meta.sources.map(src=>(src.json || "").toLowerCase()).sort(SortUtil.ascSortLower).join(" :: ");
        return null;
    }

    _getNextBrews(brews, brewsToAdd) {
        const idsToAdd = new Set(brewsToAdd.map(brews=>this._getBrewId(brews)).filter(Boolean));
        brews = brews.filter(brew=>{
            const id = this._getBrewId(brew);
            if (id == null)
                return true;
            return !idsToAdd.has(id);
        }
        );
        return [...brews, ...brewsToAdd];
    }

    async _pGetBrewDependencies({brewDocs, brewsRaw=null, brewsRawLocal=null, lockToken}) {
        try {
            lockToken = await this._LOCK.pLock({
                token: lockToken
            });
            return (await this._pGetBrewDependencies_({
                brewDocs,
                brewsRaw,
                brewsRawLocal,
                lockToken
            }));
        } finally {
            this._LOCK.unlock();
        }
    }

    async _pGetBrewDependencies_({brewDocs, brewsRaw=null, brewsRawLocal=null, lockToken}) {
        const urlRoot = await this.pGetCustomUrl();
        const brewIndex = await this._pGetSourceIndex(urlRoot);

        const toLoadSources = [];
        const loadedSources = new Set();
        const out = [];

        brewsRaw = brewsRaw || await this._pGetBrewRaw({
            lockToken
        });
        brewsRawLocal = brewsRawLocal || await this._pGetBrew_pGetLocalBrew({
            lockToken
        });

        const trackLoaded = brew=>(brew.body._meta?.sources || []).filter(src=>src.json).forEach(src=>loadedSources.add(src.json));
        brewsRaw.forEach(brew=>trackLoaded(brew));
        brewsRawLocal.forEach(brew=>trackLoaded(brew));

        brewDocs.forEach(brewDoc=>toLoadSources.push(...this._getBrewDependencySources({
            brewDoc,
            brewIndex
        })));

        while (toLoadSources.length) {
            const src = toLoadSources.pop();
            if (loadedSources.has(src))
                continue;
            loadedSources.add(src);

            const url = this.getFileUrl(brewIndex[src], urlRoot);
            const brewDocDep = await this._pGetBrewDocFromUrl({
                url
            });
            out.push(brewDocDep);
            trackLoaded(brewDocDep);

            toLoadSources.push(...this._getBrewDependencySources({
                brewDoc: brewDocDep,
                brewIndex
            }));
        }

        return out;
    }

    async pGetSourceUrl(source) {
        const urlRoot = await this.pGetCustomUrl();
        const brewIndex = await this._pGetSourceIndex(urlRoot);

        if (brewIndex[source])
            return this.getFileUrl(brewIndex[source], urlRoot);

        const sourceLower = source.toLowerCase();
        if (brewIndex[sourceLower])
            return this.getFileUrl(brewIndex[sourceLower], urlRoot);

        const sourceOriginal = Object.keys(brewIndex).find(k=>k.toLowerCase() === sourceLower);
        if (!brewIndex[sourceOriginal])
            return null;
        return this.getFileUrl(brewIndex[sourceOriginal], urlRoot);
    }

    async _pGetSourceIndex(urlRoot) {
        throw new Error("Unimplemented!");
    }
    getFileUrl(path, urlRoot) {
        throw new Error("Unimplemented!");
    }
    pLoadTimestamps(urlRoot) {
        throw new Error("Unimplemented!");
    }
    pLoadPropIndex(urlRoot) {
        throw new Error("Unimplemented!");
    }
    pLoadMetaIndex(urlRoot) {
        throw new Error("Unimplemented!");
    }

    _PROPS_DEPS = ["dependencies", "includes"];
    _PROPS_DEPS_DEEP = ["otherSources"];

    _getBrewDependencySources({brewDoc, brewIndex}) {
        const out = new Set();

        this._PROPS_DEPS.forEach(prop=>{
            const obj = brewDoc.body._meta?.[prop];
            if (!obj || !Object.keys(obj).length)
                return;
            Object.values(obj).flat().filter(src=>brewIndex[src]).forEach(src=>out.add(src));
        }
        );

        this._PROPS_DEPS_DEEP.forEach(prop=>{
            const obj = brewDoc.body._meta?.[prop];
            if (!obj || !Object.keys(obj).length)
                return;
            return Object.values(obj).map(objSub=>Object.keys(objSub)).flat().filter(src=>brewIndex[src]).forEach(src=>out.add(src));
        }
        );

        return out;
    }

    async pAddBrewFromUrl(url, {lockToken, isLazy}={}) {
        try {
            return (await this._pAddBrewFromUrl({
                url,
                lockToken,
                isLazy
            }));
        } catch (e) {
            JqueryUtil.doToast({
                type: "danger",
                content: `Failed to load ${this.DISPLAY_NAME} from URL "${url}"! ${VeCt.STR_SEE_CONSOLE}`
            });
            setTimeout(()=>{
                throw e;
            }
            );
        }
        return [];
    }

    async _pGetBrewDocFromUrl({url}) {
        const json = await DataUtil.loadRawJSON(url);
        return this._getBrewDoc({
            json,
            url,
            filename: UrlUtil.getFilename(url)
        });
    }

    async _pAddBrewFromUrl({url, lockToken, isLazy}) {
        const brewDoc = await this._pGetBrewDocFromUrl({
            url
        });

        if (isLazy) {
            try {
                await this._LOCK.pLock({
                    token: lockToken
                });
                this._addLazy_brewsTemp.push(brewDoc);
            } finally {
                this._LOCK.unlock();
            }

            return [brewDoc];
        }

        const brewDocs = [brewDoc];
        try {
            lockToken = await this._LOCK.pLock({
                token: lockToken
            });
            const brews = MiscUtil.copyFast(await this._pGetBrewRaw({
                lockToken
            }));

            const brewDocsDependencies = await this._pGetBrewDependencies({
                brewDocs,
                brewsRaw: brews,
                lockToken
            });
            brewDocs.push(...brewDocsDependencies);

            const brewsNxt = this._getNextBrews(brews, brewDocs);
            await this.pSetBrew(brewsNxt, {
                lockToken
            });
        } finally {
            this._LOCK.unlock();
        }

        return brewDocs;
    }

    async pAddBrewsFromFiles(files) {
        try {
            const lockToken = await this._LOCK.pLock();
            return (await this._pAddBrewsFromFiles({
                files,
                lockToken
            }));
        } catch (e) {
            JqueryUtil.doToast({
                type: "danger",
                content: `Failed to load ${this.DISPLAY_NAME} from file(s)! ${VeCt.STR_SEE_CONSOLE}`
            });
            setTimeout(()=>{
                throw e;
            }
            );
        } finally {
            this._LOCK.unlock();
        }
        return [];
    }

    async _pAddBrewsFromFiles({files, lockToken}) {
        const brewDocs = files.map(file=>this._getBrewDoc({
            json: file.json,
            filename: file.name
        }));

        const brews = MiscUtil.copyFast(await this._pGetBrewRaw({
            lockToken
        }));

        const brewDocsDependencies = await this._pGetBrewDependencies({
            brewDocs,
            brewsRaw: brews,
            lockToken
        });
        brewDocs.push(...brewDocsDependencies);

        const brewsNxt = this._getNextBrews(brews, brewDocs);
        await this.pSetBrew(brewsNxt, {
            lockToken
        });

        return brewDocs;
    }

    async pAddBrewsLazyFinalize({lockToken}={}) {
        try {
            lockToken = await this._LOCK.pLock({
                token: lockToken
            });
            return (await this._pAddBrewsLazyFinalize_({
                lockToken
            }));
        } finally {
            this._LOCK.unlock();
        }
    }

    async _pAddBrewsLazyFinalize_({lockToken}) {
        const brewsRaw = await this._pGetBrewRaw({
            lockToken
        });
        const brewDeps = await this._pGetBrewDependencies({
            brewDocs: this._addLazy_brewsTemp,
            brewsRaw,
            lockToken
        });
        const out = MiscUtil.copyFast(brewDeps);
        const brewsNxt = this._getNextBrews(MiscUtil.copyFast(brewsRaw), [...this._addLazy_brewsTemp, ...brewDeps]);
        await this.pSetBrew(brewsNxt, {
            lockToken
        });
        this._addLazy_brewsTemp = [];
        return out;
    }

    async pPullAllBrews({brews}={}) {
        try {
            const lockToken = await this._LOCK.pLock();
            return (await this._pPullAllBrews_({
                lockToken,
                brews
            }));
        } finally {
            this._LOCK.unlock();
        }
    }

    async _pPullAllBrews_({lockToken, brews}) {
        let cntPulls = 0;

        brews = brews || MiscUtil.copyFast(await this._pGetBrewRaw({
            lockToken
        }));
        const brewsNxt = await brews.pMap(async brew=>{
            if (!this.isPullable(brew))
                return brew;

            const json = await DataUtil.loadRawJSON(brew.head.url, {
                isBustCache: true
            });

            const localLastModified = brew.body._meta?.dateLastModified ?? 0;
            const sourceLastModified = json._meta?.dateLastModified ?? 0;

            if (sourceLastModified <= localLastModified)
                return brew;

            cntPulls++;
            return BrewDoc.fromObject(brew).mutUpdate({
                json
            }).toObject();
        }
        );

        if (!cntPulls)
            return cntPulls;

        await this.pSetBrew(brewsNxt, {
            lockToken
        });
        return cntPulls;
    }

    isPullable(brew) {
        return !brew.head.isEditable && !!brew.head.url;
    }

    async pPullBrew(brew) {
        try {
            const lockToken = await this._LOCK.pLock();
            return (await this._pPullBrew_({
                brew,
                lockToken
            }));
        } finally {
            this._LOCK.unlock();
        }
    }

    async _pPullBrew_({brew, lockToken}) {
        const brews = await this._pGetBrewRaw({
            lockToken
        });
        if (!brews?.length)
            return;

        let isPull = false;
        const brewsNxt = await brews.pMap(async it=>{
            if (it.head.docIdLocal !== brew.head.docIdLocal || !this.isPullable(it))
                return it;

            const json = await DataUtil.loadRawJSON(it.head.url, {
                isBustCache: true
            });

            const localLastModified = it.body._meta?.dateLastModified ?? 0;
            const sourceLastModified = json._meta?.dateLastModified ?? 0;

            if (sourceLastModified <= localLastModified)
                return it;

            isPull = true;
            return BrewDoc.fromObject(it).mutUpdate({
                json
            }).toObject();
        }
        );

        if (!isPull)
            return isPull;

        await this.pSetBrew(brewsNxt, {
            lockToken
        });
        return isPull;
    }

    async pAddBrewFromLoaderTag(ele) {
        const $ele = $(ele);
        if (!$ele.hasClass("rd__wrp-loadbrew--ready"))
            return;
        let jsonPath = ele.dataset.rdLoaderPath;
        const name = ele.dataset.rdLoaderName;
        const cached = $ele.html();
        const cachedTitle = $ele.title();
        $ele.title("");
        $ele.removeClass("rd__wrp-loadbrew--ready").html(`${name.qq()}<span class="glyphicon glyphicon-refresh rd__loadbrew-icon rd__loadbrew-icon--active"></span>`);

        jsonPath = jsonPath.unescapeQuotes();
        if (!UrlUtil.isFullUrl(jsonPath)) {
            const brewUrl = await this.pGetCustomUrl();
            jsonPath = this.getFileUrl(jsonPath, brewUrl);
        }

        await this.pAddBrewFromUrl(jsonPath);
        $ele.html(`${name.qq()}<span class="glyphicon glyphicon-saved rd__loadbrew-icon"></span>`);
        setTimeout(()=>$ele.html(cached).addClass("rd__wrp-loadbrew--ready").title(cachedTitle), 500);
    }

    _getBrewDoc({json, url=null, filename=null, isLocal=false, isEditable=false}) {
        return BrewDoc.fromValues({
            head: {
                json,
                url,
                filename,
                isLocal,
                isEditable,
            },
            body: json,
        }).toObject();
    }

    _getBrewDocReduced(brewDoc) {
        return {
            docIdLocal: brewDoc.head.docIdLocal,
            _meta: brewDoc.body._meta
        };
    }

    async pDeleteBrews(brews) {
        try {
            const lockToken = await this._LOCK.pLock();
            await this._pDeleteBrews_({
                brews,
                lockToken
            });
        } finally {
            this._LOCK.unlock();
        }
    }

    async _pDeleteBrews_({brews, lockToken}) {
        const brewsStored = await this._pGetBrewRaw({
            lockToken
        });
        if (!brewsStored?.length)
            return;

        const idsToDelete = new Set(brews.map(brew=>brew.head.docIdLocal));

        const nxtBrews = brewsStored.filter(brew=>!idsToDelete.has(brew.head.docIdLocal));
        await this.pSetBrew(nxtBrews, {
            lockToken
        });
    }

    async pUpdateBrew(brew) {
        try {
            const lockToken = await this._LOCK.pLock();
            await this._pUpdateBrew_({
                brew,
                lockToken
            });
        } finally {
            this._LOCK.unlock();
        }
    }

    async _pUpdateBrew_({brew, lockToken}) {
        const brews = await this._pGetBrewRaw({
            lockToken
        });
        if (!brews?.length)
            return;

        const nxtBrews = brews.map(it=>it.head.docIdLocal !== brew.head.docIdLocal ? it : brew);
        await this.pSetBrew(nxtBrews, {
            lockToken
        });
    }

    pGetEditableBrewDoc(brew) {
        throw new Error("Unimplemented");
    }
    pGetOrCreateEditableBrewDoc() {
        throw new Error("Unimplemented");
    }
    pSetEditableBrewDoc() {
        throw new Error("Unimplemented");
    }
    pGetEditableBrewEntity(prop, uniqueId, {isDuplicate=false}={}) {
        throw new Error("Unimplemented");
    }
    pPersistEditableBrewEntity(prop, ent) {
        throw new Error("Unimplemented");
    }
    pRemoveEditableBrewEntity(prop, uniqueId) {
        throw new Error("Unimplemented");
    }
    pAddSource(sourceObj) {
        throw new Error("Unimplemented");
    }
    pEditSource(sourceObj) {
        throw new Error("Unimplemented");
    }
    pIsEditableSourceJson(sourceJson) {
        throw new Error("Unimplemented");
    }
    pMoveOrCopyToEditableBySourceJson(sourceJson) {
        throw new Error("Unimplemented");
    }
    pMoveToEditable({brews}) {
        throw new Error("Unimplemented");
    }
    pCopyToEditable({brews}) {
        throw new Error("Unimplemented");
    }

    _PAGE_TO_PROPS__SPELLS = [...UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_SPELLS], "spellFluff"];
    _PAGE_TO_PROPS__BESTIARY = ["monster", "legendaryGroup", "monsterFluff"];

    _PAGE_TO_PROPS = {
        [UrlUtil.PG_SPELLS]: this._PAGE_TO_PROPS__SPELLS,
        [UrlUtil.PG_CLASSES]: ["class", "subclass", "classFeature", "subclassFeature"],
        [UrlUtil.PG_BESTIARY]: this._PAGE_TO_PROPS__BESTIARY,
        [UrlUtil.PG_BACKGROUNDS]: ["background"],
        [UrlUtil.PG_FEATS]: ["feat"],
        [UrlUtil.PG_OPT_FEATURES]: ["optionalfeature"],
        [UrlUtil.PG_RACES]: [...UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_RACES], "raceFluff"],
        [UrlUtil.PG_OBJECTS]: ["object"],
        [UrlUtil.PG_TRAPS_HAZARDS]: ["trap", "hazard"],
        [UrlUtil.PG_DEITIES]: ["deity"],
        [UrlUtil.PG_ITEMS]: [...UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_ITEMS], "itemFluff"],
        [UrlUtil.PG_REWARDS]: ["reward"],
        [UrlUtil.PG_PSIONICS]: ["psionic"],
        [UrlUtil.PG_VARIANTRULES]: ["variantrule"],
        [UrlUtil.PG_CONDITIONS_DISEASES]: ["condition", "disease", "status"],
        [UrlUtil.PG_ADVENTURES]: ["adventure", "adventureData"],
        [UrlUtil.PG_BOOKS]: ["book", "bookData"],
        [UrlUtil.PG_TABLES]: ["table", "tableGroup"],
        [UrlUtil.PG_MAKE_BREW]: [...this._PAGE_TO_PROPS__SPELLS, ...this._PAGE_TO_PROPS__BESTIARY, "makebrewCreatureTrait", ],
        [UrlUtil.PG_MANAGE_BREW]: ["*"],
        [UrlUtil.PG_MANAGE_PRERELEASE]: ["*"],
        [UrlUtil.PG_DEMO_RENDER]: ["*"],
        [UrlUtil.PG_VEHICLES]: ["vehicle", "vehicleUpgrade"],
        [UrlUtil.PG_ACTIONS]: ["action"],
        [UrlUtil.PG_CULTS_BOONS]: ["cult", "boon"],
        [UrlUtil.PG_LANGUAGES]: ["language", "languageScript"],
        [UrlUtil.PG_CHAR_CREATION_OPTIONS]: ["charoption"],
        [UrlUtil.PG_RECIPES]: ["recipe"],
        [UrlUtil.PG_CLASS_SUBCLASS_FEATURES]: ["classFeature", "subclassFeature"],
        [UrlUtil.PG_DECKS]: ["card", "deck"],
    };

    getPageProps({page, isStrict=false, fallback=null}={}) {
        page = this._getBrewPage(page);

        const out = this._PAGE_TO_PROPS[page];
        if (out)
            return out;
        if (fallback)
            return fallback;

        if (isStrict)
            throw new Error(`No ${this.DISPLAY_NAME} properties defined for category ${page}`);

        return null;
    }

    getPropPages() {
        return Object.entries(this._PAGE_TO_PROPS).map(([page,props])=>[page, props.filter(it=>it !== "*")]).filter(([,props])=>props.length).map(([page])=>page);
    }

    _getBrewPage(page) {
        return page || (IS_VTT ? this.PAGE_MANAGE : UrlUtil.getCurrentPage());
    }

    getDirProp(dir) {
        switch (dir) {
        case "creature":
            return "monster";
        case "makebrew":
            return "makebrewCreatureTrait";
        }
        return dir;
    }

    getPropDisplayName(prop) {
        switch (prop) {
        case "adventure":
            return "Adventure Contents/Info";
        case "book":
            return "Book Contents/Info";
        }
        return Parser.getPropDisplayName(prop);
    }

    _doCacheMetas() {
        if (this._cache_metas)
            return;

        this._cache_metas = {};

        (this._getBrewMetas() || []).forEach(({_meta})=>{
            Object.entries(_meta || {}).forEach(([prop,val])=>{
                if (!val)
                    return;
                if (typeof val !== "object")
                    return;

                if (val instanceof Array) {
                    (this._cache_metas[prop] = this._cache_metas[prop] || []).push(...MiscUtil.copyFast(val));
                    return;
                }

                this._cache_metas[prop] = this._cache_metas[prop] || {};
                Object.assign(this._cache_metas[prop], MiscUtil.copyFast(val));
            }
            );
        }
        );

        this._cache_metas["_sources"] = (this._getBrewMetas() || []).mergeMap(({_meta})=>{
            return (_meta?.sources || []).mergeMap(src=>({
                [(src.json || "").toLowerCase()]: MiscUtil.copyFast(src)
            }));
        }
        );
    }

    hasSourceJson(source) {
        if (!source)
            return false;
        source = source.toLowerCase();
        return !!this.getMetaLookup("_sources")[source];
    }

    sourceJsonToFull(source) {
        if (!source)
            return "";
        source = source.toLowerCase();
        return this.getMetaLookup("_sources")[source]?.full || source;
    }

    sourceJsonToAbv(source) {
        if (!source)
            return "";
        source = source.toLowerCase();
        return this.getMetaLookup("_sources")[source]?.abbreviation || source;
    }

    sourceJsonToDate(source) {
        if (!source)
            return "";
        source = source.toLowerCase();
        return this.getMetaLookup("_sources")[source]?.dateReleased || "1970-01-01";
    }

    sourceJsonToSource(source) {
        if (!source)
            return null;
        source = source.toLowerCase();
        return this.getMetaLookup("_sources")[source];
    }

    sourceJsonToStyle(source) {
        const stylePart = this.sourceJsonToStylePart(source);
        if (!stylePart)
            return stylePart;
        return `style="${stylePart}"`;
    }

    sourceToStyle(source) {
        const stylePart = this.sourceToStylePart(source);
        if (!stylePart)
            return stylePart;
        return `style="${stylePart}"`;
    }

    sourceJsonToStylePart(source) {
        if (!source)
            return "";
        const color = this.sourceJsonToColor(source);
        if (color)
            return this._getColorStylePart(color);
        return "";
    }

    sourceToStylePart(source) {
        if (!source)
            return "";
        const color = this.sourceToColor(source);
        if (color)
            return this._getColorStylePart(color);
        return "";
    }

    _getColorStylePart(color) {
        return `color: #${color} !important; border-color: #${color} !important; text-decoration-color: #${color} !important;`;
    }

    sourceJsonToColor(source) {
        if (!source)
            return "";
        source = source.toLowerCase();
        if (!this.getMetaLookup("_sources")[source]?.color)
            return "";
        return BrewUtilShared$1.getValidColor(this.getMetaLookup("_sources")[source].color);
    }

    sourceToColor(source) {
        if (!source?.color)
            return "";
        return BrewUtilShared$1.getValidColor(source.color);
    }

    getSources() {
        this._doCacheMetas();
        return Object.values(this._cache_metas["_sources"]);
    }

    getMetaLookup(type) {
        if (!type)
            return null;
        this._doCacheMetas();
        return this._cache_metas[type];
    }

    getMergedData(data, homebrew) {
        const out = {};
        Object.entries(data).forEach(([prop,val])=>{
            if (!homebrew[prop]) {
                out[prop] = [...val];
                return;
            }

            if (!(homebrew[prop]instanceof Array))
                throw new Error(`${this.DISPLAY_NAME.uppercaseFirst()} was not array!`);
            if (!(val instanceof Array))
                throw new Error(`Data was not array!`);
            out[prop] = [...val, ...homebrew[prop]];
        }
        );

        return out;
    }

    async pGetSearchIndex({id=0}={}) {
        const indexer = new Omnidexer(id);

        const brew = await this.pGetBrewProcessed();

        await [...Omnidexer.TO_INDEX__FROM_INDEX_JSON, ...Omnidexer.TO_INDEX].pSerialAwaitMap(async arbiter=>{
            if (arbiter.isSkipBrew)
                return;
            if (!brew[arbiter.brewProp || arbiter.listProp]?.length)
                return;

            if (arbiter.pFnPreProcBrew) {
                const toProc = await arbiter.pFnPreProcBrew.bind(arbiter)(brew);
                await indexer.pAddToIndex(arbiter, toProc);
                return;
            }

            await indexer.pAddToIndex(arbiter, brew);
        }
        );

        return Omnidexer.decompressIndex(indexer.getIndex());
    }

    async pGetAdditionalSearchIndices(highestId, addiProp) {
        const indexer = new Omnidexer(highestId + 1);

        const brew = await this.pGetBrewProcessed();

        await [...Omnidexer.TO_INDEX__FROM_INDEX_JSON, ...Omnidexer.TO_INDEX].filter(it=>it.additionalIndexes && (brew[it.listProp] || []).length).pMap(it=>{
            Object.entries(it.additionalIndexes).filter(([prop])=>prop === addiProp).pMap(async([,pGetIndex])=>{
                const toIndex = await pGetIndex(indexer, {
                    [it.listProp]: brew[it.listProp]
                });
                toIndex.forEach(add=>indexer.pushToIndex(add));
            }
            );
        }
        );

        return Omnidexer.decompressIndex(indexer.getIndex());
    }

    async pGetAlternateSearchIndices(highestId, altProp) {
        const indexer = new Omnidexer(highestId + 1);

        const brew = await this.pGetBrewProcessed();

        await [...Omnidexer.TO_INDEX__FROM_INDEX_JSON, ...Omnidexer.TO_INDEX].filter(ti=>ti.alternateIndexes && (brew[ti.listProp] || []).length).pSerialAwaitMap(async arbiter=>{
            await Object.keys(arbiter.alternateIndexes).filter(prop=>prop === altProp).pSerialAwaitMap(async prop=>{
                await indexer.pAddToIndex(arbiter, brew, {
                    alt: arbiter.alternateIndexes[prop]
                });
            }
            );
        }
        );

        return Omnidexer.decompressIndex(indexer.getIndex());
    }

    async pGetUrlExportableSources() {
        const brews = await this._pGetBrewRaw();
        const brewsExportable = brews.filter(brew=>!brew.head.isEditable && !brew.head.isLocal);
        return brewsExportable.flatMap(brew=>brew.body._meta.sources.map(src=>src.json)).unique();
    }
}

class _BrewUtil2 extends _BrewUtil2Base {
    _STORAGE_KEY_LEGACY = "HOMEBREW_STORAGE";
    _STORAGE_KEY_LEGACY_META = "HOMEBREW_META_STORAGE";

    _STORAGE_KEY = "HOMEBREW_2_STORAGE";
    _STORAGE_KEY_META = "HOMEBREW_2_STORAGE_METAS";

    _STORAGE_KEY_CUSTOM_URL = "HOMEBREW_CUSTOM_REPO_URL";
    _STORAGE_KEY_MIGRATION_VERSION = "HOMEBREW_2_STORAGE_MIGRATION";

    _VERSION = 2;

    _PATH_LOCAL_DIR = "homebrew";
    _PATH_LOCAL_INDEX = VeCt.JSON_BREW_INDEX;

    IS_EDITABLE = true;
    PAGE_MANAGE = UrlUtil.PG_MANAGE_BREW;
    URL_REPO_DEFAULT = VeCt.URL_BREW;
    DISPLAY_NAME = "homebrew";
    DISPLAY_NAME_PLURAL = "homebrews";
    DEFAULT_AUTHOR = "";
    STYLE_BTN = "btn-info";

    _pInit_doBindDragDrop() {
        document.body.addEventListener("drop", async evt=>{
            if (EventUtil.isInInput(evt))
                return;

            evt.stopPropagation();
            evt.preventDefault();

            const files = evt.dataTransfer?.files;
            if (!files?.length)
                return;

            const pFiles = [...files].map((file,i)=>{
                if (!/\.json$/i.test(file.name))
                    return null;

                return new Promise(resolve=>{
                    const reader = new FileReader();
                    reader.onload = ()=>{
                        let json;
                        try {
                            json = JSON.parse(reader.result);
                        } catch (ignored) {
                            return resolve(null);
                        }

                        resolve({
                            name: file.name,
                            json
                        });
                    }
                    ;

                    reader.readAsText(files[i]);
                }
                );
            }
            );

            const fileMetas = (await Promise.allSettled(pFiles)).filter(({status})=>status === "fulfilled").map(({value})=>value).filter(Boolean);

            await this.pAddBrewsFromFiles(fileMetas);

            if (this.isReloadRequired())
                location.reload();
        }
        );

        document.body.addEventListener("dragover", evt=>{
            if (EventUtil.isInInput(evt))
                return;

            evt.stopPropagation();
            evt.preventDefault();
        }
        );
    }

    async _pGetSourceIndex(urlRoot) {
        return DataUtil.brew.pLoadSourceIndex(urlRoot);
    }

    getFileUrl(path, urlRoot) {
        return DataUtil.brew.getFileUrl(path, urlRoot);
    }

    pLoadTimestamps(brewIndex, src, urlRoot) {
        return DataUtil.brew.pLoadTimestamps(urlRoot);
    }

    pLoadPropIndex(brewIndex, src, urlRoot) {
        return DataUtil.brew.pLoadPropIndex(urlRoot);
    }

    pLoadMetaIndex(brewIndex, src, urlRoot) {
        return DataUtil.brew.pLoadMetaIndex(urlRoot);
    }

    async pGetEditableBrewDoc() {
        return this._findEditableBrewDoc({
            brewRaw: await this._pGetBrewRaw()
        });
    }

    _findEditableBrewDoc({brewRaw}) {
        return brewRaw.find(it=>it.head.isEditable);
    }

    async pGetOrCreateEditableBrewDoc() {
        const existing = await this.pGetEditableBrewDoc();
        if (existing)
            return existing;

        const brew = this._getNewEditableBrewDoc();
        const brews = [...MiscUtil.copyFast(await this._pGetBrewRaw()), brew];
        await this.pSetBrew(brews);

        return brew;
    }

    async pSetEditableBrewDoc(brew) {
        if (!brew?.head?.docIdLocal || !brew?.body)
            throw new Error(`Invalid editable brew document!`);
        await this.pUpdateBrew(brew);
    }

    async pGetEditableBrewEntity(prop, uniqueId, {isDuplicate=false}={}) {
        if (!uniqueId)
            throw new Error(`A "uniqueId" must be provided!`);

        const brew = await this.pGetOrCreateEditableBrewDoc();

        const out = (brew.body?.[prop] || []).find(it=>it.uniqueId === uniqueId);
        if (!out || !isDuplicate)
            return out;

        if (isDuplicate)
            out.uniqueId = CryptUtil.uid();

        return out;
    }

    async pPersistEditableBrewEntity(prop, ent) {
        if (!ent.uniqueId)
            throw new Error(`Entity did not have a "uniqueId"!`);

        const brew = await this.pGetOrCreateEditableBrewDoc();

        const ixExisting = (brew.body?.[prop] || []).findIndex(it=>it.uniqueId === ent.uniqueId);
        if (!~ixExisting) {
            const nxt = MiscUtil.copyFast(brew);
            MiscUtil.getOrSet(nxt.body, prop, []).push(ent);

            await this.pUpdateBrew(nxt);

            return;
        }

        const nxt = MiscUtil.copyFast(brew);
        nxt.body[prop][ixExisting] = ent;

        await this.pUpdateBrew(nxt);
    }

    async pRemoveEditableBrewEntity(prop, uniqueId) {
        if (!uniqueId)
            throw new Error(`A "uniqueId" must be provided!`);

        const brew = await this.pGetOrCreateEditableBrewDoc();

        if (!brew.body?.[prop]?.length)
            return;

        const nxt = MiscUtil.copyFast(brew);
        nxt.body[prop] = nxt.body[prop].filter(it=>it.uniqueId !== uniqueId);

        if (nxt.body[prop].length === brew.body[prop])
            return;
        await this.pUpdateBrew(nxt);
    }

    async pAddSource(sourceObj) {
        const existing = await this.pGetEditableBrewDoc();

        if (existing) {
            const nxt = MiscUtil.copyFast(existing);
            const sources = MiscUtil.getOrSet(nxt.body, "_meta", "sources", []);
            sources.push(sourceObj);

            await this.pUpdateBrew(nxt);

            return;
        }

        const json = {
            _meta: {
                sources: [sourceObj]
            }
        };
        const brew = this._getBrewDoc({
            json,
            isEditable: true
        });
        const brews = [...MiscUtil.copyFast(await this._pGetBrewRaw()), brew];
        await this.pSetBrew(brews);
    }

    async pEditSource(sourceObj) {
        const existing = await this.pGetEditableBrewDoc();
        if (!existing)
            throw new Error(`Editable brew document does not exist!`);

        const nxt = MiscUtil.copyFast(existing);
        const sources = MiscUtil.get(nxt.body, "_meta", "sources");
        if (!sources)
            throw new Error(`Source "${sourceObj.json}" does not exist in editable brew document!`);

        const existingSourceObj = sources.find(it=>it.json === sourceObj.json);
        if (!existingSourceObj)
            throw new Error(`Source "${sourceObj.json}" does not exist in editable brew document!`);
        Object.assign(existingSourceObj, sourceObj);

        await this.pUpdateBrew(nxt);
    }

    async pIsEditableSourceJson(sourceJson) {
        const brew = await this.pGetEditableBrewDoc();
        if (!brew)
            return false;

        const sources = MiscUtil.get(brew.body, "_meta", "sources") || [];
        return sources.some(it=>it.json === sourceJson);
    }

    async pMoveOrCopyToEditableBySourceJson(sourceJson) {
        if (await this.pIsEditableSourceJson(sourceJson))
            return;

        const brews = (await this._pGetBrewRaw()).filter(brew=>(brew.body._meta?.sources || []).some(src=>src.json === sourceJson));
        const brewsLocal = (await this._pGetBrew_pGetLocalBrew()).filter(brew=>(brew.body._meta?.sources || []).some(src=>src.json === sourceJson));

        let brew = brews.find(brew=>BrewDoc.isOperationPermitted_moveToEditable({
            brew
        }));
        if (!brew)
            brew = brewsLocal.find(brew=>BrewDoc.isOperationPermitted_moveToEditable({
                brew,
                isAllowLocal: true
            }));

        if (!brew)
            return;

        if (brew.head.isLocal)
            return this.pCopyToEditable({
                brews: [brew]
            });

        return this.pMoveToEditable({
            brews: [brew]
        });
    }

    async pMoveToEditable({brews}) {
        const out = await this.pCopyToEditable({
            brews
        });
        await this.pDeleteBrews(brews);
        return out;
    }

    async pCopyToEditable({brews}) {
        const brewEditable = await this.pGetOrCreateEditableBrewDoc();

        const cpyBrewEditableDoc = BrewDoc.fromObject(brewEditable, {
            isCopy: true
        });
        brews.forEach((brew,i)=>cpyBrewEditableDoc.mutMerge({
            json: brew.body,
            isLazy: i !== brews.length - 1
        }));

        await this.pSetEditableBrewDoc(cpyBrewEditableDoc.toObject());

        return cpyBrewEditableDoc;
    }
}

class _PrereleaseUtil extends _BrewUtil2Base {
    _STORAGE_KEY_LEGACY = null;
    _STORAGE_KEY_LEGACY_META = null;

    _STORAGE_KEY = "PRERELEASE_STORAGE";
    _STORAGE_KEY_META = "PRERELEASE_META_STORAGE";

    _STORAGE_KEY_CUSTOM_URL = "PRERELEASE_CUSTOM_REPO_URL";
    _STORAGE_KEY_MIGRATION_VERSION = "PRERELEASE_STORAGE_MIGRATION";

    _PATH_LOCAL_DIR = "prerelease";
    _PATH_LOCAL_INDEX = VeCt.JSON_PRERELEASE_INDEX;

    _VERSION = 1;

    IS_EDITABLE = false;
    PAGE_MANAGE = UrlUtil.PG_MANAGE_PRERELEASE;
    URL_REPO_DEFAULT = VeCt.URL_PRERELEASE;
    DISPLAY_NAME = "prerelease content";
    DISPLAY_NAME_PLURAL = "prereleases";
    DEFAULT_AUTHOR = "Wizards of the Coast";
    STYLE_BTN = "btn-primary";

    _pInit_doBindDragDrop() {}

    async _pGetSourceIndex(urlRoot) {
        return DataUtil.prerelease.pLoadSourceIndex(urlRoot);
    }

    getFileUrl(path, urlRoot) {
        return DataUtil.prerelease.getFileUrl(path, urlRoot);
    }

    pLoadTimestamps(brewIndex, src, urlRoot) {
        return DataUtil.prerelease.pLoadTimestamps(urlRoot);
    }

    pLoadPropIndex(brewIndex, src, urlRoot) {
        return DataUtil.prerelease.pLoadPropIndex(urlRoot);
    }

    pLoadMetaIndex(brewIndex, src, urlRoot) {
        return DataUtil.prerelease.pLoadMetaIndex(urlRoot);
    }

    pGetEditableBrewDoc(brew) {
        return super.pGetEditableBrewDoc(brew);
    }
    pGetOrCreateEditableBrewDoc() {
        return super.pGetOrCreateEditableBrewDoc();
    }
    pSetEditableBrewDoc() {
        return super.pSetEditableBrewDoc();
    }
    pGetEditableBrewEntity(prop, uniqueId, {isDuplicate=false}={}) {
        return super.pGetEditableBrewEntity(prop, uniqueId, {
            isDuplicate
        });
    }
    pPersistEditableBrewEntity(prop, ent) {
        return super.pPersistEditableBrewEntity(prop, ent);
    }
    pRemoveEditableBrewEntity(prop, uniqueId) {
        return super.pRemoveEditableBrewEntity(prop, uniqueId);
    }
    pAddSource(sourceObj) {
        return super.pAddSource(sourceObj);
    }
    pEditSource(sourceObj) {
        return super.pEditSource(sourceObj);
    }
    pIsEditableSourceJson(sourceJson) {
        return super.pIsEditableSourceJson(sourceJson);
    }
    pMoveOrCopyToEditableBySourceJson(sourceJson) {
        return super.pMoveOrCopyToEditableBySourceJson(sourceJson);
    }
    pMoveToEditable({brews}) {
        return super.pMoveToEditable({
            brews
        });
    }
    pCopyToEditable({brews}) {
        return super.pCopyToEditable({
            brews
        });
    }

}

globalThis.BrewUtil2 = new _BrewUtil2();
globalThis.PrereleaseUtil = new _PrereleaseUtil();
//#endregion

//#region Helper Functions
class HelperFunctions{

    /**
     * Will set the modal to only have the sources provided enabled (all others will be set to 0)
     * @param {ModalFilter} modalFilter
     * @param {String[]} sourcesToUse example: ["PHB", "XGE", "TCE"]
     */
    static setModalFilterSourcesStrings(modalFilter, sourcesToUse){
        let sources = {};
        for(let src of sourcesToUse){
            sources[src] = 1;
        }
        modalFilter.pageFilter.filterBox.setFromValues({Source: sources});
    }

    static getClassFeaturesFromClassInData(myData, cls){
        return myData.classFeature.filter(f => !!f && f.className == cls.name && f.classSource == cls.source);
    }

    static async loadJSONFile(localURL){
        //const localURL = "data/class/index.json";
        const result = await DataUtil.loadRawJSON(localURL);
        return result;
    }
}
//#endregion

Charactermancer_StartingEquipment._EQUIPMENT_SET_NAMES = {
    weaponAny: "Weapon",
    weaponSimple: "Simple Weapon",
    weaponSimpleMelee: "Simple Melee Weapon",
    weaponSimpleRanged: "Simple Ranged Weapon",
    weaponMartial: "Martial Weapon",
    weaponMartialMelee: "Martial Melee Weapon",
    weaponMartialRanged: "Martial Ranged Weapon",
    instrumentMusical: "Musical Instrument",
    armorLight: "Light Armor",
    armorMedium: "Medium Armor",
    armorHeavy: "Heavy Armor",
    weaponMelee: "Melee Weapon",
    weaponRanged: "Ranged Weapon",
    focusSpellcasting: "Spellcasting Focus",
    setGaming: "Gaming Set",
    toolArtisan: "Artisan's Tool",
};
Charactermancer_StartingEquipment._EQUIPMENT_SETS = {
    weapon: [...UtilDataConverter.WEAPONS_SIMPLE, ...UtilDataConverter.WEAPONS_MARTIAL, ],
    weaponSimple: [...UtilDataConverter.WEAPONS_SIMPLE, ],
    weaponSimpleMelee: ["club|phb", "dagger|phb", "greatclub|phb", "handaxe|phb", "javelin|phb", "light hammer|phb", "mace|phb", "quarterstaff|phb", "sickle|phb", "spear|phb", ],
    weaponSimpleRanged: ["light crossbow|phb", "shortbow|phb", ],
    weaponMartial: [...UtilDataConverter.WEAPONS_MARTIAL, ],
    weaponMartialMelee: ["battleaxe|phb", "flail|phb", "glaive|phb", "greataxe|phb", "greatsword|phb", "halberd|phb", "lance|phb", "longsword|phb", "maul|phb", "morningstar|phb", "pike|phb", "rapier|phb", "scimitar|phb", "shortsword|phb", "trident|phb", "war pick|phb", "warhammer|phb", "whip|phb", ],
    weaponMartialRanged: ["blowgun|phb", "hand crossbow|phb", "heavy crossbow|phb", "longbow|phb", ],
    instrumentMusical: ["bagpipes|phb", "drum|phb", "dulcimer|phb", "flute|phb", "horn|phb", "lute|phb", "lyre|phb", "pan flute|phb", "shawm|phb", "viol|phb", ],
    armorLight: ["leather armor|phb", "padded armor|phb", "studded leather armor|phb", ],
    armorMedium: ["hide armor|phb", "chain shirt|phb", "scale mail|phb", "breastplate|phb", "half plate armor|phb", ],
    armorHeavy: ["ring mail|phb", "chain mail|phb", "splint armor|phb", "plate armor|phb", ],
    weaponMelee: ["battleaxe|phb", "club|phb", "dagger|phb", "flail|phb", "glaive|phb", "greataxe|phb", "greatclub|phb", "greatsword|phb", "halberd|phb", "handaxe|phb", "javelin|phb", "lance|phb", "light hammer|phb", "longsword|phb", "mace|phb", "maul|phb", "morningstar|phb", "pike|phb", "quarterstaff|phb", "rapier|phb", "scimitar|phb", "shortsword|phb", "sickle|phb", "spear|phb", "staff|phb", "trident|phb", "war pick|phb", "warhammer|phb", "whip|phb", ],
    weaponRanged: ["blowgun|phb", "dart|phb", "hand crossbow|phb", "heavy crossbow|phb", "light crossbow|phb", "longbow|phb", "net|phb", "shortbow|phb", "sling|phb", ],
    focusSpellcasting: ["crystal|phb", "orb|phb", "rod|phb", "staff|phb", "wand|phb", ],
    setGaming: ["dice set|phb", "dragonchess set|phb", "playing card set|phb", "three-dragon ante set|phb", ],
    toolArtisan: ["alchemist's supplies|phb", "brewer's supplies|phb", "calligrapher's supplies|phb", "carpenter's tools|phb", "cartographer's tools|phb", "cobbler's tools|phb", "cook's utensils|phb", "glassblower's tools|phb", "jeweler's tools|phb", "leatherworker's tools|phb", "mason's tools|phb", "painter's supplies|phb", "potter's tools|phb", "smith's tools|phb", "tinker's tools|phb", "weaver's tools|phb", "woodcarver's tools|phb", ],
};

let Hist = class Hist {
    static hashChange({isForceLoad, isBlankFilterLoad=false}={}) {
        if (Hist.isHistorySuppressed) {
            Hist.setSuppressHistory(false);
            return;
        }

        const [link,...sub] = Hist.getHashParts();

        if (link !== Hist.lastLoadedLink || sub.length === 0 || isForceLoad) {
            Hist.lastLoadedLink = link;
            if (link === HASH_BLANK) {
                isBlankFilterLoad = true;
            } else {
                const listItem = Hist.getActiveListItem(link);

                if (listItem == null) {
                    if (typeof pHandleUnknownHash === "function" && window.location.hash.length && Hist._lastUnknownLink !== link) {
                        Hist._lastUnknownLink = link;
                        pHandleUnknownHash(link, sub);
                        return;
                    } else {
                        Hist._freshLoad();
                        return;
                    }
                }

                const toLoad = listItem.ix;
                if (toLoad === undefined)
                    Hist._freshLoad();
                else {
                    Hist.lastLoadedId = listItem.ix;
                    loadHash(listItem.ix);
                    document.title = `${listItem.name ? `${listItem.name} - ` : ""}5etools`;
                }
            }
        }

        if (typeof loadSubHash === "function" && (sub.length > 0 || isForceLoad))
            loadSubHash(sub);
        if (isBlankFilterLoad)
            Hist._freshLoad();
    }

    static init(initialLoadComplete) {
        window.onhashchange = ()=>Hist.hashChange({
            isForceLoad: true
        });
        if (window.location.hash.length) {
            Hist.hashChange();
        } else {
            Hist._freshLoad();
        }
        if (initialLoadComplete)
            Hist.initialLoad = false;
    }

    static setSuppressHistory(val) {
        Hist.isHistorySuppressed = val;
    }

    static _listPage = null;

    static setListPage(listPage) {
        this._listPage = listPage;
    }

    static getSelectedListItem() {
        const [link] = Hist.getHashParts();
        return Hist.getActiveListItem(link);
    }

    static getSelectedListElementWithLocation() {
        const [link] = Hist.getHashParts();
        return Hist.getActiveListItem(link, true);
    }

    static getHashParts() {
        return Hist.util.getHashParts(window.location.hash);
    }

    static getActiveListItem(link, getIndex) {
        const primaryLists = this._listPage.primaryLists;
        if (primaryLists && primaryLists.length) {
            for (let x = 0; x < primaryLists.length; ++x) {
                const list = primaryLists[x];

                const foundItemIx = list.items.findIndex(it=>it.values.hash === link);
                if (~foundItemIx) {
                    if (getIndex)
                        return {
                            item: list.items[foundItemIx],
                            x: x,
                            y: foundItemIx,
                            list
                        };
                    return list.items[foundItemIx];
                }
            }
        }
    }

    static _freshLoad() {
        setTimeout(()=>{
            const goTo = $("#listcontainer").find(".list a").attr("href");
            if (goTo) {
                const parts = location.hash.split(HASH_PART_SEP);
                const fullHash = `${goTo}${parts.length > 1 ? `${HASH_PART_SEP}${parts.slice(1).join(HASH_PART_SEP)}` : ""}`;
                location.replace(fullHash);
            }
        }
        , 1);
    }

    static cleanSetHash(toSet) {
        window.location.hash = Hist.util.getCleanHash(toSet);
    }

    static getHashSource() {
        const [link] = Hist.getHashParts();
        return link ? link.split(HASH_LIST_SEP).last() : null;
    }

    static getSubHash(key) {
        return Hist.util.getSubHash(window.location.hash, key);
    }

    static setSubhash(key, val) {
        const nxtHash = Hist.util.setSubhash(window.location.hash, key, val);
        Hist.cleanSetHash(nxtHash);
    }

    static setMainHash(hash) {
        const subHashPart = Hist.util.getHashParts(window.location.hash, key, val).slice(1).join(HASH_PART_SEP);
        Hist.cleanSetHash([hash, subHashPart].filter(Boolean).join(HASH_PART_SEP));
    }

    static replaceHistoryHash(hash) {
        window.history.replaceState({}, document.title, `${location.origin}${location.pathname}${hash ? `#${hash}` : ""}`, );
    }
}
;
Hist.lastLoadedLink = null;
Hist._lastUnknownLink = null;
Hist.lastLoadedId = null;
Hist.initialLoad = true;
Hist.isHistorySuppressed = false;

Hist.util = class {
    static getCleanHash(hash) {
        return hash.replace(/,+/g, ",").replace(/,$/, "").toLowerCase();
    }

    static _SYMS_NO_ENCODE = [/(,)/g, /(:)/g, /(=)/g];

    static getHashParts(location, {isReturnEncoded=false}={}) {
        if (location[0] === "#")
            location = location.slice(1);

        if (location === "google_vignette")
            location = "";

        if (isReturnEncoded) {
            return location.split(HASH_PART_SEP);
        }

        let pts = [location];
        this._SYMS_NO_ENCODE.forEach(re=>{
            pts = pts.map(pt=>pt.split(re)).flat();
        }
        );
        pts = pts.map(pt=>{
            if (this._SYMS_NO_ENCODE.some(re=>re.test(pt)))
                return pt;
            return decodeURIComponent(pt).toUrlified();
        }
        );
        location = pts.join("");

        return location.split(HASH_PART_SEP);
    }

    static getSubHash(location, key) {
        const [link,...sub] = Hist.util.getHashParts(location);
        const hKey = `${key}${HASH_SUB_KV_SEP}`;
        const part = sub.find(it=>it.startsWith(hKey));
        if (part)
            return part.slice(hKey.length);
        return null;
    }

    static setSubhash(location, key, val) {
        if (key.endsWith(HASH_SUB_KV_SEP))
            key = key.slice(0, -1);

        const [link,...sub] = Hist.util.getHashParts(location);
        if (!link)
            return "";

        const hKey = `${key}${HASH_SUB_KV_SEP}`;
        const out = [link];
        if (sub.length)
            sub.filter(it=>!it.startsWith(hKey)).forEach(it=>out.push(it));
        if (val != null)
            out.push(`${hKey}${val}`);

        return Hist.util.getCleanHash(out.join(HASH_PART_SEP));
    }
};

