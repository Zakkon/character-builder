
document.addEventListener('DOMContentLoaded', function () {
    JqueryUtil.initEnhancements();
    //test_AddClassPage();
});
window.addEventListener('load', function () {
   
    /* createPage_ClassSelect();
    addNewClassChoiceSection();
    let exportBtn = $(document).find("#btn_export");
    exportBtn.on('click', () => {
        e_onPressExportButton();
    }); */
    test_AddClassPage();

    
});

function test_AddClassPage(){

    let window = new ParentWindow();
    
    //let comp = new ActorCharactermancerClass(window);
    //Lets try to add it to our DOM
    //comp.render();
}
class SETTINGS{
    static FILTERS = false;
    static PARENTLESS_MODE = true;
    static DO_RENDER_DICE = false;
    static USE_EXISTING = false;
}
class ParentWindow {
    tabClass;
    tabRace;
    tabAbilities;
    tabButtonParent;
    comp_class;
    comp_race;
    comp_ability;

    constructor(){

        this.createTabs();

        const _root = $("#window-root");

        const $tabClass = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabClass = new WindowTab($tabClass);
        const $tabRace = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabRace = new WindowTab($tabRace);
        const $tabAbilities = $(`<div class="ui-tab__wrp-tab-body ve-flex-col ui-tab__wrp-tab-body--border"></div>`).appendTo(_root);
        this.tabAbilities = new WindowTab($tabAbilities);


        this.data = ContentGetter._getBase();
        this.data.races = ContentGetter.getRaces(true);

        this.comp_class = new ActorCharactermancerClass(this);
        this.comp_class.render();

        this.comp_race = new ActorCharactermancerRace(this);
        this.comp_race.render();

        this.comp_ability = new ActorCharactermancerAbility(this);
        this.comp_ability.render();

        this.e_switchTab("class");
    }

    createTabs(){
        const tabHolder = $(`.tab_button_holder`);
        //Create the tabs

        //Class tab (mark as active)
        const clsBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Class</button>`).click(()=>{
            this.e_switchTab("class");
        }).appendTo(tabHolder);
        const raceBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Race</button>`).click(()=>{
            this.e_switchTab("race");
        }).appendTo(tabHolder);
        const ablBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Abilities</button>`).click(()=>{
            this.e_switchTab("abilities");
        }).appendTo(tabHolder);
        const bckBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Background</button>`).click(()=>{

        }).appendTo(tabHolder);
        const startEqBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Starting Equipment</button>`).click(()=>{

        }).appendTo(tabHolder);
        const eqShopBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Equipment Shop</button>`).click(()=>{

        }).appendTo(tabHolder);
        const spellsBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Spells</button>`).click(()=>{

        }).appendTo(tabHolder);
        const featsBtn = $(`<button class="btn btn-default ui-tab__btn-tab-head btn-sm">Feats</button>`).click(()=>{

        }).appendTo(tabHolder);
        
        this.tabButtonParent = tabHolder;
        clsBtn.addClass("active");
    }

    //#region Events
    e_switchTab(tabName){
        //TODO: improve this
        //this.panel_class.setActive(false);
        //this.panel_race.setActive(false);
        let newActivePanel = null;
        let tabIx = 0;
        this.tabButtonParent.children().each(function() {$(this).removeClass("active");});
        this.setActive(this.tabClass.$wrpTab, false);
        this.setActive(this.tabRace.$wrpTab, false);
        this.setActive(this.tabAbilities.$wrpTab, false);

        switch(tabName){
            case "class": newActivePanel = this.tabClass; tabIx = 0; break;
            case "race": newActivePanel = this.tabRace; tabIx = 1; break;
            case "abilities": newActivePanel = this.tabAbilities; tabIx = 2; break;
        }
        const pressedBtn = this.tabButtonParent.children().eq(tabIx);
        pressedBtn.addClass("active");
        this.setActive(newActivePanel.$wrpTab, true);
    }
    //#endregion

    
    setActive($tab, active){
        const hi = "ve-hidden";
        if(!$tab){return;}
        if(active && $tab.hasClass(hi)){$tab.removeClass(hi);}
        else if(!active && !$tab.hasClass(hi)){$tab.addClass(hi);}
   }
}
/**Don't think of this as a tab button, but more as a tab screen */
class WindowTab {
    $wrpTab;
    constructor(parentDiv){
        this.$wrpTab = parentDiv;
    }
    
}

//#region Parser
globalThis.Parser = {};
Parser._parse_aToB = function(abMap, a, fallback) {
    if (a === undefined || a === null)
        throw new TypeError("undefined or null object passed to parser");
    if (typeof a === "string")
        a = a.trim();
    if (abMap[a] !== undefined)
        return abMap[a];
    return fallback !== undefined ? fallback : a;
}
;

Parser._parse_bToA = function(abMap, b, fallback) {
    if (b === undefined || b === null)
        throw new TypeError("undefined or null object passed to parser");
    if (typeof b === "string")
        b = b.trim();
    for (const v in abMap) {
        if (!abMap.hasOwnProperty(v))
            continue;
        if (abMap[v] === b)
            return v;
    }
    return fallback !== undefined ? fallback : b;
}
;

Parser.attrChooseToFull = function(attList) {
    if (attList.length === 1)
        return `${Parser.attAbvToFull(attList[0])} modifier`;
    else {
        const attsTemp = [];
        for (let i = 0; i < attList.length; ++i) {
            attsTemp.push(Parser.attAbvToFull(attList[i]));
        }
        return `${attsTemp.join(" or ")} modifier (your choice)`;
    }
}
;

Parser.numberToText = function(number) {
    if (number == null)
        throw new TypeError(`undefined or null object passed to parser`);
    if (Math.abs(number) >= 100)
        return `${number}`;

    return `${number < 0 ? "negative " : ""}${Parser.numberToText._getPositiveNumberAsText(Math.abs(number))}`;
}
;

Parser.numberToText._getPositiveNumberAsText = num=>{
    const [preDotRaw,postDotRaw] = `${num}`.split(".");

    if (!postDotRaw)
        return Parser.numberToText._getPositiveIntegerAsText(num);

    let preDot = preDotRaw === "0" ? "" : `${Parser.numberToText._getPositiveIntegerAsText(Math.trunc(num))} and `;

    switch (postDotRaw) {
    case "125":
        return `${preDot}one-eighth`;
    case "2":
        return `${preDot}one-fifth`;
    case "25":
        return `${preDot}one-quarter`;
    case "375":
        return `${preDot}three-eighths`;
    case "4":
        return `${preDot}two-fifths`;
    case "5":
        return `${preDot}one-half`;
    case "6":
        return `${preDot}three-fifths`;
    case "625":
        return `${preDot}five-eighths`;
    case "75":
        return `${preDot}three-quarters`;
    case "8":
        return `${preDot}four-fifths`;
    case "875":
        return `${preDot}seven-eighths`;

    default:
        {
            const asNum = Number(`0.${postDotRaw}`);

            if (asNum.toFixed(2) === (1 / 3).toFixed(2))
                return `${preDot}one-third`;
            if (asNum.toFixed(2) === (2 / 3).toFixed(2))
                return `${preDot}two-thirds`;

            if (asNum.toFixed(2) === (1 / 6).toFixed(2))
                return `${preDot}one-sixth`;
            if (asNum.toFixed(2) === (5 / 6).toFixed(2))
                return `${preDot}five-sixths`;
        }
    }
}
;

Parser.numberToText._getPositiveIntegerAsText = num=>{
    switch (num) {
    case 0:
        return "zero";
    case 1:
        return "one";
    case 2:
        return "two";
    case 3:
        return "three";
    case 4:
        return "four";
    case 5:
        return "five";
    case 6:
        return "six";
    case 7:
        return "seven";
    case 8:
        return "eight";
    case 9:
        return "nine";
    case 10:
        return "ten";
    case 11:
        return "eleven";
    case 12:
        return "twelve";
    case 13:
        return "thirteen";
    case 14:
        return "fourteen";
    case 15:
        return "fifteen";
    case 16:
        return "sixteen";
    case 17:
        return "seventeen";
    case 18:
        return "eighteen";
    case 19:
        return "nineteen";
    case 20:
        return "twenty";
    case 30:
        return "thirty";
    case 40:
        return "forty";
    case 50:
        return "fifty";
    case 60:
        return "sixty";
    case 70:
        return "seventy";
    case 80:
        return "eighty";
    case 90:
        return "ninety";
    default:
        {
            const str = String(num);
            return `${Parser.numberToText._getPositiveIntegerAsText(Number(`${str[0]}0`))}-${Parser.numberToText._getPositiveIntegerAsText(Number(str[1]))}`;
        }
    }
}
;

Parser.textToNumber = function(str) {
    str = str.trim().toLowerCase();
    if (!isNaN(str))
        return Number(str);
    switch (str) {
    case "zero":
        return 0;
    case "one":
    case "a":
    case "an":
        return 1;
    case "two":
    case "double":
        return 2;
    case "three":
    case "triple":
        return 3;
    case "four":
    case "quadruple":
        return 4;
    case "five":
        return 5;
    case "six":
        return 6;
    case "seven":
        return 7;
    case "eight":
        return 8;
    case "nine":
        return 9;
    case "ten":
        return 10;
    case "eleven":
        return 11;
    case "twelve":
        return 12;
    case "thirteen":
        return 13;
    case "fourteen":
        return 14;
    case "fifteen":
        return 15;
    case "sixteen":
        return 16;
    case "seventeen":
        return 17;
    case "eighteen":
        return 18;
    case "nineteen":
        return 19;
    case "twenty":
        return 20;
    case "thirty":
        return 30;
    case "forty":
        return 40;
    case "fifty":
        return 50;
    case "sixty":
        return 60;
    case "seventy":
        return 70;
    case "eighty":
        return 80;
    case "ninety":
        return 90;
    }
    return NaN;
}
;

Parser.numberToVulgar = function(number, {isFallbackOnFractional=true}={}) {
    const isNeg = number < 0;
    const spl = `${number}`.replace(/^-/, "").split(".");
    if (spl.length === 1)
        return number;

    let preDot = spl[0] === "0" ? "" : spl[0];
    if (isNeg)
        preDot = `-${preDot}`;

    switch (spl[1]) {
    case "125":
        return `${preDot}⅛`;
    case "2":
        return `${preDot}⅕`;
    case "25":
        return `${preDot}¼`;
    case "375":
        return `${preDot}⅜`;
    case "4":
        return `${preDot}⅖`;
    case "5":
        return `${preDot}½`;
    case "6":
        return `${preDot}⅗`;
    case "625":
        return `${preDot}⅝`;
    case "75":
        return `${preDot}¾`;
    case "8":
        return `${preDot}⅘`;
    case "875":
        return `${preDot}⅞`;

    default:
        {
            const asNum = Number(`0.${spl[1]}`);

            if (asNum.toFixed(2) === (1 / 3).toFixed(2))
                return `${preDot}⅓`;
            if (asNum.toFixed(2) === (2 / 3).toFixed(2))
                return `${preDot}⅔`;

            if (asNum.toFixed(2) === (1 / 6).toFixed(2))
                return `${preDot}⅙`;
            if (asNum.toFixed(2) === (5 / 6).toFixed(2))
                return `${preDot}⅚`;
        }
    }

    return isFallbackOnFractional ? Parser.numberToFractional(number) : null;
}
;

Parser.vulgarToNumber = function(str) {
    const [,leading="0",vulgar=""] = /^(\d+)?([⅛¼⅜½⅝¾⅞⅓⅔⅙⅚])?$/.exec(str) || [];
    let out = Number(leading);
    switch (vulgar) {
    case "⅛":
        out += 0.125;
        break;
    case "¼":
        out += 0.25;
        break;
    case "⅜":
        out += 0.375;
        break;
    case "½":
        out += 0.5;
        break;
    case "⅝":
        out += 0.625;
        break;
    case "¾":
        out += 0.75;
        break;
    case "⅞":
        out += 0.875;
        break;
    case "⅓":
        out += 1 / 3;
        break;
    case "⅔":
        out += 2 / 3;
        break;
    case "⅙":
        out += 1 / 6;
        break;
    case "⅚":
        out += 5 / 6;
        break;
    case "":
        break;
    default:
        throw new Error(`Unhandled vulgar part "${vulgar}"`);
    }
    return out;
}
;

Parser.numberToSuperscript = function(number) {
    return `${number}`.split("").map(c=>isNaN(c) ? c : Parser._NUMBERS_SUPERSCRIPT[Number(c)]).join("");
}
;
Parser._NUMBERS_SUPERSCRIPT = "⁰¹²³⁴⁵⁶⁷⁸⁹";

Parser.numberToSubscript = function(number) {
    return `${number}`.split("").map(c=>isNaN(c) ? c : Parser._NUMBERS_SUBSCRIPT[Number(c)]).join("");
}
;
Parser._NUMBERS_SUBSCRIPT = "₀₁₂₃₄₅₆₇₈₉";

Parser._greatestCommonDivisor = function(a, b) {
    if (b < Number.EPSILON)
        return a;
    return Parser._greatestCommonDivisor(b, Math.floor(a % b));
}
;
Parser.numberToFractional = function(number) {
    const len = number.toString().length - 2;
    let denominator = 10 ** len;
    let numerator = number * denominator;
    const divisor = Parser._greatestCommonDivisor(numerator, denominator);
    numerator = Math.floor(numerator / divisor);
    denominator = Math.floor(denominator / divisor);

    return denominator === 1 ? String(numerator) : `${Math.floor(numerator)}/${Math.floor(denominator)}`;
}
;

Parser.ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

Parser.attAbvToFull = function(abv) {
    return Parser._parse_aToB(Parser.ATB_ABV_TO_FULL, abv);
}
;

Parser.attFullToAbv = function(full) {
    return Parser._parse_bToA(Parser.ATB_ABV_TO_FULL, full);
}
;

Parser.sizeAbvToFull = function(abv) {
    return Parser._parse_aToB(Parser.SIZE_ABV_TO_FULL, abv);
}
;

Parser.getAbilityModNumber = function(abilityScore) {
    return Math.floor((abilityScore - 10) / 2);
}
;

Parser.getAbilityModifier = function(abilityScore) {
    let modifier = Parser.getAbilityModNumber(abilityScore);
    if (modifier >= 0)
        modifier = `+${modifier}`;
    return `${modifier}`;
}
;

Parser.getSpeedString = (ent,{isMetric=false, isSkipZeroWalk=false}={})=>{
    if (ent.speed == null)
        return "\u2014";

    const unit = isMetric ? Parser.metric.getMetricUnit({
        originalUnit: "ft.",
        isShortForm: true
    }) : "ft.";
    if (typeof ent.speed === "object") {
        const stack = [];
        let joiner = ", ";

        Parser.SPEED_MODES.filter(mode=>!ent.speed.hidden?.includes(mode)).forEach(mode=>Parser._getSpeedString_addSpeedMode({
            ent,
            prop: mode,
            stack,
            isMetric,
            isSkipZeroWalk,
            unit
        }));

        if (ent.speed.choose && !ent.speed.hidden?.includes("choose")) {
            joiner = "; ";
            stack.push(`${ent.speed.choose.from.sort().joinConjunct(", ", " or ")} ${ent.speed.choose.amount} ${unit}${ent.speed.choose.note ? ` ${ent.speed.choose.note}` : ""}`);
        }

        return stack.join(joiner) + (ent.speed.note ? ` ${ent.speed.note}` : "");
    }

    return (isMetric ? Parser.metric.getMetricNumber({
        originalValue: ent.speed,
        originalUnit: Parser.UNT_FEET
    }) : ent.speed) + (ent.speed === "Varies" ? "" : ` ${unit} `);
}
;
Parser._getSpeedString_addSpeedMode = ({ent, prop, stack, isMetric, isSkipZeroWalk, unit})=>{
    if (ent.speed[prop] || (!isSkipZeroWalk && prop === "walk"))
        Parser._getSpeedString_addSpeed({
            prop,
            speed: ent.speed[prop] || 0,
            isMetric,
            unit,
            stack
        });
    if (ent.speed.alternate && ent.speed.alternate[prop])
        ent.speed.alternate[prop].forEach(speed=>Parser._getSpeedString_addSpeed({
            prop,
            speed,
            isMetric,
            unit,
            stack
        }));
}
;
Parser._getSpeedString_addSpeed = ({prop, speed, isMetric, unit, stack})=>{
    const ptName = prop === "walk" ? "" : `${prop} `;
    const ptValue = Parser._getSpeedString_getVal({
        prop,
        speed,
        isMetric
    });
    const ptUnit = speed === true ? "" : ` ${unit}`;
    const ptCondition = Parser._getSpeedString_getCondition({
        speed
    });
    stack.push([ptName, ptValue, ptUnit, ptCondition].join(""));
}
;
Parser._getSpeedString_getVal = ({prop, speed, isMetric})=>{
    if (speed === true && prop !== "walk")
        return "equal to your walking speed";

    const num = speed === true ? 0 : speed.number != null ? speed.number : speed;

    return isMetric ? Parser.metric.getMetricNumber({
        originalValue: num,
        originalUnit: Parser.UNT_FEET
    }) : num;
}
;
Parser._getSpeedString_getCondition = ({speed})=>speed.condition ? ` ${Renderer.get().render(speed.condition)}` : "";

Parser.SPEED_MODES = ["walk", "burrow", "climb", "fly", "swim"];

Parser.SPEED_TO_PROGRESSIVE = {
    "walk": "walking",
    "burrow": "burrowing",
    "climb": "climbing",
    "fly": "flying",
    "swim": "swimming",
};

Parser.speedToProgressive = function(prop) {
    return Parser._parse_aToB(Parser.SPEED_TO_PROGRESSIVE, prop);
}
;

Parser._addCommas = function(intNum) {
    return `${intNum}`.replace(/(\d)(?=(\d{3})+$)/g, "$1,");
}
;

Parser.raceCreatureTypesToFull = function(creatureTypes) {
    const hasSubOptions = creatureTypes.some(it=>it.choose);
    return creatureTypes.map(it=>{
        if (!it.choose)
            return Parser.monTypeToFullObj(it).asText;
        return [...it.choose].sort(SortUtil.ascSortLower).map(sub=>Parser.monTypeToFullObj(sub).asText).joinConjunct(", ", " or ");
    }
    ).joinConjunct(hasSubOptions ? "; " : ", ", " and ");
}
;

Parser.crToXp = function(cr, {isDouble=false}={}) {
    if (cr != null && cr.xp)
        return Parser._addCommas(`${isDouble ? cr.xp * 2 : cr.xp}`);

    const toConvert = cr ? (cr.cr || cr) : null;
    if (toConvert === "Unknown" || toConvert == null || !Parser.XP_CHART_ALT[toConvert])
        return "Unknown";
    if (toConvert === "0")
        return "10";
    const xp = Parser.XP_CHART_ALT[toConvert];
    return Parser._addCommas(`${isDouble ? 2 * xp : xp}`);
}
;

Parser.crToXpNumber = function(cr) {
    if (cr != null && cr.xp)
        return cr.xp;
    const toConvert = cr ? (cr.cr || cr) : cr;
    if (toConvert === "Unknown" || toConvert == null)
        return null;
    return Parser.XP_CHART_ALT[toConvert] ?? null;
}
;

Parser.LEVEL_TO_XP_EASY = [0, 25, 50, 75, 125, 250, 300, 350, 450, 550, 600, 800, 1000, 1100, 1250, 1400, 1600, 2000, 2100, 2400, 2800];
Parser.LEVEL_TO_XP_MEDIUM = [0, 50, 100, 150, 250, 500, 600, 750, 900, 1100, 1200, 1600, 2000, 2200, 2500, 2800, 3200, 3900, 4100, 4900, 5700];
Parser.LEVEL_TO_XP_HARD = [0, 75, 150, 225, 375, 750, 900, 1100, 1400, 1600, 1900, 2400, 3000, 3400, 3800, 4300, 4800, 5900, 6300, 7300, 8500];
Parser.LEVEL_TO_XP_DEADLY = [0, 100, 200, 400, 500, 1100, 1400, 1700, 2100, 2400, 2800, 3600, 4500, 5100, 5700, 6400, 7200, 8800, 9500, 10900, 12700];
Parser.LEVEL_TO_XP_DAILY = [0, 300, 600, 1200, 1700, 3500, 4000, 5000, 6000, 7500, 9000, 10500, 11500, 13500, 15000, 18000, 20000, 25000, 27000, 30000, 40000];

Parser.LEVEL_XP_REQUIRED = [0, 300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000];

Parser.CRS = ["0", "1/8", "1/4", "1/2", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30"];

Parser.levelToXpThreshold = function(level) {
    return [Parser.LEVEL_TO_XP_EASY[level], Parser.LEVEL_TO_XP_MEDIUM[level], Parser.LEVEL_TO_XP_HARD[level], Parser.LEVEL_TO_XP_DEADLY[level]];
}
;

Parser.isValidCr = function(cr) {
    return Parser.CRS.includes(cr);
}
;

Parser.crToNumber = function(cr, opts={}) {
    const {isDefaultNull=false} = opts;

    if (cr === "Unknown" || cr === "\u2014" || cr == null)
        return isDefaultNull ? null : VeCt.CR_UNKNOWN;
    if (cr.cr)
        return Parser.crToNumber(cr.cr, opts);

    const parts = cr.trim().split("/");
    if (!parts.length || parts.length >= 3)
        return isDefaultNull ? null : VeCt.CR_CUSTOM;
    if (isNaN(parts[0]))
        return isDefaultNull ? null : VeCt.CR_CUSTOM;

    if (parts.length === 2) {
        if (isNaN(Number(parts[1])))
            return isDefaultNull ? null : VeCt.CR_CUSTOM;
        return Number(parts[0]) / Number(parts[1]);
    }

    return Number(parts[0]);
}
;

Parser.numberToCr = function(number, safe) {
    if (safe && typeof number === "string" && Parser.CRS.includes(number))
        return number;

    if (number == null)
        return "Unknown";

    return Parser.numberToFractional(number);
}
;

Parser.crToPb = function(cr) {
    if (cr === "Unknown" || cr == null)
        return 0;
    cr = cr.cr || cr;
    if (Parser.crToNumber(cr) < 5)
        return 2;
    return Math.ceil(cr / 4) + 1;
}
;

Parser.levelToPb = function(level) {
    if (!level)
        return 2;
    return Math.ceil(level / 4) + 1;
}
;
Parser.SKILL_TO_ATB_ABV = {
    "athletics": "str",
    "acrobatics": "dex",
    "sleight of hand": "dex",
    "stealth": "dex",
    "arcana": "int",
    "history": "int",
    "investigation": "int",
    "nature": "int",
    "religion": "int",
    "animal handling": "wis",
    "insight": "wis",
    "medicine": "wis",
    "perception": "wis",
    "survival": "wis",
    "deception": "cha",
    "intimidation": "cha",
    "performance": "cha",
    "persuasion": "cha",
};


Parser.skillToAbilityAbv = function(skill) {
    return Parser._parse_aToB(Parser.SKILL_TO_ATB_ABV, skill);
}
;

Parser.SKILL_TO_SHORT = {
    "athletics": "ath",
    "acrobatics": "acro",
    "sleight of hand": "soh",
    "stealth": "slth",
    "arcana": "arc",
    "history": "hist",
    "investigation": "invn",
    "nature": "natr",
    "religion": "reli",
    "animal handling": "hndl",
    "insight": "ins",
    "medicine": "med",
    "perception": "perp",
    "survival": "surv",
    "deception": "decp",
    "intimidation": "intm",
    "performance": "perf",
    "persuasion": "pers",
};

Parser.skillToShort = function(skill) {
    return Parser._parse_aToB(Parser.SKILL_TO_SHORT, skill);
}
;

Parser.LANGUAGES_STANDARD = ["Common", "Dwarvish", "Elvish", "Giant", "Gnomish", "Goblin", "Halfling", "Orc", ];

Parser.LANGUAGES_EXOTIC = ["Abyssal", "Aquan", "Auran", "Celestial", "Draconic", "Deep Speech", "Ignan", "Infernal", "Primordial", "Sylvan", "Terran", "Undercommon", ];

Parser.LANGUAGES_SECRET = ["Druidic", "Thieves' cant", ];

Parser.LANGUAGES_ALL = [...Parser.LANGUAGES_STANDARD, ...Parser.LANGUAGES_EXOTIC, ...Parser.LANGUAGES_SECRET, ].sort();

Parser.acToFull = function(ac, renderer) {
    if (typeof ac === "string")
        return ac;
    renderer = renderer || Renderer.get();

    let stack = "";
    let inBraces = false;
    for (let i = 0; i < ac.length; ++i) {
        const cur = ac[i];
        const nxt = ac[i + 1];

        if (cur.special != null) {
            if (inBraces)
                inBraces = false;

            stack += cur.special;
        } else if (cur.ac) {
            const isNxtBraces = nxt && nxt.braces;

            if (!inBraces && cur.braces) {
                stack += "(";
                inBraces = true;
            }

            stack += cur.ac;

            if (cur.from) {
                if (cur.braces) {
                    stack += " (";
                } else {
                    stack += inBraces ? "; " : " (";
                }

                inBraces = true;

                stack += cur.from.map(it=>renderer.render(it)).join(", ");

                if (cur.braces) {
                    stack += ")";
                } else if (!isNxtBraces) {
                    stack += ")";
                    inBraces = false;
                }
            }

            if (cur.condition)
                stack += ` ${renderer.render(cur.condition)}`;

            if (inBraces && !isNxtBraces) {
                stack += ")";
                inBraces = false;
            }
        } else {
            stack += cur;
        }

        if (nxt) {
            if (nxt.braces) {
                stack += inBraces ? "; " : " (";
                inBraces = true;
            } else
                stack += ", ";
        }
    }
    if (inBraces)
        stack += ")";

    return stack.trim();
}
;

Parser.MONSTER_COUNT_TO_XP_MULTIPLIER = [1, 1.5, 2, 2, 2, 2, 2.5, 2.5, 2.5, 2.5, 3, 3, 3, 3, 4];
Parser.numMonstersToXpMult = function(num, playerCount=3) {
    const baseVal = (()=>{
        if (num >= Parser.MONSTER_COUNT_TO_XP_MULTIPLIER.length)
            return 4;
        return Parser.MONSTER_COUNT_TO_XP_MULTIPLIER[num - 1];
    }
    )();

    if (playerCount < 3)
        return baseVal >= 3 ? baseVal + 1 : baseVal + 0.5;
    else if (playerCount > 5) {
        return baseVal === 4 ? 3 : baseVal - 0.5;
    } else
        return baseVal;
}
;

Parser.armorFullToAbv = function(armor) {
    return Parser._parse_bToA(Parser.ARMOR_ABV_TO_FULL, armor);
}
;

Parser.weaponFullToAbv = function(weapon) {
    return Parser._parse_bToA(Parser.WEAPON_ABV_TO_FULL, weapon);
}
;

Parser._getSourceStringFromSource = function(source) {
    if (source && source.source)
        return source.source;
    return source;
}
;
Parser._buildSourceCache = function(dict) {
    const out = {};
    Object.entries(dict).forEach(([k,v])=>out[k.toLowerCase()] = v);
    return out;
}
;
Parser._sourceJsonCache = null;
Parser.hasSourceJson = function(source) {
    Parser._sourceJsonCache = Parser._sourceJsonCache || Parser._buildSourceCache(Object.keys(Parser.SOURCE_JSON_TO_FULL).mergeMap(k=>({
        [k]: k
    })));
    return !!Parser._sourceJsonCache[source.toLowerCase()];
}
;
Parser._sourceFullCache = null;
Parser.hasSourceFull = function(source) {
    Parser._sourceFullCache = Parser._sourceFullCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_FULL);
    return !!Parser._sourceFullCache[source.toLowerCase()];
}
;
Parser._sourceAbvCache = null;
Parser.hasSourceAbv = function(source) {
    Parser._sourceAbvCache = Parser._sourceAbvCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_ABV);
    return !!Parser._sourceAbvCache[source.toLowerCase()];
}
;
Parser._sourceDateCache = null;
Parser.hasSourceDate = function(source) {
    Parser._sourceDateCache = Parser._sourceDateCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_DATE);
    return !!Parser._sourceDateCache[source.toLowerCase()];
}
;
Parser.sourceJsonToJson = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceJson(source))
        return Parser._sourceJsonCache[source.toLowerCase()];
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToSource(source).json;
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToSource(source).json;
    return source;
}
;
Parser.sourceJsonToFull = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceFull(source))
        return Parser._sourceFullCache[source.toLowerCase()].replace(/'/g, "\u2019");
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToFull(source).replace(/'/g, "\u2019");
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToFull(source).replace(/'/g, "\u2019");
    return Parser._parse_aToB(Parser.SOURCE_JSON_TO_FULL, source).replace(/'/g, "\u2019");
}
;
Parser.sourceJsonToFullCompactPrefix = function(source) {
    return Parser.sourceJsonToFull(source).replace(Parser.UA_PREFIX, Parser.UA_PREFIX_SHORT).replace(/^Unearthed Arcana (\d+): /, "UA$1: ").replace(Parser.AL_PREFIX, Parser.AL_PREFIX_SHORT).replace(Parser.PS_PREFIX, Parser.PS_PREFIX_SHORT);
}
;
Parser.sourceJsonToAbv = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceAbv(source))
        return Parser._sourceAbvCache[source.toLowerCase()];
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToAbv(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToAbv(source);
    return Parser._parse_aToB(Parser.SOURCE_JSON_TO_ABV, source);
}
;
Parser.sourceJsonToDate = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceDate(source))
        return Parser._sourceDateCache[source.toLowerCase()];
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToDate(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToDate(source);
    return Parser._parse_aToB(Parser.SOURCE_JSON_TO_DATE, source, null);
}
;

Parser.sourceJsonToColor = function(source) {
    return `source${Parser.sourceJsonToAbv(source)}`;
}
;

Parser.sourceJsonToStyle = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceJson(source))
        return "";
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToStyle(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToStyle(source);
    return "";
}
;

Parser.sourceJsonToStylePart = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceJson(source))
        return "";
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToStylePart(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToStylePart(source);
    return "";
}
;

Parser.stringToSlug = function(str) {
    return str.trim().toLowerCase().toAscii().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
}
;

Parser.stringToCasedSlug = function(str) {
    return str.toAscii().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
}
;

Parser.ITEM_SPELLCASTING_FOCUS_CLASSES = ["Artificer", "Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"];

Parser.itemValueToFull = function(item, opts={
    isShortForm: false,
    isSmallUnits: false
}) {
    return Parser._moneyToFull(item, "value", "valueMult", opts);
}
;

Parser.itemValueToFullMultiCurrency = function(item, opts={
    isShortForm: false,
    isSmallUnits: false
}) {
    return Parser._moneyToFullMultiCurrency(item, "value", "valueMult", opts);
}
;

Parser.itemVehicleCostsToFull = function(item, isShortForm) {
    return {
        travelCostFull: Parser._moneyToFull(item, "travelCost", "travelCostMult", {
            isShortForm
        }),
        shippingCostFull: Parser._moneyToFull(item, "shippingCost", "shippingCostMult", {
            isShortForm
        }),
    };
}
;

Parser.spellComponentCostToFull = function(item, isShortForm) {
    return Parser._moneyToFull(item, "cost", "costMult", {
        isShortForm
    });
}
;

Parser.vehicleCostToFull = function(item, isShortForm) {
    return Parser._moneyToFull(item, "cost", "costMult", {
        isShortForm
    });
}
;

Parser._moneyToFull = function(it, prop, propMult, opts={
    isShortForm: false,
    isSmallUnits: false
}) {
    if (it[prop] == null && it[propMult] == null)
        return "";
    if (it[prop] != null) {
        const {coin, mult} = Parser.getCurrencyAndMultiplier(it[prop], it.currencyConversion);
        return `${(it[prop] * mult).toLocaleString(undefined, {
            maximumFractionDigits: 5
        })}${opts.isSmallUnits ? `<span class="small ml-1">${coin}</span>` : ` ${coin}`}`;
    } else if (it[propMult] != null)
        return opts.isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;
    return "";
}
;

Parser._moneyToFullMultiCurrency = function(it, prop, propMult, {isShortForm, multiplier}={}) {
    if (it[prop]) {
        const conversionTable = Parser.getCurrencyConversionTable(it.currencyConversion);

        const simplified = it.currencyConversion ? CurrencyUtil.doSimplifyCoins({
            [conversionTable[0]?.coin || "cp"]: it[prop] * (multiplier ?? conversionTable[0]?.mult ?? 1),
        }, {
            currencyConversionId: it.currencyConversion,
        }, ) : CurrencyUtil.doSimplifyCoins({
            cp: it[prop] * (multiplier ?? 1),
        });

        return [...conversionTable].reverse().filter(meta=>simplified[meta.coin]).map(meta=>`${simplified[meta.coin].toLocaleString(undefined, {
            maximumFractionDigits: 5
        })} ${meta.coin}`).join(", ");
    }

    if (it[propMult])
        return isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;

    return "";
}
;

Parser.DEFAULT_CURRENCY_CONVERSION_TABLE = [{
    coin: "cp",
    mult: 1,
}, {
    coin: "sp",
    mult: 0.1,
}, {
    coin: "gp",
    mult: 0.01,
    isFallback: true,
}, ];
Parser.FULL_CURRENCY_CONVERSION_TABLE = [{
    coin: "cp",
    mult: 1,
}, {
    coin: "sp",
    mult: 0.1,
}, {
    coin: "ep",
    mult: 0.02,
}, {
    coin: "gp",
    mult: 0.01,
    isFallback: true,
}, {
    coin: "pp",
    mult: 0.001,
}, ];
Parser.getCurrencyConversionTable = function(currencyConversionId) {
    const fromPrerelease = currencyConversionId ? PrereleaseUtil.getMetaLookup("currencyConversions")?.[currencyConversionId] : null;
    const fromBrew = currencyConversionId ? BrewUtil2.getMetaLookup("currencyConversions")?.[currencyConversionId] : null;
    const conversionTable = fromPrerelease?.length ? fromPrerelease : fromBrew?.length ? fromBrew : Parser.DEFAULT_CURRENCY_CONVERSION_TABLE;
    if (conversionTable !== Parser.DEFAULT_CURRENCY_CONVERSION_TABLE)
        conversionTable.sort((a,b)=>SortUtil.ascSort(b.mult, a.mult));
    return conversionTable;
}
;
Parser.getCurrencyAndMultiplier = function(value, currencyConversionId) {
    const conversionTable = Parser.getCurrencyConversionTable(currencyConversionId);

    if (!value)
        return conversionTable.find(it=>it.isFallback) || conversionTable[0];
    if (conversionTable.length === 1)
        return conversionTable[0];
    if (!Number.isInteger(value) && value < conversionTable[0].mult)
        return conversionTable[0];

    for (let i = conversionTable.length - 1; i >= 0; --i) {
        if (Number.isInteger(value * conversionTable[i].mult))
            return conversionTable[i];
    }

    return conversionTable.last();
}
;

Parser.COIN_ABVS = ["cp", "sp", "ep", "gp", "pp"];
Parser.COIN_ABV_TO_FULL = {
    "cp": "copper pieces",
    "sp": "silver pieces",
    "ep": "electrum pieces",
    "gp": "gold pieces",
    "pp": "platinum pieces",
};
Parser.COIN_CONVERSIONS = [1, 10, 50, 100, 1000];

Parser.coinAbvToFull = function(coin) {
    return Parser._parse_aToB(Parser.COIN_ABV_TO_FULL, coin);
}
;

Parser.getDisplayCurrency = function(currency, {isDisplayEmpty=false}={}) {
    return [...Parser.COIN_ABVS].reverse().filter(abv=>isDisplayEmpty ? currency[abv] != null : currency[abv]).map(abv=>`${currency[abv].toLocaleString()} ${abv}`).join(", ");
}
;

Parser.itemWeightToFull = function(item, isShortForm) {
    if (item.weight) {
        if (Math.round(item.weight) === item.weight)
            return `${item.weight} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

        const integerPart = Math.floor(item.weight);

        const vulgarGlyph = Parser.numberToVulgar(item.weight - integerPart, {
            isFallbackOnFractional: false
        });
        if (vulgarGlyph)
            return `${integerPart || ""}${vulgarGlyph} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

        return `${(item.weight < 1 ? item.weight * 16 : item.weight).toLocaleString(undefined, {
            maximumFractionDigits: 5
        })} ${item.weight < 1 ? "oz" : "lb"}.${(item.weightNote ? ` ${item.weightNote}` : "")}`;
    }
    if (item.weightMult)
        return isShortForm ? `×${item.weightMult}` : `base weight ×${item.weightMult}`;
    return "";
}
;

Parser.ITEM_RECHARGE_TO_FULL = {
    round: "Every Round",
    restShort: "Short Rest",
    restLong: "Long Rest",
    dawn: "Dawn",
    dusk: "Dusk",
    midnight: "Midnight",
    week: "Week",
    month: "Month",
    year: "Year",
    decade: "Decade",
    century: "Century",
    special: "Special",
};
Parser.itemRechargeToFull = function(recharge) {
    return Parser._parse_aToB(Parser.ITEM_RECHARGE_TO_FULL, recharge);
}
;

Parser.ITEM_MISC_TAG_TO_FULL = {
    "CF/W": "Creates Food/Water",
    "TT": "Trinket Table",
};
Parser.itemMiscTagToFull = function(type) {
    return Parser._parse_aToB(Parser.ITEM_MISC_TAG_TO_FULL, type);
}
;

Parser._decimalSeparator = (0.1).toLocaleString().substring(1, 2);
Parser._numberCleanRegexp = Parser._decimalSeparator === "." ? new RegExp(/[\s,]*/g,"g") : new RegExp(/[\s.]*/g,"g");
Parser._costSplitRegexp = Parser._decimalSeparator === "." ? new RegExp(/(\d+(\.\d+)?)([csegp]p)/) : new RegExp(/(\d+(,\d+)?)([csegp]p)/);

Parser.coinValueToNumber = function(value) {
    if (!value)
        return 0;
    if (value === "Varies")
        return 0;

    value = value.replace(/\s*/, "").replace(Parser._numberCleanRegexp, "").toLowerCase();
    const m = Parser._costSplitRegexp.exec(value);
    if (!m)
        throw new Error(`Badly formatted value "${value}"`);
    const ixCoin = Parser.COIN_ABVS.indexOf(m[3]);
    if (!~ixCoin)
        throw new Error(`Unknown coin type "${m[3]}"`);
    return Number(m[1]) * Parser.COIN_CONVERSIONS[ixCoin];
}
;

Parser.weightValueToNumber = function(value) {
    if (!value)
        return 0;

    if (Number(value))
        return Number(value);
    else
        throw new Error(`Badly formatted value ${value}`);
}
;

Parser.dmgTypeToFull = function(dmgType) {
    return Parser._parse_aToB(Parser.DMGTYPE_JSON_TO_FULL, dmgType);
}
;

Parser.skillProficienciesToFull = function(skillProficiencies) {
    function renderSingle(skProf) {
        if (skProf.any) {
            skProf = MiscUtil.copyFast(skProf);
            skProf.choose = {
                "from": Object.keys(Parser.SKILL_TO_ATB_ABV),
                "count": skProf.any
            };
            delete skProf.any;
        }

        const keys = Object.keys(skProf).sort(SortUtil.ascSortLower);

        const ixChoose = keys.indexOf("choose");
        if (~ixChoose)
            keys.splice(ixChoose, 1);

        const baseStack = [];
        keys.filter(k=>skProf[k]).forEach(k=>baseStack.push(Renderer.get().render(`{@skill ${k.toTitleCase()}}`)));

        const chooseStack = [];
        if (~ixChoose) {
            const chObj = skProf.choose;
            if (chObj.from.length === 18) {
                chooseStack.push(`choose any ${!chObj.count || chObj.count === 1 ? "skill" : chObj.count}`);
            } else {
                chooseStack.push(`choose ${chObj.count || 1} from ${chObj.from.map(it=>Renderer.get().render(`{@skill ${it.toTitleCase()}}`)).joinConjunct(", ", " and ")}`);
            }
        }

        const base = baseStack.joinConjunct(", ", " and ");
        const choose = chooseStack.join("");
        if (baseStack.length && chooseStack.length)
            return `${base}; and ${choose}`;
        else if (baseStack.length)
            return base;
        else if (chooseStack.length)
            return choose;
    }

    return skillProficiencies.map(renderSingle).join(" <i>or</i> ");
}
;

Parser.spSchoolAndSubschoolsAbvsToFull = function(school, subschools) {
    if (!subschools || !subschools.length)
        return Parser.spSchoolAbvToFull(school);
    else
        return `${Parser.spSchoolAbvToFull(school)} (${subschools.map(sub=>Parser.spSchoolAbvToFull(sub)).join(", ")})`;
}
;

Parser.spSchoolAbvToFull = function(schoolOrSubschool) {
    const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_FULL, schoolOrSubschool);
    if (Parser.SP_SCHOOL_ABV_TO_FULL[schoolOrSubschool])
        return out;
    if (PrereleaseUtil.getMetaLookup("spellSchools")?.[schoolOrSubschool])
        return PrereleaseUtil.getMetaLookup("spellSchools")?.[schoolOrSubschool].full;
    if (BrewUtil2.getMetaLookup("spellSchools")?.[schoolOrSubschool])
        return BrewUtil2.getMetaLookup("spellSchools")?.[schoolOrSubschool].full;
    return out;
}
;

Parser.spSchoolAndSubschoolsAbvsShort = function(school, subschools) {
    if (!subschools || !subschools.length)
        return Parser.spSchoolAbvToShort(school);
    else
        return `${Parser.spSchoolAbvToShort(school)} (${subschools.map(sub=>Parser.spSchoolAbvToShort(sub)).join(", ")})`;
}
;

Parser.spSchoolAbvToShort = function(school) {
    const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_SHORT, school);
    if (Parser.SP_SCHOOL_ABV_TO_SHORT[school])
        return out;
    if (PrereleaseUtil.getMetaLookup("spellSchools")?.[school])
        return PrereleaseUtil.getMetaLookup("spellSchools")?.[school].short;
    if (BrewUtil2.getMetaLookup("spellSchools")?.[school])
        return BrewUtil2.getMetaLookup("spellSchools")?.[school].short;
    if (out.length <= 4)
        return out;
    return `${out.slice(0, 3)}.`;
}
;

Parser.spSchoolAbvToStyle = function(school) {
    const stylePart = Parser.spSchoolAbvToStylePart(school);
    if (!stylePart)
        return stylePart;
    return `style="${stylePart}"`;
}
;

Parser.spSchoolAbvToStylePart = function(school) {
    return Parser._spSchoolAbvToStylePart_prereleaseBrew({
        school,
        brewUtil: PrereleaseUtil
    }) || Parser._spSchoolAbvToStylePart_prereleaseBrew({
        school,
        brewUtil: BrewUtil2
    }) || "";
}
;

Parser._spSchoolAbvToStylePart_prereleaseBrew = function({school, brewUtil}) {
    const rawColor = brewUtil.getMetaLookup("spellSchools")?.[school]?.color;
    if (!rawColor || !rawColor.trim())
        return "";
    const validColor = BrewUtilShared.getValidColor(rawColor);
    if (validColor.length)
        return `color: #${validColor};`;
}
;

Parser.getOrdinalForm = function(i) {
    i = Number(i);
    if (isNaN(i))
        return "";
    const j = i % 10;
    const k = i % 100;
    if (j === 1 && k !== 11)
        return `${i}st`;
    if (j === 2 && k !== 12)
        return `${i}nd`;
    if (j === 3 && k !== 13)
        return `${i}rd`;
    return `${i}th`;
}
;

Parser.spLevelToFull = function(level) {
    if (level === 0)
        return "Cantrip";
    else
        return Parser.getOrdinalForm(level);
}
;

Parser.getArticle = function(str) {
    str = `${str}`;
    str = str.replace(/\d+/g, (...m)=>Parser.numberToText(m[0]));
    return /^[aeiou]/i.test(str) ? "an" : "a";
}
;

Parser.spLevelToFullLevelText = function(level, {isDash=false, isPluralCantrips=true}={}) {
    return `${Parser.spLevelToFull(level)}${(level === 0 ? (isPluralCantrips ? "s" : "") : `${isDash ? "-" : " "}level`)}`;
}
;

Parser.spLevelToSpellPoints = function(lvl) {
    lvl = Number(lvl);
    if (isNaN(lvl) || lvl === 0)
        return 0;
    return Math.ceil(1.34 * lvl);
}
;

Parser.spMetaToArr = function(meta) {
    if (!meta)
        return [];
    return Object.entries(meta).filter(([_,v])=>v).sort(SortUtil.ascSort).map(([k])=>k);
}
;

Parser.spMetaToFull = function(meta) {
    if (!meta)
        return "";
    const metaTags = Parser.spMetaToArr(meta);
    if (metaTags.length)
        return ` (${metaTags.join(", ")})`;
    return "";
}
;

Parser.spLevelSchoolMetaToFull = function(level, school, meta, subschools) {
    const levelPart = level === 0 ? Parser.spLevelToFull(level).toLowerCase() : `${Parser.spLevelToFull(level)}-level`;
    const levelSchoolStr = level === 0 ? `${Parser.spSchoolAbvToFull(school)} ${levelPart}` : `${levelPart} ${Parser.spSchoolAbvToFull(school).toLowerCase()}`;

    const metaArr = Parser.spMetaToArr(meta);
    if (metaArr.length || (subschools && subschools.length)) {
        const metaAndSubschoolPart = [(subschools || []).map(sub=>Parser.spSchoolAbvToFull(sub)).join(", "), metaArr.join(", "), ].filter(Boolean).join("; ").toLowerCase();
        return `${levelSchoolStr} (${metaAndSubschoolPart})`;
    }
    return levelSchoolStr;
}
;

Parser.spTimeListToFull = function(times, isStripTags) {
    return times.map(t=>`${Parser.getTimeToFull(t)}${t.condition ? `, ${isStripTags ? Renderer.stripTags(t.condition) : Renderer.get().render(t.condition)}` : ""}`).join(" or ");
}
;

Parser.getTimeToFull = function(time) {
    return `${time.number ? `${time.number} ` : ""}${time.unit === "bonus" ? "bonus action" : time.unit}${time.number > 1 ? "s" : ""}`;
}
;

Parser.getMinutesToFull = function(mins) {
    const days = Math.floor(mins / (24 * 60));
    mins = mins % (24 * 60);

    const hours = Math.floor(mins / 60);
    mins = mins % 60;

    return [days ? `${days} day${days > 1 ? "s" : ""}` : null, hours ? `${hours} hour${hours > 1 ? "s" : ""}` : null, mins ? `${mins} minute${mins > 1 ? "s" : ""}` : null, ].filter(Boolean).join(" ");
}
;

Parser.RNG_SPECIAL = "special";
Parser.RNG_POINT = "point";
Parser.RNG_LINE = "line";
Parser.RNG_CUBE = "cube";
Parser.RNG_CONE = "cone";
Parser.RNG_RADIUS = "radius";
Parser.RNG_SPHERE = "sphere";
Parser.RNG_HEMISPHERE = "hemisphere";
Parser.RNG_CYLINDER = "cylinder";
Parser.RNG_SELF = "self";
Parser.RNG_SIGHT = "sight";
Parser.RNG_UNLIMITED = "unlimited";
Parser.RNG_UNLIMITED_SAME_PLANE = "plane";
Parser.RNG_TOUCH = "touch";
Parser.SP_RANGE_TYPE_TO_FULL = {
    [Parser.RNG_SPECIAL]: "Special",
    [Parser.RNG_POINT]: "Point",
    [Parser.RNG_LINE]: "Line",
    [Parser.RNG_CUBE]: "Cube",
    [Parser.RNG_CONE]: "Cone",
    [Parser.RNG_RADIUS]: "Radius",
    [Parser.RNG_SPHERE]: "Sphere",
    [Parser.RNG_HEMISPHERE]: "Hemisphere",
    [Parser.RNG_CYLINDER]: "Cylinder",
    [Parser.RNG_SELF]: "Self",
    [Parser.RNG_SIGHT]: "Sight",
    [Parser.RNG_UNLIMITED]: "Unlimited",
    [Parser.RNG_UNLIMITED_SAME_PLANE]: "Unlimited on the same plane",
    [Parser.RNG_TOUCH]: "Touch",
};

Parser.spRangeTypeToFull = function(range) {
    return Parser._parse_aToB(Parser.SP_RANGE_TYPE_TO_FULL, range);
}
;

Parser.UNT_FEET = "feet";
Parser.UNT_YARDS = "yards";
Parser.UNT_MILES = "miles";
Parser.SP_DIST_TYPE_TO_FULL = {
    [Parser.UNT_FEET]: "Feet",
    [Parser.UNT_YARDS]: "Yards",
    [Parser.UNT_MILES]: "Miles",
    [Parser.RNG_SELF]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_SELF],
    [Parser.RNG_TOUCH]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_TOUCH],
    [Parser.RNG_SIGHT]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_SIGHT],
    [Parser.RNG_UNLIMITED]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_UNLIMITED],
    [Parser.RNG_UNLIMITED_SAME_PLANE]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_UNLIMITED_SAME_PLANE],
};

Parser.spDistanceTypeToFull = function(range) {
    return Parser._parse_aToB(Parser.SP_DIST_TYPE_TO_FULL, range);
}
;

Parser.SP_RANGE_TO_ICON = {
    [Parser.RNG_SPECIAL]: "fa-star",
    [Parser.RNG_POINT]: "",
    [Parser.RNG_LINE]: "fa-grip-lines-vertical",
    [Parser.RNG_CUBE]: "fa-cube",
    [Parser.RNG_CONE]: "fa-traffic-cone",
    [Parser.RNG_RADIUS]: "fa-hockey-puck",
    [Parser.RNG_SPHERE]: "fa-globe",
    [Parser.RNG_HEMISPHERE]: "fa-globe",
    [Parser.RNG_CYLINDER]: "fa-database",
    [Parser.RNG_SELF]: "fa-street-view",
    [Parser.RNG_SIGHT]: "fa-eye",
    [Parser.RNG_UNLIMITED_SAME_PLANE]: "fa-globe-americas",
    [Parser.RNG_UNLIMITED]: "fa-infinity",
    [Parser.RNG_TOUCH]: "fa-hand-paper",
};

Parser.spRangeTypeToIcon = function(range) {
    return Parser._parse_aToB(Parser.SP_RANGE_TO_ICON, range);
}
;

Parser.spRangeToShortHtml = function(range) {
    switch (range.type) {
    case Parser.RNG_SPECIAL:
        return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="Special"></span>`;
    case Parser.RNG_POINT:
        return Parser.spRangeToShortHtml._renderPoint(range);
    case Parser.RNG_LINE:
    case Parser.RNG_CUBE:
    case Parser.RNG_CONE:
    case Parser.RNG_RADIUS:
    case Parser.RNG_SPHERE:
    case Parser.RNG_HEMISPHERE:
    case Parser.RNG_CYLINDER:
        return Parser.spRangeToShortHtml._renderArea(range);
    }
}
;
Parser.spRangeToShortHtml._renderPoint = function(range) {
    const dist = range.distance;
    switch (dist.type) {
    case Parser.RNG_SELF:
    case Parser.RNG_SIGHT:
    case Parser.RNG_UNLIMITED:
    case Parser.RNG_UNLIMITED_SAME_PLANE:
    case Parser.RNG_SPECIAL:
    case Parser.RNG_TOUCH:
        return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(dist.type)} help-subtle" title="${Parser.spRangeTypeToFull(dist.type)}"></span>`;
    case Parser.UNT_FEET:
    case Parser.UNT_YARDS:
    case Parser.UNT_MILES:
    default:
        return `${dist.amount} <span class="ve-small">${Parser.getSingletonUnit(dist.type, true)}</span>`;
    }
}
;
Parser.spRangeToShortHtml._renderArea = function(range) {
    const size = range.distance;
    return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(Parser.RNG_SELF)} help-subtle" title="Self"></span> ${size.amount}<span class="ve-small">-${Parser.getSingletonUnit(size.type, true)}</span> ${Parser.spRangeToShortHtml._getAreaStyleString(range)}`;
}
;
Parser.spRangeToShortHtml._getAreaStyleString = function(range) {
    return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="${Parser.spRangeTypeToFull(range.type)}"></span>`;
}
;

Parser.spRangeToFull = function(range) {
    switch (range.type) {
    case Parser.RNG_SPECIAL:
        return Parser.spRangeTypeToFull(range.type);
    case Parser.RNG_POINT:
        return Parser.spRangeToFull._renderPoint(range);
    case Parser.RNG_LINE:
    case Parser.RNG_CUBE:
    case Parser.RNG_CONE:
    case Parser.RNG_RADIUS:
    case Parser.RNG_SPHERE:
    case Parser.RNG_HEMISPHERE:
    case Parser.RNG_CYLINDER:
        return Parser.spRangeToFull._renderArea(range);
    }
}
;
Parser.spRangeToFull._renderPoint = function(range) {
    const dist = range.distance;
    switch (dist.type) {
    case Parser.RNG_SELF:
    case Parser.RNG_SIGHT:
    case Parser.RNG_UNLIMITED:
    case Parser.RNG_UNLIMITED_SAME_PLANE:
    case Parser.RNG_SPECIAL:
    case Parser.RNG_TOUCH:
        return Parser.spRangeTypeToFull(dist.type);
    case Parser.UNT_FEET:
    case Parser.UNT_YARDS:
    case Parser.UNT_MILES:
    default:
        return `${dist.amount} ${dist.amount === 1 ? Parser.getSingletonUnit(dist.type) : dist.type}`;
    }
}
;
Parser.spRangeToFull._renderArea = function(range) {
    const size = range.distance;
    return `Self (${size.amount}-${Parser.getSingletonUnit(size.type)}${Parser.spRangeToFull._getAreaStyleString(range)}${range.type === Parser.RNG_CYLINDER ? `${size.amountSecondary != null && size.typeSecondary != null ? `, ${size.amountSecondary}-${Parser.getSingletonUnit(size.typeSecondary)}-high` : ""} cylinder` : ""})`;
}
;
Parser.spRangeToFull._getAreaStyleString = function(range) {
    switch (range.type) {
    case Parser.RNG_SPHERE:
        return " radius";
    case Parser.RNG_HEMISPHERE:
        return `-radius ${range.type}`;
    case Parser.RNG_CYLINDER:
        return "-radius";
    default:
        return ` ${range.type}`;
    }
}
;

Parser.getSingletonUnit = function(unit, isShort) {
    switch (unit) {
    case Parser.UNT_FEET:
        return isShort ? "ft." : "foot";
    case Parser.UNT_YARDS:
        return isShort ? "yd." : "yard";
    case Parser.UNT_MILES:
        return isShort ? "mi." : "mile";
    default:
        {
            const fromPrerelease = Parser._getSingletonUnit_prereleaseBrew({
                unit,
                isShort,
                brewUtil: PrereleaseUtil
            });
            if (fromPrerelease)
                return fromPrerelease;

            const fromBrew = Parser._getSingletonUnit_prereleaseBrew({
                unit,
                isShort,
                brewUtil: BrewUtil2
            });
            if (fromBrew)
                return fromBrew;

            if (unit.charAt(unit.length - 1) === "s")
                return unit.slice(0, -1);
            return unit;
        }
    }
}
;

Parser._getSingletonUnit_prereleaseBrew = function({unit, isShort, brewUtil}) {
    const fromBrew = brewUtil.getMetaLookup("spellDistanceUnits")?.[unit]?.["singular"];
    if (fromBrew)
        return fromBrew;
}
;

Parser.RANGE_TYPES = [{
    type: Parser.RNG_POINT,
    hasDistance: true,
    isRequireAmount: false
},
{
    type: Parser.RNG_LINE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_CUBE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_CONE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_RADIUS,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_SPHERE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_HEMISPHERE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_CYLINDER,
    hasDistance: true,
    isRequireAmount: true
},
{
    type: Parser.RNG_SPECIAL,
    hasDistance: false,
    isRequireAmount: false
}, ];

Parser.DIST_TYPES = [{
    type: Parser.RNG_SELF,
    hasAmount: false
}, {
    type: Parser.RNG_TOUCH,
    hasAmount: false
},
{
    type: Parser.UNT_FEET,
    hasAmount: true
}, {
    type: Parser.UNT_YARDS,
    hasAmount: true
}, {
    type: Parser.UNT_MILES,
    hasAmount: true
},
{
    type: Parser.RNG_SIGHT,
    hasAmount: false
}, {
    type: Parser.RNG_UNLIMITED_SAME_PLANE,
    hasAmount: false
}, {
    type: Parser.RNG_UNLIMITED,
    hasAmount: false
}, ];

Parser.spComponentsToFull = function(comp, level, {isPlainText=false}={}) {
    if (!comp)
        return "None";
    const out = [];
    if (comp.v)
        out.push("V");
    if (comp.s)
        out.push("S");
    if (comp.m != null) {
        const fnRender = isPlainText ? Renderer.stripTags.bind(Renderer) : Renderer.get().render.bind(Renderer.get());
        out.push(`M${comp.m !== true ? ` (${fnRender(comp.m.text != null ? comp.m.text : comp.m)})` : ""}`);
    }
    if (comp.r)
        out.push(`R (${level} gp)`);
    return out.join(", ") || "None";
}
;

Parser.SP_END_TYPE_TO_FULL = {
    "dispel": "dispelled",
    "trigger": "triggered",
    "discharge": "discharged",
};
Parser.spEndTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.SP_END_TYPE_TO_FULL, type);
}
;

Parser.spDurationToFull = function(dur) {
    let hasSubOr = false;
    const outParts = dur.map(d=>{
        switch (d.type) {
        case "special":
            return "Special";
        case "instant":
            return `Instantaneous${d.condition ? ` (${d.condition})` : ""}`;
        case "timed":
            return `${d.concentration ? "Concentration, " : ""}${d.concentration ? "u" : d.duration.upTo ? "U" : ""}${d.concentration || d.duration.upTo ? "p to " : ""}${d.duration.amount} ${d.duration.amount === 1 ? d.duration.type : `${d.duration.type}s`}`;
        case "permanent":
            {
                if (d.ends) {
                    const endsToJoin = d.ends.map(m=>Parser.spEndTypeToFull(m));
                    hasSubOr = hasSubOr || endsToJoin.length > 1;
                    return `Until ${endsToJoin.joinConjunct(", ", " or ")}`;
                } else {
                    return "Permanent";
                }
            }
        }
    }
    );
    return `${outParts.joinConjunct(hasSubOr ? "; " : ", ", " or ")}${dur.length > 1 ? " (see below)" : ""}`;
}
;

Parser.DURATION_TYPES = [{
    type: "instant",
    full: "Instantaneous"
}, {
    type: "timed",
    hasAmount: true
}, {
    type: "permanent",
    hasEnds: true
}, {
    type: "special"
}, ];

Parser.DURATION_AMOUNT_TYPES = ["turn", "round", "minute", "hour", "day", "week", "year", ];

Parser.spClassesToFull = function(sp, {isTextOnly=false, subclassLookup={}}={}) {
    const fromSubclassList = Renderer.spell.getCombinedClasses(sp, "fromSubclass");
    const fromSubclasses = Parser.spSubclassesToFull(fromSubclassList, {
        isTextOnly,
        subclassLookup
    });
    const fromClassList = Renderer.spell.getCombinedClasses(sp, "fromClassList");
    return `${Parser.spMainClassesToFull(fromClassList, {
        isTextOnly
    })}${fromSubclasses ? `, ${fromSubclasses}` : ""}`;
}
;

Parser.spMainClassesToFull = function(fromClassList, {isTextOnly=false}={}) {
    return fromClassList.map(c=>({
        hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](c),
        c
    })).filter(it=>!ExcludeUtil.isInitialised || !ExcludeUtil.isExcluded(it.hash, "class", it.c.source)).sort((a,b)=>SortUtil.ascSort(a.c.name, b.c.name)).map(it=>{
        if (isTextOnly)
            return it.c.name;

        return `<span title="${it.c.definedInSource ? `Class source` : "Source"}: ${Parser.sourceJsonToFull(it.c.source)}${it.c.definedInSource ? `. Spell list defined in: ${Parser.sourceJsonToFull(it.c.definedInSource)}.` : ""}">${Renderer.get().render(`{@class ${it.c.name}|${it.c.source}}`)}</span>`;
    }
    ).join(", ") || "";
}
;

Parser.spSubclassesToFull = function(fromSubclassList, {isTextOnly=false, subclassLookup={}}={}) {
    return fromSubclassList.filter(mt=>{
        if (!ExcludeUtil.isInitialised)
            return true;
        const excludeClass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](mt.class), "class", mt.class.source);
        if (excludeClass)
            return false;

        return !ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
            shortName: mt.subclass.name,
            source: mt.subclass.source,
            className: mt.class.name,
            classSource: mt.class.source,
        }), "subclass", mt.subclass.source, {
            isNoCount: true
        }, );
    }
    ).sort((a,b)=>{
        const byName = SortUtil.ascSort(a.class.name, b.class.name);
        return byName || SortUtil.ascSort(a.subclass.name, b.subclass.name);
    }
    ).map(c=>Parser._spSubclassItem({
        fromSubclass: c,
        isTextOnly
    })).join(", ") || "";
}
;

Parser._spSubclassItem = function({fromSubclass, isTextOnly}) {
    const c = fromSubclass.class;
    const sc = fromSubclass.subclass;
    const text = `${sc.shortName}${sc.subSubclass ? ` (${sc.subSubclass})` : ""}`;
    if (isTextOnly)
        return text;

    const classPart = `<span title="Source: ${Parser.sourceJsonToFull(c.source)}${c.definedInSource ? ` From a class spell list defined in: ${Parser.sourceJsonToFull(c.definedInSource)}` : ""}">${Renderer.get().render(`{@class ${c.name}|${c.source}}`)}</span>`;

    return `<span class="italic" title="Source: ${Parser.sourceJsonToFull(fromSubclass.subclass.source)}">${Renderer.get().render(`{@class ${c.name}|${c.source}|${text}|${sc.shortName}|${sc.source}}`)}</span> ${classPart}`;
}
;

Parser.SPELL_ATTACK_TYPE_TO_FULL = {};
Parser.SPELL_ATTACK_TYPE_TO_FULL["M"] = "Melee";
Parser.SPELL_ATTACK_TYPE_TO_FULL["R"] = "Ranged";
Parser.SPELL_ATTACK_TYPE_TO_FULL["O"] = "Other/Unknown";

Parser.spAttackTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.SPELL_ATTACK_TYPE_TO_FULL, type);
}
;

Parser.SPELL_AREA_TYPE_TO_FULL = {
    ST: "Single Target",
    MT: "Multiple Targets",
    C: "Cube",
    N: "Cone",
    Y: "Cylinder",
    S: "Sphere",
    R: "Circle",
    Q: "Square",
    L: "Line",
    H: "Hemisphere",
    W: "Wall",
};
Parser.spAreaTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.SPELL_AREA_TYPE_TO_FULL, type);
}
;

Parser.SP_MISC_TAG_TO_FULL = {
    HL: "Healing",
    THP: "Grants Temporary Hit Points",
    SGT: "Requires Sight",
    PRM: "Permanent Effects",
    SCL: "Scaling Effects",
    SMN: "Summons Creature",
    MAC: "Modifies AC",
    TP: "Teleportation",
    FMV: "Forced Movement",
    RO: "Rollable Effects",
    LGTS: "Creates Sunlight",
    LGT: "Creates Light",
    UBA: "Uses Bonus Action",
    PS: "Plane Shifting",
    OBS: "Obscures Vision",
    DFT: "Difficult Terrain",
    AAD: "Additional Attack Damage",
    OBJ: "Affects Objects",
    ADV: "Grants Advantage",
};
Parser.spMiscTagToFull = function(type) {
    return Parser._parse_aToB(Parser.SP_MISC_TAG_TO_FULL, type);
}
;

Parser.SP_CASTER_PROGRESSION_TO_FULL = {
    full: "Full",
    "1/2": "Half",
    "1/3": "One-Third",
    "pact": "Pact Magic",
};
Parser.spCasterProgressionToFull = function(type) {
    return Parser._parse_aToB(Parser.SP_CASTER_PROGRESSION_TO_FULL, type);
}
;

Parser.monTypeToFullObj = function(type) {
    const out = {
        types: [],
        tags: [],
        asText: "",
        asTextShort: "",

        typeSidekick: null,
        tagsSidekick: [],
        asTextSidekick: null,
    };

    if (typeof type === "string") {
        out.types = [type];
        out.asText = type.toTitleCase();
        out.asTextShort = out.asText;
        return out;
    }

    if (type.type?.choose) {
        out.types = type.type.choose;
    } else {
        out.types = [type.type];
    }

    if (type.swarmSize) {
        out.tags.push("swarm");
        out.asText = `swarm of ${Parser.sizeAbvToFull(type.swarmSize)} ${out.types.map(typ=>Parser.monTypeToPlural(typ).toTitleCase()).joinConjunct(", ", " or ")}`;
        out.asTextShort = out.asText;
        out.swarmSize = type.swarmSize;
    } else {
        out.asText = out.types.map(typ=>typ.toTitleCase()).joinConjunct(", ", " or ");
        out.asTextShort = out.asText;
    }

    const tagMetas = Parser.monTypeToFullObj._getTagMetas(type.tags);
    if (tagMetas.length) {
        out.tags.push(...tagMetas.map(({filterTag})=>filterTag));
        const ptTags = ` (${tagMetas.map(({displayTag})=>displayTag).join(", ")})`;
        out.asText += ptTags;
        out.asTextShort += ptTags;
    }

    if (type.note)
        out.asText += ` ${type.note}`;

    if (type.sidekickType) {
        out.typeSidekick = type.sidekickType;
        if (!type.sidekickHidden)
            out.asTextSidekick = `${type.sidekickType}`;

        const tagMetas = Parser.monTypeToFullObj._getTagMetas(type.sidekickTags);
        if (tagMetas.length) {
            out.tagsSidekick.push(...tagMetas.map(({filterTag})=>filterTag));
            if (!type.sidekickHidden)
                out.asTextSidekick += ` (${tagMetas.map(({displayTag})=>displayTag).join(", ")})`;
        }
    }

    return out;
}
;

Parser.monTypeToFullObj._getTagMetas = (tags)=>{
    return tags ? tags.map(tag=>{
        if (typeof tag === "string") {
            return {
                filterTag: tag.toLowerCase(),
                displayTag: tag.toTitleCase(),
            };
        } else {
            return {
                filterTag: tag.tag.toLowerCase(),
                displayTag: `${tag.prefix} ${tag.tag}`.toTitleCase(),
            };
        }
    }
    ) : [];
}
;

Parser.monTypeToPlural = function(type) {
    return Parser._parse_aToB(Parser.MON_TYPE_TO_PLURAL, type);
}
;

Parser.monTypeFromPlural = function(type) {
    return Parser._parse_bToA(Parser.MON_TYPE_TO_PLURAL, type);
}
;

Parser.monCrToFull = function(cr, {xp=null, isMythic=false}={}) {
    if (cr == null)
        return "";

    if (typeof cr === "string") {
        if (Parser.crToNumber(cr) >= VeCt.CR_CUSTOM)
            return `${cr}${xp != null ? ` (${xp} XP)` : ""}`;

        xp = xp != null ? Parser._addCommas(xp) : Parser.crToXp(cr);
        return `${cr} (${xp} XP${isMythic ? `, or ${Parser.crToXp(cr, {
            isDouble: true
        })} XP as a mythic encounter` : ""})`;
    } else {
        const stack = [Parser.monCrToFull(cr.cr, {
            xp: cr.xp,
            isMythic
        })];
        if (cr.lair)
            stack.push(`${Parser.monCrToFull(cr.lair)} when encountered in lair`);
        if (cr.coven)
            stack.push(`${Parser.monCrToFull(cr.coven)} when part of a coven`);
        return stack.joinConjunct(", ", " or ");
    }
}
;

Parser.getFullImmRes = function(toParse) {
    if (!toParse?.length)
        return "";

    let maxDepth = 0;

    function toString(it, depth=0) {
        maxDepth = Math.max(maxDepth, depth);
        if (typeof it === "string") {
            return it;
        } else if (it.special) {
            return it.special;
        } else {
            const stack = [];

            if (it.preNote)
                stack.push(it.preNote);

            const prop = it.immune ? "immune" : it.resist ? "resist" : it.vulnerable ? "vulnerable" : null;
            if (prop) {
                const toJoin = it[prop].length === Parser.DMG_TYPES.length && CollectionUtil.deepEquals(Parser.DMG_TYPES, it[prop]) ? ["all damage"] : it[prop].map(nxt=>toString(nxt, depth + 1));
                stack.push(depth ? toJoin.join(maxDepth ? "; " : ", ") : toJoin.joinConjunct(", ", " and "));
            }

            if (it.note)
                stack.push(it.note);

            return stack.join(" ");
        }
    }

    const arr = toParse.map(it=>toString(it));

    if (arr.length <= 1)
        return arr.join("");

    let out = "";
    for (let i = 0; i < arr.length - 1; ++i) {
        const it = arr[i];
        const nxt = arr[i + 1];

        const orig = toParse[i];
        const origNxt = toParse[i + 1];

        out += it;
        out += (it.includes(",") || nxt.includes(",") || (orig && orig.cond) || (origNxt && origNxt.cond)) ? "; " : ", ";
    }
    out += arr.last();
    return out;
}
;

Parser.getFullCondImm = function(condImm, {isPlainText=false, isEntry=false}={}) {
    if (isPlainText && isEntry)
        throw new Error(`Options "isPlainText" and "isEntry" are mutually exclusive!`);

    if (!condImm?.length)
        return "";

    const render = condition=>{
        if (isPlainText)
            return condition;
        const ent = `{@condition ${condition}}`;
        if (isEntry)
            return ent;
        return Renderer.get().render(ent);
    }
    ;

    return condImm.map(it=>{
        if (it.special)
            return it.special;
        if (it.conditionImmune)
            return `${it.preNote ? `${it.preNote} ` : ""}${it.conditionImmune.map(render).join(", ")}${it.note ? ` ${it.note}` : ""}`;
        return render(it);
    }
    ).sort(SortUtil.ascSortLower).join(", ");
}
;

Parser.MON_SENSE_TAG_TO_FULL = {
    "B": "blindsight",
    "D": "darkvision",
    "SD": "superior darkvision",
    "T": "tremorsense",
    "U": "truesight",
};
Parser.monSenseTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_SENSE_TAG_TO_FULL, tag);
}
;

Parser.MON_SPELLCASTING_TAG_TO_FULL = {
    "P": "Psionics",
    "I": "Innate",
    "F": "Form Only",
    "S": "Shared",
    "O": "Other",
    "CA": "Class, Artificer",
    "CB": "Class, Bard",
    "CC": "Class, Cleric",
    "CD": "Class, Druid",
    "CP": "Class, Paladin",
    "CR": "Class, Ranger",
    "CS": "Class, Sorcerer",
    "CL": "Class, Warlock",
    "CW": "Class, Wizard",
};
Parser.monSpellcastingTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_SPELLCASTING_TAG_TO_FULL, tag);
}
;

Parser.MON_MISC_TAG_TO_FULL = {
    "AOE": "Has Areas of Effect",
    "HPR": "Has HP Reduction",
    "MW": "Has Weapon Attacks, Melee",
    "RW": "Has Weapon Attacks, Ranged",
    "MLW": "Has Melee Weapons",
    "RNG": "Has Ranged Weapons",
    "RCH": "Has Reach Attacks",
    "THW": "Has Thrown Weapons",
};
Parser.monMiscTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_MISC_TAG_TO_FULL, tag);
}
;

Parser.MON_LANGUAGE_TAG_TO_FULL = {
    "AB": "Abyssal",
    "AQ": "Aquan",
    "AU": "Auran",
    "C": "Common",
    "CE": "Celestial",
    "CS": "Can't Speak Known Languages",
    "D": "Dwarvish",
    "DR": "Draconic",
    "DS": "Deep Speech",
    "DU": "Druidic",
    "E": "Elvish",
    "G": "Gnomish",
    "GI": "Giant",
    "GO": "Goblin",
    "GTH": "Gith",
    "H": "Halfling",
    "I": "Infernal",
    "IG": "Ignan",
    "LF": "Languages Known in Life",
    "O": "Orc",
    "OTH": "Other",
    "P": "Primordial",
    "S": "Sylvan",
    "T": "Terran",
    "TC": "Thieves' cant",
    "TP": "Telepathy",
    "U": "Undercommon",
    "X": "Any (Choose)",
    "XX": "All",
};
Parser.monLanguageTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_LANGUAGE_TAG_TO_FULL, tag);
}
;

Parser.ENVIRONMENTS = ["arctic", "coastal", "desert", "forest", "grassland", "hill", "mountain", "swamp", "underdark", "underwater", "urban"];

Parser.PSI_ABV_TYPE_TALENT = "T";
Parser.PSI_ABV_TYPE_DISCIPLINE = "D";
Parser.PSI_ORDER_NONE = "None";
Parser.psiTypeToFull = type=>Parser.psiTypeToMeta(type).full;

Parser.psiTypeToMeta = type=>{
    let out = {};
    if (type === Parser.PSI_ABV_TYPE_TALENT)
        out = {
            hasOrder: false,
            full: "Talent"
        };
    else if (type === Parser.PSI_ABV_TYPE_DISCIPLINE)
        out = {
            hasOrder: true,
            full: "Discipline"
        };
    else if (PrereleaseUtil.getMetaLookup("psionicTypes")?.[type])
        out = MiscUtil.copyFast(PrereleaseUtil.getMetaLookup("psionicTypes")[type]);
    else if (BrewUtil2.getMetaLookup("psionicTypes")?.[type])
        out = MiscUtil.copyFast(BrewUtil2.getMetaLookup("psionicTypes")[type]);
    out.full = out.full || "Unknown";
    out.short = out.short || out.full;
    return out;
}
;

Parser.psiOrderToFull = (order)=>{
    return order === undefined ? Parser.PSI_ORDER_NONE : order;
}
;

Parser.prereqSpellToFull = function(spell, {isTextOnly=false}={}) {
    if (spell) {
        const [text,suffix] = spell.split("#");
        if (!suffix)
            return isTextOnly ? spell : Renderer.get().render(`{@spell ${spell}}`);
        else if (suffix === "c")
            return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))(`{@spell ${text}} cantrip`);
        else if (suffix === "x")
            return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))("{@spell hex} spell or a warlock feature that curses");
    } else
        return VeCt.STR_NONE;
}
;

Parser.prereqPactToFull = function(pact) {
    if (pact === "Chain")
        return "Pact of the Chain";
    if (pact === "Tome")
        return "Pact of the Tome";
    if (pact === "Blade")
        return "Pact of the Blade";
    if (pact === "Talisman")
        return "Pact of the Talisman";
    return pact;
}
;

Parser.prereqPatronToShort = function(patron) {
    if (patron === "Any")
        return patron;
    const mThe = /^The (.*?)$/.exec(patron);
    if (mThe)
        return mThe[1];
    return patron;
}
;

Parser.OPT_FEATURE_TYPE_TO_FULL = {
    AI: "Artificer Infusion",
    ED: "Elemental Discipline",
    EI: "Eldritch Invocation",
    MM: "Metamagic",
    "MV": "Maneuver",
    "MV:B": "Maneuver, Battle Master",
    "MV:C2-UA": "Maneuver, Cavalier V2 (UA)",
    "AS:V1-UA": "Arcane Shot, V1 (UA)",
    "AS:V2-UA": "Arcane Shot, V2 (UA)",
    "AS": "Arcane Shot",
    OTH: "Other",
    "FS:F": "Fighting Style; Fighter",
    "FS:B": "Fighting Style; Bard",
    "FS:P": "Fighting Style; Paladin",
    "FS:R": "Fighting Style; Ranger",
    "PB": "Pact Boon",
    "OR": "Onomancy Resonant",
    "RN": "Rune Knight Rune",
    "AF": "Alchemical Formula",
};

Parser.optFeatureTypeToFull = function(type) {
    if (Parser.OPT_FEATURE_TYPE_TO_FULL[type])
        return Parser.OPT_FEATURE_TYPE_TO_FULL[type];
    if (PrereleaseUtil.getMetaLookup("optionalFeatureTypes")?.[type])
        return PrereleaseUtil.getMetaLookup("optionalFeatureTypes")[type];
    if (BrewUtil2.getMetaLookup("optionalFeatureTypes")?.[type])
        return BrewUtil2.getMetaLookup("optionalFeatureTypes")[type];
    return type;
}
;

Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL = {
    "SG": "Supernatural Gift",
    "OF": "Optional Feature",
    "DG": "Dark Gift",
    "RF:B": "Replacement Feature: Background",
    "CS": "Character Secret",
};

Parser.charCreationOptionTypeToFull = function(type) {
    if (Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type])
        return Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type];
    if (PrereleaseUtil.getMetaLookup("charOption")?.[type])
        return PrereleaseUtil.getMetaLookup("charOption")[type];
    if (BrewUtil2.getMetaLookup("charOption")?.[type])
        return BrewUtil2.getMetaLookup("charOption")[type];
    return type;
}
;

Parser.alignmentAbvToFull = function(alignment) {
    if (!alignment)
        return null;
    if (typeof alignment === "object") {
        if (alignment.special != null) {
            return alignment.special;
        } else {
            return `${alignment.alignment.map(a=>Parser.alignmentAbvToFull(a)).join(" ")}${alignment.chance ? ` (${alignment.chance}%)` : ""}${alignment.note ? ` (${alignment.note})` : ""}`;
        }
    } else {
        alignment = alignment.toUpperCase();
        switch (alignment) {
        case "L":
            return "lawful";
        case "N":
            return "neutral";
        case "NX":
            return "neutral (law/chaos axis)";
        case "NY":
            return "neutral (good/evil axis)";
        case "C":
            return "chaotic";
        case "G":
            return "good";
        case "E":
            return "evil";
        case "U":
            return "unaligned";
        case "A":
            return "any alignment";
        }
        return alignment;
    }
}
;

Parser.alignmentListToFull = function(alignList) {
    if (!alignList)
        return "";
    if (alignList.some(it=>typeof it !== "string")) {
        if (alignList.some(it=>typeof it === "string"))
            throw new Error(`Mixed alignment types: ${JSON.stringify(alignList)}`);
        alignList = alignList.filter(it=>it.alignment === undefined || it.alignment != null);
        return alignList.map(it=>it.special != null || it.chance != null || it.note != null ? Parser.alignmentAbvToFull(it) : Parser.alignmentListToFull(it.alignment)).join(" or ");
    } else {
        if (alignList.length === 1)
            return Parser.alignmentAbvToFull(alignList[0]);
        if (alignList.length === 2) {
            return alignList.map(a=>Parser.alignmentAbvToFull(a)).join(" ");
        }
        if (alignList.length === 3) {
            if (alignList.includes("NX") && alignList.includes("NY") && alignList.includes("N"))
                return "any neutral alignment";
        }
        if (alignList.length === 5) {
            if (!alignList.includes("G"))
                return "any non-good alignment";
            if (!alignList.includes("E"))
                return "any non-evil alignment";
            if (!alignList.includes("L"))
                return "any non-lawful alignment";
            if (!alignList.includes("C"))
                return "any non-chaotic alignment";
        }
        if (alignList.length === 4) {
            if (!alignList.includes("L") && !alignList.includes("NX"))
                return "any chaotic alignment";
            if (!alignList.includes("G") && !alignList.includes("NY"))
                return "any evil alignment";
            if (!alignList.includes("C") && !alignList.includes("NX"))
                return "any lawful alignment";
            if (!alignList.includes("E") && !alignList.includes("NY"))
                return "any good alignment";
        }
        throw new Error(`Unmapped alignment: ${JSON.stringify(alignList)}`);
    }
}
;

Parser.weightToFull = function(lbs, isSmallUnit) {
    const tons = Math.floor(lbs / 2000);
    lbs = lbs - (2000 * tons);
    return [tons ? `${tons}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}ton${tons === 1 ? "" : "s"}${isSmallUnit ? `</span>` : ""}` : null, lbs ? `${lbs}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}lb.${isSmallUnit ? `</span>` : ""}` : null, ].filter(Boolean).join(", ");
}
;

Parser.RARITIES = ["common", "uncommon", "rare", "very rare", "legendary", "artifact"];
Parser.ITEM_RARITIES = ["none", ...Parser.RARITIES, "unknown", "unknown (magic)", "other"];

Parser.CAT_ID_CREATURE = 1;
Parser.CAT_ID_SPELL = 2;
Parser.CAT_ID_BACKGROUND = 3;
Parser.CAT_ID_ITEM = 4;
Parser.CAT_ID_CLASS = 5;
Parser.CAT_ID_CONDITION = 6;
Parser.CAT_ID_FEAT = 7;
Parser.CAT_ID_ELDRITCH_INVOCATION = 8;
Parser.CAT_ID_PSIONIC = 9;
Parser.CAT_ID_RACE = 10;
Parser.CAT_ID_OTHER_REWARD = 11;
Parser.CAT_ID_VARIANT_OPTIONAL_RULE = 12;
Parser.CAT_ID_ADVENTURE = 13;
Parser.CAT_ID_DEITY = 14;
Parser.CAT_ID_OBJECT = 15;
Parser.CAT_ID_TRAP = 16;
Parser.CAT_ID_HAZARD = 17;
Parser.CAT_ID_QUICKREF = 18;
Parser.CAT_ID_CULT = 19;
Parser.CAT_ID_BOON = 20;
Parser.CAT_ID_DISEASE = 21;
Parser.CAT_ID_METAMAGIC = 22;
Parser.CAT_ID_MANEUVER_BATTLEMASTER = 23;
Parser.CAT_ID_TABLE = 24;
Parser.CAT_ID_TABLE_GROUP = 25;
Parser.CAT_ID_MANEUVER_CAVALIER = 26;
Parser.CAT_ID_ARCANE_SHOT = 27;
Parser.CAT_ID_OPTIONAL_FEATURE_OTHER = 28;
Parser.CAT_ID_FIGHTING_STYLE = 29;
Parser.CAT_ID_CLASS_FEATURE = 30;
Parser.CAT_ID_VEHICLE = 31;
Parser.CAT_ID_PACT_BOON = 32;
Parser.CAT_ID_ELEMENTAL_DISCIPLINE = 33;
Parser.CAT_ID_ARTIFICER_INFUSION = 34;
Parser.CAT_ID_SHIP_UPGRADE = 35;
Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE = 36;
Parser.CAT_ID_ONOMANCY_RESONANT = 37;
Parser.CAT_ID_RUNE_KNIGHT_RUNE = 37;
Parser.CAT_ID_ALCHEMICAL_FORMULA = 38;
Parser.CAT_ID_MANEUVER = 39;
Parser.CAT_ID_SUBCLASS = 40;
Parser.CAT_ID_SUBCLASS_FEATURE = 41;
Parser.CAT_ID_ACTION = 42;
Parser.CAT_ID_LANGUAGE = 43;
Parser.CAT_ID_BOOK = 44;
Parser.CAT_ID_PAGE = 45;
Parser.CAT_ID_LEGENDARY_GROUP = 46;
Parser.CAT_ID_CHAR_CREATION_OPTIONS = 47;
Parser.CAT_ID_RECIPES = 48;
Parser.CAT_ID_STATUS = 49;
Parser.CAT_ID_SKILLS = 50;
Parser.CAT_ID_SENSES = 51;
Parser.CAT_ID_DECK = 52;
Parser.CAT_ID_CARD = 53;

Parser.CAT_ID_TO_FULL = {};
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CREATURE] = "Bestiary";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SPELL] = "Spell";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BACKGROUND] = "Background";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ITEM] = "Item";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS] = "Class";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CONDITION] = "Condition";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FEAT] = "Feat";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELDRITCH_INVOCATION] = "Eldritch Invocation";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PSIONIC] = "Psionic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RACE] = "Race";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OTHER_REWARD] = "Other Reward";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "Variant/Optional Rule";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ADVENTURE] = "Adventure";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DEITY] = "Deity";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OBJECT] = "Object";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TRAP] = "Trap";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_HAZARD] = "Hazard";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_QUICKREF] = "Quick Reference";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CULT] = "Cult";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOON] = "Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DISEASE] = "Disease";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_METAMAGIC] = "Metamagic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "Maneuver; Battlemaster";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE_GROUP] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_CAVALIER] = "Maneuver; Cavalier";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARCANE_SHOT] = "Arcane Shot";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "Optional Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FIGHTING_STYLE] = "Fighting Style";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS_FEATURE] = "Class Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VEHICLE] = "Vehicle";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PACT_BOON] = "Pact Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "Elemental Discipline";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARTIFICER_INFUSION] = "Infusion";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SHIP_UPGRADE] = "Ship Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "Infernal War Machine Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ONOMANCY_RESONANT] = "Onomancy Resonant";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "Rune Knight Rune";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "Alchemical Formula";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER] = "Maneuver";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS] = "Subclass";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS_FEATURE] = "Subclass Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ACTION] = "Action";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LANGUAGE] = "Language";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOOK] = "Book";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PAGE] = "Page";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LEGENDARY_GROUP] = "Legendary Group";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "Character Creation Option";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RECIPES] = "Recipe";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_STATUS] = "Status";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DECK] = "Deck";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CARD] = "Card";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SKILLS] = "Skill";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SENSES] = "Sense";

Parser.pageCategoryToFull = function(catId) {
    return Parser._parse_aToB(Parser.CAT_ID_TO_FULL, catId);
}
;

Parser.CAT_ID_TO_PROP = {};
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CREATURE] = "monster";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SPELL] = "spell";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BACKGROUND] = "background";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ITEM] = "item";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS] = "class";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CONDITION] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FEAT] = "feat";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PSIONIC] = "psionic";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RACE] = "race";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OTHER_REWARD] = "reward";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "variantrule";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ADVENTURE] = "adventure";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DEITY] = "deity";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OBJECT] = "object";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TRAP] = "trap";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_HAZARD] = "hazard";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CULT] = "cult";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOON] = "boon";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DISEASE] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE] = "table";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE_GROUP] = "tableGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VEHICLE] = "vehicle";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELDRITCH_INVOCATION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_CAVALIER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARCANE_SHOT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FIGHTING_STYLE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_METAMAGIC] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PACT_BOON] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARTIFICER_INFUSION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SHIP_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ONOMANCY_RESONANT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_QUICKREF] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS_FEATURE] = "classFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS] = "subclass";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ACTION] = "action";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LANGUAGE] = "language";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOOK] = "book";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PAGE] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "charoption";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RECIPES] = "recipe";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_STATUS] = "status";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DECK] = "deck";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CARD] = "card";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SKILLS] = "skill";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SENSES] = "sense";

Parser.pageCategoryToProp = function(catId) {
    return Parser._parse_aToB(Parser.CAT_ID_TO_PROP, catId);
}
;

Parser.ABIL_ABVS = ["str", "dex", "con", "int", "wis", "cha"];

Parser.spClassesToCurrentAndLegacy = function(fromClassList) {
    const current = [];
    const legacy = [];
    fromClassList.forEach(cls=>{
        if ((cls.name === "Artificer" && cls.source === "UAArtificer") || (cls.name === "Artificer (Revisited)" && cls.source === "UAArtificerRevisited"))
            legacy.push(cls);
        else
            current.push(cls);
    }
    );
    return [current, legacy];
}
;

Parser.spSubclassesToCurrentAndLegacyFull = function(sp, subclassLookup) {
    return Parser._spSubclassesToCurrentAndLegacyFull({
        sp,
        subclassLookup,
        prop: "fromSubclass"
    });
}
;

Parser.spVariantSubclassesToCurrentAndLegacyFull = function(sp, subclassLookup) {
    return Parser._spSubclassesToCurrentAndLegacyFull({
        sp,
        subclassLookup,
        prop: "fromSubclassVariant"
    });
}
;

Parser._spSubclassesToCurrentAndLegacyFull = ({sp, subclassLookup, prop})=>{
    const fromSubclass = Renderer.spell.getCombinedClasses(sp, prop);
    if (!fromSubclass.length)
        return ["", ""];

    const current = [];
    const legacy = [];
    const curNames = new Set();
    const toCheck = [];
    fromSubclass.filter(c=>{
        const excludeClass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
            name: c.class.name,
            source: c.class.source
        }), "class", c.class.source, {
            isNoCount: true
        }, );
        if (excludeClass)
            return false;

        const excludeSubclass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
            shortName: c.subclass.shortName,
            source: c.subclass.source,
            className: c.class.name,
            classSource: c.class.source,
        }), "subclass", c.subclass.source, {
            isNoCount: true
        }, );
        if (excludeSubclass)
            return false;

        return !Renderer.spell.isExcludedSubclassVariantSource({
            classDefinedInSource: c.class.definedInSource
        });
    }
    ).sort((a,b)=>{
        const byName = SortUtil.ascSort(a.subclass.name, b.subclass.name);
        return byName || SortUtil.ascSort(a.class.name, b.class.name);
    }
    ).forEach(c=>{
        const nm = c.subclass.name;
        const src = c.subclass.source;

        const toAdd = Parser._spSubclassItem({
            fromSubclass: c,
            isTextOnly: false
        });

        const fromLookup = MiscUtil.get(subclassLookup, c.class.source, c.class.name, c.subclass.source, c.subclass.name, );

        if (fromLookup && fromLookup.isReprinted) {
            legacy.push(toAdd);
        } else if (SourceUtil.isNonstandardSource(src)) {
            const cleanName = Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent(nm.split("(")[0].trim().split(/v\d+/)[0].trim(), );
            toCheck.push({
                "name": cleanName,
                "ele": toAdd
            });
        } else {
            current.push(toAdd);
            curNames.add(nm);
        }
    }
    );

    toCheck.forEach(n=>{
        if (curNames.has(n.name)) {
            legacy.push(n.ele);
        } else {
            current.push(n.ele);
        }
    }
    );

    return [current.join(", "), legacy.join(", ")];
}
;

Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent = (shortName)=>{
    switch (shortName) {
    case "Favored Soul":
        return "Divine Soul";
    case "Undying Light":
        return "Celestial";
    case "Deep Stalker":
        return "Gloom Stalker";
    }
    return shortName;
}
;

Parser.spVariantClassesToCurrentAndLegacy = function(fromVariantClassList) {
    const current = [];
    const legacy = [];
    fromVariantClassList.forEach(cls=>{
        if (SourceUtil.isPrereleaseSource(cls.definedInSource))
            legacy.push(cls);
        else
            current.push(cls);
    }
    );
    return [current, legacy];
}
;

Parser.attackTypeToFull = function(attackType) {
    return Parser._parse_aToB(Parser.ATK_TYPE_TO_FULL, attackType);
}
;

Parser.trapHazTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.TRAP_HAZARD_TYPE_TO_FULL, type);
}
;

Parser.TRAP_HAZARD_TYPE_TO_FULL = {
    MECH: "Mechanical Trap",
    MAG: "Magical Trap",
    SMPL: "Simple Trap",
    CMPX: "Complex Trap",
    HAZ: "Hazard",
    WTH: "Weather",
    ENV: "Environmental Hazard",
    WLD: "Wilderness Hazard",
    GEN: "Generic",
    EST: "Eldritch Storm",
};

Parser.tierToFullLevel = function(tier) {
    return Parser._parse_aToB(Parser.TIER_TO_FULL_LEVEL, tier);
}
;

Parser.TIER_TO_FULL_LEVEL = {};
Parser.TIER_TO_FULL_LEVEL[1] = "1st\u20134th Level";
Parser.TIER_TO_FULL_LEVEL[2] = "5th\u201310th Level";
Parser.TIER_TO_FULL_LEVEL[3] = "11th\u201316th Level";
Parser.TIER_TO_FULL_LEVEL[4] = "17th\u201320th Level";

Parser.trapInitToFull = function(init) {
    return Parser._parse_aToB(Parser.TRAP_INIT_TO_FULL, init);
}
;

Parser.TRAP_INIT_TO_FULL = {};
Parser.TRAP_INIT_TO_FULL[1] = "initiative count 10";
Parser.TRAP_INIT_TO_FULL[2] = "initiative count 20";
Parser.TRAP_INIT_TO_FULL[3] = "initiative count 20 and initiative count 10";

Parser.ATK_TYPE_TO_FULL = {};
Parser.ATK_TYPE_TO_FULL["MW"] = "Melee Weapon Attack";
Parser.ATK_TYPE_TO_FULL["RW"] = "Ranged Weapon Attack";

Parser.bookOrdinalToAbv = (ordinal,preNoSuff)=>{
    if (ordinal === undefined)
        return "";
    switch (ordinal.type) {
    case "part":
        return `${preNoSuff ? " " : ""}Part ${ordinal.identifier}${preNoSuff ? "" : " \u2014 "}`;
    case "chapter":
        return `${preNoSuff ? " " : ""}Ch. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
    case "episode":
        return `${preNoSuff ? " " : ""}Ep. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
    case "appendix":
        return `${preNoSuff ? " " : ""}App.${ordinal.identifier != null ? ` ${ordinal.identifier}` : ""}${preNoSuff ? "" : ": "}`;
    case "level":
        return `${preNoSuff ? " " : ""}Level ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
    default:
        throw new Error(`Unhandled ordinal type "${ordinal.type}"`);
    }
}
;

Parser.IMAGE_TYPE_TO_FULL = {
    "map": "Map",
    "mapPlayer": "Map (Player)",
};
Parser.imageTypeToFull = function(imageType) {
    return Parser._parse_aToB(Parser.IMAGE_TYPE_TO_FULL, imageType, "Other");
}
;

Parser.nameToTokenName = function(name) {
    return name.toAscii().replace(/"/g, "");
}
;

Parser.bytesToHumanReadable = function(bytes, {fixedDigits=2}={}) {
    if (bytes == null)
        return "";
    if (!bytes)
        return "0 B";
    const e = Math.floor(Math.log(bytes) / Math.log(1024));
    return `${(bytes / Math.pow(1024, e)).toFixed(fixedDigits)} ${`\u200bKMGTP`.charAt(e)}B`;
}
;

Parser.SKL_ABV_ABJ = "A";
Parser.SKL_ABV_EVO = "V";
Parser.SKL_ABV_ENC = "E";
Parser.SKL_ABV_ILL = "I";
Parser.SKL_ABV_DIV = "D";
Parser.SKL_ABV_NEC = "N";
Parser.SKL_ABV_TRA = "T";
Parser.SKL_ABV_CON = "C";
Parser.SKL_ABV_PSI = "P";
Parser.SKL_ABVS = [Parser.SKL_ABV_ABJ, Parser.SKL_ABV_CON, Parser.SKL_ABV_DIV, Parser.SKL_ABV_ENC, Parser.SKL_ABV_EVO, Parser.SKL_ABV_ILL, Parser.SKL_ABV_NEC, Parser.SKL_ABV_PSI, Parser.SKL_ABV_TRA, ];

Parser.SP_TM_ACTION = "action";
Parser.SP_TM_B_ACTION = "bonus";
Parser.SP_TM_REACTION = "reaction";
Parser.SP_TM_ROUND = "round";
Parser.SP_TM_MINS = "minute";
Parser.SP_TM_HRS = "hour";
Parser.SP_TIME_SINGLETONS = [Parser.SP_TM_ACTION, Parser.SP_TM_B_ACTION, Parser.SP_TM_REACTION, Parser.SP_TM_ROUND];
Parser.SP_TIME_TO_FULL = {
    [Parser.SP_TM_ACTION]: "Action",
    [Parser.SP_TM_B_ACTION]: "Bonus Action",
    [Parser.SP_TM_REACTION]: "Reaction",
    [Parser.SP_TM_ROUND]: "Rounds",
    [Parser.SP_TM_MINS]: "Minutes",
    [Parser.SP_TM_HRS]: "Hours",
};
Parser.spTimeUnitToFull = function(timeUnit) {
    return Parser._parse_aToB(Parser.SP_TIME_TO_FULL, timeUnit);
}
;

Parser.SP_TIME_TO_SHORT = {
    [Parser.SP_TM_ROUND]: "Rnd.",
    [Parser.SP_TM_MINS]: "Min.",
    [Parser.SP_TM_HRS]: "Hr.",
};
Parser.spTimeUnitToShort = function(timeUnit) {
    return Parser._parse_aToB(Parser.SP_TIME_TO_SHORT, timeUnit);
}
;

Parser.SP_TIME_TO_ABV = {
    [Parser.SP_TM_ACTION]: "A",
    [Parser.SP_TM_B_ACTION]: "BA",
    [Parser.SP_TM_REACTION]: "R",
    [Parser.SP_TM_ROUND]: "rnd",
    [Parser.SP_TM_MINS]: "min",
    [Parser.SP_TM_HRS]: "hr",
};
Parser.spTimeUnitToAbv = function(timeUnit) {
    return Parser._parse_aToB(Parser.SP_TIME_TO_ABV, timeUnit);
}
;

Parser.spTimeToShort = function(time, isHtml) {
    if (!time)
        return "";
    return (time.number === 1 && Parser.SP_TIME_SINGLETONS.includes(time.unit)) ? `${Parser.spTimeUnitToAbv(time.unit).uppercaseFirst()}${time.condition ? "*" : ""}` : `${time.number} ${isHtml ? `<span class="ve-small">` : ""}${Parser.spTimeUnitToAbv(time.unit)}${isHtml ? `</span>` : ""}${time.condition ? "*" : ""}`;
}
;

Parser.SKL_ABJ = "Abjuration";
Parser.SKL_EVO = "Evocation";
Parser.SKL_ENC = "Enchantment";
Parser.SKL_ILL = "Illusion";
Parser.SKL_DIV = "Divination";
Parser.SKL_NEC = "Necromancy";
Parser.SKL_TRA = "Transmutation";
Parser.SKL_CON = "Conjuration";
Parser.SKL_PSI = "Psionic";

Parser.SP_SCHOOL_ABV_TO_FULL = {};
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ABJ] = Parser.SKL_ABJ;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_EVO] = Parser.SKL_EVO;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ENC] = Parser.SKL_ENC;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ILL] = Parser.SKL_ILL;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_DIV] = Parser.SKL_DIV;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_NEC] = Parser.SKL_NEC;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_TRA] = Parser.SKL_TRA;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_CON] = Parser.SKL_CON;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_PSI] = Parser.SKL_PSI;

Parser.SP_SCHOOL_ABV_TO_SHORT = {};
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ABJ] = "Abj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_EVO] = "Evoc.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ENC] = "Ench.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ILL] = "Illu.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_DIV] = "Divin.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_NEC] = "Necro.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_TRA] = "Trans.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_CON] = "Conj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_PSI] = "Psi.";

Parser.ATB_ABV_TO_FULL = {
    "str": "Strength",
    "dex": "Dexterity",
    "con": "Constitution",
    "int": "Intelligence",
    "wis": "Wisdom",
    "cha": "Charisma",
};

Parser.TP_ABERRATION = "aberration";
Parser.TP_BEAST = "beast";
Parser.TP_CELESTIAL = "celestial";
Parser.TP_CONSTRUCT = "construct";
Parser.TP_DRAGON = "dragon";
Parser.TP_ELEMENTAL = "elemental";
Parser.TP_FEY = "fey";
Parser.TP_FIEND = "fiend";
Parser.TP_GIANT = "giant";
Parser.TP_HUMANOID = "humanoid";
Parser.TP_MONSTROSITY = "monstrosity";
Parser.TP_OOZE = "ooze";
Parser.TP_PLANT = "plant";
Parser.TP_UNDEAD = "undead";
Parser.MON_TYPES = [Parser.TP_ABERRATION, Parser.TP_BEAST, Parser.TP_CELESTIAL, Parser.TP_CONSTRUCT, Parser.TP_DRAGON, Parser.TP_ELEMENTAL, Parser.TP_FEY, Parser.TP_FIEND, Parser.TP_GIANT, Parser.TP_HUMANOID, Parser.TP_MONSTROSITY, Parser.TP_OOZE, Parser.TP_PLANT, Parser.TP_UNDEAD];
Parser.MON_TYPE_TO_PLURAL = {};
Parser.MON_TYPE_TO_PLURAL[Parser.TP_ABERRATION] = "aberrations";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_BEAST] = "beasts";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_CELESTIAL] = "celestials";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_CONSTRUCT] = "constructs";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_DRAGON] = "dragons";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_ELEMENTAL] = "elementals";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_FEY] = "fey";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_FIEND] = "fiends";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_GIANT] = "giants";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_HUMANOID] = "humanoids";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_MONSTROSITY] = "monstrosities";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_OOZE] = "oozes";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_PLANT] = "plants";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_UNDEAD] = "undead";

Parser.SZ_FINE = "F";
Parser.SZ_DIMINUTIVE = "D";
Parser.SZ_TINY = "T";
Parser.SZ_SMALL = "S";
Parser.SZ_MEDIUM = "M";
Parser.SZ_LARGE = "L";
Parser.SZ_HUGE = "H";
Parser.SZ_GARGANTUAN = "G";
Parser.SZ_COLOSSAL = "C";
Parser.SZ_VARIES = "V";
Parser.SIZE_ABVS = [Parser.SZ_TINY, Parser.SZ_SMALL, Parser.SZ_MEDIUM, Parser.SZ_LARGE, Parser.SZ_HUGE, Parser.SZ_GARGANTUAN, Parser.SZ_VARIES];
Parser.SIZE_ABV_TO_FULL = {};
Parser.SIZE_ABV_TO_FULL[Parser.SZ_FINE] = "Fine";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_DIMINUTIVE] = "Diminutive";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_TINY] = "Tiny";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_SMALL] = "Small";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_MEDIUM] = "Medium";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_LARGE] = "Large";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_HUGE] = "Huge";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_GARGANTUAN] = "Gargantuan";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_COLOSSAL] = "Colossal";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_VARIES] = "Varies";

Parser.XP_CHART_ALT = {
    "0": 10,
    "1/8": 25,
    "1/4": 50,
    "1/2": 100,
    "1": 200,
    "2": 450,
    "3": 700,
    "4": 1100,
    "5": 1800,
    "6": 2300,
    "7": 2900,
    "8": 3900,
    "9": 5000,
    "10": 5900,
    "11": 7200,
    "12": 8400,
    "13": 10000,
    "14": 11500,
    "15": 13000,
    "16": 15000,
    "17": 18000,
    "18": 20000,
    "19": 22000,
    "20": 25000,
    "21": 33000,
    "22": 41000,
    "23": 50000,
    "24": 62000,
    "25": 75000,
    "26": 90000,
    "27": 105000,
    "28": 120000,
    "29": 135000,
    "30": 155000,
};

Parser.ARMOR_ABV_TO_FULL = {
    "l.": "light",
    "m.": "medium",
    "h.": "heavy",
};

Parser.WEAPON_ABV_TO_FULL = {
    "s.": "simple",
    "m.": "martial",
};

Parser.CONDITION_TO_COLOR = {
    "Blinded": "#525252",
    "Charmed": "#f01789",
    "Deafened": "#ababab",
    "Exhausted": "#947a47",
    "Frightened": "#c9ca18",
    "Grappled": "#8784a0",
    "Incapacitated": "#3165a0",
    "Invisible": "#7ad2d6",
    "Paralyzed": "#c00900",
    "Petrified": "#a0a0a0",
    "Poisoned": "#4dc200",
    "Prone": "#5e60a0",
    "Restrained": "#d98000",
    "Stunned": "#a23bcb",
    "Unconscious": "#3a40ad",

    "Concentration": "#009f7a",
};

Parser.RULE_TYPE_TO_FULL = {
    "O": "Optional",
    "P": "Prerelease",
    "V": "Variant",
    "VO": "Variant Optional",
    "VV": "Variant Variant",
    "U": "Unknown",
};

Parser.ruleTypeToFull = function(ruleType) {
    return Parser._parse_aToB(Parser.RULE_TYPE_TO_FULL, ruleType);
}
;

Parser.VEHICLE_TYPE_TO_FULL = {
    "SHIP": "Ship",
    "SPELLJAMMER": "Spelljammer Ship",
    "INFWAR": "Infernal War Machine",
    "CREATURE": "Creature",
    "OBJECT": "Object",
    "SHP:H": "Ship Upgrade, Hull",
    "SHP:M": "Ship Upgrade, Movement",
    "SHP:W": "Ship Upgrade, Weapon",
    "SHP:F": "Ship Upgrade, Figurehead",
    "SHP:O": "Ship Upgrade, Miscellaneous",
    "IWM:W": "Infernal War Machine Variant, Weapon",
    "IWM:A": "Infernal War Machine Upgrade, Armor",
    "IWM:G": "Infernal War Machine Upgrade, Gadget",
};

Parser.vehicleTypeToFull = function(vehicleType) {
    return Parser._parse_aToB(Parser.VEHICLE_TYPE_TO_FULL, vehicleType);
}
;

Parser.SRC_5ETOOLS_TMP = "Parser.SRC_5ETOOLS_TMP";
Parser.SRC_CoS = "CoS";
Parser.SRC_DMG = "DMG";
Parser.SRC_EEPC = "EEPC";
Parser.SRC_EET = "EET";
Parser.SRC_HotDQ = "HotDQ";
Parser.SRC_LMoP = "LMoP";
Parser.SRC_MM = "MM";
Parser.SRC_OotA = "OotA";
Parser.SRC_PHB = "PHB";
Parser.SRC_PotA = "PotA";
Parser.SRC_RoT = "RoT";
Parser.SRC_RoTOS = "RoTOS";
Parser.SRC_SCAG = "SCAG";
Parser.SRC_SKT = "SKT";
Parser.SRC_ToA = "ToA";
Parser.SRC_TLK = "TLK";
Parser.SRC_ToD = "ToD";
Parser.SRC_TTP = "TTP";
Parser.SRC_TYP = "TftYP";
Parser.SRC_TYP_AtG = "TftYP-AtG";
Parser.SRC_TYP_DiT = "TftYP-DiT";
Parser.SRC_TYP_TFoF = "TftYP-TFoF";
Parser.SRC_TYP_THSoT = "TftYP-THSoT";
Parser.SRC_TYP_TSC = "TftYP-TSC";
Parser.SRC_TYP_ToH = "TftYP-ToH";
Parser.SRC_TYP_WPM = "TftYP-WPM";
Parser.SRC_VGM = "VGM";
Parser.SRC_XGE = "XGE";
Parser.SRC_OGA = "OGA";
Parser.SRC_MTF = "MTF";
Parser.SRC_WDH = "WDH";
Parser.SRC_WDMM = "WDMM";
Parser.SRC_GGR = "GGR";
Parser.SRC_KKW = "KKW";
Parser.SRC_LLK = "LLK";
Parser.SRC_AZfyT = "AZfyT";
Parser.SRC_GoS = "GoS";
Parser.SRC_AI = "AI";
Parser.SRC_OoW = "OoW";
Parser.SRC_ESK = "ESK";
Parser.SRC_DIP = "DIP";
Parser.SRC_HftT = "HftT";
Parser.SRC_DC = "DC";
Parser.SRC_SLW = "SLW";
Parser.SRC_SDW = "SDW";
Parser.SRC_BGDIA = "BGDIA";
Parser.SRC_LR = "LR";
Parser.SRC_AL = "AL";
Parser.SRC_SAC = "SAC";
Parser.SRC_ERLW = "ERLW";
Parser.SRC_EFR = "EFR";
Parser.SRC_RMBRE = "RMBRE";
Parser.SRC_RMR = "RMR";
Parser.SRC_MFF = "MFF";
Parser.SRC_AWM = "AWM";
Parser.SRC_IMR = "IMR";
Parser.SRC_SADS = "SADS";
Parser.SRC_EGW = "EGW";
Parser.SRC_EGW_ToR = "ToR";
Parser.SRC_EGW_DD = "DD";
Parser.SRC_EGW_FS = "FS";
Parser.SRC_EGW_US = "US";
Parser.SRC_MOT = "MOT";
Parser.SRC_IDRotF = "IDRotF";
Parser.SRC_TCE = "TCE";
Parser.SRC_VRGR = "VRGR";
Parser.SRC_HoL = "HoL";
Parser.SRC_XMtS = "XMtS";
Parser.SRC_RtG = "RtG";
Parser.SRC_AitFR = "AitFR";
Parser.SRC_AitFR_ISF = "AitFR-ISF";
Parser.SRC_AitFR_THP = "AitFR-THP";
Parser.SRC_AitFR_AVT = "AitFR-AVT";
Parser.SRC_AitFR_DN = "AitFR-DN";
Parser.SRC_AitFR_FCD = "AitFR-FCD";
Parser.SRC_WBtW = "WBtW";
Parser.SRC_DoD = "DoD";
Parser.SRC_MaBJoV = "MaBJoV";
Parser.SRC_FTD = "FTD";
Parser.SRC_SCC = "SCC";
Parser.SRC_SCC_CK = "SCC-CK";
Parser.SRC_SCC_HfMT = "SCC-HfMT";
Parser.SRC_SCC_TMM = "SCC-TMM";
Parser.SRC_SCC_ARiR = "SCC-ARiR";
Parser.SRC_MPMM = "MPMM";
Parser.SRC_CRCotN = "CRCotN";
Parser.SRC_JttRC = "JttRC";
Parser.SRC_SAiS = "SAiS";
Parser.SRC_AAG = "AAG";
Parser.SRC_BAM = "BAM";
Parser.SRC_LoX = "LoX";
Parser.SRC_DoSI = "DoSI";
Parser.SRC_DSotDQ = "DSotDQ";
Parser.SRC_KftGV = "KftGV";
Parser.SRC_BGG = "BGG";
Parser.SRC_TDCSR = "TDCSR";
Parser.SRC_PaBTSO = "PaBTSO";
Parser.SRC_PAitM = "PAitM";
Parser.SRC_SatO = "SatO";
Parser.SRC_ToFW = "ToFW";
Parser.SRC_MPP = "MPP";
Parser.SRC_BMT = "BMT";
Parser.SRC_GHLoE = "GHLoE";
Parser.SRC_DoDk = "DoDk";
Parser.SRC_SCREEN = "Screen";
Parser.SRC_SCREEN_WILDERNESS_KIT = "ScreenWildernessKit";
Parser.SRC_SCREEN_DUNGEON_KIT = "ScreenDungeonKit";
Parser.SRC_SCREEN_SPELLJAMMER = "ScreenSpelljammer";
Parser.SRC_HF = "HF";
Parser.SRC_HFFotM = "HFFotM";
Parser.SRC_HFStCM = "HFStCM";
Parser.SRC_CM = "CM";
Parser.SRC_NRH = "NRH";
Parser.SRC_NRH_TCMC = "NRH-TCMC";
Parser.SRC_NRH_AVitW = "NRH-AVitW";
Parser.SRC_NRH_ASS = "NRH-ASS";
Parser.SRC_NRH_CoI = "NRH-CoI";
Parser.SRC_NRH_TLT = "NRH-TLT";
Parser.SRC_NRH_AWoL = "NRH-AWoL";
Parser.SRC_NRH_AT = "NRH-AT";
Parser.SRC_MGELFT = "MGELFT";
Parser.SRC_VD = "VD";
Parser.SRC_SjA = "SjA";
Parser.SRC_HAT_TG = "HAT-TG";
Parser.SRC_HAT_LMI = "HAT-LMI";
Parser.SRC_GotSF = "GotSF";
Parser.SRC_LK = "LK";
Parser.SRC_CoA = "CoA";
Parser.SRC_PiP = "PiP";

Parser.SRC_AL_PREFIX = "AL";

Parser.SRC_ALCoS = `${Parser.SRC_AL_PREFIX}CurseOfStrahd`;
Parser.SRC_ALEE = `${Parser.SRC_AL_PREFIX}ElementalEvil`;
Parser.SRC_ALRoD = `${Parser.SRC_AL_PREFIX}RageOfDemons`;

Parser.SRC_PS_PREFIX = "PS";

Parser.SRC_PSA = `${Parser.SRC_PS_PREFIX}A`;
Parser.SRC_PSI = `${Parser.SRC_PS_PREFIX}I`;
Parser.SRC_PSK = `${Parser.SRC_PS_PREFIX}K`;
Parser.SRC_PSZ = `${Parser.SRC_PS_PREFIX}Z`;
Parser.SRC_PSX = `${Parser.SRC_PS_PREFIX}X`;
Parser.SRC_PSD = `${Parser.SRC_PS_PREFIX}D`;

Parser.SRC_UA_PREFIX = "UA";
Parser.SRC_UA_ONE_PREFIX = "XUA";
Parser.SRC_MCVX_PREFIX = "MCV";
Parser.SRC_MisMVX_PREFIX = "MisMV";
Parser.SRC_AA_PREFIX = "AA";

Parser.SRC_UATMC = `${Parser.SRC_UA_PREFIX}TheMysticClass`;
Parser.SRC_MCV1SC = `${Parser.SRC_MCVX_PREFIX}1SC`;
Parser.SRC_MCV2DC = `${Parser.SRC_MCVX_PREFIX}2DC`;
Parser.SRC_MCV3MC = `${Parser.SRC_MCVX_PREFIX}3MC`;
Parser.SRC_MCV4EC = `${Parser.SRC_MCVX_PREFIX}4EC`;
Parser.SRC_MisMV1 = `${Parser.SRC_MisMVX_PREFIX}1`;
Parser.SRC_AATM = `${Parser.SRC_AA_PREFIX}TM`;

Parser.AL_PREFIX = "Adventurers League: ";
Parser.AL_PREFIX_SHORT = "AL: ";
Parser.PS_PREFIX = "Plane Shift: ";
Parser.PS_PREFIX_SHORT = "PS: ";
Parser.UA_PREFIX = "Unearthed Arcana: ";
Parser.UA_PREFIX_SHORT = "UA: ";
Parser.TftYP_NAME = "Tales from the Yawning Portal";
Parser.AitFR_NAME = "Adventures in the Forgotten Realms";
Parser.NRH_NAME = "NERDS Restoring Harmony";
Parser.MCVX_PREFIX = "Monstrous Compendium Volume ";
Parser.MisMVX_PREFIX = "Misplaced Monsters: Volume ";
Parser.AA_PREFIX = "Adventure Atlas: ";

Parser.SOURCE_JSON_TO_FULL = {};
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CoS] = "Curse of Strahd";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DMG] = "Dungeon Master's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EEPC] = "Elemental Evil Player's Companion";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EET] = "Elemental Evil: Trinkets";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HotDQ] = "Hoard of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LMoP] = "Lost Mine of Phandelver";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MM] = "Monster Manual";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OotA] = "Out of the Abyss";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PHB] = "Player's Handbook";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PotA] = "Princes of the Apocalypse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RoT] = "The Rise of Tiamat";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RoTOS] = "The Rise of Tiamat Online Supplement";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCAG] = "Sword Coast Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SKT] = "Storm King's Thunder";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToA] = "Tomb of Annihilation";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TLK] = "The Lost Kenku";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToD] = "Tyranny of Dragons";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TTP] = "The Tortle Package";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP] = Parser.TftYP_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_AtG] = `${Parser.TftYP_NAME}: Against the Giants`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_DiT] = `${Parser.TftYP_NAME}: Dead in Thay`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_TFoF] = `${Parser.TftYP_NAME}: The Forge of Fury`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_THSoT] = `${Parser.TftYP_NAME}: The Hidden Shrine of Tamoachan`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_TSC] = `${Parser.TftYP_NAME}: The Sunless Citadel`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_ToH] = `${Parser.TftYP_NAME}: Tomb of Horrors`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_WPM] = `${Parser.TftYP_NAME}: White Plume Mountain`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VGM] = "Volo's Guide to Monsters";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_XGE] = "Xanathar's Guide to Everything";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OGA] = "One Grung Above";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MTF] = "Mordenkainen's Tome of Foes";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WDH] = "Waterdeep: Dragon Heist";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WDMM] = "Waterdeep: Dungeon of the Mad Mage";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GGR] = "Guildmasters' Guide to Ravnica";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_KKW] = "Krenko's Way";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LLK] = "Lost Laboratory of Kwalish";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AZfyT] = "A Zib for your Thoughts";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GoS] = "Ghosts of Saltmarsh";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AI] = "Acquisitions Incorporated";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OoW] = "The Orrery of the Wanderer";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ESK] = "Essentials Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DIP] = "Dragon of Icespire Peak";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HftT] = "Hunt for the Thessalhydra";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DC] = "Divine Contention";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SLW] = "Storm Lord's Wrath";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SDW] = "Sleeping Dragon's Wake";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BGDIA] = "Baldur's Gate: Descent Into Avernus";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LR] = "Locathah Rising";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AL] = "Adventurers' League";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SAC] = "Sage Advice Compendium";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ERLW] = "Eberron: Rising from the Last War";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EFR] = "Eberron: Forgotten Relics";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RMBRE] = "The Lost Dungeon of Rickedness: Big Rick Energy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RMR] = "Dungeons & Dragons vs. Rick and Morty: Basic Rules";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MFF] = "Mordenkainen's Fiendish Folio";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AWM] = "Adventure with Muk";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_IMR] = "Infernal Machine Rebuild";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SADS] = "Sapphire Anniversary Dice Set";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW] = "Explorer's Guide to Wildemount";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_ToR] = "Tide of Retribution";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_DD] = "Dangerous Designs";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_FS] = "Frozen Sick";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_US] = "Unwelcome Spirits";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MOT] = "Mythic Odysseys of Theros";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_IDRotF] = "Icewind Dale: Rime of the Frostmaiden";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TCE] = "Tasha's Cauldron of Everything";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VRGR] = "Van Richten's Guide to Ravenloft";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HoL] = "The House of Lament";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RtG] = "Return to Glory";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR] = Parser.AitFR_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_ISF] = `${Parser.AitFR_NAME}: In Scarlet Flames`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_THP] = `${Parser.AitFR_NAME}: The Hidden Page`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_AVT] = `${Parser.AitFR_NAME}: A Verdant Tomb`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_DN] = `${Parser.AitFR_NAME}: Deepest Night`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_FCD] = `${Parser.AitFR_NAME}: From Cyan Depths`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WBtW] = "The Wild Beyond the Witchlight";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoD] = "Domains of Delight";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MaBJoV] = "Minsc and Boo's Journal of Villainy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_FTD] = "Fizban's Treasury of Dragons";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC] = "Strixhaven: A Curriculum of Chaos";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_CK] = "Campus Kerfuffle";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_HfMT] = "Hunt for Mage Tower";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_TMM] = "The Magister's Masquerade";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_ARiR] = "A Reckoning in Ruins";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MPMM] = "Mordenkainen Presents: Monsters of the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CRCotN] = "Critical Role: Call of the Netherdeep";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_JttRC] = "Journeys through the Radiant Citadel";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SAiS] = "Spelljammer: Adventures in Space";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AAG] = "Astral Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BAM] = "Boo's Astral Menagerie";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LoX] = "Light of Xaryxis";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoSI] = "Dragons of Stormwreck Isle";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DSotDQ] = "Dragonlance: Shadow of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_KftGV] = "Keys from the Golden Vault";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BGG] = "Bigby Presents: Glory of the Giants";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TDCSR] = "Tal'Dorei Campaign Setting Reborn";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PaBTSO] = "Phandelver and Below: The Shattered Obelisk";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PAitM] = "Planescape: Adventures in the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SatO] = "Sigil and the Outlands";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToFW] = "Turn of Fortune's Wheel";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MPP] = "Morte's Planar Parade";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BMT] = "The Book of Many Things";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GHLoE] = "Grim Hollow: Lairs of Etharis";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoDk] = "Dungeons of Drakkenheim";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN] = "Dungeon Master's Screen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_WILDERNESS_KIT] = "Dungeon Master's Screen: Wilderness Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_DUNGEON_KIT] = "Dungeon Master's Screen: Dungeon Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_SPELLJAMMER] = "Dungeon Master's Screen: Spelljammer";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HF] = "Heroes' Feast";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HFFotM] = "Heroes' Feast: Flavors of the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HFStCM] = "Heroes' Feast: Saving the Childrens Menu";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CM] = "Candlekeep Mysteries";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH] = Parser.NRH_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_TCMC] = `${Parser.NRH_NAME}: The Candy Mountain Caper`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AVitW] = `${Parser.NRH_NAME}: A Voice in the Wilderness`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_ASS] = `${Parser.NRH_NAME}: A Sticky Situation`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_CoI] = `${Parser.NRH_NAME}: Circus of Illusions`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_TLT] = `${Parser.NRH_NAME}: The Lost Tomb`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AWoL] = `${Parser.NRH_NAME}: A Web of Lies`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AT] = `${Parser.NRH_NAME}: Adventure Together`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MGELFT] = "Muk's Guide To Everything He Learned From Tasha";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VD] = "Vecna Dossier";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SjA] = "Spelljammer Academy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HAT_TG] = "Honor Among Thieves: Thieves' Gallery";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HAT_LMI] = "Honor Among Thieves: Legendary Magic Items";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GotSF] = "Giants of the Star Forge";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LK] = "Lightning Keep";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CoA] = "Chains of Asmodeus";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PiP] = "Peril in Pinebrook";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALCoS] = `${Parser.AL_PREFIX}Curse of Strahd`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALEE] = `${Parser.AL_PREFIX}Elemental Evil`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALRoD] = `${Parser.AL_PREFIX}Rage of Demons`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSA] = `${Parser.PS_PREFIX}Amonkhet`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSI] = `${Parser.PS_PREFIX}Innistrad`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSK] = `${Parser.PS_PREFIX}Kaladesh`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSZ] = `${Parser.PS_PREFIX}Zendikar`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSX] = `${Parser.PS_PREFIX}Ixalan`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSD] = `${Parser.PS_PREFIX}Dominaria`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_XMtS] = `X Marks the Spot`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATMC] = `${Parser.UA_PREFIX}The Mystic Class`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV1SC] = `${Parser.MCVX_PREFIX}1: Spelljammer Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV2DC] = `${Parser.MCVX_PREFIX}2: Dragonlance Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV3MC] = `${Parser.MCVX_PREFIX}3: Minecraft Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV4EC] = `${Parser.MCVX_PREFIX}4: Eldraine Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MisMV1] = `${Parser.MisMVX_PREFIX}1`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AATM] = `${Parser.AA_PREFIX}The Mortuary`;

Parser.SOURCE_JSON_TO_ABV = {};
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CoS] = "CoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DMG] = "DMG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EEPC] = "EEPC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EET] = "EET";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HotDQ] = "HotDQ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LMoP] = "LMoP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MM] = "MM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OotA] = "OotA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PHB] = "PHB";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PotA] = "PotA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RoT] = "RoT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RoTOS] = "RoTOS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCAG] = "SCAG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SKT] = "SKT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToA] = "ToA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TLK] = "TLK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToD] = "ToD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TTP] = "TTP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_AtG] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_DiT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_TFoF] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_THSoT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_TSC] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_ToH] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_WPM] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VGM] = "VGM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_XGE] = "XGE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OGA] = "OGA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MTF] = "MTF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WDH] = "WDH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WDMM] = "WDMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GGR] = "GGR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_KKW] = "KKW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LLK] = "LLK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AZfyT] = "AZfyT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GoS] = "GoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AI] = "AI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OoW] = "OoW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ESK] = "ESK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DIP] = "DIP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HftT] = "HftT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DC] = "DC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SLW] = "SLW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SDW] = "SDW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BGDIA] = "BGDIA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LR] = "LR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AL] = "AL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SAC] = "SAC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ERLW] = "ERLW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EFR] = "EFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RMBRE] = "RMBRE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RMR] = "RMR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MFF] = "MFF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AWM] = "AWM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_IMR] = "IMR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SADS] = "SADS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW] = "EGW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_ToR] = "ToR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_DD] = "DD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_FS] = "FS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_US] = "US";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MOT] = "MOT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_IDRotF] = "IDRotF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TCE] = "TCE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VRGR] = "VRGR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HoL] = "HoL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RtG] = "RtG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR] = "AitFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_ISF] = "AitFR-ISF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_THP] = "AitFR-THP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_AVT] = "AitFR-AVT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_DN] = "AitFR-DN";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_FCD] = "AitFR-FCD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WBtW] = "WBtW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoD] = "DoD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MaBJoV] = "MaBJoV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_FTD] = "FTD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC] = "SCC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_CK] = "SCC-CK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_HfMT] = "SCC-HfMT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_TMM] = "SCC-TMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_ARiR] = "SCC-ARiR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MPMM] = "MPMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CRCotN] = "CRCotN";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_JttRC] = "JttRC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SAiS] = "SAiS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AAG] = "AAG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BAM] = "BAM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LoX] = "LoX";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoSI] = "DoSI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DSotDQ] = "DSotDQ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_KftGV] = "KftGV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BGG] = "BGG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TDCSR] = "TDCSR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PaBTSO] = "PaBTSO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PAitM] = "PAitM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SatO] = "SatO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToFW] = "ToFW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MPP] = "MPP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BMT] = "BMT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GHLoE] = "GHLoE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoDk] = "DoDk";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN] = "Screen";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_WILDERNESS_KIT] = "ScWild";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_DUNGEON_KIT] = "ScDun";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_SPELLJAMMER] = "ScSJ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HF] = "HF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HFFotM] = "HFFotM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HFStCM] = "HFStCM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CM] = "CM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH] = "NRH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_TCMC] = "NRH-TCMC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AVitW] = "NRH-AVitW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_ASS] = "NRH-ASS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_CoI] = "NRH-CoI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_TLT] = "NRH-TLT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AWoL] = "NRH-AWoL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AT] = "NRH-AT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MGELFT] = "MGELFT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VD] = "VD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SjA] = "SjA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HAT_TG] = "HAT-TG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HAT_LMI] = "HAT-LMI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GotSF] = "GotSF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LK] = "LK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CoA] = "CoA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PiP] = "PiP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALCoS] = "ALCoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALEE] = "ALEE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALRoD] = "ALRoD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSA] = "PSA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSI] = "PSI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSK] = "PSK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSZ] = "PSZ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSX] = "PSX";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSD] = "PSD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_XMtS] = "XMtS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATMC] = "UAMy";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV1SC] = "MCV1SC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV2DC] = "MCV2DC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV3MC] = "MCV3MC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV4EC] = "MCV4EC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MisMV1] = "MisMV1";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AATM] = "AATM";

Parser.SOURCE_JSON_TO_DATE = {};
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DMG] = "2014-12-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EEPC] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EET] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HotDQ] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LMoP] = "2014-07-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MM] = "2014-09-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OotA] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PHB] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PotA] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RoT] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RoTOS] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCAG] = "2015-11-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SKT] = "2016-09-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToA] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TLK] = "2017-11-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToD] = "2019-10-22";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TTP] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_AtG] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_DiT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_TFoF] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_THSoT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_TSC] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_ToH] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_WPM] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VGM] = "2016-11-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_XGE] = "2017-11-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OGA] = "2017-10-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MTF] = "2018-05-29";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WDH] = "2018-09-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WDMM] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GGR] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_KKW] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LLK] = "2018-11-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AZfyT] = "2019-03-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GoS] = "2019-05-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AI] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OoW] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ESK] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DIP] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HftT] = "2019-05-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DC] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SLW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SDW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BGDIA] = "2019-09-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LR] = "2019-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SAC] = "2019-01-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ERLW] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EFR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RMBRE] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RMR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MFF] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AWM] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_IMR] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SADS] = "2019-12-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_ToR] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_DD] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_FS] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_US] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MOT] = "2020-06-02";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_IDRotF] = "2020-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TCE] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VRGR] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HoL] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RtG] = "2021-05-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_ISF] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_THP] = "2021-07-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_AVT] = "2021-07-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_DN] = "2021-07-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_FCD] = "2021-07-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WBtW] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoD] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MaBJoV] = "2021-10-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_FTD] = "2021-11-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_CK] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_HfMT] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_TMM] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_ARiR] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MPMM] = "2022-01-25";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CRCotN] = "2022-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_JttRC] = "2022-07-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SAiS] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AAG] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BAM] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LoX] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoSI] = "2022-07-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DSotDQ] = "2022-11-22";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_KftGV] = "2023-02-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BGG] = "2023-08-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TDCSR] = "2022-01-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PaBTSO] = "2023-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PAitM] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SatO] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToFW] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MPP] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BMT] = "2023-11-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GHLoE] = "2023-11-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoDk] = "2023-12-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN] = "2015-01-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_WILDERNESS_KIT] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_DUNGEON_KIT] = "2020-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_SPELLJAMMER] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HF] = "2020-10-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HFFotM] = "2023-11-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HFStCM] = "2023-11-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CM] = "2021-03-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_TCMC] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AVitW] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_ASS] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_CoI] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_TLT] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AWoL] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AT] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MGELFT] = "2020-12-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VD] = "2022-06-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SjA] = "2022-07-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HAT_TG] = "2023-03-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HAT_LMI] = "2023-03-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GotSF] = "2023-08-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LK] = "2023-09-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CoA] = "2023-10-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PiP] = "2023-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALCoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALEE] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALRoD] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSA] = "2017-07-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSI] = "2016-07-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSK] = "2017-02-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSZ] = "2016-04-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSX] = "2018-01-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSD] = "2018-07-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_XMtS] = "2017-12-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATMC] = "2017-03-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV1SC] = "2022-04-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV2DC] = "2022-12-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV3MC] = "2023-03-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV4EC] = "2023-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MisMV1] = "2023-05-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AATM] = "2023-10-17";

Parser.SOURCES_ADVENTURES = new Set([Parser.SRC_LMoP, Parser.SRC_HotDQ, Parser.SRC_RoT, Parser.SRC_RoTOS, Parser.SRC_PotA, Parser.SRC_OotA, Parser.SRC_CoS, Parser.SRC_SKT, Parser.SRC_TYP, Parser.SRC_TYP_AtG, Parser.SRC_TYP_DiT, Parser.SRC_TYP_TFoF, Parser.SRC_TYP_THSoT, Parser.SRC_TYP_TSC, Parser.SRC_TYP_ToH, Parser.SRC_TYP_WPM, Parser.SRC_ToA, Parser.SRC_TLK, Parser.SRC_TTP, Parser.SRC_WDH, Parser.SRC_LLK, Parser.SRC_WDMM, Parser.SRC_KKW, Parser.SRC_AZfyT, Parser.SRC_GoS, Parser.SRC_HftT, Parser.SRC_OoW, Parser.SRC_DIP, Parser.SRC_SLW, Parser.SRC_SDW, Parser.SRC_DC, Parser.SRC_BGDIA, Parser.SRC_LR, Parser.SRC_EFR, Parser.SRC_RMBRE, Parser.SRC_IMR, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US, Parser.SRC_IDRotF, Parser.SRC_CM, Parser.SRC_HoL, Parser.SRC_XMtS, Parser.SRC_RtG, Parser.SRC_AitFR, Parser.SRC_AitFR_ISF, Parser.SRC_AitFR_THP, Parser.SRC_AitFR_AVT, Parser.SRC_AitFR_DN, Parser.SRC_AitFR_FCD, Parser.SRC_WBtW, Parser.SRC_NRH, Parser.SRC_NRH_TCMC, Parser.SRC_NRH_AVitW, Parser.SRC_NRH_ASS, Parser.SRC_NRH_CoI, Parser.SRC_NRH_TLT, Parser.SRC_NRH_AWoL, Parser.SRC_NRH_AT, Parser.SRC_SCC, Parser.SRC_SCC_CK, Parser.SRC_SCC_HfMT, Parser.SRC_SCC_TMM, Parser.SRC_SCC_ARiR, Parser.SRC_CRCotN, Parser.SRC_JttRC, Parser.SRC_SjA, Parser.SRC_LoX, Parser.SRC_DoSI, Parser.SRC_DSotDQ, Parser.SRC_KftGV, Parser.SRC_GotSF, Parser.SRC_PaBTSO, Parser.SRC_LK, Parser.SRC_CoA, Parser.SRC_PiP, Parser.SRC_HFStCM, Parser.SRC_GHLoE, Parser.SRC_DoDk,
Parser.SRC_AWM, ]);
Parser.SOURCES_CORE_SUPPLEMENTS = new Set(Object.keys(Parser.SOURCE_JSON_TO_FULL).filter(it=>!Parser.SOURCES_ADVENTURES.has(it)));
Parser.SOURCES_NON_STANDARD_WOTC = new Set([Parser.SRC_OGA, Parser.SRC_LLK, Parser.SRC_AZfyT, Parser.SRC_LR, Parser.SRC_TLK, Parser.SRC_TTP, Parser.SRC_AWM, Parser.SRC_IMR, Parser.SRC_SADS, Parser.SRC_MFF, Parser.SRC_XMtS, Parser.SRC_RtG, Parser.SRC_AitFR, Parser.SRC_AitFR_ISF, Parser.SRC_AitFR_THP, Parser.SRC_AitFR_AVT, Parser.SRC_AitFR_DN, Parser.SRC_AitFR_FCD, Parser.SRC_DoD, Parser.SRC_MaBJoV, Parser.SRC_NRH, Parser.SRC_NRH_TCMC, Parser.SRC_NRH_AVitW, Parser.SRC_NRH_ASS, Parser.SRC_NRH_CoI, Parser.SRC_NRH_TLT, Parser.SRC_NRH_AWoL, Parser.SRC_NRH_AT, Parser.SRC_MGELFT, Parser.SRC_VD, Parser.SRC_SjA, Parser.SRC_HAT_TG, Parser.SRC_HAT_LMI, Parser.SRC_GotSF, Parser.SRC_MCV3MC, Parser.SRC_MCV4EC, Parser.SRC_MisMV1, Parser.SRC_LK, Parser.SRC_AATM, Parser.SRC_CoA, Parser.SRC_PiP, Parser.SRC_HFStCM, ]);
Parser.SOURCES_PARTNERED_WOTC = new Set([Parser.SRC_RMBRE, Parser.SRC_RMR, Parser.SRC_EGW, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US, Parser.SRC_CRCotN, Parser.SRC_TDCSR, Parser.SRC_HftT, Parser.SRC_GHLoE, Parser.SRC_DoDk, ]);

Parser.SOURCES_VANILLA = new Set([Parser.SRC_DMG, Parser.SRC_MM, Parser.SRC_PHB, Parser.SRC_SCAG, Parser.SRC_XGE, Parser.SRC_SAC, Parser.SRC_MFF, Parser.SRC_SADS, Parser.SRC_TCE, Parser.SRC_FTD, Parser.SRC_MPMM, Parser.SRC_SCREEN, Parser.SRC_SCREEN_WILDERNESS_KIT, Parser.SRC_SCREEN_DUNGEON_KIT, Parser.SRC_VD, Parser.SRC_GotSF, Parser.SRC_BGG, Parser.SRC_MaBJoV, Parser.SRC_CoA, Parser.SRC_BMT, ]);

Parser.SOURCES_COMEDY = new Set([Parser.SRC_AI, Parser.SRC_OoW, Parser.SRC_RMR, Parser.SRC_RMBRE, Parser.SRC_HftT, Parser.SRC_AWM, Parser.SRC_MGELFT, Parser.SRC_HAT_TG, Parser.SRC_HAT_LMI, Parser.SRC_MCV3MC, Parser.SRC_MisMV1, Parser.SRC_LK, Parser.SRC_PiP, ]);

Parser.SOURCES_NON_FR = new Set([Parser.SRC_GGR, Parser.SRC_KKW, Parser.SRC_ERLW, Parser.SRC_EFR, Parser.SRC_EGW, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US, Parser.SRC_MOT, Parser.SRC_XMtS, Parser.SRC_AZfyT, Parser.SRC_SCC, Parser.SRC_SCC_CK, Parser.SRC_SCC_HfMT, Parser.SRC_SCC_TMM, Parser.SRC_SCC_ARiR, Parser.SRC_CRCotN, Parser.SRC_SjA, Parser.SRC_SAiS, Parser.SRC_AAG, Parser.SRC_BAM, Parser.SRC_LoX, Parser.SRC_DSotDQ, Parser.SRC_TDCSR, Parser.SRC_PAitM, Parser.SRC_SatO, Parser.SRC_ToFW, Parser.SRC_MPP, Parser.SRC_MCV4EC, Parser.SRC_LK, Parser.SRC_GHLoE, Parser.SRC_DoDk, ]);

Parser.SOURCES_AVAILABLE_DOCS_BOOK = {};
[Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG, Parser.SRC_SCAG, Parser.SRC_VGM, Parser.SRC_OGA, Parser.SRC_XGE, Parser.SRC_MTF, Parser.SRC_GGR, Parser.SRC_AI, Parser.SRC_ERLW, Parser.SRC_RMR, Parser.SRC_EGW, Parser.SRC_MOT, Parser.SRC_TCE, Parser.SRC_VRGR, Parser.SRC_DoD, Parser.SRC_MaBJoV, Parser.SRC_FTD, Parser.SRC_SCC, Parser.SRC_MPMM, Parser.SRC_AAG, Parser.SRC_BAM, Parser.SRC_HAT_TG, Parser.SRC_SCREEN, Parser.SRC_SCREEN_WILDERNESS_KIT, Parser.SRC_SCREEN_DUNGEON_KIT, Parser.SRC_SCREEN_SPELLJAMMER, Parser.SRC_BGG, Parser.SRC_TDCSR, Parser.SRC_SatO, Parser.SRC_MPP, Parser.SRC_HF, Parser.SRC_HFFotM, Parser.SRC_BMT, ].forEach(src=>{
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = src;
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = src;
}
);
[{
    src: Parser.SRC_PSA,
    id: "PS-A"
}, {
    src: Parser.SRC_PSI,
    id: "PS-I"
}, {
    src: Parser.SRC_PSK,
    id: "PS-K"
}, {
    src: Parser.SRC_PSZ,
    id: "PS-Z"
}, {
    src: Parser.SRC_PSX,
    id: "PS-X"
}, {
    src: Parser.SRC_PSD,
    id: "PS-D"
}, ].forEach(({src, id})=>{
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = id;
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = id;
}
);
Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE = {};
[Parser.SRC_LMoP, Parser.SRC_HotDQ, Parser.SRC_RoT, Parser.SRC_PotA, Parser.SRC_OotA, Parser.SRC_CoS, Parser.SRC_SKT, Parser.SRC_TYP_AtG, Parser.SRC_TYP_DiT, Parser.SRC_TYP_TFoF, Parser.SRC_TYP_THSoT, Parser.SRC_TYP_TSC, Parser.SRC_TYP_ToH, Parser.SRC_TYP_WPM, Parser.SRC_ToA, Parser.SRC_TLK, Parser.SRC_TTP, Parser.SRC_WDH, Parser.SRC_LLK, Parser.SRC_WDMM, Parser.SRC_KKW, Parser.SRC_AZfyT, Parser.SRC_GoS, Parser.SRC_HftT, Parser.SRC_OoW, Parser.SRC_DIP, Parser.SRC_SLW, Parser.SRC_SDW, Parser.SRC_DC, Parser.SRC_BGDIA, Parser.SRC_LR, Parser.SRC_EFR, Parser.SRC_RMBRE, Parser.SRC_IMR, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US, Parser.SRC_IDRotF, Parser.SRC_CM, Parser.SRC_HoL, Parser.SRC_XMtS, Parser.SRC_RtG, Parser.SRC_AitFR_ISF, Parser.SRC_AitFR_THP, Parser.SRC_AitFR_AVT, Parser.SRC_AitFR_DN, Parser.SRC_AitFR_FCD, Parser.SRC_WBtW, Parser.SRC_NRH, Parser.SRC_NRH_TCMC, Parser.SRC_NRH_AVitW, Parser.SRC_NRH_ASS, Parser.SRC_NRH_CoI, Parser.SRC_NRH_TLT, Parser.SRC_NRH_AWoL, Parser.SRC_NRH_AT, Parser.SRC_SCC_CK, Parser.SRC_SCC_HfMT, Parser.SRC_SCC_TMM, Parser.SRC_SCC_ARiR, Parser.SRC_CRCotN, Parser.SRC_JttRC, Parser.SRC_LoX, Parser.SRC_DoSI, Parser.SRC_DSotDQ, Parser.SRC_KftGV, Parser.SRC_GotSF, Parser.SRC_PaBTSO, Parser.SRC_ToFW, Parser.SRC_LK, Parser.SRC_CoA, Parser.SRC_PiP, Parser.SRC_HFStCM, Parser.SRC_GHLoE, Parser.SRC_DoDk, ].forEach(src=>{
    Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src] = src;
    Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src.toLowerCase()] = src;
}
);

Parser.getTagSource = function(tag, source) {
    if (source && source.trim())
        return source;

    tag = tag.trim();

    const tagMeta = Renderer.tag.TAG_LOOKUP[tag];

    if (!tagMeta)
        throw new Error(`Unhandled tag "${tag}"`);
    return tagMeta.defaultSource;
}
;

Parser.PROP_TO_TAG = {
    "monster": "creature",
    "optionalfeature": "optfeature",
    "tableGroup": "table",
    "vehicleUpgrade": "vehupgrade",
    "baseitem": "item",
    "itemGroup": "item",
    "magicvariant": "item",
};
Parser.getPropTag = function(prop) {
    if (Parser.PROP_TO_TAG[prop])
        return Parser.PROP_TO_TAG[prop];
    return prop;
}
;

Parser.PROP_TO_DISPLAY_NAME = {
    "variantrule": "Variant Rule",
    "optionalfeature": "Option/Feature",
    "magicvariant": "Magic Item Variant",
    "baseitem": "Item (Base)",
    "item": "Item",
    "adventure": "Adventure",
    "adventureData": "Adventure Text",
    "book": "Book",
    "bookData": "Book Text",
    "makebrewCreatureTrait": "Homebrew Builder Creature Trait",
    "charoption": "Other Character Creation Option",

    "bonus": "Bonus Action",
    "legendary": "Legendary Action",
    "mythic": "Mythic Action",
    "lairActions": "Lair Action",
    "regionalEffects": "Regional Effect",
};
Parser.getPropDisplayName = function(prop, {suffix=""}={}) {
    if (Parser.PROP_TO_DISPLAY_NAME[prop])
        return `${Parser.PROP_TO_DISPLAY_NAME[prop]}${suffix}`;

    const mFluff = /Fluff$/.exec(prop);
    if (mFluff)
        return Parser.getPropDisplayName(prop.slice(0, -mFluff[0].length), {
            suffix: " Fluff"
        });

    const mFoundry = /^foundry(?<prop>[A-Z].*)$/.exec(prop);
    if (mFoundry)
        return Parser.getPropDisplayName(mFoundry.groups.prop.lowercaseFirst(), {
            suffix: " Foundry Data"
        });

    return `${prop.split(/([A-Z][a-z]+)/g).filter(Boolean).join(" ").uppercaseFirst()}${suffix}`;
}
;

Parser.ITEM_TYPE_JSON_TO_ABV = {
    "A": "ammunition",
    "AF": "ammunition",
    "AT": "artisan's tools",
    "EM": "eldritch machine",
    "EXP": "explosive",
    "FD": "food and drink",
    "G": "adventuring gear",
    "GS": "gaming set",
    "HA": "heavy armor",
    "IDG": "illegal drug",
    "INS": "instrument",
    "LA": "light armor",
    "M": "melee weapon",
    "MA": "medium armor",
    "MNT": "mount",
    "MR": "master rune",
    "GV": "generic variant",
    "P": "potion",
    "R": "ranged weapon",
    "RD": "rod",
    "RG": "ring",
    "S": "shield",
    "SC": "scroll",
    "SCF": "spellcasting focus",
    "OTH": "other",
    "T": "tools",
    "TAH": "tack and harness",
    "TG": "trade good",
    "$": "treasure",
    "VEH": "vehicle (land)",
    "SHP": "vehicle (water)",
    "AIR": "vehicle (air)",
    "SPC": "vehicle (space)",
    "WD": "wand",
};

Parser.DMGTYPE_JSON_TO_FULL = {
    "A": "acid",
    "B": "bludgeoning",
    "C": "cold",
    "F": "fire",
    "O": "force",
    "L": "lightning",
    "N": "necrotic",
    "P": "piercing",
    "I": "poison",
    "Y": "psychic",
    "R": "radiant",
    "S": "slashing",
    "T": "thunder",
};

Parser.DMG_TYPES = ["acid", "bludgeoning", "cold", "fire", "force", "lightning", "necrotic", "piercing", "poison", "psychic", "radiant", "slashing", "thunder"];
Parser.CONDITIONS = ["blinded", "charmed", "deafened", "exhaustion", "frightened", "grappled", "incapacitated", "invisible", "paralyzed", "petrified", "poisoned", "prone", "restrained", "stunned", "unconscious"];

Parser.SENSES = [{
    "name": "blindsight",
    "source": Parser.SRC_PHB
}, {
    "name": "darkvision",
    "source": Parser.SRC_PHB
}, {
    "name": "tremorsense",
    "source": Parser.SRC_MM
}, {
    "name": "truesight",
    "source": Parser.SRC_PHB
}, ];

Parser.NUMBERS_ONES = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
Parser.NUMBERS_TENS = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];
Parser.NUMBERS_TEENS = ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"];

Parser.metric = {
    MILES_TO_KILOMETRES: 1.6,
    FEET_TO_METRES: 0.3,
    YARDS_TO_METRES: 0.9,
    POUNDS_TO_KILOGRAMS: 0.5,
    getMetricNumber({originalValue, originalUnit, toFixed=null}) {
        if (originalValue == null || isNaN(originalValue))
            return originalValue;

        originalValue = Number(originalValue);
        if (!originalValue)
            return originalValue;

        let out = null;
        switch (originalUnit) {
        case "ft.":
        case "ft":
        case Parser.UNT_FEET:
            out = originalValue * Parser.metric.FEET_TO_METRES;
            break;
        case "yd.":
        case "yd":
        case Parser.UNT_YARDS:
            out = originalValue * Parser.metric.YARDS_TO_METRES;
            break;
        case "mi.":
        case "mi":
        case Parser.UNT_MILES:
            out = originalValue * Parser.metric.MILES_TO_KILOMETRES;
            break;
        case "lb.":
        case "lb":
        case "lbs":
            out = originalValue * Parser.metric.POUNDS_TO_KILOGRAMS;
            break;
        default:
            return originalValue;
        }
        if (toFixed != null)
            return NumberUtil.toFixedNumber(out, toFixed);
        return out;
    },

    getMetricUnit({originalUnit, isShortForm=false, isPlural=true}) {
        switch (originalUnit) {
        case "ft.":
        case "ft":
        case Parser.UNT_FEET:
            return isShortForm ? "m" : `meter`[isPlural ? "toPlural" : "toString"]();
        case "yd.":
        case "yd":
        case Parser.UNT_YARDS:
            return isShortForm ? "m" : `meter`[isPlural ? "toPlural" : "toString"]();
        case "mi.":
        case "mi":
        case Parser.UNT_MILES:
            return isShortForm ? "km" : `kilometre`[isPlural ? "toPlural" : "toString"]();
        case "lb.":
        case "lb":
        case "lbs":
            return isShortForm ? "kg" : `kilogram`[isPlural ? "toPlural" : "toString"]();
        default:
            return originalUnit;
        }
    },
};

Parser.MAP_GRID_TYPE_TO_FULL = {};
Parser.MAP_GRID_TYPE_TO_FULL["none"] = "None";
Parser.MAP_GRID_TYPE_TO_FULL["square"] = "Square";
Parser.MAP_GRID_TYPE_TO_FULL["hexRowsOdd"] = "Hex Rows (Odd)";
Parser.MAP_GRID_TYPE_TO_FULL["hexRowsEven"] = "Hex Rows (Even)";
Parser.MAP_GRID_TYPE_TO_FULL["hexColsOdd"] = "Hex Columns (Odd)";
Parser.MAP_GRID_TYPE_TO_FULL["hexColsEven"] = "Hex Columns (Even)";

Parser.mapGridTypeToFull = function(gridType) {
    return Parser._parse_aToB(Parser.MAP_GRID_TYPE_TO_FULL, gridType);
}
;
//#endregion
//#region SortUtil
class SortUtil {
    static ascSort(a, b) {
        if (b === a)
            return 0;
        return b < a ? 1 : -1;
    }

    static ascSortLower(a, b) {
        return SortUtil.ascSort((a || "").toLowerCase(), (b || "").toLowerCase())
    }
}
;
//#endregion
//#region UtilActors

//#endregion
//#region VeCt
globalThis.IS_DEPLOYED = undefined;
globalThis.VERSION_NUMBER = "1.197.0";
globalThis.DEPLOYED_STATIC_ROOT = "";
globalThis.DEPLOYED_IMG_ROOT = undefined;
globalThis.IS_VTT = false;

globalThis.IMGUR_CLIENT_ID = `abdea4de492d3b0`;

globalThis.HASH_PART_SEP = ",";
globalThis.HASH_LIST_SEP = "_";
globalThis.HASH_SUB_LIST_SEP = "~";
globalThis.HASH_SUB_KV_SEP = ":";
globalThis.HASH_BLANK = "blankhash";
globalThis.HASH_SUB_NONE = "null";
globalThis.VeCt = {
    STR_NONE: "None",
    STR_SEE_CONSOLE: "See the console (CTRL+SHIFT+J) for details.",

    HASH_SCALED: "scaled",
    HASH_SCALED_SPELL_SUMMON: "scaledspellsummon",
    HASH_SCALED_CLASS_SUMMON: "scaledclasssummon",

    FILTER_BOX_SUB_HASH_SEARCH_PREFIX: "fbsr",

    JSON_PRERELEASE_INDEX: `prerelease/index.json`,
    JSON_BREW_INDEX: `homebrew/index.json`,

    STORAGE_HOMEBREW: "HOMEBREW_STORAGE",
    STORAGE_HOMEBREW_META: "HOMEBREW_META_STORAGE",
    STORAGE_EXCLUDES: "EXCLUDES_STORAGE",
    STORAGE_DMSCREEN: "DMSCREEN_STORAGE",
    STORAGE_DMSCREEN_TEMP_SUBLIST: "DMSCREEN_TEMP_SUBLIST",
    STORAGE_ROLLER_MACRO: "ROLLER_MACRO_STORAGE",
    STORAGE_ENCOUNTER: "ENCOUNTER_STORAGE",
    STORAGE_POINTBUY: "POINTBUY_STORAGE",
    STORAGE_GLOBAL_COMPONENT_STATE: "GLOBAL_COMPONENT_STATE",

    DUR_INLINE_NOTIFY: 500,

    PG_NONE: "NO_PAGE",
    STR_GENERIC: "Generic",

    SYM_UI_SKIP: Symbol("uiSkip"),

    SYM_WALKER_BREAK: Symbol("walkerBreak"),

    SYM_UTIL_TIMEOUT: Symbol("timeout"),

    LOC_ORIGIN_CANCER: "https://5e.tools",

    URL_BREW: `https://github.com/TheGiddyLimit/homebrew`,
    URL_ROOT_BREW: `https://raw.githubusercontent.com/TheGiddyLimit/homebrew/master/`,
    URL_PRERELEASE: `https://github.com/TheGiddyLimit/unearthed-arcana`,
    URL_ROOT_PRERELEASE: `https://raw.githubusercontent.com/TheGiddyLimit/unearthed-arcana/master/`,
    STR_NO_ATTUNEMENT: "No Attunement Required",

    CR_UNKNOWN: 100001,
    CR_CUSTOM: 100000,

    SPELL_LEVEL_MAX: 9,
    LEVEL_MAX: 20,

    ENTDATA_TABLE_INCLUDE: "tableInclude",
    ENTDATA_ITEM_MERGED_ENTRY_TAG: "item__mergedEntryTag",

    DRAG_TYPE_IMPORT: "ve-Import",
    DRAG_TYPE_LOOT: "ve-Loot",

    Z_INDEX_BENEATH_HOVER: 199,
};
//#endregion

//#region UrlUtil
globalThis.UrlUtil = {
    encodeForHash(toEncode) {
        if (toEncode instanceof Array)
            return toEncode.map(it=>`${it}`.toUrlified()).join(HASH_LIST_SEP);
        else
            return `${toEncode}`.toUrlified();
    },

    encodeArrayForHash(...toEncodes) {
        return toEncodes.map(UrlUtil.encodeForHash).join(HASH_LIST_SEP);
    },

    autoEncodeHash(obj) {
        const curPage = UrlUtil.getCurrentPage();
        const encoder = UrlUtil.URL_TO_HASH_BUILDER[curPage];
        if (!encoder)
            throw new Error(`No encoder found for page ${curPage}`);
        return encoder(obj);
    },

    decodeHash(hash) {
        return hash.split(HASH_LIST_SEP).map(it=>decodeURIComponent(it));
    },

    getSluggedHash(hash) {
        return Parser.stringToSlug(decodeURIComponent(hash)).replace(/_/g, "-");
    },

    getCurrentPage() {
        if (typeof window === "undefined")
            return VeCt.PG_NONE;
        const pSplit = window.location.pathname.split("/");
        let out = pSplit[pSplit.length - 1];
        if (!out.toLowerCase().endsWith(".html"))
            out += ".html";
        return out;
    },

    link(href, {isBustCache=false}={}) {
        if (isBustCache)
            return UrlUtil._link_getWithParam(href, {
                param: `t=${Date.now()}`
            });
        return href;
    },

    _link_getWithParam(href, {param=`v=${VERSION_NUMBER}`}={}) {
        if (href.includes("?"))
            return `${href}&${param}`;
        return `${href}?${param}`;
    },

    unpackSubHash(subHash, unencode) {
        if (subHash.includes(HASH_SUB_KV_SEP)) {
            const keyValArr = subHash.split(HASH_SUB_KV_SEP).map(s=>s.trim());
            const out = {};
            let k = keyValArr[0].toLowerCase();
            if (unencode)
                k = decodeURIComponent(k);
            let v = keyValArr[1].toLowerCase();
            if (unencode)
                v = decodeURIComponent(v);
            out[k] = v.split(HASH_SUB_LIST_SEP).map(s=>s.trim());
            if (out[k].length === 1 && out[k] === HASH_SUB_NONE)
                out[k] = [];
            return out;
        } else {
            throw new Error(`Badly formatted subhash ${subHash}`);
        }
    },

    packSubHash(key, values, opts) {
        opts = opts || {};
        if (opts.isEncodeBoth || opts.isEncodeKey)
            key = key.toUrlified();
        if (opts.isEncodeBoth || opts.isEncodeValues)
            values = values.map(it=>it.toUrlified());
        return `${key}${HASH_SUB_KV_SEP}${values.join(HASH_SUB_LIST_SEP)}`;
    },

    categoryToPage(category) {
        return UrlUtil.CAT_TO_PAGE[category];
    },
    categoryToHoverPage(category) {
        return UrlUtil.CAT_TO_HOVER_PAGE[category] || UrlUtil.categoryToPage(category);
    },

    pageToDisplayPage(page) {
        return UrlUtil.PG_TO_NAME[page] || page;
    },

    getFilename(url) {
        return url.slice(url.lastIndexOf("/") + 1);
    },

    isFullUrl(url) {
        return url && /^.*?:\/\//.test(url);
    },

    mini: {
        compress(primitive) {
            const type = typeof primitive;
            if (primitive === undefined)
                return "u";
            if (primitive === null)
                return "x";
            switch (type) {
            case "boolean":
                return `b${Number(primitive)}`;
            case "number":
                return `n${primitive}`;
            case "string":
                return `s${primitive.toUrlified()}`;
            default:
                throw new Error(`Unhandled type "${type}"`);
            }
        },

        decompress(raw) {
            const [type,data] = [raw.slice(0, 1), raw.slice(1)];
            switch (type) {
            case "u":
                return undefined;
            case "x":
                return null;
            case "b":
                return !!Number(data);
            case "n":
                return Number(data);
            case "s":
                return decodeURIComponent(String(data));
            default:
                throw new Error(`Unhandled type "${type}"`);
            }
        },
    },

    class: {
        getIndexedClassEntries(cls) {
            const out = [];

            (cls.classFeatures || []).forEach((lvlFeatureList,ixLvl)=>{
                lvlFeatureList.filter(feature=>(!feature.gainSubclassFeature || feature.gainSubclassFeatureHasContent) && feature.name !== "Ability Score Improvement" && feature.name !== "Proficiency Versatility").forEach((feature,ixFeature)=>{
                    const name = Renderer.findName(feature);
                    if (!name) {
                        if (BrewUtil2.hasSourceJson(cls.source))
                            return;
                        else
                            throw new Error("Class feature had no name!");
                    }
                    out.push({
                        _type: "classFeature",
                        source: cls.source.source || cls.source,
                        name,
                        hash: `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](cls)}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                            feature: {
                                ixLevel: ixLvl,
                                ixFeature: ixFeature
                            }
                        })}`,
                        entry: feature,
                        level: ixLvl + 1,
                    });
                }
                );
            }
            );

            return out;
        },

        getIndexedSubclassEntries(sc) {
            const out = [];

            const lvlFeatures = sc.subclassFeatures || [];
            sc.source = sc.source || sc.classSource;
            lvlFeatures.forEach(lvlFeature=>{
                lvlFeature.forEach((feature,ixFeature)=>{
                    const subclassFeatureHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
                        name: sc.className,
                        source: sc.classSource
                    })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                        subclass: sc,
                        feature: {
                            ixLevel: feature.level - 1,
                            ixFeature: ixFeature
                        }
                    })}`;

                    const name = Renderer.findName(feature);
                    if (!name) {
                        if (BrewUtil2.hasSourceJson(sc.source))
                            return;
                        else
                            throw new Error("Subclass feature had no name!");
                    }
                    out.push({
                        _type: "subclassFeature",
                        name,
                        subclassName: sc.name,
                        subclassShortName: sc.shortName,
                        source: sc.source.source || sc.source,
                        hash: subclassFeatureHash,
                        entry: feature,
                        level: feature.level,
                    });

                    if (feature.entries) {
                        const namedFeatureParts = feature.entries.filter(it=>it.name);
                        namedFeatureParts.forEach(it=>{
                            if (out.find(existing=>it.name === existing.name && feature.level === existing.level))
                                return;
                            out.push({
                                _type: "subclassFeaturePart",
                                name: it.name,
                                subclassName: sc.name,
                                subclassShortName: sc.shortName,
                                source: sc.source.source || sc.source,
                                hash: subclassFeatureHash,
                                entry: feature,
                                level: feature.level,
                            });
                        }
                        );
                    }
                }
                );
            }
            );

            return out;
        },
    },

    getStateKeySubclass(sc) {
        return Parser.stringToSlug(`sub ${sc.shortName || sc.name} ${sc.source}`);
    },

    getClassesPageStatePart(opts) {
        if (!opts.subclass && !opts.feature)
            return "";

        if (!opts.feature)
            return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_subclass(opts.subclass)]);
        if (!opts.subclass)
            return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_feature(opts.feature)]);

        return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_subclass(opts.subclass), UrlUtil._getClassesPageStatePart_feature(opts.feature), ], );
    },

    _getClassesPageStatePart_subclass(sc) {
        return `${UrlUtil.getStateKeySubclass(sc)}=${UrlUtil.mini.compress(true)}`;
    },
    _getClassesPageStatePart_feature(feature) {
        return `feature=${UrlUtil.mini.compress(`${feature.ixLevel}-${feature.ixFeature}`)}`;
    },
};

UrlUtil.PG_BESTIARY = "bestiary.html";
UrlUtil.PG_SPELLS = "spells.html";
UrlUtil.PG_BACKGROUNDS = "backgrounds.html";
UrlUtil.PG_ITEMS = "items.html";
UrlUtil.PG_CLASSES = "classes.html";
UrlUtil.PG_CONDITIONS_DISEASES = "conditionsdiseases.html";
UrlUtil.PG_FEATS = "feats.html";
UrlUtil.PG_OPT_FEATURES = "optionalfeatures.html";
UrlUtil.PG_PSIONICS = "psionics.html";
UrlUtil.PG_RACES = "races.html";
UrlUtil.PG_REWARDS = "rewards.html";
UrlUtil.PG_VARIANTRULES = "variantrules.html";
UrlUtil.PG_ADVENTURE = "adventure.html";
UrlUtil.PG_ADVENTURES = "adventures.html";
UrlUtil.PG_BOOK = "book.html";
UrlUtil.PG_BOOKS = "books.html";
UrlUtil.PG_DEITIES = "deities.html";
UrlUtil.PG_CULTS_BOONS = "cultsboons.html";
UrlUtil.PG_OBJECTS = "objects.html";
UrlUtil.PG_TRAPS_HAZARDS = "trapshazards.html";
UrlUtil.PG_QUICKREF = "quickreference.html";
UrlUtil.PG_MANAGE_BREW = "managebrew.html";
UrlUtil.PG_MANAGE_PRERELEASE = "manageprerelease.html";
UrlUtil.PG_MAKE_BREW = "makebrew.html";
UrlUtil.PG_DEMO_RENDER = "renderdemo.html";
UrlUtil.PG_TABLES = "tables.html";
UrlUtil.PG_VEHICLES = "vehicles.html";
UrlUtil.PG_CHARACTERS = "characters.html";
UrlUtil.PG_ACTIONS = "actions.html";
UrlUtil.PG_LANGUAGES = "languages.html";
UrlUtil.PG_STATGEN = "statgen.html";
UrlUtil.PG_LIFEGEN = "lifegen.html";
UrlUtil.PG_NAMES = "names.html";
UrlUtil.PG_DM_SCREEN = "dmscreen.html";
UrlUtil.PG_CR_CALCULATOR = "crcalculator.html";
UrlUtil.PG_ENCOUNTERGEN = "encountergen.html";
UrlUtil.PG_LOOTGEN = "lootgen.html";
UrlUtil.PG_TEXT_CONVERTER = "converter.html";
UrlUtil.PG_CHANGELOG = "changelog.html";
UrlUtil.PG_CHAR_CREATION_OPTIONS = "charcreationoptions.html";
UrlUtil.PG_RECIPES = "recipes.html";
UrlUtil.PG_CLASS_SUBCLASS_FEATURES = "classfeatures.html";
UrlUtil.PG_CREATURE_FEATURES = "creaturefeatures.html";
UrlUtil.PG_VEHICLE_FEATURES = "vehiclefeatures.html";
UrlUtil.PG_OBJECT_FEATURES = "objectfeatures.html";
UrlUtil.PG_TRAP_FEATURES = "trapfeatures.html";
UrlUtil.PG_MAPS = "maps.html";
UrlUtil.PG_SEARCH = "search.html";
UrlUtil.PG_DECKS = "decks.html";

UrlUtil.URL_TO_HASH_GENERIC = (it)=>UrlUtil.encodeArrayForHash(it.name, it.source);

UrlUtil.URL_TO_HASH_BUILDER = {};
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE] = (it)=>UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK] = (it)=>UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.pantheon, it.source);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES] = (it)=>`${UrlUtil.encodeArrayForHash(it.name, it.source)}${it._scaleFactor ? `${HASH_PART_SEP}${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}${it._scaleFactor}` : ""}`;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASS_SUBCLASS_FEATURES] = (it)=>(it.__prop === "subclassFeature" || it.subclassSource) ? UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](it) : UrlUtil.URL_TO_HASH_BUILDER["classFeature"](it);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CREATURE_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLE_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECT_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAP_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_QUICKREF] = ({name, ixChapter, ixHeader})=>{
    const hashParts = ["bookref-quick", ixChapter, UrlUtil.encodeForHash(name.toLowerCase())];
    if (ixHeader)
        hashParts.push(ixHeader);
    return hashParts.join(HASH_PART_SEP);
}
;

UrlUtil.URL_TO_HASH_BUILDER["monster"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY];
UrlUtil.URL_TO_HASH_BUILDER["spell"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS];
UrlUtil.URL_TO_HASH_BUILDER["background"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS];
UrlUtil.URL_TO_HASH_BUILDER["item"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["itemGroup"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["baseitem"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["magicvariant"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["class"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES];
UrlUtil.URL_TO_HASH_BUILDER["condition"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["disease"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["status"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["feat"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS];
UrlUtil.URL_TO_HASH_BUILDER["optionalfeature"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES];
UrlUtil.URL_TO_HASH_BUILDER["psionic"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS];
UrlUtil.URL_TO_HASH_BUILDER["race"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES];
UrlUtil.URL_TO_HASH_BUILDER["subrace"] = (it)=>UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES]({
    name: `${it.name} (${it.raceName})`,
    source: it.source
});
UrlUtil.URL_TO_HASH_BUILDER["reward"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS];
UrlUtil.URL_TO_HASH_BUILDER["variantrule"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES];
UrlUtil.URL_TO_HASH_BUILDER["adventure"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES];
UrlUtil.URL_TO_HASH_BUILDER["adventureData"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES];
UrlUtil.URL_TO_HASH_BUILDER["book"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS];
UrlUtil.URL_TO_HASH_BUILDER["bookData"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS];
UrlUtil.URL_TO_HASH_BUILDER["deity"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES];
UrlUtil.URL_TO_HASH_BUILDER["cult"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS];
UrlUtil.URL_TO_HASH_BUILDER["boon"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS];
UrlUtil.URL_TO_HASH_BUILDER["object"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS];
UrlUtil.URL_TO_HASH_BUILDER["trap"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS];
UrlUtil.URL_TO_HASH_BUILDER["hazard"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS];
UrlUtil.URL_TO_HASH_BUILDER["table"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES];
UrlUtil.URL_TO_HASH_BUILDER["tableGroup"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES];
UrlUtil.URL_TO_HASH_BUILDER["vehicle"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES];
UrlUtil.URL_TO_HASH_BUILDER["vehicleUpgrade"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES];
UrlUtil.URL_TO_HASH_BUILDER["action"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS];
UrlUtil.URL_TO_HASH_BUILDER["language"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES];
UrlUtil.URL_TO_HASH_BUILDER["charoption"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS];
UrlUtil.URL_TO_HASH_BUILDER["recipe"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES];
UrlUtil.URL_TO_HASH_BUILDER["deck"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS];

UrlUtil.URL_TO_HASH_BUILDER["subclass"] = it=>{
    return Hist.util.getCleanHash(`${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
        name: it.className,
        source: it.classSource
    })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
        subclass: it
    })}`, );
}
;
UrlUtil.URL_TO_HASH_BUILDER["classFeature"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.className, it.classSource, it.level, it.source);
UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.className, it.classSource, it.subclassShortName, it.subclassSource, it.level, it.source);
UrlUtil.URL_TO_HASH_BUILDER["card"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.set, it.source);
UrlUtil.URL_TO_HASH_BUILDER["legendaryGroup"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["itemEntry"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["itemProperty"] = (it)=>UrlUtil.encodeArrayForHash(it.abbreviation, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemType"] = (it)=>UrlUtil.encodeArrayForHash(it.abbreviation, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemTypeAdditionalEntries"] = (it)=>UrlUtil.encodeArrayForHash(it.appliesTo, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemMastery"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["skill"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["sense"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["raceFeature"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.raceName, it.raceSource, it.source);
UrlUtil.URL_TO_HASH_BUILDER["citation"] = UrlUtil.URL_TO_HASH_GENERIC;

Object.keys(UrlUtil.URL_TO_HASH_BUILDER).filter(k=>!k.endsWith(".html") && k.toLowerCase() !== k).forEach(k=>UrlUtil.URL_TO_HASH_BUILDER[k.toLowerCase()] = UrlUtil.URL_TO_HASH_BUILDER[k]);

Object.keys(UrlUtil.URL_TO_HASH_BUILDER).filter(k=>!k.endsWith(".html")).forEach(k=>UrlUtil.URL_TO_HASH_BUILDER[`raw_${k}`] = UrlUtil.URL_TO_HASH_BUILDER[k]);

Object.keys(UrlUtil.URL_TO_HASH_BUILDER).filter(k=>!k.endsWith(".html")).forEach(k=>{
    UrlUtil.URL_TO_HASH_BUILDER[`${k}Fluff`] = UrlUtil.URL_TO_HASH_BUILDER[k];
    UrlUtil.URL_TO_HASH_BUILDER[`${k}Template`] = UrlUtil.URL_TO_HASH_BUILDER[k];
}
);

UrlUtil.PG_TO_NAME = {};
UrlUtil.PG_TO_NAME[UrlUtil.PG_BESTIARY] = "Bestiary";
UrlUtil.PG_TO_NAME[UrlUtil.PG_SPELLS] = "Spells";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BACKGROUNDS] = "Backgrounds";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ITEMS] = "Items";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CLASSES] = "Classes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CONDITIONS_DISEASES] = "Conditions & Diseases";
UrlUtil.PG_TO_NAME[UrlUtil.PG_FEATS] = "Feats";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OPT_FEATURES] = "Other Options and Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_PSIONICS] = "Psionics";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RACES] = "Races";
UrlUtil.PG_TO_NAME[UrlUtil.PG_REWARDS] = "Supernatural Gifts & Rewards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VARIANTRULES] = "Optional, Variant, and Expanded Rules";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ADVENTURES] = "Adventures";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BOOKS] = "Books";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEITIES] = "Deities";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CULTS_BOONS] = "Cults & Supernatural Boons";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OBJECTS] = "Objects";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TRAPS_HAZARDS] = "Traps & Hazards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_QUICKREF] = "Quick Reference";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_BREW] = "Homebrew Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_PRERELEASE] = "Prerelease Content Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAKE_BREW] = "Homebrew Builder";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEMO_RENDER] = "Renderer Demo";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TABLES] = "Tables";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VEHICLES] = "Vehicles";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ACTIONS] = "Actions";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LANGUAGES] = "Languages";
UrlUtil.PG_TO_NAME[UrlUtil.PG_STATGEN] = "Stat Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LIFEGEN] = "This Is Your Life";
UrlUtil.PG_TO_NAME[UrlUtil.PG_NAMES] = "Names";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DM_SCREEN] = "DM Screen";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CR_CALCULATOR] = "CR Calculator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ENCOUNTERGEN] = "Encounter Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LOOTGEN] = "Loot Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TEXT_CONVERTER] = "Text Converter";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHANGELOG] = "Changelog";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHAR_CREATION_OPTIONS] = "Other Character Creation Options";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RECIPES] = "Recipes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CREATURE_FEATURES] = "Creature Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VEHICLE_FEATURES] = "Vehicle Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OBJECT_FEATURES] = "Object Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TRAP_FEATURES] = "Trap Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAPS] = "Maps";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DECKS] = "Decks";

UrlUtil.CAT_TO_PAGE = {};
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CREATURE] = UrlUtil.PG_BESTIARY;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SPELL] = UrlUtil.PG_SPELLS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BACKGROUND] = UrlUtil.PG_BACKGROUNDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ITEM] = UrlUtil.PG_ITEMS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CONDITION] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FEAT] = UrlUtil.PG_FEATS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELDRITCH_INVOCATION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_METAMAGIC] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_CAVALIER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARCANE_SHOT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FIGHTING_STYLE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PSIONIC] = UrlUtil.PG_PSIONICS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RACE] = UrlUtil.PG_RACES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OTHER_REWARD] = UrlUtil.PG_REWARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = UrlUtil.PG_VARIANTRULES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ADVENTURE] = UrlUtil.PG_ADVENTURE;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DEITY] = UrlUtil.PG_DEITIES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OBJECT] = UrlUtil.PG_OBJECTS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TRAP] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_HAZARD] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_QUICKREF] = UrlUtil.PG_QUICKREF;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CULT] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOON] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DISEASE] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE_GROUP] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VEHICLE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PACT_BOON] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARTIFICER_INFUSION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SHIP_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ONOMANCY_RESONANT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ALCHEMICAL_FORMULA] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ACTION] = UrlUtil.PG_ACTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LANGUAGE] = UrlUtil.PG_LANGUAGES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOOK] = UrlUtil.PG_BOOK;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PAGE] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = UrlUtil.PG_CHAR_CREATION_OPTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RECIPES] = UrlUtil.PG_RECIPES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_STATUS] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DECK] = UrlUtil.PG_DECKS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CARD] = "card";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SKILLS] = "skill";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SENSES] = "sense";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";

UrlUtil.CAT_TO_HOVER_PAGE = {};
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CLASS_FEATURE] = "classfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CARD] = "card";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SKILLS] = "skill";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SENSES] = "sense";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";

/* UrlUtil.HASH_START_CREATURE_SCALED = `${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_SPELL_SUMMON = `${VeCt.HASH_SCALED_SPELL_SUMMON}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_CLASS_SUMMON = `${VeCt.HASH_SCALED_CLASS_SUMMON}${HASH_SUB_KV_SEP}`; */

UrlUtil.SUBLIST_PAGES = {
    [UrlUtil.PG_BESTIARY]: true,
    [UrlUtil.PG_SPELLS]: true,
    [UrlUtil.PG_BACKGROUNDS]: true,
    [UrlUtil.PG_ITEMS]: true,
    [UrlUtil.PG_CONDITIONS_DISEASES]: true,
    [UrlUtil.PG_FEATS]: true,
    [UrlUtil.PG_OPT_FEATURES]: true,
    [UrlUtil.PG_PSIONICS]: true,
    [UrlUtil.PG_RACES]: true,
    [UrlUtil.PG_REWARDS]: true,
    [UrlUtil.PG_VARIANTRULES]: true,
    [UrlUtil.PG_DEITIES]: true,
    [UrlUtil.PG_CULTS_BOONS]: true,
    [UrlUtil.PG_OBJECTS]: true,
    [UrlUtil.PG_TRAPS_HAZARDS]: true,
    [UrlUtil.PG_TABLES]: true,
    [UrlUtil.PG_VEHICLES]: true,
    [UrlUtil.PG_ACTIONS]: true,
    [UrlUtil.PG_LANGUAGES]: true,
    [UrlUtil.PG_CHAR_CREATION_OPTIONS]: true,
    [UrlUtil.PG_RECIPES]: true,
    [UrlUtil.PG_DECKS]: true,
};

UrlUtil.PAGE_TO_PROPS = {};
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_SPELLS] = ["spell"];
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_ITEMS] = ["item", "itemGroup", "itemType", "itemEntry", "itemProperty", "itemTypeAdditionalEntries", "itemMastery", "baseitem", "magicvariant"];
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_RACES] = ["race", "subrace"];
//#endregion

//#region Extension Functions
String.prototype.toAscii = String.prototype.toAscii || function() {
    return this.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/Æ/g, "AE").replace(/æ/g, "ae");
};
Array.prototype.mergeMap || Object.defineProperty(Array.prototype, "mergeMap", {
    enumerable: false,
    writable: true,
    value: function(fnMap) {
        return this.map((...args)=>fnMap(...args)).filter(it=>it != null).reduce((a,b)=>Object.assign(a, b), {});
    },
});
String.prototype.toUrlified = String.prototype.toUrlified || function() {
    return encodeURIComponent(this.toLowerCase()).toLowerCase();
}
;
String.prototype.qq = String.prototype.qq || function() {
    return this.escapeQuotes();
}
;
String.prototype.escapeQuotes = String.prototype.escapeQuotes || function() {
    return this.replace(/'/g, `&apos;`).replace(/"/g, `&quot;`).replace(/</g, `&lt;`).replace(/>/g, `&gt;`);
}
;
Array.prototype.pSerialAwaitMap || Object.defineProperty(Array.prototype, "pSerialAwaitMap", {
	enumerable: false,
	writable: true,
	value: async function (fnMap) {
		const out = [];
		for (let i = 0, len = this.length; i < len; ++i) out.push(await fnMap(this[i], i, this));
		return out;
	},
});
Array.prototype.shuffle || Object.defineProperty(Array.prototype, "shuffle", {
    enumerable: false,
    writable: true,
    value: function() {
        const len = this.length;
        const ixLast = len - 1;
        for (let i = 0; i < len; ++i) {
            const j = i + Math.floor(Math.random() * (ixLast - i + 1));
            [this[i],this[j]] = [this[j], this[i]];
        }
        return this;
    },
});
String.prototype.toTitleCase = String.prototype.toTitleCase || function() {
    let str = this.replace(/([^\W_]+[^-\u2014\s/]*) */g, m0=>m0.charAt(0).toUpperCase() + m0.substring(1).toLowerCase());

    StrUtil._TITLE_LOWER_WORDS_RE = StrUtil._TITLE_LOWER_WORDS_RE || StrUtil.TITLE_LOWER_WORDS.map(it=>new RegExp(`\\s${it}\\s`,"gi"));
    StrUtil._TITLE_UPPER_WORDS_RE = StrUtil._TITLE_UPPER_WORDS_RE || StrUtil.TITLE_UPPER_WORDS.map(it=>new RegExp(`\\b${it}\\b`,"g"));
    StrUtil._TITLE_UPPER_WORDS_PLURAL_RE = StrUtil._TITLE_UPPER_WORDS_PLURAL_RE || StrUtil.TITLE_UPPER_WORDS_PLURAL.map(it=>new RegExp(`\\b${it}\\b`,"g"));

    const len = StrUtil.TITLE_LOWER_WORDS.length;
    for (let i = 0; i < len; i++) {
        str = str.replace(StrUtil._TITLE_LOWER_WORDS_RE[i], txt=>txt.toLowerCase(), );
    }

    const len1 = StrUtil.TITLE_UPPER_WORDS.length;
    for (let i = 0; i < len1; i++) {
        str = str.replace(StrUtil._TITLE_UPPER_WORDS_RE[i], StrUtil.TITLE_UPPER_WORDS[i].toUpperCase(), );
    }

    for (let i = 0; i < len1; i++) {
        str = str.replace(StrUtil._TITLE_UPPER_WORDS_PLURAL_RE[i], `${StrUtil.TITLE_UPPER_WORDS_PLURAL[i].slice(0, -1).toUpperCase()}${StrUtil.TITLE_UPPER_WORDS_PLURAL[i].slice(-1).toLowerCase()}`, );
    }

    str = str.split(/([;:?!.])/g).map(pt=>pt.replace(/^(\s*)([^\s])/, (...m)=>`${m[1]}${m[2].toUpperCase()}`)).join("");

    return str;
};
String.prototype.last = String.prototype.last || function() {return this[this.length - 1];};
//#endregion


//#region Renderer
globalThis.Renderer = function() {
    this.wrapperTag = "div";
    this.baseUrl = "";
    this.baseMediaUrls = {};

    if (globalThis.DEPLOYED_IMG_ROOT) {
        this.baseMediaUrls["img"] = globalThis.DEPLOYED_IMG_ROOT;
    }

    this._lazyImages = false;
    this._subVariant = false;
    this._firstSection = true;
    this._isAddHandlers = true;
    this._headerIndex = 1;
    this._tagExportDict = null;
    this._roll20Ids = null;
    this._trackTitles = {
        enabled: false,
        titles: {}
    };
    this._enumerateTitlesRel = {
        enabled: false,
        titles: {}
    };
    this._isHeaderIndexIncludeTableCaptions = false;
    this._isHeaderIndexIncludeImageTitles = false;
    this._plugins = {};
    this._fnPostProcess = null;
    this._extraSourceClasses = null;
    this._depthTracker = null;
    this._depthTrackerAdditionalProps = [];
    this._depthTrackerAdditionalPropsInherited = [];
    this._lastDepthTrackerInheritedProps = {};
    this._isInternalLinksDisabled = false;
    this._isPartPageExpandCollapseDisabled = false;
    this._fnsGetStyleClasses = {};

    this.setLazyImages = function(bool) {
        if (typeof IntersectionObserver === "undefined")
            this._lazyImages = false;
        else
            this._lazyImages = !!bool;
        return this;
    }
    ;

    this.setWrapperTag = function(tag) {
        this.wrapperTag = tag;
        return this;
    }
    ;

    this.setBaseUrl = function(url) {
        this.baseUrl = url;
        return this;
    }
    ;

    this.setBaseMediaUrl = function(mediaDir, url) {
        this.baseMediaUrls[mediaDir] = url;
        return this;
    }
    ;

    this.setFirstSection = function(bool) {
        this._firstSection = bool;
        return this;
    }
    ;

    this.setAddHandlers = function(bool) {
        this._isAddHandlers = bool;
        return this;
    }
    ;

    this.setFnPostProcess = function(fn) {
        this._fnPostProcess = fn;
        return this;
    }
    ;

    this.setExtraSourceClasses = function(arr) {
        this._extraSourceClasses = arr;
        return this;
    }
    ;

    this.resetHeaderIndex = function() {
        this._headerIndex = 1;
        this._trackTitles.titles = {};
        this._enumerateTitlesRel.titles = {};
        return this;
    }
    ;

    this.getHeaderIndex = function() {
        return this._headerIndex;
    }
    ;

    this.setHeaderIndexTableCaptions = function(bool) {
        this._isHeaderIndexIncludeTableCaptions = bool;
        return this;
    }
    ;
    this.setHeaderIndexImageTitles = function(bool) {
        this._isHeaderIndexIncludeImageTitles = bool;
        return this;
    }
    ;

    this.doExportTags = function(toObj) {
        this._tagExportDict = toObj;
        return this;
    }
    ;

    this.resetExportTags = function() {
        this._tagExportDict = null;
        return this;
    }
    ;

    this.setRoll20Ids = function(roll20Ids) {
        this._roll20Ids = roll20Ids;
        return this;
    }
    ;

    this.resetRoll20Ids = function() {
        this._roll20Ids = null;
        return this;
    }
    ;

    this.setInternalLinksDisabled = function(val) {
        this._isInternalLinksDisabled = !!val;
        return this;
    }
    ;
    this.isInternalLinksDisabled = function() {
        return !!this._isInternalLinksDisabled;
    }
    ;

    this.setPartPageExpandCollapseDisabled = function(val) {
        this._isPartPageExpandCollapseDisabled = !!val;
        return this;
    }
    ;

    this.setFnGetStyleClasses = function(identifier, fn) {
        if (fn == null) {
            delete this._fnsGetStyleClasses[identifier];
            return this;
        }

        this._fnsGetStyleClasses[identifier] = fn;
        return this;
    }
    ;

    this.setEnumerateTitlesRel = function(bool) {
        this._enumerateTitlesRel.enabled = bool;
        return this;
    }
    ;

    this._getEnumeratedTitleRel = function(name) {
        if (this._enumerateTitlesRel.enabled && name) {
            const clean = name.toLowerCase();
            this._enumerateTitlesRel.titles[clean] = this._enumerateTitlesRel.titles[clean] || 0;
            return `data-title-relative-index="${this._enumerateTitlesRel.titles[clean]++}"`;
        } else
            return "";
    }
    ;

    this.setTrackTitles = function(bool) {
        this._trackTitles.enabled = bool;
        return this;
    }
    ;

    this.getTrackedTitles = function() {
        return MiscUtil.copyFast(this._trackTitles.titles);
    }
    ;

    this.getTrackedTitlesInverted = function({isStripTags=false}={}) {
        const trackedTitlesInverse = {};
        Object.entries(this._trackTitles.titles || {}).forEach(([titleIx,titleName])=>{
            if (isStripTags)
                titleName = Renderer.stripTags(titleName);
            titleName = titleName.toLowerCase().trim();
            (trackedTitlesInverse[titleName] = trackedTitlesInverse[titleName] || []).push(titleIx);
        }
        );
        return trackedTitlesInverse;
    }
    ;

    this._handleTrackTitles = function(name, {isTable=false, isImage=false}={}) {
        if (!this._trackTitles.enabled)
            return;
        if (isTable && !this._isHeaderIndexIncludeTableCaptions)
            return;
        if (isImage && !this._isHeaderIndexIncludeImageTitles)
            return;
        this._trackTitles.titles[this._headerIndex] = name;
    }
    ;

    this._handleTrackDepth = function(entry, depth) {
        if (!entry.name || !this._depthTracker)
            return;

        this._lastDepthTrackerInheritedProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        if (entry.source)
            this._lastDepthTrackerInheritedProps.source = entry.source;
        if (this._depthTrackerAdditionalPropsInherited?.length) {
            this._depthTrackerAdditionalPropsInherited.forEach(prop=>this._lastDepthTrackerInheritedProps[prop] = entry[prop] || this._lastDepthTrackerInheritedProps[prop]);
        }

        const additionalData = this._depthTrackerAdditionalProps.length ? this._depthTrackerAdditionalProps.mergeMap(it=>({
            [it]: entry[it]
        })) : {};

        this._depthTracker.push({
            ...this._lastDepthTrackerInheritedProps,
            ...additionalData,
            depth,
            name: entry.name,
            type: entry.type,
            ixHeader: this._headerIndex,
            source: this._lastDepthTrackerInheritedProps.source,
            data: entry.data,
            page: entry.page,
            alias: entry.alias,
            entry,
        });
    }
    ;

    this.addPlugin = function(pluginType, fnPlugin) {
        MiscUtil.getOrSet(this._plugins, pluginType, []).push(fnPlugin);
    }
    ;

    this.removePlugin = function(pluginType, fnPlugin) {
        if (!fnPlugin)
            return;
        const ix = (MiscUtil.get(this._plugins, pluginType) || []).indexOf(fnPlugin);
        if (~ix)
            this._plugins[pluginType].splice(ix, 1);
    }
    ;

    this.removePlugins = function(pluginType) {
        MiscUtil.delete(this._plugins, pluginType);
    }
    ;

    this._getPlugins = function(pluginType) {
        return this._plugins[pluginType] || [];
    }
    ;

    this.withPlugin = function({pluginTypes, fnPlugin, fn}) {
        for (const pt of pluginTypes)
            this.addPlugin(pt, fnPlugin);
        try {
            return fn(this);
        } finally {
            for (const pt of pluginTypes)
                this.removePlugin(pt, fnPlugin);
        }
    }
    ;

    this.pWithPlugin = async function({pluginTypes, fnPlugin, pFn}) {
        for (const pt of pluginTypes)
            this.addPlugin(pt, fnPlugin);
        try {
            const out = await pFn(this);
            return out;
        } finally {
            for (const pt of pluginTypes)
                this.removePlugin(pt, fnPlugin);
        }
    }
    ;

    this.setDepthTracker = function(arr, {additionalProps, additionalPropsInherited}={}) {
        this._depthTracker = arr;
        this._depthTrackerAdditionalProps = additionalProps || [];
        this._depthTrackerAdditionalPropsInherited = additionalPropsInherited || [];
        return this;
    }
    ;

    this.getLineBreak = function() {
        return "<br>";
    }
    ;

    this.recursiveRender = function(entry, textStack, meta, options) {
        if (entry instanceof Array) {
            entry.forEach(nxt=>this.recursiveRender(nxt, textStack, meta, options));
            setTimeout(()=>{
                throw new Error(`Array passed to renderer! The renderer only guarantees support for primitives and basic objects.`);
            }
            );
            return this;
        }

        if (textStack.length === 0)
            textStack[0] = "";
        else
            textStack.reverse();

        meta = meta || {};
        meta._typeStack = [];
        meta.depth = meta.depth == null ? 0 : meta.depth;

        this._recursiveRender(entry, textStack, meta, options);
        if (this._fnPostProcess)
            textStack[0] = this._fnPostProcess(textStack[0]);
        textStack.reverse();

        return this;
    }
    ;

    this._recursiveRender = function(entry, textStack, meta, options) {
        if (entry == null)
            return;
        if (!textStack)
            throw new Error("Missing stack!");
        if (!meta)
            throw new Error("Missing metadata!");
        if (entry.type === "section")
            meta.depth = -1;

        options = options || {};

        meta._didRenderPrefix = false;
        meta._didRenderSuffix = false;

        if (typeof entry === "object") {
            const type = entry.type == null || entry.type === "section" ? "entries" : entry.type;

            if (type === "wrapper")
                return this._recursiveRender(entry.wrapped, textStack, meta, options);

            meta._typeStack.push(type);

            switch (type) {
            case "entries":
                this._renderEntries(entry, textStack, meta, options);
                break;
            case "options":
                this._renderOptions(entry, textStack, meta, options);
                break;
            case "list":
                this._renderList(entry, textStack, meta, options);
                break;
            case "table":
                //TEMPFIX
                //this._renderTable(entry, textStack, meta, options);
                break;
            case "tableGroup":
                this._renderTableGroup(entry, textStack, meta, options);
                break;
            case "inset":
                this._renderInset(entry, textStack, meta, options);
                break;
            case "insetReadaloud":
                this._renderInsetReadaloud(entry, textStack, meta, options);
                break;
            case "variant":
                this._renderVariant(entry, textStack, meta, options);
                break;
            case "variantInner":
                this._renderVariantInner(entry, textStack, meta, options);
                break;
            case "variantSub":
                this._renderVariantSub(entry, textStack, meta, options);
                break;
            case "spellcasting":
                this._renderSpellcasting(entry, textStack, meta, options);
                break;
            case "quote":
                this._renderQuote(entry, textStack, meta, options);
                break;
            case "optfeature":
                this._renderOptfeature(entry, textStack, meta, options);
                break;
            case "patron":
                this._renderPatron(entry, textStack, meta, options);
                break;

            case "abilityDc":
                this._renderAbilityDc(entry, textStack, meta, options);
                break;
            case "abilityAttackMod":
                this._renderAbilityAttackMod(entry, textStack, meta, options);
                break;
            case "abilityGeneric":
                this._renderAbilityGeneric(entry, textStack, meta, options);
                break;

            case "inline":
                this._renderInline(entry, textStack, meta, options);
                break;
            case "inlineBlock":
                this._renderInlineBlock(entry, textStack, meta, options);
                break;
            case "bonus":
                this._renderBonus(entry, textStack, meta, options);
                break;
            case "bonusSpeed":
                this._renderBonusSpeed(entry, textStack, meta, options);
                break;
            case "dice":
                this._renderDice(entry, textStack, meta, options);
                break;
            case "link":
                this._renderLink(entry, textStack, meta, options);
                break;
            case "actions":
                this._renderActions(entry, textStack, meta, options);
                break;
            case "attack":
                this._renderAttack(entry, textStack, meta, options);
                break;
            case "ingredient":
                this._renderIngredient(entry, textStack, meta, options);
                break;

            case "item":
                this._renderItem(entry, textStack, meta, options);
                break;
            case "itemSub":
                this._renderItemSub(entry, textStack, meta, options);
                break;
            case "itemSpell":
                this._renderItemSpell(entry, textStack, meta, options);
                break;

            case "statblockInline":
                this._renderStatblockInline(entry, textStack, meta, options);
                break;
            case "statblock":
                this._renderStatblock(entry, textStack, meta, options);
                break;

            case "image":
                this._renderImage(entry, textStack, meta, options);
                break;
            case "gallery":
                this._renderGallery(entry, textStack, meta, options);
                break;

            case "flowchart":
                this._renderFlowchart(entry, textStack, meta, options);
                break;
            case "flowBlock":
                this._renderFlowBlock(entry, textStack, meta, options);
                break;

            case "homebrew":
                this._renderHomebrew(entry, textStack, meta, options);
                break;

            case "code":
                this._renderCode(entry, textStack, meta, options);
                break;
            case "hr":
                this._renderHr(entry, textStack, meta, options);
                break;
            }

            meta._typeStack.pop();
        } else if (typeof entry === "string") {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderString(entry, textStack, meta, options);
            this._renderSuffix(entry, textStack, meta, options);
        } else {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderPrimitive(entry, textStack, meta, options);
            this._renderSuffix(entry, textStack, meta, options);
        }
    }
    ;

    this._RE_TEXT_CENTER = /\btext-center\b/;

    this._getMutatedStyleString = function(str) {
        if (!str)
            return str;
        return str.replace(this._RE_TEXT_CENTER, "ve-text-center");
    }
    ;

    this._adjustDepth = function(meta, dDepth) {
        const cachedDepth = meta.depth;
        meta.depth += dDepth;
        meta.depth = Math.min(Math.max(-1, meta.depth), 2);
        return cachedDepth;
    }
    ;

    this._renderPrefix = function(entry, textStack, meta, options) {
        if (meta._didRenderPrefix)
            return;
        if (options.prefix != null) {
            textStack[0] += options.prefix;
            meta._didRenderPrefix = true;
        }
    }
    ;

    this._renderSuffix = function(entry, textStack, meta, options) {
        if (meta._didRenderSuffix)
            return;
        if (options.suffix != null) {
            textStack[0] += options.suffix;
            meta._didRenderSuffix = true;
        }
    }
    ;

    this._renderImage = function(entry, textStack, meta, options) {
        if (entry.title)
            this._handleTrackTitles(entry.title, {
                isImage: true
            });

        textStack[0] += `<div class="float-clear"></div>`;

        if (entry.imageType === "map" || entry.imageType === "mapPlayer")
            textStack[0] += `<div class="rd__wrp-map">`;
        textStack[0] += `<div class="${meta._typeStack.includes("gallery") ? "rd__wrp-gallery-image" : ""}">`;

        const href = this._renderImage_getUrl(entry);
        const svg = this._lazyImages && entry.width != null && entry.height != null ? `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="${entry.width}" height="${entry.height}"><rect width="100%" height="100%" fill="#ccc3"></rect></svg>`)}` : null;
        const ptTitleCreditTooltip = this._renderImage_getTitleCreditTooltipText(entry);
        const ptTitle = ptTitleCreditTooltip ? `title="${ptTitleCreditTooltip}"` : "";
        const pluginDataIsNoLink = this._getPlugins("image_isNoLink").map(plugin=>plugin(entry, textStack, meta, options)).some(Boolean);

        textStack[0] += `<div class="${this._renderImage_getWrapperClasses(entry, meta)}" ${entry.title && this._isHeaderIndexIncludeImageTitles ? `data-title-index="${this._headerIndex++}"` : ""}>
			${pluginDataIsNoLink ? "" : `<a href="${href}" target="_blank" rel="noopener noreferrer" ${ptTitle}>`}
				<img class="${this._renderImage_getImageClasses(entry, meta)}" src="${svg || href}" ${pluginDataIsNoLink ? ptTitle : ""} ${entry.altText || entry.title ? `alt="${Renderer.stripTags((entry.altText || entry.title)).qq()}"` : ""} ${svg ? `data-src="${href}"` : `loading="lazy"`} ${this._renderImage_getStylePart(entry)}>
			${pluginDataIsNoLink ? "" : `</a>`}
		</div>`;

        if (!this._renderImage_isComicStyling(entry) && (entry.title || entry.credit || entry.mapRegions)) {
            const ptAdventureBookMeta = entry.mapRegions && meta.adventureBookPage && meta.adventureBookSource && meta.adventureBookHash ? `data-rd-adventure-book-map-page="${meta.adventureBookPage.qq()}" data-rd-adventure-book-map-source="${meta.adventureBookSource.qq()}" data-rd-adventure-book-map-hash="${meta.adventureBookHash.qq()}"` : "";

            textStack[0] += `<div class="rd__image-title">`;

            if (entry.title && !entry.mapRegions)
                textStack[0] += `<div class="rd__image-title-inner">${this.render(entry.title)}</div>`;

            if (entry.mapRegions && !IS_VTT) {
                textStack[0] += `<button class="btn btn-xs btn-default rd__image-btn-viewer" onclick="RenderMap.pShowViewer(event, this)" data-rd-packed-map="${this._renderImage_getMapRegionData(entry)}" ${ptAdventureBookMeta} title="Open Dynamic Viewer (SHIFT to Open in New Window)"><span class="glyphicon glyphicon-picture"></span> ${Renderer.stripTags(entry.title) || "Dynamic Viewer"}</button>`;
            }

            if (entry.credit)
                textStack[0] += `<div class="rd__image-credit ve-muted"><span class="glyphicon glyphicon-pencil" title="Art Credit"></span> ${this.render(entry.credit)}</div>`;

            textStack[0] += `</div>`;
        }

        if (entry._galleryTitlePad)
            textStack[0] += `<div class="rd__image-title">&nbsp;</div>`;
        if (entry._galleryCreditPad)
            textStack[0] += `<div class="rd__image-credit">&nbsp;</div>`;

        textStack[0] += `</div>`;
        if (entry.imageType === "map" || entry.imageType === "mapPlayer")
            textStack[0] += `</div>`;
    }
    ;

    this._renderImage_getTitleCreditTooltipText = function(entry) {
        if (!entry.title && !entry.credit)
            return null;
        return Renderer.stripTags([entry.title, entry.credit ? `Art credit: ${entry.credit}` : null].filter(Boolean).join(". "), ).qq();
    }
    ;

    this._renderImage_getStylePart = function(entry) {
        const styles = [entry.maxWidth ? `max-width: min(100%, ${entry.maxWidth}${entry.maxWidthUnits || "px"})` : "", entry.maxHeight ? `max-height: min(60vh, ${entry.maxHeight}${entry.maxHeightUnits || "px"})` : "", ].filter(Boolean).join("; ");
        return styles ? `style="${styles}"` : "";
    }
    ;

    this._renderImage_getMapRegionData = function(entry) {
        return JSON.stringify(this.getMapRegionData(entry)).escapeQuotes();
    }
    ;

    this.getMapRegionData = function(entry) {
        return {
            regions: entry.mapRegions,
            width: entry.width,
            height: entry.height,
            href: this._renderImage_getUrl(entry),
            hrefThumbnail: this._renderImage_getUrlThumbnail(entry),
            page: entry.page,
            source: entry.source,
            hash: entry.hash,
        };
    }
    ;

    this._renderImage_isComicStyling = function(entry) {
        if (!entry.style)
            return false;
        return ["comic-speaker-left", "comic-speaker-right"].includes(entry.style);
    }
    ;

    this._renderImage_getWrapperClasses = function(entry) {
        const out = ["rd__wrp-image", "relative"];
        if (entry.style) {
            switch (entry.style) {
            case "comic-speaker-left":
                out.push("rd__comic-img-speaker", "rd__comic-img-speaker--left");
                break;
            case "comic-speaker-right":
                out.push("rd__comic-img-speaker", "rd__comic-img-speaker--right");
                break;
            }
        }
        return out.join(" ");
    }
    ;

    this._renderImage_getImageClasses = function(entry) {
        const out = ["rd__image"];
        if (entry.style) {
            switch (entry.style) {
            case "deity-symbol":
                out.push("rd__img-small");
                break;
            }
        }
        return out.join(" ");
    }
    ;

    this._renderImage_getUrl = function(entry) {
        let url = Renderer.utils.getMediaUrl(entry, "href", "img");
        for (const plugin of this._getPlugins(`image_urlPostProcess`)) {
            url = plugin(entry, url) || url;
        }
        return url;
    }
    ;

    this._renderImage_getUrlThumbnail = function(entry) {
        let url = Renderer.utils.getMediaUrl(entry, "hrefThumbnail", "img");
        for (const plugin of this._getPlugins(`image_urlThumbnailPostProcess`)) {
            url = plugin(entry, url) || url;
        }
        return url;
    }
    ;

    this._renderList_getListCssClasses = function(entry, textStack, meta, options) {
        const out = [`rd__list`];
        if (entry.style || entry.columns) {
            if (entry.style)
                out.push(...entry.style.split(" ").map(it=>`rd__${it}`));
            if (entry.columns)
                out.push(`columns-${entry.columns}`);
        }
        return out.join(" ");
    }
    ;

    this._renderTableGroup = function(entry, textStack, meta, options) {
        const len = entry.tables.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.tables[i], textStack, meta);
    }
    ;

    this._renderTable = function(entry, textStack, meta, options) {
        if (entry.intro) {
            const len = entry.intro.length;
            for (let i = 0; i < len; ++i) {
                this._recursiveRender(entry.intro[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
            }
        }

        textStack[0] += `<table class="w-100 rd__table ${this._getMutatedStyleString(entry.style || "")} ${entry.isStriped === false ? "" : "stripe-odd-table"}">`;

        const headerRowMetas = Renderer.table.getHeaderRowMetas(entry);

        const autoRollMode = Renderer.table.getAutoConvertedRollMode(entry, {headerRowMetas});

        const toRenderLabel = autoRollMode ? RollerUtil.getFullRollCol(headerRowMetas.last()[0]) : null;
        const isInfiniteResults = autoRollMode === RollerUtil.ROLL_COL_VARIABLE;

        if (entry.caption != null) {
            this._handleTrackTitles(entry.caption, {
                isTable: true
            });
            textStack[0] += `<caption ${this._isHeaderIndexIncludeTableCaptions ? `data-title-index="${this._headerIndex++}"` : ""}>${entry.caption}</caption>`;
        }

        const rollCols = [];
        let bodyStack = [""];
        bodyStack[0] += "<tbody>";
        const lenRows = entry.rows.length;
        for (let ixRow = 0; ixRow < lenRows; ++ixRow) {
            bodyStack[0] += "<tr>";
            const r = entry.rows[ixRow];
            let roRender = r.type === "row" ? r.row : r;

            const len = roRender.length;
            for (let ixCell = 0; ixCell < len; ++ixCell) {
                rollCols[ixCell] = rollCols[ixCell] || false;

                if (autoRollMode && ixCell === 0) {
                    roRender = Renderer.getRollableRow(roRender, {
                        isForceInfiniteResults: isInfiniteResults,
                        isFirstRow: ixRow === 0,
                        isLastRow: ixRow === lenRows - 1,
                    }, );
                    rollCols[ixCell] = true;
                }

                let toRenderCell;
                if (roRender[ixCell].type === "cell") {
                    if (roRender[ixCell].roll) {
                        rollCols[ixCell] = true;
                        if (roRender[ixCell].entry) {
                            toRenderCell = roRender[ixCell].entry;
                        } else if (roRender[ixCell].roll.exact != null) {
                            toRenderCell = roRender[ixCell].roll.pad ? StrUtil.padNumber(roRender[ixCell].roll.exact, 2, "0") : roRender[ixCell].roll.exact;
                        } else {

                            const dispMin = roRender[ixCell].roll.displayMin != null ? roRender[ixCell].roll.displayMin : roRender[ixCell].roll.min;
                            const dispMax = roRender[ixCell].roll.displayMax != null ? roRender[ixCell].roll.displayMax : roRender[ixCell].roll.max;

                            if (dispMax === Renderer.dice.POS_INFINITE) {
                                toRenderCell = roRender[ixCell].roll.pad ? `${StrUtil.padNumber(dispMin, 2, "0")}+` : `${dispMin}+`;
                            } else {
                                toRenderCell = roRender[ixCell].roll.pad ? `${StrUtil.padNumber(dispMin, 2, "0")}-${StrUtil.padNumber(dispMax, 2, "0")}` : `${dispMin}-${dispMax}`;
                            }
                        }
                    } else if (roRender[ixCell].entry) {
                        toRenderCell = roRender[ixCell].entry;
                    }
                } else {
                    toRenderCell = roRender[ixCell];
                }
                bodyStack[0] += `<td ${this._renderTable_makeTableTdClassText(entry, ixCell)} ${this._renderTable_getCellDataStr(roRender[ixCell])} ${roRender[ixCell].type === "cell" && roRender[ixCell].width ? `colspan="${roRender[ixCell].width}"` : ""}>`;
                if (r.style === "row-indent-first" && ixCell === 0)
                    bodyStack[0] += `<div class="rd__tab-indent"></div>`;
                const cacheDepth = this._adjustDepth(meta, 1);
                this._recursiveRender(toRenderCell, bodyStack, meta);
                meta.depth = cacheDepth;
                bodyStack[0] += "</td>";
            }
            bodyStack[0] += "</tr>";
        }
        bodyStack[0] += "</tbody>";

        if (headerRowMetas) {
            textStack[0] += "<thead>";

            for (let ixRow = 0, lenRows = headerRowMetas.length; ixRow < lenRows; ++ixRow) {
                textStack[0] += "<tr>";

                const headerRowMeta = headerRowMetas[ixRow];
                for (let ixCell = 0, lenCells = headerRowMeta.length; ixCell < lenCells; ++ixCell) {
                    const lbl = headerRowMeta[ixCell];
                    textStack[0] += `<th ${this._renderTable_getTableThClassText(entry, ixCell)} data-rd-isroller="${rollCols[ixCell]}" ${entry.isNameGenerator ? `data-rd-namegeneratorrolls="${headerRowMeta.length - 1}"` : ""}>`;
                    this._recursiveRender(autoRollMode && ixCell === 0 ? RollerUtil.getFullRollCol(lbl) : lbl, textStack, meta);
                    textStack[0] += `</th>`;
                }

                textStack[0] += "</tr>";
            }

            textStack[0] += "</thead>";
        }

        textStack[0] += bodyStack[0];

        if (entry.footnotes != null) {
            textStack[0] += "<tfoot>";
            const len = entry.footnotes.length;
            for (let i = 0; i < len; ++i) {
                textStack[0] += `<tr><td colspan="99">`;
                const cacheDepth = this._adjustDepth(meta, 1);
                this._recursiveRender(entry.footnotes[i], textStack, meta);
                meta.depth = cacheDepth;
                textStack[0] += "</td></tr>";
            }
            textStack[0] += "</tfoot>";
        }
        textStack[0] += "</table>";

        if (entry.outro) {
            const len = entry.outro.length;
            for (let i = 0; i < len; ++i) {
                this._recursiveRender(entry.outro[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
            }
        }
    }
    ;

    this._renderTable_getCellDataStr = function(ent) {
        function convertZeros(num) {
            if (num === 0)
                return 100;
            return num;
        }

        if (ent.roll) {
            return `data-roll-min="${convertZeros(ent.roll.exact != null ? ent.roll.exact : ent.roll.min)}" data-roll-max="${convertZeros(ent.roll.exact != null ? ent.roll.exact : ent.roll.max)}"`;
        }

        return "";
    }
    ;

    this._renderTable_getTableThClassText = function(entry, i) {
        return entry.colStyles == null || i >= entry.colStyles.length ? "" : `class="${this._getMutatedStyleString(entry.colStyles[i])}"`;
    }
    ;

    this._renderTable_makeTableTdClassText = function(entry, i) {
        if (entry.rowStyles != null)
            return i >= entry.rowStyles.length ? "" : `class="${this._getMutatedStyleString(entry.rowStyles[i])}"`;
        else
            return this._renderTable_getTableThClassText(entry, i);
    }
    ;

    this._renderEntries = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, true);
    }
    ;

    this._getPagePart = function(entry, isInset) {
        if (!Renderer.utils.isDisplayPage(entry.page))
            return "";
        return ` <span class="rd__title-link ${isInset ? `rd__title-link--inset` : ""}">${entry.source ? `<span class="help-subtle" title="${Parser.sourceJsonToFull(entry.source)}">${Parser.sourceJsonToAbv(entry.source)}</span> ` : ""}p${entry.page}</span>`;
    }
    ;

    this._renderEntriesSubtypes = function(entry, textStack, meta, options, incDepth) {
        const type = entry.type || "entries";
        const isInlineTitle = meta.depth >= 2;
        const isAddPeriod = isInlineTitle && entry.name && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
        const pagePart = !this._isPartPageExpandCollapseDisabled && !isInlineTitle ? this._getPagePart(entry) : "";
        const partExpandCollapse = !this._isPartPageExpandCollapseDisabled && !isInlineTitle ? `<span class="rd__h-toggle ml-2 clickable no-select" data-rd-h-toggle-button="true" title="Toggle Visibility (CTRL to Toggle All)">[\u2013]</span>` : "";
        const partPageExpandCollapse = !this._isPartPageExpandCollapseDisabled && (pagePart || partExpandCollapse) ? `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>` : "";
        const nextDepth = incDepth && meta.depth < 2 ? meta.depth + 1 : meta.depth;
        const styleString = this._renderEntriesSubtypes_getStyleString(entry, meta, isInlineTitle);
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);

        const headerTag = isInlineTitle ? "span" : `h${Math.min(Math.max(meta.depth + 2, 1), 6)}`;
        const headerClass = `rd__h--${meta.depth + 1}`;
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, meta.depth);

        const pluginDataNamePrefix = this._getPlugins(`${type}_namePrefix`).map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);

        const headerSpan = entry.name ? `<${headerTag} class="rd__h ${headerClass}" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}> <span class="entry-title-inner${!pagePart && entry.source ? ` help-subtle` : ""}"${!pagePart && entry.source ? ` title="Source: ${Parser.sourceJsonToFull(entry.source)}${entry.page ? `, p${entry.page}` : ""}"` : ""}>${pluginDataNamePrefix.join("")}${this.render({
            type: "inline",
            entries: [entry.name]
        })}${isAddPeriod ? "." : ""}</span>${partPageExpandCollapse}</${headerTag}> ` : "";

        if (meta.depth === -1) {
            if (!this._firstSection)
                textStack[0] += `<hr class="rd__hr rd__hr--section">`;
            this._firstSection = false;
        }

        if (entry.entries || entry.name) {
            textStack[0] += `<${this.wrapperTag} ${dataString} ${styleString}>${headerSpan}`;
            this._renderEntriesSubtypes_renderPreReqText(entry, textStack, meta);
            if (entry.entries) {
                const cacheDepth = meta.depth;
                const len = entry.entries.length;
                for (let i = 0; i < len; ++i) {
                    meta.depth = nextDepth;
                    this._recursiveRender(entry.entries[i], textStack, meta, {
                        prefix: "<p>",
                        suffix: "</p>"
                    });
                    if (i === 0 && cacheDepth >= 2)
                        textStack[0] += `<div class="rd__spc-inline-post"></div>`;
                }
                meta.depth = cacheDepth;
            }
            textStack[0] += `</${this.wrapperTag}>`;
        }

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderEntriesSubtypes_getDataString = function(entry) {
        let dataString = "";
        if (entry.source)
            dataString += `data-source="${entry.source}"`;
        if (entry.data) {
            for (const k in entry.data) {
                if (!k.startsWith("rd-"))
                    continue;
                dataString += ` data-${k}="${`${entry.data[k]}`.escapeQuotes()}"`;
            }
        }
        return dataString;
    }
    ;

    this._renderEntriesSubtypes_renderPreReqText = function(entry, textStack, meta) {
        if (entry.prerequisite) {
            textStack[0] += `<span class="rd__prerequisite">Prerequisite: `;
            this._recursiveRender({
                type: "inline",
                entries: [entry.prerequisite]
            }, textStack, meta);
            textStack[0] += `</span>`;
        }
    }
    ;

    this._renderEntriesSubtypes_getStyleString = function(entry, meta, isInlineTitle) {
        const styleClasses = ["rd__b"];
        styleClasses.push(this._getStyleClass(entry.type || "entries", entry));
        if (isInlineTitle) {
            if (this._subVariant)
                styleClasses.push(Renderer.HEAD_2_SUB_VARIANT);
            else
                styleClasses.push(Renderer.HEAD_2);
        } else
            styleClasses.push(meta.depth === -1 ? Renderer.HEAD_NEG_1 : meta.depth === 0 ? Renderer.HEAD_0 : Renderer.HEAD_1);
        return styleClasses.length > 0 ? `class="${styleClasses.join(" ")}"` : "";
    }
    ;

    this._renderOptions = function(entry, textStack, meta, options) {
        if (!entry.entries)
            return;
        entry.entries = entry.entries.sort((a,b)=>a.name && b.name ? SortUtil.ascSort(a.name, b.name) : a.name ? -1 : b.name ? 1 : 0);

        if (entry.style && entry.style === "list-hang-notitle") {
            const fauxEntry = {
                type: "list",
                style: "list-hang-notitle",
                items: entry.entries.map(ent=>{
                    if (typeof ent === "string")
                        return ent;
                    if (ent.type === "item")
                        return ent;

                    const out = {
                        ...ent,
                        type: "item"
                    };
                    if (ent.name)
                        out.name = Renderer._INLINE_HEADER_TERMINATORS.has(ent.name[ent.name.length - 1]) ? out.name : `${out.name}.`;
                    return out;
                }
                ),
            };
            this._renderList(fauxEntry, textStack, meta, options);
        } else
            this._renderEntriesSubtypes(entry, textStack, meta, options, false);
    }
    ;

    this._renderList = function(entry, textStack, meta, options) {
        if (entry.items) {
            const tag = entry.start ? "ol" : "ul";
            const cssClasses = this._renderList_getListCssClasses(entry, textStack, meta, options);
            textStack[0] += `<${tag} ${cssClasses ? `class="${cssClasses}"` : ""} ${entry.start ? `start="${entry.start}"` : ""}>`;
            if (entry.name)
                textStack[0] += `<li class="rd__list-name">${entry.name}</li>`;
            const isListHang = entry.style && entry.style.split(" ").includes("list-hang");
            const len = entry.items.length;
            for (let i = 0; i < len; ++i) {
                const item = entry.items[i];
                if (item.type !== "list") {
                    const className = `${this._getStyleClass(entry.type, item)}${item.type === "itemSpell" ? " rd__li-spell" : ""}`;
                    textStack[0] += `<li class="rd__li ${className}">`;
                }
                if (isListHang && typeof item === "string")
                    textStack[0] += "<div>";
                this._recursiveRender(item, textStack, meta);
                if (isListHang && typeof item === "string")
                    textStack[0] += "</div>";
                if (item.type !== "list")
                    textStack[0] += "</li>";
            }
            textStack[0] += `</${tag}>`;
        }
    }
    ;

    this._getPtExpandCollapseSpecial = function() {
        return `<span class="rd__h-toggle ml-2 clickable no-select" data-rd-h-special-toggle-button="true" title="Toggle Visibility (CTRL to Toggle All)">[\u2013]</span>`;
    }
    ;

    this._renderInset = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset ${this._getMutatedStyleString(entry.style || "")}" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4>${partPageExpandCollapse}</span>`;
        } else {
            textStack[0] += `<span class="rd__h rd__h--2-inset rd__h--2-inset-no-name">${partPageExpandCollapse}</span>`;
        }

        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i) {
                const cacheDepth = meta.depth;
                meta.depth = 2;
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
                meta.depth = cacheDepth;
            }
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderInsetReadaloud = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset rd__b-inset--readaloud ${this._getMutatedStyleString(entry.style || "")}" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4>${this._getPagePart(entry, true)}</span>`;
        } else {
            textStack[0] += `<span class="rd__h rd__h--2-inset rd__h--2-inset-no-name">${partPageExpandCollapse}</span>`;
        }

        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariant = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset" ${dataString}>`;
        textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">Variant: ${entry.name}</h4>${partPageExpandCollapse}</span>`;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        if (entry.source)
            textStack[0] += Renderer.utils.getSourceAndPageTrHtml({
                source: entry.source,
                page: entry.page
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariantInner = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        textStack[0] += `<${this.wrapperTag} class="rd__b-inset-inner" ${dataString}>`;
        textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4></span>`;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        if (entry.source)
            textStack[0] += Renderer.utils.getSourceAndPageTrHtml({
                source: entry.source,
                page: entry.page
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariantSub = function(entry, textStack, meta, options) {
        this._subVariant = true;
        const fauxEntry = entry;
        fauxEntry.type = "entries";
        const cacheDepth = meta.depth;
        meta.depth = 3;
        this._recursiveRender(fauxEntry, textStack, meta, {
            prefix: "<p>",
            suffix: "</p>"
        });
        meta.depth = cacheDepth;
        this._subVariant = false;
    }
    ;

    this._renderSpellcasting_getEntries = function(entry) {
        const hidden = new Set(entry.hidden || []);
        const toRender = [{
            type: "entries",
            name: entry.name,
            entries: entry.headerEntries ? MiscUtil.copyFast(entry.headerEntries) : []
        }];

        if (entry.constant || entry.will || entry.recharge || entry.charges || entry.rest || entry.daily || entry.weekly || entry.yearly || entry.ritual) {
            const tempList = {
                type: "list",
                style: "list-hang-notitle",
                items: [],
                data: {
                    isSpellList: true
                }
            };
            if (entry.constant && !hidden.has("constant"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `Constant:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.constant).join(", ")
                });
            if (entry.will && !hidden.has("will"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `At will:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.will).join(", ")
                });

            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "recharge",
                fnGetDurationText: num=>`{@recharge ${num}|m}`,
                isSkipPrefix: true
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "charges",
                fnGetDurationText: num=>` charge${num === 1 ? "" : "s"}`
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "rest",
                durationText: "/rest"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "daily",
                durationText: "/day"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "weekly",
                durationText: "/week"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "yearly",
                durationText: "/year"
            });

            if (entry.ritual && !hidden.has("ritual"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `Rituals:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.ritual).join(", ")
                });
            tempList.items = tempList.items.filter(it=>it.entry !== "");
            if (tempList.items.length)
                toRender[0].entries.push(tempList);
        }

        if (entry.spells && !hidden.has("spells")) {
            const tempList = {
                type: "list",
                style: "list-hang-notitle",
                items: [],
                data: {
                    isSpellList: true
                }
            };

            const lvls = Object.keys(entry.spells).map(lvl=>Number(lvl)).sort(SortUtil.ascSort);

            for (const lvl of lvls) {
                const spells = entry.spells[lvl];
                if (spells) {
                    let levelCantrip = `${Parser.spLevelToFull(lvl)}${(lvl === 0 ? "s" : " level")}`;
                    let slotsAtWill = ` (at will)`;
                    const slots = spells.slots;
                    if (slots >= 0)
                        slotsAtWill = slots > 0 ? ` (${slots} slot${slots > 1 ? "s" : ""})` : ``;
                    if (spells.lower && spells.lower !== lvl) {
                        levelCantrip = `${Parser.spLevelToFull(spells.lower)}-${levelCantrip}`;
                        if (slots >= 0)
                            slotsAtWill = slots > 0 ? ` (${slots} ${Parser.spLevelToFull(lvl)}-level slot${slots > 1 ? "s" : ""})` : ``;
                    }
                    tempList.items.push({
                        type: "itemSpell",
                        name: `${levelCantrip}${slotsAtWill}:`,
                        entry: this._renderSpellcasting_getRenderableList(spells.spells).join(", ") || "\u2014"
                    });
                }
            }

            toRender[0].entries.push(tempList);
        }

        if (entry.footerEntries)
            toRender.push({
                type: "entries",
                entries: entry.footerEntries
            });
        return toRender;
    }
    ;

    this._renderSpellcasting_getEntries_procPerDuration = function({entry, hidden, tempList, prop, durationText, fnGetDurationText, isSkipPrefix}) {
        if (!entry[prop] || hidden.has(prop))
            return;

        for (let lvl = 9; lvl > 0; lvl--) {
            const perDur = entry[prop];
            if (perDur[lvl]) {
                tempList.items.push({
                    type: "itemSpell",
                    name: `${isSkipPrefix ? "" : lvl}${fnGetDurationText ? fnGetDurationText(lvl) : durationText}:`,
                    entry: this._renderSpellcasting_getRenderableList(perDur[lvl]).join(", "),
                });
            }

            const lvlEach = `${lvl}e`;
            if (perDur[lvlEach]) {
                const isHideEach = !perDur[lvl] && perDur[lvlEach].length === 1;
                tempList.items.push({
                    type: "itemSpell",
                    name: `${isSkipPrefix ? "" : lvl}${fnGetDurationText ? fnGetDurationText(lvl) : durationText}${isHideEach ? "" : ` each`}:`,
                    entry: this._renderSpellcasting_getRenderableList(perDur[lvlEach]).join(", "),
                });
            }
        }
    }
    ;

    this._renderSpellcasting_getRenderableList = function(spellList) {
        return spellList.filter(it=>!it.hidden).map(it=>it.entry || it);
    }
    ;

    this._renderSpellcasting = function(entry, textStack, meta, options) {
        const toRender = this._renderSpellcasting_getEntries(entry);
        if (!toRender?.[0].entries?.length)
            return;
        this._recursiveRender({
            type: "entries",
            entries: toRender
        }, textStack, meta);
    }
    ;

    this._renderQuote = function(entry, textStack, meta, options) {
        textStack[0] += `<div class="${this._renderList_getQuoteCssClasses(entry, textStack, meta, options)}">`;

        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            textStack[0] += `<p class="rd__quote-line ${i === len - 1 && entry.by ? `rd__quote-line--last` : ""}">${i === 0 && !entry.skipMarks ? "&ldquo;" : ""}`;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: entry.skipItalics ? "" : "<i>",
                suffix: entry.skipItalics ? "" : "</i>"
            });
            textStack[0] += `${i === len - 1 && !entry.skipMarks ? "&rdquo;" : ""}</p>`;
        }

        if (entry.by || entry.from) {
            textStack[0] += `<p>`;
            const tempStack = [""];
            const byArr = this._renderQuote_getBy(entry);
            if (byArr) {
                for (let i = 0, len = byArr.length; i < len; ++i) {
                    const by = byArr[i];
                    this._recursiveRender(by, tempStack, meta);
                    if (i < len - 1)
                        tempStack[0] += "<br>";
                }
            }
            textStack[0] += `<span class="rd__quote-by">\u2014 ${byArr ? tempStack.join("") : ""}${byArr && entry.from ? `, ` : ""}${entry.from ? `<i>${entry.from}</i>` : ""}</span>`;
            textStack[0] += `</p>`;
        }

        textStack[0] += `</div>`;
    }
    ;

    this._renderList_getQuoteCssClasses = function(entry, textStack, meta, options) {
        const out = [`rd__quote`];
        if (entry.style) {
            if (entry.style)
                out.push(...entry.style.split(" ").map(it=>`rd__${it}`));
        }
        return out.join(" ");
    }
    ;

    this._renderQuote_getBy = function(entry) {
        if (!entry.by?.length)
            return null;
        return entry.by instanceof Array ? entry.by : [entry.by];
    }
    ;

    this._renderOptfeature = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, true);
    }
    ;

    this._renderPatron = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, false);
    }
    ;

    this._renderAbilityDc = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center"><b>`;
        this._recursiveRender(entry.name, textStack, meta);
        textStack[0] += ` save DC</b> = 8 + your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderAbilityAttackMod = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center"><b>`;
        this._recursiveRender(entry.name, textStack, meta);
        textStack[0] += ` attack modifier</b> = your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderAbilityGeneric = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center">`;
        if (entry.name)
            this._recursiveRender(entry.name, textStack, meta, {
                prefix: "<b>",
                suffix: "</b> = "
            });
        textStack[0] += `${entry.text}${entry.attributes ? ` ${Parser.attrChooseToFull(entry.attributes)}` : ""}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderInline = function(entry, textStack, meta, options) {
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta);
        }
    }
    ;

    this._renderInlineBlock = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta);
        }
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderBonus = function(entry, textStack, meta, options) {
        textStack[0] += (entry.value < 0 ? "" : "+") + entry.value;
    }
    ;

    this._renderBonusSpeed = function(entry, textStack, meta, options) {
        textStack[0] += entry.value === 0 ? "\u2014" : `${entry.value < 0 ? "" : "+"}${entry.value} ft.`;
    }
    ;

    this._renderDice = function(entry, textStack, meta, options) {
        const pluginResults = this._getPlugins("dice").map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);

        textStack[0] += Renderer.getEntryDice(entry, entry.name, {
            isAddHandlers: this._isAddHandlers,
            pluginResults
        });
    }
    ;

    this._renderActions = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 2);

        textStack[0] += `<${this.wrapperTag} class="${Renderer.HEAD_2}" ${dataString}><span class="rd__h rd__h--3" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><span class="entry-title-inner">${entry.name}.</span></span> `;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderAttack = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<i>${Parser.attackTypeToFull(entry.attackType)}:</i> `;
        const len = entry.attackEntries.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.attackEntries[i], textStack, meta);
        textStack[0] += ` <i>Hit:</i> `;
        const len2 = entry.hitEntries.length;
        for (let i = 0; i < len2; ++i)
            this._recursiveRender(entry.hitEntries[i], textStack, meta);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderIngredient = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        this._recursiveRender(entry.entry, textStack, meta);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItem = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<p class="rd__p-list-item"><span class="${this._getMutatedStyleString(entry.style) || "bold"} rd__list-item-name">${this.render(entry.name)}${this._renderItem_isAddPeriod(entry) ? "." : ""}</span> `;
        if (entry.entry)
            this._recursiveRender(entry.entry, textStack, meta);
        else if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: i > 0 ? `<span class="rd__p-cont-indent">` : "",
                    suffix: i > 0 ? "</span>" : ""
                });
        }
        textStack[0] += "</p>";
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItem_isAddPeriod = function(entry) {
        return entry.name && entry.nameDot !== false && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
    }
    ;

    this._renderItemSub = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        const isAddPeriod = entry.name && entry.nameDot !== false && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
        this._recursiveRender(entry.entry, textStack, meta, {
            prefix: `<p class="rd__p-list-item"><span class="italic rd__list-item-name">${entry.name}${isAddPeriod ? "." : ""}</span> `,
            suffix: "</p>"
        });
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItemSpell = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);

        const tempStack = [""];
        this._recursiveRender(entry.name || "", tempStack, meta);

        this._recursiveRender(entry.entry, textStack, meta, {
            prefix: `<p>${tempStack.join("")} `,
            suffix: "</p>"
        });
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._InlineStatblockStrategy = function({pFnPreProcess, }, ) {
        this.pFnPreProcess = pFnPreProcess;
    }
    ;

    this._INLINE_STATBLOCK_STRATEGIES = {
        "item": new this._InlineStatblockStrategy({
            pFnPreProcess: async(ent)=>{
                await Renderer.item.pPopulatePropertyAndTypeReference();
                Renderer.item.enhanceItem(ent);
                return ent;
            }
            ,
        }),
    };

    this._renderStatblockInline = function(entry, textStack, meta, options) {
        const fnGetRenderCompact = Renderer.hover.getFnRenderCompact(entry.dataType);

        const headerName = entry.displayName || entry.data?.name;
        const headerStyle = entry.style;

        if (!fnGetRenderCompact) {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderDataHeader(textStack, headerName, headerStyle);
            textStack[0] += `<tr>
				<td colspan="6">
					<i class="text-danger">Cannot render &quot;${entry.type}&quot;&mdash;unknown data type &quot;${entry.dataType}&quot;!</i>
				</td>
			</tr>`;
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);
            return;
        }

        const strategy = this._INLINE_STATBLOCK_STRATEGIES[entry.dataType];

        if (!strategy?.pFnPreProcess && !entry.data?._copy) {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderDataHeader(textStack, headerName, headerStyle, {
                isCollapsed: entry.collapsed
            });
            textStack[0] += fnGetRenderCompact(entry.data, {
                isEmbeddedEntity: true
            });
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);
            return;
        }

        this._renderPrefix(entry, textStack, meta, options);
        this._renderDataHeader(textStack, headerName, headerStyle, {
            isCollapsed: entry.collapsed
        });

        const id = CryptUtil.uid();
        Renderer._cache.inlineStatblock[id] = {
            pFn: async(ele)=>{
                const entLoaded = entry.data?._copy ? (await DataUtil.pDoMetaMergeSingle(entry.dataType, {
                    dependencies: {
                        [entry.dataType]: entry.dependencies
                    }
                }, entry.data, )) : entry.data;

                const ent = strategy?.pFnPreProcess ? await strategy.pFnPreProcess(entLoaded) : entLoaded;

                const tbl = ele.closest("table");
                const nxt = e_({
                    outer: Renderer.utils.getEmbeddedDataHeader(headerName, headerStyle, {
                        isCollapsed: entry.collapsed
                    }) + fnGetRenderCompact(ent, {
                        isEmbeddedEntity: true
                    }) + Renderer.utils.getEmbeddedDataFooter(),
                });
                tbl.parentNode.replaceChild(nxt, tbl, );
            }
            ,
        };

        textStack[0] += `<tr><td colspan="6"><style data-rd-cache-id="${id}" data-rd-cache="inlineStatblock" onload="Renderer._cache.pRunFromEle(this)"></style></td></tr>`;
        this._renderDataFooter(textStack);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderDataHeader = function(textStack, name, style, {isCollapsed=false}={}) {
        textStack[0] += Renderer.utils.getEmbeddedDataHeader(name, style, {
            isCollapsed
        });
    }
    ;

    this._renderDataFooter = function(textStack) {
        textStack[0] += Renderer.utils.getEmbeddedDataFooter();
    }
    ;

    this._renderStatblock = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);

        const page = entry.prop || Renderer.tag.getPage(entry.tag);
        const source = Parser.getTagSource(entry.tag, entry.source);
        const hash = entry.hash || (UrlUtil.URL_TO_HASH_BUILDER[page] ? UrlUtil.URL_TO_HASH_BUILDER[page]({
            ...entry,
            name: entry.name,
            source
        }) : null);

        const asTag = `{@${entry.tag} ${entry.name}|${source}${entry.displayName ? `|${entry.displayName}` : ""}}`;

        if (!page || !source || !hash) {
            this._renderDataHeader(textStack, entry.name, entry.style);
            textStack[0] += `<tr>
				<td colspan="6">
					<i class="text-danger">Cannot load ${entry.tag ? `&quot;${asTag}&quot;` : entry.displayName || entry.name}! An unknown tag/prop, source, or hash was provided.</i>
				</td>
			</tr>`;
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);

            return;
        }

        this._renderDataHeader(textStack, entry.displayName || entry.name, entry.style, {
            isCollapsed: entry.collapsed
        });
        textStack[0] += `<tr>
			<td colspan="6" data-rd-tag="${(entry.tag || "").qq()}" data-rd-page="${(page || "").qq()}" data-rd-source="${(source || "").qq()}" data-rd-hash="${(hash || "").qq()}" data-rd-name="${(entry.name || "").qq()}" data-rd-display-name="${(entry.displayName || "").qq()}" data-rd-style="${(entry.style || "").qq()}">
				<i>Loading ${entry.tag ? `${Renderer.get().render(asTag)}` : entry.displayName || entry.name}...</i>
				<style onload="Renderer.events.handleLoad_inlineStatblock(this)"></style>
			</td>
		</tr>`;
        this._renderDataFooter(textStack);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderGallery = function(entry, textStack, meta, options) {
        if (entry.name)
            textStack[0] += `<h5 class="rd__gallery-name">${entry.name}</h5>`;
        textStack[0] += `<div class="rd__wrp-gallery">`;
        const len = entry.images.length;
        const anyNamed = entry.images.some(it=>it.title);
        const isAnyCredited = entry.images.some(it=>it.credit);
        for (let i = 0; i < len; ++i) {
            const img = MiscUtil.copyFast(entry.images[i]);

            if (anyNamed && !img.title)
                img._galleryTitlePad = true;
            if (isAnyCredited && !img.credit)
                img._galleryCreditPad = true;

            delete img.imageType;
            this._recursiveRender(img, textStack, meta, options);
        }
        textStack[0] += `</div>`;
    }
    ;

    this._renderFlowchart = function(entry, textStack, meta, options) {
        textStack[0] += `<div class="rd__wrp-flowchart">`;
        const len = entry.blocks.length;
        for (let i = 0; i < len; ++i) {
            this._recursiveRender(entry.blocks[i], textStack, meta, options);
            if (i !== len - 1) {
                textStack[0] += `<div class="rd__s-v-flow"></div>`;
            }
        }
        textStack[0] += `</div>`;
    }
    ;

    this._renderFlowBlock = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-flow ve-text-center" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-flow-block" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${this.render({
                type: "inline",
                entries: [entry.name]
            })}</h4></span>`;
        }
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i) {
                const cacheDepth = meta.depth;
                meta.depth = 2;
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
                meta.depth = cacheDepth;
            }
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderHomebrew = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="homebrew-section"><div class="homebrew-float"><span class="homebrew-notice"></span>`;

        if (entry.oldEntries) {
            const hoverMeta = Renderer.hover.getInlineHover({
                type: "entries",
                name: "Homebrew",
                entries: entry.oldEntries
            });
            let markerText;
            if (entry.movedTo) {
                markerText = "(See moved content)";
            } else if (entry.entries) {
                markerText = "(See replaced content)";
            } else {
                markerText = "(See removed content)";
            }
            textStack[0] += `<span class="homebrew-old-content" href="#${window.location.hash}" ${hoverMeta.html}>${markerText}</span>`;
        }

        textStack[0] += `</div>`;

        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
        } else if (entry.movedTo) {
            textStack[0] += `<i>This content has been moved to ${entry.movedTo}.</i>`;
        } else {
            textStack[0] += "<i>This content has been deleted.</i>";
        }

        textStack[0] += `</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderCode = function(entry, textStack, meta, options) {
        const isWrapped = !!StorageUtil.syncGet("rendererCodeWrap");
        textStack[0] += `
			<div class="ve-flex-col h-100">
				<div class="ve-flex no-shrink pt-1">
					<button class="btn btn-default btn-xs mb-1 mr-2" onclick="Renderer.events.handleClick_copyCode(event, this)">Copy Code</button>
					<button class="btn btn-default btn-xs mb-1 ${isWrapped ? "active" : ""}" onclick="Renderer.events.handleClick_toggleCodeWrap(event, this)">Word Wrap</button>
				</div>
				<pre class="h-100 w-100 mb-1 ${isWrapped ? "rd__pre-wrap" : ""}">${entry.preformatted}</pre>
			</div>
		`;
    }
    ;

    this._renderHr = function(entry, textStack, meta, options) {
        textStack[0] += `<hr class="rd__hr">`;
    }
    ;

    this._getStyleClass = function(entryType, entry) {
        const outList = [];

        const pluginResults = this._getPlugins(`${entryType}_styleClass_fromSource`).map(plugin=>plugin(entryType, entry)).filter(Boolean);

        if (!pluginResults.some(it=>it.isSkip)) {
            if (SourceUtil.isNonstandardSource(entry.source) || (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(entry.source)))
                outList.push("spicy-sauce");
            if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(entry.source))
                outList.push("refreshing-brew");
        }

        if (this._extraSourceClasses)
            outList.push(...this._extraSourceClasses);
        for (const k in this._fnsGetStyleClasses) {
            const fromFn = this._fnsGetStyleClasses[k](entry);
            if (fromFn)
                outList.push(...fromFn);
        }
        if (entry.style)
            outList.push(this._getMutatedStyleString(entry.style));
        return outList.join(" ");
    }
    ;

    this._renderString = function(entry, textStack, meta, options) {
        const tagSplit = Renderer.splitByTags(entry);
        const len = tagSplit.length;
        for (let i = 0; i < len; ++i) {
            const s = tagSplit[i];
            if (!s)
                continue;
            if (s.startsWith("{@")) {
                const [tag,text] = Renderer.splitFirstSpace(s.slice(1, -1));
                this._renderString_renderTag(textStack, meta, options, tag, text);
            } else
                textStack[0] += s;
        }
    }
    ;

    this._renderString_renderTag = function(textStack, meta, options, tag, text) {
        for (const plugin of this._getPlugins("string_tag")) {
            const out = plugin(tag, text, textStack, meta, options);
            if (out)
                return void (textStack[0] += out);
        }

        for (const plugin of this._getPlugins(`string_${tag}`)) {
            const out = plugin(tag, text, textStack, meta, options);
            if (out)
                return void (textStack[0] += out);
        }

        switch (tag) {
        case "@b":
        case "@bold":
            textStack[0] += `<b>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</b>`;
            break;
        case "@i":
        case "@italic":
            textStack[0] += `<i>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</i>`;
            break;
        case "@s":
        case "@strike":
            textStack[0] += `<s>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</s>`;
            break;
        case "@u":
        case "@underline":
            textStack[0] += `<u>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</u>`;
            break;
        case "@sup":
            textStack[0] += `<sup>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</sup>`;
            break;
        case "@sub":
            textStack[0] += `<sub>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</sub>`;
            break;
        case "@kbd":
            textStack[0] += `<kbd>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</kbd>`;
            break;
        case "@code":
            textStack[0] += `<span class="code">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@style":
            {
                const [displayText,styles] = Renderer.splitTagByPipe(text);
                const classNames = (styles || "").split(";").map(it=>Renderer._STYLE_TAG_ID_TO_STYLE[it.trim()]).filter(Boolean).join(" ");
                textStack[0] += `<span class="${classNames}">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@font":
            {
                const [displayText,fontFamily] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span style="font-family: '${fontFamily}'">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@note":
            textStack[0] += `<i class="ve-muted">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</i>`;
            break;
        case "@tip":
            {
                const [displayText,titielText] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span title="${titielText.qq()}">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@atk":
            textStack[0] += `<i>${Renderer.attackTagToFull(text)}</i>`;
            break;
        case "@h":
            textStack[0] += `<i>Hit:</i> `;
            break;
        case "@m":
            textStack[0] += `<i>Miss:</i> `;
            break;
        case "@color":
            {
                const [toDisplay,color] = Renderer.splitTagByPipe(text);
                const ptColor = this._renderString_renderTag_getBrewColorPart(color);

                textStack[0] += `<span class="rd__color" style="color: ${ptColor}">`;
                this._recursiveRender(toDisplay, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@highlight":
            {
                const [toDisplay,color] = Renderer.splitTagByPipe(text);
                const ptColor = this._renderString_renderTag_getBrewColorPart(color);

                textStack[0] += ptColor ? `<span style="background-color: ${ptColor}">` : `<span class="rd__highlight">`;
                textStack[0] += toDisplay;
                textStack[0] += `</span>`;
                break;
            }
        case "@help":
            {
                const [toDisplay,title=""] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span class="help" title="${title.qq()}">`;
                this._recursiveRender(toDisplay, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }

        case "@unit":
            {
                const [amount,unitSingle,unitPlural] = Renderer.splitTagByPipe(text);
                textStack[0] += isNaN(amount) ? unitSingle : Number(amount) > 1 ? (unitPlural || unitSingle.toPlural()) : unitSingle;
                break;
            }

        case "@comic":
            textStack[0] += `<span class="rd__comic">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH1":
            textStack[0] += `<span class="rd__comic rd__comic--h1">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH2":
            textStack[0] += `<span class="rd__comic rd__comic--h2">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH3":
            textStack[0] += `<span class="rd__comic rd__comic--h3">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH4":
            textStack[0] += `<span class="rd__comic rd__comic--h4">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicNote":
            textStack[0] += `<span class="rd__comic rd__comic--note">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;

        case "@dc":
            {
                const [dcText,displayText] = Renderer.splitTagByPipe(text);
                textStack[0] += `DC <span class="rd__dc">${displayText || dcText}</span>`;
                break;
            }

        case "@dcYourSpellSave":
            {
                const [displayText] = Renderer.splitTagByPipe(text);
                textStack[0] += displayText || "your spell save DC";
                break;
            }

        case "@dice":
        case "@autodice":
        case "@damage":
        case "@hit":
        case "@d20":
        case "@chance":
        case "@coinflip":
        case "@recharge":
        case "@ability":
        case "@savingThrow":
        case "@skillCheck":
            {
                const fauxEntry = Renderer.utils.getTagEntry(tag, text);

                if (tag === "@recharge") {
                    const [,flagsRaw] = Renderer.splitTagByPipe(text);
                    const flags = flagsRaw ? flagsRaw.split("") : null;
                    textStack[0] += `${flags && flags.includes("m") ? "" : "("}Recharge `;
                    this._recursiveRender(fauxEntry, textStack, meta);
                    textStack[0] += `${flags && flags.includes("m") ? "" : ")"}`;
                } else {
                    this._recursiveRender(fauxEntry, textStack, meta);
                }

                break;
            }

        case "@hitYourSpellAttack":
            this._renderString_renderTag_hitYourSpellAttack(textStack, meta, options, tag, text);
            break;

        case "@scaledice":
        case "@scaledamage":
            {
                const fauxEntry = Renderer.parseScaleDice(tag, text);
                this._recursiveRender(fauxEntry, textStack, meta);
                break;
            }

        case "@filter":
            {
                const [displayText,page,...filters] = Renderer.splitTagByPipe(text);

                const filterSubhashMeta = Renderer.getFilterSubhashes(filters);

                const fauxEntry = {
                    type: "link",
                    text: displayText,
                    href: {
                        type: "internal",
                        path: `${page}.html`,
                        hash: HASH_BLANK,
                        hashPreEncoded: true,
                        subhashes: filterSubhashMeta.subhashes,
                    },
                };

                if (filterSubhashMeta.customHash)
                    fauxEntry.href.hash = filterSubhashMeta.customHash;

                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        case "@link":
            {
                const [displayText,url] = Renderer.splitTagByPipe(text);
                let outUrl = url == null ? displayText : url;
                if (!outUrl.startsWith("http"))
                    outUrl = `http://${outUrl}`;
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "external",
                        url: outUrl,
                    },
                    text: displayText,
                };
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        case "@5etools":
            {
                const [displayText,page,hash] = Renderer.splitTagByPipe(text);
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                    },
                    text: displayText,
                };
                if (hash) {
                    fauxEntry.hash = hash;
                    fauxEntry.hashPreEncoded = true;
                }
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }

        case "@footnote":
            {
                const [displayText,footnoteText,optTitle] = Renderer.splitTagByPipe(text);
                const hoverMeta = Renderer.hover.getInlineHover({
                    type: "entries",
                    name: optTitle ? optTitle.toTitleCase() : "Footnote",
                    entries: [footnoteText, optTitle ? `{@note ${optTitle}}` : ""].filter(Boolean),
                });
                textStack[0] += `<span class="help" ${hoverMeta.html}>`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;

                break;
            }
        case "@homebrew":
            {
                const [newText,oldText] = Renderer.splitTagByPipe(text);
                const tooltipEntries = [];
                if (newText && oldText) {
                    tooltipEntries.push("{@b This is a homebrew addition, replacing the following:}");
                } else if (newText) {
                    tooltipEntries.push("{@b This is a homebrew addition.}");
                } else if (oldText) {
                    tooltipEntries.push("{@b The following text has been removed with this homebrew:}");
                }
                if (oldText) {
                    tooltipEntries.push(oldText);
                }
                const hoverMeta = Renderer.hover.getInlineHover({
                    type: "entries",
                    name: "Homebrew Modifications",
                    entries: tooltipEntries,
                });
                textStack[0] += `<span class="homebrew-inline" ${hoverMeta.html}>`;
                this._recursiveRender(newText || "[...]", textStack, meta);
                textStack[0] += `</span>`;

                break;
            }
        case "@area":
            {
                const {areaId, displayText} = Renderer.tag.TAG_LOOKUP.area.getMeta(tag, text);

                if (typeof BookUtil === "undefined") {
                    textStack[0] += displayText;
                } else {
                    const area = BookUtil.curRender.headerMap[areaId] || {
                        entry: {
                            name: ""
                        }
                    };
                    const hoverMeta = Renderer.hover.getInlineHover(area.entry, {
                        isLargeBookContent: true,
                        depth: area.depth
                    });
                    textStack[0] += `<a href="#${BookUtil.curRender.curBookId},${area.chapter},${UrlUtil.encodeForHash(area.entry.name)},0" ${hoverMeta.html}>${displayText}</a>`;
                }

                break;
            }

        case "@loader":
            {
                const {name, path, mode} = this._renderString_getLoaderTagMeta(text);

                const brewUtilName = mode === "homebrew" ? "BrewUtil2" : mode === "prerelease" ? "PrereleaseUtil" : null;
                const brewUtil = globalThis[brewUtilName];

                if (!brewUtil) {
                    textStack[0] += `<span class="text-danger" title="Unknown loader mode &quot;${mode.qq()}&quot;!">${name}<span class="glyphicon glyphicon-alert rd__loadbrew-icon rd__loadbrew-icon"></span></span>`;

                    break;
                }

                textStack[0] += `<span onclick="${brewUtilName}.pAddBrewFromLoaderTag(this)" data-rd-loader-path="${path.escapeQuotes()}" data-rd-loader-name="${name.escapeQuotes()}" class="rd__wrp-loadbrew--ready" title="Click to install ${brewUtil.DISPLAY_NAME}">${name}<span class="glyphicon glyphicon-download-alt rd__loadbrew-icon rd__loadbrew-icon"></span></span>`;
                break;
            }

        case "@book":
        case "@adventure":
            {
                const page = tag === "@book" ? "book.html" : "adventure.html";
                const [displayText,book,chapter,section,rawNumber] = Renderer.splitTagByPipe(text);
                const number = rawNumber || 0;
                const hash = `${book}${chapter ? `${HASH_PART_SEP}${chapter}${section ? `${HASH_PART_SEP}${UrlUtil.encodeForHash(section)}${number != null ? `${HASH_PART_SEP}${UrlUtil.encodeForHash(number)}` : ""}` : ""}` : ""}`;
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                        hash,
                        hashPreEncoded: true,
                    },
                    text: displayText,
                };
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }

        default:
            {
                const {name, source, displayText, others, page, hash, hashPreEncoded, pageHover, hashHover, hashPreEncodedHover, preloadId, linkText, subhashes, subhashesHover, isFauxPage} = Renderer.utils.getTagMeta(tag, text);

                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                        hash,
                        hover: {
                            page,
                            isFauxPage,
                            source,
                        },
                    },
                    text: (displayText || name),
                };

                if (hashPreEncoded != null)
                    fauxEntry.href.hashPreEncoded = hashPreEncoded;
                if (pageHover != null)
                    fauxEntry.href.hover.page = pageHover;
                if (hashHover != null)
                    fauxEntry.href.hover.hash = hashHover;
                if (hashPreEncodedHover != null)
                    fauxEntry.href.hover.hashPreEncoded = hashPreEncodedHover;
                if (preloadId != null)
                    fauxEntry.href.hover.preloadId = preloadId;
                if (linkText)
                    fauxEntry.text = linkText;
                if (subhashes)
                    fauxEntry.href.subhashes = subhashes;
                if (subhashesHover)
                    fauxEntry.href.hover.subhashes = subhashesHover;

                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        }
    }
    ;

    this._renderString_renderTag_getBrewColorPart = function(color) {
        if (!color)
            return "";
        const scrubbedColor = BrewUtilShared.getValidColor(color, {
            isExtended: true
        });
        return scrubbedColor.startsWith("--") ? `var(${scrubbedColor})` : `#${scrubbedColor}`;
    }
    ;

    this._renderString_renderTag_hitYourSpellAttack = function(textStack, meta, options, tag, text) {
        const [displayText] = Renderer.splitTagByPipe(text);

        const fauxEntry = {
            type: "dice",
            rollable: true,
            subType: "d20",
            displayText: displayText || "your spell attack modifier",
            toRoll: `1d20 + #$prompt_number:title=Enter your Spell Attack Modifier$#`,
        };
        return this._recursiveRender(fauxEntry, textStack, meta);
    }
    ;

    this._renderString_getLoaderTagMeta = function(text, {isDefaultUrl=false}={}) {
        const [name,file,mode="homebrew"] = Renderer.splitTagByPipe(text);

        if (!isDefaultUrl)
            return {
                name,
                path: file,
                mode
            };

        const path = /^.*?:\/\//.test(file) ? file : `${VeCt.URL_ROOT_BREW}${file}`;
        return {
            name,
            path,
            mode
        };
    }
    ;

    this._renderPrimitive = function(entry, textStack, meta, options) {
        textStack[0] += entry;
    }
    ;

    this._renderLink = function(entry, textStack, meta, options) {
        let href = this._renderLink_getHref(entry);

        if (entry.href.hover && this._roll20Ids) {
            const procHash = UrlUtil.encodeForHash(entry.href.hash);
            const id = this._roll20Ids[procHash];
            if (id) {
                href = `http://journal.roll20.net/${id.type}/${id.roll20Id}`;
            }
        }

        const pluginData = this._getPlugins("link").map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);
        const isDisableEvents = pluginData.some(it=>it.isDisableEvents);
        const additionalAttributes = pluginData.map(it=>it.attributes).filter(Boolean);

        if (this._isInternalLinksDisabled && entry.href.type === "internal") {
            textStack[0] += `<span class="bold" ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</span>`;
        } else if (entry.href.hover?.isFauxPage) {
            textStack[0] += `<span class="help help--hover" ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</span>`;
        } else {
            textStack[0] += `<a href="${href.qq()}" ${entry.href.type === "internal" ? "" : `target="_blank" rel="noopener noreferrer"`} ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</a>`;
        }
    }
    ;

    this._renderLink_getHref = function(entry) {
        let href;
        if (entry.href.type === "internal") {
            href = `${this.baseUrl}${entry.href.path}#`;
            if (entry.href.hash != null) {
                href += entry.href.hashPreEncoded ? entry.href.hash : UrlUtil.encodeForHash(entry.href.hash);
            }
            if (entry.href.subhashes != null) {
                href += Renderer.utils.getLinkSubhashString(entry.href.subhashes);
            }
        } else if (entry.href.type === "external") {
            href = entry.href.url;
        }
        return href;
    }
    ;

    this._renderLink_getHoverString = function(entry) {
        if (!entry.href.hover || !this._isAddHandlers)
            return "";

        let procHash = entry.href.hover.hash ? entry.href.hover.hashPreEncoded ? entry.href.hover.hash : UrlUtil.encodeForHash(entry.href.hover.hash) : entry.href.hashPreEncoded ? entry.href.hash : UrlUtil.encodeForHash(entry.href.hash);

        if (this._tagExportDict) {
            this._tagExportDict[procHash] = {
                page: entry.href.hover.page,
                source: entry.href.hover.source,
                hash: procHash,
            };
        }

        if (entry.href.hover.subhashes) {
            procHash += Renderer.utils.getLinkSubhashString(entry.href.hover.subhashes);
        }

        const pluginData = this._getPlugins("link_attributesHover").map(plugin=>plugin(entry, procHash)).filter(Boolean);
        const replacementAttributes = pluginData.map(it=>it.attributesHoverReplace).filter(Boolean);
        if (replacementAttributes.length)
            return replacementAttributes.join(" ");

        return `onmouseover="Renderer.hover.pHandleLinkMouseOver(event, this)" onmouseleave="Renderer.hover.handleLinkMouseLeave(event, this)" onmousemove="Renderer.hover.handleLinkMouseMove(event, this)" data-vet-page="${entry.href.hover.page.qq()}" data-vet-source="${entry.href.hover.source.qq()}" data-vet-hash="${procHash.qq()}" ${entry.href.hover.preloadId != null ? `data-vet-preload-id="${`${entry.href.hover.preloadId}`.qq()}"` : ""} ${entry.href.hover.isFauxPage ? `data-vet-is-faux-page="true"` : ""} ${Renderer.hover.getPreventTouchString()}`;
    }
    ;

    this.render = function(entry, depth=0) {
        const tempStack = [];
        this.recursiveRender(entry, tempStack, {
            depth
        });
        return tempStack.join("");
    }
    ;
}
;

Renderer.generic = class {
    static getCompactRenderedString(ent, opts) {
        opts = opts || {};
        const prerequisite = Renderer.utils.prerequisite.getHtml(ent.prerequisite);

        return `
		${opts.dataProp && opts.page ? Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: opts.dataProp,
            page: opts.page
        }) : ""}
		${opts.isSkipNameRow ? "" : Renderer.utils.getNameTr(ent, {
            page: opts.page
        })}
		<tr class="text"><td colspan="6">
		${prerequisite ? `<p>${prerequisite}</p>` : ""}
		${Renderer.get().setFirstSection(true).render({
            entries: ent.entries
        })}
		</td></tr>
		${opts.isSkipPageRow ? "" : Renderer.utils.getPageTr(ent)}`;
    }

    static FEATURE__SKILLS_ALL = Object.keys(Parser.SKILL_TO_ATB_ABV).sort(SortUtil.ascSortLower);

    static FEATURE__TOOLS_ARTISANS = ["alchemist's supplies", "brewer's supplies", "calligrapher's supplies", "carpenter's tools", "cartographer's tools", "cobbler's tools", "cook's utensils", "glassblower's tools", "jeweler's tools", "leatherworker's tools", "mason's tools", "painter's supplies", "potter's tools", "smith's tools", "tinker's tools", "weaver's tools", "woodcarver's tools", ];
    static FEATURE__TOOLS_MUSICAL_INSTRUMENTS = ["bagpipes", "drum", "dulcimer", "flute", "horn", "lute", "lyre", "pan flute", "shawm", "viol", ];
    static FEATURE__TOOLS_ALL = ["artisan's tools",
    ...this.FEATURE__TOOLS_ARTISANS, ...this.FEATURE__TOOLS_MUSICAL_INSTRUMENTS,
    "disguise kit", "forgery kit", "gaming set", "herbalism kit", "musical instrument", "navigator's tools", "thieves' tools", "poisoner's kit", "vehicles (land)", "vehicles (water)", "vehicles (air)", "vehicles (space)", ];

    static FEATURE__LANGUAGES_ALL = Parser.LANGUAGES_ALL.map(it=>it.toLowerCase());
    static FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ = {
        from: [...Parser.LANGUAGES_STANDARD.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesStandard",
        })), ...Parser.LANGUAGES_EXOTIC.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesExotic",
        })), ...Parser.LANGUAGES_SECRET.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesSecret",
        })), ],
        groups: {
            languagesStandard: {
                name: "Standard Languages",
            },
            languagesExotic: {
                name: "Exotic Languages",
                hint: "With your DM's permission, you can choose an exotic language.",
            },
            languagesSecret: {
                name: "Secret Languages",
                hint: "With your DM's permission, you can choose a secret language.",
            },
        },
    };

    static FEATURE__SAVING_THROWS_ALL = [...Parser.ABIL_ABVS];

    static _SKILL_TOOL_LANGUAGE_KEYS__SKILL_ANY = new Set(["anySkill"]);
    static _SKILL_TOOL_LANGUAGE_KEYS__TOOL_ANY = new Set(["anyTool", "anyArtisansTool"]);
    static _SKILL_TOOL_LANGUAGE_KEYS__LANGAUGE_ANY = new Set(["anyLanguage", "anyStandardLanguage", "anyExoticLanguage"]);

    static getSkillSummary({skillProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: skillProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__SKILLS_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__SKILL_ANY,
            isShort,
            hoverTag: "skill",
        });
    }

    static getToolSummary({toolProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: toolProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__TOOLS_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__TOOL_ANY,
            isShort,
        });
    }

    static getLanguageSummary({languageProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: languageProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__LANGUAGES_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__LANGAUGE_ANY,
            isShort,
        });
    }

    static _summariseProfs({profGroupArr, skillToolLanguageProfs, setValid, setValidAny, isShort, hoverTag}) {
        if (!profGroupArr?.length && !skillToolLanguageProfs?.length)
            return {
                summary: "",
                collection: []
            };

        const collectionSet = new Set();

        const handleProfGroup = (profGroup,{isValidate=true}={})=>{
            let sep = ", ";

            const toJoin = Object.entries(profGroup).sort(([kA],[kB])=>this._summariseProfs_sortKeys(kA, kB)).filter(([k,v])=>v && (!isValidate || setValid.has(k) || setValidAny.has(k))).map(([k,v],i)=>{
                const vMapped = this.getMappedAnyProficiency({
                    keyAny: k,
                    countRaw: v
                }) ?? v;

                if (k === "choose") {
                    sep = "; ";

                    const chooseProfs = vMapped.from.filter(s=>!isValidate || setValid.has(s)).map(s=>{
                        collectionSet.add(s);
                        return this._summariseProfs_getEntry({
                            str: s,
                            isShort,
                            hoverTag
                        });
                    }
                    );
                    return `${isShort ? `${i === 0 ? "C" : "c"}hoose ` : ""}${v.count || 1} ${isShort ? `of` : `from`} ${chooseProfs.joinConjunct(", ", " or ")}`;
                }

                collectionSet.add(k);
                return this._summariseProfs_getEntry({
                    str: k,
                    isShort,
                    hoverTag
                });
            }
            );

            return toJoin.join(sep);
        }
        ;

        const summary = [...(profGroupArr || []).map(profGroup=>handleProfGroup(profGroup, {
            isValidate: false
        })), ...(skillToolLanguageProfs || []).map(profGroup=>handleProfGroup(profGroup)), ].filter(Boolean).join(` <i>or</i> `);

        return {
            summary,
            collection: [...collectionSet].sort(SortUtil.ascSortLower)
        };
    }

    static _summariseProfs_sortKeys(a, b, {setValidAny=null}={}) {
        if (a === b)
            return 0;
        if (a === "choose")
            return 2;
        if (b === "choose")
            return -2;
        if (setValidAny) {
            if (setValidAny.has(a))
                return 1;
            if (setValidAny.has(b))
                return -1;
        }
        return SortUtil.ascSort(a, b);
    }

    static _summariseProfs_getEntry({str, isShort, hoverTag}) {
        return isShort ? str.toTitleCase() : hoverTag ? `{@${hoverTag} ${str.toTitleCase()}}` : str.toTitleCase();
    }

    static getMappedAnyProficiency({keyAny, countRaw}) {
        const mappedCount = !isNaN(countRaw) ? Number(countRaw) : 1;
        if (mappedCount <= 0)
            return null;

        switch (keyAny) {
        case "anySkill":
            return {
                name: mappedCount === 1 ? `Any Skill` : `Any ${mappedCount} Skills`,
                from: this.FEATURE__SKILLS_ALL.map(it=>({
                    name: it,
                    prop: "skillProficiencies"
                })),
                count: mappedCount,
            };
        case "anyTool":
            return {
                name: mappedCount === 1 ? `Any Tool` : `Any ${mappedCount} Tools`,
                from: this.FEATURE__TOOLS_ALL.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyArtisansTool":
            return {
                name: mappedCount === 1 ? `Any Artisan's Tool` : `Any ${mappedCount} Artisan's Tools`,
                from: this.FEATURE__TOOLS_ARTISANS.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyMusicalInstrument":
            return {
                name: mappedCount === 1 ? `Any Musical Instrument` : `Any ${mappedCount} Musical Instruments`,
                from: this.FEATURE__TOOLS_MUSICAL_INSTRUMENTS.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyLanguage":
            return {
                name: mappedCount === 1 ? `Any Language` : `Any ${mappedCount} Languages`,
                from: this.FEATURE__LANGUAGES_ALL.map(it=>({
                    name: it,
                    prop: "languageProficiencies"
                })),
                count: mappedCount,
            };
        case "anyStandardLanguage":
            return {
                name: mappedCount === 1 ? `Any Standard Language` : `Any ${mappedCount} Standard Languages`,
                ...MiscUtil.copyFast(this.FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ),
                count: mappedCount,
            };
        case "anyExoticLanguage":
            return {
                name: mappedCount === 1 ? `Any Exotic Language` : `Any ${mappedCount} Exotic Languages`,
                ...MiscUtil.copyFast(this.FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ),
                count: mappedCount,
            };
        case "anySavingThrow":
            return {
                name: mappedCount === 1 ? `Any Saving Throw` : `Any ${mappedCount} Saving Throws`,
                from: this.FEATURE__SAVING_THROWS_ALL.map(it=>({
                    name: it,
                    prop: "savingThrowProficiencies"
                })),
                count: mappedCount,
            };

        case "anyWeapon":
            throw new Error(`Property handling for "anyWeapon" is unimplemented!`);
        case "anyArmor":
            throw new Error(`Property handling for "anyArmor" is unimplemented!`);

        default:
            return null;
        }
    }
};
Renderer.hover = {
    LinkMeta: function() {
        this.isHovered = false;
        this.isLoading = false;
        this.isPermanent = false;
        this.windowMeta = null;
    },

    _BAR_HEIGHT: 16,

    _linkCache: {},
    _eleCache: new Map(),
    _entryCache: {},
    _isInit: false,
    _dmScreen: null,
    _lastId: 0,
    _contextMenu: null,
    _contextMenuLastClicked: null,

    bindDmScreen(screen) {
        this._dmScreen = screen;
    },

    _getNextId() {
        return ++Renderer.hover._lastId;
    },

    _doInit() {
        if (!Renderer.hover._isInit) {
            Renderer.hover._isInit = true;

            $(document.body).on("click", ()=>Renderer.hover.cleanTempWindows());

            Renderer.hover._contextMenu = ContextUtil.getMenu([new ContextUtil.Action("Maximize All",()=>{
                const $permWindows = $(`.hoverborder[data-perm="true"]`);
                $permWindows.attr("data-display-title", "false");
            }
            ,), new ContextUtil.Action("Minimize All",()=>{
                const $permWindows = $(`.hoverborder[data-perm="true"]`);
                $permWindows.attr("data-display-title", "true");
            }
            ,), null, new ContextUtil.Action("Close Others",()=>{
                const hoverId = Renderer.hover._contextMenuLastClicked?.hoverId;
                Renderer.hover._doCloseAllWindows({
                    hoverIdBlocklist: new Set([hoverId])
                });
            }
            ,), new ContextUtil.Action("Close All",()=>Renderer.hover._doCloseAllWindows(),), ]);
        }
    },

    cleanTempWindows() {
        for (const [key,meta] of Renderer.hover._eleCache.entries()) {
            if (!meta.isPermanent && meta.windowMeta && typeof key === "number") {
                meta.windowMeta.doClose();
                Renderer.hover._eleCache.delete(key);
                return;
            }

            if (!meta.isPermanent && meta.windowMeta && !document.body.contains(key)) {
                meta.windowMeta.doClose();
                return;
            }

            if (!meta.isPermanent && meta.isHovered && meta.windowMeta) {
                const bounds = key.getBoundingClientRect();
                if (EventUtil._mouseX < bounds.x || EventUtil._mouseY < bounds.y || EventUtil._mouseX > bounds.x + bounds.width || EventUtil._mouseY > bounds.y + bounds.height) {
                    meta.windowMeta.doClose();
                }
            }
        }
    },

    _doCloseAllWindows({hoverIdBlocklist=null}={}) {
        Object.entries(Renderer.hover._WINDOW_METAS).filter(([hoverId,meta])=>hoverIdBlocklist == null || !hoverIdBlocklist.has(Number(hoverId))).forEach(([,meta])=>meta.doClose());
    },

    _getSetMeta(ele) {
        if (!Renderer.hover._eleCache.has(ele))
            Renderer.hover._eleCache.set(ele, new Renderer.hover.LinkMeta());
        return Renderer.hover._eleCache.get(ele);
    },

    _handleGenericMouseOverStart({evt, ele}) {
        if (Renderer.hover.isSmallScreen(evt) && !evt.shiftKey)
            return;

        Renderer.hover.cleanTempWindows();

        const meta = Renderer.hover._getSetMeta(ele);
        if (meta.isHovered || meta.isLoading)
            return;
        ele.style.cursor = "progress";

        meta.isHovered = true;
        meta.isLoading = true;
        meta.isPermanent = evt.shiftKey;

        return meta;
    },

    _doPredefinedShowStart({entryId}) {
        Renderer.hover.cleanTempWindows();

        const meta = Renderer.hover._getSetMeta(entryId);

        meta.isPermanent = true;

        return meta;
    },

    async pHandleLinkMouseOver(evt, ele, opts) {
        Renderer.hover._doInit();

        let page, source, hash, preloadId, customHashId, isFauxPage;
        if (opts) {
            page = opts.page;
            source = opts.source;
            hash = opts.hash;
            preloadId = opts.preloadId;
            customHashId = opts.customHashId;
            isFauxPage = !!opts.isFauxPage;
        } else {
            page = ele.dataset.vetPage;
            source = ele.dataset.vetSource;
            hash = ele.dataset.vetHash;
            preloadId = ele.dataset.vetPreloadId;
            isFauxPage = ele.dataset.vetIsFauxPage;
        }

        let meta = Renderer.hover._handleGenericMouseOverStart({
            evt,
            ele
        });
        if (meta == null)
            return;

        if ((EventUtil.isCtrlMetaKey(evt)) && Renderer.hover._pageToFluffFn(page))
            meta.isFluff = true;

        let toRender;
        if (preloadId != null) {
            switch (page) {
            case UrlUtil.PG_BESTIARY:
                {
                    const {_scaledCr: scaledCr, _scaledSpellSummonLevel: scaledSpellSummonLevel, _scaledClassSummonLevel: scaledClassSummonLevel} = Renderer.monster.getUnpackedCustomHashId(preloadId);

                    const baseMon = await DataLoader.pCacheAndGet(page, source, hash);
                    if (scaledCr != null) {
                        toRender = await ScaleCreature.scale(baseMon, scaledCr);
                    } else if (scaledSpellSummonLevel != null) {
                        toRender = await ScaleSpellSummonedCreature.scale(baseMon, scaledSpellSummonLevel);
                    } else if (scaledClassSummonLevel != null) {
                        toRender = await ScaleClassSummonedCreature.scale(baseMon, scaledClassSummonLevel);
                    }
                    break;
                }
            }
        } else if (customHashId) {
            toRender = await DataLoader.pCacheAndGet(page, source, hash);
            toRender = await Renderer.hover.pApplyCustomHashId(page, toRender, customHashId);
        } else {
            if (meta.isFluff)
                toRender = await Renderer.hover.pGetHoverableFluff(page, source, hash);
            else
                toRender = await DataLoader.pCacheAndGet(page, source, hash);
        }

        meta.isLoading = false;

        if (opts?.isDelay) {
            meta.isDelayed = true;
            ele.style.cursor = "help";
            await MiscUtil.pDelay(1100);
            meta.isDelayed = false;
        }

        ele.style.cursor = "";

        if (!meta || (!meta.isHovered && !meta.isPermanent))
            return;

        const tmpEvt = meta._tmpEvt;
        delete meta._tmpEvt;

        const win = (evt.view || {}).window;

        const $content = meta.isFluff ? Renderer.hover.$getHoverContent_fluff(page, toRender) : Renderer.hover.$getHoverContent_stats(page, toRender);

        const compactReferenceData = {
            page,
            source,
            hash,
        };

        if (meta.windowMeta && !meta.isPermanent) {
            meta.windowMeta.doClose();
            meta.windowMeta = null;
        }

        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(tmpEvt || evt, {
            isPreventFlicker: !meta.isPermanent
        }), {
            title: toRender ? toRender.name : "",
            isPermanent: meta.isPermanent,
            pageUrl: isFauxPage ? null : `${Renderer.get().baseUrl}${page}#${hash}`,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = meta.isFluff = false,
            isBookContent: page === UrlUtil.PG_RECIPES,
            compactReferenceData,
            sourceData: toRender,
        }, );

        if (!meta.isFluff && !win?._IS_POPOUT) {
            const fnBind = Renderer.hover.getFnBindListenersCompact(page);
            if (fnBind)
                fnBind(toRender, $content);
        }
    },

    handleInlineMouseOver(evt, ele, entry, opts) {
        Renderer.hover._doInit();

        entry = entry || JSON.parse(ele.dataset.vetEntry);

        let meta = Renderer.hover._handleGenericMouseOverStart({
            evt,
            ele
        });
        if (meta == null)
            return;

        meta.isLoading = false;

        ele.style.cursor = "";

        if (!meta || (!meta.isHovered && !meta.isPermanent))
            return;

        const tmpEvt = meta._tmpEvt;
        delete meta._tmpEvt;

        const win = (evt.view || {}).window;

        const $content = Renderer.hover.$getHoverContent_generic(entry, opts);

        if (meta.windowMeta && !meta.isPermanent) {
            meta.windowMeta.doClose();
            meta.windowMeta = null;
        }

        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(tmpEvt || evt, {
            isPreventFlicker: !meta.isPermanent
        }), {
            title: entry?.name || "",
            isPermanent: meta.isPermanent,
            pageUrl: null,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = false,
            isBookContent: true,
            sourceData: entry,
        }, );
    },

    async pGetHoverableFluff(page, source, hash, opts) {
        let toRender = await DataLoader.pCacheAndGet(`${page}Fluff`, source, hash, opts);

        if (!toRender) {
            const entity = await DataLoader.pCacheAndGet(page, source, hash, opts);

            const pFnGetFluff = Renderer.hover._pageToFluffFn(page);
            if (!pFnGetFluff && opts?.isSilent)
                return null;

            toRender = await pFnGetFluff(entity);
        }

        if (!toRender)
            return toRender;

        if (toRender && (!toRender.name || !toRender.source)) {
            const toRenderParent = await DataLoader.pCacheAndGet(page, source, hash, opts);
            toRender = MiscUtil.copyFast(toRender);
            toRender.name = toRenderParent.name;
            toRender.source = toRenderParent.source;
        }

        return toRender;
    },

    handleLinkMouseLeave(evt, ele) {
        const meta = Renderer.hover._eleCache.get(ele);
        ele.style.cursor = "";

        if (!meta || meta.isPermanent)
            return;

        if (evt.shiftKey) {
            meta.isPermanent = true;
            meta.windowMeta.setIsPermanent(true);
            return;
        }

        meta.isHovered = false;
        if (meta.windowMeta) {
            meta.windowMeta.doClose();
            meta.windowMeta = null;
        }
    },

    handleLinkMouseMove(evt, ele) {
        const meta = Renderer.hover._eleCache.get(ele);
        if (!meta || meta.isPermanent)
            return;

        if (meta.isDelayed) {
            meta._tmpEvt = evt;
            return;
        }

        if (!meta.windowMeta)
            return;

        meta.windowMeta.setPosition(Renderer.hover.getWindowPositionFromEvent(evt, {
            isPreventFlicker: !evt.shiftKey && !meta.isPermanent
        }));

        if (evt.shiftKey && !meta.isPermanent) {
            meta.isPermanent = true;
            meta.windowMeta.setIsPermanent(true);
        }
    },

    handlePredefinedMouseOver(evt, ele, entryId, opts) {
        opts = opts || {};

        const meta = Renderer.hover._handleGenericMouseOverStart({
            evt,
            ele
        });
        if (meta == null)
            return;

        Renderer.hover.cleanTempWindows();

        const toRender = Renderer.hover._entryCache[entryId];

        meta.isLoading = false;
        if (!meta.isHovered && !meta.isPermanent)
            return;

        const $content = Renderer.hover.$getHoverContent_generic(toRender, opts);
        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(evt, {
            isPreventFlicker: !meta.isPermanent
        }), {
            title: toRender.data && toRender.data.hoverTitle != null ? toRender.data.hoverTitle : toRender.name,
            isPermanent: meta.isPermanent,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = false,
            sourceData: toRender,
        }, );

        ele.style.cursor = "";
    },

    doPredefinedShow(entryId, opts) {
        opts = opts || {};

        const meta = Renderer.hover._doPredefinedShowStart({
            entryId
        });
        if (meta == null)
            return;

        Renderer.hover.cleanTempWindows();

        const toRender = Renderer.hover._entryCache[entryId];

        const $content = Renderer.hover.$getHoverContent_generic(toRender, opts);
        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionExact((window.innerWidth / 2) - (Renderer.hover._DEFAULT_WIDTH_PX / 2), 100), {
            title: toRender.data && toRender.data.hoverTitle != null ? toRender.data.hoverTitle : toRender.name,
            isPermanent: meta.isPermanent,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = false,
            sourceData: toRender,
        }, );
    },

    handlePredefinedMouseLeave(evt, ele) {
        return Renderer.hover.handleLinkMouseLeave(evt, ele);
    },

    handlePredefinedMouseMove(evt, ele) {
        return Renderer.hover.handleLinkMouseMove(evt, ele);
    },

    _WINDOW_POSITION_PROPS_FROM_EVENT: ["isFromBottom", "isFromRight", "clientX", "window", "isPreventFlicker", "bcr", ],

    getWindowPositionFromEvent(evt, {isPreventFlicker=false}={}) {
        const ele = evt.target;
        const win = evt?.view?.window || window;

        const bcr = ele.getBoundingClientRect().toJSON();

        const isFromBottom = bcr.top > win.innerHeight / 2;
        const isFromRight = bcr.left > win.innerWidth / 2;

        return {
            mode: "autoFromElement",
            isFromBottom,
            isFromRight,
            clientX: EventUtil.getClientX(evt),
            window: win,
            isPreventFlicker,
            bcr,
        };
    },

    getWindowPositionExact(x, y, evt=null) {
        return {
            window: evt?.view?.window || window,
            mode: "exact",
            x,
            y,
        };
    },

    getWindowPositionExactVisibleBottom(x, y, evt=null) {
        return {
            ...Renderer.hover.getWindowPositionExact(x, y, evt),
            mode: "exactVisibleBottom",
        };
    },

    _WINDOW_METAS: {},
    MIN_Z_INDEX: 200,
    _MAX_Z_INDEX: 300,
    _DEFAULT_WIDTH_PX: 600,
    _BODY_SCROLLER_WIDTH_PX: 15,

    _getZIndex() {
        const zIndices = Object.values(Renderer.hover._WINDOW_METAS).map(it=>it.zIndex);
        if (!zIndices.length)
            return Renderer.hover.MIN_Z_INDEX;
        return Math.max(...zIndices);
    },

    _getNextZIndex(hoverId) {
        const cur = Renderer.hover._getZIndex();
        if (hoverId != null && Renderer.hover._WINDOW_METAS[hoverId].zIndex === cur)
            return cur;
        const out = cur + 1;

        if (out > Renderer.hover._MAX_Z_INDEX) {
            const sortedWindowMetas = Object.entries(Renderer.hover._WINDOW_METAS).sort(([kA,vA],[kB,vB])=>SortUtil.ascSort(vA.zIndex, vB.zIndex));

            if (sortedWindowMetas.length >= (Renderer.hover._MAX_Z_INDEX - Renderer.hover.MIN_Z_INDEX)) {
                sortedWindowMetas.forEach(([k,v])=>{
                    v.setZIndex(Renderer.hover.MIN_Z_INDEX);
                }
                );
            } else {
                sortedWindowMetas.forEach(([k,v],i)=>{
                    v.setZIndex(Renderer.hover.MIN_Z_INDEX + i);
                }
                );
            }

            return Renderer.hover._getNextZIndex(hoverId);
        } else
            return out;
    },

    _isIntersectRect(r1, r2) {
        return r1.left <= r2.right && r2.left <= r1.right && r1.top <= r2.bottom && r2.top <= r1.bottom;
    },

    getShowWindow($content, position, opts) {
        opts = opts || {};

        Renderer.hover._doInit();

        const initialWidth = opts.width == null ? Renderer.hover._DEFAULT_WIDTH_PX : opts.width;
        const initialZIndex = Renderer.hover._getNextZIndex();

        const $body = $(position.window.document.body);
        const $hov = $(`<div class="hwin"></div>`).css({
            "right": -initialWidth,
            "width": initialWidth,
            "zIndex": initialZIndex,
        });
        const $wrpContent = $(`<div class="hwin__wrp-table"></div>`);
        if (opts.height != null)
            $wrpContent.css("height", opts.height);
        const $hovTitle = $(`<span class="window-title min-w-0 overflow-ellipsis" title="${`${opts.title || ""}`.qq()}">${opts.title || ""}</span>`);

        const hoverWindow = {};
        const hoverId = Renderer.hover._getNextId();
        Renderer.hover._WINDOW_METAS[hoverId] = hoverWindow;
        const mouseUpId = `mouseup.${hoverId} touchend.${hoverId}`;
        const mouseMoveId = `mousemove.${hoverId} touchmove.${hoverId}`;
        const resizeId = `resize.${hoverId}`;
        const drag = {};

        const $brdrTopRightResize = $(`<div class="hoverborder__resize-ne"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 1
        }));

        const $brdrRightResize = $(`<div class="hoverborder__resize-e"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 2
        }));

        const $brdrBottomRightResize = $(`<div class="hoverborder__resize-se"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 3
        }));

        const $brdrBtm = $(`<div class="hoverborder hoverborder--btm ${opts.isBookContent ? "hoverborder-book" : ""}"><div class="hoverborder__resize-s"></div></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 4
        }));

        const $brdrBtmLeftResize = $(`<div class="hoverborder__resize-sw"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 5
        }));

        const $brdrLeftResize = $(`<div class="hoverborder__resize-w"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 6
        }));

        const $brdrTopLeftResize = $(`<div class="hoverborder__resize-nw"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 7
        }));

        const $brdrTopResize = $(`<div class="hoverborder__resize-n"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 8
        }));

        const $brdrTop = $(`<div class="hoverborder hoverborder--top ${opts.isBookContent ? "hoverborder-book" : ""}" ${opts.isPermanent ? `data-perm="true"` : ""}></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 9
        })).on("contextmenu", (evt)=>{
            Renderer.hover._contextMenuLastClicked = {
                hoverId,
            };
            ContextUtil.pOpenMenu(evt, Renderer.hover._contextMenu);
        }
        );

        $(position.window.document).on(mouseUpId, (evt)=>{
            if (drag.type) {
                if (drag.type < 9) {
                    $wrpContent.css("max-height", "");
                    $hov.css("max-width", "");
                }
                Renderer.hover._getShowWindow_adjustPosition({
                    $hov,
                    $wrpContent,
                    position
                });

                if (drag.type === 9) {
                    if (EventUtil.isUsingTouch() && evt.target.classList.contains("hwin__top-border-icon")) {
                        evt.preventDefault();
                        drag.type = 0;
                        $(evt.target).click();
                        return;
                    }

                    if (this._dmScreen && opts.compactReferenceData) {
                        const panel = this._dmScreen.getPanelPx(EventUtil.getClientX(evt), EventUtil.getClientY(evt));
                        if (!panel)
                            return;
                        this._dmScreen.setHoveringPanel(panel);
                        const target = panel.getAddButtonPos();

                        if (Renderer.hover._getShowWindow_isOverHoverTarget({
                            evt,
                            target
                        })) {
                            panel.doPopulate_Stats(opts.compactReferenceData.page, opts.compactReferenceData.source, opts.compactReferenceData.hash);
                            Renderer.hover._getShowWindow_doClose({
                                $hov,
                                position,
                                mouseUpId,
                                mouseMoveId,
                                resizeId,
                                hoverId,
                                opts,
                                hoverWindow
                            });
                        }
                        this._dmScreen.resetHoveringButton();
                    }
                }
                drag.type = 0;
            }
        }
        ).on(mouseMoveId, (evt)=>{
            const args = {
                $wrpContent,
                $hov,
                drag,
                evt
            };
            switch (drag.type) {
            case 1:
                Renderer.hover._getShowWindow_handleNorthDrag(args);
                Renderer.hover._getShowWindow_handleEastDrag(args);
                break;
            case 2:
                Renderer.hover._getShowWindow_handleEastDrag(args);
                break;
            case 3:
                Renderer.hover._getShowWindow_handleSouthDrag(args);
                Renderer.hover._getShowWindow_handleEastDrag(args);
                break;
            case 4:
                Renderer.hover._getShowWindow_handleSouthDrag(args);
                break;
            case 5:
                Renderer.hover._getShowWindow_handleSouthDrag(args);
                Renderer.hover._getShowWindow_handleWestDrag(args);
                break;
            case 6:
                Renderer.hover._getShowWindow_handleWestDrag(args);
                break;
            case 7:
                Renderer.hover._getShowWindow_handleNorthDrag(args);
                Renderer.hover._getShowWindow_handleWestDrag(args);
                break;
            case 8:
                Renderer.hover._getShowWindow_handleNorthDrag(args);
                break;
            case 9:
                {
                    const diffX = drag.startX - EventUtil.getClientX(evt);
                    const diffY = drag.startY - EventUtil.getClientY(evt);
                    $hov.css("left", drag.baseLeft - diffX).css("top", drag.baseTop - diffY);
                    drag.startX = EventUtil.getClientX(evt);
                    drag.startY = EventUtil.getClientY(evt);
                    drag.baseTop = parseFloat($hov.css("top"));
                    drag.baseLeft = parseFloat($hov.css("left"));

                    if (this._dmScreen) {
                        const panel = this._dmScreen.getPanelPx(EventUtil.getClientX(evt), EventUtil.getClientY(evt));
                        if (!panel)
                            return;
                        this._dmScreen.setHoveringPanel(panel);
                        const target = panel.getAddButtonPos();

                        if (Renderer.hover._getShowWindow_isOverHoverTarget({
                            evt,
                            target
                        }))
                            this._dmScreen.setHoveringButton(panel);
                        else
                            this._dmScreen.resetHoveringButton();
                    }
                    break;
                }
            }
        }
        );
        $(position.window).on(resizeId, ()=>Renderer.hover._getShowWindow_adjustPosition({
            $hov,
            $wrpContent,
            position
        }));

        $brdrTop.attr("data-display-title", false);
        $brdrTop.on("dblclick", ()=>Renderer.hover._getShowWindow_doToggleMinimizedMaximized({
            $brdrTop,
            $hov
        }));
        $brdrTop.append($hovTitle);
        const $brdTopRhs = $(`<div class="ve-flex ml-auto no-shrink"></div>`).appendTo($brdrTop);

        if (opts.pageUrl && !position.window._IS_POPOUT && !Renderer.get().isInternalLinksDisabled()) {
            const $btnGotoPage = $(`<a class="hwin__top-border-icon glyphicon glyphicon-modal-window" title="Go to Page" href="${opts.pageUrl}"></a>`).appendTo($brdTopRhs);
        }

        if (!position.window._IS_POPOUT && !opts.isPopout) {
            const $btnPopout = $(`<span class="hwin__top-border-icon glyphicon glyphicon-new-window hvr__popout" title="Open as Popup Window"></span>`).on("click", evt=>{
                evt.stopPropagation();
                return Renderer.hover._getShowWindow_pDoPopout({
                    $hov,
                    position,
                    mouseUpId,
                    mouseMoveId,
                    resizeId,
                    hoverId,
                    opts,
                    hoverWindow,
                    $content
                }, {
                    evt
                });
            }
            ).appendTo($brdTopRhs);
        }

        if (opts.sourceData) {
            const btnPopout = e_({
                tag: "span",
                clazz: `hwin__top-border-icon hwin__top-border-icon--text`,
                title: "Show Source Data",
                text: "{}",
                click: evt=>{
                    evt.stopPropagation();
                    evt.preventDefault();

                    const $content = Renderer.hover.$getHoverContent_statsCode(opts.sourceData);
                    Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(evt), {
                        title: [opts.sourceData._displayName || opts.sourceData.name, "Source Data"].filter(Boolean).join(" \u2014 "),
                        isPermanent: true,
                        isBookContent: true,
                    }, );
                }
                ,
            });
            $brdTopRhs.append(btnPopout);
        }

        const $btnClose = $(`<span class="hwin__top-border-icon glyphicon glyphicon-remove" title="Close (CTRL to Close All)"></span>`).on("click", (evt)=>{
            evt.stopPropagation();

            if (EventUtil.isCtrlMetaKey(evt)) {
                Renderer.hover._doCloseAllWindows();
                return;
            }

            Renderer.hover._getShowWindow_doClose({
                $hov,
                position,
                mouseUpId,
                mouseMoveId,
                resizeId,
                hoverId,
                opts,
                hoverWindow
            });
        }
        ).appendTo($brdTopRhs);

        $wrpContent.append($content);

        $hov.append($brdrTopResize).append($brdrTopRightResize).append($brdrRightResize).append($brdrBottomRightResize).append($brdrBtmLeftResize).append($brdrLeftResize).append($brdrTopLeftResize)
        .append($brdrTop).append($wrpContent).append($brdrBtm);

        $body.append($hov);

        Renderer.hover._getShowWindow_setPosition({
            $hov,
            $wrpContent,
            position
        }, position);

        hoverWindow.$windowTitle = $hovTitle;
        hoverWindow.zIndex = initialZIndex;
        hoverWindow.setZIndex = Renderer.hover._getNextZIndex.bind(this, {
            $hov,
            hoverWindow
        });

        hoverWindow.setPosition = Renderer.hover._getShowWindow_setPosition.bind(this, {
            $hov,
            $wrpContent,
            position
        });
        hoverWindow.setIsPermanent = Renderer.hover._getShowWindow_setIsPermanent.bind(this, {
            opts,
            $brdrTop
        });
        hoverWindow.doClose = Renderer.hover._getShowWindow_doClose.bind(this, {
            $hov,
            position,
            mouseUpId,
            mouseMoveId,
            resizeId,
            hoverId,
            opts,
            hoverWindow
        });
        hoverWindow.doMaximize = Renderer.hover._getShowWindow_doMaximize.bind(this, {
            $brdrTop,
            $hov
        });
        hoverWindow.doZIndexToFront = Renderer.hover._getShowWindow_doZIndexToFront.bind(this, {
            $hov,
            hoverWindow,
            hoverId
        });

        if (opts.isPopout)
            Renderer.hover._getShowWindow_pDoPopout({
                $hov,
                position,
                mouseUpId,
                mouseMoveId,
                resizeId,
                hoverId,
                opts,
                hoverWindow,
                $content
            });

        return hoverWindow;
    },

    _getShowWindow_doClose({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow}) {
        $hov.remove();
        $(position.window.document).off(mouseUpId);
        $(position.window.document).off(mouseMoveId);
        $(position.window).off(resizeId);

        delete Renderer.hover._WINDOW_METAS[hoverId];

        if (opts.cbClose)
            opts.cbClose(hoverWindow);
    },

    _getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type}) {
        if (evt.which === 0 || evt.which === 1)
            evt.preventDefault();
        hoverWindow.zIndex = Renderer.hover._getNextZIndex(hoverId);
        $hov.css({
            "z-index": hoverWindow.zIndex,
            "animation": "initial",
        });
        drag.type = type;
        drag.startX = EventUtil.getClientX(evt);
        drag.startY = EventUtil.getClientY(evt);
        drag.baseTop = parseFloat($hov.css("top"));
        drag.baseLeft = parseFloat($hov.css("left"));
        drag.baseHeight = $wrpContent.height();
        drag.baseWidth = parseFloat($hov.css("width"));
        if (type < 9) {
            $wrpContent.css({
                "height": drag.baseHeight,
                "max-height": "initial",
            });
            $hov.css("max-width", "initial");
        }
    },

    _getShowWindow_isOverHoverTarget({evt, target}) {
        return EventUtil.getClientX(evt) >= target.left && EventUtil.getClientX(evt) <= target.left + target.width && EventUtil.getClientY(evt) >= target.top && EventUtil.getClientY(evt) <= target.top + target.height;
    },

    _getShowWindow_handleNorthDrag({$wrpContent, $hov, drag, evt}) {
        const diffY = Math.max(drag.startY - EventUtil.getClientY(evt), 80 - drag.baseHeight);
        $wrpContent.css("height", drag.baseHeight + diffY);
        $hov.css("top", drag.baseTop - diffY);
        drag.startY = EventUtil.getClientY(evt);
        drag.baseHeight = $wrpContent.height();
        drag.baseTop = parseFloat($hov.css("top"));
    },

    _getShowWindow_handleEastDrag({$wrpContent, $hov, drag, evt}) {
        const diffX = drag.startX - EventUtil.getClientX(evt);
        $hov.css("width", drag.baseWidth - diffX);
        drag.startX = EventUtil.getClientX(evt);
        drag.baseWidth = parseFloat($hov.css("width"));
    },

    _getShowWindow_handleSouthDrag({$wrpContent, $hov, drag, evt}) {
        const diffY = drag.startY - EventUtil.getClientY(evt);
        $wrpContent.css("height", drag.baseHeight - diffY);
        drag.startY = EventUtil.getClientY(evt);
        drag.baseHeight = $wrpContent.height();
    },

    _getShowWindow_handleWestDrag({$wrpContent, $hov, drag, evt}) {
        const diffX = Math.max(drag.startX - EventUtil.getClientX(evt), 150 - drag.baseWidth);
        $hov.css("width", drag.baseWidth + diffX).css("left", drag.baseLeft - diffX);
        drag.startX = EventUtil.getClientX(evt);
        drag.baseWidth = parseFloat($hov.css("width"));
        drag.baseLeft = parseFloat($hov.css("left"));
    },

    _getShowWindow_doToggleMinimizedMaximized({$brdrTop, $hov}) {
        const curState = $brdrTop.attr("data-display-title");
        const isNextMinified = curState === "false";
        $brdrTop.attr("data-display-title", isNextMinified);
        $brdrTop.attr("data-perm", true);
        $hov.toggleClass("hwin--minified", isNextMinified);
    },

    _getShowWindow_doMaximize({$brdrTop, $hov}) {
        $brdrTop.attr("data-display-title", false);
        $hov.toggleClass("hwin--minified", false);
    },

    async _getShowWindow_pDoPopout({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow, $content}, {evt}={}) {
        const dimensions = opts.fnGetPopoutSize ? opts.fnGetPopoutSize() : {
            width: 600,
            height: $content.height()
        };
        const win = window.open("", opts.title || "", `width=${dimensions.width},height=${dimensions.height}location=0,menubar=0,status=0,titlebar=0,toolbar=0`, );

        if (!win._IS_POPOUT) {
            win._IS_POPOUT = true;
            win.document.write(`
				<!DOCTYPE html>
				<html lang="en" class="ve-popwindow ${typeof styleSwitcher !== "undefined" ? styleSwitcher.getDayNightClassNames() : ""}"><head>
					<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
					<title>${opts.title}</title>
					${$(`link[rel="stylesheet"][href]`).map((i,e)=>e.outerHTML).get().join("\n")}
					<!-- Favicons -->
					<link rel="icon" type="image/svg+xml" href="favicon.svg">
					<link rel="icon" type="image/png" sizes="256x256" href="favicon-256x256.png">
					<link rel="icon" type="image/png" sizes="144x144" href="favicon-144x144.png">
					<link rel="icon" type="image/png" sizes="128x128" href="favicon-128x128.png">
					<link rel="icon" type="image/png" sizes="64x64" href="favicon-64x64.png">
					<link rel="icon" type="image/png" sizes="48x48" href="favicon-48x48.png">
					<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
					<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">

					<!-- Chrome Web App Icons -->
					<link rel="manifest" href="manifest.webmanifest">
					<meta name="application-name" content="5etools">
					<meta name="theme-color" content="#006bc4">

					<!-- Windows Start Menu tiles -->
					<meta name="msapplication-config" content="browserconfig.xml"/>
					<meta name="msapplication-TileColor" content="#006bc4">

					<!-- Apple Touch Icons -->
					<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
					<link rel="apple-touch-icon" sizes="360x360" href="apple-touch-icon-360x360.png">
					<link rel="apple-touch-icon" sizes="167x167" href="apple-touch-icon-167x167.png">
					<link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
					<link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120x120.png">
					<meta name="apple-mobile-web-app-title" content="5etools">

					<!-- macOS Safari Pinned Tab and Touch Bar -->
					<link rel="mask-icon" href="safari-pinned-tab.svg" color="#006bc4">

					<style>
						html, body { width: 100%; height: 100%; }
						body { overflow-y: scroll; }
						.hwin--popout { max-width: 100%; max-height: 100%; box-shadow: initial; width: 100%; overflow-y: auto; }
					</style>
				</head><body class="rd__body-popout">
				<div class="hwin hoverbox--popout hwin--popout"></div>
				<script type="text/javascript" src="js/parser.js"></script>
				<script type="text/javascript" src="js/utils.js"></script>
				<script type="text/javascript" src="lib/jquery.js"></script>
				</body></html>
			`);

            win.Renderer = Renderer;

            let ticks = 50;
            while (!win.document.body && ticks-- > 0)
                await MiscUtil.pDelay(5);

            win.$wrpHoverContent = $(win.document).find(`.hoverbox--popout`);
        }

        let $cpyContent;
        if (opts.$pFnGetPopoutContent) {
            $cpyContent = await opts.$pFnGetPopoutContent();
        } else {
            $cpyContent = $content.clone(true, true);
        }

        $cpyContent.appendTo(win.$wrpHoverContent.empty());

        Renderer.hover._getShowWindow_doClose({
            $hov,
            position,
            mouseUpId,
            mouseMoveId,
            resizeId,
            hoverId,
            opts,
            hoverWindow
        });
    },

    _getShowWindow_setPosition({$hov, $wrpContent, position}, positionNxt) {
        switch (positionNxt.mode) {
        case "autoFromElement":
            {
                const bcr = $hov[0].getBoundingClientRect();

                if (positionNxt.isFromBottom)
                    $hov.css("top", positionNxt.bcr.top - (bcr.height + 10));
                else
                    $hov.css("top", positionNxt.bcr.top + positionNxt.bcr.height + 10);

                if (positionNxt.isFromRight)
                    $hov.css("left", (positionNxt.clientX || positionNxt.bcr.left) - (bcr.width + 10));
                else
                    $hov.css("left", (positionNxt.clientX || (positionNxt.bcr.left + positionNxt.bcr.width)) + 10);

                if (position !== positionNxt) {
                    Renderer.hover._WINDOW_POSITION_PROPS_FROM_EVENT.forEach(prop=>{
                        position[prop] = positionNxt[prop];
                    }
                    );
                }

                break;
            }
        case "exact":
            {
                $hov.css({
                    "left": positionNxt.x,
                    "top": positionNxt.y,
                });
                break;
            }
        case "exactVisibleBottom":
            {
                $hov.css({
                    "left": positionNxt.x,
                    "top": positionNxt.y,
                    "animation": "initial",
                });

                let yPos = positionNxt.y;

                const {bottom: posBottom, height: winHeight} = $hov[0].getBoundingClientRect();
                const height = position.window.innerHeight;
                if (posBottom > height) {
                    yPos = position.window.innerHeight - winHeight;
                    $hov.css({
                        "top": yPos,
                        "animation": "",
                    });
                }

                break;
            }
        default:
            throw new Error(`Positiong mode unimplemented: "${positionNxt.mode}"`);
        }

        Renderer.hover._getShowWindow_adjustPosition({
            $hov,
            $wrpContent,
            position
        });
    },

    _getShowWindow_adjustPosition({$hov, $wrpContent, position}) {
        const eleHov = $hov[0];
        const wrpContent = $wrpContent[0];

        const bcr = eleHov.getBoundingClientRect().toJSON();
        const screenHeight = position.window.innerHeight;
        const screenWidth = position.window.innerWidth;

        if (bcr.top < 0) {
            bcr.top = 0;
            bcr.bottom = bcr.top + bcr.height;
            eleHov.style.top = `${bcr.top}px`;
        } else if (bcr.top >= screenHeight - Renderer.hover._BAR_HEIGHT) {
            bcr.top = screenHeight - Renderer.hover._BAR_HEIGHT;
            bcr.bottom = bcr.top + bcr.height;
            eleHov.style.top = `${bcr.top}px`;
        }

        if (bcr.left < 0) {
            bcr.left = 0;
            bcr.right = bcr.left + bcr.width;
            eleHov.style.left = `${bcr.left}px`;
        } else if (bcr.left + bcr.width + Renderer.hover._BODY_SCROLLER_WIDTH_PX > screenWidth) {
            bcr.left = Math.max(screenWidth - bcr.width - Renderer.hover._BODY_SCROLLER_WIDTH_PX, 0);
            bcr.right = bcr.left + bcr.width;
            eleHov.style.left = `${bcr.left}px`;
        }

        if (position.isPreventFlicker && Renderer.hover._isIntersectRect(bcr, position.bcr)) {
            if (position.isFromBottom) {
                bcr.height = position.bcr.top - 5;
                wrpContent.style.height = `${bcr.height}px`;
            } else {
                bcr.height = screenHeight - position.bcr.bottom - 5;
                wrpContent.style.height = `${bcr.height}px`;
            }
        }
    },

    _getShowWindow_setIsPermanent({opts, $brdrTop}, isPermanent) {
        opts.isPermanent = isPermanent;
        $brdrTop.attr("data-perm", isPermanent);
    },

    _getShowWindow_setZIndex({$hov, hoverWindow}, zIndex) {
        $hov.css("z-index", zIndex);
        hoverWindow.zIndex = zIndex;
    },

    _getShowWindow_doZIndexToFront({$hov, hoverWindow, hoverId}) {
        const nxtZIndex = Renderer.hover._getNextZIndex(hoverId);
        Renderer.hover._getNextZIndex({
            $hov,
            hoverWindow
        }, nxtZIndex);
    },

    getMakePredefinedHover(entry, opts) {
        opts = opts || {};

        const id = opts.id ?? Renderer.hover._getNextId();
        Renderer.hover._entryCache[id] = entry;
        return {
            id,
            html: `onmouseover="Renderer.hover.handlePredefinedMouseOver(event, this, ${id}, ${JSON.stringify(opts).escapeQuotes()})" onmousemove="Renderer.hover.handlePredefinedMouseMove(event, this)" onmouseleave="Renderer.hover.handlePredefinedMouseLeave(event, this)" ${Renderer.hover.getPreventTouchString()}`,
            mouseOver: (evt,ele)=>Renderer.hover.handlePredefinedMouseOver(evt, ele, id, opts),
            mouseMove: (evt,ele)=>Renderer.hover.handlePredefinedMouseMove(evt, ele),
            mouseLeave: (evt,ele)=>Renderer.hover.handlePredefinedMouseLeave(evt, ele),
            touchStart: (evt,ele)=>Renderer.hover.handleTouchStart(evt, ele),
            show: ()=>Renderer.hover.doPredefinedShow(id, opts),
        };
    },

    updatePredefinedHover(id, entry) {
        Renderer.hover._entryCache[id] = entry;
    },

    getInlineHover(entry, opts) {
        return {
            html: `onmouseover="Renderer.hover.handleInlineMouseOver(event, this)" onmouseleave="Renderer.hover.handleLinkMouseLeave(event, this)" onmousemove="Renderer.hover.handleLinkMouseMove(event, this)" data-vet-entry="${JSON.stringify(entry).qq()}" ${opts ? `data-vet-opts="${JSON.stringify(opts).qq()}"` : ""} ${Renderer.hover.getPreventTouchString()}`,
        };
    },

    getPreventTouchString() {
        return `ontouchstart="Renderer.hover.handleTouchStart(event, this)"`;
    },

    handleTouchStart(evt, ele) {
        if (!Renderer.hover.isSmallScreen(evt)) {
            $(ele).data("href", $(ele).data("href") || $(ele).attr("href"));
            $(ele).attr("href", "javascript:void(0)");
            setTimeout(()=>{
                const data = $(ele).data("href");
                if (data) {
                    $(ele).attr("href", data);
                    $(ele).data("href", null);
                }
            }
            , 100);
        }
    },

    getEntityLink(ent, {displayText=null, prop=null, isLowerCase=false, isTitleCase=false, }={}, ) {
        if (isLowerCase && isTitleCase)
            throw new Error(`"isLowerCase" and "isTitleCase" are mutually exclusive!`);

        const name = isLowerCase ? ent.name.toLowerCase() : isTitleCase ? ent.name.toTitleCase() : ent.name;

        let parts = [name, ent.source, displayText || "", ];

        switch (prop || ent.__prop) {
        case "monster":
            {
                if (ent._isScaledCr) {
                    parts.push(`${VeCt.HASH_SCALED}=${Parser.numberToCr(ent._scaledCr)}`);
                }

                if (ent._isScaledSpellSummon) {
                    parts.push(`${VeCt.HASH_SCALED_SPELL_SUMMON}=${ent._scaledSpellSummonLevel}`);
                }

                if (ent._isScaledClassSummon) {
                    parts.push(`${VeCt.HASH_SCALED_CLASS_SUMMON}=${ent._scaledClassSummonLevel}`);
                }

                break;
            }

        case "deity":
            {
                parts.splice(1, 0, ent.pantheon);
                break;
            }
        }

        while (parts.length && !parts.last()?.length)
            parts.pop();

        return Renderer.get().render(`{@${Parser.getPropTag(prop || ent.__prop)} ${parts.join("|")}}`);
    },

    getRefMetaFromTag(str) {
        str = str.slice(2, -1);
        const [tag,...refParts] = str.split(" ");
        const ref = refParts.join(" ");
        const type = `ref${tag.uppercaseFirst()}`;
        return {
            type,
            [tag]: ref
        };
    },

    async pApplyCustomHashId(page, ent, customHashId) {
        switch (page) {
        case UrlUtil.PG_BESTIARY:
            {
                const out = await Renderer.monster.pGetModifiedCreature(ent, customHashId);
                Renderer.monster.updateParsed(out);
                return out;
            }

        case UrlUtil.PG_RECIPES:
            return Renderer.recipe.pGetModifiedRecipe(ent, customHashId);

        default:
            return ent;
        }
    },

    getGenericCompactRenderedString(entry, depth=0) {
        return `
			<tr class="text homebrew-hover"><td colspan="6">
			${Renderer.get().setFirstSection(true).render(entry, depth)}
			</td></tr>
		`;
    },

    getFnRenderCompact(page, {isStatic=false}={}) {
        switch (page) {
        case "generic":
        case "hover":
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_QUICKREF:
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_CLASSES:
            return Renderer.class.getCompactRenderedString;
        case UrlUtil.PG_SPELLS:
            return Renderer.spell.getCompactRenderedString;
        case UrlUtil.PG_ITEMS:
            return Renderer.item.getCompactRenderedString;
        case UrlUtil.PG_BESTIARY:
            return it=>Renderer.monster.getCompactRenderedString(it, {
                isShowScalers: !isStatic,
                isScaledCr: it._originalCr != null,
                isScaledSpellSummon: it._isScaledSpellSummon,
                isScaledClassSummon: it._isScaledClassSummon
            });
        case UrlUtil.PG_CONDITIONS_DISEASES:
            return Renderer.condition.getCompactRenderedString;
        case UrlUtil.PG_BACKGROUNDS:
            return Renderer.background.getCompactRenderedString;
        case UrlUtil.PG_FEATS:
            return Renderer.feat.getCompactRenderedString;
        case UrlUtil.PG_OPT_FEATURES:
            return Renderer.optionalfeature.getCompactRenderedString;
        case UrlUtil.PG_PSIONICS:
            return Renderer.psionic.getCompactRenderedString;
        case UrlUtil.PG_REWARDS:
            return Renderer.reward.getCompactRenderedString;
        case UrlUtil.PG_RACES:
            return it=>Renderer.race.getCompactRenderedString(it, {
                isStatic
            });
        case UrlUtil.PG_DEITIES:
            return Renderer.deity.getCompactRenderedString;
        case UrlUtil.PG_OBJECTS:
            return Renderer.object.getCompactRenderedString;
        case UrlUtil.PG_TRAPS_HAZARDS:
            return Renderer.traphazard.getCompactRenderedString;
        case UrlUtil.PG_VARIANTRULES:
            return Renderer.variantrule.getCompactRenderedString;
        case UrlUtil.PG_CULTS_BOONS:
            return Renderer.cultboon.getCompactRenderedString;
        case UrlUtil.PG_TABLES:
            return Renderer.table.getCompactRenderedString;
        case UrlUtil.PG_VEHICLES:
            return Renderer.vehicle.getCompactRenderedString;
        case UrlUtil.PG_ACTIONS:
            return Renderer.action.getCompactRenderedString;
        case UrlUtil.PG_LANGUAGES:
            return Renderer.language.getCompactRenderedString;
        case UrlUtil.PG_CHAR_CREATION_OPTIONS:
            return Renderer.charoption.getCompactRenderedString;
        case UrlUtil.PG_RECIPES:
            return Renderer.recipe.getCompactRenderedString;
        case UrlUtil.PG_CLASS_SUBCLASS_FEATURES:
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_CREATURE_FEATURES:
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_DECKS:
            return Renderer.deck.getCompactRenderedString;
        case "classfeature":
        case "classFeature":
            return Renderer.hover.getGenericCompactRenderedString;
        case "subclassfeature":
        case "subclassFeature":
            return Renderer.hover.getGenericCompactRenderedString;
        case "citation":
            return Renderer.hover.getGenericCompactRenderedString;
        default:
            if (Renderer[page]?.getCompactRenderedString){return Renderer[page].getCompactRenderedString;}
            return null;
        }
    },

    getFnBindListenersCompact(page) {
        switch (page) {
        case UrlUtil.PG_BESTIARY:
            return Renderer.monster.bindListenersCompact;
        case UrlUtil.PG_RACES:
            return Renderer.race.bindListenersCompact;
        default:
            return null;
        }
    },

    _pageToFluffFn(page) {
        switch (page) {
        case UrlUtil.PG_BESTIARY:
            return Renderer.monster.pGetFluff;
        case UrlUtil.PG_ITEMS:
            return Renderer.item.pGetFluff;
        case UrlUtil.PG_CONDITIONS_DISEASES:
            return Renderer.condition.pGetFluff;
        case UrlUtil.PG_SPELLS:
            return Renderer.spell.pGetFluff;
        case UrlUtil.PG_RACES:
            return Renderer.race.pGetFluff;
        case UrlUtil.PG_BACKGROUNDS:
            return Renderer.background.pGetFluff;
        case UrlUtil.PG_FEATS:
            return Renderer.feat.pGetFluff;
        case UrlUtil.PG_LANGUAGES:
            return Renderer.language.pGetFluff;
        case UrlUtil.PG_VEHICLES:
            return Renderer.vehicle.pGetFluff;
        case UrlUtil.PG_CHAR_CREATION_OPTIONS:
            return Renderer.charoption.pGetFluff;
        case UrlUtil.PG_RECIPES:
            return Renderer.recipe.pGetFluff;
        default:
            return null;
        }
    },

    isSmallScreen(evt) {
        if (typeof window === "undefined")
            return false;

        evt = evt || {};
        const win = (evt.view || {}).window || window;
        return win.innerWidth <= 768;
    },

    $getHoverContent_stats(page, toRender, opts, renderFnOpts) {
        opts = opts || {};
        if (page === UrlUtil.PG_RECIPES){
            opts = {
                ...MiscUtil.copyFast(opts),
                isBookContent: true
            };
        }

        const fnRender = opts.fnRender || Renderer.hover.getFnRenderCompact(page, {isStatic: opts.isStatic});
        const $out = $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}">${fnRender(toRender, renderFnOpts)}</table>`;

        if (!opts.isStatic) {
            const fnBind = Renderer.hover.getFnBindListenersCompact(page);
            if (fnBind){fnBind(toRender, $out[0]);}
        }

        return $out;
    },

    $getHoverContent_fluff(page, toRender, opts, renderFnOpts) {
        opts = opts || {};
        if (page === UrlUtil.PG_RECIPES)
            opts = {
                ...MiscUtil.copyFast(opts),
                isBookContent: true
            };

        if (!toRender) {
            return $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}"><tr class="text"><td colspan="6" class="p-2 ve-text-center">${Renderer.utils.HTML_NO_INFO}</td></tr></table>`;
        }

        toRender = MiscUtil.copyFast(toRender);

        if (toRender.images && toRender.images.length) {
            const cachedImages = MiscUtil.copyFast(toRender.images);
            delete toRender.images;

            toRender.entries = toRender.entries || [];
            const hasText = toRender.entries.length > 0;
            if (hasText)
                toRender.entries.unshift({
                    type: "hr"
                });
            cachedImages[0].maxHeight = 33;
            cachedImages[0].maxHeightUnits = "vh";
            toRender.entries.unshift(cachedImages[0]);

            if (cachedImages.length > 1) {
                if (hasText)
                    toRender.entries.push({
                        type: "hr"
                    });
                toRender.entries.push(...cachedImages.slice(1));
            }
        }

        return $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}">${Renderer.generic.getCompactRenderedString(toRender, renderFnOpts)}</table>`;
    },

    $getHoverContent_statsCode(toRender, {isSkipClean=false, title=null}={}) {
        const cleanCopy = isSkipClean ? toRender : DataUtil.cleanJson(MiscUtil.copyFast(toRender));
        return Renderer.hover.$getHoverContent_miscCode(title || [cleanCopy.name, "Source Data"].filter(Boolean).join(" \u2014 "), JSON.stringify(cleanCopy, null, "\t"), );
    },

    $getHoverContent_miscCode(name, code) {
        const toRenderCode = {
            type: "code",
            name,
            preformatted: code,
        };
        return $$`<table class="w-100 stats stats--book">${Renderer.get().render(toRenderCode)}</table>`;
    },

    $getHoverContent_generic(toRender, opts) {
        opts = opts || {};

        return $$`<table class="w-100 stats ${opts.isBookContent || opts.isLargeBookContent ? "stats--book" : ""} ${opts.isLargeBookContent ? "stats--book-large" : ""}">${Renderer.hover.getGenericCompactRenderedString(toRender, opts.depth || 0)}</table>`;
    },

    doPopoutCurPage(evt, entity) {
        const page = UrlUtil.getCurrentPage();
        const $content = Renderer.hover.$getHoverContent_stats(page, entity);
        Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(evt), {
            pageUrl: `#${UrlUtil.autoEncodeHash(entity)}`,
            title: entity._displayName || entity.name,
            isPermanent: true,
            isBookContent: page === UrlUtil.PG_RECIPES,
            sourceData: entity,
        }, );
    },
};
Renderer.get = ()=>{
    if (!Renderer.defaultRenderer){Renderer.defaultRenderer = new Renderer();}
    return Renderer.defaultRenderer;
};
Renderer.splitFirstSpace = function(string) {
    const firstIndex = string.indexOf(" ");
    return firstIndex === -1 ? [string, ""] : [string.substr(0, firstIndex), string.substr(firstIndex + 1)];
};
Renderer._splitByTagsBase = function(leadingCharacter) {
    return function(string) {
        let tagDepth = 0;
        let char, char2;
        const out = [];
        let curStr = "";
        let isLastOpen = false;

        const len = string.length;
        for (let i = 0; i < len; ++i) {
            char = string[i];
            char2 = string[i + 1];

            switch (char) {
            case "{":
                isLastOpen = true;
                if (char2 === leadingCharacter) {
                    if (tagDepth++ > 0) {
                        curStr += "{";
                    } else {
                        out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));
                        curStr = `{${leadingCharacter}`;
                        ++i;
                    }
                } else
                    curStr += "{";
                break;

            case "}":
                isLastOpen = false;
                curStr += "}";
                if (tagDepth !== 0 && --tagDepth === 0) {
                    out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));
                    curStr = "";
                }
                break;

            case leadingCharacter:
                {
                    if (!isLastOpen)
                        curStr += "<VE_LEAD>";
                    else
                        curStr += leadingCharacter;
                    break;
                }

            default:
                isLastOpen = false;
                curStr += char;
                break;
            }
        }

        if (curStr)
            out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));

        return out;
    }
    ;
};

Renderer.splitByTags = Renderer._splitByTagsBase("@");
Renderer.splitByPropertyInjectors = Renderer._splitByTagsBase("=");

Renderer._splitByPipeBase = function(leadingCharacter) {
    return function(string) {
        let tagDepth = 0;
        let char, char2;
        const out = [];
        let curStr = "";

        const len = string.length;
        for (let i = 0; i < len; ++i) {
            char = string[i];
            char2 = string[i + 1];

            switch (char) {
            case "{":
                if (char2 === leadingCharacter)
                    tagDepth++;
                curStr += "{";

                break;

            case "}":
                if (tagDepth)
                    tagDepth--;
                curStr += "}";

                break;

            case "|":
                {
                    if (tagDepth)
                        curStr += "|";
                    else {
                        out.push(curStr);
                        curStr = "";
                    }
                    break;
                }

            default:
                {
                    curStr += char;
                    break;
                }
            }
        }

        if (curStr)
            out.push(curStr);
        return out;
    }
    ;
}
;

Renderer.splitTagByPipe = Renderer._splitByPipeBase("@");
Renderer.utils = {
    getBorderTr: (optText=null)=>{
        return `<tr><th class="border" colspan="6">${optText || ""}</th></tr>`;
    }
    ,

    getDividerTr: ()=>{
        return `<tr><td class="divider" colspan="6"><div></div></td></tr>`;
    }
    ,

    getSourceSubText(it) {
        return it.sourceSub ? ` \u2014 ${it.sourceSub}` : "";
    },

    getNameTr: (it,opts)=>{
        opts = opts || {};

        let dataPart = "";
        let pageLinkPart;
        if (opts.page) {
            const hash = UrlUtil.URL_TO_HASH_BUILDER[opts.page](it);
            dataPart = `data-page="${opts.page}" data-source="${it.source.escapeQuotes()}" data-hash="${hash.escapeQuotes()}" ${opts.extensionData != null ? `data-extension='${JSON.stringify(opts.extensionData).escapeQuotes()}` : ""}'`;
            pageLinkPart = SourceUtil.getAdventureBookSourceHref(it.source, it.page);

            if (opts.isEmbeddedEntity) { ExtensionUtil.addEmbeddedToCache(opts.page, it.source, hash, it); }
        }

        const tagPartSourceStart = `<${pageLinkPart ? `a href="${Renderer.get().baseUrl}${pageLinkPart}"` : "span"}`;
        const tagPartSourceEnd = `</${pageLinkPart ? "a" : "span"}>`;

        //TEMPFIX
        /* const ptBrewSourceLink = Renderer.utils._getNameTr_getPtPrereleaseBrewSourceLink({
            ent: it,
            brewUtil: PrereleaseUtil
        }) || Renderer.utils._getNameTr_getPtPrereleaseBrewSourceLink({
            ent: it,
            brewUtil: BrewUtil2
        }); */
        const ptBrewSourceLink = $(`<div></div>`); //Debug

        const $ele = $$`<tr>
			<th class="rnd-name ${opts.extraThClasses ? opts.extraThClasses.join(" ") : ""}" colspan="6" ${dataPart}>
				<div class="name-inner">
					<div class="ve-flex-v-center">
						<h1 class="stats-name copyable m-0" onmousedown="event.preventDefault()" onclick="Renderer.utils._pHandleNameClick(this)">${opts.prefix || ""}${it._displayName || it.name}${opts.suffix || ""}</h1>
						${opts.controlRhs || ""}
					</div>
					<div class="stats-source ve-flex-v-baseline">
						${tagPartSourceStart} class="help-subtle stats-source-abbreviation ${it.source ? `${Parser.sourceJsonToColor(it.source)}" title="${Parser.sourceJsonToFull(it.source)}
                        ${Renderer.utils.getSourceSubText(it)}` : ""}" ${Parser.sourceJsonToStyle(it.source)}>${it.source ? Parser.sourceJsonToAbv(it.source) : ""}${tagPartSourceEnd}

						${Renderer.utils.isDisplayPage(it.page) ? ` ${tagPartSourceStart} class="rd__stats-name-page ml-1" title="Page ${it.page}">p${it.page}${tagPartSourceEnd}` : ""}

						${ptBrewSourceLink}
					</div>
				</div>
			</th>
		</tr>`;

        if (opts.asJquery){return $ele;}
        else {return $ele[0].outerHTML;}
    },

    _getNameTr_getPtPrereleaseBrewSourceLink({ent, brewUtil}) {
        if (!brewUtil.hasSourceJson(ent.source) || !brewUtil.sourceJsonToSource(ent.source)?.url)
            return "";

        return `<a href="${brewUtil.sourceJsonToSource(ent.source).url}" title="View ${brewUtil.DISPLAY_NAME.toTitleCase()} Source" class="ve-self-flex-center ml-2 ve-muted rd__stats-name-brew-link" target="_blank" rel="noopener noreferrer"><span class="	glyphicon glyphicon-share"></span></a>`;
    },

    getBtnSendToFoundryHtml({isMb=true}={}) {
        return `<button title="Send to Foundry (SHIFT for Temporary Import)" class="btn btn-xs btn-default btn-stats-name mx-2 ${isMb ? "mb-2" : ""} ve-self-flex-end" onclick="ExtensionUtil.pDoSendStats(event, this)" draggable="true" ondragstart="ExtensionUtil.doDragStart(event, this)"><span class="glyphicon glyphicon-send"></span></button>`;
    },

    isDisplayPage(page) {
        return page != null && ((!isNaN(page) && page > 0) || isNaN(page));
    },

    getExcludedTr({entity, dataProp, page, isExcluded}) {
        const excludedHtml = Renderer.utils.getExcludedHtml({
            entity,
            dataProp,
            page,
            isExcluded
        });
        if (!excludedHtml)
            return "";
        return `<tr><td colspan="6" class="pt-3">${excludedHtml}</td></tr>`;
    },

    getExcludedHtml({entity, dataProp, page, isExcluded}) {
        if (isExcluded != null && !isExcluded)
            return "";
        if (isExcluded == null) {
            if (!ExcludeUtil.isInitialised)
                return "";
            if (page && !UrlUtil.URL_TO_HASH_BUILDER[page])
                return "";
            const hash = page ? UrlUtil.URL_TO_HASH_BUILDER[page](entity) : UrlUtil.autoEncodeHash(entity);
            isExcluded = isExcluded || dataProp === "item" ? Renderer.item.isExcluded(entity, {
                hash
            }) : ExcludeUtil.isExcluded(hash, dataProp, entity.source);
        }
        return isExcluded ? `<div class="ve-text-center text-danger"><b><i>Warning: This content has been <a href="blocklist.html">blocklisted</a>.</i></b></div>` : "";
    },

    getSourceAndPageTrHtml(it, {tag, fnUnpackUid}={}) {
        const html = Renderer.utils.getSourceAndPageHtml(it, {
            tag,
            fnUnpackUid
        });
        return html ? `<b>Source:</b> ${html}` : "";
    },

    _getAltSourceHtmlOrText(it, prop, introText, isText) {
        if (!it[prop] || !it[prop].length)
            return "";

        return `${introText} ${it[prop].map(as=>{
            if (as.entry)
                return (isText ? Renderer.stripTags : Renderer.get().render)(as.entry);
            return `${isText ? "" : `<i class="help-subtle" title="${Parser.sourceJsonToFull(as.source).qq()}">`}${Parser.sourceJsonToAbv(as.source)}${isText ? "" : `</i>`}${Renderer.utils.isDisplayPage(as.page) ? `, page ${as.page}` : ""}`;
        }
        ).join("; ")}`;
    },

    _getReprintedAsHtmlOrText(ent, {isText, tag, fnUnpackUid}={}) {
        if (!ent.reprintedAs)
            return "";
        if (!tag || !fnUnpackUid)
            return "";

        const ptReprinted = ent.reprintedAs.map(it=>{
            const uid = it.uid ?? it;
            const tag_ = it.tag ?? tag;

            const {name, source, displayText} = fnUnpackUid(uid);

            if (isText) {
                return `${Renderer.stripTags(displayText || name)} in ${Parser.sourceJsonToAbv(source)}`;
            }

            const asTag = `{@${tag_} ${name}|${source}${displayText ? `|${displayText}` : ""}}`;

            return `${Renderer.get().render(asTag)} in <i class="help-subtle" title="${Parser.sourceJsonToFull(source).qq()}">${Parser.sourceJsonToAbv(source)}</i>`;
        }
        ).join("; ");

        return `Reprinted as ${ptReprinted}`;
    },

    getSourceAndPageHtml(it, {tag, fnUnpackUid}={}) {
        return this._getSourceAndPageHtmlOrText(it, {
            tag,
            fnUnpackUid
        });
    },
    getSourceAndPageText(it, {tag, fnUnpackUid}={}) {
        return this._getSourceAndPageHtmlOrText(it, {
            isText: true,
            tag,
            fnUnpackUid
        });
    },

    _getSourceAndPageHtmlOrText(it, {isText, tag, fnUnpackUid}={}) {
        const sourceSub = Renderer.utils.getSourceSubText(it);
        const baseText = `${isText ? `` : `<i title="${Parser.sourceJsonToFull(it.source)}${sourceSub}">`}${Parser.sourceJsonToAbv(it.source)}${sourceSub}${isText ? "" : `</i>`}${Renderer.utils.isDisplayPage(it.page) ? `, page ${it.page}` : ""}`;
        const reprintedAsText = Renderer.utils._getReprintedAsHtmlOrText(it, {
            isText,
            tag,
            fnUnpackUid
        });
        const addSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "additionalSources", "Additional information from", isText);
        const otherSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "otherSources", "Also found in", isText);
        const externalSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "externalSources", "External sources:", isText);

        const srdText = it.srd ? `${isText ? "" : `the <span title="Systems Reference Document">`}SRD${isText ? "" : `</span>`}${typeof it.srd === "string" ? ` (as &quot;${it.srd}&quot;)` : ""}` : "";
        const basicRulesText = it.basicRules ? `the Basic Rules${typeof it.basicRules === "string" ? ` (as &quot;${it.basicRules}&quot;)` : ""}` : "";
        const srdAndBasicRulesText = (srdText || basicRulesText) ? `Available in ${[srdText, basicRulesText].filter(it=>it).join(" and ")}` : "";

        return `${[baseText, addSourceText, reprintedAsText, otherSourceText, srdAndBasicRulesText, externalSourceText].filter(it=>it).join(". ")}${baseText && (addSourceText || otherSourceText || srdAndBasicRulesText || externalSourceText) ? "." : ""}`;
    },

    async _pHandleNameClick(ele) {
        await MiscUtil.pCopyTextToClipboard($(ele).text());
        JqueryUtil.showCopiedEffect($(ele));
    },

    getPageTr(it, {tag, fnUnpackUid}={}) {
        return `<tr><td colspan=6>${Renderer.utils.getSourceAndPageTrHtml(it, {
            tag,
            fnUnpackUid
        })}</td></tr>`;
    },

    getAbilityRollerEntry(statblock, ability) {
        if (statblock[ability] == null)
            return "\u2014";
        return `{@ability ${ability} ${statblock[ability]}}`;
    },

    getAbilityRoller(statblock, ability) {
        return Renderer.get().render(Renderer.utils.getAbilityRollerEntry(statblock, ability));
    },

    getEmbeddedDataHeader(name, style, {isCollapsed=false}={}) {
        return `<table class="rd__b-special rd__b-data ${style ? `rd__b-data--${style}` : ""}">
		<thead><tr><th class="rd__data-embed-header" colspan="6" data-rd-data-embed-header="true"><span class="rd__data-embed-name ${isCollapsed ? "" : `ve-hidden`}">${name}</span><span class="rd__data-embed-toggle">[${isCollapsed ? "+" : "\u2013"}]</span></th></tr></thead><tbody class="${isCollapsed ? `ve-hidden` : ""}" data-rd-embedded-data-render-target="true">`;
    },

    getEmbeddedDataFooter() {
        return `</tbody></table>`;
    },

    TabButton: function({label, fnChange, fnPopulate, isVisible}) {
        this.label = label;
        this.fnChange = fnChange;
        this.fnPopulate = fnPopulate;
        this.isVisible = isVisible;
    },

    _tabs: {},
    _curTab: null,
    _tabsPreferredLabel: null,
    bindTabButtons({tabButtons, tabLabelReference, $wrpTabs, $pgContent}) {
        Renderer.utils._tabs = {};
        Renderer.utils._curTab = null;

        $wrpTabs.find(`.stat-tab-gen`).remove();

        tabButtons.forEach((tb,i)=>{
            tb.ix = i;

            tb.$t = $(`<button class="ui-tab__btn-tab-head btn btn-default stat-tab-gen">${tb.label}</button>`).click(()=>tb.fnActivateTab({
                isUserInput: true
            }));

            tb.fnActivateTab = ({isUserInput=false}={})=>{
                const curTab = Renderer.utils._curTab;
                const tabs = Renderer.utils._tabs;

                if (!curTab || curTab.label !== tb.label) {
                    if (curTab)
                        curTab.$t.removeClass(`ui-tab__btn-tab-head--active`);
                    Renderer.utils._curTab = tb;
                    tb.$t.addClass(`ui-tab__btn-tab-head--active`);
                    if (curTab)
                        tabs[curTab.label].$content = $pgContent.children().detach();

                    tabs[tb.label] = tb;
                    if (!tabs[tb.label].$content && tb.fnPopulate)
                        tb.fnPopulate();
                    else
                        $pgContent.append(tabs[tb.label].$content);
                    if (tb.fnChange)
                        tb.fnChange();
                }

                if (isUserInput)
                    Renderer.utils._tabsPreferredLabel = tb.label;
            }
            ;
        }
        );

        if (tabButtons.length !== 1)
            tabButtons.slice().reverse().forEach(tb=>$wrpTabs.prepend(tb.$t));

        if (!Renderer.utils._tabsPreferredLabel)
            return tabButtons[0].fnActivateTab();

        const tabButton = tabButtons.find(tb=>tb.label === Renderer.utils._tabsPreferredLabel);
        if (tabButton)
            return tabButton.fnActivateTab();

        const ixDesired = tabLabelReference.indexOf(Renderer.utils._tabsPreferredLabel);
        if (!~ixDesired)
            return tabButtons[0].fnActivateTab();
        const ixsAvailableMetas = tabButtons.map(tb=>{
            const ixMapped = tabLabelReference.indexOf(tb.label);
            if (!~ixMapped)
                return null;
            return {
                ixMapped,
                label: tb.label,
            };
        }
        ).filter(Boolean);
        if (!ixsAvailableMetas.length)
            return tabButtons[0].fnActivateTab();
        const ixMetaHigher = ixsAvailableMetas.find(({ixMapped})=>ixMapped > ixDesired);
        if (ixMetaHigher != null)
            return (tabButtons.find(it=>it.label === ixMetaHigher.label) || tabButtons[0]).fnActivateTab();

        const ixMetaMax = ixsAvailableMetas.last();
        (tabButtons.find(it=>it.label === ixMetaMax.label) || tabButtons[0]).fnActivateTab();
    },

    _pronounceButtonsBound: false,
    bindPronounceButtons() {
        if (Renderer.utils._pronounceButtonsBound)
            return;
        Renderer.utils._pronounceButtonsBound = true;
        $(`body`).on("click", ".btn-name-pronounce", function() {
            const audio = $(this).find(`.name-pronounce`)[0];
            audio.currentTime = 0;
            audio.play();
        });
    },

    async pHasFluffText(entity, prop) {
        return entity.hasFluff || ((await Renderer.utils.pGetPredefinedFluff(entity, prop))?.entries?.length || 0) > 0;
    },

    async pHasFluffImages(entity, prop) {
        return entity.hasFluffImages || (((await Renderer.utils.pGetPredefinedFluff(entity, prop))?.images?.length || 0) > 0);
    },

    async pGetPredefinedFluff(entry, prop) {
        if (!entry.fluff)
            return null;

        const mappedProp = `_${prop}`;
        const mappedPropAppend = `_append${prop.uppercaseFirst()}`;
        const fluff = {};

        const assignPropsIfExist = (fromObj,...props)=>{
            props.forEach(prop=>{
                if (fromObj[prop])
                    fluff[prop] = fromObj[prop];
            }
            );
        }
        ;

        assignPropsIfExist(entry.fluff, "name", "type", "entries", "images");

        if (entry.fluff[mappedProp]) {
            const fromList = [...((await PrereleaseUtil.pGetBrewProcessed())[prop] || []), ...((await BrewUtil2.pGetBrewProcessed())[prop] || []), ].find(it=>it.name === entry.fluff[mappedProp].name && it.source === entry.fluff[mappedProp].source, );
            if (fromList) {
                assignPropsIfExist(fromList, "name", "type", "entries", "images");
            }
        }

        if (entry.fluff[mappedPropAppend]) {
            const fromList = [...((await PrereleaseUtil.pGetBrewProcessed())[prop] || []), ...((await BrewUtil2.pGetBrewProcessed())[prop] || []), ].find(it=>it.name === entry.fluff[mappedPropAppend].name && it.source === entry.fluff[mappedPropAppend].source, );
            if (fromList) {
                if (fromList.entries) {
                    fluff.entries = MiscUtil.copyFast(fluff.entries || []);
                    fluff.entries.push(...MiscUtil.copyFast(fromList.entries));
                }
                if (fromList.images) {
                    fluff.images = MiscUtil.copyFast(fluff.images || []);
                    fluff.images.push(...MiscUtil.copyFast(fromList.images));
                }
            }
        }

        return fluff;
    },

    async pGetFluff({entity, pFnPostProcess, fnGetFluffData, fluffUrl, fluffBaseUrl, fluffProp}={}) {
        let predefinedFluff = await Renderer.utils.pGetPredefinedFluff(entity, fluffProp);
        if (predefinedFluff) {
            if (pFnPostProcess)
                predefinedFluff = await pFnPostProcess(predefinedFluff);
            return predefinedFluff;
        }
        if (!fnGetFluffData && !fluffBaseUrl && !fluffUrl)
            return null;

        const fluffIndex = fluffBaseUrl ? await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffBaseUrl}fluff-index.json`) : null;
        if (fluffIndex && !fluffIndex[entity.source])
            return null;

        const data = fnGetFluffData ? await fnGetFluffData() : fluffIndex && fluffIndex[entity.source] ? await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffBaseUrl}${fluffIndex[entity.source]}`) : await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffUrl}`);
        if (!data)
            return null;

        let fluff = (data[fluffProp] || []).find(it=>it.name === entity.name && it.source === entity.source);
        if (!fluff && entity._versionBase_name && entity._versionBase_source)
            fluff = (data[fluffProp] || []).find(it=>it.name === entity._versionBase_name && it.source === entity._versionBase_source);
        if (!fluff)
            return null;

        if (pFnPostProcess)
            fluff = await pFnPostProcess(fluff);
        return fluff;
    },

    _TITLE_SKIP_TYPES: new Set(["entries", "section"]),
    async pBuildFluffTab({isImageTab, $content, entity, $headerControls, pFnGetFluff}={}) {
        $content.append(Renderer.utils.getBorderTr());
        $content.append(Renderer.utils.getNameTr(entity, {
            controlRhs: $headerControls,
            asJquery: true
        }));
        const $td = $(`<td colspan="6" class="text"></td>`);
        $$`<tr class="text">${$td}</tr>`.appendTo($content);
        $content.append(Renderer.utils.getBorderTr());

        const fluff = MiscUtil.copyFast((await pFnGetFluff(entity)) || {});
        fluff.entries = fluff.entries || [Renderer.utils.HTML_NO_INFO];
        fluff.images = fluff.images || [Renderer.utils.HTML_NO_IMAGES];

        $td.fastSetHtml(Renderer.utils.getFluffTabContent({
            entity,
            fluff,
            isImageTab
        }));
    },

    getFluffTabContent({entity, fluff, isImageTab=false}) {
        Renderer.get().setFirstSection(true);
        return (fluff[isImageTab ? "images" : "entries"] || []).map((ent,i)=>{
            if (isImageTab)
                return Renderer.get().render(ent);

            if (i === 0 && ent.name && entity.name && (Renderer.utils._TITLE_SKIP_TYPES).has(ent.type)) {
                const entryLowName = ent.name.toLowerCase().trim();
                const entityLowName = entity.name.toLowerCase().trim();

                if (entryLowName.includes(entityLowName) || entityLowName.includes(entryLowName)) {
                    const cpy = MiscUtil.copyFast(ent);
                    delete cpy.name;
                    return Renderer.get().render(cpy);
                } else
                    return Renderer.get().render(ent);
            } else {
                if (typeof ent === "string")
                    return `<p>${Renderer.get().render(ent)}</p>`;
                else
                    return Renderer.get().render(ent);
            }
        }
        ).join("");
    },

    HTML_NO_INFO: "<i>No information available.</i>",
    HTML_NO_IMAGES: "<i>No images available.</i>",

    /* prerequisite: class {
        static _WEIGHTS = ["level", "pact", "patron", "spell", "race", "alignment", "ability", "proficiency", "spellcasting", "spellcasting2020", "spellcastingFeature", "spellcastingPrepared", "psionics", "feature", "feat", "background", "item", "itemType", "itemProperty", "campaign", "group", "other", "otherSummary", undefined, ].mergeMap((k,i)=>({
            [k]: i
        }));

        static _getShortClassName(className) {
            const ixFirstVowel = /[aeiou]/.exec(className).index;
            const start = className.slice(0, ixFirstVowel + 1);
            let end = className.slice(ixFirstVowel + 1);
            end = end.replace(/[aeiou]/g, "");
            return `${start}${end}`.toTitleCase();
        }

        static getHtml(prerequisites, {isListMode=false, blocklistKeys=new Set(), isTextOnly=false, isSkipPrefix=false}={}) {
            if (!prerequisites?.length)
                return isListMode ? "\u2014" : "";

            const prereqsShared = prerequisites.length === 1 ? {} : Object.entries(prerequisites.slice(1).reduce((a,b)=>CollectionUtil.objectIntersect(a, b), prerequisites[0]), ).filter(([k,v])=>prerequisites.every(pre=>CollectionUtil.deepEquals(pre[k], v))).mergeMap(([k,v])=>({
                [k]: v
            }));

            const shared = Object.keys(prereqsShared).length ? this.getHtml([prereqsShared], {
                isListMode,
                blocklistKeys,
                isTextOnly,
                isSkipPrefix: true
            }) : null;

            let cntPrerequisites = 0;
            let hasNote = false;
            const listOfChoices = prerequisites.map(pr=>{
                const ptNote = !isListMode && pr.note ? Renderer.get().render(pr.note) : null;
                if (ptNote) {
                    hasNote = true;
                }

                const prereqsToJoin = Object.entries(pr).filter(([k])=>!prereqsShared[k]).sort(([kA],[kB])=>this._WEIGHTS[kA] - this._WEIGHTS[kB]).map(([k,v])=>{
                    if (k === "note" || blocklistKeys.has(k))
                        return false;

                    cntPrerequisites += 1;

                    switch (k) {
                    case "level":
                        return this._getHtml_level({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "pact":
                        return this._getHtml_pact({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "patron":
                        return this._getHtml_patron({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spell":
                        return this._getHtml_spell({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "feat":
                        return this._getHtml_feat({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "feature":
                        return this._getHtml_feature({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "item":
                        return this._getHtml_item({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "itemType":
                        return this._getHtml_itemType({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "itemProperty":
                        return this._getHtml_itemProperty({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "otherSummary":
                        return this._getHtml_otherSummary({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "other":
                        return this._getHtml_other({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "race":
                        return this._getHtml_race({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "background":
                        return this._getHtml_background({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "ability":
                        return this._getHtml_ability({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "proficiency":
                        return this._getHtml_proficiency({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcasting":
                        return this._getHtml_spellcasting({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcasting2020":
                        return this._getHtml_spellcasting2020({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcastingFeature":
                        return this._getHtml_spellcastingFeature({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcastingPrepared":
                        return this._getHtml_spellcastingPrepared({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "psionics":
                        return this._getHtml_psionics({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "alignment":
                        return this._getHtml_alignment({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "campaign":
                        return this._getHtml_campaign({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "group":
                        return this._getHtml_group({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    default:
                        throw new Error(`Unhandled key: ${k}`);
                    }
                }
                ).filter(Boolean);

                const ptPrereqs = prereqsToJoin.join(prereqsToJoin.some(it=>/ or /.test(it)) ? "; " : ", ");

                return [ptPrereqs, ptNote].filter(Boolean).join(". ");
            }
            ).filter(Boolean);

            if (!listOfChoices.length && !shared)
                return isListMode ? "\u2014" : "";
            if (isListMode)
                return [shared, listOfChoices.join("/")].filter(Boolean).join(" + ");

            const sharedSuffix = MiscUtil.findCommonSuffix(listOfChoices, {
                isRespectWordBoundaries: true
            });
            const listOfChoicesTrimmed = sharedSuffix ? listOfChoices.map(it=>it.slice(0, -sharedSuffix.length)) : listOfChoices;

            const joinedChoices = (hasNote ? listOfChoicesTrimmed.join(" Or, ") : listOfChoicesTrimmed.joinConjunct(listOfChoicesTrimmed.some(it=>/ or /.test(it)) ? "; " : ", ", " or ")) + sharedSuffix;
            return `${isSkipPrefix ? "" : `Prerequisite${cntPrerequisites === 1 ? "" : "s"}: `}${[shared, joinedChoices].filter(Boolean).join(", plus ")}`;
        }

        static _getHtml_level({v, isListMode}) {
            if (typeof v === "number") {
                if (isListMode)
                    return `Lvl ${v}`;
                else
                    return `${Parser.getOrdinalForm(v)} level`;
            } else if (!v.class && !v.subclass) {
                if (isListMode)
                    return `Lvl ${v.level}`;
                else
                    return `${Parser.getOrdinalForm(v.level)} level`;
            }

            const isLevelVisible = v.level !== 1;
            const isSubclassVisible = v.subclass && v.subclass.visible;
            const isClassVisible = v.class && (v.class.visible || isSubclassVisible);
            if (isListMode) {
                const shortNameRaw = isClassVisible ? this._getShortClassName(v.class.name) : null;
                return `${isClassVisible ? `${shortNameRaw.slice(0, 4)}${isSubclassVisible ? "*" : "."}` : ""}${isLevelVisible ? ` Lvl ${v.level}` : ""}`;
            } else {
                let classPart = "";
                if (isClassVisible && isSubclassVisible)
                    classPart = ` ${v.class.name} (${v.subclass.name})`;
                else if (isClassVisible)
                    classPart = ` ${v.class.name}`;
                else if (isSubclassVisible)
                    classPart = ` &lt;remember to insert class name here&gt; (${v.subclass.name})`;
                return `${isLevelVisible ? `${Parser.getOrdinalForm(v.level)} level` : ""}${isClassVisible ? ` ${classPart}` : ""}`;
            }
        }

        static _getHtml_pact({v, isListMode}) {
            return Parser.prereqPactToFull(v);
        }

        static _getHtml_patron({v, isListMode}) {
            return isListMode ? `${Parser.prereqPatronToShort(v)} patron` : `${v} patron`;
        }

        static _getHtml_spell({v, isListMode, isTextOnly}) {
            return isListMode ? v.map(sp=>{
                if (typeof sp === "string")
                    return sp.split("#")[0].split("|")[0].toTitleCase();
                return sp.entrySummary || sp.entry;
            }
            ).join("/") : v.map(sp=>{
                if (typeof sp === "string")
                    return Parser.prereqSpellToFull(sp, {
                        isTextOnly
                    });
                return isTextOnly ? Renderer.stripTags(sp.entry) : Renderer.get().render(`{@filter ${sp.entry}|spells|${sp.choose}}`);
            }
            ).joinConjunct(", ", " or ");
        }

        static _getHtml_feat({v, isListMode, isTextOnly}) {
            return isListMode ? v.map(x=>x.split("|")[0].toTitleCase()).join("/") : v.map(it=>(isTextOnly ? Renderer.stripTags.bind(Renderer) : Renderer.get().render.bind(Renderer.get()))(`{@feat ${it}} feat`)).joinConjunct(", ", " or ");
        }

        static _getHtml_feature({v, isListMode, isTextOnly}) {
            return isListMode ? v.map(x=>Renderer.stripTags(x).toTitleCase()).join("/") : v.map(it=>isTextOnly ? Renderer.stripTags(it) : Renderer.get().render(it)).joinConjunct(", ", " or ");
        }

        static _getHtml_item({v, isListMode}) {
            return isListMode ? v.map(x=>x.toTitleCase()).join("/") : v.joinConjunct(", ", " or ");
        }

        static _getHtml_itemType({v, isListMode}) {
            return isListMode ? v.map(it=>Renderer.item.getType(it)).map(it=>it?.abbreviation).join("+") : v.map(it=>Renderer.item.getType(it)).map(it=>it?.name?.toTitleCase()).joinConjunct(", ", " and ");
        }

        static _getHtml_itemProperty({v, isListMode}) {
            if (v == null)
                return isListMode ? "No Prop." : "No Other Properties";

            return isListMode ? v.map(it=>Renderer.item.getProperty(it)).map(it=>it?.abbreviation).join("+") : (`${v.map(it=>Renderer.item.getProperty(it)).map(it=>it?.name?.toTitleCase()).joinConjunct(", ", " and ")} Property`);
        }

        static _getHtml_otherSummary({v, isListMode, isTextOnly}) {
            return isListMode ? (v.entrySummary || Renderer.stripTags(v.entry)) : (isTextOnly ? Renderer.stripTags(v.entry) : Renderer.get().render(v.entry));
        }

        static _getHtml_other({v, isListMode, isTextOnly}) {
            return isListMode ? "Special" : (isTextOnly ? Renderer.stripTags(v) : Renderer.get().render(v));
        }

        static _getHtml_race({v, isListMode, isTextOnly}) {
            const parts = v.map((it,i)=>{
                if (isListMode) {
                    return `${it.name.toTitleCase()}${it.subrace != null ? ` (${it.subrace})` : ""}`;
                } else {
                    const raceName = it.displayEntry ? (isTextOnly ? Renderer.stripTags(it.displayEntry) : Renderer.get().render(it.displayEntry)) : i === 0 ? it.name.toTitleCase() : it.name;
                    return `${raceName}${it.subrace != null ? ` (${it.subrace})` : ""}`;
                }
            }
            );
            return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
        }

        static _getHtml_background({v, isListMode, isTextOnly}) {
            const parts = v.map((it,i)=>{
                if (isListMode) {
                    return `${it.name.toTitleCase()}`;
                } else {
                    return it.displayEntry ? (isTextOnly ? Renderer.stripTags(it.displayEntry) : Renderer.get().render(it.displayEntry)) : i === 0 ? it.name.toTitleCase() : it.name;
                }
            }
            );
            return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
        }

        static _getHtml_ability({v, isListMode, isTextOnly}) {

            let hadMultipleInner = false;
            let hadMultiMultipleInner = false;
            let allValuesEqual = null;

            outer: for (const abMeta of v) {
                for (const req of Object.values(abMeta)) {
                    if (allValuesEqual == null)
                        allValuesEqual = req;
                    else {
                        if (req !== allValuesEqual) {
                            allValuesEqual = null;
                            break outer;
                        }
                    }
                }
            }

            const abilityOptions = v.map(abMeta=>{
                if (allValuesEqual) {
                    const abList = Object.keys(abMeta);
                    hadMultipleInner = hadMultipleInner || abList.length > 1;
                    return isListMode ? abList.map(ab=>ab.uppercaseFirst()).join(", ") : abList.map(ab=>Parser.attAbvToFull(ab)).joinConjunct(", ", " and ");
                } else {
                    const groups = {};

                    Object.entries(abMeta).forEach(([ab,req])=>{
                        (groups[req] = groups[req] || []).push(ab);
                    }
                    );

                    let isMulti = false;
                    const byScore = Object.entries(groups).sort(([reqA],[reqB])=>SortUtil.ascSort(Number(reqB), Number(reqA))).map(([req,abs])=>{
                        hadMultipleInner = hadMultipleInner || abs.length > 1;
                        if (abs.length > 1)
                            hadMultiMultipleInner = isMulti = true;

                        abs = abs.sort(SortUtil.ascSortAtts);
                        return isListMode ? `${abs.map(ab=>ab.uppercaseFirst()).join(", ")} ${req}+` : `${abs.map(ab=>Parser.attAbvToFull(ab)).joinConjunct(", ", " and ")} ${req} or higher`;
                    }
                    );

                    return isListMode ? `${isMulti || byScore.length > 1 ? "(" : ""}${byScore.join(" & ")}${isMulti || byScore.length > 1 ? ")" : ""}` : isMulti ? byScore.joinConjunct("; ", " and ") : byScore.joinConjunct(", ", " and ");
                }
            }
            );

            if (isListMode) {
                return `${abilityOptions.join("/")}${allValuesEqual != null ? ` ${allValuesEqual}+` : ""}`;
            } else {
                const isComplex = hadMultiMultipleInner || hadMultipleInner || allValuesEqual == null;
                const joined = abilityOptions.joinConjunct(hadMultiMultipleInner ? " - " : hadMultipleInner ? "; " : ", ", isComplex ? (isTextOnly ? ` /or/ ` : ` <i>or</i> `) : " or ", );
                return `${joined}${allValuesEqual != null ? ` ${allValuesEqual} or higher` : ""}`;
            }
        }

        static _getHtml_proficiency({v, isListMode}) {
            const parts = v.map(obj=>{
                return Object.entries(obj).map(([profType,prof])=>{
                    switch (profType) {
                    case "armor":
                        {
                            return isListMode ? `Prof ${Parser.armorFullToAbv(prof)} armor` : `Proficiency with ${prof} armor`;
                        }
                    case "weapon":
                        {
                            return isListMode ? `Prof ${Parser.weaponFullToAbv(prof)} weapon` : `Proficiency with a ${prof} weapon`;
                        }
                    case "weaponGroup":
                        {
                            return isListMode ? `Prof ${Parser.weaponFullToAbv(prof)} weapons` : `${prof.toTitleCase()} Proficiency`;
                        }
                    default:
                        throw new Error(`Unhandled proficiency type: "${profType}"`);
                    }
                }
                );
            }
            );
            return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
        }

        static _getHtml_spellcasting({v, isListMode}) {
            return isListMode ? "Spellcasting" : "The ability to cast at least one spell";
        }

        static _getHtml_spellcasting2020({v, isListMode}) {
            return isListMode ? "Spellcasting" : "Spellcasting or Pact Magic feature";
        }

        static _getHtml_spellcastingFeature({v, isListMode}) {
            return isListMode ? "Spellcasting" : "Spellcasting Feature";
        }

        static _getHtml_spellcastingPrepared({v, isListMode}) {
            return isListMode ? "Spellcasting" : "Spellcasting feature from a class that prepares spells";
        }

        static _getHtml_psionics({v, isListMode, isTextOnly}) {
            return isListMode ? "Psionics" : (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))("Psionic Talent feature or Wild Talent feat");
        }

        static _getHtml_alignment({v, isListMode}) {
            return isListMode ? Parser.alignmentListToFull(v).replace(/\bany\b/gi, "").trim().replace(/\balignment\b/gi, "align").trim().toTitleCase() : Parser.alignmentListToFull(v);
        }

        static _getHtml_campaign({v, isListMode}) {
            return isListMode ? v.join("/") : `${v.joinConjunct(", ", " or ")} Campaign`;
        }

        static _getHtml_group({v, isListMode}) {
            return isListMode ? v.map(it=>it.toTitleCase()).join("/") : `${v.map(it=>it.toTitleCase()).joinConjunct(", ", " or ")} Group`;
        }
    }, */

    getRepeatableEntry(ent) {
        if (!ent.repeatable)
            return null;
        return `{@b Repeatable:} ${ent.repeatableNote || (ent.repeatable ? "Yes" : "No")}`;
    },

    getRepeatableHtml(ent, {isListMode=false}={}) {
        const entryRepeatable = Renderer.utils.getRepeatableEntry(ent);
        if (entryRepeatable == null)
            return isListMode ? "\u2014" : "";
        return Renderer.get().render(entryRepeatable);
    },

    getRenderedSize(size) {
        return [...(size ? [size].flat() : [])].sort(SortUtil.ascSortSize).map(sz=>Parser.sizeAbvToFull(sz)).joinConjunct(", ", " or ");
    },

    getMediaUrl(entry, prop, mediaDir) {
        if (!entry[prop])
            return "";

        let href = "";
        if (entry[prop].type === "internal") {
            const baseUrl = Renderer.get().baseMediaUrls[mediaDir] || Renderer.get().baseUrl;
            const mediaPart = `${mediaDir}/${entry[prop].path}`;
            href = baseUrl !== "" ? `${baseUrl}${mediaPart}` : UrlUtil.link(mediaPart);
        } else if (entry[prop].type === "external") {
            href = entry[prop].url;
        }
        return href;
    },

    getTagEntry(tag, text) {
        switch (tag) {
        case "@dice":
        case "@autodice":
        case "@damage":
        case "@hit":
        case "@d20":
        case "@chance":
        case "@recharge":
            {
                const fauxEntry = {
                    type: "dice",
                    rollable: true,
                };
                const [rollText,displayText,name,...others] = Renderer.splitTagByPipe(text);
                if (displayText)
                    fauxEntry.displayText = displayText;

                if ((!fauxEntry.displayText && (rollText || "").includes("summonSpellLevel")) || (fauxEntry.displayText && fauxEntry.displayText.includes("summonSpellLevel")))
                    fauxEntry.displayText = (fauxEntry.displayText || rollText || "").replace(/summonSpellLevel/g, "the spell's level");

                if ((!fauxEntry.displayText && (rollText || "").includes("summonClassLevel")) || (fauxEntry.displayText && fauxEntry.displayText.includes("summonClassLevel")))
                    fauxEntry.displayText = (fauxEntry.displayText || rollText || "").replace(/summonClassLevel/g, "your class level");

                if (name)
                    fauxEntry.name = name;

                switch (tag) {
                case "@dice":
                case "@autodice":
                case "@damage":
                    {
                        fauxEntry.toRoll = rollText;

                        if (!fauxEntry.displayText && (rollText || "").includes(";"))
                            fauxEntry.displayText = rollText.replace(/;/g, "/");
                        if ((!fauxEntry.displayText && (rollText || "").includes("#$")) || (fauxEntry.displayText && fauxEntry.displayText.includes("#$")))
                            fauxEntry.displayText = (fauxEntry.displayText || rollText).replace(/#\$prompt_number[^$]*\$#/g, "(n)");
                        fauxEntry.displayText = fauxEntry.displayText || fauxEntry.toRoll;

                        if (tag === "@damage")
                            fauxEntry.subType = "damage";
                        if (tag === "@autodice")
                            fauxEntry.autoRoll = true;

                        return fauxEntry;
                    }
                case "@d20":
                case "@hit":
                    {
                        let mod;
                        if (!isNaN(rollText)) {
                            const n = Number(rollText);
                            mod = `${n >= 0 ? "+" : ""}${n}`;
                        } else
                            mod = /^\s+[-+]/.test(rollText) ? rollText : `+${rollText}`;
                        fauxEntry.displayText = fauxEntry.displayText || mod;
                        fauxEntry.toRoll = `1d20${mod}`;
                        fauxEntry.subType = "d20";
                        fauxEntry.d20mod = mod;
                        if (tag === "@hit")
                            fauxEntry.context = {
                                type: "hit"
                            };
                        return fauxEntry;
                    }
                case "@chance":
                    {
                        const [textSuccess,textFailure] = others;
                        fauxEntry.toRoll = `1d100`;
                        fauxEntry.successThresh = Number(rollText);
                        fauxEntry.chanceSuccessText = textSuccess;
                        fauxEntry.chanceFailureText = textFailure;
                        return fauxEntry;
                    }
                case "@recharge":
                    {
                        const flags = displayText ? displayText.split("") : null;
                        fauxEntry.toRoll = "1d6";
                        const asNum = Number(rollText || 6);
                        fauxEntry.successThresh = 7 - asNum;
                        fauxEntry.successMax = 6;
                        fauxEntry.displayText = `${asNum}${asNum < 6 ? `\u20136` : ""}`;
                        fauxEntry.chanceSuccessText = "Recharged!";
                        fauxEntry.chanceFailureText = "Did not recharge";
                        fauxEntry.isColorSuccessFail = true;
                        return fauxEntry;
                    }
                }

                return fauxEntry;
            }

        case "@ability":
        case "@savingThrow":
            {
                const fauxEntry = {
                    type: "dice",
                    rollable: true,
                    subType: "d20",
                    context: {
                        type: tag === "@ability" ? "abilityCheck" : "savingThrow"
                    },
                };

                const [abilAndScoreOrScore,displayText,name,...others] = Renderer.splitTagByPipe(text);

                let[abil,...rawScoreOrModParts] = abilAndScoreOrScore.split(" ").map(it=>it.trim()).filter(Boolean);
                abil = abil.toLowerCase();

                fauxEntry.context.ability = abil;

                if (name)
                    fauxEntry.name = name;
                else {
                    if (tag === "@ability")
                        fauxEntry.name = Parser.attAbvToFull(abil);
                    else if (tag === "@savingThrow")
                        fauxEntry.name = `${Parser.attAbvToFull(abil)} save`;
                }

                const rawScoreOrMod = rawScoreOrModParts.join(" ");
                if (isNaN(rawScoreOrMod) && tag === "@savingThrow") {
                    if (displayText)
                        fauxEntry.displayText = displayText;
                    else
                        fauxEntry.displayText = rawScoreOrMod;

                    fauxEntry.toRoll = `1d20${rawScoreOrMod}`;
                    fauxEntry.d20mod = rawScoreOrMod;
                } else {
                    const scoreOrMod = Number(rawScoreOrMod) || 0;
                    const mod = (tag === "@ability" ? Parser.getAbilityModifier : UiUtil.intToBonus)(scoreOrMod);

                    if (displayText)
                        fauxEntry.displayText = displayText;
                    else {
                        if (tag === "@ability")
                            fauxEntry.displayText = `${scoreOrMod} (${mod})`;
                        else
                            fauxEntry.displayText = mod;
                    }

                    fauxEntry.toRoll = `1d20${mod}`;
                    fauxEntry.d20mod = mod;
                }

                return fauxEntry;
            }

        case "@skillCheck":
            {
                const fauxEntry = {
                    type: "dice",
                    rollable: true,
                    subType: "d20",
                    context: {
                        type: "skillCheck"
                    },
                };

                const [skillAndMod,displayText,name,...others] = Renderer.splitTagByPipe(text);

                const parts = skillAndMod.split(" ").map(it=>it.trim()).filter(Boolean);
                const namePart = parts.shift();
                const bonusPart = parts.join(" ");
                const skill = namePart.replace(/_/g, " ");

                let mod = bonusPart;
                if (!isNaN(bonusPart))
                    mod = UiUtil.intToBonus(Number(bonusPart) || 0);
                else if (bonusPart.startsWith("#$"))
                    mod = `+${bonusPart}`;

                fauxEntry.context.skill = skill;
                fauxEntry.displayText = displayText || mod;

                if (name)
                    fauxEntry.name = name;
                else
                    fauxEntry.name = skill.toTitleCase();

                fauxEntry.toRoll = `1d20${mod}`;
                fauxEntry.d20mod = mod;

                return fauxEntry;
            }

        case "@coinflip":
            {
                const [displayText,name,textSuccess,textFailure] = Renderer.splitTagByPipe(text);

                const fauxEntry = {
                    type: "dice",
                    toRoll: "1d2",
                    successThresh: 1,
                    successMax: 2,
                    displayText: displayText || "flip a coin",
                    chanceSuccessText: textSuccess || `Heads`,
                    chanceFailureText: textFailure || `Tails`,
                    isColorSuccessFail: !textSuccess && !textFailure,
                    rollable: true,
                };

                return fauxEntry;
            }

        default:
            throw new Error(`Unhandled tag "${tag}"`);
        }
    },

    getTagMeta(tag, text) {
        switch (tag) {
        case "@deity":
            {
                let[name,pantheon,source,displayText,...others] = Renderer.splitTagByPipe(text);
                pantheon = pantheon || "forgotten realms";
                source = source || Parser.getTagSource(tag, source);
                const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES]({
                    name,
                    pantheon,
                    source
                });

                return {
                    name,
                    displayText,
                    others,

                    page: UrlUtil.PG_DEITIES,
                    source,
                    hash,

                    hashPreEncoded: true,
                };
            }

        case "@card":
            {
                const unpacked = DataUtil.deck.unpackUidCard(text);
                const {name, set, source, displayText} = unpacked;
                const hash = UrlUtil.URL_TO_HASH_BUILDER["card"]({
                    name,
                    set,
                    source
                });

                return {
                    name,
                    displayText,

                    isFauxPage: true,
                    page: "card",
                    source,
                    hash,
                    hashPreEncoded: true,
                };
            }

        case "@classFeature":
            {
                const unpacked = DataUtil.class.unpackUidClassFeature(text);

                const classPageHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
                    name: unpacked.className,
                    source: unpacked.classSource
                })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                    feature: {
                        ixLevel: unpacked.level - 1,
                        ixFeature: 0
                    }
                })}`;

                return {
                    name: unpacked.name,
                    displayText: unpacked.displayText,

                    page: UrlUtil.PG_CLASSES,
                    source: unpacked.source,
                    hash: classPageHash,
                    hashPreEncoded: true,

                    pageHover: "classfeature",
                    hashHover: UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked),
                    hashPreEncodedHover: true,
                };
            }

        case "@subclassFeature":
            {
                const unpacked = DataUtil.class.unpackUidSubclassFeature(text);

                const classPageHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
                    name: unpacked.className,
                    source: unpacked.classSource
                })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                    feature: {
                        ixLevel: unpacked.level - 1,
                        ixFeature: 0
                    }
                })}`;

                return {
                    name: unpacked.name,
                    displayText: unpacked.displayText,

                    page: UrlUtil.PG_CLASSES,
                    source: unpacked.source,
                    hash: classPageHash,
                    hashPreEncoded: true,

                    pageHover: "subclassfeature",
                    hashHover: UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked),
                    hashPreEncodedHover: true,
                };
            }

        case "@quickref":
            {
                const unpacked = DataUtil.quickreference.unpackUid(text);

                const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_QUICKREF](unpacked);

                return {
                    name: unpacked.name,
                    displayText: unpacked.displayText,

                    page: UrlUtil.PG_QUICKREF,
                    source: unpacked.source,
                    hash,
                    hashPreEncoded: true,
                };
            }

        default:
            return Renderer.utils._getTagMeta_generic(tag, text);
        }
    },

    _getTagMeta_generic(tag, text) {
        const {name, source, displayText, others} = DataUtil.generic.unpackUid(text, tag);
        const hash = UrlUtil.encodeForHash([name, source]);

        const out = {
            name,
            displayText,
            others,

            page: null,
            source,
            hash,

            preloadId: null,
            subhashes: null,
            linkText: null,

            hashPreEncoded: true,
        };

        switch (tag) {
        case "@spell":
            out.page = UrlUtil.PG_SPELLS;
            break;
        case "@item":
            out.page = UrlUtil.PG_ITEMS;
            break;
        case "@condition":
        case "@disease":
        case "@status":
            out.page = UrlUtil.PG_CONDITIONS_DISEASES;
            break;
        case "@background":
            out.page = UrlUtil.PG_BACKGROUNDS;
            break;
        case "@race":
            out.page = UrlUtil.PG_RACES;
            break;
        case "@optfeature":
            out.page = UrlUtil.PG_OPT_FEATURES;
            break;
        case "@reward":
            out.page = UrlUtil.PG_REWARDS;
            break;
        case "@feat":
            out.page = UrlUtil.PG_FEATS;
            break;
        case "@psionic":
            out.page = UrlUtil.PG_PSIONICS;
            break;
        case "@object":
            out.page = UrlUtil.PG_OBJECTS;
            break;
        case "@boon":
        case "@cult":
            out.page = UrlUtil.PG_CULTS_BOONS;
            break;
        case "@trap":
        case "@hazard":
            out.page = UrlUtil.PG_TRAPS_HAZARDS;
            break;
        case "@variantrule":
            out.page = UrlUtil.PG_VARIANTRULES;
            break;
        case "@table":
            out.page = UrlUtil.PG_TABLES;
            break;
        case "@vehicle":
        case "@vehupgrade":
            out.page = UrlUtil.PG_VEHICLES;
            break;
        case "@action":
            out.page = UrlUtil.PG_ACTIONS;
            break;
        case "@language":
            out.page = UrlUtil.PG_LANGUAGES;
            break;
        case "@charoption":
            out.page = UrlUtil.PG_CHAR_CREATION_OPTIONS;
            break;
        case "@recipe":
            out.page = UrlUtil.PG_RECIPES;
            break;
        case "@deck":
            out.page = UrlUtil.PG_DECKS;
            break;

        case "@legroup":
            {
                out.page = "legendaryGroup";
                out.isFauxPage = true;
                break;
            }

        case "@creature":
            {
                out.page = UrlUtil.PG_BESTIARY;

                if (others.length) {
                    const [type,value] = others[0].split("=").map(it=>it.trim().toLowerCase()).filter(Boolean);
                    if (type && value) {
                        switch (type) {
                        case VeCt.HASH_SCALED:
                            {
                                const targetCrNum = Parser.crToNumber(value);
                                out.preloadId = Renderer.monster.getCustomHashId({
                                    name,
                                    source,
                                    _isScaledCr: true,
                                    _scaledCr: targetCrNum
                                });
                                out.subhashes = [{
                                    key: VeCt.HASH_SCALED,
                                    value: targetCrNum
                                }, ];
                                out.linkText = displayText || `${name} (CR ${value})`;
                                break;
                            }

                        case VeCt.HASH_SCALED_SPELL_SUMMON:
                            {
                                const scaledSpellNum = Number(value);
                                out.preloadId = Renderer.monster.getCustomHashId({
                                    name,
                                    source,
                                    _isScaledSpellSummon: true,
                                    _scaledSpellSummonLevel: scaledSpellNum
                                });
                                out.subhashes = [{
                                    key: VeCt.HASH_SCALED_SPELL_SUMMON,
                                    value: scaledSpellNum
                                }, ];
                                out.linkText = displayText || `${name} (Spell Level ${value})`;
                                break;
                            }

                        case VeCt.HASH_SCALED_CLASS_SUMMON:
                            {
                                const scaledClassNum = Number(value);
                                out.preloadId = Renderer.monster.getCustomHashId({
                                    name,
                                    source,
                                    _isScaledClassSummon: true,
                                    _scaledClassSummonLevel: scaledClassNum
                                });
                                out.subhashes = [{
                                    key: VeCt.HASH_SCALED_CLASS_SUMMON,
                                    value: scaledClassNum
                                }, ];
                                out.linkText = displayText || `${name} (Class Level ${value})`;
                                break;
                            }
                        }
                    }
                }

                break;
            }

        case "@class":
            {
                out.page = UrlUtil.PG_CLASSES;

                if (others.length) {
                    const [subclassShortName,subclassSource,featurePart] = others;

                    if (subclassSource)
                        out.source = subclassSource;

                    const classStateOpts = {
                        subclass: {
                            shortName: subclassShortName.trim(),
                            source: subclassSource ? subclassSource.trim() : Parser.SRC_PHB,
                        },
                    };

                    const hoverSubhashObj = UrlUtil.unpackSubHash(UrlUtil.getClassesPageStatePart(classStateOpts));
                    out.subhashesHover = [{
                        key: "state",
                        value: hoverSubhashObj.state,
                        preEncoded: true
                    }];

                    if (featurePart) {
                        const featureParts = featurePart.trim().split("-");
                        classStateOpts.feature = {
                            ixLevel: featureParts[0] || "0",
                            ixFeature: featureParts[1] || "0",
                        };
                    }

                    const subhashObj = UrlUtil.unpackSubHash(UrlUtil.getClassesPageStatePart(classStateOpts));

                    out.subhashes = [{
                        key: "state",
                        value: subhashObj.state.join(HASH_SUB_LIST_SEP),
                        preEncoded: true
                    }, {
                        key: "fltsource",
                        value: "clear"
                    }, {
                        key: "flstmiscellaneous",
                        value: "clear"
                    }, ];
                }

                break;
            }

        case "@skill":
            {
                out.isFauxPage = true;
                out.page = "skill";
                break;
            }
        case "@sense":
            {
                out.isFauxPage = true;
                out.page = "sense";
                break;
            }
        case "@itemMastery":
            {
                out.isFauxPage = true;
                out.page = "itemMastery";
                break;
            }
        case "@cite":
            {
                out.isFauxPage = true;
                out.page = "citation";
                break;
            }

        default:
            throw new Error(`Unhandled tag "${tag}"`);
        }

        return out;
    },

    applyTemplate(ent, templateString, {fnPreApply, mapCustom}={}) {
        return templateString.replace(/{{([^}]+)}}/g, (fullMatch,strArgs)=>{
            if (fnPreApply)
                fnPreApply(fullMatch, strArgs);

            if (strArgs === "item.dmg1") {
                return Renderer.item._getTaggedDamage(ent.dmg1);
            } else if (strArgs === "item.dmg2") {
                return Renderer.item._getTaggedDamage(ent.dmg2);
            }

            if (mapCustom && mapCustom[strArgs])
                return mapCustom[strArgs];

            const args = strArgs.split(" ").map(arg=>arg.trim()).filter(Boolean);

            if (args.length === 1) {
                return Renderer.utils._applyTemplate_getValue(ent, args[0]);
            } else if (args.length === 2) {
                const val = Renderer.utils._applyTemplate_getValue(ent, args[1]);
                switch (args[0]) {
                case "getFullImmRes":
                    return Parser.getFullImmRes(val);
                default:
                    throw new Error(`Unknown template function "${args[0]}"`);
                }
            } else
                throw new Error(`Unhandled number of arguments ${args.length}`);
        }
        );
    },

    _applyTemplate_getValue(ent, prop) {
        const spl = prop.split(".");
        switch (spl[0]) {
        case "item":
            {
                const path = spl.slice(1);
                if (!path.length)
                    return `{@i missing key path}`;
                return MiscUtil.get(ent, ...path);
            }
        default:
            return `{@i unknown template root: "${spl[0]}"}`;
        }
    },

    getFlatEntries(entry) {
        const out = [];
        const depthStack = [];

        const recurse = ({obj})=>{
            let isPopDepth = false;

            Renderer.ENTRIES_WITH_ENUMERATED_TITLES.forEach(meta=>{
                if (obj.type !== meta.type)
                    return;

                const kName = "name";
                if (obj[kName] == null)
                    return;

                isPopDepth = true;

                const curDepth = depthStack.length ? depthStack.last() : 0;
                const nxtDepth = meta.depth ? meta.depth : meta.depthIncrement ? curDepth + meta.depthIncrement : curDepth;

                depthStack.push(Math.min(nxtDepth, 2, ), );

                const cpyObj = MiscUtil.copyFast(obj);

                out.push({
                    depth: curDepth,
                    entry: cpyObj,
                    key: meta.key,
                    ix: out.length,
                    name: cpyObj.name,
                });

                cpyObj[meta.key] = cpyObj[meta.key].map(child=>{
                    if (!child.type)
                        return child;
                    const childMeta = Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[child.type];
                    if (!childMeta)
                        return child;

                    const kNameChild = "name";
                    if (child[kName] == null)
                        return child;

                    const ixNextRef = out.length;

                    recurse({
                        obj: child
                    });

                    return {
                        IX_FLAT_REF: ixNextRef
                    };
                }
                );
            }
            );

            if (isPopDepth)
                depthStack.pop();
        }
        ;

        recurse({
            obj: entry
        });

        return out;
    },

    getLinkSubhashString(subhashes) {
        let out = "";
        const len = subhashes.length;
        for (let i = 0; i < len; ++i) {
            const subHash = subhashes[i];
            if (subHash.preEncoded)
                out += `${HASH_PART_SEP}${subHash.key}${HASH_SUB_KV_SEP}`;
            else
                out += `${HASH_PART_SEP}${UrlUtil.encodeForHash(subHash.key)}${HASH_SUB_KV_SEP}`;
            if (subHash.value != null) {
                if (subHash.preEncoded)
                    out += subHash.value;
                else
                    out += UrlUtil.encodeForHash(subHash.value);
            } else {
                out += subHash.values.map(v=>UrlUtil.encodeForHash(v)).join(HASH_SUB_LIST_SEP);
            }
        }
        return out;
    },

    initFullEntries_(ent, {propEntries="entries", propFullEntries="_fullEntries"}={}) {
        ent[propFullEntries] = ent[propFullEntries] || (ent[propEntries] ? MiscUtil.copyFast(ent[propEntries]) : []);
    },

    lazy: {
        _getIntersectionConfig() {
            return {
                rootMargin: "150px 0px",
                threshold: 0.01,
            };
        },

        _OBSERVERS: {},
        getCreateObserver({observerId, fnOnObserve}) {
            if (!Renderer.utils.lazy._OBSERVERS[observerId]) {
                const observer = Renderer.utils.lazy._OBSERVERS[observerId] = new IntersectionObserver(Renderer.utils.lazy.getFnOnIntersect({
                    observerId,
                    fnOnObserve,
                }),Renderer.utils.lazy._getIntersectionConfig(),);

                observer._TRACKED = new Set();

                observer.track = it=>{
                    observer._TRACKED.add(it);
                    return observer.observe(it);
                }
                ;

                observer.untrack = it=>{
                    observer._TRACKED.delete(it);
                    return observer.unobserve(it);
                }
                ;

                observer._printListener = evt=>{
                    if (!observer._TRACKED.size)
                        return;

                    [...observer._TRACKED].forEach(it=>{
                        observer.untrack(it);
                        fnOnObserve({
                            observer,
                            entry: {
                                target: it,
                            },
                        });
                    }
                    );

                    alert(`All content must be loaded prior to printing. Please cancel the print and wait a few moments for loading to complete!`);
                }
                ;
                window.addEventListener("beforeprint", observer._printListener);
            }
            return Renderer.utils.lazy._OBSERVERS[observerId];
        },

        destroyObserver({observerId}) {
            const observer = Renderer.utils.lazy._OBSERVERS[observerId];
            if (!observer)
                return;

            observer.disconnect();
            window.removeEventListener("beforeprint", observer._printListener);
        },

        getFnOnIntersect({observerId, fnOnObserve}) {
            return obsEntries=>{
                const observer = Renderer.utils.lazy._OBSERVERS[observerId];

                obsEntries.forEach(entry=>{
                    if (entry.intersectionRatio <= 0)
                        return;

                    observer.untrack(entry.target);
                    fnOnObserve({
                        observer,
                        entry,
                    });
                }
                );
            }
            ;
        },
    },
};

Renderer.tag = class {
    static _TagBase = class {
        tagName;
        defaultSource = null;
        page = null;

        get tag() {
            return `@${this.tagName}`;
        }

        getStripped(tag, text) {
            text = text.replace(/<\$([^$]+)\$>/gi, "");
            return this._getStripped(tag, text);
        }

        _getStripped(tag, text) {
            throw new Error("Unimplemented!");
        }

        getMeta(tag, text) {
            return this._getMeta(tag, text);
        }
        _getMeta(tag, text) {
            throw new Error("Unimplemented!");
        }
    }
    ;

    static _TagBaseAt = class extends this._TagBase {
        get tag() {
            return `@${this.tagName}`;
        }
    }
    ;

    static _TagBaseHash = class extends this._TagBase {
        get tag() {
            return `#${this.tagName}`;
        }
    }
    ;

    static _TagTextStyle = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            return text;
        }
    }
    ;

    static TagBoldShort = class extends this._TagTextStyle {
        tagName = "b";
    }
    ;

    static TagBoldLong = class extends this._TagTextStyle {
        tagName = "bold";
    }
    ;

    static TagItalicShort = class extends this._TagTextStyle {
        tagName = "i";
    }
    ;

    static TagItalicLong = class extends this._TagTextStyle {
        tagName = "italic";
    }
    ;

    static TagStrikethroughShort = class extends this._TagTextStyle {
        tagName = "s";
    }
    ;

    static TagStrikethroughLong = class extends this._TagTextStyle {
        tagName = "strike";
    }
    ;

    static TagUnderlineShort = class extends this._TagTextStyle {
        tagName = "u";
    }
    ;

    static TagUnderlineLong = class extends this._TagTextStyle {
        tagName = "underline";
    }
    ;

    static TagSup = class extends this._TagTextStyle {
        tagName = "sup";
    }
    ;

    static TagSub = class extends this._TagTextStyle {
        tagName = "sub";
    }
    ;

    static TagKbd = class extends this._TagTextStyle {
        tagName = "kbd";
    }
    ;

    static TagCode = class extends this._TagTextStyle {
        tagName = "code";
    }
    ;

    static TagStyle = class extends this._TagTextStyle {
        tagName = "style";
    }
    ;

    static TagFont = class extends this._TagTextStyle {
        tagName = "font";
    }
    ;

    static TagComic = class extends this._TagTextStyle {
        tagName = "comic";
    }
    ;

    static TagComicH1 = class extends this._TagTextStyle {
        tagName = "comicH1";
    }
    ;

    static TagComicH2 = class extends this._TagTextStyle {
        tagName = "comicH2";
    }
    ;

    static TagComicH3 = class extends this._TagTextStyle {
        tagName = "comicH3";
    }
    ;

    static TagComicH4 = class extends this._TagTextStyle {
        tagName = "comicH4";
    }
    ;

    static TagComicNote = class extends this._TagTextStyle {
        tagName = "comicNote";
    }
    ;

    static TagNote = class extends this._TagTextStyle {
        tagName = "note";
    }
    ;

    static TagTip = class extends this._TagTextStyle {
        tagName = "tip";
    }
    ;

    static TagUnit = class extends this._TagBaseAt {
        tagName = "unit";

        _getStripped(tag, text) {
            const [amount,unitSingle,unitPlural] = Renderer.splitTagByPipe(text);
            return isNaN(amount) ? unitSingle : Number(amount) > 1 ? (unitPlural || unitSingle.toPlural()) : unitSingle;
        }
    }
    ;

    static TagHit = class extends this._TagBaseAt {
        tagName = "h";

        _getStripped(tag, text) {
            return "Hit: ";
        }
    }
    ;

    static TagMiss = class extends this._TagBaseAt {
        tagName = "m";

        _getStripped(tag, text) {
            return "Miss: ";
        }
    }
    ;

    static TagAtk = class extends this._TagBaseAt {
        tagName = "atk";

        _getStripped(tag, text) {
            return Renderer.attackTagToFull(text);
        }
    }
    ;

    static TagHitYourSpellAttack = class extends this._TagBaseAt {
        tagName = "hitYourSpellAttack";

        _getStripped(tag, text) {
            const [displayText] = Renderer.splitTagByPipe(text);
            return displayText || "your spell attack modifier";
        }
    }
    ;

    static TagDc = class extends this._TagBaseAt {
        tagName = "dc";

        _getStripped(tag, text) {
            const [dcText,displayText] = Renderer.splitTagByPipe(text);
            return `DC ${displayText || dcText}`;
        }
    }
    ;

    static TagDcYourSpellSave = class extends this._TagBaseAt {
        tagName = "dcYourSpellSave";

        _getStripped(tag, text) {
            const [displayText] = Renderer.splitTagByPipe(text);
            return displayText || "your spell save DC";
        }
    }
    ;

    static _TagDiceFlavor = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const [rollText,displayText] = Renderer.splitTagByPipe(text);
            switch (tag) {
            case "@damage":
            case "@dice":
            case "@autodice":
                {
                    return displayText || rollText.replace(/;/g, "/");
                }
            case "@d20":
            case "@hit":
                {
                    return displayText || (()=>{
                        const n = Number(rollText);
                        if (!isNaN(n))
                            return `${n >= 0 ? "+" : ""}${n}`;
                        return rollText;
                    }
                    )();
                }
            case "@recharge":
                {
                    const asNum = Number(rollText || 6);
                    if (isNaN(asNum)) {
                        throw new Error(`Could not parse "${rollText}" as a number!`);
                    }
                    return `(Recharge ${asNum}${asNum < 6 ? `\u20136` : ""})`;
                }
            case "@chance":
                {
                    return displayText || `${rollText} percent`;
                }
            case "@ability":
                {
                    const [,rawScore] = rollText.split(" ").map(it=>it.trim().toLowerCase()).filter(Boolean);
                    const score = Number(rawScore) || 0;
                    return displayText || `${score} (${Parser.getAbilityModifier(score)})`;
                }
            case "@savingThrow":
            case "@skillCheck":
                {
                    return displayText || rollText;
                }
            }
            throw new Error(`Unhandled tag: ${tag}`);
        }
    }
    ;

    static TaChance = class extends this._TagDiceFlavor {
        tagName = "chance";
    }
    ;

    static TaD20 = class extends this._TagDiceFlavor {
        tagName = "d20";
    }
    ;

    static TaDamage = class extends this._TagDiceFlavor {
        tagName = "damage";
    }
    ;

    static TaDice = class extends this._TagDiceFlavor {
        tagName = "dice";
    }
    ;

    static TaAutodice = class extends this._TagDiceFlavor {
        tagName = "autodice";
    }
    ;

    static TaHit = class extends this._TagDiceFlavor {
        tagName = "hit";
    }
    ;

    static TaRecharge = class extends this._TagDiceFlavor {
        tagName = "recharge";
    }
    ;

    static TaAbility = class extends this._TagDiceFlavor {
        tagName = "ability";
    }
    ;

    static TaSavingThrow = class extends this._TagDiceFlavor {
        tagName = "savingThrow";
    }
    ;

    static TaSkillCheck = class extends this._TagDiceFlavor {
        tagName = "skillCheck";
    }
    ;

    static _TagDiceFlavorScaling = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const [,,addPerProgress,,displayText] = Renderer.splitTagByPipe(text);
            return displayText || addPerProgress;
        }
    }
    ;

    static TagScaledice = class extends this._TagDiceFlavorScaling {
        tagName = "scaledice";
    }
    ;

    static TagScaledamage = class extends this._TagDiceFlavorScaling {
        tagName = "scaledamage";
    }
    ;

    static TagCoinflip = class extends this._TagBaseAt {
        tagName = "coinflip";

        _getStripped(tag, text) {
            const [displayText] = Renderer.splitTagByPipe(text);
            return displayText || "flip a coin";
        }
    }
    ;

    static _TagPipedNoDisplayText = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts[0];
        }
    }
    ;

    static Tag5etools = class extends this._TagPipedNoDisplayText {
        tagName = "5etools";
    }
    ;

    static TagAdventure = class extends this._TagPipedNoDisplayText {
        tagName = "adventure";
    }
    ;

    static TagBook = class extends this._TagPipedNoDisplayText {
        tagName = "book";
    }
    ;

    static TagFilter = class extends this._TagPipedNoDisplayText {
        tagName = "filter";
    }
    ;

    static TagFootnote = class extends this._TagPipedNoDisplayText {
        tagName = "footnote";
    }
    ;

    static TagLink = class extends this._TagPipedNoDisplayText {
        tagName = "link";
    }
    ;

    static TagLoader = class extends this._TagPipedNoDisplayText {
        tagName = "loader";
    }
    ;

    static TagColor = class extends this._TagPipedNoDisplayText {
        tagName = "color";
    }
    ;

    static TagHighlight = class extends this._TagPipedNoDisplayText {
        tagName = "highlight";
    }
    ;

    static TagHelp = class extends this._TagPipedNoDisplayText {
        tagName = "help";
    }
    ;

    static _TagPipedDisplayTextThird = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 3 ? parts[2] : parts[0];
        }
    }
    ;

    static TagAction = class extends this._TagPipedDisplayTextThird {
        tagName = "action";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_ACTIONS;
    }
    ;

    static TagBackground = class extends this._TagPipedDisplayTextThird {
        tagName = "background";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_BACKGROUNDS;
    }
    ;

    static TagBoon = class extends this._TagPipedDisplayTextThird {
        tagName = "boon";
        defaultSource = Parser.SRC_MTF;
        page = UrlUtil.PG_CULTS_BOONS;
    }
    ;

    static TagCharoption = class extends this._TagPipedDisplayTextThird {
        tagName = "charoption";
        defaultSource = Parser.SRC_MOT;
        page = UrlUtil.PG_CHAR_CREATION_OPTIONS;
    }
    ;

    static TagClass = class extends this._TagPipedDisplayTextThird {
        tagName = "class";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CLASSES;
    }
    ;

    static TagCondition = class extends this._TagPipedDisplayTextThird {
        tagName = "condition";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CONDITIONS_DISEASES;
    }
    ;

    static TagCreature = class extends this._TagPipedDisplayTextThird {
        tagName = "creature";
        defaultSource = Parser.SRC_MM;
        page = UrlUtil.PG_BESTIARY;
    }
    ;

    static TagCult = class extends this._TagPipedDisplayTextThird {
        tagName = "cult";
        defaultSource = Parser.SRC_MTF;
        page = UrlUtil.PG_CULTS_BOONS;
    }
    ;

    static TagDeck = class extends this._TagPipedDisplayTextThird {
        tagName = "deck";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_DECKS;
    }
    ;

    static TagDisease = class extends this._TagPipedDisplayTextThird {
        tagName = "disease";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_CONDITIONS_DISEASES;
    }
    ;

    static TagFeat = class extends this._TagPipedDisplayTextThird {
        tagName = "feat";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_FEATS;
    }
    ;

    static TagHazard = class extends this._TagPipedDisplayTextThird {
        tagName = "hazard";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_TRAPS_HAZARDS;
    }
    ;

    static TagItem = class extends this._TagPipedDisplayTextThird {
        tagName = "item";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_ITEMS;
    }
    ;

    static TagItemMastery = class extends this._TagPipedDisplayTextThird {
        tagName = "itemMastery";
        defaultSource = VeCt.STR_GENERIC;
        page = "itemMastery";
    }
    ;

    static TagLanguage = class extends this._TagPipedDisplayTextThird {
        tagName = "language";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_LANGUAGES;
    }
    ;

    static TagLegroup = class extends this._TagPipedDisplayTextThird {
        tagName = "legroup";
        defaultSource = Parser.SRC_MM;
        page = "legendaryGroup";
    }
    ;

    static TagObject = class extends this._TagPipedDisplayTextThird {
        tagName = "object";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_OBJECTS;
    }
    ;

    static TagOptfeature = class extends this._TagPipedDisplayTextThird {
        tagName = "optfeature";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_OPT_FEATURES;
    }
    ;

    static TagPsionic = class extends this._TagPipedDisplayTextThird {
        tagName = "psionic";
        defaultSource = Parser.SRC_UATMC;
        page = UrlUtil.PG_PSIONICS;
    }
    ;

    static TagRace = class extends this._TagPipedDisplayTextThird {
        tagName = "race";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_RACES;
    }
    ;

    static TagRecipe = class extends this._TagPipedDisplayTextThird {
        tagName = "recipe";
        defaultSource = Parser.SRC_HF;
        page = UrlUtil.PG_RECIPES;
    }
    ;

    static TagReward = class extends this._TagPipedDisplayTextThird {
        tagName = "reward";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_REWARDS;
    }
    ;

    static TagVehicle = class extends this._TagPipedDisplayTextThird {
        tagName = "vehicle";
        defaultSource = Parser.SRC_GoS;
        page = UrlUtil.PG_VEHICLES;
    }
    ;

    static TagVehupgrade = class extends this._TagPipedDisplayTextThird {
        tagName = "vehupgrade";
        defaultSource = Parser.SRC_GoS;
        page = UrlUtil.PG_VEHICLES;
    }
    ;

    static TagSense = class extends this._TagPipedDisplayTextThird {
        tagName = "sense";
        defaultSource = Parser.SRC_PHB;
        page = "sense";
    }
    ;

    static TagSkill = class extends this._TagPipedDisplayTextThird {
        tagName = "skill";
        defaultSource = Parser.SRC_PHB;
        page = "skill";
    }
    ;

    static TagSpell = class extends this._TagPipedDisplayTextThird {
        tagName = "spell";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_SPELLS;
    }
    ;

    static TagStatus = class extends this._TagPipedDisplayTextThird {
        tagName = "status";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CONDITIONS_DISEASES;
    }
    ;

    static TagTable = class extends this._TagPipedDisplayTextThird {
        tagName = "table";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_TABLES;
    }
    ;

    static TagTrap = class extends this._TagPipedDisplayTextThird {
        tagName = "trap";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_TRAPS_HAZARDS;
    }
    ;

    static TagVariantrule = class extends this._TagPipedDisplayTextThird {
        tagName = "variantrule";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_VARIANTRULES;
    }
    ;

    static TagCite = class extends this._TagPipedDisplayTextThird {
        tagName = "cite";
        defaultSource = Parser.SRC_PHB;
        page = "citation";
    }
    ;

    static _TagPipedDisplayTextFourth = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 4 ? parts[3] : parts[0];
        }
    }
    ;

    static TagCard = class extends this._TagPipedDisplayTextFourth {
        tagName = "card";
        defaultSource = Parser.SRC_DMG;
        page = "card";
    }
    ;

    static TagDeity = class extends this._TagPipedDisplayTextFourth {
        tagName = "deity";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_DEITIES;
    }
    ;

    static _TagPipedDisplayTextSixth = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 6 ? parts[5] : parts[0];
        }
    }
    ;

    static TagClassFeature = class extends this._TagPipedDisplayTextSixth {
        tagName = "classFeature";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CLASSES;
    }
    ;

    static _TagPipedDisplayTextEight = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 8 ? parts[7] : parts[0];
        }
    }
    ;

    static TagSubclassFeature = class extends this._TagPipedDisplayTextEight {
        tagName = "subclassFeature";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CLASSES;
    }
    ;

    static TagQuickref = class extends this._TagBaseAt {
        tagName = "quickref";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_QUICKREF;

        _getStripped(tag, text) {
            const {name, displayText} = DataUtil.quickreference.unpackUid(text);
            return displayText || name;
        }
    }
    ;

    static TagArea = class extends this._TagBaseAt {
        tagName = "area";

        _getStripped(tag, text) {
            const [compactText,,flags] = Renderer.splitTagByPipe(text);

            return flags && flags.includes("x") ? compactText : `${flags && flags.includes("u") ? "A" : "a"}rea ${compactText}`;
        }

        _getMeta(tag, text) {
            const [compactText,areaId,flags] = Renderer.splitTagByPipe(text);

            const displayText = flags && flags.includes("x") ? compactText : `${flags && flags.includes("u") ? "A" : "a"}rea ${compactText}`;

            return {
                areaId,
                displayText,
            };
        }
    }
    ;

    static TagHomebrew = class extends this._TagBaseAt {
        tagName = "homebrew";

        _getStripped(tag, text) {
            const [newText,oldText] = Renderer.splitTagByPipe(text);
            if (newText && oldText) {
                return `${newText} [this is a homebrew addition, replacing the following: "${oldText}"]`;
            } else if (newText) {
                return `${newText} [this is a homebrew addition]`;
            } else if (oldText) {
                return `[the following text has been removed due to homebrew: ${oldText}]`;
            } else
                throw new Error(`Homebrew tag had neither old nor new text!`);
        }
    }
    ;

    static TagItemEntry = class extends this._TagBaseHash {
        tagName = "itemEntry";
        defaultSource = Parser.SRC_DMG;
    }
    ;

    static TAGS = [new this.TagBoldShort(), new this.TagBoldLong(), new this.TagItalicShort(), new this.TagItalicLong(), new this.TagStrikethroughShort(), new this.TagStrikethroughLong(), new this.TagUnderlineShort(), new this.TagUnderlineLong(), new this.TagSup(), new this.TagSub(), new this.TagKbd(), new this.TagCode(), new this.TagStyle(), new this.TagFont(),
    new this.TagComic(), new this.TagComicH1(), new this.TagComicH2(), new this.TagComicH3(), new this.TagComicH4(), new this.TagComicNote(),
    new this.TagNote(), new this.TagTip(),
    new this.TagUnit(),
    new this.TagHit(), new this.TagMiss(),
    new this.TagAtk(),
    new this.TagHitYourSpellAttack(),
    new this.TagDc(),
    new this.TagDcYourSpellSave(),
    new this.TaChance(), new this.TaD20(), new this.TaDamage(), new this.TaDice(), new this.TaAutodice(), new this.TaHit(), new this.TaRecharge(), new this.TaAbility(), new this.TaSavingThrow(), new this.TaSkillCheck(),
    new this.TagScaledice(), new this.TagScaledamage(),
    new this.TagCoinflip(),
    new this.Tag5etools(), new this.TagAdventure(), new this.TagBook(), new this.TagFilter(), new this.TagFootnote(), new this.TagLink(), new this.TagLoader(), new this.TagColor(), new this.TagHighlight(), new this.TagHelp(),
    new this.TagQuickref(),
    new this.TagArea(),
    new this.TagAction(), new this.TagBackground(), new this.TagBoon(), new this.TagCharoption(), new this.TagClass(), new this.TagCondition(), new this.TagCreature(), new this.TagCult(), new this.TagDeck(), new this.TagDisease(), new this.TagFeat(), new this.TagHazard(), new this.TagItem(), new this.TagItemMastery(), new this.TagLanguage(), new this.TagLegroup(), new this.TagObject(), new this.TagOptfeature(), new this.TagPsionic(), new this.TagRace(), new this.TagRecipe(), new this.TagReward(), new this.TagVehicle(), new this.TagVehupgrade(), new this.TagSense(), new this.TagSkill(), new this.TagSpell(), new this.TagStatus(), new this.TagTable(), new this.TagTrap(), new this.TagVariantrule(), new this.TagCite(),
    new this.TagCard(), new this.TagDeity(),
    new this.TagClassFeature({
        tagName: "classFeature"
    }),
    new this.TagSubclassFeature({
        tagName: "subclassFeature"
    }),
    new this.TagHomebrew(),
    new this.TagItemEntry(), ];

    static TAG_LOOKUP = {};

    static _init() {
        this.TAGS.forEach(tag=>{
            this.TAG_LOOKUP[tag.tag] = tag;
            this.TAG_LOOKUP[tag.tagName] = tag;
        }
        );

        return null;
    }

    static _ = this._init();

    static getPage(tag) {
        const tagInfo = this.TAG_LOOKUP[tag];
        return tagInfo?.page;
    }
};
Renderer.race = class {
    static getRaceRenderableEntriesMeta(race) {
        return {
            entryMain: race._isBaseRace ? {
                type: "entries",
                entries: race._baseRaceEntries
            } : {
                type: "entries",
                entries: race.entries
            },
        };
    }

    static getCompactRenderedString(race, {isStatic=false}={}) {
        const renderer = Renderer.get();
        const renderStack = [];

        renderStack.push(`
			${Renderer.utils.getExcludedTr({
            entity: race,
            dataProp: "race",
            page: UrlUtil.PG_RACES
        })}
			${Renderer.utils.getNameTr(race, {
            page: UrlUtil.PG_RACES
        })}
			<tr><td colspan="6">
				<table class="w-100 summary stripe-even-table">
					<tr>
						<th class="col-4 ve-text-center">Ability Scores</th>
						<th class="col-4 ve-text-center">Size</th>
						<th class="col-4 ve-text-center">Speed</th>
					</tr>
					<tr>
						<td class="ve-text-center">${Renderer.getAbilityData(race.ability).asText}</td>
						<td class="ve-text-center">${(race.size || [Parser.SZ_VARIES]).map(sz=>Parser.sizeAbvToFull(sz)).join("/")}</td>
						<td class="ve-text-center">${Parser.getSpeedString(race)}</td>
					</tr>
				</table>
			</td></tr>
			<tr class="text"><td colspan="6">
		`);

        renderer.recursiveRender(Renderer.race.getRaceRenderableEntriesMeta(race).entryMain, renderStack, {depth: 1});

        renderStack.push("</td></tr>");

        const ptHeightWeight = Renderer.race.getHeightAndWeightPart(race, {isStatic});

        if (ptHeightWeight)
            renderStack.push(`<tr class="text"><td colspan="6"><hr class="rd__hr">${ptHeightWeight}</td></tr>`);

        return renderStack.join("");
    }

    static getRenderedSize(race) {
        return (race.size || [Parser.SZ_VARIES]).map(sz=>Parser.sizeAbvToFull(sz)).join("/");
    }

    static getHeightAndWeightPart(race, {isStatic=false}={}) {
        if (!race.heightAndWeight)
            return null;
        if (race._isBaseRace)
            return null;
        return Renderer.get().render({
            entries: Renderer.race.getHeightAndWeightEntries(race, {
                isStatic
            })
        });
    }

    static getHeightAndWeightEntries(race, {isStatic=false}={}) {
        const colLabels = ["Base Height", "Base Weight", "Height Modifier", "Weight Modifier"];
        const colStyles = ["col-2-3 ve-text-center", "col-2-3 ve-text-center", "col-2-3 ve-text-center", "col-2 ve-text-center"];

        const cellHeightMod = !isStatic ? `+<span data-race-heightmod="true">${race.heightAndWeight.heightMod}</span>` : `+${race.heightAndWeight.heightMod}`;
        const cellWeightMod = !isStatic ? `× <span data-race-weightmod="true">${race.heightAndWeight.weightMod || "1"}</span> lb.` : `× ${race.heightAndWeight.weightMod || "1"} lb.`;

        const row = [Renderer.race.getRenderedHeight(race.heightAndWeight.baseHeight), `${race.heightAndWeight.baseWeight} lb.`, cellHeightMod, cellWeightMod, ];

        if (!isStatic) {
            colLabels.push("");
            colStyles.push("col-3-1 ve-text-center");
            row.push(`<div class="ve-flex-vh-center">
				<div class="ve-hidden race__disp-result-height-weight ve-flex-v-baseline">
					<div class="mr-1">=</div>
					<div class="race__disp-result-height"></div>
					<div class="mr-2">; </div>
					<div class="race__disp-result-weight mr-1"></div>
					<div class="small">lb.</div>
				</div>
				<button class="btn btn-default btn-xs my-1 race__btn-roll-height-weight">Roll</button>
			</div>`);
        }

        return ["You may roll for your character's height and weight on the Random Height and Weight table. The roll in the Height Modifier column adds a number (in inches) to the character's base height. To get a weight, multiply the number you rolled for height by the roll in the Weight Modifier column and add the result (in pounds) to the base weight.", {
            type: "table",
            caption: "Random Height and Weight",
            colLabels,
            colStyles,
            rows: [row],
        }, ];
    }

    static getRenderedHeight(height) {
        const heightFeet = Number(Math.floor(height / 12).toFixed(3));
        const heightInches = Number((height % 12).toFixed(3));
        return `${heightFeet ? `${heightFeet}'` : ""}${heightInches ? `${heightInches}"` : ""}`;
    }

    static mergeSubraces(races, opts) {
        opts = opts || {};

        const out = [];
        races.forEach(r=>{
            if (r.size && typeof r.size === "string")
                r.size = [r.size];

            if (r.lineage && r.lineage !== true) {
                r = MiscUtil.copyFast(r);

                if (r.lineage === "VRGR") {
                    r.ability = r.ability || [{
                        choose: {
                            weighted: {
                                from: [...Parser.ABIL_ABVS],
                                weights: [2, 1],
                            },
                        },
                    }, {
                        choose: {
                            weighted: {
                                from: [...Parser.ABIL_ABVS],
                                weights: [1, 1, 1],
                            },
                        },
                    }, ];
                } else if (r.lineage === "UA1") {
                    r.ability = r.ability || [{
                        choose: {
                            weighted: {
                                from: [...Parser.ABIL_ABVS],
                                weights: [2, 1],
                            },
                        },
                    }, ];
                }

                r.entries = r.entries || [];
                r.entries.push({
                    type: "entries",
                    name: "Languages",
                    entries: ["You can speak, read, and write Common and one other language that you and your DM agree is appropriate for your character."],
                });

                r.languageProficiencies = r.languageProficiencies || [{
                    "common": true,
                    "anyStandard": 1
                }];
            }

            if (r.subraces && !r.subraces.length)
                delete r.subraces;

            if (r.subraces) {
                r.subraces.forEach(sr=>{
                    sr.source = sr.source || r.source;
                    sr._isSubRace = true;
                }
                );

                r.subraces.sort((a,b)=>SortUtil.ascSortLower(a.name || "_", b.name || "_") || SortUtil.ascSortLower(Parser.sourceJsonToAbv(a.source), Parser.sourceJsonToAbv(b.source)));
            }

            if (opts.isAddBaseRaces && r.subraces) {
                const baseRace = MiscUtil.copyFast(r);

                baseRace._isBaseRace = true;

                const isAnyNoName = r.subraces.some(it=>!it.name);
                if (isAnyNoName) {
                    baseRace._rawName = baseRace.name;
                    baseRace.name = `${baseRace.name} (Base)`;
                }

                const nameCounts = {};
                r.subraces.filter(sr=>sr.name).forEach(sr=>nameCounts[sr.name.toLowerCase()] = (nameCounts[sr.name.toLowerCase()] || 0) + 1);
                nameCounts._ = r.subraces.filter(sr=>!sr.name).length;

                const lst = {
                    type: "list",
                    items: r.subraces.map(sr=>{
                        const count = nameCounts[(sr.name || "_").toLowerCase()];
                        const idName = Renderer.race.getSubraceName(r.name, sr.name);
                        return `{@race ${idName}|${sr.source}${count > 1 ? `|${idName} (<span title="${Parser.sourceJsonToFull(sr.source).escapeQuotes()}">${Parser.sourceJsonToAbv(sr.source)}</span>)` : ""}}`;
                    }
                    ),
                };

                Renderer.race._mutBaseRaceEntries(baseRace, lst);
                baseRace._subraces = r.subraces.map(sr=>({
                    name: Renderer.race.getSubraceName(r.name, sr.name),
                    source: sr.source
                }));

                delete baseRace.subraces;

                out.push(baseRace);
            }

            out.push(...Renderer.race._mergeSubraces(r));
        }
        );

        return out;
    }

    static _mutMakeBaseRace(baseRace) {
        if (baseRace._isBaseRace)
            return;

        baseRace._isBaseRace = true;

        Renderer.race._mutBaseRaceEntries(baseRace, {
            type: "list",
            items: []
        });
    }

    static _mutBaseRaceEntries(baseRace, lst) {
        baseRace._baseRaceEntries = [{
            type: "section",
            entries: ["This race has multiple subraces, as listed below:", lst, ],
        }, {
            type: "section",
            entries: [{
                type: "entries",
                entries: [{
                    type: "entries",
                    name: "Traits",
                    entries: [...MiscUtil.copyFast(baseRace.entries), ],
                }, ],
            }, ],
        }, ];
    }

    static getSubraceName(raceName, subraceName) {
        if (!subraceName)
            return raceName;

        const mBrackets = /^(.*?)(\(.*?\))$/i.exec(raceName || "");
        if (!mBrackets)
            return `${raceName} (${subraceName})`;

        const bracketPart = mBrackets[2].substring(1, mBrackets[2].length - 1);
        return `${mBrackets[1]}(${[bracketPart, subraceName].join("; ")})`;
    }

    static _mergeSubraces(race) {
        if (!race.subraces)
            return [race];
        return MiscUtil.copyFast(race.subraces).map(s=>Renderer.race._getMergedSubrace(race, s));
    }

    static _getMergedSubrace(race, cpySr) {
        const cpy = MiscUtil.copyFast(race);
        cpy._baseName = cpy.name;
        cpy._baseSource = cpy.source;
        cpy._baseSrd = cpy.srd;
        cpy._baseBasicRules = cpy.basicRules;
        delete cpy.subraces;
        delete cpy.srd;
        delete cpy.basicRules;
        delete cpy._versions;
        delete cpy.hasFluff;
        delete cpy.hasFluffImages;
        delete cpySr.__prop;

        if (cpySr.name) {
            cpy._subraceName = cpySr.name;

            if (cpySr.alias) {
                cpy.alias = cpySr.alias.map(it=>Renderer.race.getSubraceName(cpy.name, it));
                delete cpySr.alias;
            }

            cpy.name = Renderer.race.getSubraceName(cpy.name, cpySr.name);
            delete cpySr.name;
        }
        if (cpySr.ability) {
            if ((cpySr.overwrite && cpySr.overwrite.ability) || !cpy.ability)
                cpy.ability = cpySr.ability.map(()=>({}));

            if (cpy.ability.length !== cpySr.ability.length)
                throw new Error(`Race and subrace ability array lengths did not match!`);
            cpySr.ability.forEach((obj,i)=>Object.assign(cpy.ability[i], obj));
            delete cpySr.ability;
        }
        if (cpySr.entries) {
            cpySr.entries.forEach(ent=>{
                if (!ent.data?.overwrite)
                    return cpy.entries.push(ent);

                const toOverwrite = cpy.entries.findIndex(it=>it.name?.toLowerCase()?.trim() === ent.data.overwrite.toLowerCase().trim());
                if (~toOverwrite)
                    cpy.entries[toOverwrite] = ent;
                else
                    cpy.entries.push(ent);
            }
            );
            delete cpySr.entries;
        }

        if (cpySr.traitTags) {
            if (cpySr.overwrite && cpySr.overwrite.traitTags)
                cpy.traitTags = cpySr.traitTags;
            else
                cpy.traitTags = (cpy.traitTags || []).concat(cpySr.traitTags);
            delete cpySr.traitTags;
        }

        if (cpySr.languageProficiencies) {
            if (cpySr.overwrite && cpySr.overwrite.languageProficiencies)
                cpy.languageProficiencies = cpySr.languageProficiencies;
            else
                cpy.languageProficiencies = cpy.languageProficiencies = (cpy.languageProficiencies || []).concat(cpySr.languageProficiencies);
            delete cpySr.languageProficiencies;
        }

        if (cpySr.skillProficiencies) {
            if (!cpy.skillProficiencies || (cpySr.overwrite && cpySr.overwrite["skillProficiencies"]))
                cpy.skillProficiencies = cpySr.skillProficiencies;
            else {
                if (!cpySr.skillProficiencies.length || !cpy.skillProficiencies.length)
                    throw new Error(`No items!`);
                if (cpySr.skillProficiencies.length > 1 || cpy.skillProficiencies.length > 1)
                    throw new Error(`Subrace merging does not handle choices!`);
                if (cpySr.skillProficiencies.choose) {
                    if (cpy.skillProficiencies.choose)
                        throw new Error(`Subrace choose merging is not supported!!`);
                    cpy.skillProficiencies.choose = cpySr.skillProficiencies.choose;
                    delete cpySr.skillProficiencies.choose;
                }
                Object.assign(cpy.skillProficiencies[0], cpySr.skillProficiencies[0]);
            }

            delete cpySr.skillProficiencies;
        }

        Object.assign(cpy, cpySr);

        Object.entries(cpy).forEach(([k,v])=>{
            if (v != null)
                return;
            delete cpy[k];
        }
        );

        return cpy;
    }

    static adoptSubraces(allRaces, subraces) {
        const nxtData = [];

        subraces.forEach(sr=>{
            if (!sr.raceName || !sr.raceSource)
                throw new Error(`Subrace was missing parent "raceName" and/or "raceSource"!`);

            const _baseRace = allRaces.find(r=>r.name === sr.raceName && r.source === sr.raceSource);
            if (!_baseRace)
                throw new Error(`Could not find parent race for subrace "${sr.name}" (${sr.source})!`);

            if ((_baseRace._seenSubraces || []).some(it=>it.name === sr.name && it.source === sr.source))
                return;
            (_baseRace._seenSubraces = _baseRace._seenSubraces || []).push({
                name: sr.name,
                source: sr.source
            });

            if (!_baseRace._isBaseRace && (PrereleaseUtil.hasSourceJson(_baseRace.source) || BrewUtil2.hasSourceJson(_baseRace.source))) {
                Renderer.race._mutMakeBaseRace(_baseRace);
            }

            if (_baseRace._isBaseRace) {
                const subraceListEntry = ((_baseRace._baseRaceEntries[0] || {}).entries || []).find(it=>it.type === "list");
                subraceListEntry.items.push(`{@race ${_baseRace._rawName || _baseRace.name} (${sr.name})|${sr.source || _baseRace.source}}`);
            }

            let baseRace = nxtData.find(r=>r.name === sr.raceName && r.source === sr.raceSource);
            if (!baseRace) {
                baseRace = MiscUtil.copyFast(_baseRace);
                if (baseRace._rawName) {
                    baseRace.name = baseRace._rawName;
                    delete baseRace._rawName;
                }
                delete baseRace._isBaseRace;
                delete baseRace._baseRaceEntries;

                nxtData.push(baseRace);
            }

            baseRace.subraces = baseRace.subraces || [];
            baseRace.subraces.push(sr);
        }
        );

        return nxtData;
    }

    static bindListenersHeightAndWeight(race, ele) {
        if (!race.heightAndWeight)
            return;
        if (race._isBaseRace)
            return;

        const $render = $(ele);

        const $dispResult = $render.find(`.race__disp-result-height-weight`);
        const $dispHeight = $render.find(`.race__disp-result-height`);
        const $dispWeight = $render.find(`.race__disp-result-weight`);

        const lock = new VeLock();
        let hasRolled = false;
        let resultHeight;
        let resultWeightMod;

        const $btnRollHeight = $render.find(`[data-race-heightmod="true"]`).html(race.heightAndWeight.heightMod).addClass("roller").mousedown(evt=>evt.preventDefault()).click(async()=>{
            try {
                await lock.pLock();

                if (!hasRolled)
                    return pDoFullRoll(true);
                await pRollHeight();
                updateDisplay();
            } finally {
                lock.unlock();
            }
        }
        );

        const isWeightRoller = race.heightAndWeight.weightMod && isNaN(race.heightAndWeight.weightMod);
        const $btnRollWeight = $render.find(`[data-race-weightmod="true"]`).html(isWeightRoller ? `(<span class="roller">${race.heightAndWeight.weightMod}</span>)` : race.heightAndWeight.weightMod || "1").click(async()=>{
            try {
                await lock.pLock();

                if (!hasRolled)
                    return pDoFullRoll(true);
                await pRollWeight();
                updateDisplay();
            } finally {
                lock.unlock();
            }
        }
        );
        if (isWeightRoller)
            $btnRollWeight.mousedown(evt=>evt.preventDefault());

        const $btnRoll = $render.find(`button.race__btn-roll-height-weight`).click(async()=>pDoFullRoll());

        const pRollHeight = async()=>{
            const mResultHeight = await Renderer.dice.pRoll2(race.heightAndWeight.heightMod, {
                isUser: false,
                label: "Height Modifier",
                name: race.name,
            });
            if (mResultHeight == null)
                return;
            resultHeight = mResultHeight;
        }
        ;

        const pRollWeight = async()=>{
            const weightModRaw = race.heightAndWeight.weightMod || "1";
            const mResultWeightMod = isNaN(weightModRaw) ? await Renderer.dice.pRoll2(weightModRaw, {
                isUser: false,
                label: "Weight Modifier",
                name: race.name,
            }) : Number(weightModRaw);
            if (mResultWeightMod == null)
                return;
            resultWeightMod = mResultWeightMod;
        }
        ;

        const updateDisplay = ()=>{
            const renderedHeight = Renderer.race.getRenderedHeight(race.heightAndWeight.baseHeight + resultHeight);
            const totalWeight = race.heightAndWeight.baseWeight + (resultWeightMod * resultHeight);
            $dispHeight.text(renderedHeight);
            $dispWeight.text(Number(totalWeight.toFixed(3)));
        }
        ;

        const pDoFullRoll = async isPreLocked=>{
            try {
                if (!isPreLocked)
                    await lock.pLock();

                $btnRoll.parent().removeClass(`ve-flex-vh-center`).addClass(`split-v-center`);
                await pRollHeight();
                await pRollWeight();
                $dispResult.removeClass(`ve-hidden`);
                updateDisplay();

                hasRolled = true;
            } finally {
                if (!isPreLocked)
                    lock.unlock();
            }
        }
        ;
    }

    static bindListenersCompact(race, ele) {
        Renderer.race.bindListenersHeightAndWeight(race, ele);
    }

    static pGetFluff(race) {
        return Renderer.utils.pGetFluff({
            entity: race,
            fnGetFluffData: DataUtil.raceFluff.loadJSON.bind(DataUtil.raceFluff),
            fluffProp: "raceFluff",
        });
    }
};

Renderer.getAbilityData = function(abArr, {isOnlyShort, isCurrentLineage}={}) {
    if (isOnlyShort && isCurrentLineage)
        return new Renderer._AbilityData({
            asTextShort: "Lineage (choose)"
        });

    const outerStack = (abArr || [null]).map(it=>Renderer.getAbilityData._doRenderOuter(it));
    if (outerStack.length <= 1)
        return outerStack[0];
    return new Renderer._AbilityData({
        asText: `Choose one of: ${outerStack.map((it,i)=>`(${Parser.ALPHABET[i].toLowerCase()}) ${it.asText}`).join(" ")}`,
        asTextShort: `${outerStack.map((it,i)=>`(${Parser.ALPHABET[i].toLowerCase()}) ${it.asTextShort}`).join(" ")}`,
        asCollection: [...new Set(outerStack.map(it=>it.asCollection).flat())],
        areNegative: [...new Set(outerStack.map(it=>it.areNegative).flat())],
    });
};

Renderer.getAbilityData._doRenderOuter = function(abObj) {
    const mainAbs = [];
    const asCollection = [];
    const areNegative = [];
    const toConvertToText = [];
    const toConvertToShortText = [];

    if (abObj != null) {
        handleAllAbilities(abObj);
        handleAbilitiesChoose();
        return new Renderer._AbilityData({
            asText: toConvertToText.join("; "),
            asTextShort: toConvertToShortText.join("; "),
            asCollection: asCollection,
            areNegative: areNegative,
        });
    }

    return new Renderer._AbilityData();

    function handleAllAbilities(abObj, targetList) {
        MiscUtil.copyFast(Parser.ABIL_ABVS).sort((a,b)=>SortUtil.ascSort(abObj[b] || 0, abObj[a] || 0)).forEach(shortLabel=>handleAbility(abObj, shortLabel, targetList));
    }

    function handleAbility(abObj, shortLabel, optToConvertToTextStorage) {
        if (abObj[shortLabel] != null) {
            const isNegMod = abObj[shortLabel] < 0;
            const toAdd = `${shortLabel.uppercaseFirst()} ${(isNegMod ? "" : "+")}${abObj[shortLabel]}`;

            if (optToConvertToTextStorage) {
                optToConvertToTextStorage.push(toAdd);
            } else {
                toConvertToText.push(toAdd);
                toConvertToShortText.push(toAdd);
            }

            mainAbs.push(shortLabel.uppercaseFirst());
            asCollection.push(shortLabel);
            if (isNegMod)
                areNegative.push(shortLabel);
        }
    }

    function handleAbilitiesChoose() {
        if (abObj.choose != null) {
            const ch = abObj.choose;
            let outStack = "";
            if (ch.weighted) {
                const w = ch.weighted;
                const froms = w.from.map(it=>it.uppercaseFirst());
                const isAny = froms.length === 6;
                const isAllEqual = w.weights.unique().length === 1;
                let cntProcessed = 0;

                const weightsIncrease = w.weights.filter(it=>it >= 0).sort(SortUtil.ascSort).reverse();
                const weightsReduce = w.weights.filter(it=>it < 0).map(it=>-it).sort(SortUtil.ascSort);

                const areIncreaseShort = [];
                const areIncrease = isAny && isAllEqual && w.weights.length > 1 && w.weights[0] >= 0 ? (()=>{
                    weightsIncrease.forEach(it=>areIncreaseShort.push(`+${it}`));
                    return [`${cntProcessed ? "choose " : ""}${Parser.numberToText(w.weights.length)} different +${weightsIncrease[0]}`];
                }
                )() : weightsIncrease.map(it=>{
                    areIncreaseShort.push(`+${it}`);
                    if (isAny)
                        return `${cntProcessed ? "choose " : ""}any ${cntProcessed++ ? `other ` : ""}+${it}`;
                    return `one ${cntProcessed++ ? `other ` : ""}ability to increase by ${it}`;
                }
                );

                const areReduceShort = [];
                const areReduce = isAny && isAllEqual && w.weights.length > 1 && w.weights[0] < 0 ? (()=>{
                    weightsReduce.forEach(it=>areReduceShort.push(`-${it}`));
                    return [`${cntProcessed ? "choose " : ""}${Parser.numberToText(w.weights.length)} different -${weightsReduce[0]}`];
                }
                )() : weightsReduce.map(it=>{
                    areReduceShort.push(`-${it}`);
                    if (isAny)
                        return `${cntProcessed ? "choose " : ""}any ${cntProcessed++ ? `other ` : ""}-${it}`;
                    return `one ${cntProcessed++ ? `other ` : ""}ability to decrease by ${it}`;
                }
                );

                const startText = isAny ? `Choose ` : `From ${froms.joinConjunct(", ", " and ")} choose `;

                const ptAreaIncrease = isAny ? areIncrease.concat(areReduce).join("; ") : areIncrease.concat(areReduce).joinConjunct(", ", isAny ? "; " : " and ");
                toConvertToText.push(`${startText}${ptAreaIncrease}`);
                toConvertToShortText.push(`${isAny ? "Any combination " : ""}${areIncreaseShort.concat(areReduceShort).join("/")}${isAny ? "" : ` from ${froms.join("/")}`}`);
            } else {
                const allAbilities = ch.from.length === 6;
                const allAbilitiesWithParent = isAllAbilitiesWithParent(ch);
                let amount = ch.amount === undefined ? 1 : ch.amount;
                amount = (amount < 0 ? "" : "+") + amount;
                if (allAbilities) {
                    outStack += "any ";
                } else if (allAbilitiesWithParent) {
                    outStack += "any other ";
                }
                if (ch.count != null && ch.count > 1) {
                    outStack += `${Parser.numberToText(ch.count)} `;
                }
                if (allAbilities || allAbilitiesWithParent) {
                    outStack += `${ch.count > 1 ? "unique " : ""}${amount}`;
                } else {
                    for (let j = 0; j < ch.from.length; ++j) {
                        let suffix = "";
                        if (ch.from.length > 1) {
                            if (j === ch.from.length - 2) {
                                suffix = " or ";
                            } else if (j < ch.from.length - 2) {
                                suffix = ", ";
                            }
                        }
                        let thsAmount = ` ${amount}`;
                        if (ch.from.length > 1) {
                            if (j !== ch.from.length - 1) {
                                thsAmount = "";
                            }
                        }
                        outStack += ch.from[j].uppercaseFirst() + thsAmount + suffix;
                    }
                }
            }

            if (outStack.trim()) {
                toConvertToText.push(`Choose ${outStack}`);
                toConvertToShortText.push(outStack.uppercaseFirst());
            }
        }
    }

    function isAllAbilitiesWithParent(chooseAbs) {
        const tempAbilities = [];
        for (let i = 0; i < mainAbs.length; ++i) {
            tempAbilities.push(mainAbs[i].toLowerCase());
        }
        for (let i = 0; i < chooseAbs.from.length; ++i) {
            const ab = chooseAbs.from[i].toLowerCase();
            if (!tempAbilities.includes(ab))
                tempAbilities.push(ab);
            if (!asCollection.includes(ab.toLowerCase))
                asCollection.push(ab.toLowerCase());
        }
        return tempAbilities.length === 6;
    }
};

Renderer._AbilityData = function({asText, asTextShort, asCollection, areNegative}={}) {
    this.asText = asText || "";
    this.asTextShort = asTextShort || "";
    this.asCollection = asCollection || [];
    this.areNegative = areNegative || [];
};

Renderer.ENTRIES_WITH_ENUMERATED_TITLES = [{
    type: "section",
    key: "entries",
    depth: -1
}, {
    type: "entries",
    key: "entries",
    depthIncrement: 1
}, {
    type: "options",
    key: "entries"
}, {
    type: "inset",
    key: "entries",
    depth: 2
}, {
    type: "insetReadaloud",
    key: "entries",
    depth: 2
}, {
    type: "variant",
    key: "entries",
    depth: 2
}, {
    type: "variantInner",
    key: "entries",
    depth: 2
}, {
    type: "actions",
    key: "entries",
    depth: 2
}, {
    type: "flowBlock",
    key: "entries",
    depth: 2
}, {
    type: "optfeature",
    key: "entries",
    depthIncrement: 1
}, {
    type: "patron",
    key: "entries"
}, ];
Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP = Renderer.ENTRIES_WITH_ENUMERATED_TITLES.mergeMap(it=>({[it.type]: it}));
Renderer._INLINE_HEADER_TERMINATORS = new Set([".", ",", "!", "?", ";", ":", `"`]);

Renderer.table = class {
    static getCompactRenderedString(it) {
        it.type = it.type || "table";
        const cpy = MiscUtil.copyFast(it);
        delete cpy.name;
        return `
			${Renderer.utils.getExcludedTr({
            entity: it,
            dataProp: "table",
            page: UrlUtil.PG_TABLES
        })}
			${Renderer.utils.getNameTr(it, {
            page: UrlUtil.PG_TABLES
        })}
			<tr><td colspan="6">
			${Renderer.get().setFirstSection(true).render(it)}
			</td></tr>
		`;
    }

    static getConvertedEncounterOrNamesTable({group, tableRaw, fnGetNameCaption, colLabel1}) {
        const getPadded = (number)=>{
            if (tableRaw.diceExpression === "d100")
                return String(number).padStart(2, "0");
            return String(number);
        }
        ;

        const nameCaption = fnGetNameCaption(group, tableRaw);
        return {
            name: nameCaption,
            type: "table",
            source: group?.source,
            page: group?.page,
            caption: nameCaption,
            colLabels: [`{@dice ${tableRaw.diceExpression}}`, colLabel1, tableRaw.rollAttitude ? `Attitude` : null, ].filter(Boolean),
            colStyles: ["col-2 text-center", tableRaw.rollAttitude ? "col-8" : "col-10", tableRaw.rollAttitude ? `col-2 text-center` : null, ].filter(Boolean),
            rows: tableRaw.table.map(it=>[`${getPadded(it.min)}${it.max != null && it.max !== it.min ? `-${getPadded(it.max)}` : ""}`, it.result, tableRaw.rollAttitude ? it.resultAttitude || "\u2014" : null, ].filter(Boolean)),
            footnotes: tableRaw.footnotes,
        };
    }

    static getConvertedEncounterTableName(group, tableRaw) {
        return `${group.name}${tableRaw.caption ? ` ${tableRaw.caption}` : ""}${/\bencounters?\b/i.test(group.name) ? "" : " Encounters"}${tableRaw.minlvl && tableRaw.maxlvl ? ` (Levels ${tableRaw.minlvl}\u2014${tableRaw.maxlvl})` : ""}`;
    }

    static getConvertedNameTableName(group, tableRaw) {
        return `${group.name} Names \u2013 ${tableRaw.option}`;
    }

    static getHeaderRowMetas(ent) {
        if (!ent.colLabels?.length && !ent.colLabelGroups?.length)
            return null;

        if (ent.colLabels?.length)
            return [ent.colLabels];

        const maxHeight = Math.max(...ent.colLabelGroups.map(clg=>clg.colLabels?.length || 0));

        const padded = ent.colLabelGroups.map(clg=>{
            const out = [...(clg.colLabels || [])];
            while (out.length < maxHeight)
                out.unshift("");
            return out;
        }
        );

        return [...new Array(maxHeight)].map((_,i)=>padded.map(lbls=>lbls[i]));
    }

    static _RE_TABLE_ROW_DASHED_NUMBERS = /^\d+([-\u2012\u2013]\d+)?/;
    static getAutoConvertedRollMode(table, {headerRowMetas}={}) {
        if (headerRowMetas === undefined){headerRowMetas = Renderer.table.getHeaderRowMetas(table);}

        if (!headerRowMetas || headerRowMetas[headerRowMetas.length-1].length < 2){return RollerUtil.ROLL_COL_NONE;}

        const rollColMode = RollerUtil.getColRollType(headerRowMetas[headerRowMetas.length-1][0]);
        if (!rollColMode){return RollerUtil.ROLL_COL_NONE;}

        if (!Renderer.table.isEveryRowRollable(table.rows)){return RollerUtil.ROLL_COL_NONE;}

        return rollColMode;
    }

    static isEveryRowRollable(rows) {
        return rows.every(row=>{
            if (!row)
                return false;
            const [cell] = row;
            return Renderer.table.isRollableCell(cell);
        }
        );
    }

    static isRollableCell(cell) {
        if (cell == null)
            return false;
        if (cell?.roll)
            return true;

        if (typeof cell === "number")
            return Number.isInteger(cell);

        return typeof cell === "string" && Renderer.table._RE_TABLE_ROW_DASHED_NUMBERS.test(cell);
    }
};

Renderer.stripTags = function(str) {
    if (!str)
        return str;
    let nxtStr = Renderer._stripTagLayer(str);
    while (nxtStr.length !== str.length) {
        str = nxtStr;
        nxtStr = Renderer._stripTagLayer(str);
    }
    return nxtStr;
};

Renderer._stripTagLayer = function(str) {
    if (str.includes("{@")) {
        const tagSplit = Renderer.splitByTags(str);
        return tagSplit.filter(it=>it).map(it=>{
            if (it.startsWith("{@")) {
                let[tag,text] = Renderer.splitFirstSpace(it.slice(1, -1));
                const tagInfo = Renderer.tag.TAG_LOOKUP[tag];
                if (!tagInfo)
                    throw new Error(`Unhandled tag: "${tag}"`);
                return tagInfo.getStripped(tag, text);
            } else
                return it;
        }
        ).join("");
    }
    return str;
};

Renderer.class = class {
    static getCompactRenderedString(cls) {
        if (cls.__prop === "subclass")
            return Renderer.subclass.getCompactRenderedString(cls);

        const clsEntry = {
            type: "section",
            name: cls.name,
            source: cls.source,
            page: cls.page,
            entries: MiscUtil.copyFast((cls.classFeatures || []).flat()),
        };

        return Renderer.hover.getGenericCompactRenderedString(clsEntry);
    }

    static getHitDiceEntry(clsHd) {
        return clsHd ? {
            toRoll: `${clsHd.number}d${clsHd.faces}`,
            rollable: true
        } : null;
    }
    static getHitPointsAtFirstLevel(clsHd) {
        return clsHd ? `${clsHd.number * clsHd.faces} + your Constitution modifier` : null;
    }
    static getHitPointsAtHigherLevels(className, clsHd, hdEntry) {
        return className && clsHd && hdEntry ? `${SETTINGS.DO_RENDER_DICE? Renderer.getEntryDice(hdEntry, "Hit die"): hdEntry.toRoll} (or 
            ${((clsHd.number * clsHd.faces) / 2 + 1)}) + your Constitution modifier per ${className} level after 1st` : null;
    }

    static getRenderedArmorProfs(armorProfs) {
        return armorProfs.map(a=>Renderer.get().render(a.full ? a.full : a === "light" || a === "medium" || a === "heavy" ? `{@filter ${a} armor|items|type=${a} armor}` : a)).join(", ");
    }
    static getRenderedWeaponProfs(weaponProfs) {
        return weaponProfs.map(w=>Renderer.get().render(w === "simple" || w === "martial" ? `{@filter ${w} weapons|items|type=${w} weapon}` : w.optional ? `<span class="help help--hover" title="Optional Proficiency">${w.proficiency}</span>` : w)).join(", ");
    }
    static getRenderedToolProfs(toolProfs) {
        return toolProfs.map(it=>Renderer.get().render(it)).join(", ");
    }
    static getRenderedSkillProfs(skills) {
        return `${Parser.skillProficienciesToFull(skills).uppercaseFirst()}.`;
    }

    static getWalkerFilterDereferencedFeatures() {
        return MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
            isAllowDeleteObjects: true,
            isDepthFirst: true,
        });
    }

    static mutFilterDereferencedClassFeatures({walker, cpyCls, pageFilter, filterValues, isUseSubclassSources=false, }, ) {
        walker = walker || Renderer.class.getWalkerFilterDereferencedFeatures();

        cpyCls.classFeatures = cpyCls.classFeatures.map((lvlFeatures,ixLvl)=>{
            return walker.walk(lvlFeatures, {
                object: (obj)=>{
                    if (!obj.source)
                        return obj;
                    const fText = obj.isClassFeatureVariant ? {
                        isClassFeatureVariant: true
                    } : null;

                    const isDisplay = [obj.source, ...(obj.otherSources || []).map(it=>it.source)].some(src=>pageFilter.filterBox.toDisplayByFilters(filterValues, ...[{
                        filter: pageFilter.sourceFilter,
                        value: isUseSubclassSources && src === cpyCls.source ? pageFilter.getActiveSource(filterValues) : src,
                    }, pageFilter.levelFilter ? {
                        filter: pageFilter.levelFilter,
                        value: ixLvl + 1,
                    } : null, {
                        filter: pageFilter.optionsFilter,
                        value: fText,
                    }, ].filter(Boolean), ));

                    return isDisplay ? obj : null;
                }
                ,
                array: (arr)=>{
                    return arr.filter(it=>it != null);
                }
                ,
            }, );
        }
        );
    }

    static mutFilterDereferencedSubclassFeatures({walker, cpySc, pageFilter, filterValues, }, ) {
        walker = walker || Renderer.class.getWalkerFilterDereferencedFeatures();

        cpySc.subclassFeatures = cpySc.subclassFeatures.map(lvlFeatures=>{
            const level = CollectionUtil.bfs(lvlFeatures, {
                prop: "level"
            });

            return walker.walk(lvlFeatures, {
                object: (obj)=>{
                    if (obj.entries && !obj.entries.length)
                        return null;
                    if (!obj.source)
                        return obj;
                    const fText = obj.isClassFeatureVariant ? {
                        isClassFeatureVariant: true
                    } : null;

                    const isDisplay = [obj.source, ...(obj.otherSources || []).map(it=>it.source)].some(src=>pageFilter.filterBox.toDisplayByFilters(filterValues, ...[{
                        filter: pageFilter.sourceFilter,
                        value: src,
                    }, pageFilter.levelFilter ? {
                        filter: pageFilter.levelFilter,
                        value: level,
                    } : null, {
                        filter: pageFilter.optionsFilter,
                        value: fText,
                    }, ].filter(Boolean), ));

                    return isDisplay ? obj : null;
                }
                ,
                array: (arr)=>{
                    return arr.filter(it=>it != null);
                }
                ,
            }, );
        }
        );
    }
};

Renderer.subclass = class {
    static getCompactRenderedString(sc) {
        const scEntry = {
            type: "section",
            name: sc.name,
            source: sc.source,
            page: sc.page,
            entries: MiscUtil.copyFast((sc.subclassFeatures || []).flat()),
        };

        return Renderer.hover.getGenericCompactRenderedString(scEntry);
    }
};
//#endregion

class MixedProxyBase //extends Cls
{
    constructor(...args) {
        //super(...args);
        this.__hooks = {};
        this.__hooksAll = {};
        this.__hooksTmp = null;
        this.__hooksAllTmp = null;
    }

    _getProxy(hookProp, toProxy) {
        return new Proxy(toProxy,{
            set: (object,prop,value)=>{
                return this._doProxySet(hookProp, object, prop, value);
            }
            ,
            deleteProperty: (object,prop)=>{
                if (!(prop in object))
                    return true;
                const prevValue = object[prop];
                Reflect.deleteProperty(object, prop);
                this._doFireHooksAll(hookProp, prop, undefined, prevValue);
                if (this.__hooks[hookProp] && this.__hooks[hookProp][prop])
                    this.__hooks[hookProp][prop].forEach(hook=>hook(prop, undefined, prevValue));
                return true;
            }
            ,
        });
    }

    _doProxySet(hookProp, object, prop, value) {
        if (object[prop] === value){return true;}
        const prevValue = object[prop];
        Reflect.set(object, prop, value);
        this._doFireHooksAll(hookProp, prop, value, prevValue);
        this._doFireHooks(hookProp, prop, value, prevValue);
        return true;
    }

    async _pDoProxySet(hookProp, object, prop, value) {
        if (object[prop] === value)
            return true;
        const prevValue = object[prop];
        Reflect.set(object, prop, value);
        if (this.__hooksAll[hookProp])
            for (const hook of this.__hooksAll[hookProp])
                await hook(prop, value, prevValue);
        if (this.__hooks[hookProp] && this.__hooks[hookProp][prop])
            for (const hook of this.__hooks[hookProp][prop])
                await hook(prop, value, prevValue);
        return true;
    }

    _doFireHooks(hookProp, prop, value, prevValue) {
        if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]){
            console.log("Fire hooks");
            this.__hooks[hookProp][prop].forEach(hook=>hook(prop, value, prevValue));
        }
    }

    _doFireHooksAll(hookProp, prop, value, prevValue) {
        if (this.__hooksAll[hookProp])
            this.__hooksAll[hookProp].forEach(hook=>hook(prop, undefined, prevValue));
    }

    _doFireAllHooks(hookProp) {
        if (this.__hooks[hookProp])
            Object.entries(this.__hooks[hookProp]).forEach(([prop,hk])=>hk(prop));
    }

    _addHook(hookProp, prop, hook) {
        ProxyBase._addHook_to(this.__hooks, hookProp, prop, hook);
        if (this.__hooksTmp)
            ProxyBase._addHook_to(this.__hooksTmp, hookProp, prop, hook);
        return hook;
    }

    static _addHook_to(obj, hookProp, prop, hook) {
        ((obj[hookProp] = obj[hookProp] || {})[prop] = (obj[hookProp][prop] || [])).push(hook);
    }

    _addHookAll(hookProp, hook) {
        ProxyBase._addHookAll_to(this.__hooksAll, hookProp, hook);
        if (this.__hooksAllTmp)
            ProxyBase._addHookAll_to(this.__hooksAllTmp, hookProp, hook);
        return hook;
    }

    static _addHookAll_to(obj, hookProp, hook) {
        (obj[hookProp] = obj[hookProp] || []).push(hook);
    }

    _removeHook(hookProp, prop, hook) {
        ProxyBase._removeHook_from(this.__hooks, hookProp, prop, hook);
        if (this.__hooksTmp)
            ProxyBase._removeHook_from(this.__hooksTmp, hookProp, prop, hook);
    }

    static _removeHook_from(obj, hookProp, prop, hook) {
        if (obj[hookProp] && obj[hookProp][prop]) {
            const ix = obj[hookProp][prop].findIndex(hk=>hk === hook);
            if (~ix)
                obj[hookProp][prop].splice(ix, 1);
        }
    }

    _removeHooks(hookProp, prop) {
        if (this.__hooks[hookProp])
            delete this.__hooks[hookProp][prop];
        if (this.__hooksTmp && this.__hooksTmp[hookProp])
            delete this.__hooksTmp[hookProp][prop];
    }

    _removeHookAll(hookProp, hook) {
        ProxyBase._removeHookAll_from(this.__hooksAll, hookProp, hook);
        if (this.__hooksAllTmp)
            ProxyBase._removeHook_from(this.__hooksAllTmp, hookProp, hook);
    }

    static _removeHookAll_from(obj, hookProp, hook) {
        if (obj[hookProp]) {
            const ix = obj[hookProp].findIndex(hk=>hk === hook);
            if (~ix)
                obj[hookProp].splice(ix, 1);
        }
    }

    _resetHooks(hookProp) {
        if (hookProp !== undefined)
            delete this.__hooks[hookProp];
        else
            Object.keys(this.__hooks).forEach(prop=>delete this.__hooks[prop]);
    }

    _resetHooksAll(hookProp) {
        if (hookProp !== undefined)
            delete this.__hooksAll[hookProp];
        else
            Object.keys(this.__hooksAll).forEach(prop=>delete this.__hooksAll[prop]);
    }

    _saveHookCopiesTo(obj) {
        this.__hooksTmp = obj;
    }
    _saveHookAllCopiesTo(obj) {
        this.__hooksAllTmp = obj;
    }

    _proxyAssign(hookProp, proxyProp, underProp, toObj, isOverwrite) {
        const oldKeys = Object.keys(this[proxyProp]);
        const nuKeys = new Set(Object.keys(toObj));
        const dirtyKeyValues = {};

        if (isOverwrite) {
            oldKeys.forEach(k=>{
                if (!nuKeys.has(k) && this[underProp] !== undefined) {
                    const prevValue = this[proxyProp][k];
                    delete this[underProp][k];
                    dirtyKeyValues[k] = prevValue;
                }
            }
            );
        }

        nuKeys.forEach(k=>{
            if (!CollectionUtil.deepEquals(this[underProp][k], toObj[k])) {
                const prevValue = this[proxyProp][k];
                this[underProp][k] = toObj[k];
                dirtyKeyValues[k] = prevValue;
            }
        }
        );

        Object.entries(dirtyKeyValues).forEach(([k,prevValue])=>{
            this._doFireHooksAll(hookProp, k, this[underProp][k], prevValue);
            if (this.__hooks[hookProp] && this.__hooks[hookProp][k])
                this.__hooks[hookProp][k].forEach(hk=>hk(k, this[underProp][k], prevValue));
        }
        );
    }

    _proxyAssignSimple(hookProp, toObj, isOverwrite) {
        return this._proxyAssign(hookProp, `_${hookProp}`, `__${hookProp}`, toObj, isOverwrite);
    }
}
class BaseComponent //extends Cls
extends MixedProxyBase
{
    _state;
    constructor(...args) {
        super(...args);

        this.__locks = {};
        this.__rendered = {};

        this.__state = {...this._getDefaultState()};
        this._state = this._getProxy("state", this.__state);
    }

    _addHookBase(prop, hook) {
        return this._addHook("state", prop, hook);
    }

    _removeHookBase(prop, hook) {
        return this._removeHook("state", prop, hook);
    }

    _removeHooksBase(prop) {
        return this._removeHooks("state", prop);
    }

    _addHookAllBase(hook) {
        return this._addHookAll("state", hook);
    }

    _removeHookAllBase(hook) {
        return this._removeHookAll("state", hook);
    }

    _setState(toState) {
        this._proxyAssign("state", "_state", "__state", toState, true);
    }

    _setStateValue(prop, value, {isForceTriggerHooks=true}={}) {
        if (this._state[prop] === value && !isForceTriggerHooks)
            return value;
        if (this._state[prop] !== value)
            return this._state[prop] = value;

        this._doFireHooksAll("state", prop, value, value);
        this._doFireHooks("state", prop, value, value);
        return value;
    }

    _getState() {
        return MiscUtil.copyFast(this.__state);
    }

    getPod() {
        this.__pod = this.__pod || {
            get: (prop)=>this._state[prop],
            set: (prop,val)=>this._state[prop] = val,
            delete: (prop)=>delete this._state[prop],
            addHook: (prop,hook)=>this._addHookBase(prop, hook),
            addHookAll: (hook)=>this._addHookAllBase(hook),
            removeHook: (prop,hook)=>this._removeHookBase(prop, hook),
            removeHookAll: (hook)=>this._removeHookAllBase(hook),
            triggerCollectionUpdate: (prop)=>this._triggerCollectionUpdate(prop),
            setState: (state)=>this._setState(state),
            getState: ()=>this._getState(),
            assign: (toObj,isOverwrite)=>this._proxyAssign("state", "_state", "__state", toObj, isOverwrite),
            pLock: lockName=>this._pLock(lockName),
            unlock: lockName=>this._unlock(lockName),
            component: this,
        };
        return this.__pod;
    }

    _getDefaultState() {
        return {};
    }

    getBaseSaveableState() {
        return {
            state: MiscUtil.copyFast(this.__state),
        };
    }

    setBaseSaveableStateFrom(toLoad, isOverwrite=false) {
        toLoad?.state && this._proxyAssignSimple("state", toLoad.state, isOverwrite);
    }

    _getRenderedCollection(opts) {
        opts = opts || {};
        const renderedLookupProp = opts.namespace ? `${opts.namespace}.${opts.prop}` : opts.prop;
        return (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
    }

    _renderCollection(opts) {
        opts = opts || {};

        const rendered = this._getRenderedCollection(opts);
        const entities = this._state[opts.prop] || [];
        return this._renderCollection_doRender(rendered, entities, opts);
    }

    _renderCollection_doRender(rendered, entities, opts) {
        opts = opts || {};

        const toDelete = new Set(Object.keys(rendered));

        for (let i = 0; i < entities.length; ++i) {
            const it = entities[i];

            if (it.id == null)
                throw new Error(`Collection item did not have an ID!`);
            const meta = rendered[it.id];

            toDelete.delete(it.id);
            if (meta) {
                if (opts.isDiffMode) {
                    const nxtHash = this._getCollectionEntityHash(it);
                    if (nxtHash !== meta.__hash)
                        meta.__hash = nxtHash;
                    else
                        continue;
                }

                meta.data = it;
                opts.fnUpdateExisting(meta, it, i);
            } else {
                const meta = opts.fnGetNew(it, i);

                if (meta == null)
                    continue;

                meta.data = it;
                if (!meta.$wrpRow && !meta.fnRemoveEles)
                    throw new Error(`A "$wrpRow" or a "fnRemoveEles" property is required for deletes!`);

                if (opts.isDiffMode)
                    meta.__hash = this._getCollectionEntityHash(it);

                rendered[it.id] = meta;
            }
        }

        const doRemoveElements = meta=>{
            if (meta.$wrpRow)
                meta.$wrpRow.remove();
            if (meta.fnRemoveEles)
                meta.fnRemoveEles();
        }
        ;

        toDelete.forEach(id=>{
            const meta = rendered[id];
            doRemoveElements(meta);
            delete rendered[id];
            if (opts.fnDeleteExisting)
                opts.fnDeleteExisting(meta);
        }
        );

        if (opts.fnReorderExisting) {
            entities.forEach((it,i)=>{
                const meta = rendered[it.id];
                opts.fnReorderExisting(meta, it, i);
            }
            );
        }
    }

    async _pRenderCollection(opts) {
        opts = opts || {};

        const rendered = this._getRenderedCollection(opts);
        const entities = this._state[opts.prop] || [];
        return this._pRenderCollection_doRender(rendered, entities, opts);
    }

    async _pRenderCollection_doRender(rendered, entities, opts) {
        opts = opts || {};

        const toDelete = new Set(Object.keys(rendered));

        for (let i = 0; i < entities.length; ++i) {
            const it = entities[i];

            if (!it.id)
                throw new Error(`Collection item did not have an ID!`);
            const meta = rendered[it.id];

            toDelete.delete(it.id);
            if (meta) {
                if (opts.isDiffMode) {
                    const nxtHash = this._getCollectionEntityHash(it);
                    if (nxtHash !== meta.__hash)
                        meta.__hash = nxtHash;
                    else
                        continue;
                }

                const nxtMeta = await opts.pFnUpdateExisting(meta, it);
                if (opts.isMultiRender)
                    rendered[it.id] = nxtMeta;
            } else {
                const meta = await opts.pFnGetNew(it);

                if (meta == null)
                    continue;

                if (!opts.isMultiRender && !meta.$wrpRow && !meta.fnRemoveEles)
                    throw new Error(`A "$wrpRow" or a "fnRemoveEles" property is required for deletes!`);
                if (opts.isMultiRender && meta.some(it=>!it.$wrpRow && !it.fnRemoveEles))
                    throw new Error(`A "$wrpRow" or a "fnRemoveEles" property is required for deletes!`);

                if (opts.isDiffMode)
                    meta.__hash = this._getCollectionEntityHash(it);

                rendered[it.id] = meta;
            }
        }

        const doRemoveElements = meta=>{
            if (meta.$wrpRow)
                meta.$wrpRow.remove();
            if (meta.fnRemoveEles)
                meta.fnRemoveEles();
        }
        ;

        for (const id of toDelete) {
            const meta = rendered[id];
            if (opts.isMultiRender)
                meta.forEach(it=>doRemoveElements(it));
            else
                doRemoveElements(meta);
            if (opts.additionalCaches)
                opts.additionalCaches.forEach(it=>delete it[id]);
            delete rendered[id];
            if (opts.pFnDeleteExisting)
                await opts.pFnDeleteExisting(meta);
        }

        if (opts.pFnReorderExisting) {
            await entities.pSerialAwaitMap(async(it,i)=>{
                const meta = rendered[it.id];
                await opts.pFnReorderExisting(meta, it, i);
            }
            );
        }
    }

    _detachCollection(prop, namespace=null) {
        const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
        const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
        Object.values(rendered).forEach(it=>it.$wrpRow.detach());
    }

    _resetCollectionRenders(prop, namespace=null) {
        const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
        const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
        Object.values(rendered).forEach(it=>it.$wrpRow.remove());
        delete this.__rendered[renderedLookupProp];
    }

    _getCollectionEntityHash(ent) {
        return CryptUtil.md5(JSON.stringify(ent));
    }

    render() {
        throw new Error("Unimplemented!");
    }

    getSaveableState() {
        return {
            ...this.getBaseSaveableState()
        };
    }
    setStateFrom(toLoad, isOverwrite=false) {
        this.setBaseSaveableStateFrom(toLoad, isOverwrite);
    }

    async _pLock(lockName) {
        while (this.__locks[lockName])
            await this.__locks[lockName].lock;
        let unlock = null;
        const lock = new Promise(resolve=>unlock = resolve);
        this.__locks[lockName] = {
            lock,
            unlock,
        };
    }

    async _pGate(lockName) {
        while (this.__locks[lockName])
            await this.__locks[lockName].lock;
    }

    _unlock(lockName) {
        const lockMeta = this.__locks[lockName];
        if (lockMeta) {
            delete this.__locks[lockName];
            lockMeta.unlock();
        }
    }

    async _pDoProxySetBase(prop, value) {
        return this._pDoProxySet("state", this.__state, prop, value);
    }

    _triggerCollectionUpdate(prop) {
        if (!this._state[prop])
            return;
        this._state[prop] = [...this._state[prop]];
    }

    static _toCollection(array) {
        if (array)
            return array.map(it=>({
                id: CryptUtil.uid(),
                entity: it
            }));
    }

    static _fromCollection(array) {
        if (array)
            return array.map(it=>it.entity);
    }

    static fromObject(obj, ...noModCollections) {
        const comp = new this();
        Object.entries(MiscUtil.copyFast(obj)).forEach(([k,v])=>{
            if (v == null)
                comp.__state[k] = v;
            else if (noModCollections.includes(k) || noModCollections.includes("*"))
                comp.__state[k] = v;
            else if (typeof v === "object" && v instanceof Array)
                comp.__state[k] = BaseComponent$1._toCollection(v);
            else
                comp.__state[k] = v;
        }
        );
        return comp;
    }

    static fromObjectNoMod(obj) {
        return this.fromObject(obj, "*");
    }

    toObject(...noModCollections) {
        const cpy = MiscUtil.copyFast(this.__state);
        Object.entries(cpy).forEach(([k,v])=>{
            if (v == null)
                return;

            if (noModCollections.includes(k) || noModCollections.includes("*"))
                cpy[k] = v;
            else if (v instanceof Array && v.every(it=>it && it.id))
                cpy[k] = BaseComponent$1._fromCollection(v);
        }
        );
        return cpy;
    }

    toObjectNoMod() {
        return this.toObject("*");
    }
}

//#region Base Components
let RenderableCollectionBase$1 = class RenderableCollectionBase {
    constructor(comp, prop, opts) {
        opts = opts || {};
        this._comp = comp;
        this._prop = prop;
        this._namespace = opts.namespace;
        this._isDiffMode = opts.isDiffMode;
    }

    getNewRender(entity, i) {
        throw new Error(`Unimplemented!`);
    }

    doUpdateExistingRender(renderedMeta, entity, i) {
        throw new Error(`Unimplemented!`);
    }

    doDeleteExistingRender(renderedMeta) {}

    doReorderExistingComponent(renderedMeta, entity, i) {}

    _getCollectionItem(id) {
        return this._comp._state[this._prop].find(it=>it.id === id);
    }

    render(opts) {
        opts = opts || {};
        this._comp._renderCollection({
            prop: this._prop,
            fnUpdateExisting: (rendered,ent,i)=>this.doUpdateExistingRender(rendered, ent, i),
            fnGetNew: (entity,i)=>this.getNewRender(entity, i),
            fnDeleteExisting: (rendered)=>this.doDeleteExistingRender(rendered),
            fnReorderExisting: (rendered,ent,i)=>this.doReorderExistingComponent(rendered, ent, i),
            namespace: this._namespace,
            isDiffMode: opts.isDiffMode != null ? opts.isDiffMode : this._isDiffMode,
        });
    }
};

globalThis.RenderableCollectionBase = RenderableCollectionBase$1;

class _RenderableCollectionGenericRowsSyncAsyncUtils {
    constructor({comp, prop, $wrpRows, namespace}) {
        this._comp = comp;
        this._prop = prop;
        this._$wrpRows = $wrpRows;
        this._namespace = namespace;
    }

    _getCollectionItem(id) {
        return this._comp._state[this._prop].find(it=>it.id === id);
    }

    getNewRenderComp(entity, i) {
        const comp = BaseComponent.fromObject(entity.entity, "*");
        comp._addHookAll("state", ()=>{
            this._getCollectionItem(entity.id).entity = comp.toObject("*");
            this._comp._triggerCollectionUpdate(this._prop);
        }
        );
        return comp;
    }

    doUpdateExistingRender(renderedMeta, entity, i) {
        renderedMeta.comp._proxyAssignSimple("state", entity.entity, true);
        if (!renderedMeta.$wrpRow.parent().is(this._$wrpRows))
            renderedMeta.$wrpRow.appendTo(this._$wrpRows);
    }

    static _doSwapJqueryElements($eles, ixA, ixB) {
        if (ixA > ixB)
            [ixA,ixB] = [ixB, ixA];

        const eleA = $eles.get(ixA);
        const eleB = $eles.get(ixB);

        const eleActive = document.activeElement;

        $(eleA).insertAfter(eleB);
        $(eleB).insertBefore($eles.get(ixA + 1));

        if (eleActive)
            eleActive.focus();
    }

    doReorderExistingComponent(renderedMeta, entity, i) {
        const ix = this._comp._state[this._prop].map(it=>it.id).indexOf(entity.id);
        const $rows = this._$wrpRows.find(`> *`);
        const curIx = $rows.index(renderedMeta.$wrpRow);

        const isMove = !this._$wrpRows.length || curIx !== ix;
        if (!isMove)
            return;

        this.constructor._doSwapJqueryElements($rows, curIx, ix);
    }

    $getBtnDelete({entity, title="Delete"}) {
        return $(`<button class="btn btn-xxs btn-danger" title="${title.qq()}"><span class="glyphicon glyphicon-trash"></span></button>`).click(()=>this.doDelete({
            entity
        }));
    }

    doDelete({entity}) {
        this._comp._state[this._prop] = this._comp._state[this._prop].filter(it=>it?.id !== entity.id);
    }

    doDeleteMultiple({entities}) {
        const ids = new Set(entities.map(it=>it.id));
        this._comp._state[this._prop] = this._comp._state[this._prop].filter(it=>!ids.has(it?.id));
    }

    $getPadDrag({$wrpRow}) {
        return DragReorderUiUtil$1.$getDragPadOpts(()=>$wrpRow, {
            swapRowPositions: (ixA,ixB)=>{
                [this._comp._state[this._prop][ixA],this._comp._state[this._prop][ixB]] = [this._comp._state[this._prop][ixB], this._comp._state[this._prop][ixA]];
                this._comp._triggerCollectionUpdate(this._prop);
            }
            ,
            $getChildren: ()=>{
                const rendered = this._comp._getRenderedCollection({
                    prop: this._prop,
                    namespace: this._namespace
                });
                return this._comp._state[this._prop].map(it=>rendered[it.id].$wrpRow);
            }
            ,
            $parent: this._$wrpRows,
        }, );
    }
}

let RenderableCollectionGenericRows$1 = class RenderableCollectionGenericRows extends RenderableCollectionBase$1 {
    constructor(comp, prop, $wrpRows, opts) {
        super(comp, prop, opts);
        this._$wrpRows = $wrpRows;

        this._utils = new _RenderableCollectionGenericRowsSyncAsyncUtils({
            comp,
            prop,
            $wrpRows,
            namespace: opts?.namespace,
        });
    }

    doUpdateExistingRender(renderedMeta, entity, i) {
        return this._utils.doUpdateExistingRender(renderedMeta, entity, i);
    }

    doReorderExistingComponent(renderedMeta, entity, i) {
        return this._utils.doReorderExistingComponent(renderedMeta, entity, i);
    }

    getNewRender(entity, i) {
        const comp = this._utils.getNewRenderComp(entity, i);

        const $wrpRow = this._$getWrpRow().appendTo(this._$wrpRows);

        const renderAdditional = this._populateRow({
            comp,
            $wrpRow,
            entity
        });

        return {
            ...(renderAdditional || {}),
            id: entity.id,
            comp,
            $wrpRow,
        };
    }

    _$getWrpRow() {
        return $(`<div class="ve-flex-v-center w-100"></div>`);
    }

    _populateRow({comp, $wrpRow, entity}) {
        throw new Error(`Unimplemented!`);
    }
};

globalThis.RenderableCollectionGenericRows = RenderableCollectionGenericRows$1;

//#region UtilActors
class UtilActors {
    static init() {
        UtilActors.VALID_DAMAGE_TYPES = Object.keys(MiscUtil.get(CONFIG, "DND5E", "damageTypes") || {});
        UtilActors.VALID_CONDITIONS = Object.keys(MiscUtil.get(CONFIG, "DND5E", "conditionTypes") || {});
    }

    static async pGetActorSpellItemOpts({actor, isAllowAutoDetectPreparationMode=false}={}) {
        const opts = {
            isActorItem: true,
            isActorItemNpc: actor?.type === "npc",
            isPrepared: !!Config.get("importSpell", "prepareActorSpells"),
            preparationMode: Config.get("importSpell", "actorSpellPreparationMode"),
        };

        if (!actor || this.isImporterTempActor(actor))
            return opts;

        const spellcastingAbility = MiscUtil.get(actor, "system", "attributes", "spellcasting");
        if (spellcastingAbility)
            opts.ability = spellcastingAbility.value;

        if (actor && isAllowAutoDetectPreparationMode) {
            const autoPreparationMode = await this._pGetActorSpellItemOpts_getAutoPreparationMode({
                actor
            });
            if (autoPreparationMode != null)
                opts.preparationMode = autoPreparationMode;
        }

        return opts;
    }

    static isImporterTempActor(actor) {
        return !!MiscUtil.get(actor, "flags", SharedConsts.MODULE_ID, "isImporterTempActor");
    }

    static async _pGetActorSpellItemOpts_getAutoPreparationMode({actor}) {
        if (!Config.get("importSpell", "isAutoDetectActorSpellPreparationMode"))
            return null;

        const classItems = actor.items.filter(it=>it.type === "class" && it.system?.spellcasting?.progression !== "none");
        if (!classItems.length || classItems.length > 1)
            return null;

        const sheetItem = classItems[0];

        const spellProgression = sheetItem.system.spellcasting.progression;
        switch (spellProgression) {
        case "full":
        case "half":
        case "third":
        case "artificer":
            {
                const classSubclassMeta = await UtilDataConverter.pGetClassItemClassAndSubclass({
                    sheetItem,
                    subclassSheetItems: actor.items.filter(it=>it.type === "subclass")
                });
                if (classSubclassMeta.matchingClasses.length !== 1)
                    return null;
                return (classSubclassMeta.matchingClasses[0].preparedSpells || classSubclassMeta.matchingClasses[0].preparedSpellsProgression) ? "prepared" : "always";
            }
        case "pact":
            return "pact";
        default:
            return null;
        }
    }

    static getSpellItemItemOpts() {
        const opts = {};

        opts.isPrepared = !!Config.get("importSpell", "prepareSpellItems");
        opts.preparationMode = Config.get("importSpell", "spellItemPreparationMode");

        return opts;
    }

    static getMappedTool(str) {
        str = str.toLowerCase().trim();
        if (this.VALID_TOOL_PROFICIENCIES[str])
            return this.VALID_TOOL_PROFICIENCIES[str];
        str = str.split("|")[0];
        return this.VALID_TOOL_PROFICIENCIES[str];
    }

    static getUnmappedTool(str) {
        if (!str)
            return null;
        return Parser._parse_bToA(this.VALID_TOOL_PROFICIENCIES, str, null);
    }

    static getMappedLanguage(str) {
        str = str.toLowerCase().trim();
        return this.VALID_LANGUAGES[str];
    }

    static getMappedCasterType(str) {
        if (!str)
            return str;
        return this._VET_CASTER_TYPE_TO_FVTT[str];
    }

    static getMappedArmorProficiency(str) {
        if (!str)
            return null;
        return Parser._parse_aToB(this.VALID_ARMOR_PROFICIENCIES, str, null);
    }

    static getUnmappedArmorProficiency(str) {
        if (!str)
            return null;
        return Parser._parse_bToA(this.VALID_ARMOR_PROFICIENCIES, str, null);
    }

    static getMappedWeaponProficiency(str) {
        if (!str)
            return null;
        return Parser._parse_aToB(this.VALID_WEAPON_PROFICIENCIES, str, null);
    }

    static getUnmappedWeaponProficiency(str) {
        if (!str)
            return null;
        return Parser._parse_bToA(this.VALID_WEAPON_PROFICIENCIES, str, null);
    }

    static getItemUIdFromWeaponProficiency(str) {
        if (!str)
            return null;
        str = str.trim();
        const tagItemUid = this._getItemUidFromTag(str);
        if (tagItemUid)
            return tagItemUid;
        return Parser._parse_aToB(this._WEAPON_PROFICIENCIES_TO_ITEM_UIDS, str, null);
    }

    static getItemUIdFromToolProficiency(str) {
        if (!str)
            return null;
        str = str.trim();
        const tagItemUid = this._getItemUidFromTag(str);
        if (tagItemUid)
            return tagItemUid;
        return Parser._parse_aToB(this._TOOL_PROFICIENCIES_TO_ITEM_UIDS, str, null);
    }

    static _getItemUidFromTag(str) {
        const mItem = /^{@item ([^}]+)}$/.exec(str);
        if (!mItem)
            return null;
        const {name, source} = DataUtil.generic.unpackUid(mItem[1], "item", {
            isLower: true
        });
        return `${name}|${source}`;
    }

    static getActorBarAttributes(actor) {
        if (!actor)
            return [];

        const attributeSource = actor?.system instanceof foundry.abstract.DataModel ? actor?.type : actor?.system;
        const attributes = MiscUtil.copyFast(TokenDocument.implementation.getTrackedAttributes(attributeSource), );

        return TokenDocument.implementation.getTrackedAttributeChoices(attributes);
    }

    static getTotalClassLevels(actor) {
        return actor.items.filter(it=>it.type === "class").map(it=>it.system.levels || 0).reduce((a,b)=>a + b, 0);
    }

    static isLevelUp(actor) {
        let xpCur = Number(actor?.system?.details?.xp?.value);
        if (isNaN(xpCur))
            xpCur = 0;

        const lvlTarget = actor.items.filter(it=>it.type === "class").map(it=>it.system.levels || 0).sum();
        let xpMax = game.system.config.CHARACTER_EXP_LEVELS[lvlTarget];
        if (isNaN(xpMax))
            xpMax = Number.MAX_SAFE_INTEGER;

        return xpCur >= xpMax;
    }

    static ICON_SPELL_POINTS_ = "icons/magic/light/explosion-star-glow-silhouette.webp";
    static _SPELL_POINTS_SLOT_COUNT = 99;
    static async pGetCreateActorSpellPointsSlotsEffect({actor, isTemporary, isRender}) {
        if (this.hasActorSpellPointSlotEffect({
            actor
        }))
            return;

        await UtilDocuments.pCreateEmbeddedDocuments(actor, this.getActorSpellPointsSlotsEffectData({
            actor
        }), {
            ClsEmbed: ActiveEffect,
            isTemporary,
            isRender
        }, );

        await UtilDocuments.pUpdateDocument(actor, this.getActorSpellPointsSlotsUpdateSys());
    }

    static hasActorSpellPointSlotEffect({actor}) {
        return (actor?.effects || []).some(it=>it.flags[SharedConsts.MODULE_ID]?.["isSpellPointsSlotUnlocker"]);
    }

    static getActorSpellPointsSlotsEffectData({actor=null, sheetItem=null}={}) {
        return UtilActiveEffects.getExpandedEffects([{
            name: `Spell Points Spell Slot Unlock`,
            changes: [...new Array(9)].map((_,i)=>({
                "key": `system.spells.spell${i + 1}.override`,
                "mode": "OVERRIDE",
                "value": this._SPELL_POINTS_SLOT_COUNT,
            })),
            flags: {
                [SharedConsts.MODULE_ID]: {
                    isSpellPointsSlotUnlocker: true,
                    dedupeId: "spellPointsSlotUnlocker",
                },
            },
        }, ], {
            img: this.ICON_SPELL_POINTS_,
            actor,
            sheetItem,
        }, );
    }

    static getActorSpellPointsSlotsUpdateSys() {
        return {
            system: {
                spells: [...new Array(9)].mergeMap((_,i)=>({
                    [`spell${i + 1}`]: {
                        value: 99,
                    },
                })),
            },
        };
    }

    static getActorSpellPointsItem({actor}) {
        return SpellPointsItemBuilder.getItem({
            actor
        });
    }

    static async pGetCreateActorSpellPointsItem({actor, totalSpellcastingLevels=null}) {
        return SpellPointsItemBuilder.pGetCreateItem({
            actor,
            totalLevels: totalSpellcastingLevels
        });
    }

    static getActorPsiPointsItem({actor}) {
        return PsiPointsItemBuilder.getItem({
            actor
        });
    }

    static async pGetCreateActorPsiPointsItem({actor, totalMysticLevels=null}) {
        return PsiPointsItemBuilder.pGetCreateItem({
            actor,
            totalLevels: totalMysticLevels
        });
    }

    static getActorSpellcastingInfo({actor, sheetItems, isForceSpellcastingMulticlass=false, }={}, ) {
        if (actor && sheetItems)
            throw new Error(`Only one of "actor" or "sheetItems" may be specified!`);

        const spellcastingClassItems = (actor?.items || sheetItems).filter(it=>it.type === "class").filter(it=>it.system?.spellcasting);

        if (!spellcastingClassItems.length) {
            return {
                totalSpellcastingLevels: 0,
                casterClassCount: 0,
                maxPactCasterLevel: 0,
                isSpellcastingMulticlass: isForceSpellcastingMulticlass,
            };
        }

        let totalSpellcastingLevels = 0;
        let maxPactCasterLevel = 0;

        const isSpellcastingMulticlass = isForceSpellcastingMulticlass || spellcastingClassItems.length > 1;

        const getSpellcastingLevel = (lvl,type)=>{
            switch (type) {
            case "half":
                return Math.ceil(lvl / 2);
            case "third":
                return Math.ceil(lvl / 3);
            case "artificer":
                return lvl === 1 ? 1 : getSpellcastingLevel(lvl, "half");
            default:
                throw new Error(`Unhandled spellcaster type "${type}"`);
            }
        }
        ;

        const getSpellcastingLevelMulticlass = (lvl,type)=>{
            switch (type) {
            case "half":
                return Math.floor(lvl / 2);
            case "third":
                return Math.floor(lvl / 3);
            case "artificer":
                return Math.ceil(lvl / 2);
            default:
                throw new Error(`Unhandled spellcaster type "${type}"`);
            }
        }
        ;

        const fnGetSpellcastingLevelHalfThird = isSpellcastingMulticlass ? getSpellcastingLevelMulticlass : getSpellcastingLevel;

        spellcastingClassItems.forEach(it=>{
            const lvl = it.system.levels || 0;

            switch (it.system.spellcasting.progression) {
            case "full":
                totalSpellcastingLevels += lvl;
                break;
            case "half":
                totalSpellcastingLevels += fnGetSpellcastingLevelHalfThird(lvl, it.system.spellcasting.progression);
                break;
            case "third":
                totalSpellcastingLevels += fnGetSpellcastingLevelHalfThird(lvl, it.system.spellcasting.progression);
                break;
            case "pact":
                Math.max(maxPactCasterLevel, lvl);
                break;
            case "artificer":
                totalSpellcastingLevels += fnGetSpellcastingLevelHalfThird(lvl, it.system.spellcasting.progression);
                break;
            }
        }
        );

        return {
            totalSpellcastingLevels,
            casterClassCount: spellcastingClassItems.length,
            maxPactCasterLevel,
            isSpellcastingMulticlass
        };
    }

    static async pLinkTempUuids({actor}) {
        const SENTINEL = `__${SharedConsts.MODULE_ID_FAKE}_REPLACE_TARGET__`;

        const reUuid = new RegExp(`(?<prefix>@UUID\\[[^\\]]+\\.)temp-${SharedConsts.MODULE_ID_FAKE}-(?<packed>[^.\\]]+)(?<suffix>](?:\\{[^}]+})?)`,"g");
        const reSentinelLi = new RegExp(`<li[^>]*>\\s*${SENTINEL}\\s*<\\/li>`,"g");
        const reSentinelP = new RegExp(`<p[^>]*>\\s*${SENTINEL}\\s*<\\/p>`,"g");
        const reSentinel = new RegExp(SENTINEL,"g");

        const updates = actor.items.map(item=>{
            const desc = item.system.description.value || "";
            const nxtDesc = desc.replace(reUuid, (...m)=>{
                const packed = m.last().packed;
                try {
                    const {page, source, hash} = JSON.parse(decodeURIComponent(atob(packed)));
                    if (!page || !source || !hash)
                        return SENTINEL;

                    const matchedItem = actor.items.find(it=>it.flags?.[SharedConsts.MODULE_ID]?.page === page && it.flags?.[SharedConsts.MODULE_ID]?.source === source && it.flags?.[SharedConsts.MODULE_ID]?.hash === hash);

                    if (!matchedItem)
                        return SENTINEL;

                    return `${m.last().prefix}${matchedItem.id}${m.last().suffix}`;
                } catch (e) {
                    console.error(...LGT, `Failed to unpack temp page/source/hash`, e);
                    return "";
                }
            }
            ).replace(reSentinelLi, "").replace(reSentinelP, "").replace(reSentinel, "");

            if (desc === nxtDesc)
                return null;

            return {
                _id: item.id,
                system: {
                    description: {
                        value: nxtDesc,
                    },
                },
            };
        }
        ).filter(Boolean);

        if (!updates.length)
            return;

        await UtilDocuments.pUpdateEmbeddedDocuments(actor, updates, {
            ClsEmbed: Item
        });
    }

    static isSetMaxHp({actor}) {
        if (!UtilVersions.getSystemVersion().isVersionTwoOnePlus)
            return true;
        return actor._source.system.attributes.hp.max != null;
    }

    static getProficiencyBonusNumber({actor}) {
        const prof = actor.getRollData().prof;
        if (typeof prof === "number")
            return prof;
        return prof.flat;
    }
}
UtilActors.SKILL_ABV_TO_FULL = {
    acr: "acrobatics",
    ani: "animal handling",
    arc: "arcana",
    ath: "athletics",
    dec: "deception",
    his: "history",
    ins: "insight",
    itm: "intimidation",
    inv: "investigation",
    med: "medicine",
    nat: "nature",
    prc: "perception",
    prf: "performance",
    per: "persuasion",
    rel: "religion",
    slt: "sleight of hand",
    ste: "stealth",
    sur: "survival",
};
UtilActors.TOOL_ABV_TO_FULL = {
    art: "artisan's tools",
    alchemist: "alchemist's supplies",
    brewer: "brewer's supplies",
    calligrapher: "calligrapher's supplies",
    carpenter: "carpenter's tools",
    cartographer: "cartographer's tools",
    cobbler: "cobbler's tools",
    cook: "cook's utensils",
    glassblower: "glassblower's tools",
    jeweler: "jeweler's tools",
    leatherworker: "leatherworker's tools",
    mason: "mason's tools",
    painter: "painter's supplies",
    potter: "potter's tools",
    smith: "smith's tools",
    tinker: "tinker's tools",
    weaver: "weaver's tools",
    woodcarver: "woodcarver's tools",

    disg: "disguise kit",
    forg: "forgery kit",

    game: "gaming set",
    chess: "dragonchess set",
    dice: "dice set",
    card: "three-dragon ante set",

    herb: "herbalism kit",

    music: "musical instrument",
    bagpipes: "bagpipes",
    drum: "drum",
    dulcimer: "dulcimer",
    flute: "flute",
    horn: "horn",
    lute: "lute",
    lyre: "lyre",
    panflute: "pan flute",
    shawm: "shawm",
    viol: "viol",

    navg: "navigator's tools",

    pois: "poisoner's kit",

    thief: "thieves' tools",

    vehicle: "vehicles",
    air: "vehicles (air)",
    land: "vehicles (land)",
    space: "vehicles (space)",
    water: "vehicles (water)",
};
UtilActors.PROF_TO_ICON_CLASS = {
    "1": "fa-check",
    "2": "fa-check-double",
    "0.5": "fa-adjust",
};
UtilActors.PROF_TO_TEXT = {
    "1": "Proficient",
    "2": "Proficient with Expertise",
    "0.5": "Half-Proficient",
    "0": "",
};
UtilActors.VET_SIZE_TO_ABV = {
    [Parser.SZ_TINY]: "tiny",
    [Parser.SZ_SMALL]: "sm",
    [Parser.SZ_MEDIUM]: "med",
    [Parser.SZ_LARGE]: "lg",
    [Parser.SZ_HUGE]: "huge",
    [Parser.SZ_GARGANTUAN]: "grg",
};
UtilActors.VET_SPELL_SCHOOL_TO_ABV = {
    A: "abj",
    C: "con",
    D: "div",
    E: "enc",
    V: "evo",
    I: "ill",
    N: "nec",
    T: "trs",
};

UtilActors.PACT_CASTER_MAX_SPELL_LEVEL = 5;

UtilActors.VALID_DAMAGE_TYPES = null;
UtilActors.VALID_CONDITIONS = null;

UtilActors.TOOL_PROFICIENCIES_TO_UID = {
    "alchemist's supplies": "alchemist's supplies|phb",
    "brewer's supplies": "brewer's supplies|phb",
    "calligrapher's supplies": "calligrapher's supplies|phb",
    "carpenter's tools": "carpenter's tools|phb",
    "cartographer's tools": "cartographer's tools|phb",
    "cobbler's tools": "cobbler's tools|phb",
    "cook's utensils": "cook's utensils|phb",
    "glassblower's tools": "glassblower's tools|phb",
    "jeweler's tools": "jeweler's tools|phb",
    "leatherworker's tools": "leatherworker's tools|phb",
    "mason's tools": "mason's tools|phb",
    "painter's supplies": "painter's supplies|phb",
    "potter's tools": "potter's tools|phb",
    "smith's tools": "smith's tools|phb",
    "tinker's tools": "tinker's tools|phb",
    "weaver's tools": "weaver's tools|phb",
    "woodcarver's tools": "woodcarver's tools|phb",
    "disguise kit": "disguise kit|phb",
    "forgery kit": "forgery kit|phb",
    "gaming set": "gaming set|phb",
    "herbalism kit": "herbalism kit|phb",
    "musical instrument": "musical instrument|phb",
    "navigator's tools": "navigator's tools|phb",
    "thieves' tools": "thieves' tools|phb",
    "poisoner's kit": "poisoner's kit|phb",
};
UtilActors.VALID_TOOL_PROFICIENCIES = {
    "artisan's tools": "art",
    "alchemist's supplies": "alchemist",
    "brewer's supplies": "brewer",
    "calligrapher's supplies": "calligrapher",
    "carpenter's tools": "carpenter",
    "cartographer's tools": "cartographer",
    "cobbler's tools": "cobbler",
    "cook's utensils": "cook",
    "glassblower's tools": "glassblower",
    "jeweler's tools": "jeweler",
    "leatherworker's tools": "leatherworker",
    "mason's tools": "mason",
    "painter's supplies": "painter",
    "potter's tools": "potter",
    "smith's tools": "smith",
    "tinker's tools": "tinker",
    "weaver's tools": "weaver",
    "woodcarver's tools": "woodcarver",

    "disguise kit": "disg",

    "forgery kit": "forg",

    "gaming set": "game",
    "dice set": "dice",
    "dragonchess set": "chess",
    "playing card set": "card",
    "three-dragon ante set": "card",

    "herbalism kit": "herb",

    "musical instrument": "music",
    "bagpipes": "bagpipes",
    "drum": "drum",
    "dulcimer": "dulcimer",
    "flute": "flute",
    "lute": "lute",
    "lyre": "lyre",
    "horn": "horn",
    "pan flute": "panflute",
    "shawm": "shawm",
    "viol": "viol",

    "navigator's tools": "navg",

    "poisoner's kit": "pois",

    "thieves' tools": "thief",

    "vehicle (land or water)": "vehicle",
    "vehicle (air)": "air",
    "vehicle (land)": "land",
    "vehicle (water)": "water",
    "vehicle (space)": "space",
};
UtilActors.VALID_LANGUAGES = {
    "common": "common",
    "aarakocra": "aarakocra",
    "abyssal": "abyssal",
    "aquan": "aquan",
    "auran": "auran",
    "celestial": "celestial",
    "deep speech": "deep",
    "draconic": "draconic",
    "druidic": "druidic",
    "dwarvish": "dwarvish",
    "elvish": "elvish",
    "giant": "giant",
    "gith": "gith",
    "gnomish": "gnomish",
    "goblin": "goblin",
    "gnoll": "gnoll",
    "halfling": "halfling",
    "ignan": "ignan",
    "infernal": "infernal",
    "orc": "orc",
    "primordial": "primordial",
    "sylvan": "sylvan",
    "terran": "terran",
    "thieves' cant": "cant",
    "undercommon": "undercommon",
};
UtilActors.LANGUAGES_PRIMORDIAL = ["aquan", "auran", "ignan", "terran", ];
UtilActors._VET_CASTER_TYPE_TO_FVTT = {
    "full": "full",
    "1/2": "half",
    "1/3": "third",
    "pact": "pact",
    "artificer": "artificer",
};
UtilActors.ARMOR_PROFICIENCIES = ["light", "medium", "heavy", "shield|phb", ];
UtilActors.VALID_ARMOR_PROFICIENCIES = {
    "light": "lgt",
    "medium": "med",
    "heavy": "hvy",
    "shield|phb": "shl",
};
UtilActors.WEAPON_PROFICIENCIES = ["battleaxe|phb", "club|phb", "dagger|phb", "flail|phb", "glaive|phb", "greataxe|phb", "greatclub|phb", "greatsword|phb", "halberd|phb", "handaxe|phb", "javelin|phb", "lance|phb", "light hammer|phb", "longsword|phb", "mace|phb", "maul|phb", "morningstar|phb", "pike|phb", "quarterstaff|phb", "rapier|phb", "scimitar|phb", "shortsword|phb", "sickle|phb", "spear|phb", "staff|phb", "trident|phb", "war pick|phb", "warhammer|phb", "whip|phb", "blowgun|phb", "dart|phb", "hand crossbow|phb", "heavy crossbow|phb", "light crossbow|phb", "longbow|phb", "net|phb", "shortbow|phb", "sling|phb", ];
UtilActors.VALID_WEAPON_PROFICIENCIES = {
    "simple": "sim",
    "martial": "mar",

    "club|phb": "club",
    "dagger|phb": "dagger",
    "dart|phb": "dart",
    "greatclub|phb": "greatclub",
    "handaxe|phb": "handaxe",
    "javelin|phb": "javelin",
    "light crossbow|phb": "lightcrossbow",
    "light hammer|phb": "lighthammer",
    "mace|phb": "mace",
    "quarterstaff|phb": "quarterstaff",
    "shortbow|phb": "shortbow",
    "sickle|phb": "sickle",
    "sling|phb": "sling",
    "spear|phb": "spear",

    "battleaxe|phb": "battleaxe",
    "blowgun|phb": "blowgun",
    "flail|phb": "flail",
    "glaive|phb": "glaive",
    "greataxe|phb": "greataxe",
    "greatsword|phb": "greatsword",
    "halberd|phb": "halberd",
    "hand crossbow|phb": "handcrossbow",
    "heavy crossbow|phb": "heavycrossbow",
    "lance|phb": "lance",
    "longbow|phb": "longbow",
    "longsword|phb": "longsword",
    "maul|phb": "maul",
    "morningstar|phb": "morningstar",
    "net|phb": "net",
    "pike|phb": "pike",
    "rapier|phb": "rapier",
    "scimitar|phb": "scimitar",
    "shortsword|phb": "shortsword",
    "trident|phb": "trident",
    "war pick|phb": "warpick",
    "warhammer|phb": "warhammer",
    "whip|phb": "whip",
};
UtilActors._WEAPON_PROFICIENCIES_TO_ITEM_UIDS = {
    "battleaxes": "battleaxe|phb",
    "clubs": "club|phb",
    "daggers": "dagger|phb",
    "flails": "flail|phb",
    "glaives": "glaive|phb",
    "greataxes": "greataxe|phb",
    "greatclubs": "greatclub|phb",
    "greatswords": "greatsword|phb",
    "halberds": "halberd|phb",
    "handaxes": "handaxe|phb",
    "javelins": "javelin|phb",
    "lances": "lance|phb",
    "light hammers": "light hammer|phb",
    "longswords": "longsword|phb",
    "maces": "mace|phb",
    "mauls": "maul|phb",
    "morningstars": "morningstar|phb",
    "pikes": "pike|phb",
    "quarterstaffs": "quarterstaff|phb",
    "rapiers": "rapier|phb",
    "scimitars": "scimitar|phb",
    "shortswords": "shortsword|phb",
    "sickles": "sickle|phb",
    "spears": "spear|phb",
    "staffs": "staff|phb",
    "tridents": "trident|phb",
    "war picks": "war pick|phb",
    "warhammers": "warhammer|phb",
    "whips": "whip|phb",

    "blowguns": "blowgun|phb",
    "darts": "dart|phb",
    "hand crossbows": "hand crossbow|phb",
    "heavy crossbows": "heavy crossbow|phb",
    "light crossbows": "light crossbow|phb",
    "longbows": "longbow|phb",
    "nets": "net|phb",
    "shortbows": "shortbow|phb",
    "slings": "sling|phb",

    "battleaxe": "battleaxe|phb",
    "club": "club|phb",
    "dagger": "dagger|phb",
    "flail": "flail|phb",
    "glaive": "glaive|phb",
    "greataxe": "greataxe|phb",
    "greatclub": "greatclub|phb",
    "greatsword": "greatsword|phb",
    "halberd": "halberd|phb",
    "handaxe": "handaxe|phb",
    "javelin": "javelin|phb",
    "lance": "lance|phb",
    "light hammer": "light hammer|phb",
    "longsword": "longsword|phb",
    "mace": "mace|phb",
    "maul": "maul|phb",
    "morningstar": "morningstar|phb",
    "pike": "pike|phb",
    "quarterstaff": "quarterstaff|phb",
    "rapier": "rapier|phb",
    "scimitar": "scimitar|phb",
    "shortsword": "shortsword|phb",
    "sickle": "sickle|phb",
    "spear": "spear|phb",
    "staff": "staff|phb",
    "trident": "trident|phb",
    "war pick": "war pick|phb",
    "warhammer": "warhammer|phb",
    "whip": "whip|phb",

    "blowgun": "blowgun|phb",
    "dart": "dart|phb",
    "hand crossbow": "hand crossbow|phb",
    "heavy crossbow": "heavy crossbow|phb",
    "light crossbow": "light crossbow|phb",
    "longbow": "longbow|phb",
    "net": "net|phb",
    "shortbow": "shortbow|phb",
    "sling": "sling|phb",
};
UtilActors._TOOL_PROFICIENCIES_TO_ITEM_UIDS = {
    "alchemist's supplies": "alchemist's supplies|phb",
    "artisan's tools": "artisan's tools|phb",
    "bagpipes": "bagpipes|phb",
    "brewer's supplies": "brewer's supplies|phb",
    "calligrapher's supplies": "calligrapher's supplies|phb",
    "carpenter's tools": "carpenter's tools|phb",
    "cartographer's tools": "cartographer's tools|phb",
    "cobbler's tools": "cobbler's tools|phb",
    "cook's utensils": "cook's utensils|phb",
    "disguise kit": "disguise kit|phb",
    "drum": "drum|phb",
    "dulcimer": "dulcimer|phb",
    "flute": "flute|phb",
    "forgery kit": "forgery kit|phb",
    "glassblower's tools": "glassblower's tools|phb",
    "herbalism kit": "herbalism kit|phb",
    "horn": "horn|phb",
    "jeweler's tools": "jeweler's tools|phb",
    "leatherworker's tools": "leatherworker's tools|phb",
    "lute": "lute|phb",
    "lyre": "lyre|phb",
    "mason's tools": "mason's tools|phb",
    "musical instrument": "musical instrument|phb",
    "navigator's tools": "navigator's tools|phb",
    "painter's supplies": "painter's supplies|phb",
    "pan flute": "pan flute|phb",
    "poisoner's kit": "poisoner's kit|phb",
    "potter's tools": "potter's tools|phb",
    "shawm": "shawm|phb",
    "smith's tools": "smith's tools|phb",
    "thieves' tools": "thieves' tools|phb",
    "tinker's tools": "tinker's tools|phb",
    "viol": "viol|phb",
    "weaver's tools": "weaver's tools|phb",
    "woodcarver's tools": "woodcarver's tools|phb",
};

UtilActors.BG_SKILL_PROFS_CUSTOMIZE = [{
    choose: {
        from: Object.keys(Parser.SKILL_TO_ATB_ABV),
        count: 2,
    },
}, ];

UtilActors.LANG_TOOL_PROFS_CUSTOMIZE = [{
    anyStandardLanguage: 2,
}, {
    anyStandardLanguage: 1,
    anyTool: 1,
}, {
    anyTool: 2,
}, ];
//#endregion

class Charactermancer_FeatureSourceTracker extends BaseComponent {
    constructor() {
        super();
        this._registered = new Map();
    }

    register(comp) {
        this._registered.set(comp, {
            state: null,
            hookMetas: []
        });
    }

    _validateProp(propPulse) {
        if (!Charactermancer_FeatureSourceTracker._VALID_HOOK_PROPS.has(propPulse))
            throw new Error(`Unhandled pulse prop "${propPulse}"`);
    }

    addHook(comp, propPulse, hk) {
        this._validateProp(propPulse);

        if (!this._registered.has(comp))
            this.register(comp);

        this._registered.get(comp).hookMetas.push({
            propPulse,
            hook: hk
        });
        this._addHookBase(propPulse, hk);
    }

    removeHook(comp, propPulse, hk) {
        this._validateProp(propPulse);

        if (!this._registered.has(comp))
            return;

        const compMeta = this._registered.get(comp);
        const ixHook = compMeta.hookMetas.findIndex(it=>it.hook === hk);
        if (~ixHook)
            compMeta.hookMetas.splice(ixHook, 1);
        this._removeHookBase(propPulse, hk);
    }

    setState(comp, state) {
        if (!this._registered.has(comp))
            this.register(comp);

        const compMeta = this._registered.get(comp);

        const prevState = compMeta.state ? MiscUtil.copy(compMeta.state) : compMeta.state;
        compMeta.state = state;

        const allKeys = new Set([...Object.keys(prevState || {}), ...Object.keys(state || {}), ]);

        allKeys.forEach(k=>{
            const oldVal = prevState?.[k];
            const nuVal = state?.[k];

            if (CollectionUtil.deepEquals(oldVal, nuVal))
                return;

            this._doPulseForProp(k);
        }
        );
    }

    getStatesForKey(key, {ignore=null}={}) {
        const out = [];
        for (const [comp,compMeta] of this._registered.entries()) {
            if (ignore === comp)
                continue;
            if (compMeta?.state?.[key])
                out.push(compMeta.state[key]);
        }
        return out;
    }

    unregister(comp) {
        if (!comp)
            return;

        const registered = this._registered.get(comp);
        if (!registered)
            return;

        this._registered.delete(comp);

        registered.hookMetas.forEach(({propPulse, hook})=>{
            this._removeHookBase(propPulse, hook);
        }
        );

        if (registered.state) {
            Object.keys(registered.state).forEach(k=>{
                this._doPulseForProp(k);
            }
            );
        }
    }

    _doPulseForProp(k) {
        switch (k) {
        case "skillProficiencies":
            return this._state.pulseSkillProficiencies = !this._state.pulseSkillProficiencies;
        case "languageProficiencies":
            return this._state.pulseLanguageProficiencies = !this._state.pulseLanguageProficiencies;
        case "toolProficiencies":
            return this._state.pulseToolProficiencies = !this._state.pulseToolProficiencies;
        case "armorProficiencies":
            return this._state.pulseArmorProficiencies = !this._state.pulseArmorProficiencies;
        case "weaponProficiencies":
            return this._state.pulseWeaponProficiencies = !this._state.pulseWeaponProficiencies;
        case "features":
            return this._state.pulseFeatures = !this._state.pulseFeatures;
        case "savingThrowProficiencies":
            return this._state.pulseSavingThrowProficiencies = !this._state.pulseSavingThrowProficiencies;
        case "immune":
            return this._state.pulseImmune = !this._state.pulseImmune;
        case "resist":
            return this._state.pulseResist = !this._state.pulseResist;
        case "vulnerable":
            return this._state.pulseVulnerable = !this._state.pulseVulnerable;
        case "conditionImmune":
            return this._state.pulseConditionImmune = !this._state.pulseConditionImmune;
        case "expertise":
            return this._state.pulseExpertise = !this._state.pulseExpertise;
        default:
            throw new Error(`Unhandled tracked state key ${k}`);
        }
    }

    _getDefaultState() {
        return [...Charactermancer_FeatureSourceTracker._VALID_HOOK_PROPS].mergeMap(it=>({
            [it]: false
        }));
    }
}
Charactermancer_FeatureSourceTracker._VALID_HOOK_PROPS = new Set(["pulseSkillProficiencies", "pulseLanguageProficiencies", "pulseToolProficiencies", "pulseArmorProficiencies", "pulseWeaponProficiencies", "pulseFeatures", "pulseSavingThrowProficiencies", "pulseImmune", "pulseResist", "pulseVulnerable", "pulseConditionImmune", "pulseExpertise", ]);

//#endregion

class ActorCharactermancerBaseComponent extends BaseComponent {
    get state() {return this._state; }
    addHookBase(prop, hook) {
      this._addHookBase(prop, hook);
    }
    proxyAssignSimple(hookProp, toObj, isOverwrite) {
      return this._proxyAssignSimple(hookProp, toObj, isOverwrite);
    }
    /**Simply creates a property out of an index, to use for asking _state for information */
    static class_getProps(ix) {
    return {
        'propPrefixClass': 'class_' + ix + '_',
        'propIxClass': "class_" + ix + "_ixClass",
        'propPrefixSubclass': "class_" + ix + "_subclass_",
        'propIxSubclass': "class_" + ix + "_subclass_ixSubclass",
        'propCntAsi': "class_" + ix + "_cntAsi",
        'propCurLevel': "class_" + ix + "_curLevel",
        'propTargetLevel': "class_" + ix + "_targetLevel"
      };
    }
    _shared_renderEntity_stgOtherProficiencies({
        $stg: element,
        ent: entity,
        propComp: propComp,
        propProficiencies: propProf,
        title: title,
        CompClass: CompClass,
        propPathActorExistingProficiencies: propPathActorExistingProficiencies,
        fnGetExistingFvtt: fnGetExistingFvtt,
        fnGetMappedProficiencies: fnGetMappedProficiencies
        }) {
        element.empty();
        //TEMPFIX
        //this._parent.featureSourceTracker_.unregister(this[propComp]);
        if (entity && entity[propProf]) {
            element.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">" + title + "</div>");
            const existingFvtt = fnGetExistingFvtt ? fnGetExistingFvtt(this._actor) : {
            [propProf]: MiscUtil.get(this._actor, '_source', ...propPathActorExistingProficiencies)
            };
            this[propComp] = new CompClass({
            //'featureSourceTracker': this._parent.featureSourceTracker_,
            'existing': CompClass.getExisting(existingFvtt),
            'existingFvtt': existingFvtt,
            'available': fnGetMappedProficiencies ? fnGetMappedProficiencies(entity[propProf], propProf) : entity[propProf]
            });
            this[propComp].render(element);
        }
        else {
            element.hideVe();
            this[propComp] = null;
        }
    }
    _shared_renderEntity_stgDiDrDvCi({
      $stg: _0x53e426,
      ent: _0x137c88,
      propComp: _0x528966,
      CompClass: _0x49593b,
      title: _0xf6f71d,
      propRaceData: _0xcf0cc,
      propTraits: _0x141da8
    }) {
      _0x53e426.empty();
      if (_0x137c88 && _0x137c88[_0xcf0cc]) {
        _0x53e426.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">" + _0xf6f71d + "</div>");
        const _0x44ab2c = {
          [_0xcf0cc]: MiscUtil.get(this._actor, "_source", "system", "traits", _0x141da8)
        };
        this[_0x528966] = new _0x49593b({
          'existing': _0x49593b.getExisting(_0x44ab2c),
          'existingFvtt': _0x44ab2c,
          'available': _0x137c88[_0xcf0cc]
        });
        this[_0x528966].render(_0x53e426);
      } else {
        _0x53e426.hideVe();
        this[_0x528966] = null;
      }
    }
}
class ActorCharactermancerClass extends ActorCharactermancerBaseComponent {
    _data;
    _tabClass;
    _actor;

    constructor(_0x13f182) {
      _0x13f182 = _0x13f182 || {};
      super();
      this._actor = _0x13f182.actor;
      this._data = _0x13f182.data; //data is an object containing information about all classes, subclasses, feats, etc
      this._parent = _0x13f182.parent;
      //_0x13f182 is basically the window, tabClass contains DOM elements, one for each "screen" (class, race, abiltiies, etc)
      this._tabClass = _0x13f182.tabClass;
      //TEMP not sure what this does, bloat code so im commenting it out for the moment
      this._modalFilterClasses = new ModalFilterClassesFvtt({
        'namespace': "ActorCharactermancer.classes",
        'allData': this._data["class"]
      });
      this._metaHksClassStgSubclass = [];
      this._compsClassStartingProficiencies = [];
      this._compsClassHpIncreaseMode = [];
      this._compsClassHpInfo = [];
      this._compsClassLevelSelect = [];
      this._compsClassFeatureOptionsSelect = [];
      this._compsClassSkillProficiencies = [];
      this._compsClassToolProficiencies = [];
      this._metaHksClassStgSkills = [];
      this._metaHksClassStgTools = [];
      this._metaHksClassStgStartingProficiencies = [];
      this._$wrpsClassTable = [];
      this._existingClassMetas = [];

    }
    //FINDME ActorCharactermancerClass.render
    render() {
        let wrptab = this._tabClass?.$wrpTab;
        if (!wrptab) { return; }
        let classChoiceElement = $(`<div class="ve-flex-col w-100 h-100 px-1 pt-1 overflow-y-auto ve-grow veapp__bg-foundry"></div>`);
        let sidebarElement = $(`<div class="ve-flex-col w-100 h-100 px-1 overflow-y-auto ve-grow veapp__bg-foundry"></div>`);
        for (let i = 0; i < this._state.class_ixMax + 1; ++i) {
          this._class_renderClass(classChoiceElement, sidebarElement, i);
        }
        this._addHookBase("class_ixPrimaryClass", () => this._state.class_pulseChange = !this._state.class_pulseChange);
  
        //ADD CLASS BUTTON
        const addClassBtn = $(`<button class="btn btn-5et btn-sm">Add Another Class</button>`)
        .click(() => {
          this._class_renderClass(classChoiceElement, sidebarElement, ++this._state.class_ixMax);
        });
  
  
        let o = $$`<div class="ve-flex w-100 h-100">
        <div class="ve-flex-col w-100">
            ${classChoiceElement}
            <div class="mt-2">${addClassBtn}</div>
        </div>
        <div class="vr-1"></div>
        ${sidebarElement}
        </div>`.appendTo(wrptab);
    }
    _class_renderClass(element1, element2, ix) {
        //Main properties for asking our _state for information on this class
      const {
        propPrefixClass: propPrefixClass,
        propIxClass: propIxClass,
        propPrefixSubclass: propPrefixSubclass,
        propIxSubclass: propIxSubclass,
        propCntAsi: propCntAsi,
        propCurLevel: propCurLevel,
        propTargetLevel: propTargetLevel
      } = ActorCharactermancerBaseComponent.class_getProps(ix);
      const filter_evnt_valchange_class = FilterBox.EVNT_VALCHANGE + ".class_" + ix + "_classLevels";
      const filter_evnt_valchange_subclass = FilterBox.EVNT_VALCHANGE + ".class_" + ix + "_subclass";

      const {
        lockChangeClass: lockChangeClass,
        lockChangeSubclass: lockChangeSubclass,
        lockRenderFeatureOptionsSelects: _0x3217e0
      } = this.constructor._class_getLocks(ix);

      this._addHookBase(propIxClass, () => this._state.class_pulseChange = !this._state.class_pulseChange);

      //Get some information on how this class choice would be displayed (in a dropdown)
      const {
        $wrp: wrapper, //Wrapper DOM for the dropdown menu DOM object
        $iptDisplay: inputDisplay, //a function that returns the visible name of a class that you provide the index for
        $iptSearch: inputSearch,
        fnUpdateHidden: fnUpdateHidden
      } = ComponentUiUtil.$getSelSearchable(this, propIxClass, {
        'values': this._data.class.map((_0x2b7aa2, _0x2f3ba4) => _0x2f3ba4), //Think this is just the ix's of the classes
        'isAllowNull': true,
        'fnDisplay': clsIx => {
            //Using a simple index, ask _data for the class
          const cls = this.getClass_({'ix': clsIx });
          if (!cls) {
            console.warn(...LGT, "Could not find class with index " + clsIx + " (" + this._data.class.length + " classes were available)");
            return '(Unknown)';
          }
          //Then return what should be the displayed name
          return cls.name + " " + (cls.source !== Parser.SRC_PHB ? '[' + Parser.sourceJsonToAbv(cls.source) + ']' : '');
        },
        'fnGetAdditionalStyleClasses': classIx => {
          if (classIx == null) { return null; }
          const cls = this.getClass_({'ix': classIx});
          if (!cls) { return; }
          return cls._versionBase_isVersion ? ['italic'] : null;
        },
        'asMeta': true,
        'isDisabled': this._class_isClassSelectionDisabled({'ix': ix })
      });

      inputDisplay.addClass("bl-0");
      inputSearch.addClass("bl-0");

      const updateHiddenClasses = () => {
        const filterValues = this._modalFilterClasses.pageFilter.filterBox.getValues();
        const classes = this._data.class.map(cls => !this._modalFilterClasses.pageFilter.toDisplay(filterValues, cls));
        fnUpdateHidden(classes, false);
      };

      const applySubclassFilter = () => {
        const cls = this.getClass_({'propIxClass': propIxClass});
        if (!cls || !this._metaHksClassStgSubclass[ix]) { return; }
        const filteredValues = this._modalFilterClasses.pageFilter.filterBox.getValues();
        const displayableSubclasses = cls.subclasses.map(val => !this._modalFilterClasses.pageFilter.toDisplay(filteredValues, val));
        this._metaHksClassStgSubclass[ix].fnUpdateHidden(displayableSubclasses, false);
      };

      //TEMPFIX
      if(SETTINGS.FILTERS){
        //this._modalFilterClasses.pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, () => _0x1133f2());
        //_0x1133f2();
        }
      const filterBtn = $("<button class=\"btn btn-xs btn-5et h-100 btr-0 bbr-0 pr-2\" title=\"Filter for Class and Subclass\"><span class=\"glyphicon glyphicon-filter\"></span> Filter</button>")
      .click(async () => {
        const cls = this.getClass_({
          'propIxClass': propIxClass
        });
        const subcls = this.getSubclass_({
          'cls': cls,
          'propIxSubclass': propIxSubclass
        });
        const classSelectDisabled = this._class_isClassSelectionDisabled({
          'ix': ix
        });
        const subclassSelectDisabled = this._class_isSubclassSelectionDisabled({
          'ix': ix
        });
        const userSelection = await this._modalFilterClasses.pGetUserSelection({
          'selectedClass': cls,
          'selectedSubclass': subcls,
          'isClassDisabled': classSelectDisabled,
          'isSubclassDisabled': subclassSelectDisabled
        });
        if (classSelectDisabled && subclassSelectDisabled) {
          return;
        }
        if (userSelection == null || !userSelection.class) {
          return;
        }
        const class_index = this._data.class.findIndex(_0x46996f => _0x46996f.name === userSelection.class.name && _0x46996f.source === userSelection['class'].source);
        if (!~class_index) {
          throw new Error("Could not find selected class: " + JSON.stringify(userSelection["class"]));
        }
        this._state[propIxClass] = class_index;
        await this._pGate(lockChangeClass);
        if (userSelection.subclass != null) {
          const cls = this.getClass_({
            'propIxClass': propIxClass
          });
          const subcls_index = cls.subclasses.findIndex(_0x482224 => _0x482224.name === userSelection.subclass.name && _0x482224.source === userSelection.subclass.source);
          if (!~subcls_index) {
            throw new Error("Could not find selected subclass: " + JSON.stringify(userSelection.subclass));
          }
          this._state[propIxSubclass] = subcls_index;
        } else {
          this._state[propIxSubclass] = null;
        }
      });

      const renderClass = async _0xd4d6f7 => {
        if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.off(filter_evnt_valchange_subclass);}
        //FIXME SET STATE!
        if (_0xd4d6f7) {
          const toObj = Object.keys(this.__state).filter(propName => propName.startsWith(propPrefixClass) && propName !== propIxClass).mergeMap(_0x77ce3e => ({
            [_0x77ce3e]: null
          }));
          this._proxyAssignSimple("state", toObj);
        }
        //First time this function is called, we will probably not get anything out of getClass since we haven't set anything to _state yet
        const cls = this.getClass_({'propIxClass': propIxClass});
        const subcls = this.getSubclass_({
          'cls': cls,
          'propIxSubclass': propIxSubclass
        });
        console.log("renderClass", cls);
        this._class_renderClass_stgSelectSubclass({
          '$stgSelectSubclass': holder_selectSubclass,
          'cls': cls,
          'ix': ix,
          'propIxSubclass': propIxSubclass,
          'idFilterBoxChangeSubclass': filter_evnt_valchange_subclass,
          'doApplyFilterToSelSubclass': applySubclassFilter
        });
        this._class_renderClass_stgHpMode({
          '$stgHpMode': holder_hpMode,
          'ix': ix,
          'cls': cls
        });
        this._class_renderClass_stgHpInfo({
          '$stgHpInfo': holder_hpInfo,
          'ix': ix,
          'cls': cls
        }); 
        this._class_renderClass_stgStartingProficiencies({
          '$stgStartingProficiencies': holder_startingProf,
          'ix': ix,
          'cls': cls
        });
        await this._class_renderClass_pStgLevelSelect({
          '$stgLevelSelect': holder_levelSelect,
          '$stgFeatureOptions': holder_featureOptions,
          'ix': ix,
          'cls': cls,
          'sc': subcls,
          'propIxSubclass': propIxSubclass,
          'propCurLevel': propCurLevel,
          'propTargetLevel': propTargetLevel,
          'propCntAsi': propCntAsi,
          'lockRenderFeatureOptionsSelects': _0x3217e0,
          'idFilterBoxChangeClassLevels': filter_evnt_valchange_class
        });
        this._state.class_totalLevels = this.class_getTotalLevels();
        /* this._class_renderClass_stgSkills({
          '$stgSkills': holder_skills,
          'ix': ix,
          'propIxClass': propIxClass
        }); */
        /* this._class_renderClass_stgTools({
          '$stgTools': holder_tools,
          'ix': ix,
          'propIxClass': propIxClass
        }); */
        /* await this._class_renderClass_pDispClass({
          'ix': ix,
          '$dispClass': holder_dispClass,
          'cls': cls,
          'sc': subcls
        }); */
        disp_subclass.empty();
      };

      const renderClass_safe = async _0x7a25e5 => {
        try {
          await this._pLock(lockChangeClass);
          await renderClass(_0x7a25e5);
        } finally {
          this._unlock(lockChangeClass);
        }
      };
      this._addHookBase(propIxClass, renderClass_safe);

      const renderSubclass = async () => {
        if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.off(filter_evnt_valchange_subclass);}
        const toObj = Object.keys(this.__state).filter(prop => prop.startsWith(propPrefixSubclass) && prop !== propIxSubclass).mergeMap(_0x207fe4 => ({
          [_0x207fe4]: null
        }));
        this._proxyAssignSimple("state", toObj);
        const cls = this.getClass_({
          'propIxClass': propIxClass
        });
        const subcls = this.getSubclass_({
          'cls': cls,
          'propIxSubclass': propIxSubclass
        });
        /* const filteredFeatures = this._class_getFilteredFeatures(cls, subcls);
        if (this._compsClassLevelSelect[ix]) {
          this._compsClassLevelSelect[ix].setFeatures(filteredFeatures);
        }
        await this._class_pRenderFeatureOptionsSelects({
          'ix': ix,
          'propCntAsi': propCntAsi,
          'filteredFeatures': filteredFeatures,
          '$stgFeatureOptions': holder_featureOptions,
          'lockRenderFeatureOptionsSelects': _0x3217e0
        }); */
        if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.on(filter_evnt_valchange_subclass, () => applySubclassFilter());}
        /* applySubclassFilter();
        await this._class_renderClass_pDispSubclass({
          'ix': ix,
          '$dispSubclass': disp_subclass,
          'cls': cls,
          'sc': subcls
        }); */
      };
      const renderSubclass_safe = async () => {
        try {
          await this._pLock(lockChangeSubclass);
          await renderSubclass();
        } finally {
          this._unlock(lockChangeSubclass);
        }
      };

      this._addHookBase(propIxSubclass, renderSubclass_safe);

      //Create parent objects to hold subcomponents, hide the later ones
      const header = $("<div class=\"bold\">Select a Class</div>");
      const holder_selectSubclass = $(`<div class="ve-flex-col w-100"></div>`).hideVe();
      const holder_hpMode = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_hpInfo = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_startingProf = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_levelSelect = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_featureOptions = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_skills = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_tools = $(`<div class="ve-flex-col"></div>`).hideVe();

      let primaryBtn = null;
      if (!this._existingClassMetas.length) {
        primaryBtn = $("<button class=\"btn btn-5et btn-xs mr-2\"></button>").click(() => this._state.class_ixPrimaryClass = ix);
        const primaryBtnHover = () => {
          primaryBtn.text(this._state.class_ixPrimaryClass === ix ? "Primary Class" : "Make Primary").title(this._state.class_ixPrimaryClass === ix ? "This is your primary class, i.e. the one you chose at level 1 for the purposes of proficiencies/etc." : "Make this your primary class, i.e. the one you chose at level 1 for the purposes of proficiencies/etc.").prop("disabled", this._state.class_ixPrimaryClass === ix);
        };
        this._addHookBase("class_ixPrimaryClass", primaryBtnHover);
        primaryBtnHover();
      }

      const minimizerToggle = $("<div class=\"py-1 clickable ve-muted\">[‒]</div>").click(() => {
        const isMinimized = minimizerToggle.text() === '[+]';
        minimizerToggle.text(isMinimized ? "[‒]" : "[+]");
        if (isMinimized) {
          header.text("Select a Class");
        } else {
          const cls = this.getClass_({'propIxClass': propIxClass});
          const subcls = this.getSubclass_({
            'cls': cls,
            'propIxSubclass': propIxSubclass
          });
          if (cls) { header.text('' + cls.name + (subcls ? " (" + subcls.name + ')' : ''));}
          else { header.text("Select a Class"); }
        }
        classChoicePanels.toggleVe();
      });
      
      const holder_dispClass = $(`<div class="ve-flex-col w-100"></div>`);
      const disp_subclass = $(`<div class="ve-flex-col w-100"></div>`);

      /* const classChoicePanels = $(`<div class="ve-flex-col w-100 mt-2">
              <div class="ve-flex btn-group w-100">
                  <div class="ve-flex no-shrink">
                      ${filterBtn[0].outerHTML}
                  </div>
                  <div class="ve-flex-col w-100">
                      ${wrapper[0].outerHTML}
                      ${holder_selectSubclass[0].outerHTML}
                  </div>
              </div>
              ${holder_hpMode[0].outerHTML}
              ${holder_hpInfo[0].outerHTML}
              ${holder_startingProf[0].outerHTML}
              ${holder_skills[0].outerHTML}
              ${holder_tools[0].outerHTML}
              ${holder_levelSelect[0].outerHTML}
              ${holder_featureOptions[0].outerHTML}
          </div>`); */
          const classChoicePanels = $$`<div class="ve-flex-col w-100 mt-2">
              <div class="ve-flex btn-group w-100">
                  <div class="ve-flex no-shrink">
                      ${filterBtn}
                  </div>
                  <div class="ve-flex-col w-100">
                        ${wrapper}
                        ${holder_selectSubclass}
                  </div>
              </div>
              ${holder_hpMode}
              ${holder_hpInfo}
              ${holder_startingProf}
              ${holder_levelSelect}
          </div>`;

      /* const classChoicePanelsWrapper = $(`<div class="ve-flex-col">
          ${ix>0? `<hr class=\"hr-3 hr--heavy\">`:''}

          <div class="split-v-center">
              ${header}
              <div class="ve-flex-v-center">
                  ${primaryBtn}
                  ${minimizerToggle}
              </div>
          </div>

          ${classChoicePanels}
      </div>`); */
      const classChoicePanelsWrapper = $$`<div class="ve-flex-col">
        ${ix>0? `<hr class=\"hr-3 hr--heavy\">`:''}
        <div class="split-v-center">
            ${header}
            <div class="ve-flex-v-center">
                ${primaryBtn}
                ${minimizerToggle}
            </div>
        </div>

        ${classChoicePanels}
      </div>`;
      classChoicePanelsWrapper.appendTo(element1);

      //Sidebar display (class text info)
      const sidebarContent=$(`<div>
          ${ix>0?'<hr\x20class=\x22hr-2\x20hr--heavy\x22>':''}

          ${holder_dispClass}
          ${disp_subclass}
      </div>`).appendTo(element2);

      renderClass_safe().then(() => renderSubclass_safe());
    }

    get modalFilterClasses() {
      return this._modalFilterClasses;
    }
    get compsClassStartingProficiencies() {
      return this._compsClassStartingProficiencies;
    }
    get compsClassHpIncreaseMode() {
      return this._compsClassHpIncreaseMode;
    }
    get compsClassLevelSelect() {
      return this._compsClassLevelSelect;
    }
    get compsClassFeatureOptionsSelect() {
      return this._compsClassFeatureOptionsSelect;
    }
    get compsClassSkillProficiencies() {
      return this._compsClassSkillProficiencies;
    }
    get compsClassToolProficiencies() {
      return this._compsClassToolProficiencies;
    }
    get existingClassMetas() {
      return this._existingClassMetas;
    }
    async pLoad() {
      await this._modalFilterClasses.pPreloadHidden();
      await this._pLoad_pDoHandleExistingClassItems();
    }
    async _pLoad_pDoHandleExistingClassItems() {
      const _0x1c249f = this._actor.items.filter(_0x5de464 => _0x5de464.type === 'class');
      const _0x3dab8a = this._actor.items.filter(_0x248afa => _0x248afa.type === 'subclass');
      this._existingClassMetas = _0x1c249f.map(_0x122387 => {
        const _0x39760a = this._pLoad_getExistingClassIndex(_0x122387);
        const _0x56b925 = _0x3dab8a.find(_0x162fde => _0x162fde.system.classIdentifier === _0x122387.system.identifier);
        let _0xa0d172 = this._pLoad_getExistingSubclassIndex(_0x39760a, _0x56b925);
        const _0x5372b3 = this._actor.system?.details?.['originalClass'] ? this._actor.system?.details?.originalClass === _0x122387.id : !!_0x122387.flags?.[SharedConsts.MODULE_ID]?.['isPrimaryClass'];
        const _0x55c437 = ~_0x39760a ? null : "Could not find class \"" + _0x122387.name + "\" (\"" + UtilDocumentSource.getDocumentSourceDisplayString(_0x122387) + "\") in loaded data. " + Charactermancer_Util.STR_WARN_SOURCE_SELECTION;
        if (_0x55c437) {
          ui.notifications.warn(_0x55c437);
          console.warn(...LGT, _0x55c437, "Strict source matching is: " + Config.get("import", "isStrictMatching") + '.');
        }
        const _0x530b46 = _0x56b925 == null || ~_0xa0d172 ? null : "Could not find subclass \"" + _0x56b925.name + "\" in loaded data. " + Charactermancer_Util.STR_WARN_SOURCE_SELECTION;
        if (_0x530b46) {
          ui.notifications.warn(_0x530b46);
          console.warn(...LGT, _0x530b46, "Strict source matching is: " + Config.get("import", "isStrictMatching") + '.');
        }
        return new ActorCharactermancerClass.ExistingClassMeta({
          'item': _0x122387,
          'ixClass': _0x39760a,
          'isUnknownClass': !~_0x39760a,
          'ixSubclass': _0xa0d172,
          'isUnknownSubclass': _0xa0d172 == null && !~_0xa0d172,
          'level': Number(_0x122387.system.levels || 0x0),
          'isPrimary': _0x5372b3,
          'spellSlotLevelSelection': _0x122387?.flags?.[SharedConsts.MODULE_ID]?.['spellSlotLevelSelection']
        });
      });
      if (!this._existingClassMetas.length) {
        return;
      }
      this._state.class_ixMax = this._existingClassMetas.length - 0x1;
      for (let _0xfaa7c6 = 0x0; _0xfaa7c6 < this._existingClassMetas.length; ++_0xfaa7c6) {
        const _0x325547 = this._existingClassMetas[_0xfaa7c6];
        const {
          propIxClass: _0x57fec3,
          propIxSubclass: _0x4335dc
        } = ActorCharactermancerBaseComponent.class_getProps(_0xfaa7c6);
        await this._pDoProxySetBase(_0x57fec3, _0x325547.ixClass);
        await this._pDoProxySetBase(_0x4335dc, _0x325547.ixSubclass);
        if (_0x325547.isPrimary) {
          this._state.class_ixPrimaryClass = _0xfaa7c6;
        }
      }
      if (!this._existingClassMetas.some(_0x34ec7d => _0x34ec7d.isPrimary)) {
        this._state.class_ixPrimaryClass = 0x0;
      }
    }
    _pLoad_getExistingClassIndex(_0x31ccce) {
      const _0x9c6a99 = _0x31ccce.flags?.[SharedConsts.MODULE_ID];
      if (_0x9c6a99?.propDroppable === 'class' && _0x9c6a99?.source && _0x9c6a99?.hash) {
        const _0x4fb2d3 = this._data["class"].findIndex(_0xc280a8 => _0x9c6a99.source === _0xc280a8.source && _0x9c6a99.hash === UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](_0xc280a8));
        if (~_0x4fb2d3) {
          return _0x4fb2d3;
        }
      }
      const _0x22658f = (IntegrationBabele.getOriginalName(_0x31ccce) || '').toLowerCase().trim();
      const _0xf5d9aa = this._data['class'].findIndex(_0x5112df => {
        return _0x22658f === _0x5112df.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(_0x31ccce).source || '').toLowerCase() === Parser.sourceJsonToAbv(_0x5112df.source).toLowerCase());
      });
      if (~_0xf5d9aa) {
        return _0xf5d9aa;
      }
      const _0x4d5c9d = /^(.*?)\(.*\)$/.exec(_0x22658f);
      if (!_0x4d5c9d) {
        return -0x1;
      }
      return this._data["class"].findIndex(_0x12f0b7 => {
        return _0x4d5c9d[0x1].trim() === _0x12f0b7.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(_0x31ccce).source || '').toLowerCase() === Parser.sourceJsonToAbv(_0x12f0b7.source).toLowerCase());
      });
    }
    _pLoad_getExistingSubclassIndex(_0x161fa4, _0x3e14d4) {
      if (!_0x3e14d4 || !~_0x161fa4) {
        return null;
      }
      const _0x10558f = this._data['class'][_0x161fa4];
      const _0x50af12 = _0x3e14d4.flags?.[SharedConsts.MODULE_ID];
      if (_0x50af12?.["propDroppable"] === "subclass" && _0x50af12?.["source"] && _0x50af12?.["hash"]) {
        const _0x37d579 = _0x10558f.subclasses.findIndex(_0x5067b7 => _0x50af12.source === _0x5067b7.source && _0x50af12.hash === UrlUtil.URL_TO_HASH_BUILDER.subclass(_0x5067b7));
        if (~_0x37d579) {
          return _0x37d579;
        }
      }
      return _0x10558f.subclasses.findIndex(_0x54c0e7 => (IntegrationBabele.getOriginalName(_0x3e14d4) || '').toLowerCase().trim() === _0x54c0e7.name.toLowerCase().trim() && (!Config.get("import", 'isStrictMatching') || (UtilDocumentSource.getDocumentSource(_0x3e14d4).source || '').toLowerCase() === Parser.sourceJsonToAbv(_0x54c0e7.source).toLowerCase()));
    }
    getExistingClassTotalLevels_() {
      return this._existingClassMetas.filter(Boolean).map(_0x29ccbb => _0x29ccbb.level).sum();
    }
    _getExistingClassCount() {
      return this._existingClassMetas.filter(Boolean).length;
    }
    getClass_({ix: ix, propIxClass: propIxClass}) {
        //console.log("_getClass", ix, propIxClass, this._data);
      if (ix == null && propIxClass == null) { throw new Error("At least one argument must be provided!"); }
      //If a propIxClass was provived, try to get the class from this._state
      if (propIxClass != null) {
        if (this._state[propIxClass] == null) { return null;  }
        if (!~this._state[propIxClass]) { return DataConverterClass.getClassStub(); }
        return this._data.class[this._state[propIxClass]];
      }
      //Otherwise, try to get it from this._data, if we have an ix
      if (ix != null && ~ix) { return this._data.class[ix];}
      return DataConverterClass.getClassStub();
    }
    getSubclass_({
      cls: _0x5c8967,
      propIxSubclass: _0x3ff653,
      ix: _0x325aa4
    }) {
      if (_0x325aa4 == null && _0x3ff653 == null) {
        throw new Error("At least one argument must be provided!");
      }
      if (!_0x5c8967) {
        return null;
      }
      if (_0x3ff653 != null) {
        if (this._state[_0x3ff653] == null) {
          return null;
        }
        if (!~this._state[_0x3ff653]) {
          return DataConverterClass.getSubclassStub({
            'cls': _0x5c8967
          });
        }
        if (!_0x5c8967.subclasses?.["length"]) {
          return DataConverterClass.getSubclassStub({
            'cls': _0x5c8967
          });
        }
        return _0x5c8967.subclasses[this._state[_0x3ff653]];
      }
      if (_0x325aa4 != null && ~_0x325aa4) {
        return _0x5c8967.subclasses[_0x325aa4];
      }
      return DataConverterClass.getSubclassStub({
        'cls': _0x5c8967
      });
    }
    _class_isClassSelectionDisabled({
      ix: _0x5bbf32
    }) {
      return !!this._existingClassMetas[_0x5bbf32];
    }
    _class_isSubclassSelectionDisabled({
      ix: _0x3ccf09
    }) {
      return this._existingClassMetas[_0x3ccf09] && (this._existingClassMetas[_0x3ccf09].ixSubclass != null || this._existingClassMetas[_0x3ccf09].isUnknownClass);
    }
    
    static _class_getLocks(ix) {
      return {
        'lockChangeClass': 'class_' + ix + '_pHkChangeClass',
        'lockChangeSubclass': "class_" + ix + '_pHkChangeSubclass',
        'lockRenderFeatureOptionsSelects': 'class_' + ix + "_renderFeatureOptionsSelects"
      };
    }
    
    
    _class_renderClass_stgSelectSubclass({
      $stgSelectSubclass: stgSelectSubclass,
      cls: cls,
      ix: ix,
      propIxSubclass: propIxSubclass,
      idFilterBoxChangeSubclass: idFilterBoxChangeSubclass,
      doApplyFilterToSelSubclass: doApplyFilterToSelSubclass
    }) {
      stgSelectSubclass.empty();
      if (this._metaHksClassStgSubclass[ix]) { this._metaHksClassStgSubclass[ix].unhook(); }
      if(cls == null){console.error("Class is null");}
      if (cls && cls.subclasses && cls.subclasses.length) {
        const uiSearchElement = ComponentUiUtil.$getSelSearchable(this, propIxSubclass, {
          'values': cls.subclasses.map((a, b) => b),
          'isAllowNull': true,
          'fnDisplay': ix => {
            const subcls = this.getSubclass_({'cls': cls, 'ix': ix });
            if (!subcls) {
              console.warn(...LGT, "Could not find subclass with index " + ix + " (" + cls.subclasses.length + " subclasses were available for class " + cls.name + ')');
              return '(Unknown)';
            }
            return subcls.name + " " + (subcls.source !== Parser.SRC_PHB ? '[' + Parser.sourceJsonToAbv(subcls.source) + ']' : '');
          },
          'fnGetAdditionalStyleClasses': ix => {
            if (ix == null) { return null; }
            const subcls = this.getSubclass_({'cls': cls, 'ix': ix });
            if (!subcls) { return; }
            return subcls._versionBase_isVersion ? ['italic'] : null;
          },
          'asMeta': true,
          'isDisabled': this._class_isSubclassSelectionDisabled({'ix': ix}),
          'displayNullAs': "Select a Subclass"
        });
        uiSearchElement.$iptDisplay.addClass('bl-0');
        uiSearchElement.$iptSearch.addClass("bl-0");
        this._metaHksClassStgSubclass[ix] = uiSearchElement;
        this._modalFilterClasses.pageFilter.filterBox.on(idFilterBoxChangeSubclass, () => doApplyFilterToSelSubclass());
        doApplyFilterToSelSubclass();
        const wrp = $$`<div class="ve-flex-col w-100 mt-1">${uiSearchElement.$wrp}</div>`;
        stgSelectSubclass.showVe().append(wrp);
      }
      else {
        console.error("No subclasses found");
        console.log(cls);
        stgSelectSubclass.hideVe();
        this._metaHksClassStgSubclass[ix] = null;
      }
    }
    _class_renderClass_stgHpMode({
      $stgHpMode: parentElement,
      ix: ix,
      cls: cls
    }) {
      parentElement.empty();
      if (cls && Charactermancer_Class_HpIncreaseModeSelect.isHpAvailable(cls)) {
        parentElement.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Hit Points Increase Mode</div>");
        this._compsClassHpIncreaseMode[ix] = new Charactermancer_Class_HpIncreaseModeSelect();
        this._compsClassHpIncreaseMode[ix].render(parentElement);
      }
      else {
        parentElement.hideVe();
        this._compsClassHpIncreaseMode[ix] = null;
      }
    }
    _class_renderClass_stgHpInfo({
      $stgHpInfo: parentElement,
      ix: ix,
      cls: cls
    }) {
      parentElement.empty();
      if (cls && Charactermancer_Class_HpIncreaseModeSelect.isHpAvailable(cls)) {
        parentElement.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Hit Points</div>");
        this._compsClassHpInfo[ix] = new Charactermancer_Class_HpInfo({
          'className': cls.name,
          'hitDice': cls.hd
        });
        this._compsClassHpInfo[ix].render(parentElement);
      }
      else {
        parentElement.hideVe();
        this._compsClassHpInfo[ix] = null;
      }
    }
    _class_renderClass_stgStartingProficiencies({
        $stgStartingProficiencies: element, ix: ix, cls: cls}) {

        const existingClassMeta = SETTINGS.USE_EXISTING? this._class_getExistingClassMeta(ix) : null;
        if (existingClassMeta) {return;}
        if (this._metaHksClassStgStartingProficiencies[ix]) {
            this._metaHksClassStgStartingProficiencies[ix].unhook();
        }
        element.empty();

        //Our parent should be an ActorCharactermancer
        if(!SETTINGS.PARENTLESS_MODE){this._parent.featureSourceTracker_.unregister(this._compsClassStartingProficiencies[ix]);}
        if (cls && (cls.startingProficiencies || cls.multiclassing?.["proficienciesGained"])) {
            element.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Proficiencies</div>");
            this._compsClassStartingProficiencies[ix] = Charactermancer_Class_StartingProficiencies.get({
                //TEMPFIX //'featureSourceTracker': this._parent.featureSourceTracker_,
                'primaryProficiencies': cls.startingProficiencies,
                'multiclassProficiencies': cls.multiclassing?.["proficienciesGained"],
                'savingThrowsProficiencies': cls.proficiency,
                'existingProficienciesFvttArmor': MiscUtil.get(this._actor, "_source", "system", "traits", "armorProf"),
                'existingProficienciesFvttWeapons': MiscUtil.get(this._actor, '_source', "system", "traits", "weaponProf"),
                'existingProficienciesFvttSavingThrows': Charactermancer_Class_StartingProficiencies.getExistingProficienciesFvttSavingThrows(this._actor)
            });
            this._compsClassStartingProficiencies[ix].render(element);
        }
        else {
            element.hideVe();
            this._compsClassStartingProficiencies[ix] = null;
        }

        const setProfMode = () => {
            if (this._compsClassStartingProficiencies[ix]) {
            this._compsClassStartingProficiencies[ix].mode =
            this._state.class_ixPrimaryClass === ix ? Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY
            : Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS;
            }
        };

        this._addHookBase("class_ixPrimaryClass", setProfMode);
        this._metaHksClassStgStartingProficiencies[ix] = {
            'unhook': () => this._removeHookBase("class_ixPrimaryClass", setProfMode)
        };

        setProfMode();
    }
    _class_getExistingClassMeta(classIx) {
      if (this._existingClassMetas[classIx]) {return this._existingClassMetas[classIx];}

      const {propIxClass: propIxClass } = ActorCharactermancerBaseComponent.class_getProps(classIx);

      const cls = this.getClass_({'propIxClass': propIxClass });

      const classItems = Charactermancer_Class_Util.getExistingClassItems(this._actor, cls);
      const firstItem = classItems.length ? classItems[0] : null;
      if (!firstItem) { return null; }
      return {'item': firstItem, 'level': Number(firstItem.system.levels || 0)};
    }
    async _class_renderClass_pStgLevelSelect({
        $stgLevelSelect: ele_levelSelect,
        $stgFeatureOptions: ele_featureOptions,
        ix: ix,
        cls: cls,
        sc: sc,
        propIxSubclass: propIxSubclass,
        propCurLevel: propCurLevel,
        propTargetLevel: propTargetLevel,
        propCntAsi: propCntAsi,
        lockRenderFeatureOptionsSelects: lockRenderFeatureOptionsSelects,
        idFilterBoxChangeClassLevels: idFilterBoxChangeClassLevels
    }) {
        ele_levelSelect.empty();
        if (cls) {
            ele_levelSelect.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Select Levels</div>");
            const filteredFeatures = this._class_getFilteredFeatures(cls, sc);
            const existingClassMeta = this._class_getExistingClassMeta(ix);
            this._compsClassLevelSelect[ix] = new Charactermancer_Class_LevelSelect({
                'features': filteredFeatures,
                'isRadio': true,
                'isForceSelect': this.getExistingClassTotalLevels_() === 0 || !existingClassMeta,
                'maxPreviousLevel': existingClassMeta?.["level"],
                'isSubclass': true
            });
            this._compsClassLevelSelect[ix].render(ele_levelSelect);

            const e_onChange = async () => {
                const subclass = this.getSubclass_({'cls': cls, 'propIxSubclass': propIxSubclass});
                const _features = this._class_getFilteredFeatures(cls, subclass);
                await this._class_pRenderFeatureOptionsSelects({
                    'ix': ix,
                    'propCntAsi': propCntAsi,
                    'filteredFeatures': _features,
                    '$stgFeatureOptions': ele_featureOptions,
                    'lockRenderFeatureOptionsSelects': lockRenderFeatureOptionsSelects
                });
                this._state[propCurLevel] = this._compsClassLevelSelect[ix].getCurLevel();
                this._state[propTargetLevel] = this._compsClassLevelSelect[ix].getTargetLevel();
                this._state.class_totalLevels = this.class_getTotalLevels();
            };

            this._compsClassLevelSelect[ix].onchange(e_onChange);
            await e_onChange();

            this._modalFilterClasses.pageFilter.filterBox.on(idFilterBoxChangeClassLevels, () => {
            if (!this._compsClassLevelSelect[ix]) {
                return;
            }
            const _0x5bc252 = this.getSubclass_({
                'cls': cls,
                'propIxSubclass': propIxSubclass
            });
            const _0x10299e = this._class_getFilteredFeatures(cls, _0x5bc252);
            if (this._compsClassLevelSelect[ix]) {
                this._compsClassLevelSelect[ix].setFeatures(_0x10299e);
            }
            this._class_pRenderFeatureOptionsSelects({
                'ix': ix,
                'propCntAsi': propCntAsi,
                'filteredFeatures': _0x10299e,
                '$stgFeatureOptions': ele_featureOptions,
                'lockRenderFeatureOptionsSelects': lockRenderFeatureOptionsSelects
            });
            });
        }
        else {
            ele_levelSelect.hideVe();
            this._compsClassLevelSelect[ix] = null;
            ele_featureOptions.empty().hideVe();
            this._class_unregisterFeatureSourceTrackingFeatureComps(ix);
            this._state[propCntAsi] = null;
            if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.off(idFilterBoxChangeClassLevels);}
        }
    }
    /* _class_renderClass_stgSkills({
      $stgSkills: _0x18fe7d,
      ix: _0x138ef0,
      propIxClass: _0x2f063c
    }) {
      this._class_renderClass_stgSkillsTools({
        '$stg': _0x18fe7d,
        'ix': _0x138ef0,
        'propIxClass': _0x2f063c,
        'propMetaHks': "_metaHksClassStgSkills",
        'propCompsClass': '_compsClassSkillProficiencies',
        'propSystem': 'skills',
        'fnGetProfs': ({
          cls: _0x1dbeaa,
          isPrimaryClass: _0x155251
        }) => {
          if (!_0x1dbeaa) {
            return null;
          }
          return _0x155251 ? _0x1dbeaa.startingProficiencies?.["skills"] : _0x1dbeaa.multiclassing?.['proficienciesGained']?.["skills"];
        },
        'headerText': "Skill Proficiencies",
        'fnGetMapped': Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect)
      });
    }
    _class_renderClass_stgTools({
      $stgTools: _0x32cea1,
      ix: _0x40352a,
      propIxClass: _0x1e9a92
    }) {
      this._class_renderClass_stgSkillsTools({
        '$stg': _0x32cea1,
        'ix': _0x40352a,
        'propIxClass': _0x1e9a92,
        'propMetaHks': "_metaHksClassStgTools",
        'propCompsClass': '_compsClassToolProficiencies',
        'propSystem': "tools",
        'fnGetProfs': ({
          cls: _0x5ed998,
          isPrimaryClass: _0x1be964
        }) => {
          if (!_0x5ed998) {
            return null;
          }
          return _0x1be964 ? Charactermancer_Class_Util.getToolProficiencyData(_0x5ed998.startingProficiencies) : Charactermancer_Class_Util.getToolProficiencyData(_0x5ed998.multiclassing?.['proficienciesGained']);
        },
        'headerText': "Tool Proficiencies",
        'fnGetMapped': Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect)
      });
    } */
    _class_renderClass_stgSkillsTools({
      $stg: _0x469daf,
      ix: _0x3fe1d8,
      propIxClass: _0x15d389,
      propMetaHks: _0x343f18,
      propCompsClass: _0x122a08,
      propSystem: _0x4a9a60,
      fnGetProfs: _0x39bdbe,
      headerText: _0x17d1c9,
      fnGetMapped: _0x2664f3
    }) {
      const _0x1d6f33 = this._class_getExistingClassMeta(_0x3fe1d8);
      if (_0x1d6f33) {
        return;
      }
      if (this[_0x343f18][_0x3fe1d8]) {
        this[_0x343f18][_0x3fe1d8].unhook();
      }
      const _0x3f3f87 = () => {
        _0x469daf.empty();
        const _0x456745 = this.getClass_({
          'propIxClass': _0x15d389
        });
        const _0x405d40 = this._state.class_ixPrimaryClass === _0x3fe1d8;
        this._parent.featureSourceTracker_.unregister(this[_0x122a08][_0x3fe1d8]);
        const _0x52873c = _0x39bdbe({
          'cls': _0x456745,
          'isPrimaryClass': _0x405d40
        });
        if (_0x456745 && _0x52873c) {
          _0x469daf.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">" + _0x17d1c9 + "</div>");
          const _0x16d7ec = {
            'skillProficiencies': MiscUtil.get(this._actor, "_source", "system", _0x4a9a60)
          };
          this[_0x122a08][_0x3fe1d8] = new Charactermancer_OtherProficiencySelect({
            'featureSourceTracker': this._parent.featureSourceTracker_,
            'existing': Charactermancer_OtherProficiencySelect.getExisting(_0x16d7ec),
            'existingFvtt': _0x16d7ec,
            'available': _0x2664f3(_0x52873c)
          });
          this[_0x122a08][_0x3fe1d8].render(_0x469daf);
        } else {
          _0x469daf.hideVe();
          this[_0x122a08][_0x3fe1d8] = null;
        }
      };
      this._addHookBase("class_ixPrimaryClass", _0x3f3f87);
      this[_0x343f18][_0x3fe1d8] = {
        'unhook': () => this._removeHookBase("class_ixPrimaryClass", _0x3f3f87)
      };
      _0x3f3f87();
    }
    async _class_renderClass_pDispClass({
      ix: _0x3c9e06,
      $dispClass: _0x1bf26,
      cls: _0x50e1af,
      sc: _0x1f1733
    }) {
      if (this._$wrpsClassTable[_0x3c9e06]) {
        this._$wrpsClassTable[_0x3c9e06].detach();
      } else {
        this._$wrpsClassTable[_0x3c9e06] = $("<div class=\"ve-flex-col w-100\"></div>");
      }
      _0x1bf26.empty();
      if (_0x50e1af) {
        const _0x184e57 = _0x50e1af._isStub ? _0x50e1af : await DataLoader.pCacheAndGet("class", _0x50e1af.source, UrlUtil.URL_TO_HASH_BUILDER["class"](_0x50e1af));
        let _0x5c41fe = MiscUtil.copy(_0x184e57.classFeatures || []).flat();
        _0x5c41fe = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x5c41fe, this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
        const _0x50ec18 = {
          'type': "section",
          'entries': _0x5c41fe
        };
        this._class_renderEntriesSection(_0x1bf26, _0x50e1af.name, _0x50ec18, {
          '$wrpTable': this._$wrpsClassTable[_0x3c9e06]
        });
        await this._class_renderClass_pClassTable({
          'ix': _0x3c9e06,
          'cls': _0x50e1af,
          'sc': _0x1f1733
        });
      }
    }
    async _class_renderClass_pDispSubclass({
      ix: _0xd8d788,
      $dispSubclass: _0x189ba0,
      cls: _0x3f21f6,
      sc: _0x5dd639
    }) {
      _0x189ba0.empty();
      if (_0x5dd639) {
        _0x189ba0.append("<hr class=\"hr-1\">");
        const _0x19c6a9 = _0x5dd639._isStub ? _0x5dd639 : await DataLoader.pCacheAndGet("subclass", _0x5dd639.source, UrlUtil.URL_TO_HASH_BUILDER.subclass(_0x5dd639));
        let _0x4cd88b = MiscUtil.copy(_0x19c6a9.subclassFeatures).flat();
        _0x4cd88b = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x4cd88b, this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
        const _0x92cb5c = {
          'type': "section",
          'entries': _0x4cd88b
        };
        if (_0x92cb5c.entries[0x0] && _0x92cb5c.entries[0x0].name) {
          delete _0x92cb5c.entries[0x0].name;
        }
        this._class_renderEntriesSection(_0x189ba0, _0x5dd639.name, _0x92cb5c);
      }
      await this._class_renderClass_pClassTable({
        'ix': _0xd8d788,
        'cls': _0x3f21f6,
        'sc': _0x5dd639
      });
    }
    async _class_renderClass_pClassTable({
      ix: _0x29a0a3,
      cls: _0xed637d,
      sc: _0x386619
    }) {
      const _0x57a945 = _0xed637d ? _0xed637d._isStub ? _0xed637d : await DataLoader.pCacheAndGet('class', _0xed637d.source, UrlUtil.URL_TO_HASH_BUILDER["class"](_0xed637d)) : null;
      const _0x4d6b47 = _0x386619 ? _0x386619._isStub ? _0x386619 : await DataLoader.pCacheAndGet("subclass", _0x386619.source, UrlUtil.URL_TO_HASH_BUILDER.subclass(_0x386619)) : null;
      const _0x2da178 = _0x57a945?.["classFeatures"] || _0x4d6b47?.["subclassFeatures"] ? this._modalFilterClasses.pageFilter.filterBox.getValues() : null;
      if (_0x57a945?.["classFeatures"]) {
        _0x57a945.classFeatures = _0x57a945.classFeatures.map(_0x2106c1 => {
          _0x2106c1 = MiscUtil.copy(_0x2106c1);
          _0x2106c1 = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x2106c1, this._modalFilterClasses.pageFilter, _0x2da178);
          return _0x2106c1;
        });
      }
      if (_0x4d6b47?.["subclassFeatures"]) {
        _0x4d6b47.subclassFeatures = _0x4d6b47.subclassFeatures.map(_0x3cb3f1 => {
          _0x3cb3f1 = MiscUtil.copy(_0x3cb3f1);
          _0x3cb3f1 = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x3cb3f1, this._modalFilterClasses.pageFilter, _0x2da178);
          return _0x3cb3f1;
        });
      }
      const _0x5e497c = DataConverterClass.getRenderedClassTableFromDereferenced(_0x57a945, _0x4d6b47);
      this._$wrpsClassTable[_0x29a0a3].html('').fastSetHtml(_0x5e497c);
    }
    _class_getFilteredFeatures(cls, sc) {
        if (!cls) {return [];}
        cls = MiscUtil.copy(cls);
        cls.subclasses = [sc].filter(Boolean);
        
        return Charactermancer_Util.getFilteredFeatures(Charactermancer_Class_Util.getAllFeatures(cls),
        this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
    }
    async _class_pRenderFeatureOptionsSelects(_0xd3c29b) {
      const {
        lockRenderFeatureOptionsSelects: _0x105085
      } = _0xd3c29b;
      try {
        await this._pLock(_0x105085);
        return this._class_pRenderFeatureOptionsSelects_(_0xd3c29b);
      } finally {
        this._unlock(_0x105085);
      }
    }
    async _class_pRenderFeatureOptionsSelects_({
      ix: ix,
      propCntAsi: propCntAsi,
      filteredFeatures: filteredFeatures,
      $stgFeatureOptions: stgFeatureOptions
    }) {
      const selElement = this._compsClassFeatureOptionsSelect[ix] || [];
      selElement.forEach(e => this._parent.featureSourceTracker_.unregister(e));
      stgFeatureOptions.empty();
      const existingFeatureChecker = this._existingClassMetas[ix] ? new Charactermancer_Class_Util.ExistingFeatureChecker(this._actor) : null;
      const importableFeatures = Charactermancer_Util.getImportableFeatures(filteredFeatures);
      const features = MiscUtil.copy(importableFeatures);
      Charactermancer_Util.doApplyFilterToFeatureEntries_bySource(features, this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
      const groupedByOptionsSet = Charactermancer_Util.getFeaturesGroupedByOptionsSet(features);
      const {
        lvlMin: lvlMin,
        lvlMax: lvlMax
      } = await this._class_pGetMinMaxLevel(ix);
      this._class_unregisterFeatureSourceTrackingFeatureComps(ix);
      let asiCount = 0;
      for (const grpA of groupedByOptionsSet) {
        const {
          topLevelFeature: topLevelFeature,
          optionsSets: optionsSets
        } = _0x54d088;
        if (topLevelFeature.level < lvlMin || topLevelFeature.level > lvlMax) {
          continue;
        }
        const featureName = topLevelFeature.name.toLowerCase();
        if (featureName === "ability score improvement") {
          asiCount++;
          continue;
        }
        for (const set of optionsSets) {
          const component = new Charactermancer_FeatureOptionsSelect({
            'featureSourceTracker': this._parent.featureSourceTracker_,
            'existingFeatureChecker': existingFeatureChecker,
            'actor': this._actor,
            'optionsSet': set,
            'level': topLevelFeature.level,
            'modalFilterSpells': this._parent.compSpell.modalFilterSpells
          });
          this._compsClassFeatureOptionsSelect[ix].push(component);
          component.findAndCopyStateFrom(selElement);
        }
      }
      this._state[propCntAsi] = asiCount;
      await this._class_pRenderFeatureComps(ix, {
        '$stgFeatureOptions': stgFeatureOptions
      });
    }
    ["_class_unregisterFeatureSourceTrackingFeatureComps"](_0x3f9ba9) {
      (this._compsClassFeatureOptionsSelect[_0x3f9ba9] || []).forEach(_0x2edadc => _0x2edadc.unregisterFeatureSourceTracking());
      this._compsClassFeatureOptionsSelect[_0x3f9ba9] = [];
    }
    async ["_class_pGetMinMaxLevel"](_0x356dbb) {
      let _0x3d959d = 0x0;
      let _0x1005e8 = 0x0;
      if (this._compsClassLevelSelect[_0x356dbb]) {
        const _0xbda027 = await this._compsClassLevelSelect[_0x356dbb].pGetFormData().data;
        _0x3d959d = Math.min(..._0xbda027) + 0x1;
        _0x1005e8 = Math.max(..._0xbda027) + 0x1;
      }
      return {
        'lvlMin': _0x3d959d,
        'lvlMax': _0x1005e8
      };
    }
    async ["_class_pRenderFeatureComps"](_0x3f9795, {
      $stgFeatureOptions: _0x3179cf
    }) {
      for (const _0x5b3543 of this._compsClassFeatureOptionsSelect[_0x3f9795]) {
        if ((await _0x5b3543.pIsNoChoice()) && !(await _0x5b3543.pIsAvailable())) {
          continue;
        }
        if (!(await _0x5b3543.pIsNoChoice()) || (await _0x5b3543.pIsForceDisplay())) {
          _0x3179cf.showVe().append('' + (_0x5b3543.modalTitle ? "<hr class=\"hr-2\"><div class=\"mb-2 bold w-100\">" + _0x5b3543.modalTitle + "</div>" : ''));
        }
        _0x5b3543.render(_0x3179cf);
      }
    }
    ["_class_renderEntriesSection"](_0x3413d5, _0x582d2d, _0x1aea64, {
      $wrpTable = null
    } = {}) {
      const _0x4c8fa0 = $("<div class=\"py-1 pl-2 clickable ve-muted\">[‒]</div>").click(() => {
        _0x4c8fa0.text(_0x4c8fa0.text() === '[+]' ? '[‒]' : "[+]");
        if ($wrpTable) {
          $wrpTable.toggleVe();
        }
        _0x3fe7d2.toggleVe();
      });
      const _0x3fe7d2 = Renderer.hover.$getHoverContent_generic(_0x1aea64);
      $`<div class="ve-flex-col">
              <div class="split-v-center">
                  <div class="rd__h rd__h--0"><div class="entry-title-inner">${(_0x582d2d || '').qq()}</div></div>
                  ${_0x4c8fa0}
              </div>
              ${$wrpTable}
              ${_0x3fe7d2}
          </div>`.appendTo(_0x3413d5);
    }
    ['class_getPrimaryClass']() {
      if (!~this._state.class_ixPrimaryClass) {
        return null;
      }
      const {
        propIxClass: _0x42dfba
      } = ActorCharactermancerBaseComponent.class_getProps(this._state.class_ixPrimaryClass);
      return this._data["class"][this._state[_0x42dfba]];
    }
    ["class_getTotalLevels"]() {
      return this._compsClassLevelSelect.filter(Boolean).map(_0x169930 => _0x169930.getTargetLevel() || _0x169930.getCurLevel()).reduce((_0x130249, _0x125134) => _0x130249 + _0x125134, 0x0);
    }
    ["class_getMinMaxSpellLevel"]() {
      const _0x35ebcb = [];
      const _0x5ba174 = [];
      let _0x8a1dd5 = false;
      for (let _0xa4aa35 = 0x0; _0xa4aa35 < this._state.class_ixMax + 0x1; ++_0xa4aa35) {
        const {
          propIxClass: _0x27f359,
          propIxSubclass: _0x215bda,
          propCurLevel: _0x496498,
          propTargetLevel: _0x4c7a29
        } = ActorCharactermancerBaseComponent.class_getProps(_0xa4aa35);
        const _0x2bea38 = this.getClass_({
          'propIxClass': _0x27f359
        });
        if (!_0x2bea38) {
          continue;
        }
        const _0x6aec7a = this.getSubclass_({
          'cls': _0x2bea38,
          'propIxSubclass': _0x215bda
        });
        const _0x19e990 = this._state[_0x496498];
        const _0x275d07 = this._state[_0x4c7a29];
        const _0x547cd0 = DataConverter.getMaxCasterProgression(_0x2bea38.casterProgression, _0x6aec7a?.["casterProgression"]);
        const _0x52dd93 = Charactermancer_Spell_Util.getCasterProgressionMeta({
          'casterProgression': _0x547cd0,
          'curLevel': _0x19e990,
          'targetLevel': _0x275d07,
          'isBreakpointsOnly': true
        })?.["spellLevelLow"];
        if (_0x52dd93 != null) {
          _0x35ebcb.push(_0x52dd93);
        }
        const _0x38d005 = Charactermancer_Spell_Util.getCasterProgressionMeta({
          'casterProgression': _0x547cd0,
          'curLevel': _0x19e990,
          'targetLevel': _0x275d07,
          'isBreakpointsOnly': true
        })?.["spellLevelHigh"];
        if (_0x38d005 != null) {
          _0x5ba174.push(_0x38d005);
        }
        _0x8a1dd5 = _0x8a1dd5 || Charactermancer_Spell_Util.getMaxLearnedCantrips({
          'cls': _0x2bea38,
          'sc': _0x6aec7a,
          'targetLevel': _0x275d07
        }) != null;
      }
      return {
        'min': _0x35ebcb.length ? Math.min(..._0x35ebcb) : null,
        'max': _0x5ba174.length ? Math.max(..._0x5ba174) : null,
        'isAnyCantrips': _0x8a1dd5
      };
    }
    /**Defines the starting default values of our _state proxy  */
    _getDefaultState() {
      return {
        'class_ixPrimaryClass': 0,
        'class_ixMax': 0,
        'class_totalLevels': 0,
        'class_pulseChange': false
      };
    }
}
class Charactermancer_Class_HpIncreaseModeSelect extends BaseComponent {
    static async pGetUserInput() {
        if (this.isNoChoice()) {
            const comp = new this();
            return comp.pGetFormData();
        }

        return UtilApplications.pGetImportCompApplicationFormData({
            comp: new this(),
            width: 480,
            height: 150,
        });
    }

    static isHpAvailable(cls) {
        return cls.hd && cls.hd.number && !isNaN(cls.hd.number) && cls.hd.faces && !isNaN(cls.hd.faces);
    }

    static isNoChoice() {
        if (game.user.isGM)
            return false;

        if (Config.get("importClass", "hpIncreaseMode") === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM && Config.get("importClass", "hpIncreaseModeCustomRollFormula") == null)
            return false;

        return Config.get("importClass", "hpIncreaseMode") != null;
    }

    pGetFormData() {
        return {
            isFormComplete: true,
            data: {
                mode: this._state.mode,
                customFormula: this._state.customFormula,
            },
        };
    }

    get modalTitle() {
        return `Select Hit Points Increase Mode`;
    }

    render($wrp) {
        const $sel = ComponentUiUtil.$getSelEnum(this, "mode", {
            values: [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE, ],
            fnDisplay: mode=>ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[mode],
        }, );

        /* if (!game.user.isGM && Config.get("importClass", "hpIncreaseMode") != null)
            $sel.disable(); */

        const $iptCustom = ComponentUiUtil.$getIptStr(this, "customFormula").addClass("code");

        /* if (!game.user.isGM && Config.get("importClass", "hpIncreaseModeCustomRollFormula") != null)
            $iptCustom.disable(); */

        const $stgCustom = $$`<div class="mt-2 ve-flex-v-center">
			<div class="inline-block bold mr-1 no-wrap">Custom Formula:</div>
			${$iptCustom}
		</div>`;
        const hkMode = ()=>{
            $stgCustom.toggleVe(this._state.mode === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM);
        }
        ;
        this._addHookBase("mode", hkMode);
        hkMode();

        $$`<div class="ve-flex-col min-h-0">
			${$sel}
			${$stgCustom}
		</div>`.appendTo($wrp);
    }

    _getDefaultState() {
        return {
            mode: Config.get("importClass", "hpIncreaseMode") ?? ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE,
            customFormula: Config.get("importClass", "hpIncreaseModeCustomRollFormula") ?? "(2 * @hd.number)d(@hd.faces / 2)",
        };
    }
}
class Charactermancer_Class_HpInfo extends BaseComponent {
    constructor({className, hitDice}) {
        super();
        this._className = className;
        this._hitDice = hitDice;
    }

    render($wrp) {
        const hdEntry = Renderer.class.getHitDiceEntry(this._hitDice);

        const we = $$`<div class="ve-flex-col min-h-0 ve-small">
			<div class="block"><div class="inline-block bold mr-1">Hit Dice:</div>${SETTINGS.DO_RENDER_DICE? Vetools.withUnpatchedDiceRendering(()=>
                Renderer.getEntryDice(hdEntry, "Hit die")) : hdEntry.toRoll}</div>
			<div class="block"><div class="inline-block bold mr-1">Hit Points:</div>${Renderer.class.getHitPointsAtFirstLevel(this._hitDice)}</div>
			<div class="block"><div class="inline-block bold mr-1">Hit Points at Higher Levels:</div>
            ${Vetools.withUnpatchedDiceRendering(()=>Renderer.class.getHitPointsAtHigherLevels(this._className, this._hitDice, hdEntry))}</div>
		</div>`;
        we.appendTo($wrp);
    }
}
class Charactermancer_Class_ProficiencyImportModeSelect extends BaseComponent {
    static async pGetUserInput() {
        return UtilApplications.pGetImportCompApplicationFormData({
            comp: new this(),
            isUnskippable: true,
            isAutoResize: true,
        });
    }

    pGetFormData() {
        return {
            isFormComplete: true,
            data: this._state.mode,
        };
    }

    get modalTitle() {
        return `Select Class Proficiency Import Mode`;
    }

    render($wrp) {
        const $sel = ComponentUiUtil.$getSelEnum(this, "mode", {
            values: [Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS, Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY, Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE, ],
            fnDisplay: mode=>Charactermancer_Class_ProficiencyImportModeSelect.DISPLAY_MODES[mode],
        }, );

        $$`<div class="ve-flex-col min-h-0">
			${$sel}
		</div>`.appendTo($wrp);
    }

    _getDefaultState() {
        return {
            mode: Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS,
        };
    }
}
Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS = 0;
Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY = 1;
Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE = 2;

Charactermancer_Class_ProficiencyImportModeSelect.DISPLAY_MODES = {
    [Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS]: "Add multiclass proficiencies (this is my second+ class)",
    [Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY]: "Add base class proficiencies and equipment (this is my first class)",
    [Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE]: "Do not add proficiencies or equipment",
};
class Charactermancer_Class_StartingProficiencies extends BaseComponent {
    static get({featureSourceTracker, primaryProficiencies, multiclassProficiencies, savingThrowsProficiencies, mode, existingProficienciesFvttArmor, existingProficienciesFvttWeapons, existingProficienciesFvttSavingThrows, }={}, ) {
        const {existingProficienciesVetArmor, existingProficienciesCustomArmor,
        existingProficienciesVetWeapons, existingProficienciesCustomWeapons,
        existingProficienciesVetSavingThrows, } = this._getExistingProficienciesVet({
            existingProficienciesFvttArmor,
            existingProficienciesFvttWeapons,
            existingProficienciesFvttSavingThrows,
        });

        const comp = new this({
            featureSourceTracker,
            primaryProficiencies,
            multiclassProficiencies,
            savingThrowsProficiencies,
            existingProficienciesVetArmor,
            existingProficienciesVetWeapons,
            existingProficienciesVetSavingThrows,

            existingProficienciesCustomArmor,
            existingProficienciesCustomWeapons,

            existingProficienciesFvttArmor,
            existingProficienciesFvttWeapons,
            existingProficienciesFvttSavingThrows,
        });

        if (mode != null)
            comp.mode = mode;

        return comp;
    }

    static async pGetUserInput({featureSourceTracker, primaryProficiencies, multiclassProficiencies, savingThrowsProficiencies, mode, existingProficienciesFvttArmor, existingProficienciesFvttWeapons, existingProficienciesFvttSavingThrows, }={}, ) {
        return this.get({
            featureSourceTracker,
            primaryProficiencies,
            multiclassProficiencies,
            savingThrowsProficiencies,
            mode,
            existingProficienciesFvttArmor,
            existingProficienciesFvttWeapons,
            existingProficienciesFvttSavingThrows,
        }).pGetFormData();
    }

    static applyFormDataToActorUpdate(actUpdate, formData) {
        MiscUtil.getOrSet(actUpdate, "system", "traits", {});

        this._applyFormDataToActorUpdate_applyProfList({
            actUpdate,
            profList: formData?.data?.armor || [],
            profsExisting: formData?.existingDataFvtt?.existingProficienciesArmor || {},
            propTrait: "armorProf",
            fnGetMapped: UtilActors.getMappedArmorProficiency.bind(UtilActors),
        });

        this._applyFormDataToActorUpdate_applyProfList({
            actUpdate,
            profList: formData.data?.weapons || [],
            profsExisting: formData?.existingDataFvtt?.existingProficienciesWeapons || {},
            propTrait: "weaponProf",
            fnGetMapped: UtilActors.getMappedWeaponProficiency.bind(UtilActors),
            fnGetPreMapped: UtilActors.getItemUIdFromWeaponProficiency.bind(UtilActors),
        });

        const tgtAbils = MiscUtil.getOrSet(actUpdate, "system", "abilities", {});
        [...(formData.data?.savingThrows || []), ...(formData.existingDataFvtt?.savingThrows || [])].forEach(abv=>(tgtAbils[abv] = tgtAbils[abv] || {}).proficient = 1);
    }

    static _applyFormDataToActorUpdate_addIfNotExists(arr, itm) {
        if (!arr.some(it=>it.toLowerCase().trim() === itm.toLowerCase().trim()))
            arr.push(itm);
    }

    static _applyFormDataToActorUpdate_applyProfList({actUpdate, profList, profsExisting, propTrait, fnGetMapped, fnGetPreMapped, }, ) {
        if (!profList?.length)
            return;

        const tgt = MiscUtil.getOrSet(actUpdate, "system", "traits", propTrait, {});
        tgt.value = tgt.value || [];
        tgt.custom = tgt.custom || "";

        const customArr = tgt.custom.split(";").map(it=>it.trim()).filter(Boolean);

        (profsExisting.value || []).forEach(it=>this._applyFormDataToActorUpdate_addIfNotExists(tgt.value, it));

        (profsExisting.custom || "").split(";").map(it=>it.trim()).filter(Boolean).forEach(it=>this._applyFormDataToActorUpdate_addIfNotExists(customArr, it));

        profList.forEach(it=>{
            const clean = (fnGetPreMapped ? fnGetPreMapped(it) : null) ?? Renderer.stripTags(it).toLowerCase();
            const mapped = fnGetMapped(clean);
            if (mapped)
                return this._applyFormDataToActorUpdate_addIfNotExists(tgt.value, mapped);

            const [itemTag] = /{@item [^}]+}/i.exec(it) || [];
            if (itemTag) {
                const mappedAlt = fnGetMapped(Renderer.stripTags(itemTag));
                if (mappedAlt)
                    return this._applyFormDataToActorUpdate_addIfNotExists(tgt.value, mappedAlt);
            }

            this._applyFormDataToActorUpdate_addIfNotExists(customArr, Renderer.stripTags(it));
        }
        );

        tgt.custom = customArr.join("; ");
    }

    static getExistingProficienciesFvttSavingThrows(actor) {
        return Object.entries(MiscUtil.get(actor, "_source", "system", "abilities") || {}).filter(([,abMeta])=>abMeta.proficient).map(([ab])=>ab);
    }

    static _getExistingProficienciesVet({existingProficienciesFvttArmor, existingProficienciesFvttWeapons, existingProficienciesFvttSavingThrows}) {
        const vetValidWeapons = new Set();
        const customWeapons = new Set();
        const vetValidArmors = new Set();
        const customArmors = new Set();

        this._getExistingProficienciesVet_({
            existingFvtt: existingProficienciesFvttWeapons,
            fnGetUnmapped: UtilActors.getUnmappedWeaponProficiency.bind(UtilActors),
            fnCheckUnmappedAlt: UtilActors.getItemUIdFromWeaponProficiency.bind(UtilActors),
            vetValidSet: vetValidWeapons,
            customSet: customWeapons,
        });

        this._getExistingProficienciesVet_({
            existingFvtt: existingProficienciesFvttArmor,
            fnGetUnmapped: UtilActors.getUnmappedArmorProficiency.bind(UtilActors),
            vetValidSet: vetValidArmors,
            customSet: customArmors,
        });

        return {
            existingProficienciesVetWeapons: [...vetValidWeapons],
            existingProficienciesCustomWeapons: [...customWeapons],
            existingProficienciesVetArmor: [...vetValidArmors],
            existingProficienciesCustomArmor: [...customArmors],
            existingProficienciesVetSavingThrows: existingProficienciesFvttSavingThrows,
        };
    }

    static _getExistingProficienciesVet_({existingFvtt, vetValidSet, customSet, fnGetUnmapped, fnCheckUnmappedAlt, }) {
        (existingFvtt?.value || []).forEach(it=>{
            const unmapped = fnGetUnmapped(it);
            if (unmapped)
                vetValidSet.add(unmapped);
            else {
                if (fnCheckUnmappedAlt) {
                    const unmappedVet = fnCheckUnmappedAlt(it);
                    if (unmappedVet)
                        vetValidSet.add(it);
                    else
                        customSet.add(it);
                } else {
                    customSet.add(it);
                }
            }
        }
        );

        (existingFvtt?.custom || "").trim().split(";").map(it=>it.trim()).filter(Boolean).forEach(it=>{
            const low = it.toLowerCase();
            const unmapped = fnGetUnmapped(low);
            if (unmapped)
                vetValidSet.add(unmapped);
            else {
                if (fnCheckUnmappedAlt) {
                    const unmappedVet = fnCheckUnmappedAlt(low);
                    if (unmappedVet)
                        vetValidSet.add(low);
                    else
                        customSet.add(it);
                } else {
                    customSet.add(it);
                }
            }
        }
        );
    }

    static _getCleanVetProfs(vetProfs) {
        if (!vetProfs)
            return {};

        const out = {};

        if (vetProfs.armor)
            out.armor = this._getCleanVetProfs_getMappedItemTags(vetProfs.armor.map(it=>it.proficiency || it));
        if (vetProfs.weapons)
            out.weapons = this._getCleanVetProfs_getMappedItemTags(vetProfs.weapons.map(it=>(it.proficiency || it).toLowerCase().trim()));

        return out;
    }

    static _getCleanVetProfs_getMappedItemTags(arr) {
        return arr.map(it=>it.replace(/^{@item ([^}]+)}$/g, (...m)=>{
            const [name,source] = Renderer.splitTagByPipe(m[1]);
            return `${name}|${source || Parser.SRC_DMG}`.toLowerCase();
        }
        ));
    }

    constructor({featureSourceTracker, primaryProficiencies, multiclassProficiencies, savingThrowsProficiencies, existingProficienciesVetArmor, existingProficienciesVetWeapons, existingProficienciesVetSavingThrows, existingProficienciesFvttArmor, existingProficienciesFvttWeapons, existingProficienciesFvttSavingThrows, existingProficienciesCustomArmor, existingProficienciesCustomWeapons, }={}, ) {
        super();
        this._featureSourceTracker = featureSourceTracker;
        this._primaryProficiencies = Charactermancer_Class_StartingProficiencies._getCleanVetProfs(primaryProficiencies);
        this._multiclassProficiencies = Charactermancer_Class_StartingProficiencies._getCleanVetProfs(multiclassProficiencies);
        this._savingThrowsProficiencies = savingThrowsProficiencies;

        this._existingProficienciesVetArmor = existingProficienciesVetArmor;
        this._existingProficienciesVetWeapons = existingProficienciesVetWeapons;
        this._existingProficienciesVetSavingThrows = existingProficienciesVetSavingThrows;

        this._existingProficienciesCustomArmor = existingProficienciesCustomArmor;
        this._existingProficienciesCustomWeapons = existingProficienciesCustomWeapons;
        this._existingProficienciesFvttArmor = existingProficienciesFvttArmor ? MiscUtil.copy(existingProficienciesFvttArmor) : null;
        this._existingProficienciesFvttWeapons = existingProficienciesFvttWeapons ? MiscUtil.copy(existingProficienciesFvttWeapons) : null;
        this._existingProficienciesFvttSavingThrows = existingProficienciesFvttSavingThrows ? MiscUtil.copy(existingProficienciesFvttSavingThrows) : null;
    }

    set mode(mode) {
        this._state.mode = mode;
    }

    _getFormData() {
        const isPrimary = this._state.mode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY;
        const profs = isPrimary ? this._primaryProficiencies : this._multiclassProficiencies;

        if (!profs)
            return {
                isFormComplete: true,
                data: {},
                existingData: {}
            };

        return {
            isFormComplete: true,
            data: {
                armor: profs.armor || [],
                weapons: profs.weapons || [],
                savingThrows: isPrimary ? (this._savingThrowsProficiencies || []) : [],
            },
            existingDataFvtt: {
                existingProficienciesArmor: this._existingProficienciesFvttArmor,
                existingProficienciesWeapons: this._existingProficienciesFvttWeapons,
                existingProficienciesSavingThrows: this._existingProficienciesFvttSavingThrows,
            },
        };
    }

    pGetFormData() {
        return this._getFormData();
    }

    render($wrp) {
        const $wrpDisplay = $(`<div class="ve-flex-col min-h-0 ve-small"></div>`).appendTo($wrp);

        const fnsCleanup = [];

        const hkMode = ()=>{
            fnsCleanup.forEach(fn=>fn());
            fnsCleanup.splice(0, fnsCleanup.length);

            $wrpDisplay.empty();
            const isPrimary = this._state.mode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY;

            const profs = isPrimary ? this._primaryProficiencies : this._multiclassProficiencies;
            if (profs) {
                this._render_profType({
                    profList: profs.armor,
                    title: "Armor",
                    $wrpDisplay,
                    propTracker: "armorProficiencies",
                    propTrackerPulse: "pulseArmorProficiencies",
                    fnsCleanup,
                    existing: this._existingProficienciesVetArmor,
                    existingProficienciesCustom: this._existingProficienciesCustomArmor,
                    fnDisplay: str=>["light", "medium", "heavy"].includes(str) ? `${str} armor` : str.includes("|") ? `{@item ${str}}` : str,
                });

                this._render_profType({
                    profList: profs.weapons,
                    title: "Weapons",
                    $wrpDisplay,
                    propTracker: "weaponProficiencies",
                    propTrackerPulse: "pulseWeaponProficiencies",
                    fnsCleanup,
                    existing: this._existingProficienciesVetWeapons,
                    existingProficienciesCustom: this._existingProficienciesCustomWeapons,
                    fnDisplay: str=>["simple", "martial"].includes(str) ? `${str} weapons` : str.includes("|") ? `{@item ${str}}` : str,
                });
            }

            if (isPrimary && this._savingThrowsProficiencies) {
                this._render_profType({
                    profList: this._savingThrowsProficiencies,
                    title: "Saving Throws",
                    $wrpDisplay,
                    propTracker: "savingThrowProficiencies",
                    propTrackerPulse: "pulseSavingThrowProficiencies",
                    fnsCleanup,
                    existing: this._existingProficienciesVetSavingThrows,
                    fnDisplay: str=>Parser.attAbvToFull(str),
                });
            }

            if (this._featureSourceTracker)
                this._featureSourceTracker.setState(this, this._getStateTrackerData());
        }
        ;
        this._addHookBase("mode", hkMode);
        hkMode();
    }

    _getStateTrackerData() {
        const formData = this._getFormData();

        const getNoTags = (arr)=>arr.map(it=>this.constructor._getUid(it)).filter(Boolean);

        return {
            armorProficiencies: getNoTags(formData.data?.armor || []).mergeMap(it=>({
                [it]: true
            })),
            weaponProficiencies: getNoTags(formData.data?.weapons || []).mergeMap(it=>({
                [it]: true
            })),
        };
    }

    static _getUid(str) {
        if (!str.startsWith("{@item"))
            return str;

        let[name,source] = Renderer.splitTagByPipe((Renderer.splitFirstSpace(str.slice(1, -1))[1] || "").toLowerCase());
        source = source || Parser.SRC_DMG.toLowerCase();
        if (!name)
            return null;

        return `${name}|${source}`;
    }

    _render_profType({profList, title, $wrpDisplay, propTracker, propTrackerPulse, fnsCleanup, existing, existingProficienciesCustom, fnDisplay}) {
        if (!profList?.length)
            return;

        const profListUids = profList.map(prof=>this.constructor._getUid(prof));

        const $ptsExisting = {};

        const $wrps = profList.map((it,i)=>{
            const $ptExisting = $(`<div class="ve-small veapp__msg-warning inline-block"></div>`);
            const uid = profListUids[i];
            $ptsExisting[uid] = $ptExisting;
            const isNotLast = i < profList.length - 1;
            return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${Renderer.get().render(fnDisplay ? fnDisplay(it) : it)}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
        }
        );

        $$`<div class="block">
			<div class="mr-1 bold inline-block">${title}:</div>${$wrps}
		</div>`.appendTo($wrpDisplay);

        const pHkUpdatePtsExisting = async()=>{
            try {
                await this._pLock("updateExisting");
                await pHkUpdatePtsExisting_();
            } finally {
                this._unlock("updateExisting");
            }
        }
        ;

        const pHkUpdatePtsExisting_ = async()=>{
            const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(propTracker, {
                ignore: this
            }) : null;

            for (const v of profListUids) {
                if (!$ptsExisting[v])
                    return;

                const parentGroup = await UtilDataConverter.pGetItemWeaponType(v);

                let isExisting = (existing || []).includes(v) || (parentGroup && (existing || []).includes(parentGroup)) || (existingProficienciesCustom || []).includes(v) || (parentGroup && (existingProficienciesCustom || []).includes(parentGroup));

                isExisting = isExisting || (otherStates || []).some(otherState=>!!otherState[v] || (parentGroup && !!otherState[parentGroup]));

                $ptsExisting[v].title(isExisting ? "Proficient from Another Source" : "").toggleClass("ml-1", isExisting).html(isExisting ? `(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[1]}"></i>)` : "");
            }
        }
        ;
        if (this._featureSourceTracker) {
            this._featureSourceTracker.addHook(this, propTrackerPulse, pHkUpdatePtsExisting);
            fnsCleanup.push(()=>this._featureSourceTracker.removeHook(this, propTrackerPulse, pHkUpdatePtsExisting));
        }
        pHkUpdatePtsExisting();
    }

    _getDefaultState() {
        return {
            mode: Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY,
        };
    }
}

//#region Charactermancer Ability
/**The panel that handles adjusting ability scores */
class ActorCharactermancerAbility extends ActorCharactermancerBaseComponent {
    static ['_STORAGE_KEY__PB_CUSTOM'] = "actor_charactermancer_ability";
    constructor(_0x2b38cf) {
      _0x2b38cf = _0x2b38cf || {};
      super();
      this._actor = _0x2b38cf.actor;
      this._data = _0x2b38cf.data;
      this._parent = _0x2b38cf.parent;
      this._tabAbilities = _0x2b38cf.tabAbilities;
      this._compStatgen = null;
    }
    get ['compStatgen']() {
      return this._compStatgen;
    }
    ["addHookAbilityScores"](..._0x42aa73) {
      return this._compStatgen.addHookAbilityScores(..._0x42aa73);
    }
    getMode(..._0x30474b) {
      return this._compStatgen.getMode(..._0x30474b);
    }
    ["getTotals"](..._0x5d866f) {
      return this._compStatgen.getTotals(..._0x5d866f);
    }
    render() {
      const parentDiv = this._tabAbilities?.$wrpTab;
      if (!parentDiv) {return;}
      this._data.race = []; //TEMPFIX

      //This element will handle the heavy lifting, both UI wise and logic wise
      this._compStatgen = new StatGenUiCharactermancer({
        'isCharacterMode': true,
        'isFvttMode': true,
        'races': this._data.race,
        'backgrounds': this._data.background,
        'feats': this._data.feat,
        /* 'modalFilterRaces': this._parent.compRace.modalFilterRaces,
        'modalFilterBackgrounds': this._parent.compBackground.modalFilterBackgrounds,
        'modalFilterFeats': this._parent.compFeat.modalFilterFeats, */
        /* 'existingScores': this._getExistingScores() */
      });

      /* const clientThenWorld = GameStorage.getClientThenWorld(this.constructor._STORAGE_KEY__PB_CUSTOM);
      if (clientThenWorld != null) {this._compStatgen.setStateFrom(clientThenWorld);} */

      const _0x8ec07a = MiscUtil.throttle(this._doSavePbRules.bind(this), 0x64); 
      this._compStatgen.addHookPointBuyCustom(_0x8ec07a);

      //Render the ui for changing ability scores
      this._compStatgen.render(parentDiv);
      /*
      const _0x1a56f6 = () => {
        let _0x1eb097 = 0x0;
        for (let _0x1d57fc = 0x0; _0x1d57fc < this._parent.compClass.state.class_ixMax + 0x1; ++_0x1d57fc) {
          const {
            propIxClass: _0x5a8f01,
            propCntAsi: _0x320301
          } = ActorCharactermancerBaseComponent.class_getProps(_0x1d57fc);
          const _0x56ff24 = this._parent.compClass.getClass_({
            'propIxClass': _0x5a8f01
          });
          if (!_0x56ff24) {
            continue;
          }
          _0x1eb097 += Number(this._parent.compClass.state[_0x320301]) || 0x0;
        }
        this._compStatgen.common_cntAsi = _0x1eb097;
      };
      this._parent.compClass.addHookBase("class_pulseChange", _0x1a56f6);
      this._parent.compClass.addHookBase('class_totalLevels', _0x1a56f6);
      _0x1a56f6();
      const _0x4ae28f = () => this._parent.compFeat.setAdditionalFeatStateFromStatgen_();
      this._compStatgen.addHookPulseAsi(_0x4ae28f);
      this._parent.compFeat.setAdditionalFeatStateFromStatgen_();
      const _0x1ace3d = () => this._parent.compRace.state.race_ixRace = this._compStatgen.ixRace;
      this._compStatgen.addHookIxRace(_0x1ace3d);
      const _0x107d17 = () => this._parent.compBackground.state.background_ixBackground = this._compStatgen.ixBackground;
      this._compStatgen.addHookIxBackground(_0x107d17);
      const _0x5ef610 = () => this._compStatgen.ixRace = this._parent.compRace.state.race_ixRace;
      this._parent.compRace.addHookBase("race_ixRace", _0x5ef610);
      const _0xea4aee = () => this._compStatgen.ixBackground = this._parent.compBackground.state.background_ixBackground;
      this._parent.compBackground.addHookBase("background_ixBackground", _0xea4aee);
      this._compStatgen.ixRace = this._parent.compRace.state.race_ixRace;
      this._compStatgen.ixBackground = this._parent.compBackground.state.background_ixBackground; */
    }
    _doSavePbRules() {
      const pointBuySavedState = this._compStatgen.getSaveableStatePointBuyCustom();
      GameStorage.pSetWorldThenClient(this.constructor._STORAGE_KEY__PB_CUSTOM, pointBuySavedState).then(null);
    }
    ["_getExistingScores"]() {
      if (!Charactermancer_Util.getCurrentLevel(this._actor)) {
        return null;
      }
      return Charactermancer_Util.getBaseAbilityScores(this._actor);
    }
    ["_getDefaultState"]() {
      return {};
    }
}

let StatGenUi$1 = class StatGenUi extends BaseComponent {
    static _PROPS_POINT_BUY_CUSTOM = ["pb_rules", "pb_budget", "pb_isCustom", ];

    constructor(opts) {
        super();
        opts = opts || {};

        TabUiUtilSide.decorate(this, {
            isInitMeta: true
        });

        this._races = opts.races; //Set races
        this._backgrounds = opts.backgrounds;
        this._feats = opts.feats;
        this._tabMetasAdditional = opts.tabMetasAdditional;
        this._isCharacterMode = opts.isCharacterMode;
        this._isFvttMode = opts.isFvttMode;

        this._MODES = this._isFvttMode ? StatGenUi$1.MODES_FVTT : StatGenUi$1.MODES;
        if (this._isFvttMode) {
            let cnt = 0;
            this._IX_TAB_NONE = cnt++;
            this._IX_TAB_ROLLED = cnt++;
            this._IX_TAB_ARRAY = cnt++;
            this._IX_TAB_PB = cnt++;
            this._IX_TAB_MANUAL = cnt;
        } else {
            this._IX_TAB_NONE = -1;
            let cnt = 0;
            this._IX_TAB_ROLLED = cnt++;
            this._IX_TAB_ARRAY = cnt++;
            this._IX_TAB_PB = cnt++;
            this._IX_TAB_MANUAL = cnt;
        }

        /* this._modalFilterRaces = opts.modalFilterRaces || new ModalFilterRaces({
            namespace: "statgen.races",
            isRadio: true,
            allData: this._races
        });
        this._modalFilterBackgrounds = opts.modalFilterBackgrounds || new ModalFilterBackgrounds({
            namespace: "statgen.backgrounds",
            isRadio: true,
            allData: this._backgrounds
        });
        this._modalFilterFeats = opts.modalFilterFeats || new ModalFilterFeats({
            namespace: "statgen.feats",
            isRadio: true,
            allData: this._feats
        }); */

        this._isLevelUp = !!opts.existingScores;
        this._existingScores = opts.existingScores;

        this._$rollIptFormula = null;

        this._compAsi = new StatGenUi$1.CompAsi({
            parent: this
        });
    }

    get MODES() {
        return this._MODES;
    }

    get ixActiveTab() {
        return this._getIxActiveTab();
    }
    set ixActiveTab(ix) {
        this._setIxActiveTab({
            ixActiveTab: ix
        });
    }

    addHookPointBuyCustom(hook) {
        this.constructor._PROPS_POINT_BUY_CUSTOM.forEach(prop=>this._addHookBase(prop, hook));
    }

    addHookAbilityScores(hook) {
        Parser.ABIL_ABVS.forEach(ab=>this._addHookBase(`common_export_${ab}`, hook));
    }
    addHookPulseAsi(hook) {
        this._addHookBase("common_pulseAsi", hook);
    }
    getFormDataAsi() {
        return this._compAsi.getFormData();
    }

    getMode(ix, namespace) {
        const {propMode} = this.getPropsAsi(ix, namespace);
        return this._state[propMode];
    }

    setIxFeat(ix, namespace, ixFeat) {
        const {propMode, propIxFeat} = this.getPropsAsi(ix, namespace);

        if (ixFeat == null && (this._state[propMode] === "asi" || this._state[propMode] == null)) {
            this._state[propIxFeat] = null;
            return;
        }

        this._state[propMode] = "feat";
        this._state[propIxFeat] = ixFeat;
    }

    setIxFeatSet(namespace, ixSet) {
        const {propIxSel} = this.getPropsAdditionalFeats_(namespace);
        this._state[propIxSel] = ixSet;
    }

    setIxFeatSetIxFeats(namespace, metaFeats) {
        const nxtState = {};
        metaFeats.forEach(({ix, ixFeat})=>{
            const {propIxFeat} = this.getPropsAdditionalFeatsFeatSet_(namespace, "fromFilter", ix);
            nxtState[propIxFeat] = ixFeat;
        }
        );
        this._proxyAssignSimple("state", nxtState);
    }

    set common_cntAsi(val) {
        this._state.common_cntAsi = val;
    }

    addHookIxRace(hook) {
        this._addHookBase("common_ixRace", hook);
    }
    get ixRace() {
        return this._state.common_ixRace;
    }
    set ixRace(ixRace) {
        this._state.common_ixRace = ixRace;
    }

    addHookIxBackground(hook) {
        this._addHookBase("common_ixBackground", hook);
    }
    get ixBackground() {
        return this._state.common_ixBackground;
    }
    set ixBackground(ixBackground) {
        this._state.common_ixBackground = ixBackground;
    }

    addCustomFeat() {
        this._state.common_cntFeatsCustom = Math.min(StatGenUi$1._MAX_CUSTOM_FEATS, (this._state.common_cntFeatsCustom || 0) + 1);
    }
    setCntCustomFeats(val) {
        this._state.common_cntFeatsCustom = Math.min(StatGenUi$1._MAX_CUSTOM_FEATS, val || 0);
    }

    get isCharacterMode() {
        return this._isCharacterMode;
    }
    get state() {
        return this._state;
    }
    get modalFilterFeats() {
        return this._modalFilterFeats;
    }
    get feats() {
        return this._feats;
    }
    addHookBase(prop, hook) {
        return this._addHookBase(prop, hook);
    }
    removeHookBase(prop, hook) {
        return this._removeHookBase(prop, hook);
    }
    proxyAssignSimple(hookProp, toObj, isOverwrite) {
        return this._proxyAssignSimple(hookProp, toObj, isOverwrite);
    }
    get race() {
        console.warn("races disabled");
        return null; //TEMP FIX
        return this._races[this._state.common_ixRace];
    }
    get background() {
        console.warn("backgrounds disabled");
        return null; //TEMP FIX
        return this._backgrounds[this._state.common_ixBackground];
    }
    get isLevelUp() {
        return this._isLevelUp;
    }

    getTotals() {
        if (this._isLevelUp) {
            return {
                mode: "levelUp",
                totals: {
                    levelUp: this._getTotals_levelUp(),
                },
            };
        }

        return {
            mode: this._MODES[this.ixActiveTab || 0],
            totals: {
                rolled: this._getTotals_rolled(),
                array: this._getTotals_array(),
                pointbuy: this._getTotals_pb(),
                manual: this._getTotals_manual(),
            },
        };
    }

    _getTotals_rolled() {
        return Parser.ABIL_ABVS.mergeMap(ab=>({
            [ab]: this._rolled_getTotalScore(ab)
        }));
    }
    _getTotals_array() {
        return Parser.ABIL_ABVS.mergeMap(ab=>({
            [ab]: this._array_getTotalScore(ab)
        }));
    }
    _getTotals_pb() {
        return Parser.ABIL_ABVS.mergeMap(ab=>({
            [ab]: this._pb_getTotalScore(ab)
        }));
    }
    _getTotals_manual() {
        return Parser.ABIL_ABVS.mergeMap(ab=>({
            [ab]: this._manual_getTotalScore(ab)
        }));
    }
    _getTotals_levelUp() {
        return Parser.ABIL_ABVS.mergeMap(ab=>({
            [ab]: this._levelUp_getTotalScore(ab)
        }));
    }

    addHook(hookProp, prop, hook) {
        return this._addHook(hookProp, prop, hook);
    }
    addHookAll(hookProp, hook) {
        this._addHookAll(hookProp, hook);
        this._compAsi._addHookAll(hookProp, hook);
    }

    addHookActiveTag(hook) {
        this._addHookActiveTab(hook);
    }

    async pInit() {
        await this._modalFilterRaces.pPreloadHidden();
        await this._modalFilterBackgrounds.pPreloadHidden();
        await this._modalFilterFeats.pPreloadHidden();
    }

    getPropsAsi(ix, namespace) {
        return {
            prefix: `common_asi_${namespace}_${ix}_`,
            propMode: `common_asi_${namespace}_${ix}_mode`,
            propIxAsiPointOne: `common_asi_${namespace}_${ix}_asiPointOne`,
            propIxAsiPointTwo: `common_asi_${namespace}_${ix}_asiPointTwo`,
            propIxFeat: `common_asi_${namespace}_${ix}_ixFeat`,
            propIxFeatAbility: `common_asi_${namespace}_${ix}_ixFeatAbility`,
            propFeatAbilityChooseFrom: `common_asi_${namespace}_${ix}_featAbilityChooseFrom`,
        };
    }

    getPropsAdditionalFeats_(namespace) {
        return {
            propPrefix: `common_additionalFeats_${namespace}_`,
            propIxSel: `common_additionalFeats_${namespace}_ixSel`,
        };
    }

    getPropsAdditionalFeatsFeatSet_(namespace, type, ix) {
        return {
            propIxFeat: `common_additionalFeats_${namespace}_${type}_${ix}_ixFeat`,
            propIxFeatAbility: `common_additionalFeats_${namespace}_${type}_${ix}_ixFeatAbility`,
            propFeatAbilityChooseFrom: `common_additionalFeats_${namespace}_${type}_${ix}_featAbilityChooseFrom`,
        };
    }

    _roll_getRolledStats() {
        const wrpTree = Renderer.dice.lang.getTree3(this._state.rolled_formula);
        if (!wrpTree)
            return this._$rollIptFormula.addClass("form-control--error");

        const rolls = [];
        for (let i = 0; i < this._state.rolled_rollCount; i++) {
            const meta = {};
            meta.total = wrpTree.tree.evl(meta);
            rolls.push(meta);
        }
        rolls.sort((a,b)=>SortUtil.ascSort(b.total, a.total));

        return rolls.map(r=>({
            total: r.total,
            text: (r.text || []).join("")
        }));
    }

    render($parent) {
        $parent.empty().addClass("statgen");

        //If we are leveling up, some UI changes
        const iptTabMetas = this._isLevelUp ? [new TabUiUtil.TabMeta({
            name: "Existing",
            icon: this._isFvttMode ? `fas fa-fw fa-user` : `far fa-fw fa-user`,
            hasBorder: true
        }), ...this._tabMetasAdditional || [], ] : [this._isFvttMode ? new TabUiUtil.TabMeta({
            name: "Select...",
            icon: this._isFvttMode ? `fas fa-fw fa-square` : `far fa-fw fa-square`,
            hasBorder: true,
            isNoPadding: this._isFvttMode
        }) : null, new TabUiUtil.TabMeta({
            name: "Roll",
            icon: this._isFvttMode ? `fas fa-fw fa-dice` : `far fa-fw fa-dice`,
            hasBorder: true,
            isNoPadding: this._isFvttMode
        }), new TabUiUtil.TabMeta({
            name: "Standard Array",
            icon: this._isFvttMode ? `fas fa-fw fa-signal` : `far fa-fw fa-signal-alt`,
            hasBorder: true,
            isNoPadding: this._isFvttMode
        }), new TabUiUtil.TabMeta({
            name: "Point Buy",
            icon: this._isFvttMode ? `fas fa-fw fa-chart-bar` : `far fa-fw fa-chart-bar`,
            hasBorder: true,
            isNoPadding: this._isFvttMode
        }), new TabUiUtil.TabMeta({
            name: "Manual",
            icon: this._isFvttMode ? `fas fa-fw fa-tools` : `far fa-fw fa-tools`,
            hasBorder: true,
            isNoPadding: this._isFvttMode
        }), ...this._tabMetasAdditional || [], ].filter(Boolean);

        const tabMetas = this._renderTabs(iptTabMetas, {$parent: this._isFvttMode ? null : $parent});
        if (this._isFvttMode) {
            if (!this._isLevelUp) {
                const {propActive: propActiveTab, propProxy: propProxyTabs} = this._getTabProps();
                const $selMode = ComponentUiUtil.$getSelEnum(this, propActiveTab, {
                    values: iptTabMetas.map((_,ix)=>ix),
                    fnDisplay: ix=>iptTabMetas[ix].name,
                    propProxy: propProxyTabs,
                }, ).addClass("max-w-200p");
                $$`<div class="ve-flex-v-center statgen-shared__wrp-header">
					<div class="mr-2"><b>Mode</b></div>
					${$selMode}
				</div>
				<hr class="hr-2">`.appendTo($parent);
            }

            tabMetas.forEach(it=>it.$wrpTab.appendTo($parent));
        }

        const $wrpAll = $(`<div class="ve-flex-col w-100 h-100"></div>`);
        this._render_all($wrpAll);

        const hkTab = ()=>{
            tabMetas[this.ixActiveTab || 0].$wrpTab.append($wrpAll);
        }
        ;
        this._addHookActiveTab(hkTab);
        hkTab();

        this._addHookBase("common_cntAsi", ()=>this._state.common_pulseAsi = !this._state.common_pulseAsi);
        this._addHookBase("common_cntFeatsCustom", ()=>this._state.common_pulseAsi = !this._state.common_pulseAsi);
    }

    _render_all($wrpTab) {
        if (this._isLevelUp){return this._render_isLevelUp($wrpTab);}
        this._render_isLevelOne($wrpTab);
    }

    _render_isLevelOne($wrpTab) {
        let $stgNone;
        let $stgMain;
        const $elesRolled = [];
        const $elesArray = [];
        const $elesPb = [];
        const $elesManual = [];

        const $stgRolledHeader = this._render_$getStgRolledHeader();
        const hkStgRolled = ()=>$stgRolledHeader.toggleVe(this.ixActiveTab === this._IX_TAB_ROLLED);
        this._addHookActiveTab(hkStgRolled);
        hkStgRolled();

        const $stgPbHeader = this._render_$getStgPbHeader();
        const $stgPbCustom = this._render_$getStgPbCustom();
        const $vrPbCustom = $(`<div class="vr-5 mobile-ish__hidden"></div>`);
        const $hrPbCustom = $(`<hr class="hr-5 mobile-ish__visible">`);
        const hkStgPb = ()=>{
            $stgPbHeader.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
            $stgPbCustom.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
            $vrPbCustom.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
            $hrPbCustom.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
        }
        ;
        this._addHookActiveTab(hkStgPb);
        hkStgPb();

        const $stgArrayHeader = this._render_$getStgArrayHeader();
        const hkStgArray = ()=>$stgArrayHeader.toggleVe(this.ixActiveTab === this._IX_TAB_ARRAY);
        this._addHookActiveTab(hkStgArray);
        hkStgArray();

        const $stgManualHeader = this._render_$getStgManualHeader();
        const hkStgManual = ()=>$stgManualHeader.toggleVe(this.ixActiveTab === this._IX_TAB_MANUAL);
        this._addHookActiveTab(hkStgManual);
        hkStgManual();

        const hkElesMode = ()=>{
            $stgNone.toggleVe(this.ixActiveTab === this._IX_TAB_NONE);
            $stgMain.toggleVe(this.ixActiveTab !== this._IX_TAB_NONE);

            $elesRolled.forEach($ele=>$ele.toggleVe(this.ixActiveTab === this._IX_TAB_ROLLED));
            $elesArray.forEach($ele=>$ele.toggleVe(this.ixActiveTab === this._IX_TAB_ARRAY));
            $elesPb.forEach($ele=>$ele.toggleVe(this.ixActiveTab === this._IX_TAB_PB));
            $elesManual.forEach($ele=>$ele.toggleVe(this.ixActiveTab === this._IX_TAB_MANUAL));
        };
        this._addHookActiveTab(hkElesMode);

        const $btnResetRolledOrArrayOrManual = $(`<button class="btn btn-default btn-xxs relative statgen-shared__btn-reset" title="Reset"><span class="glyphicon glyphicon-refresh"></span></button>`).click(()=>this._doReset());
        const hkRolledOrArray = ()=>$btnResetRolledOrArrayOrManual.toggleVe(this.ixActiveTab === this._IX_TAB_ROLLED || this.ixActiveTab === this._IX_TAB_ARRAY || this.ixActiveTab === this._IX_TAB_MANUAL);
        this._addHookActiveTab(hkRolledOrArray);
        hkRolledOrArray();

        const $wrpsBase = Parser.ABIL_ABVS.map(ab=>{
            const {propAbilSelectedRollIx} = this.constructor._rolled_getProps(ab);

            const $selRolled = $(`<select class="form-control input-xs form-control--minimal statgen-shared__ipt statgen-shared__ipt--sel"></select>`).change(()=>{
                const ix = Number($selRolled.val());

                const nxtState = {
                    ...Parser.ABIL_ABVS.map(ab=>this.constructor._rolled_getProps(ab).propAbilSelectedRollIx).filter(prop=>ix != null && this._state[prop] === ix).mergeMap(prop=>({
                        [prop]: null
                    })),
                    [propAbilSelectedRollIx]: ~ix ? ix : null,
                };
                this._proxyAssignSimple("state", nxtState);
            }
            );
            $(`<option/>`, {
                value: -1,
                text: "\u2014"
            }).appendTo($selRolled);

            let $optionsRolled = [];
            const hkRolls = ()=>{
                $optionsRolled.forEach($opt=>$opt.remove());

                this._state.rolled_rolls.forEach((it,i)=>{
                    const cntPrevRolls = this._state.rolled_rolls.slice(0, i).filter(r=>r.total === it.total).length;
                    const $opt = $(`<option/>`, {
                        value: i,
                        text: `${it.total}${cntPrevRolls ? Parser.numberToSubscript(cntPrevRolls) : ""}`
                    }).appendTo($selRolled);
                    $optionsRolled.push($opt);
                }
                );

                let nxtSelIx = this._state[propAbilSelectedRollIx];
                if (nxtSelIx >= this._state.rolled_rolls.length)
                    nxtSelIx = null;
                $selRolled.val(`${nxtSelIx == null ? -1 : nxtSelIx}`);
                if ((nxtSelIx) !== this._state[propAbilSelectedRollIx])
                    this._state[propAbilSelectedRollIx] = nxtSelIx;
            }
            ;
            this._addHookBase("rolled_rolls", hkRolls);
            hkRolls();

            const hookIxRolled = ()=>{
                const ix = this._state[propAbilSelectedRollIx] == null ? -1 : this._state[propAbilSelectedRollIx];
                $selRolled.val(`${ix}`);
            }
            ;
            this._addHookBase(propAbilSelectedRollIx, hookIxRolled);
            hookIxRolled();

            $elesRolled.push($selRolled);

            const {propAbilSelectedScoreIx} = this.constructor._array_getProps(ab);

            const $selArray = $(`<select class="form-control input-xs form-control--minimal statgen-shared__ipt statgen-shared__ipt--sel"></select>`).change(()=>{
                const ix = Number($selArray.val());

                const nxtState = {
                    ...Parser.ABIL_ABVS.map(ab=>this.constructor._array_getProps(ab).propAbilSelectedScoreIx).filter(prop=>ix != null && this._state[prop] === ix).mergeMap(prop=>({
                        [prop]: null
                    })),
                    [propAbilSelectedScoreIx]: ~ix ? ix : null,
                };
                this._proxyAssignSimple("state", nxtState);
            }
            );
            $(`<option/>`, {
                value: -1,
                text: "\u2014"
            }).appendTo($selArray);

            StatGenUi$1._STANDARD_ARRAY.forEach((it,i)=>$(`<option/>`, {
                value: i,
                text: it
            }).appendTo($selArray));

            const hookIxArray = ()=>{
                const ix = this._state[propAbilSelectedScoreIx] == null ? -1 : this._state[propAbilSelectedScoreIx];
                $selArray.val(`${ix}`);
            }
            ;
            this._addHookBase(propAbilSelectedScoreIx, hookIxArray);
            hookIxArray();

            $elesArray.push($selArray);

            const propPb = `pb_${ab}`;
            const $iptPb = ComponentUiUtil.$getIptInt(this, propPb, 0, {
                fallbackOnNaN: 0,
                min: 0,
                html: `<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number">`,
            }, );

            const hkPb = ()=>{
                const {min: minScore, max: maxScore} = this._pb_getMinMaxScores();
                this._state[propPb] = Math.min(maxScore, Math.max(minScore, this._state[propPb]));
            }
            ;
            this._addHookBase(propPb, hkPb);
            hkPb();

            $elesPb.push($iptPb);

            const {propAbilValue} = this.constructor._manual_getProps(ab);
            const $iptManual = ComponentUiUtil.$getIptInt(this, propAbilValue, 0, {
                fallbackOnNaN: 0,
                html: `<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number">`,
            }, );

            $elesManual.push($iptManual);

            return $$`<label class="my-1 statgen-pb__cell">
				${$selRolled}
				${$selArray}
				${$iptPb}
				${$iptManual}
			</label>`;
        }
        );

        const $wrpsUser = this._render_$getWrpsUser();

        const metasTotalAndMod = this._render_getMetasTotalAndMod();

        //const {$wrpOuter: $wrpRaceOuter, $stgSel: $stgRaceSel, $dispPreview: $dispPreviewRace, $hrPreview: $hrPreviewRaceTashas, $dispTashas, } = this._renderLevelOneRace.render();

        //const {$wrpOuter: $wrpBackgroundOuter, $stgSel: $stgBackgroundSel, $dispPreview: $dispPreviewBackground, $hrPreview: $hrPreviewBackground, } = this._renderLevelOneBackground.render();


        //const $wrpAsi = this._render_$getWrpAsi();

        //TEMPFIX
        const $wrpRaceOuter = $(`<div></div>`);  const $wrpBackgroundOuter = $(`<div></div>`);  const $stgRaceSel = $(`<div></div>`);  const $stgBackgroundSel = $(`<div></div>`);
        const $dispPreviewBackground = $(`<div></div>`); const $dispPreviewRace = $(`<div></div>`);
        const $hrPreviewRaceTashas = $(`<div></div>`); const $hrPreviewBackground = $(`<div></div>`); const $dispTashas = $(`<div></div>`);
        const $wrpAsi = $(`<div></div>`);

        $stgNone = $$`<div class="ve-flex-col w-100 h-100">
			<div class="ve-flex-v-center"><i>Please select a mode.</i></div>
		</div>`;

        $stgMain = $$`<div class="ve-flex-col w-100 h-100">
			${$stgRolledHeader}
			${$stgArrayHeader}
			${$stgManualHeader}

			<div class="ve-flex mobile-ish__ve-flex-col w-100 px-3">
				<div class="ve-flex-col">
					${$stgPbHeader}

					<div class="ve-flex">
						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-h-right">${$btnResetRolledOrArrayOrManual}</div>

							${Parser.ABIL_ABVS.map(it=>`<div class="my-1 bold statgen-pb__cell ve-flex-v-center ve-flex-h-right" title="${Parser.attAbvToFull(it)}">${it.toUpperCase()}</div>`)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 bold statgen-pb__header ve-flex-vh-center">Base</div>
							${$wrpsBase}
						</div>

						${$wrpRaceOuter}

						${$wrpBackgroundOuter}

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-vh-center help text-muted" title="Input any additional/custom bonuses here">User</div>
							${$wrpsUser}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-vh-center">Total</div>
							${metasTotalAndMod.map(it=>it.$wrpIptTotal)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-vh-center" title="Modifier">Mod.</div>
							${metasTotalAndMod.map(it=>it.$wrpIptMod)}
						</div>
					</div>

					${$stgRaceSel}
					${$stgBackgroundSel}
				</div>

				${$vrPbCustom}
				${$hrPbCustom}

				${$stgPbCustom}
			</div>

			<hr class="hr-3">

			${$dispPreviewRace}
			${$hrPreviewRaceTashas}
			${$dispTashas}

			${$dispPreviewBackground}
			${$hrPreviewBackground}

			${$wrpAsi}
		</div>`;

        hkElesMode();

        $wrpTab.append($stgMain).append($stgNone);
    }

    _render_$getStgRolledHeader() {
        this._$rollIptFormula = ComponentUiUtil.$getIptStr(this, "rolled_formula").addClass("ve-text-center max-w-100p").keydown(evt=>{
            if (evt.key === "Enter")
                setTimeout(()=>$btnRoll.click());
        }
        ).change(()=>this._$rollIptFormula.removeClass("form-control--error"));

        const $iptRollCount = this._isCharacterMode ? null : ComponentUiUtil.$getIptInt(this, "rolled_rollCount", 1, {
            min: 1,
            fallbackOnNaN: 1,
            html: `<input type="text" class="form-control input-xs form-control--minimal ve-text-center max-w-100p">`
        }).keydown(evt=>{
            if (evt.key === "Enter")
                setTimeout(()=>$btnRoll.click());
        }
        ).change(()=>this._$rollIptFormula.removeClass("form-control--error"));

        const $btnRoll = $(`<button class="btn btn-primary bold">Roll</button>`).click(()=>{
            this._state.rolled_rolls = this._roll_getRolledStats();
        }
        );

        const $btnRandom = $(`<button class="btn btn-xs btn-default mt-2">Randomly Assign</button>`).hideVe().click(()=>{
            const abs = [...Parser.ABIL_ABVS].shuffle();
            abs.forEach((ab,i)=>{
                const {propAbilSelectedRollIx} = this.constructor._rolled_getProps(ab);
                this._state[propAbilSelectedRollIx] = i;
            }
            );
        }
        );

        const $wrpRolled = $(`<div class="ve-flex-v-center mr-auto statgen-rolled__wrp-results py-1"></div>`);
        const $wrpRolledOuter = $$`<div class="ve-flex-v-center"><div class="mr-2">=</div>${$wrpRolled}</div>`;

        const hkRolled = ()=>{
            $wrpRolledOuter.toggleVe(this._state.rolled_rolls.length);
            $btnRandom.toggleVe(this._state.rolled_rolls.length);

            $wrpRolled.html(this._state.rolled_rolls.map((it,i)=>{
                const cntPrevRolls = this._state.rolled_rolls.slice(0, i).filter(r=>r.total === it.total).length;
                return `<div class="px-3 py-1 help-subtle ve-flex-vh-center" title="${it.text}"><div class="ve-muted">[</div><div class="ve-flex-vh-center statgen-rolled__disp-result">${it.total}${cntPrevRolls ? Parser.numberToSubscript(cntPrevRolls) : ""}</div><div class="ve-muted">]</div></div>`;
            }
            ));
        }
        ;
        this._addHookBase("rolled_rolls", hkRolled);
        hkRolled();

        return $$`<div class="ve-flex-col mb-3 mr-auto">
			<div class="ve-flex mb-2">
				<div class="ve-flex-col ve-flex-h-center mr-3">
					<label class="ve-flex-v-center"><div class="mr-2 no-shrink w-100p">Formula:</div>${this._$rollIptFormula}</label>

					${this._isCharacterMode ? null : $$`<label class="ve-flex-v-center mt-2"><div class="mr-2 no-shrink w-100p">Number of rolls:</div>${$iptRollCount}</label>`}
				</div>
				${$btnRoll}
			</div>

			${$wrpRolledOuter}

			<div class="ve-flex-v-center">${$btnRandom}</div>
		</div>`;
    }

    _render_$getStgArrayHeader() {
        const $btnRandom = $(`<button class="btn btn-xs btn-default">Randomly Assign</button>`).click(()=>{
            const abs = [...Parser.ABIL_ABVS].shuffle();
            abs.forEach((ab,i)=>{
                const {propAbilSelectedScoreIx} = this.constructor._array_getProps(ab);
                this._state[propAbilSelectedScoreIx] = i;
            }
            );
        }
        );

        return $$`<div class="ve-flex-col mb-3 mr-auto">
			<div class="mb-2">Assign these numbers to your abilities as desired:</div>
			<div class="bold mb-2">${StatGenUi$1._STANDARD_ARRAY.join(", ")}</div>
			<div class="ve-flex">${$btnRandom}</div>
		</div>`;
    }

    _render_$getStgManualHeader() {
        return $$`<div class="ve-flex-col mb-3 mr-auto">
			<div>Enter your desired ability scores in the &quot;Base&quot; column below.</div>
		</div>`;
    }

    _doReset() {
        if (this._isLevelUp)
            return;
        const nxtState = this._getDefaultStateCommonResettable();

        switch (this.ixActiveTab) {
        case this._IX_TAB_NONE:
            Object.assign(nxtState, this._getDefaultStateNoneResettable());
            break;
        case this._IX_TAB_ROLLED:
            Object.assign(nxtState, this._getDefaultStateRolledResettable());
            break;
        case this._IX_TAB_ARRAY:
            Object.assign(nxtState, this._getDefaultStateArrayResettable());
            break;
        case this._IX_TAB_PB:
            Object.assign(nxtState, this._getDefaultStatePointBuyResettable());
            break;
        case this._IX_TAB_MANUAL:
            Object.assign(nxtState, this._getDefaultStateManualResettable());
            break;
        }

        this._proxyAssignSimple("state", nxtState);
    }

    doResetAll() {
        this._proxyAssignSimple("state", this._getDefaultState(), true);
    }

    _render_$getStgPbHeader() {
        const $iptBudget = ComponentUiUtil.$getIptInt(this, "pb_budget", 0, {
            html: `<input type="text" class="form-control statgen-pb__ipt-budget ve-text-center statgen-shared__ipt">`,
            min: 0,
            fallbackOnNaN: 0,
        }, );
        const hkIsCustom = ()=>{
            $iptBudget.attr("readonly", !this._state.pb_isCustom);
        }
        ;
        this._addHookBase("pb_isCustom", hkIsCustom);
        hkIsCustom();

        const $iptRemaining = ComponentUiUtil.$getIptInt(this, "pb_points", 0, {
            html: `<input type="text" class="form-control statgen-pb__ipt-budget ve-text-center statgen-shared__ipt">`,
            min: 0,
            fallbackOnNaN: 0,
        }, ).attr("readonly", true);

        const hkPoints = ()=>{
            this._state.pb_points = this._pb_getPointsRemaining(this._state);
            $iptRemaining.toggleClass(`statgen-pb__ipt-budget--error`, this._state.pb_points < 0);
        }
        ;
        this._addHookAll("state", hkPoints);
        hkPoints();

        const $btnReset = $(`<button class="btn btn-default">Reset</button>`).click(()=>this._doReset());

        const $btnRandom = $(`<button class="btn btn-default">Random</button>`).click(()=>{
            this._doReset();

            let canIncrease = Parser.ABIL_ABVS.map(it=>`pb_${it}`);
            const cpyBaseState = canIncrease.mergeMap(it=>({
                [it]: this._state[it]
            }));
            const cntRemaining = this._pb_getPointsRemaining(cpyBaseState);
            if (cntRemaining <= 0)
                return;

            for (let step = 0; step < 10000; ++step) {
                if (!canIncrease.length)
                    break;

                const prop = RollerUtil.rollOnArray(canIncrease);
                if (!this._state.pb_rules.some(rule=>rule.entity.score === cpyBaseState[prop] + 1)) {
                    canIncrease = canIncrease.filter(it=>it !== prop);
                    continue;
                }

                const draftCpyBaseState = MiscUtil.copy(cpyBaseState);
                draftCpyBaseState[prop]++;

                const cntRemaining = this._pb_getPointsRemaining(draftCpyBaseState);

                if (cntRemaining > 0) {
                    Object.assign(cpyBaseState, draftCpyBaseState);
                } else if (cntRemaining === 0) {
                    this._proxyAssignSimple("state", draftCpyBaseState);
                    break;
                } else {
                    canIncrease = canIncrease.filter(it=>it !== prop);
                }
            }
        }
        );

        return $$`<div class="ve-flex mobile__ve-flex-col mb-2">
			<div class="ve-flex-v-center">
				<div class="statgen-pb__cell mr-4 mobile__hidden"></div>

				<label class="ve-flex-col mr-2">
					<div class="mb-1 ve-text-center">Budget</div>
					${$iptBudget}
				</label>

				<label class="ve-flex-col mr-2">
					<div class="mb-1 ve-text-center">Remain</div>
					${$iptRemaining}
				</label>
			</div>

			<div class="ve-flex-v-center mobile__mt-2">
				<div class="ve-flex-col mr-2">
					<div class="mb-1 ve-text-center mobile__hidden">&nbsp;</div>
					${$btnReset}
				</div>

				<div class="ve-flex-col">
					<div class="mb-1 ve-text-center mobile__hidden">&nbsp;</div>
					${$btnRandom}
				</div>
			</div>
		</div>`;
    }

    _render_$getStgPbCustom() {
        const $btnAddLower = $(`<button class="btn btn-default btn-xs">Add Lower Score</button>`).click(()=>{
            const prevLowest = this._state.pb_rules[0];
            const score = prevLowest.entity.score - 1;
            const cost = prevLowest.entity.cost;
            this._state.pb_rules = [this._getDefaultState_pb_rule(score, cost), ...this._state.pb_rules];
        }
        );

        const $btnAddHigher = $(`<button class="btn btn-default btn-xs">Add Higher Score</button>`).click(()=>{
            const prevHighest = this._state.pb_rules.last();
            const score = prevHighest.entity.score + 1;
            const cost = prevHighest.entity.cost;
            this._state.pb_rules = [...this._state.pb_rules, this._getDefaultState_pb_rule(score, cost)];
        }
        );

        const $btnResetRules = $(`<button class="btn btn-danger btn-xs mr-2">Reset</button>`).click(()=>{
            this._state.pb_rules = this._getDefaultStatePointBuyCosts().pb_rules;
        }
        );

        const menuCustom = ContextUtil.getMenu([new ContextUtil.Action("Export as Code",async()=>{
            await MiscUtil.pCopyTextToClipboard(this._serialize_pb_rules());
            JqueryUtil.showCopiedEffect($btnContext);
        }
        ,), new ContextUtil.Action("Import from Code",async()=>{
            const raw = await InputUiUtil.pGetUserString({
                title: "Enter Code",
                isCode: true
            });
            if (raw == null)
                return;
            const parsed = this._deserialize_pb_rules(raw);
            if (parsed == null)
                return;

            const {pb_rules, pb_budget} = parsed;
            this._proxyAssignSimple("state", {
                pb_rules,
                pb_budget,
                pb_isCustom: true,
            }, );
            JqueryUtil.doToast("Imported!");
        }
        ,), ]);

        const $btnContext = $(`<button class="btn btn-default btn-xs" title="Menu"><span class="glyphicon glyphicon-option-vertical"></span></button>`).click(evt=>ContextUtil.pOpenMenu(evt, menuCustom));

        const $stgCustomCostControls = $$`<div class="ve-flex-col mb-auto ml-2 mobile__ml-0 mobile__mt-3">
			<div class="btn-group-vertical ve-flex-col mb-2">${$btnAddLower}${$btnAddHigher}</div>
			<div class="ve-flex-v-center">
				${$btnResetRules}
				${$btnContext}
			</div>
		</div>`;

        const $stgCostRows = $$`<div class="ve-flex-col"></div>`;

        const renderableCollectionRules = new StatGenUi$1.RenderableCollectionPbRules(this,$stgCostRows,);
        const hkRules = ()=>{
            renderableCollectionRules.render();

            const {min: minScore, max: maxScore} = this._pb_getMinMaxScores();
            Parser.ABIL_ABVS.forEach(it=>{
                const prop = `pb_${it}`;
                this._state[prop] = Math.min(maxScore, Math.max(minScore, this._state[prop]));
            }
            );
        };
        this._addHookBase("pb_rules", hkRules);
        hkRules();

        let lastIsCustom = this._state.pb_isCustom;
        const hkIsCustomReset = ()=>{
            $stgCustomCostControls.toggleVe(this._state.pb_isCustom);

            if (lastIsCustom === this._state.pb_isCustom)
                return;
            lastIsCustom = this._state.pb_isCustom;

            if (!this._state.pb_isCustom)
                this._state.pb_rules = this._getDefaultStatePointBuyCosts().pb_rules;
        }
        ;
        this._addHookBase("pb_isCustom", hkIsCustomReset);
        hkIsCustomReset();

        return $$`<div class="ve-flex-col">
			<h4>Ability Score Point Cost</h4>

			<div class="ve-flex-col">
				<div class="ve-flex mobile__ve-flex-col">
					<div class="ve-flex-col mr-3mobile__mr-0">
						<div class="ve-flex-v-center mb-1">
							<div class="statgen-pb__col-cost ve-flex-vh-center bold">Score</div>
							<div class="statgen-pb__col-cost ve-flex-vh-center bold">Modifier</div>
							<div class="statgen-pb__col-cost ve-flex-vh-center bold">Point Cost</div>
							<div class="statgen-pb__col-cost-delete"></div>
						</div>

						${$stgCostRows}
					</div>

					${$stgCustomCostControls}
				</div>
			</div>

			<hr class="hr-4 mb-2">

			<label class="ve-flex-v-center">
				<div class="mr-2">Custom Rules</div>
				${ComponentUiUtil.$getCbBool(this, "pb_isCustom")}
			</label>
		</div>`;
    }

    _serialize_pb_rules() {
        const out = [this._state.pb_budget, ...MiscUtil.copyFast(this._state.pb_rules).map(it=>[it.entity.score, it.entity.cost]), ];
        return JSON.stringify(out);
    }

    static _DESERIALIZE_MSG_INVALID = "Code was not valid!";

    _deserialize_pb_rules(raw) {
        let json;
        try {
            json = JSON.parse(raw);
        } catch (e) {
            JqueryUtil.doToast({
                type: "danger",
                content: `Failed to decode JSON! ${e.message}`
            });
            return null;
        }

        if (!(json instanceof Array))
            return void JqueryUtil.doToast({
                type: "danger",
                content: this.constructor._DESERIALIZE_MSG_INVALID
            });

        const [budget,...rules] = json;

        if (isNaN(budget))
            return void JqueryUtil.doToast({
                type: "danger",
                content: this.constructor._DESERIALIZE_MSG_INVALID
            });

        if (!rules.every(it=>it instanceof Array && it[0] != null && !isNaN(it[0]) && it[1] != null && !isNaN(it[1])))
            return void JqueryUtil.doToast({
                type: "danger",
                content: this.constructor._DESERIALIZE_MSG_INVALID
            });

        return {
            pb_budget: budget,
            pb_rules: rules.map(it=>this._getDefaultState_pb_rule(it[0], it[1])),
        };
    }

    

    static _RenderLevelOneEntity = class {
        _title;
        _titleShort;
        _propIxEntity;
        _propIxAbilityScoreSet;
        _propData;
        _propModalFilter;
        _propIsPreview;
        _propEntity;
        _page;
        _propChoiceMetasFrom;
        _propChoiceWeighted;

        constructor({parent}) {
            this._parent = parent;

            this._pbHookMetas = [];
        }

        render() {
            const $wrp = $(`<div class="ve-flex"></div>`);
            const $wrpOuter = $$`<div class="ve-flex-col">
				<div class="my-1 statgen-pb__header statgen-pb__header--group mr-3 ve-text-center italic ve-small help-subtle" title="Ability Score Changes from ${this._title}">${this._titleShort}</div>

				${$wrp}
			</div>`;

            this._parent._addHookBase(this._propIxEntity, ()=>this._parent.__state[this._propIxAbilityScoreSet] = 0);

            const hkIxEntity = (prop)=>{
                this._pb_unhookRender();
                const isInitialLoad = prop == null;
                if (!isInitialLoad)
                    this._parent._state[this._propChoiceMetasFrom] = [];
                if (!isInitialLoad)
                    this._parent._state[this._propChoiceWeighted] = [];
                const isAnyFromEntity = this._render_pointBuy($wrp);
                $wrpOuter.toggleVe(isAnyFromEntity);
            }
            ;
            this._parent._addHookBase(this._propIxEntity, hkIxEntity);
            this._bindAdditionalHooks_hkIxEntity(hkIxEntity);
            this._parent._addHookBase(this._propIxAbilityScoreSet, hkIxEntity);
            hkIxEntity();

            //Try to get races here
            const {$wrp: $selEntity, fnUpdateHidden: fnUpdateSelEntityHidden} = ComponentUiUtil.$getSelSearchable(this._parent, this._propIxEntity, {
                values: this._parent[this._propData].map((_,i)=>i),
                isAllowNull: true,
                fnDisplay: ix=>{
                    const r = this._parent[this._propData][ix];
                    if (!r){return "(Unknown)";}
                    return `${r.name} ${r.source !== Parser.SRC_PHB ? `[${Parser.sourceJsonToAbv(r.source)}]` : ""}`;
                }
                ,
                asMeta: true,
            }, );

            const doApplyFilterToSelEntity = ()=>{
                const f = this._parent[this._propModalFilter].pageFilter.filterBox.getValues();
                const isHiddenPerEntity = this._parent[this._propData].map(it=>!this._parent[this._propModalFilter].pageFilter.toDisplay(f, it));
                fnUpdateSelEntityHidden(isHiddenPerEntity, false);
            }
            ;

            //TEMPFIX
            //this._parent[this._propModalFilter].pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, ()=>doApplyFilterToSelEntity());
            //doApplyFilterToSelEntity();

            const $btnFilterForEntity = $(`<button class="btn btn-xs btn-default br-0 pr-2" title="Filter for ${this._title}"><span class="glyphicon glyphicon-filter"></span> Filter</button>`).click(async()=>{
                const selected = await this._parent[this._propModalFilter].pGetUserSelection();
                if (selected == null || !selected.length)
                    return;

                const selectedEntity = selected[0];
                const ixEntity = this._parent[this._propData].findIndex(it=>it.name === selectedEntity.name && it.source === selectedEntity.values.sourceJson);
                if (!~ixEntity)
                    throw new Error(`Could not find selected ${this._title.toLowerCase()}: ${JSON.stringify(selectedEntity)}`);
                this._parent._state[this._propIxEntity] = ixEntity;
            }
            );

            const $btnPreview = ComponentUiUtil.$getBtnBool(this._parent, this._propIsPreview, {
                html: `<button class="btn btn-xs btn-default" title="Toggle ${this._title} Preview"><span class="glyphicon glyphicon-eye-open"></span></button>`,
            }, );
            const hkBtnPreviewEntity = ()=>$btnPreview.toggleVe(this._parent._state[this._propIxEntity] != null && ~this._parent._state[this._propIxEntity]);
            this._parent._addHookBase(this._propIxEntity, hkBtnPreviewEntity);
            hkBtnPreviewEntity();

            const {$sel: $selAbilitySet, setValues: setValuesSelAbilitySet} = ComponentUiUtil.$getSelEnum(this._parent, this._propIxAbilityScoreSet, {
                values: [],
                asMeta: true,
                fnDisplay: ixAbSet=>{
                    const lst = this._pb_getAbilityList();
                    if (!lst?.[ixAbSet])
                        return "(Unknown)";
                    return Renderer.getAbilityData([lst[ixAbSet]]).asText;
                }
                ,
            }, );

            const $stgAbilityScoreSet = $$`<div class="ve-flex-v-center mb-2">
				<div class="mr-2">Ability Score Increase</div>
				<div>${$selAbilitySet}</div>
			</div>`;

            const hkSetValuesSelAbilitySet = ()=>{
                const entity = this._parent[this._propEntity];
                $stgAbilityScoreSet.toggleVe(!!entity && entity.ability?.length > 1);
                setValuesSelAbilitySet([...new Array(entity?.ability?.length || 0)].map((_,ix)=>ix), {
                    isForce: true
                }, );
            }
            ;
            this._parent._addHookBase(this._propIxEntity, hkSetValuesSelAbilitySet);
            this._bindAdditionalHooks_hkSetValuesSelAbilitySet(hkSetValuesSelAbilitySet);
            hkSetValuesSelAbilitySet();

            const $dispPreview = $(`<div class="ve-flex-col mb-2"></div>`);
            const hkPreviewEntity = ()=>{
                if (!this._parent._state[this._propIsPreview])
                    return $dispPreview.hideVe();

                const entity = this._parent._state[this._propIxEntity] != null ? this._parent[this._propData][this._parent._state[this._propIxEntity]] : null;
                if (!entity)
                    return $dispPreview.hideVe();

                $dispPreview.empty().showVe().append(Renderer.hover.$getHoverContent_stats(this._page, entity));
            }
            ;
            this._parent._addHookBase(this._propIxEntity, hkPreviewEntity);
            this._parent._addHookBase(this._propIsPreview, hkPreviewEntity);
            hkPreviewEntity();

            const {$hrPreview} = this._getHrPreviewMeta();

            const $stgSel = $$`<div class="ve-flex-col mt-3">
				<div class="mb-1">Select a ${this._title}</div>
				<div class="ve-flex-v-center mb-2">
					<div class="ve-flex-v-center btn-group w-100 mr-2">${$btnFilterForEntity}${$selEntity}</div>
					<div>${$btnPreview}</div>
				</div>
				${$stgAbilityScoreSet}
			</div>`;

            return {
                $wrpOuter,

                $stgSel,

                $dispPreview,
                $hrPreview,
            };
        }

        _pb_unhookRender() {
            this._pbHookMetas.forEach(it=>it.unhook());
            this._pbHookMetas = [];
        }

        _render_pointBuy($wrp) {
            $wrp.empty();

            const fromEntity = this._pb_getAbility();
            if (fromEntity == null)
                return false;

            let $ptBase = null;
            if (Parser.ABIL_ABVS.some(it=>fromEntity[it])) {
                const $wrpsEntity = Parser.ABIL_ABVS.map(ab=>{
                    return $$`<div class="my-1 statgen-pb__cell">
						<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number" readonly value="${fromEntity[ab] || 0}">
					</div>`;
                }
                );

                $ptBase = $$`<div class="ve-flex-col mr-3">
					<div class="my-1 statgen-pb__header ve-flex-vh-center">Static</div>
					${$wrpsEntity}
				</div>`;
            }

            let $ptChooseFrom = null;
            if (fromEntity.choose && fromEntity.choose.from) {
                const amount = fromEntity.choose.amount || 1;
                const count = fromEntity.choose.count || 1;

                const $wrpsChoose = Parser.ABIL_ABVS.map(ab=>{
                    if (!fromEntity.choose.from.includes(ab))
                        return `<div class="my-1 statgen-pb__cell"></div>`;

                    const $cb = $(`<input type="checkbox">`).change(()=>{
                        const existing = this._parent._state[this._propChoiceMetasFrom].find(it=>it.ability === ab);
                        if (existing) {
                            this._parent._state[this._propChoiceMetasFrom] = this._parent._state[this._propChoiceMetasFrom].filter(it=>it !== existing);
                            return;
                        }

                        if (this._parent._state[this._propChoiceMetasFrom].length >= count) {
                            while (this._parent._state[this._propChoiceMetasFrom].length >= count)
                                this._parent._state[this._propChoiceMetasFrom].shift();
                            this._parent._state[this._propChoiceMetasFrom] = [...this._parent._state[this._propChoiceMetasFrom]];
                        }

                        this._parent._state[this._propChoiceMetasFrom] = [...this._parent._state[this._propChoiceMetasFrom], {
                            ability: ab,
                            amount
                        }, ];
                    }
                    );

                    const hk = ()=>$cb.prop("checked", this._parent._state[this._propChoiceMetasFrom].some(it=>it.ability === ab));
                    this._parent._addHookBase(this._propChoiceMetasFrom, hk);
                    this._pbHookMetas.push({
                        unhook: ()=>this._parent._removeHookBase(this._propChoiceMetasFrom, hk)
                    });
                    hk();

                    return $$`<label class="my-1 statgen-pb__cell ve-flex-vh-center">${$cb}</label>`;
                }
                );

                $ptChooseFrom = $$`<div class="ve-flex-col mr-3">
					<div class="my-1 statgen-pb__header statgen-pb__header--choose-from ve-flex-vh-center">
						<div class="${count !== 1 ? `mr-1` : ""}">${UiUtil.intToBonus(amount, {
                    isPretty: true
                })}</div>${count !== 1 ? `<div class="ve-small ve-muted">(x${count})</div>` : ""}
					</div>
					${$wrpsChoose}
				</div>`;
            }

            let $ptsChooseWeighted = null;
            if (fromEntity.choose && fromEntity.choose.weighted && fromEntity.choose.weighted.weights) {
                $ptsChooseWeighted = fromEntity.choose.weighted.weights.map((weight,ixWeight)=>{
                    const $wrpsChoose = Parser.ABIL_ABVS.map(ab=>{
                        if (!fromEntity.choose.weighted.from.includes(ab))
                            return `<div class="my-1 statgen-pb__cell"></div>`;

                        const $cb = $(`<input type="checkbox">`).change(()=>{
                            const existing = this._parent._state[this._propChoiceWeighted].find(it=>it.ability === ab && it.ix === ixWeight);
                            if (existing) {
                                this._parent._state[this._propChoiceWeighted] = this._parent._state[this._propChoiceWeighted].filter(it=>it !== existing);
                                return;
                            }

                            const withSameAbil = this._parent._state[this._propChoiceWeighted].filter(it=>it.ability === ab || it.ix === ixWeight);
                            if (withSameAbil.length) {
                                this._parent._state[this._propChoiceWeighted] = this._parent._state[this._propChoiceWeighted].filter(it=>it.ability !== ab && it.ix !== ixWeight);
                            }

                            this._parent._state[this._propChoiceWeighted] = [...this._parent._state[this._propChoiceWeighted], {
                                ability: ab,
                                amount: weight,
                                ix: ixWeight
                            }, ];
                        }
                        );

                        const hk = ()=>{
                            $cb.prop("checked", this._parent._state[this._propChoiceWeighted].some(it=>it.ability === ab && it.ix === ixWeight));
                        }
                        ;
                        this._parent._addHookBase(this._propChoiceWeighted, hk);
                        this._pbHookMetas.push({
                            unhook: ()=>this._parent._removeHookBase(this._propChoiceWeighted, hk)
                        });
                        hk();

                        return $$`<label class="my-1 statgen-pb__cell ve-flex-vh-center">${$cb}</label>`;
                    }
                    );

                    return $$`<div class="ve-flex-col mr-3">
						<div class="my-1 statgen-pb__header statgen-pb__header--choose-from ve-flex-vh-center">${UiUtil.intToBonus(weight, {
                        isPretty: true
                    })}</div>
						${$wrpsChoose}
					</div>`;
                }
                );
            }

            $$($wrp)`
				${$ptBase}
				${$ptChooseFrom}
				${$ptsChooseWeighted}
			`;

            return $ptBase || $ptChooseFrom || $ptsChooseWeighted;
        }

        _pb_getAbilityList() {
            throw new Error("Unimplemented!");
        }

        _pb_getAbility() {
            throw new Error("Unimplemented!");
        }

        _bindAdditionalHooks_hkIxEntity(hkIxEntity) {}
        _bindAdditionalHooks_hkSetValuesSelAbilitySet(hkSetValuesSelAbilitySet) {}

        _getHrPreviewMeta() {
            const $hrPreview = $(`<hr class="hr-3">`);
            const hkPreview = this._getHkPreview({
                $hrPreview
            });
            this._parent._addHookBase(this._propIsPreview, hkPreview);
            hkPreview();

            return {
                $hrPreview,
                hkPreview,
            };
        }

        _getHkPreview({$hrPreview}) {
            return ()=>$hrPreview.toggleVe(this._parent._state[this._propIsPreview]);
        }
    }
    ;

    static _RenderLevelOneRace = class extends this._RenderLevelOneEntity {
        _title = "Race";
        _titleShort = "Race";
        _propIxEntity = "common_ixRace";
        _propIxAbilityScoreSet = "common_ixAbilityScoreSetRace";
        _propData = "_races";
        _propModalFilter = "_modalFilterRaces";
        _propIsPreview = "common_isPreviewRace";
        _propEntity = "race";
        _page = UrlUtil.PG_RACES;
        _propChoiceMetasFrom = "common_raceChoiceMetasFrom";
        _propChoiceWeighted = "common_raceChoiceMetasWeighted";

        render() {
            const out = super.render();

            const {$btnToggleTashasPin, $dispTashas} = this._$getPtsTashas();

            out.$stgSel.append($$`<label class="ve-flex-v-center mb-1">
				<div class="mr-2">Allow Origin Customization</div>
				${ComponentUiUtil.$getCbBool(this._parent, "common_isTashas")}
			</label>`);

            out.$stgSel.append($$`<div class="ve-flex">
				<div class="ve-small ve-muted italic mr-1">${Renderer.get().render(`An {@variantrule Customizing Your Origin|TCE|optional rule}`)}</div>
				${$btnToggleTashasPin}
				<div class="ve-small ve-muted italic ml-1">${Renderer.get().render(`from Tasha's Cauldron of Everything, page 8.`)}</div>
			</div>`);

            out.$dispTashas = $dispTashas;

            return out;
        }

        _pb_getAbilityList() {
            return this._parent._pb_getRaceAbilityList();
        }

        _pb_getAbility() {
            return this._parent._pb_getRaceAbility();
        }

        _bindAdditionalHooks_hkIxEntity(hkIxEntity) {
            this._parent._addHookBase("common_isTashas", hkIxEntity);
        }

        _bindAdditionalHooks_hkSetValuesSelAbilitySet(hkSetValuesSelAbilitySet) {
            this._parent._addHookBase("common_isTashas", hkSetValuesSelAbilitySet);
        }

        _getHrPreviewMeta() {
            const out = super._getHrPreviewMeta();
            const {hkPreview} = out;
            this._parent._addHookBase("common_isShowTashasRules", hkPreview);
            return out;
        }

        _getHkPreview({$hrPreview}) {
            return ()=>$hrPreview.toggleVe(this._parent._state[this._propIsPreview] && this._parent._state.common_isShowTashasRules);
        }

        _$getPtsTashas() {
            const $btnToggleTashasPin = ComponentUiUtil.$getBtnBool(this._parent, "common_isShowTashasRules", {
                html: `<button class="btn btn-xxs btn-default ve-small p-0 statgen-shared__btn-toggle-tashas-rules ve-flex-vh-center" title="Toggle &quot;Customizing Your Origin&quot; Section"><span class="glyphicon glyphicon-eye-open"></span></button>`,
            }, );

            const $dispTashas = $(`<div class="ve-flex-col"><div class="italic ve-muted">Loading...</div></div>`);
            DataLoader.pCacheAndGet(UrlUtil.PG_VARIANTRULES, Parser.SRC_TCE, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES]({
                name: "Customizing Your Origin",
                source: Parser.SRC_TCE
            })).then(rule=>{
                $$($dispTashas.empty())`${Renderer.hover.$getHoverContent_stats(UrlUtil.PG_VARIANTRULES, rule)}<hr class="hr-3">`;
            }
            );
            const hkIsShowTashas = ()=>{
                $dispTashas.toggleVe(this._parent._state.common_isShowTashasRules);
            }
            ;
            this._parent._addHookBase("common_isShowTashasRules", hkIsShowTashas);
            hkIsShowTashas();

            return {
                $btnToggleTashasPin,
                $dispTashas,
            };
        }
    }
    ;

    _renderLevelOneRace = new this.constructor._RenderLevelOneRace({
        parent: this
    });

    static _RenderLevelOneBackground = class extends this._RenderLevelOneEntity {
        _title = "Background";
        _titleShort = "Backg.";
        _propIxEntity = "common_ixBackground";
        _propIxAbilityScoreSet = "common_ixAbilityScoreSetBackground";
        _propData = "_backgrounds";
        _propModalFilter = "_modalFilterBackgrounds";
        _propIsPreview = "common_isPreviewBackground";
        _propEntity = "background";
        _page = UrlUtil.PG_BACKGROUNDS;
        _propChoiceMetasFrom = "common_backgroundChoiceMetasFrom";
        _propChoiceWeighted = "common_backgroundChoiceMetasWeighted";

        _pb_getAbilityList() {
            return this._parent._pb_getBackgroundAbilityList();
        }

        _pb_getAbility() {
            return this._parent._pb_getBackgroundAbility();
        }
    }
    ;

    _renderLevelOneBackground = new this.constructor._RenderLevelOneBackground({
        parent: this
    });

    _render_isLevelUp($wrpTab) {
        const $wrpsExisting = Parser.ABIL_ABVS.map(ab=>{
            const $iptExisting = $(`<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number" readonly>`).val(this._existingScores[ab]);

            return $$`<label class="my-1 statgen-pb__cell">
				${$iptExisting}
			</label>`;
        }
        );

        const $wrpsUser = this._render_$getWrpsUser();

        const metasTotalAndMod = this._render_getMetasTotalAndMod();

        const $wrpAsi = this._render_$getWrpAsi();

        $$($wrpTab)`
			<div class="ve-flex mobile-ish__ve-flex-col w-100 px-3">
				<div class="ve-flex-col">
					<div class="ve-flex">
						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>

							${Parser.ABIL_ABVS.map(it=>`<div class="my-1 bold statgen-pb__cell ve-flex-v-center ve-flex-h-right" title="${Parser.attAbvToFull(it)}">${it.toUpperCase()}</div>`)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 bold statgen-pb__header ve-flex-vh-center" title="Current">Curr.</div>
							${$wrpsExisting}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header ve-flex-vh-center help text-muted" title="Input any additional/custom bonuses here">User</div>
							${$wrpsUser}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header ve-flex-vh-center">Total</div>
							${metasTotalAndMod.map(it=>it.$wrpIptTotal)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header ve-flex-vh-center" title="Modifier">Mod.</div>
							${metasTotalAndMod.map(it=>it.$wrpIptMod)}
						</div>
					</div>
				</div>
			</div>

			<hr class="hr-3">

			${$wrpAsi}
		`;
    }

    _render_$getWrpsUser() {
        return Parser.ABIL_ABVS.map(ab=>{
            const {propUserBonus} = this.constructor._common_getProps(ab);
            const $ipt = ComponentUiUtil.$getIptInt(this, propUserBonus, 0, {
                fallbackOnNaN: 0,
                html: `<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number">`,
            }, );
            return $$`<label class="my-1 statgen-pb__cell">${$ipt}</label>`;
        }
        );
    }

    _render_getMetasTotalAndMod() {
        return Parser.ABIL_ABVS.map(ab=>{
            const $iptTotal = $(`<input class="form-control form-control--minimal statgen-shared__ipt ve-text-center" type="text" readonly>`);
            const $iptMod = $(`<input class="form-control form-control--minimal statgen-shared__ipt ve-text-center" type="text" readonly>`);

            const $wrpIptTotal = $$`<label class="my-1 statgen-pb__cell">${$iptTotal}</label>`;
            const $wrpIptMod = $$`<label class="my-1 statgen-pb__cell">${$iptMod}</label>`;

            const exportedStateProp = `common_export_${ab}`;

            const getTotalScore = ()=>{
                if (this._isLevelUp)
                    return this._levelUp_getTotalScore(ab);
                switch (this.ixActiveTab) {
                case this._IX_TAB_ROLLED:
                    return this._rolled_getTotalScore(ab);
                case this._IX_TAB_ARRAY:
                    return this._array_getTotalScore(ab);
                case this._IX_TAB_PB:
                    return this._pb_getTotalScore(ab);
                case this._IX_TAB_MANUAL:
                    return this._manual_getTotalScore(ab);
                default:
                    return 0;
                }
            }
            ;

            const hk = ()=>{
                const totalScore = getTotalScore();

                const isOverLimit = totalScore > 20;
                $iptTotal.val(totalScore).toggleClass("form-control--error", isOverLimit).title(isOverLimit ? `In general, you can't increase an ability score above 20.` : "");
                $iptMod.val(Parser.getAbilityModifier(totalScore));

                this._state[exportedStateProp] = totalScore;
            }
            ;
            this._addHookAll("state", hk);
            this._addHookActiveTab(hk);
            hk();

            return {
                $wrpIptTotal,
                $wrpIptMod,
            };
        }
        );
    }

    _render_$getWrpAsi() {
        const $wrpAsi = $(`<div class="ve-flex-col w-100"></div>`);
        this._compAsi.render($wrpAsi);
        return $wrpAsi;
    }

    static _common_getProps(ab) {
        return {
            propUserBonus: `${StatGenUi$1._PROP_PREFIX_COMMON}${ab}_user`,
        };
    }

    static _rolled_getProps(ab) {
        return {
            propAbilSelectedRollIx: `${StatGenUi$1._PROP_PREFIX_ROLLED}${ab}_abilSelectedRollIx`,
        };
    }

    static _array_getProps(ab) {
        return {
            propAbilSelectedScoreIx: `${StatGenUi$1._PROP_PREFIX_ARRAY}${ab}_abilSelectedScoreIx`,
        };
    }

    static _manual_getProps(ab) {
        return {
            propAbilValue: `${StatGenUi$1._PROP_PREFIX_MANUAL}${ab}_abilValue`,
        };
    }

    _pb_getRaceAbilityList() {
        const race = this.race;
        if (!race?.ability?.length){return null;}

        return race.ability.map(fromRace=>{
            if (this._state.common_isTashas) {
                const weights = [];

                if (fromRace.choose && fromRace.choose.weighted && fromRace.choose.weighted.weights) {
                    weights.push(...fromRace.choose.weighted.weights);
                }

                Parser.ABIL_ABVS.forEach(it=>{
                    if (fromRace[it])
                        weights.push(fromRace[it]);
                }
                );

                if (fromRace.choose && fromRace.choose.from) {
                    const count = fromRace.choose.count || 1;
                    const amount = fromRace.choose.amount || 1;
                    for (let i = 0; i < count; ++i)
                        weights.push(amount);
                }

                weights.sort((a,b)=>SortUtil.ascSort(b, a));

                fromRace = {
                    choose: {
                        weighted: {
                            from: [...Parser.ABIL_ABVS],
                            weights,
                        },
                    },
                };
            }

            return fromRace;
        });
    }

    _pb_getBackgroundAbilityList() {
        const background = this.background;
        if (!background?.ability?.length)
            return null;
        return background.ability;
    }

    _pb_getRaceAbility() {
        return this._pb_getRaceAbilityList()?.[this._state.common_ixAbilityScoreSetRace || 0];
    }

    _pb_getBackgroundAbility() {
        return this._pb_getBackgroundAbilityList()?.[this._state.common_ixAbilityScoreSetBackground || 0];
    }

    _pb_getPointsRemaining(baseState) {
        const spent = Parser.ABIL_ABVS.map(it=>{
            const prop = `pb_${it}`;
            const score = baseState[prop];
            const rule = this._state.pb_rules.find(it=>it.entity.score === score);
            if (!rule)
                return 0;
            return rule.entity.cost;
        }
        ).reduce((a,b)=>a + b, 0);

        return this._state.pb_budget - spent;
    }

    _rolled_getTotalScore(ab) {
        const {propAbilSelectedRollIx} = this.constructor._rolled_getProps(ab);
        const {propUserBonus} = this.constructor._common_getProps(ab);
        return (this._state.rolled_rolls[this._state[propAbilSelectedRollIx]] || {
            total: 0
        }).total + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
    }

    _array_getTotalScore(ab) {
        const {propAbilSelectedScoreIx} = this.constructor._array_getProps(ab);
        const {propUserBonus} = this.constructor._common_getProps(ab);
        return (StatGenUi$1._STANDARD_ARRAY[this._state[propAbilSelectedScoreIx]] || 0) + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
    }

    _pb_getTotalScore(ab) {
        const prop = `pb_${ab}`;
        const {propUserBonus} = this.constructor._common_getProps(ab);
        return this._state[prop] + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
    }

    _manual_getTotalScore(ab) {
        const {propAbilValue} = this.constructor._manual_getProps(ab);
        const {propUserBonus} = this.constructor._common_getProps(ab);
        return (this._state[propAbilValue] || 0) + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
    }

    _levelUp_getTotalScore(ab) {
        const {propUserBonus} = this.constructor._common_getProps(ab);
        return (this._existingScores[ab] || 0) + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
    }

    _getTotalScore_getBonuses(ab) {
        let total = 0;

        if (!this._isLevelUp) {
            const handleEntityAbility = ({fromEntity, propChoiceMetasFrom, propChoiceWeighted})=>{
                if (fromEntity) {
                    if (fromEntity[ab])
                        total += fromEntity[ab];

                    if (fromEntity.choose && fromEntity.choose.from) {
                        total += this._state[propChoiceMetasFrom].filter(it=>it.ability === ab).map(it=>it.amount).reduce((a,b)=>a + b, 0);
                    }

                    if (fromEntity.choose && fromEntity.choose.weighted && fromEntity.choose.weighted.weights) {
                        total += this._state[propChoiceWeighted].filter(it=>it.ability === ab).map(it=>it.amount).reduce((a,b)=>a + b, 0);
                    }
                }
            }
            ;

            handleEntityAbility({
                fromEntity: this._pb_getRaceAbility(),
                propChoiceMetasFrom: "common_raceChoiceMetasFrom",
                propChoiceWeighted: "common_raceChoiceMetasWeighted",
            });

            handleEntityAbility({
                fromEntity: this._pb_getBackgroundAbility(),
                propChoiceMetasFrom: "common_backgroundChoiceMetasFrom",
                propChoiceWeighted: "common_backgroundChoiceMetasWeighted",
            });
        }

        const formDataAsi = this._compAsi.getFormData();
        if (formDataAsi)
            total += formDataAsi.data[ab] || 0;

        return total;
    }

    getSaveableState() {
        const out = super.getSaveableState();

        const handleEntity = ({propIxEntity, page, propData, propHash})=>{
            if (out[propIxEntity] != null && !~this._state[propIxEntity]) {
                out[propHash] = UrlUtil.URL_TO_HASH_BUILDER[page](this[propData][out[propIxEntity]]);
                delete out[propIxEntity];
            }
        }
        ;

        handleEntity({
            propIxEntity: "common_ixRace",
            page: UrlUtil.PG_RACES,
            propData: "_races",
            propHash: "_pb_raceHash",
        });

        handleEntity({
            propIxEntity: "common_ixBackground",
            page: UrlUtil.PG_BACKGROUNDS,
            propData: "_backgrounds",
            propHash: "_pb_backgroundHash",
        });

        return out;
    }

    getSaveableStatePointBuyCustom() {
        const base = this.getSaveableState();
        return {
            state: this.constructor._PROPS_POINT_BUY_CUSTOM.mergeMap(k=>({
                [k]: base.state[k]
            })),
        };
    }

    setStateFrom(saved, isOverwrite=false) {
        saved = MiscUtil.copy(saved);

        MiscUtil.getOrSet(saved, "state", {});

        const handleEntityHash = ({propHash, page, propData, propIxEntity})=>{
            if (!saved[propHash])
                return;

            const ixEntity = this[propData].findIndex(it=>{
                const hash = UrlUtil.URL_TO_HASH_BUILDER[page](it);
                return hash === saved[propHash];
            }
            );
            if (~ixEntity)
                saved[propIxEntity] = ixEntity;
        }
        ;

        handleEntityHash({
            propHash: "_pb_raceHash",
            page: UrlUtil.PG_RACES,
            propData: "_races",
            propIxEntity: "common_ixRace",
        });

        handleEntityHash({
            propHash: "_pb_backgroundHash",
            page: UrlUtil.PG_BACKGROUNDS,
            propData: "_backgrounds",
            propIxEntity: "common_ixBackground",
        });

        const validKeys = new Set(Object.keys(this._getDefaultState()));
        const validKeyPrefixes = [StatGenUi$1._PROP_PREFIX_COMMON, StatGenUi$1._PROP_PREFIX_ROLLED, StatGenUi$1._PROP_PREFIX_ARRAY, StatGenUi$1._PROP_PREFIX_MANUAL, ];

        Object.keys(saved.state).filter(k=>!validKeys.has(k) && !validKeyPrefixes.some(it=>k.startsWith(it))).forEach(k=>delete saved.state[k]);

        for (let i = saved.state.common_cntAsi || 0; i < 1000; ++i) {
            const {propMode, prefix} = this.getPropsAsi(i, "ability");
            if (saved.state[propMode])
                Object.keys(saved.state).filter(k=>k.startsWith(prefix)).forEach(k=>delete saved.state[k]);
        }

        for (let i = saved.state.common_cntFeatsCustom || 0; i < 1000; ++i) {
            const {propMode, prefix} = this.getPropsAsi(i, "custom");
            if (saved.state[propMode])
                Object.keys(saved.state).filter(k=>k.startsWith(prefix)).forEach(k=>delete saved.state[k]);
        }

        super.setStateFrom(saved, isOverwrite);
    }

    _pb_getMinMaxScores() {
        return {
            min: Math.min(...this._state.pb_rules.map(it=>it.entity.score)),
            max: Math.max(...this._state.pb_rules.map(it=>it.entity.score)),
        };
    }

    _getDefaultStateCommonResettable() {
        return {
            ...Parser.ABIL_ABVS.mergeMap(ab=>({
                [this.constructor._common_getProps(ab).propUserBonus]: 0
            })),

            common_raceChoiceMetasFrom: [],
            common_raceChoiceMetasWeighted: [],

            common_backgroundChoiceMetasFrom: [],
            common_backgroundChoiceMetasWeighted: [],
        };
    }

    _getDefaultStateNoneResettable() {
        return {};
    }

    _getDefaultStateRolledResettable() {
        return {
            ...Parser.ABIL_ABVS.mergeMap(ab=>({
                [this.constructor._rolled_getProps(ab).propAbilSelectedRollIx]: null
            })),
        };
    }

    _getDefaultStateArrayResettable() {
        return {
            ...Parser.ABIL_ABVS.mergeMap(ab=>({
                [this.constructor._array_getProps(ab).propAbilSelectedScoreIx]: null
            })),
        };
    }

    _getDefaultStatePointBuyResettable() {
        return {
            pb_str: 8,
            pb_dex: 8,
            pb_con: 8,
            pb_int: 8,
            pb_wis: 8,
            pb_cha: 8,
        };
    }

    _getDefaultStatePointBuyCosts() {
        return {
            pb_rules: [{
                score: 8,
                cost: 0
            }, {
                score: 9,
                cost: 1
            }, {
                score: 10,
                cost: 2
            }, {
                score: 11,
                cost: 3
            }, {
                score: 12,
                cost: 4
            }, {
                score: 13,
                cost: 5
            }, {
                score: 14,
                cost: 7
            }, {
                score: 15,
                cost: 9
            }, ].map(({score, cost})=>this._getDefaultState_pb_rule(score, cost)),
        };
    }

    _getDefaultState_pb_rule(score, cost) {
        return {
            id: CryptUtil.uid(),
            entity: {
                score,
                cost,
            },
        };
    }

    _getDefaultStateManualResettable() {
        return {
            ...Parser.ABIL_ABVS.mergeMap(ab=>({
                [this.constructor._manual_getProps(ab).propAbilValue]: null
            })),
        };
    }

    _getDefaultState() {
        return {
            common_isPreviewRace: false,
            common_isTashas: false,
            common_isShowTashasRules: false,
            common_ixRace: null,
            common_ixAbilityScoreSet: 0,

            common_isPreviewBackground: false,
            common_ixBackground: null,
            common_ixAbilityScoreSetBackground: 0,

            common_pulseAsi: false,
            common_cntAsi: 0,
            common_cntFeatsCustom: 0,

            common_export_str: null,
            common_export_dex: null,
            common_export_con: null,
            common_export_int: null,
            common_export_wis: null,
            common_export_cha: null,

            ...this._getDefaultStateCommonResettable(),

            rolled_formula: "4d6dl1",
            rolled_rollCount: 6,
            rolled_rolls: [],
            ...this._getDefaultStateRolledResettable(),

            ...this._getDefaultStateArrayResettable(),

            ...this._getDefaultStatePointBuyResettable(),
            ...this._getDefaultStatePointBuyCosts(),

            pb_points: 27,
            pb_budget: 27,

            pb_isCustom: false,

            ...this._getDefaultStateManualResettable(),
        };
    }
}
;

StatGenUi$1._STANDARD_ARRAY = [15, 14, 13, 12, 10, 8];
StatGenUi$1._PROP_PREFIX_COMMON = "common_";
StatGenUi$1._PROP_PREFIX_ROLLED = "rolled_";
StatGenUi$1._PROP_PREFIX_ARRAY = "array_";
StatGenUi$1._PROP_PREFIX_MANUAL = "manual_";
StatGenUi$1.MODE_NONE = "none";
StatGenUi$1.MODES = ["rolled", "array", "pointbuy", "manual", ];
StatGenUi$1.MODES_FVTT = [StatGenUi$1.MODE_NONE, ...StatGenUi$1.MODES, ];
StatGenUi$1._MAX_CUSTOM_FEATS = 20;
globalThis.StatGenUi = StatGenUi$1;
StatGenUi$1.CompAsi = class extends BaseComponent {
    constructor({parent}) {
        super();
        this._parent = parent;

        this._metasAsi = {
            ability: [],
            race: [],
            background: [],
            custom: []
        };

        this._doPulseThrottled = MiscUtil.throttle(this._doPulse_.bind(this), 50);
    }

    _doPulse_() {
        this._parent.state.common_pulseAsi = !this._parent.state.common_pulseAsi;
    }

    _render_renderAsiFeatSection(propCnt, namespace, $wrpRows) {
        const hk = ()=>{
            let ix = 0;

            for (; ix < this._parent.state[propCnt]; ++ix) {
                const ix_ = ix;
                const {propMode, propIxFeat, propIxAsiPointOne, propIxAsiPointTwo, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAsi(ix_, namespace);

                if (!this._metasAsi[namespace][ix_]) {
                    this._parent.state[propMode] = this._parent.state[propMode] || (namespace === "ability" ? "asi" : "feat");

                    const $btnAsi = namespace !== "ability" ? null : $(`<button class="btn btn-xs btn-default w-50p">ASI</button>`).click(()=>{
                        this._parent.state[propMode] = "asi";
                        this._doPulseThrottled();
                    }
                    );

                    const $btnFeat = namespace !== "ability" ? $(`<div class="w-100p ve-text-center">Feat</div>`) : $(`<button class="btn btn-xs btn-default w-50p">Feat</button>`).click(()=>{
                        this._parent.state[propMode] = "feat";
                        this._doPulseThrottled();
                    }
                    );

                    let $stgAsi;
                    if (namespace === "ability") {
                        const $colsAsi = Parser.ABIL_ABVS.map((it,ixAsi)=>{
                            const updateDisplay = ()=>$ipt.val(Number(this._parent.state[propIxAsiPointOne] === ixAsi) + Number(this._parent.state[propIxAsiPointTwo] === ixAsi));

                            const $ipt = $(`<input class="form-control form-control--minimal text-right input-xs statgen-shared__ipt" type="number" style="width: 42px;">`).disableSpellcheck().keydown(evt=>{
                                if (evt.key === "Escape")
                                    $ipt.blur();
                            }
                            ).change(()=>{
                                const raw = $ipt.val().trim();
                                const asNum = Number(raw);

                                const activeProps = [propIxAsiPointOne, propIxAsiPointTwo].filter(prop=>this._parent.state[prop] === ixAsi);

                                if (isNaN(asNum) || asNum <= 0) {
                                    this._parent.proxyAssignSimple("state", {
                                        ...activeProps.mergeMap(prop=>({
                                            [prop]: null
                                        })),
                                    }, );
                                    updateDisplay();
                                    return this._doPulseThrottled();
                                }

                                if (asNum >= 2) {
                                    this._parent.proxyAssignSimple("state", {
                                        [propIxAsiPointOne]: ixAsi,
                                        [propIxAsiPointTwo]: ixAsi,
                                    }, );
                                    updateDisplay();
                                    return this._doPulseThrottled();
                                }

                                if (activeProps.length === 2) {
                                    this._parent.state[propIxAsiPointTwo] = null;
                                    updateDisplay();
                                    return this._doPulseThrottled();
                                }

                                if (this._parent.state[propIxAsiPointOne] == null) {
                                    this._parent.state[propIxAsiPointOne] = ixAsi;
                                    updateDisplay();
                                    return this._doPulseThrottled();
                                }

                                this._parent.state[propIxAsiPointTwo] = ixAsi;
                                updateDisplay();
                                this._doPulseThrottled();
                            }
                            );

                            const hkSelected = ()=>updateDisplay();
                            this._parent.addHookBase(propIxAsiPointOne, hkSelected);
                            this._parent.addHookBase(propIxAsiPointTwo, hkSelected);
                            hkSelected();

                            return $$`<div class="ve-flex-col h-100 mr-2">
							<div class="statgen-asi__cell ve-text-center pb-1" title="${Parser.attAbvToFull(it)}">${it.toUpperCase()}</div>
							<div class="ve-flex-vh-center statgen-asi__cell relative">
								<div class="absolute no-events statgen-asi__disp-plus">+</div>
								${$ipt}
							</div>
						</div>`;
                        }
                        );

                        $stgAsi = $$`<div class="ve-flex-v-center">
							${$colsAsi}
						</div>`;
                    }

                    const {$stgFeat, $btnChooseFeat, hkIxFeat} = this._render_getMetaFeat({
                        propIxFeat,
                        propIxFeatAbility,
                        propFeatAbilityChooseFrom
                    });

                    const hkMode = ()=>{
                        if (namespace === "ability") {
                            $btnAsi.toggleClass("active", this._parent.state[propMode] === "asi");
                            $btnFeat.toggleClass("active", this._parent.state[propMode] === "feat");
                        }

                        $btnChooseFeat.toggleVe(this._parent.state[propMode] === "feat");

                        if (namespace === "ability")
                            $stgAsi.toggleVe(this._parent.state[propMode] === "asi");
                        $stgFeat.toggleVe(this._parent.state[propMode] === "feat");

                        hkIxFeat();
                    }
                    ;
                    this._parent.addHookBase(propMode, hkMode);
                    hkMode();

                    const $row = $$`<div class="ve-flex-v-end py-3 px-1">
						<div class="btn-group">${$btnAsi}${$btnFeat}</div>
						<div class="vr-4"></div>
						${$stgAsi}
						${$stgFeat}
					</div>`.appendTo($wrpRows);

                    this._metasAsi[namespace][ix_] = {
                        $row,
                    };
                }

                this._metasAsi[namespace][ix_].$row.showVe().addClass("statgen-asi__row");
            }

            if (this._metasAsi[namespace][ix - 1])
                this._metasAsi[namespace][ix - 1].$row.removeClass("statgen-asi__row");

            for (; ix < this._metasAsi[namespace].length; ++ix) {
                if (!this._metasAsi[namespace][ix])
                    continue;
                this._metasAsi[namespace][ix].$row.hideVe().removeClass("statgen-asi__row");
            }
        }
        ;
        this._parent.addHookBase(propCnt, hk);
        hk();
    }

    _render_renderAdditionalFeatSection({namespace, $wrpRows, propEntity}) {
        const fnsCleanupEnt = [];
        const fnsCleanupGroup = [];

        const {propIxSel, propPrefix} = this._parent.getPropsAdditionalFeats_(namespace);

        const resetGroupState = ()=>{
            const nxtState = Object.keys(this._parent.state).filter(k=>k.startsWith(propPrefix) && k !== propIxSel).mergeMap(k=>({
                [k]: null
            }));
            this._parent.proxyAssignSimple("state", nxtState);
        }
        ;

        const hkEnt = (isNotFirstRun)=>{
            fnsCleanupEnt.splice(0, fnsCleanupEnt.length).forEach(fn=>fn());
            fnsCleanupGroup.splice(0, fnsCleanupGroup.length).forEach(fn=>fn());
            $wrpRows.empty();

            if (isNotFirstRun)
                resetGroupState();

            const ent = this._parent[namespace];
            if ((ent?.feats?.length || 0) > 1) {
                const {$sel: $selGroup, unhook: unhookIxGroup} = UtilAdditionalFeats$1.getSelIxSetMeta({
                    comp: this._parent,
                    prop: propIxSel,
                    available: ent.feats
                });
                fnsCleanupEnt.push(unhookIxGroup);
                $$`<div class="ve-flex-col mb-2">
					<div class="ve-flex-v-center mb-2">
						<div class="mr-2">Feat Set:</div>
						${$selGroup.addClass("max-w-200p")}
					</div>
				</div>`.appendTo($wrpRows);
            } else {
                this._parent.state[propIxSel] = 0;
            }

            const $wrpRowsInner = $(`<div class="w-100 ve-flex-col min-h-0"></div>`).appendTo($wrpRows);

            const hkIxSel = (isNotFirstRun)=>{
                fnsCleanupGroup.splice(0, fnsCleanupGroup.length).forEach(fn=>fn());
                $wrpRowsInner.empty();

                if (isNotFirstRun)
                    resetGroupState();

                const featSet = ent?.feats?.[this._parent.state[propIxSel]];

                const uidsStatic = UtilAdditionalFeats$1.getUidsStatic(featSet);

                const $rows = [];

                uidsStatic.map((uid,ix)=>{
                    const {propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "static", ix);
                    const {name, source} = DataUtil.proxy.unpackUid("feat", uid, "feat", {
                        isLower: true
                    });
                    const feat = this._parent.feats.find(it=>it.name.toLowerCase() === name && it.source.toLowerCase() === source);
                    const {$stgFeat, hkIxFeat, cleanup} = this._render_getMetaFeat({
                        featStatic: feat,
                        propIxFeatAbility,
                        propFeatAbilityChooseFrom
                    });
                    fnsCleanupGroup.push(cleanup);
                    hkIxFeat();

                    const $row = $$`<div class="ve-flex-v-end py-3 px-1 statgen-asi__row">
						<div class="btn-group"><div class="w-100p ve-text-center">Feat</div></div>
						<div class="vr-4"></div>
						${$stgFeat}
					</div>`.appendTo($wrpRowsInner);
                    $rows.push($row);
                }
                );

                [...new Array(featSet?.any || 0)].map((_,ix)=>{
                    const {propIxFeat, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "fromFilter", ix);
                    const {$stgFeat, hkIxFeat, cleanup} = this._render_getMetaFeat({
                        propIxFeat,
                        propIxFeatAbility,
                        propFeatAbilityChooseFrom
                    });
                    fnsCleanupGroup.push(cleanup);
                    hkIxFeat();

                    const $row = $$`<div class="ve-flex-v-end py-3 px-1 statgen-asi__row">
						<div class="btn-group"><div class="w-100p ve-text-center">Feat</div></div>
						<div class="vr-4"></div>
						${$stgFeat}
					</div>`.appendTo($wrpRowsInner);
                    $rows.push($row);
                }
                );

                if ($rows.last())
                    $rows.last().removeClass("statgen-asi__row");

                this._doPulseThrottled();
            }
            ;
            this._parent.addHookBase(propIxSel, hkIxSel);
            fnsCleanupEnt.push(()=>this._parent.removeHookBase(propIxSel, hkIxSel));
            hkIxSel();
            this._doPulseThrottled();
        }
        ;
        this._parent.addHookBase(propEntity, hkEnt);
        hkEnt();
    }

    _render_getMetaFeat({featStatic=null, propIxFeat=null, propIxFeatAbility, propFeatAbilityChooseFrom}) {
        if (featStatic && propIxFeat)
            throw new Error(`Cannot combine static feat and feat property!`);
        if (featStatic == null && propIxFeat == null)
            throw new Error(`Either a static feat or a feat property must be specified!`);

        const $btnChooseFeat = featStatic ? null : $(`<button class="btn btn-xxs btn-default mr-2" title="Choose a Feat"><span class="glyphicon glyphicon-search"></span></button>`).click(async()=>{
            const selecteds = await this._parent.modalFilterFeats.pGetUserSelection();
            if (selecteds == null || !selecteds.length)
                return;

            const selected = selecteds[0];
            const ix = this._parent.feats.findIndex(it=>it.name === selected.name && it.source === selected.values.sourceJson);
            if (!~ix)
                throw new Error(`Could not find selected entity: ${JSON.stringify(selected)}`);
            this._parent.state[propIxFeat] = ix;

            this._doPulseThrottled();
        }
        );

        const $dispFeat = $(`<div class="ve-flex-v-center mr-2"></div>`);
        const $stgSelectAbilitySet = $$`<div class="ve-flex-v-center mr-2"></div>`;
        const $stgFeatNoChoice = $$`<div class="ve-flex-v-center mr-2"></div>`;
        const $stgFeatChooseAsiFrom = $$`<div class="ve-flex-v-end"></div>`;
        const $stgFeatChooseAsiWeighted = $$`<div class="ve-flex-v-center"></div>`;

        const $stgFeat = $$`<div class="ve-flex-v-center">
			${$btnChooseFeat}
			${$dispFeat}
			${$stgSelectAbilitySet}
			${$stgFeatNoChoice}
			${$stgFeatChooseAsiFrom}
			${$stgFeatChooseAsiWeighted}
		</div>`;

        const fnsCleanup = [];
        const fnsCleanupFeat = [];
        const fnsCleanupFeatAbility = [];

        const hkIxFeat = (isNotFirstRun)=>{
            fnsCleanupFeat.splice(0, fnsCleanupFeat.length).forEach(fn=>fn());
            fnsCleanupFeatAbility.splice(0, fnsCleanupFeatAbility.length).forEach(fn=>fn());

            if (isNotFirstRun) {
                const nxtState = Object.keys(this._parent.state).filter(it=>it.startsWith(propFeatAbilityChooseFrom)).mergeMap(it=>({
                    [it]: null
                }));
                this._parent.proxyAssignSimple("state", nxtState);
            }

            const feat = featStatic || this._parent.feats[this._parent.state[propIxFeat]];

            $stgFeat.removeClass("ve-flex-v-end").addClass("ve-flex-v-center");
            $dispFeat.toggleClass("italic ve-muted", !feat);
            $dispFeat.html(feat ? Renderer.get().render(`{@feat ${feat.name.toLowerCase()}|${feat.source}}`) : `(Choose a feat)`);

            this._parent.state[propIxFeatAbility] = 0;

            $stgSelectAbilitySet.hideVe();
            if (feat) {
                if (feat.ability && feat.ability.length > 1) {
                    const metaChooseAbilitySet = ComponentUiUtil.$getSelEnum(this._parent, propIxFeatAbility, {
                        values: feat.ability.map((_,i)=>i),
                        fnDisplay: ix=>Renderer.getAbilityData([feat.ability[ix]]).asText,
                        asMeta: true,
                    }, );

                    $stgSelectAbilitySet.showVe().append(metaChooseAbilitySet.$sel);
                    metaChooseAbilitySet.$sel.change(()=>this._doPulseThrottled());
                    fnsCleanupFeat.push(()=>metaChooseAbilitySet.unhook());
                }

                const hkAbilitySet = ()=>{
                    fnsCleanupFeatAbility.splice(0, fnsCleanupFeatAbility.length).forEach(fn=>fn());

                    if (!feat.ability) {
                        $stgFeatNoChoice.empty().hideVe();
                        $stgFeatChooseAsiFrom.empty().hideVe();
                        return;
                    }

                    const abilitySet = feat.ability[this._parent.state[propIxFeatAbility]];

                    const ptsNoChoose = Parser.ABIL_ABVS.filter(ab=>abilitySet[ab]).map(ab=>`${Parser.attAbvToFull(ab)} ${UiUtil.intToBonus(abilitySet[ab], {
                        isPretty: true
                    })}`);
                    $stgFeatNoChoice.empty().toggleVe(ptsNoChoose.length).html(`<div><span class="mr-2">\u2014</span>${ptsNoChoose.join(", ")}</div>`);

                    if (abilitySet.choose && abilitySet.choose.from) {
                        $stgFeat.removeClass("ve-flex-v-center").addClass("ve-flex-v-end");
                        $stgFeatChooseAsiFrom.showVe().empty();
                        $stgFeatChooseAsiWeighted.empty().hideVe();

                        const count = abilitySet.choose.count || 1;
                        const amount = abilitySet.choose.amount || 1;

                        const {rowMetas, cleanup: cleanupAsiPicker} = ComponentUiUtil.getMetaWrpMultipleChoice(this._parent, propFeatAbilityChooseFrom, {
                            values: abilitySet.choose.from,
                            fnDisplay: v=>`${Parser.attAbvToFull(v)} ${UiUtil.intToBonus(amount, {
                                isPretty: true
                            })}`,
                            count,
                        }, );
                        fnsCleanupFeatAbility.push(()=>cleanupAsiPicker());

                        $stgFeatChooseAsiFrom.append(`<div><span class="mr-2">\u2014</span>choose ${count > 1 ? `${count} ` : ""}${UiUtil.intToBonus(amount, {
                            isPretty: true
                        })}</div>`);

                        rowMetas.forEach(meta=>{
                            meta.$cb.change(()=>this._doPulseThrottled());

                            $$`<label class="ve-flex-col no-select">
								<div class="ve-flex-vh-center statgen-asi__cell-feat" title="${Parser.attAbvToFull(meta.value)}">${meta.value.toUpperCase()}</div>
								<div class="ve-flex-vh-center statgen-asi__cell-feat">${meta.$cb}</div>
							</label>`.appendTo($stgFeatChooseAsiFrom);
                        }
                        );
                    } else if (abilitySet.choose && abilitySet.choose.weighted) {
                        $stgFeatChooseAsiFrom.empty().hideVe();
                        $stgFeatChooseAsiWeighted.showVe().html(`<i class="ve-muted">The selected ability score format is currently unsupported. Please check back later!</i>`);
                    } else {
                        $stgFeatChooseAsiFrom.empty().hideVe();
                        $stgFeatChooseAsiWeighted.empty().hideVe();
                    }

                    this._doPulseThrottled();
                }
                ;
                this._parent.addHookBase(propIxFeatAbility, hkAbilitySet);
                fnsCleanupFeat.push(()=>this._parent.removeHookBase(propIxFeatAbility, hkAbilitySet));
                hkAbilitySet();
            } else {
                $stgFeatNoChoice.empty().hideVe();
                $stgFeatChooseAsiFrom.empty().hideVe();
                $stgFeatChooseAsiWeighted.empty().hideVe();
            }

            this._doPulseThrottled();
        }
        ;

        if (!featStatic) {
            this._parent.addHookBase(propIxFeat, hkIxFeat);
            fnsCleanup.push(()=>this._parent.removeHookBase(propIxFeat, hkIxFeat));
        }

        const cleanup = ()=>{
            fnsCleanup.splice(0, fnsCleanup.length).forEach(fn=>fn());
            fnsCleanupFeat.splice(0, fnsCleanupFeat.length).forEach(fn=>fn());
            fnsCleanupFeatAbility.splice(0, fnsCleanupFeatAbility.length).forEach(fn=>fn());
        }
        ;

        return {
            $btnChooseFeat,
            $stgFeat,
            hkIxFeat,
            cleanup
        };
    }

    render($wrpAsi) {
        const $wrpRowsAsi = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);
        const $wrpRowsRace = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);
        const $wrpRowsBackground = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);
        const $wrpRowsCustom = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);

        this._render_renderAsiFeatSection("common_cntAsi", "ability", $wrpRowsAsi);
        this._render_renderAsiFeatSection("common_cntFeatsCustom", "custom", $wrpRowsCustom);
        this._render_renderAdditionalFeatSection({
            propEntity: "common_ixRace",
            namespace: "race",
            $wrpRows: $wrpRowsRace
        });
        this._render_renderAdditionalFeatSection({
            propEntity: "common_ixBackground",
            namespace: "background",
            $wrpRows: $wrpRowsBackground
        });

        const $getStgEntity = ({title, $wrpRows, propEntity, propIxEntity})=>{
            const $stg = $$`<div class="ve-flex-col">
				<hr class="hr-3 hr--dotted">
				<h4 class="my-2 bold">${title} Feats</h4>
				${$wrpRows}
			</div>`;

            const hkIxEntity = ()=>{
                const entity = this._parent[propEntity];
                $stg.toggleVe(!this._parent.isLevelUp && !!entity?.feats);
            }
            ;
            this._parent.addHookBase(propIxEntity, hkIxEntity);
            hkIxEntity();

            return $stg;
        }
        ;

        const $stgRace = $getStgEntity({
            title: "Race",
            $wrpRows: $wrpRowsRace,
            propEntity: "race",
            propIxEntity: "common_ixRace"
        });

        const $stgBackground = $getStgEntity({
            title: "Background",
            $wrpRows: $wrpRowsBackground,
            propEntity: "background",
            propIxEntity: "common_ixBackground"
        });

        const $iptCountFeatsCustom = ComponentUiUtil.$getIptInt(this._parent, "common_cntFeatsCustom", 0, {
            min: 0,
            max: StatGenUi$1._MAX_CUSTOM_FEATS
        }).addClass("w-100p ve-text-center");

        $$($wrpAsi)`
			<h4 class="my-2 bold">Ability Score Increases</h4>
			${this._render_$getStageCntAsi()}
			${$wrpRowsAsi}

			${$stgRace}

			${$stgBackground}

			<hr class="hr-3 hr--dotted">
			<h4 class="my-2 bold">Additional Feats</h4>
			<label class="w-100 ve-flex-v-center mb-2">
				<div class="mr-2 no-shrink">Number of additional feats:</div>${$iptCountFeatsCustom}
			</label>
			${$wrpRowsCustom}
		`;
    }

    _render_$getStageCntAsi() {
        if (!this._parent.isCharacterMode) {
            const $iptCountAsi = ComponentUiUtil.$getIptInt(this._parent, "common_cntAsi", 0, {
                min: 0,
                max: 20
            }).addClass("w-100p ve-text-center");
            return $$`<label class="w-100 ve-flex-v-center mb-2"><div class="mr-2 no-shrink">Number of Ability Score Increases to apply:</div>${$iptCountAsi}</label>`;
        }

        const $out = $$`<div class="w-100 ve-flex-v-center mb-2 italic ve-muted">No ability score increases available.</div>`;
        const hkCntAsis = ()=>$out.toggleVe(this._parent.state.common_cntAsi === 0);
        this._parent.addHookBase("common_cntAsi", hkCntAsis);
        hkCntAsis();
        return $out;
    }

    _getFormData_getForNamespace_basic(outs, outIsFormCompletes, outFeats, propCnt, namespace) {
        for (let i = 0; i < this._parent.state[propCnt]; ++i) {
            const {propMode, propIxFeat, propIxAsiPointOne, propIxAsiPointTwo, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAsi(i, namespace);

            if (this._parent.state[propMode] === "asi") {
                const out = {};

                let ttlChosen = 0;

                Parser.ABIL_ABVS.forEach((ab,abI)=>{
                    const increase = [this._parent.state[propIxAsiPointOne] === abI, this._parent.state[propIxAsiPointTwo] === abI].filter(Boolean).length;
                    if (increase)
                        out[ab] = increase;
                    ttlChosen += increase;
                }
                );

                const isFormComplete = ttlChosen === 2;

                outFeats[namespace].push(null);
                outs.push(out);
                outIsFormCompletes.push(isFormComplete);
            } else if (this._parent.state[propMode] === "feat") {
                const {isFormComplete, out} = this._getFormData_doAddFeatMeta({
                    namespace,
                    outFeats,
                    propIxFeat,
                    propIxFeatAbility,
                    propFeatAbilityChooseFrom,
                    type: "choose",
                });
                outs.push(out);
                outIsFormCompletes.push(isFormComplete);
            }
        }
    }

    _getFormData_getForNamespace_additional(outs, outIsFormCompletes, outFeats, namespace) {
        const ent = this._parent[namespace];
        if (!ent?.feats?.length)
            return;

        const {propIxSel} = this._parent.getPropsAdditionalFeats_(namespace);

        const featSet = ent.feats[this._parent.state[propIxSel]];
        if (!featSet) {
            outIsFormCompletes.push(false);
            return;
        }

        const uidsStatic = UtilAdditionalFeats$1.getUidsStatic(featSet);

        uidsStatic.map((uid,ix)=>{
            const {propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "static", ix);
            const {name, source} = DataUtil.proxy.unpackUid("feat", uid, "feat", {
                isLower: true
            });
            const feat = this._parent.feats.find(it=>it.name.toLowerCase() === name && it.source.toLowerCase() === source);

            const {isFormComplete, out} = this._getFormData_doAddFeatMeta({
                namespace,
                outFeats,
                featStatic: feat,
                propIxFeatAbility,
                propFeatAbilityChooseFrom,
                type: "static",
            });

            outs.push(out);
            outIsFormCompletes.push(isFormComplete);
        }
        );

        [...new Array(featSet.any || 0)].map((_,ix)=>{
            const {propIxFeat, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "fromFilter", ix);

            const {isFormComplete, out} = this._getFormData_doAddFeatMeta({
                namespace,
                outFeats,
                propIxFeat,
                propIxFeatAbility,
                propFeatAbilityChooseFrom,
                type: "choose",
            });

            outs.push(out);
            outIsFormCompletes.push(isFormComplete);
        }
        );
    }

    _getFormData_doAddFeatMeta({namespace, outFeats, propIxFeat=null, featStatic=null, propIxFeatAbility, propFeatAbilityChooseFrom, type}) {
        if (featStatic && propIxFeat)
            throw new Error(`Cannot combine static feat and feat property!`);
        if (featStatic == null && propIxFeat == null)
            throw new Error(`Either a static feat or a feat property must be specified!`);

        const out = {};

        const feat = featStatic || this._parent.feats[this._parent.state[propIxFeat]];

        const featMeta = feat ? {
            ix: this._parent.state[propIxFeat],
            uid: `${feat.name}|${feat.source}`,
            type
        } : {
            ix: -1,
            uid: null,
            type
        };
        outFeats[namespace].push(featMeta);

        if (!~featMeta.ix)
            return {
                isFormComplete: false,
                out
            };
        if (!feat.ability)
            return {
                isFormComplete: true,
                out
            };

        const abilitySet = feat.ability[this._parent.state[propIxFeatAbility] || 0];

        Parser.ABIL_ABVS.forEach(ab=>{
            if (abilitySet[ab])
                out[ab] = abilitySet[ab];
        }
        );

        if (!abilitySet.choose)
            return {
                isFormComplete: true,
                out
            };

        let isFormComplete = true;

        featMeta.abilityChosen = {};

        if (abilitySet.choose.from) {
            if (isFormComplete)
                isFormComplete = !!this._parent.state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable(propFeatAbilityChooseFrom)];

            const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this._parent, propFeatAbilityChooseFrom);
            ixs.map(it=>abilitySet.choose.from[it]).forEach(ab=>{
                const amount = abilitySet.choose.amount || 1;
                out[ab] = (out[ab] || 0) + amount;
                featMeta.abilityChosen[ab] = amount;
            }
            );
        }

        return {
            isFormComplete,
            out
        };
    }

    getFormData() {
        const outs = [];
        const isFormCompletes = [];
        const feats = {
            ability: [],
            race: [],
            background: [],
            custom: []
        };

        this._getFormData_getForNamespace_basic(outs, isFormCompletes, feats, "common_cntAsi", "ability");
        this._getFormData_getForNamespace_basic(outs, isFormCompletes, feats, "common_cntFeatsCustom", "custom");
        this._getFormData_getForNamespace_additional(outs, isFormCompletes, feats, "race");
        this._getFormData_getForNamespace_additional(outs, isFormCompletes, feats, "background");

        const data = {};
        outs.filter(Boolean).forEach(abilBonuses=>Object.entries(abilBonuses).forEach(([ab,bonus])=>data[ab] = (data[ab] || 0) + bonus));

        return {
            isFormComplete: isFormCompletes.every(Boolean),
            dataPerAsi: outs,
            data,
            feats,
        };
    }
};
StatGenUi$1.RenderableCollectionPbRules = class extends RenderableCollectionGenericRows {
    constructor(statGenUi, $wrp) {
        super(statGenUi, "pb_rules", $wrp);
    }

    getNewRender(rule, i) {
        const parentComp = this._comp;

        const comp = this._utils.getNewRenderComp(rule, i);

        const $dispCost = $(`<div class="ve-flex-vh-center"></div>`);
        const hkCost = ()=>$dispCost.text(comp._state.cost);
        comp._addHookBase("cost", hkCost);
        hkCost();

        const $iptCost = ComponentUiUtil.$getIptInt(comp, "cost", 0, {
            html: `<input class="form-control input-xs form-control--minimal ve-text-center">`,
            fallbackOnNaN: 0
        });

        const hkIsCustom = ()=>{
            $dispCost.toggleVe(!parentComp.state.pb_isCustom);
            $iptCost.toggleVe(parentComp.state.pb_isCustom);
        };
        parentComp._addHookBase("pb_isCustom", hkIsCustom);
        hkIsCustom();

        const $btnDelete = $(`<button class="btn btn-xxs btn-danger" title="Delete"><span class="glyphicon glyphicon-trash"></span></button>`).click(()=>{
            if (parentComp.state.pb_rules.length === 1)
                return;
            parentComp.state.pb_rules = parentComp.state.pb_rules.filter(it=>it !== rule);
        }
        );

        const $wrpRow = $$`<div class="ve-flex py-1 stripe-even statgen-pb__row-cost">
			<div class="statgen-pb__col-cost ve-flex-vh-center">${comp._state.score}</div>
			<div class="statgen-pb__col-cost ve-flex-vh-center">${Parser.getAbilityModifier(comp._state.score)}</div>
			<div class="statgen-pb__col-cost ve-flex-vh-center px-3">
				${$dispCost}
				${$iptCost}
			</div>
			<div class="statgen-pb__col-cost-delete">${$btnDelete}</div>
		</div>`.appendTo(this._$wrpRows);

        const hkRules = ()=>{
            //$btnDelete.toggleVe((parentComp.state.pb_rules[0] === rule || parentComp.state.pb_rules.last() === rule) && parentComp.state.pb_isCustom);
        };
        parentComp._addHookBase("pb_rules", hkRules);
        parentComp._addHookBase("pb_isCustom", hkRules);
        hkRules();

        return {
            comp,
            $wrpRow,
            fnCleanup: ()=>{
                parentComp._removeHookBase("pb_isCustom", hkIsCustom);
                parentComp._removeHookBase("pb_isCustom", hkRules);
                parentComp._removeHookBase("pb_rules", hkRules);
            }
            ,
        };
    }

    doDeleteExistingRender(renderedMeta) {
        renderedMeta.fnCleanup();
    }
};

class StatGenUiCharactermancer extends StatGenUi {
    ["_roll_getRolledStats"]() {
      try {
        const _0x485241 = new Roll(this._state.rolled_formula);
        _0x485241.evaluate({
          'async': false
        });
      } catch (_0x5091f0) {
        return this._$rollIptFormula.addClass("form-control--error");
      }
      const _0x1958d4 = [];
      for (let _0x88832a = 0x0; _0x88832a < this._state.rolled_rollCount; _0x88832a++) {
        const _0x381449 = new Roll(this._state.rolled_formula);
        _0x381449.evaluate({
          'async': false
        });
        _0x1958d4.push(_0x381449);
        _0x381449.toMessage({
          'sound': null
        }).then(null);
      }
      _0x1958d4.sort((_0x46f71b, _0x2b13a9) => SortUtil.ascSort(_0x2b13a9.total, _0x46f71b.total));
      return _0x1958d4.map(_0x2582e7 => ({
        'total': _0x2582e7.total,
        'text': (_0x2582e7?.['terms'] || []).map(_0x5abc9a => (_0x5abc9a?.["results"] || []).map(_0x34ec29 => '[' + (_0x34ec29.result || '‒') + ']').join('+'))
      }));
    }
}

//#endregion

//#region Charactermancer Race
class ActorCharactermancerRace extends ActorCharactermancerBaseComponent {
    constructor(_0x33d389) {
      _0x33d389 = _0x33d389 || {};
      super();
      this._actor = _0x33d389.actor;
      this._data = _0x33d389.data;
      this._parent = _0x33d389.parent;
      this._tabRace = _0x33d389.tabRace;
      /* this._modalFilterRaces = new ModalFilterRacesFvtt({
        'namespace': 'ActorCharactermancer.races',
        'isRadio': true,
        'allData': this._data.race
      }); */
      this._compRaceSize = null;
      this._compRaceSkillToolLanguageProficiencies = null;
      this._compRaceSkillProficiencies = null;
      this._compRaceLanguageProficiencies = null;
      this._compRaceToolProficiencies = null;
      this._compRaceExpertise = null;
      this._compRaceWeaponProficiencies = null;
      this._compRaceArmorProficiencies = null;
      this._compRaceDamageImmunity = null;
      this._compRaceDamageResistance = null;
      this._compRaceDamageVulnerability = null;
      this._compRaceConditionImmunity = null;
    }
    render() {
        const parentDiv = this._tabRace?.$wrpTab;
        if (!parentDiv) {return;}
        if(!this._data.race || this._data.race.length < 1){console.error("No races provided!");}
        const {
            $sel: ele_sel,
            $btnFilter: ele_btnFilter,
            $stgSelVersion: ele_selVersion
        } = Charactermancer_Util.getFilterSearchMeta({
            'comp': this,
            'prop': "race_ixRace",
            'propVersion': "race_ixRace_version",
            'data': this._data.race,
            'modalFilter': this._modalFilterRaces,
            'title': "Race"
        });

        const _0x3b7997 = () => this._setStateValue('race_ixRace_version', null);
        this._addHookBase('race_ixRace', _0x3b7997);

        const createExtraInfoElements = () => {
            const _0x4f6a85 = Object.keys(this.__state).filter(_0x2b0e53 => _0x2b0e53.startsWith('race_')
                && !['race_ixRace', 'race_ixRace_version'].includes(_0x2b0e53)).mergeMap(_0x1b8cad => ({
                [_0x1b8cad]: null
            }));
            this._proxyAssignSimple("state", _0x4f6a85);
            const curRace = this.getRace_();

            //#region Render proficiencies
            this._race_renderRace_stgSize({
                '$stgSize': ele_size,
                'race': curRace
            });
            
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_skillToolLang,
                'ent': curRace,
                'propComp': '_compRaceSkillToolLanguageProficiencies',
                'propProficiencies': 'skillToolLanguageProficiencies',
                'CompClass': Charactermancer_OtherProficiencySelect,
                'fnGetExistingFvtt': Charactermancer_OtherProficiencySelect.getExistingFvttFromActor.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_skill,
                'ent': curRace,
                'propComp': "_compRaceSkillProficiencies",
                'propProficiencies': "skillProficiencies",
                'title': "Skill Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ["system", "skills"],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_lang,
                'ent': curRace,
                'propComp': '_compRaceLanguageProficiencies',
                'propProficiencies': "languageProficiencies",
                'title': "Language Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ['system', "traits", "languages"],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_tools,
                'ent': curRace,
                'propComp': "_compRaceToolProficiencies",
                'propProficiencies': "toolProficiencies",
                'title': "Tool Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ["system", "tools"],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_expertise,
                'ent': curRace,
                'propComp': '_compRaceExpertise',
                'propProficiencies': "expertise",
                'title': "Expertise",
                'CompClass': Charactermancer_ExpertiseSelect,
                'fnGetExistingFvtt': Charactermancer_ExpertiseSelect.getExistingFvttFromActor.bind(Charactermancer_ExpertiseSelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_wep,
                'ent': curRace,
                'propComp': "_compRaceWeaponProficiencies",
                'propProficiencies': 'weaponProficiencies',
                'title': "Weapon Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ["system", 'traits', 'weaponProf'],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgOtherProficiencies({
                '$stg': ele_armor,
                'ent': curRace,
                'propComp': "_compRaceArmorProficiencies",
                'propProficiencies': "armorProficiencies",
                'title': "Armor Proficiencies",
                'CompClass': Charactermancer_OtherProficiencySelect,
                'propPathActorExistingProficiencies': ["system", "traits", "armorProf"],
                'fnGetMappedProficiencies': Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect)
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': ele_damImm,
                'ent': curRace,
                'propComp': "_compRaceDamageImmunity",
                'CompClass': Charactermancer_DamageImmunitySelect,
                'title': "Damage Immunity",
                'propRaceData': "immune",
                'propTraits': 'di'
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': ele_damRes,
                'ent': curRace,
                'propComp': "_compRaceDamageResistance",
                'CompClass': Charactermancer_DamageResistanceSelect,
                'title': "Damage Resistance",
                'propRaceData': "resist",
                'propTraits': 'dr'
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': ele_damVul,
                'ent': curRace,
                'propComp': "_compRaceDamageVulnerability",
                'CompClass': Charactermancer_DamageVulnerabilitySelect,
                'title': "Damage Vulnerability",
                'propRaceData': 'vulnerable',
                'propTraits': 'dv'
            });
            this._shared_renderEntity_stgDiDrDvCi({
                '$stg': ele_conImm,
                'ent': curRace,
                'propComp': '_compRaceConditionImmunity',
                'CompClass': Charactermancer_ConditionImmunitySelect,
                'title': "Condition Immunity",
                'propRaceData': "conditionImmune",
                'propTraits': 'ci'
            });
            //#endregion
            ele_textRoller.empty();

            if (curRace) {
                ele_textRoller.append(Renderer.hover.$getHoverContent_stats(UrlUtil.PG_RACES, MiscUtil.copy(curRace)));
                const race = this._data.race[this._state.race_ixRace];
                //TEMPFIX
                /* DataLoader.pCacheAndGet("raceFluff", race.source, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES](race)).then(o => {
                    if (!o) { return; }
                    if (o.name !== race.name || o.source !== race.source) { return; }
                    if (!o.images?.["length"]) { return; }
                    ele_textRoller.append("<hr class=\"hr-1\">");
                    ele_textRoller.append(Renderer.get().render(o.images[0]));
                }); */
            }
        };

        this._addHookBase("race_ixRace_version", createExtraInfoElements);
        const ele_size = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_skillToolLang = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_skill = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_lang = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_tools = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_wep = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_armor = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_expertise = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_damImm = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_damRes = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_damVul = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_conImm = $$`<div class="ve-flex-col"></div>`.hideVe();
        const ele_textRoller = $$`<div class="ve-flex-col w-100"></div>`;

        $$`
        <div class="ve-flex w-100 h-100">
        <div class="ve-flex-col w-100 h-100 px-1 pt-1 overflow-y-auto ve-grow veapp__bg-foundry">
            <div class="bold mb-2">Select a Race</div>
            <div class="ve-flex-v-center btn-group w-100">${ele_btnFilter}${ele_sel}</div>
            ${ele_selVersion}
            ${ele_skillToolLang}
            ${ele_size}
            ${ele_skill}
            ${ele_lang}
            ${ele_tools}
            ${ele_expertise}
            ${ele_wep}
            ${ele_armor}
            ${ele_damImm}
            ${ele_damRes}
            ${ele_damVul}
            ${ele_conImm}
            </div>
    
            <div class="vr-1"></div>
    
            <div class="ve-flex-col w-100 h-100 px-1 overflow-y-auto ve-grow veapp__bg-foundry">
                ${ele_textRoller}
            </div>
        </div>`.appendTo(parentDiv);
        createExtraInfoElements();
    }
    
    get ["modalFilterRaces"]() {
      return this._modalFilterRaces;
    }
    get ['compRaceSize']() {
      return this._compRaceSize;
    }
    get ["compRaceSkillToolLanguageProficiencies"]() {
      return this._compRaceSkillToolLanguageProficiencies;
    }
    get ["compRaceSkillProficiencies"]() {
      return this._compRaceSkillProficiencies;
    }
    get ["compRaceLanguageProficiencies"]() {
      return this._compRaceLanguageProficiencies;
    }
    get ["compRaceToolProficiencies"]() {
      return this._compRaceToolProficiencies;
    }
    get ["compRaceExpertise"]() {
      return this._compRaceExpertise;
    }
    get ['compRaceWeaponProficiencies']() {
      return this._compRaceWeaponProficiencies;
    }
    get ["compRaceArmorProficiencies"]() {
      return this._compRaceArmorProficiencies;
    }
    get ["compRaceDamageImmunity"]() {
      return this._compRaceDamageImmunity;
    }
    get ["compRaceDamageResistance"]() {
      return this._compRaceDamageResistance;
    }
    get ['compRaceDamageVulnerability']() {
      return this._compRaceDamageVulnerability;
    }
    get ["compRaceConditionImmunity"]() {
      return this._compRaceConditionImmunity;
    }
    async ["pLoad"]() {
      await this._modalFilterRaces.pPreloadHidden();
      this._pLoad_pDoHandleExistingRace();
    }
    ["_pLoad_pDoHandleExistingRace"]() {
      const _0x5554e3 = this._actor.system.details?.["race"];
      if (!_0x5554e3) {
        return;
      }
      const {
        ixRace: _0x554aa1,
        ixRaceVersion: _0x5a66c0,
        isRacePresent: _0x6e3758
      } = this._pLoad_getExistingRaceIndex(_0x5554e3);
      if (_0x6e3758 && _0x554aa1 == null) {
        const _0x5ac201 = "Could not find race \"" + _0x5554e3 + "\" in loaded data. " + Charactermancer_Util.STR_WARN_SOURCE_SELECTION;
        ui.notifications.warn(_0x5ac201);
        console.warn(...LGT, _0x5ac201, "Strict source matching is: " + Config.get('import', "isStrictMatching") + '.');
      }
      this._state.race_ixRace = _0x554aa1;
      this._state.race_ixRace_version = _0x5a66c0;
    }
    ["_pLoad_getExistingRaceIndex"](_0x41543f) {
      const _0x56fc39 = (IntegrationBabele.getOriginalName(_0x41543f) || '').trim().toLowerCase();
      const _0x2c50e0 = _0x41543f?.["flags"]?.[SharedConsts.MODULE_ID];
      const _0x4a05d9 = _0x2c50e0?.["propDroppable"] === "race" && _0x2c50e0?.["source"] && _0x2c50e0?.["hash"];
      let _0x50dc0a = null;
      let _0x21f4a5 = null;
      _0x343967: for (let _0x353561 = 0x0; _0x353561 < this._data.race.length; ++_0x353561) {
        const _0x626e38 = this._data.race[_0x353561];
        if (_0x4a05d9 && _0x2c50e0.source === _0x626e38.source && _0x2c50e0.hash === UrlUtil.URL_TO_HASH_BUILDER.race(_0x626e38) || this._pLoad_pDoHandleExistingRace_isMatch({
          'race': _0x626e38,
          'existingRaceClean': _0x56fc39
        })) {
          _0x50dc0a = _0x353561;
          break;
        }
        const _0x5adcb4 = DataUtil.generic.getVersions(_0x626e38);
        for (let _0x1a6bb8 = 0x0; _0x1a6bb8 < _0x5adcb4.length; ++_0x1a6bb8) {
          const _0x24cafe = _0x5adcb4[_0x1a6bb8];
          if (_0x4a05d9 && _0x2c50e0.source === _0x24cafe.source && _0x2c50e0.hash === UrlUtil.URL_TO_HASH_BUILDER.race(_0x24cafe) || this._pLoad_pDoHandleExistingRace_isMatch({
            'race': _0x24cafe,
            'existingRaceClean': _0x56fc39
          })) {
            _0x50dc0a = _0x353561;
            _0x21f4a5 = _0x1a6bb8;
            break _0x343967;
          }
        }
      }
      return {
        'ixRace': _0x50dc0a,
        'ixRaceVersion': _0x21f4a5,
        'isRacePresent': _0x56fc39 || _0x4a05d9
      };
    }
    ["_pLoad_pDoHandleExistingRace_isMatch"]({
      race: _0x5858ca,
      existingRaceClean: _0x10d38e
    }) {
      if (!_0x10d38e) {
        return false;
      }
      return _0x5858ca.name.toLowerCase().trim() === _0x10d38e || (PageFilterRaces.getInvertedName(_0x5858ca.name) || '').toLowerCase().trim() === _0x10d38e;
    }
    getRace_() {
        const _0x41c84d = this._data.race[this._state.race_ixRace];
        if (!_0x41c84d) {
            return null;
        }
        if (this._state.race_ixRace_version == null) {
            return _0x41c84d;
        }
        const _0x4bcc16 = DataUtil.generic.getVersions(_0x41c84d);
        return _0x4bcc16[this._state.race_ixRace_version];
    }
    ["_race_renderRace_stgSize"]({
      $stgSize: _0x40232f,
      race: _0x503779
    }) {
      _0x40232f.empty();
      if (_0x503779 && _0x503779.size) {
        _0x40232f.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Size</div>");
        this._compRaceSize = new Charactermancer_Race_SizeSelect({
          'sizes': _0x503779.size
        });
        this._compRaceSize.render(_0x40232f);
      } else {
        _0x40232f.hideVe();
        this._compRaceSize = null;
      }
    }
    ["_getDefaultState"]() {
      return {
        'race_ixRace': null,
        'race_ixRace_version': null
      };
    }
}

class Charactermancer_Race_Util {
    static async pPostLoadPrereleaseBrew(fileData) {
        const out = {
            race: []
        };

        if (fileData.race)
            out.race.push(...Renderer.race.mergeSubraces(fileData.race, {
                isAddBaseRaces: true
            }));

        if (fileData.subrace) {
            const baseListSite = MiscUtil.copy((await Vetools.pGetRaces({
                isAddBaseRaces: true
            })).race);
            baseListSite.forEach(it=>PageFilterRaces.mutateForFilters(it));

            const baseListBrew = MiscUtil.copy([...fileData.race || []]);
            baseListBrew.forEach(it=>PageFilterRaces.mutateForFilters(it));
            const baseList = [...baseListBrew, ...baseListSite];

            const nxtData = Renderer.race.adoptSubraces(baseList, fileData.subrace);
            const mergedNxtData = Renderer.race.mergeSubraces(nxtData);

            out.race.push(...mergedNxtData);
        }

        return out;
    }
}

class Charactermancer_Race_SizeSelect extends BaseComponent {
    static async pGetUserInput({sizes}) {
        if (!sizes || !sizes.length)
            return {
                isFormComplete: true,
                data: Parser.SZ_MEDIUM
            };
        const comp = new this({
            sizes
        });
        if (comp.isNoChoice())
            return comp.pGetFormData();
        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            isAutoResize: true
        });
    }

    constructor(opts) {
        opts = opts || {};
        super();

        this._sizes = opts.sizes || [Parser.SZ_MEDIUM];
    }

    get modalTitle() {
        return `Choose Size`;
    }

    render($wrp) {
        if (this._sizes.length === 1) {
            $wrp.append(`<div>${Parser.sizeAbvToFull(this._sizes[0])}</div>`);
            return;
        }

        ComponentUiUtil.$getSelEnum(this, "size", {
            values: this._sizes,
            isAllowNull: true,
            fnDisplay: Parser.sizeAbvToFull,
        }, ).appendTo($wrp);
    }

    isNoChoice() {
        return this._sizes.length <= 1;
    }

    pGetFormData() {
        return {
            isFormComplete: this._state.size != null,
            data: this._sizes.length === 1 ? this._sizes[0] : this._state.size,
        };
    }
}
//#endregion


class Charactermancer_Util {
    static getCurrentLevel(actor) {
        return actor.items.filter(it=>it.type === "class").map(it=>Number(it.system.levels || 0)).sum();
    }

    static getBaseAbilityScores(actor) {
        return this._getAbilityScores(actor, true);
    }

    static getCurrentAbilityScores(actor) {
        return this._getAbilityScores(actor, false);
    }

    static _getAbilityScores(actor, isBase) {
        const actorData = isBase ? (actor.system._source || actor.system) : actor.system;
        const out = {
            str: Number(MiscUtil.get(actorData, "abilities", "str", "value") || 0),
            dex: Number(MiscUtil.get(actorData, "abilities", "dex", "value") || 0),
            con: Number(MiscUtil.get(actorData, "abilities", "con", "value") || 0),
            int: Number(MiscUtil.get(actorData, "abilities", "int", "value") || 0),
            wis: Number(MiscUtil.get(actorData, "abilities", "wis", "value") || 0),
            cha: Number(MiscUtil.get(actorData, "abilities", "cha", "value") || 0),
        };
        Object.entries(out).forEach(([abv,val])=>{
            if (isNaN(val))
                out[abv] = 0;
        }
        );
        return out;
    }

    static getBaseHp(actor) {
        return this._getHp(actor, true);
    }

    static _getHp(actor, isBase) {
        const actorData = isBase ? (actor.system._source || actor.system) : actor.system;
        return {
            value: (actorData?.attributes?.hp?.value || 0),
            max: actorData?.attributes?.hp?.max,
        };
    }

    static getAttackAbilityScore(itemAttack, abilityScores, mode) {
        if (!itemAttack || !abilityScores)
            return null;
        switch (mode) {
        case "melee":
            {
                const isFinesse = !!MiscUtil.get(itemAttack, "system", "properties", "fin");
                if (!isFinesse)
                    return abilityScores.str;
                return abilityScores.str > abilityScores.dex ? abilityScores.str : abilityScores.dex;
            }
        case "ranged":
            {
                const isThrown = !!MiscUtil.get(itemAttack, "system", "properties", "thr");
                if (!isThrown)
                    return abilityScores.dex;
                return abilityScores.str > abilityScores.dex ? abilityScores.str : abilityScores.dex;
            }
        default:
            throw new Error(`Unhandled mode "${mode}"`);
        }
    }

    static getFilteredFeatures(allFeatures, pageFilter, filterValues) {
        return allFeatures.filter(f=>{
            const source = f.source || (f.classFeature ? DataUtil.class.unpackUidClassFeature(f.classFeature).source : f.subclassFeature ? DataUtil.class.unpackUidSubclassFeature(f.subclassFeature) : null);

            if (!pageFilter.sourceFilter.toDisplay(filterValues, source))
                return false;

            f.loadeds = f.loadeds.filter(meta=>{
                return Charactermancer_Class_Util.isClassEntryFilterMatch(meta.entity, pageFilter, filterValues);
            }
            );

            return f.loadeds.length;
        }
        );
    }

    static getImportableFeatures(allFeatures) {
        return allFeatures.filter(f=>{
            if (f.gainSubclassFeature && !f.gainSubclassFeatureHasContent)
                return false;

            const lowName = f.name.toLowerCase();
            switch (lowName) {
            case "proficiency versatility":
                return false;
            default:
                return true;
            }
        }
        );
    }

    static doApplyFilterToFeatureEntries_bySource(allFeatures, pageFilter, filterValues) {
        allFeatures.forEach(f=>{
            f.loadeds.forEach(loaded=>{
                switch (loaded.type) {
                case "classFeature":
                case "subclassFeature":
                    {
                        if (loaded.entity.entries)
                            loaded.entity.entries = Charactermancer_Class_Util.getFilteredEntries_bySource(loaded.entity.entries, pageFilter, filterValues);
                        break;
                    }
                }
            }
            );
        }
        );

        return allFeatures;
    }

    static getFeaturesGroupedByOptionsSet(allFeatures) {
        return allFeatures.map(topLevelFeature=>{
            const optionsSets = [];

            let optionsStack = [];
            let lastOptionsSetId = null;
            topLevelFeature.loadeds.forEach(l=>{
                const optionsSetId = MiscUtil.get(l, "optionsMeta", "setId") || null;
                if (lastOptionsSetId !== optionsSetId) {
                    if (optionsStack.length)
                        optionsSets.push(optionsStack);
                    optionsStack = [l];
                    lastOptionsSetId = optionsSetId;
                } else {
                    optionsStack.push(l);
                }
            }
            );
            if (optionsStack.length)
                optionsSets.push(optionsStack);

            return {
                topLevelFeature,
                optionsSets
            };
        }
        );
    }

    static getFilterSearchMeta({comp, prop, propVersion=null, data, modalFilter, title}) {
        const {$wrp: $sel, fnUpdateHidden: fnUpdateSelHidden, unhook} = ComponentUiUtil.$getSelSearchable(comp, prop, {
            values: data.map((_,i)=>i),
            isAllowNull: true,
            fnDisplay: ix=>{
                const it = data[ix];

                if (!it) {
                    console.warn(...LGT, `Could not find ${prop} with index ${ix} (${data.length} ${prop} entries were available)`);
                    return "(Unknown)";
                }

                return `${it.name} ${it.source !== Parser.SRC_PHB ? `[${Parser.sourceJsonToAbv(it.source)}]` : ""}`;
            }
            ,
            fnGetAdditionalStyleClasses: ix=>{
                if (ix == null)
                    return null;
                const it = data[ix];
                if (!it)
                    return;
                return it._versionBase_isVersion ? ["italic"] : null;
            }
            ,
            asMeta: true,
        }, );

        const doApplyFilterToSel = ()=>{
            const f = modalFilter.pageFilter.filterBox.getValues();
            const isHiddenPer = data.map(it=>!modalFilter.pageFilter.toDisplay(f, it));
            fnUpdateSelHidden(isHiddenPer, false);
        }
        ;

        //TEMPFIX
        //modalFilter.pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, doApplyFilterToSel, );
        //doApplyFilterToSel();

        const $btnFilter = $(`<button class="btn btn-xs btn-5et br-0 pr-2" title="Filter for a ${title}"><span class="glyphicon glyphicon-filter"></span> Filter</button>`).click(async()=>{
            const selecteds = await modalFilter.pGetUserSelection();
            if (selecteds == null || !selecteds.length)
                return;

            const selected = selecteds[0];
            const ix = data.findIndex(it=>it.name === selected.name && it.source === selected.values.sourceJson);
            if (!~ix)
                throw new Error(`Could not find selected entity: ${JSON.stringify(selected)}`);
            comp._state[prop] = ix;
        }
        );

        const {$stg: $stgSelVersion=null, unhook: unhookVersion=null} = this._getFilterSearchMeta_getVersionMeta({
            comp,
            prop,
            propVersion,
            data
        }) || {};

        return {
            $sel,
            $btnFilter,
            $stgSelVersion,
            unhook: ()=>{
                unhook();
                modalFilter.pageFilter.filterBox.off(FilterBox.EVNT_VALCHANGE, doApplyFilterToSel);
                if (unhookVersion)
                    unhookVersion();
            }
            ,
        };
    }

    static _getFilterSearchMeta_getVersionMeta({comp, prop, propVersion, data}) {
        if (!propVersion)
            return;

        const {$sel, setValues, unhook} = ComponentUiUtil.$getSelEnum(comp, propVersion, {
            values: [],
            isAllowNull: true,
            displayNullAs: "(Base version)",
            fnDisplay: it=>`${it.name}${it.source !== data[comp._state[prop]]?.source ? ` (${Parser.sourceJsonToAbv(it.source)})` : ""}`,
            asMeta: true,
            isSetIndexes: true,
        }, );

        const hkProp = ()=>{
            const ent = data[comp._state[prop]];
            if (ent == null) {
                setValues([]);
                return $stg.hideVe();
            }

            const versions = DataUtil.generic.getVersions(ent);
            setValues(versions);
            $stg.toggleVe(versions.length);
        }
        ;
        comp._addHookBase(prop, hkProp);

        const $stg = $$`<div class="ve-flex-col mt-2">
			<label class="split-v-center btn-group w-100">
				<div class="mr-2">Version:</div>
				${$sel}
			</label>
		</div>`;

        hkProp();

        return {
            $stg,
            unhook: ()=>{
                unhook();
                comp._removeHookBase(prop, hkProp);
            }
            ,
        };
    }
}
Charactermancer_Util.STR_WARN_SOURCE_SELECTION = `Did you change your source selection since using the Charactermancer initially?`;


class ProxyBase extends MixedProxyBase{

}

//#region TabUIUtil
class TabUiUtilBase {
    static decorate(obj, {isInitMeta=false}={}) {
        if (isInitMeta) {
            obj.__meta = {};
            obj._meta = obj._getProxy("meta", obj.__meta);
        }

        obj.__tabState = {};

        obj._getTabProps = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            return {
                propProxy,
                _propProxy: `_${propProxy}`,
                __propProxy: `__${propProxy}`,
                propActive: `ixActiveTab__${tabGroup}`,
            };
        }
        ;

        obj._renderTabs = function(tabMetas, {$parent, propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP, cbTabChange, additionalClassesWrpHeads}={}) {
            if (!tabMetas.length)
                throw new Error(`One or more tab meta must be specified!`);
            obj._resetTabs({
                tabGroup
            });

            const isSingleTab = tabMetas.length === 1;

            const {propActive, _propProxy, __propProxy} = obj._getTabProps({
                propProxy,
                tabGroup
            });

            this[__propProxy][propActive] = this[__propProxy][propActive] || 0;

            const $dispTabTitle = obj.__$getDispTabTitle({
                isSingleTab
            });

            const renderTabMetas_standard = (it,i)=>{
                const $btnTab = obj.__$getBtnTab({
                    isSingleTab,
                    tabMeta: it,
                    _propProxy,
                    propActive,
                    ixTab: i,
                });

                const $wrpTab = obj.__$getWrpTab({
                    tabMeta: it,
                    ixTab: i
                });

                return {
                    ...it,
                    ix: i,
                    $btnTab,
                    $wrpTab,
                };
            }
            ;

            const tabMetasOut = tabMetas.map((it,i)=>{
                if (it.type)
                    return obj.__renderTypedTabMeta({
                        tabMeta: it,
                        ixTab: i
                    });
                return renderTabMetas_standard(it, i);
            }
            ).filter(Boolean);

            if ($parent)
                obj.__renderTabs_addToParent({
                    $dispTabTitle,
                    $parent,
                    tabMetasOut,
                    additionalClassesWrpHeads
                });

            const hkActiveTab = ()=>{
                tabMetasOut.forEach(it=>{
                    if (it.type)
                        return;
                    const isActive = it.ix === this[_propProxy][propActive];
                    if (isActive && $dispTabTitle)
                        $dispTabTitle.text(isSingleTab ? "" : it.name);
                    if (it.$btnTab)
                        it.$btnTab.toggleClass("active", isActive);
                    it.$wrpTab.toggleVe(isActive);
                }
                );

                if (cbTabChange)
                    cbTabChange();
            }
            ;
            this._addHook(propProxy, propActive, hkActiveTab);
            hkActiveTab();

            obj.__tabState[tabGroup] = {
                fnReset: ()=>{
                    this._removeHook(propProxy, propActive, hkActiveTab);
                }
                ,
                tabMetasOut,
            };

            return tabMetasOut;
        }
        ;

        obj.__renderTabs_addToParent = function({$dispTabTitle, $parent, tabMetasOut, additionalClassesWrpHeads}) {
            const hasBorder = tabMetasOut.some(it=>it.hasBorder);
            $$`<div class="ve-flex-col w-100 h-100">
				${$dispTabTitle}
				<div class="ve-flex-col w-100 h-100 min-h-0">
					<div class="ve-flex ${hasBorder ? `ui-tab__wrp-tab-heads--border` : ""} ${additionalClassesWrpHeads || ""}">${tabMetasOut.map(it=>it.$btnTab)}</div>
					<div class="ve-flex w-100 h-100 min-h-0">${tabMetasOut.map(it=>it.$wrpTab).filter(Boolean)}</div>
				</div>
			</div>`.appendTo($parent);
        }
        ;

        obj._resetTabs = function({tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            if (!obj.__tabState[tabGroup])
                return;
            obj.__tabState[tabGroup].fnReset();
            delete obj.__tabState[tabGroup];
        }
        ;

        obj._hasPrevTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            return obj.__hasTab({
                propProxy,
                tabGroup,
                offset: -1
            });
        }
        ;
        obj._hasNextTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            return obj.__hasTab({
                propProxy,
                tabGroup,
                offset: 1
            });
        }
        ;

        obj.__hasTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP, offset}) {
            const {propActive, _propProxy} = obj._getTabProps({
                propProxy,
                tabGroup
            });
            const ixActive = obj[_propProxy][propActive];
            return !!(obj.__tabState[tabGroup]?.tabMetasOut && obj.__tabState[tabGroup]?.tabMetasOut[ixActive + offset]);
        }
        ;

        obj._doSwitchToPrevTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            return obj.__doSwitchToTab({
                propProxy,
                tabGroup,
                offset: -1
            });
        }
        ;
        obj._doSwitchToNextTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            return obj.__doSwitchToTab({
                propProxy,
                tabGroup,
                offset: 1
            });
        }
        ;

        obj.__doSwitchToTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP, offset}) {
            if (!obj.__hasTab({
                propProxy,
                tabGroup,
                offset
            }))
                return;
            const {propActive, _propProxy} = obj._getTabProps({
                propProxy,
                tabGroup
            });
            obj[_propProxy][propActive] = obj[_propProxy][propActive] + offset;
        }
        ;

        obj._addHookActiveTab = function(hook, {propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            const {propActive} = obj._getTabProps({
                propProxy,
                tabGroup
            });
            this._addHook(propProxy, propActive, hook);
        }
        ;

        obj._getIxActiveTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            const {propActive, _propProxy} = obj._getTabProps({
                propProxy,
                tabGroup
            });
            return obj[_propProxy][propActive];
        }
        ;

        obj._setIxActiveTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP, ixActiveTab}={}) {
            const {propActive, _propProxy} = obj._getTabProps({
                propProxy,
                tabGroup
            });
            obj[_propProxy][propActive] = ixActiveTab;
        }
        ;

        obj._getActiveTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP}={}) {
            const tabState = obj.__tabState[tabGroup];
            const ixActiveTab = obj._getIxActiveTab({
                propProxy,
                tabGroup
            });
            return tabState.tabMetasOut[ixActiveTab];
        }
        ;

        obj._setActiveTab = function({propProxy=TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup=TabUiUtilBase._DEFAULT_TAB_GROUP, tab}) {
            const tabState = obj.__tabState[tabGroup];
            const ix = tabState.tabMetasOut.indexOf(tab);
            obj._setIxActiveTab({
                propProxy,
                tabGroup,
                ixActiveTab: ix
            });
        }
        ;

        obj.__$getBtnTab = function() {
            throw new Error("Unimplemented!");
        }
        ;
        obj.__$getWrpTab = function() {
            throw new Error("Unimplemented!");
        }
        ;
        obj.__renderTypedTabMeta = function() {
            throw new Error("Unimplemented!");
        }
        ;
        obj.__$getDispTabTitle = function() {
            throw new Error("Unimplemented!");
        }
        ;
    }
}
TabUiUtilBase._DEFAULT_TAB_GROUP = "_default";
TabUiUtilBase._DEFAULT_PROP_PROXY = "meta";

TabUiUtilBase.TabMeta = class {
    constructor({name, icon=null, type=null, buttons=null}={}) {
        this.name = name;
        this.icon = icon;
        this.type = type;
        this.buttons = buttons;
    }
}
;

let TabUiUtil$1 = class TabUiUtil extends TabUiUtilBase {
    static decorate(obj, {isInitMeta=false}={}) {
        super.decorate(obj, {
            isInitMeta
        });

        obj.__$getBtnTab = function({tabMeta, _propProxy, propActive, ixTab}) {
            return $(`<button class="btn btn-default ui-tab__btn-tab-head ${tabMeta.isHeadHidden ? "ve-hidden" : ""}">${tabMeta.name.qq()}</button>`).click(()=>obj[_propProxy][propActive] = ixTab);
        }
        ;

        obj.__$getWrpTab = function({tabMeta}) {
            return $(`<div class="ui-tab__wrp-tab-body ve-flex-col ve-hidden ${tabMeta.hasBorder ? "ui-tab__wrp-tab-body--border" : ""} ${tabMeta.hasBackground ? "ui-tab__wrp-tab-body--background" : ""}"></div>`);
        }
        ;

        obj.__renderTypedTabMeta = function({tabMeta, ixTab}) {
            switch (tabMeta.type) {
            case "buttons":
                return obj.__renderTypedTabMeta_buttons({
                    tabMeta,
                    ixTab
                });
            default:
                throw new Error(`Unhandled tab type "${tabMeta.type}"`);
            }
        }
        ;

        obj.__renderTypedTabMeta_buttons = function({tabMeta, ixTab}) {
            const $btns = tabMeta.buttons.map((meta,j)=>{
                const $btn = $(`<button class="btn ui-tab__btn-tab-head ${meta.type ? `btn-${meta.type}` : "btn-primary"}" ${meta.title ? `title="${meta.title.qq()}"` : ""}>${meta.html}</button>`).click(evt=>meta.pFnClick(evt, $btn));
                return $btn;
            }
            );

            const $btnTab = $$`<div class="btn-group ve-flex-v-right ve-flex-h-right ml-2 w-100">${$btns}</div>`;

            return {
                ...tabMeta,
                ix: ixTab,
                $btns,
                $btnTab,
            };
        }
        ;

        obj.__$getDispTabTitle = function() {
            return null;
        }
        ;
    }
}
;

globalThis.TabUiUtil = TabUiUtil$1;

TabUiUtil$1.TabMeta = class extends TabUiUtilBase.TabMeta {
    constructor(opts) {
        super(opts);
        this.hasBorder = !!opts.hasBorder;
        this.hasBackground = !!opts.hasBackground;
        this.isHeadHidden = !!opts.isHeadHidden;
        this.isNoPadding = !!opts.isNoPadding;
    }
}
;

let TabUiUtilSide$1 = class TabUiUtilSide extends TabUiUtilBase {
    static decorate(obj, {isInitMeta=false}={}) {
        super.decorate(obj, {
            isInitMeta
        });

        obj.__$getBtnTab = function({isSingleTab, tabMeta, _propProxy, propActive, ixTab}) {
            return isSingleTab ? null : $(`<button class="btn btn-default btn-sm ui-tab-side__btn-tab mb-2 br-0 btr-0 bbr-0 text-left ve-flex-v-center" title="${tabMeta.name.qq()}"><div class="${tabMeta.icon} ui-tab-side__icon-tab mr-2 mobile-ish__mr-0 ve-text-center"></div><div class="mobile-ish__hidden">${tabMeta.name.qq()}</div></button>`).click(()=>this[_propProxy][propActive] = ixTab);
        }
        ;

        obj.__$getWrpTab = function({tabMeta}) {
            return $(`<div class="ve-flex-col w-100 h-100 ui-tab-side__wrp-tab ${tabMeta.isNoPadding ? "" : "px-3 py-2"} overflow-y-auto"></div>`);
        }
        ;

        obj.__renderTabs_addToParent = function({$dispTabTitle, $parent, tabMetasOut}) {
            $$`<div class="ve-flex-col w-100 h-100">
				${$dispTabTitle}
				<div class="ve-flex w-100 h-100 min-h-0">
					<div class="ve-flex-col h-100 pt-2">${tabMetasOut.map(it=>it.$btnTab)}</div>
					<div class="ve-flex-col w-100 h-100 min-w-0">${tabMetasOut.map(it=>it.$wrpTab).filter(Boolean)}</div>
				</div>
			</div>`.appendTo($parent);
        }
        ;

        obj.__renderTypedTabMeta = function({tabMeta, ixTab}) {
            switch (tabMeta.type) {
            case "buttons":
                return obj.__renderTypedTabMeta_buttons({
                    tabMeta,
                    ixTab
                });
            default:
                throw new Error(`Unhandled tab type "${tabMeta.type}"`);
            }
        }
        ;

        obj.__renderTypedTabMeta_buttons = function({tabMeta, ixTab}) {
            const $btns = tabMeta.buttons.map((meta,j)=>{
                const $btn = $(`<button class="btn ${meta.type ? `btn-${meta.type}` : "btn-primary"} btn-sm" ${meta.title ? `title="${meta.title.qq()}"` : ""}>${meta.html}</button>`).click(evt=>meta.pFnClick(evt, $btn));

                if (j === tabMeta.buttons.length - 1)
                    $btn.addClass(`br-0 btr-0 bbr-0`);

                return $btn;
            }
            );

            const $btnTab = $$`<div class="btn-group ve-flex-v-center ve-flex-h-right mb-2">${$btns}</div>`;

            return {
                ...tabMeta,
                ix: ixTab,
                $btnTab,
            };
        }
        ;

        obj.__$getDispTabTitle = function({isSingleTab}) {
            return $(`<div class="ui-tab-side__disp-active-tab-name ${isSingleTab ? `ui-tab-side__disp-active-tab-name--single` : ""} bold"></div>`);
        }
        ;
    }
}
;

globalThis.TabUiUtilSide = TabUiUtilSide$1;
//#endregion

//#region ElementUtil
jQuery.fn.disableSpellcheck = function(){
    return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");
}
jQuery.fn.hideVe = function() {
    this.classList.add("ve-hidden");
    return this;
}
globalThis.ElementUtil = {
    _ATTRS_NO_FALSY: new Set(["checked", "disabled", ]),

    getOrModify({tag, clazz, style, click, contextmenu, change, mousedown, mouseup, mousemove, pointerdown, pointerup, keydown, html, text, txt, ele, children, outer,
    id, name, title, val, href, type, tabindex, value, placeholder, attrs, data, }) {
        ele = ele || (outer ? (new DOMParser()).parseFromString(outer, "text/html").body.childNodes[0] : document.createElement(tag));

        if (clazz)
            ele.className = clazz;
        if (style)
            ele.setAttribute("style", style);
        if (click)
            ele.addEventListener("click", click);
        if (contextmenu)
            ele.addEventListener("contextmenu", contextmenu);
        if (change)
            ele.addEventListener("change", change);
        if (mousedown)
            ele.addEventListener("mousedown", mousedown);
        if (mouseup)
            ele.addEventListener("mouseup", mouseup);
        if (mousemove)
            ele.addEventListener("mousemove", mousemove);
        if (pointerdown)
            ele.addEventListener("pointerdown", pointerdown);
        if (pointerup)
            ele.addEventListener("pointerup", pointerup);
        if (keydown)
            ele.addEventListener("keydown", keydown);
        if (html != null)
            ele.innerHTML = html;
        if (text != null || txt != null)
            ele.textContent = text;
        if (id != null)
            ele.setAttribute("id", id);
        if (name != null)
            ele.setAttribute("name", name);
        if (title != null)
            ele.setAttribute("title", title);
        if (href != null)
            ele.setAttribute("href", href);
        if (val != null)
            ele.setAttribute("value", val);
        if (type != null)
            ele.setAttribute("type", type);
        if (tabindex != null)
            ele.setAttribute("tabindex", tabindex);
        if (value != null)
            ele.setAttribute("value", value);
        if (placeholder != null)
            ele.setAttribute("placeholder", placeholder);

        if (attrs != null) {
            for (const k in attrs) {
                if (attrs[k] === undefined)
                    continue;
                if (!attrs[k] && ElementUtil._ATTRS_NO_FALSY.has(k))
                    continue;
                ele.setAttribute(k, attrs[k]);
            }
        }

        if (data != null) {
            for (const k in data) {
                if (data[k] === undefined)
                    continue;
                ele.dataset[k] = data[k];
            }
        }

        if (children)
            for (let i = 0, len = children.length; i < len; ++i)
                if (children[i] != null)
                    ele.append(children[i]);

        ele.appends = ele.appends || ElementUtil._appends.bind(ele);
        ele.appendTo = ele.appendTo || ElementUtil._appendTo.bind(ele);
        ele.prependTo = ele.prependTo || ElementUtil._prependTo.bind(ele);
        ele.insertAfter = ele.insertAfter || ElementUtil._insertAfter.bind(ele);
        ele.addClass = ele.addClass || ElementUtil._addClass.bind(ele);
        ele.removeClass = ele.removeClass || ElementUtil._removeClass.bind(ele);
        ele.toggleClass = ele.toggleClass || ElementUtil._toggleClass.bind(ele);
        ele.showVe = ele.showVe || ElementUtil._showVe.bind(ele);
        ele.hideVe = ele.hideVe || ElementUtil._hideVe.bind(ele);
        ele.toggleVe = ele.toggleVe || ElementUtil._toggleVe.bind(ele);
        ele.empty = ele.empty || ElementUtil._empty.bind(ele);
        ele.detach = ele.detach || ElementUtil._detach.bind(ele);
        ele.attr = ele.attr || ElementUtil._attr.bind(ele);
        ele.val = ele.val || ElementUtil._val.bind(ele);
        ele.html = ele.html || ElementUtil._html.bind(ele);
        ele.txt = ele.txt || ElementUtil._txt.bind(ele);
        ele.tooltip = ele.tooltip || ElementUtil._tooltip.bind(ele);
        ele.disableSpellcheck = ele.disableSpellcheck || ElementUtil._disableSpellcheck.bind(ele);
        ele.on = ele.on || ElementUtil._onX.bind(ele);
        ele.onClick = ele.onClick || ElementUtil._onX.bind(ele, "click");
        ele.onContextmenu = ele.onContextmenu || ElementUtil._onX.bind(ele, "contextmenu");
        ele.onChange = ele.onChange || ElementUtil._onX.bind(ele, "change");
        ele.onKeydown = ele.onKeydown || ElementUtil._onX.bind(ele, "keydown");
        ele.onKeyup = ele.onKeyup || ElementUtil._onX.bind(ele, "keyup");

        return ele;
    },

    _appends(child) {
        this.appendChild(child);
        return this;
    },

    _appendTo(parent) {
        parent.appendChild(this);
        return this;
    },

    _prependTo(parent) {
        parent.prepend(this);
        return this;
    },

    _insertAfter(parent) {
        parent.after(this);
        return this;
    },

    _addClass(clazz) {
        this.classList.add(clazz);
        return this;
    },

    _removeClass(clazz) {
        this.classList.remove(clazz);
        return this;
    },

    _toggleClass(clazz, isActive) {
        if (isActive == null)
            this.classList.toggle(clazz);
        else if (isActive)
            this.classList.add(clazz);
        else
            this.classList.remove(clazz);
        return this;
    },

    _showVe() {
        this.classList.remove("ve-hidden");
        return this;
    },

    _hideVe() {
        this.classList.add("ve-hidden");
        return this;
    },

    _toggleVe(isActive) {
        this.toggleClass("ve-hidden", isActive == null ? isActive : !isActive);
        return this;
    },

    _empty() {
        this.innerHTML = "";
        return this;
    },

    _detach() {
        if (this.parentElement)
            this.parentElement.removeChild(this);
        return this;
    },

    _attr(name, value) {
        this.setAttribute(name, value);
        return this;
    },

    _html(html) {
        if (html === undefined)
            return this.innerHTML;
        this.innerHTML = html;
        return this;
    },

    _txt(txt) {
        if (txt === undefined)
            return this.innerText;
        this.innerText = txt;
        return this;
    },

    _tooltip(title) {
        return this.attr("title", title);
    },

    _disableSpellcheck() {
        return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");
    },

    _onX(evtName, fn) {
        this.addEventListener(evtName, fn);
        return this;
    },

    _val(val) {
        if (val !== undefined) {
            switch (this.tagName) {
            case "SELECT":
                {
                    let selectedIndexNxt = -1;
                    for (let i = 0, len = this.options.length; i < len; ++i) {
                        if (this.options[i]?.value === val) {
                            selectedIndexNxt = i;
                            break;
                        }
                    }
                    this.selectedIndex = selectedIndexNxt;
                    return this;
                }

            default:
                {
                    this.value = val;
                    return this;
                }
            }
        }

        switch (this.tagName) {
        case "SELECT":
            return this.options[this.selectedIndex]?.value;

        default:
            return this.value;
        }
    },

    getIndexPathToParent(parent, child) {
        if (!parent.contains(child))
            return null;
        const path = [];

        while (child !== parent) {
            if (!child.parentElement)
                return null;
            const ix = [...child.parentElement.children].indexOf(child);
            if (!~ix)
                return null;
            path.push(ix);

            child = child.parentElement;
        }

        return path.reverse();
    },

    getChildByIndexPath(parent, indexPath) {
        for (let i = 0; i < indexPath.length; ++i) {
            const ix = indexPath[i];
            parent = parent.children[ix];
            if (!parent)
                return null;
        }
        return parent;
    },
};
if (typeof window !== "undefined"){window.e_ = ElementUtil.getOrModify;}
//#endregion

//#region CollectionUtil
globalThis.CollectionUtil = {
    ObjectSet: class ObjectSet {
        constructor() {
            this.map = new Map();
            this[Symbol.iterator] = this.values;
        }
        add(item) {
            this.map.set(item._toIdString(), item);
        }

        values() {
            return this.map.values();
        }
    }
    ,

    setEq(a, b) {
        if (a.size !== b.size)
            return false;
        for (const it of a)
            if (!b.has(it))
                return false;
        return true;
    },

    setDiff(set1, set2) {
        return new Set([...set1].filter(it=>!set2.has(it)));
    },

    objectDiff(obj1, obj2) {
        const out = {};

        [...new Set([...Object.keys(obj1), ...Object.keys(obj2)])].forEach(k=>{
            const diff = CollectionUtil._objectDiff_recurse(obj1[k], obj2[k]);
            if (diff !== undefined)
                out[k] = diff;
        }
        );

        return out;
    },

    _objectDiff_recurse(a, b) {
        if (CollectionUtil.deepEquals(a, b))
            return undefined;

        if (a && b && typeof a === "object" && typeof b === "object") {
            return CollectionUtil.objectDiff(a, b);
        }

        return b;
    },

    objectIntersect(obj1, obj2) {
        const out = {};

        [...new Set([...Object.keys(obj1), ...Object.keys(obj2)])].forEach(k=>{
            const diff = CollectionUtil._objectIntersect_recurse(obj1[k], obj2[k]);
            if (diff !== undefined)
                out[k] = diff;
        }
        );

        return out;
    },

    _objectIntersect_recurse(a, b) {
        if (CollectionUtil.deepEquals(a, b))
            return a;

        if (a && b && typeof a === "object" && typeof b === "object") {
            return CollectionUtil.objectIntersect(a, b);
        }

        return undefined;
    },

    deepEquals(a, b) {
        if (Object.is(a, b))
            return true;
        if (a && b && typeof a === "object" && typeof b === "object") {
            if (CollectionUtil._eq_isPlainObject(a) && CollectionUtil._eq_isPlainObject(b))
                return CollectionUtil._eq_areObjectsEqual(a, b);
            const isArrayA = Array.isArray(a);
            const isArrayB = Array.isArray(b);
            if (isArrayA || isArrayB)
                return isArrayA === isArrayB && CollectionUtil._eq_areArraysEqual(a, b);
            const isSetA = a instanceof Set;
            const isSetB = b instanceof Set;
            if (isSetA || isSetB)
                return isSetA === isSetB && CollectionUtil.setEq(a, b);
            return CollectionUtil._eq_areObjectsEqual(a, b);
        }
        return false;
    },

    _eq_isPlainObject: (value)=>value.constructor === Object || value.constructor == null,
    _eq_areObjectsEqual(a, b) {
        const keysA = Object.keys(a);
        const {length} = keysA;
        if (Object.keys(b).length !== length)
            return false;
        for (let i = 0; i < length; i++) {
            if (!b.hasOwnProperty(keysA[i]))
                return false;
            if (!CollectionUtil.deepEquals(a[keysA[i]], b[keysA[i]]))
                return false;
        }
        return true;
    },
    _eq_areArraysEqual(a, b) {
        const {length} = a;
        if (b.length !== length)
            return false;
        for (let i = 0; i < length; i++)
            if (!CollectionUtil.deepEquals(a[i], b[i]))
                return false;
        return true;
    },

    dfs(obj, opts) {
        const {prop=null, fnMatch=null} = opts;
        if (!prop && !fnMatch)
            throw new Error(`One of "prop" or "fnMatch" must be specified!`);

        if (obj instanceof Array) {
            for (const child of obj) {
                const n = CollectionUtil.dfs(child, opts);
                if (n)
                    return n;
            }
            return;
        }

        if (obj instanceof Object) {
            if (prop && obj[prop])
                return obj[prop];
            if (fnMatch && fnMatch(obj))
                return obj;

            for (const child of Object.values(obj)) {
                const n = CollectionUtil.dfs(child, opts);
                if (n)
                    return n;
            }
        }
    },

    bfs(obj, opts) {
        const {prop=null, fnMatch=null} = opts;
        if (!prop && !fnMatch)
            throw new Error(`One of "prop" or "fnMatch" must be specified!`);

        if (obj instanceof Array) {
            for (const child of obj) {
                if (!(child instanceof Array) && child instanceof Object) {
                    if (prop && child[prop])
                        return child[prop];
                    if (fnMatch && fnMatch(child))
                        return child;
                }
            }

            for (const child of obj) {
                const n = CollectionUtil.bfs(child, opts);
                if (n)
                    return n;
            }

            return;
        }

        if (obj instanceof Object) {
            if (prop && obj[prop])
                return obj[prop];
            if (fnMatch && fnMatch(obj))
                return obj;

            return CollectionUtil.bfs(Object.values(obj));
        }
    },
};
//#endregion

//#region Charactermancer
class Charactermancer_Class_Util {
    static getAllFeatures(cls) {
        let allFeatures = [];
        const seenSubclassFeatureHashes = new Set();

        const gainSubclassFeatureLevels = cls.classFeatures.filter(it=>it.gainSubclassFeature).map(cf=>cf.level ?? DataUtil.class.unpackUidClassFeature(cf.classFeature || cf).level);

        cls.classFeatures.forEach(cf=>{
            allFeatures.push(cf);

            const cfLevel = cf.level ?? DataUtil.class.unpackUidClassFeature(cf.classFeature || cf).level;
            const nxtCfLevel = gainSubclassFeatureLevels.includes(cfLevel) ? gainSubclassFeatureLevels[gainSubclassFeatureLevels.indexOf(cfLevel) + 1] : null;

            cls.subclasses.forEach(sc=>{
                sc.subclassFeatures.filter(scf=>{
                    const scfHash = scf.hash ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).hash;
                    const scfLevel = scf.level ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).level;

                    if (seenSubclassFeatureHashes.has(scfHash))
                        return false;

                    if (scf.isGainAtNextFeatureLevel) {
                        if (!cf.gainSubclassFeature)
                            return false;

                        if (cfLevel === gainSubclassFeatureLevels[0] && scfLevel <= cfLevel)
                            return true;

                        if (scfLevel <= cfLevel && (nxtCfLevel == null || scfLevel < nxtCfLevel))
                            return true;

                        return false;
                    }

                    return scfLevel === cfLevel;
                }
                ).forEach(scf=>{
                    const scfHash = scf.hash ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).hash;
                    seenSubclassFeatureHashes.add(scfHash);

                    scf.level = cfLevel;

                    allFeatures.push(scf);
                }
                );
            }
            );
        }
        );

        return MiscUtil.copy(allFeatures);
    }

    static isClassEntryFilterMatch(entry, pageFilter, filterValues) {
        const source = entry.source;
        const options = entry.isClassFeatureVariant ? {
            isClassFeatureVariant: true
        } : null;

        if (pageFilter.filterBox) {
            return pageFilter.filterBox.toDisplayByFilters(filterValues, ...[{
                filter: pageFilter.sourceFilter,
                value: source,
            }, pageFilter.optionsFilter ? {
                filter: pageFilter.optionsFilter,
                value: options,
            } : null, ].filter(Boolean), );
        }

        return pageFilter.sourceFilter.toDisplay(filterValues, source) && (!pageFilter.optionsFilter || pageFilter.optionsFilter.toDisplay(filterValues, options));
    }

    static getFilteredEntries_bySource(entries, pageFilter, filterValues) {
        const isDisplayableEntry = ({entry, filterValues, pageFilter})=>{
            if (!entry.source)
                return true;

            return this.isClassEntryFilterMatch(entry, pageFilter, filterValues);
        }
        ;

        return this._getFilteredEntries({
            entries,
            pageFilter,
            filterValues,
            fnIsDisplayableEntry: isDisplayableEntry,
        }, );
    }

    static _getFilteredEntries({entries, pageFilter, filterValues, fnIsDisplayableEntry, }, ) {
        const recursiveFilter = (entry)=>{
            if (entry == null)
                return entry;
            if (typeof entry !== "object")
                return entry;

            if (entry instanceof Array) {
                entry = entry.filter(it=>fnIsDisplayableEntry({
                    entry: it,
                    pageFilter,
                    filterValues,
                }));

                return entry.map(it=>recursiveFilter(it));
            }

            Object.keys(entry).forEach(k=>{
                if (entry[k]instanceof Array) {
                    entry[k] = recursiveFilter(entry[k]);
                    if (!entry[k].length)
                        delete entry[k];
                } else
                    entry[k] = recursiveFilter(entry[k]);
            }
            );
            return entry;
        }
        ;

        entries = MiscUtil.copy(entries);
        return recursiveFilter(entries);
    }

    static async pGetPreparableSpells(spells, cls, spellLevelLow, spellLevelHigh) {
        Renderer.spell.populatePrereleaseLookup(await PrereleaseUtil.pGetBrewProcessed(), {
            isForce: true
        });
        Renderer.spell.populateBrewLookup(await BrewUtil2.pGetBrewProcessed(), {
            isForce: true
        });

        return spells.filter(it=>{
            if (!(it.level > 0 && it.level >= spellLevelLow && it.level <= spellLevelHigh))
                return false;

            Renderer.spell.uninitBrewSources(it);
            Renderer.spell.initBrewSources(it);

            const fromClassList = Renderer.spell.getCombinedClasses(it, "fromClassList");
            return fromClassList.some(c=>(c.name || "").toLowerCase() === cls.name.toLowerCase() && (c.source || Parser.SRC_PHB).toLowerCase() === cls.source.toLowerCase());
        }
        );
    }

    static getCasterProgression(cls, sc, {targetLevel, otherExistingClassItems=null, otherExistingSubclassItems=null}) {
        otherExistingClassItems = otherExistingClassItems || [];
        otherExistingSubclassItems = otherExistingSubclassItems || [];

        const isSpellcastingMulticlass = [...otherExistingClassItems.filter(it=>it.system?.spellcasting && it.system?.spellcasting !== "none"), ...otherExistingSubclassItems.filter(it=>it.system?.spellcasting && it.system?.spellcasting !== "none"), cls.casterProgression != null || sc?.casterProgression != null, ].filter(Boolean).length > 1;

        let {totalSpellcastingLevels, casterClassCount, maxPactCasterLevel, } = UtilActors.getActorSpellcastingInfo({
            sheetItems: [...otherExistingClassItems, ...otherExistingSubclassItems],
            isForceSpellcastingMulticlass: isSpellcastingMulticlass,
        });

        maxPactCasterLevel = Math.max(maxPactCasterLevel, targetLevel);

        const casterProgression = sc?.casterProgression || cls.casterProgression;
        const spellAbility = sc?.spellcastingAbility || cls.spellcastingAbility;

        if (casterProgression) {
            const fnRound = casterClassCount ? Math.floor : Math.ceil;
            switch (casterProgression) {
            case "full":
                totalSpellcastingLevels += targetLevel;
                break;
            case "1/2":
                totalSpellcastingLevels += fnRound(targetLevel / 2);
                break;
            case "1/3":
                totalSpellcastingLevels += fnRound(targetLevel / 3);
                break;
            }
        }

        return {
            casterProgression,
            spellAbility,
            totalSpellcastingLevels,
            maxPactCasterLevel,
        };
    }

    static getMysticProgression({cls=null, targetLevel=0, otherExistingClassItems=null, otherExistingSubclassItems=null}) {
        otherExistingClassItems = otherExistingClassItems || [];
        otherExistingSubclassItems = otherExistingSubclassItems || [];
        let totalMysticLevels = 0;

        if (cls?.name === "Mystic" && cls?.source === Parser.SRC_UATMC)
            totalMysticLevels += targetLevel;

        if (otherExistingClassItems) {
            totalMysticLevels += otherExistingClassItems.filter(it=>it.name.toLowerCase().trim() === "mystic").map(it=>it.system.levels).sum();
        }

        return {
            totalMysticLevels,
        };
    }

    static addFauxOptionalFeatureFeatures(classList, optfeatList) {
        for (const cls of classList) {
            if (cls.classFeatures && cls.optionalfeatureProgression?.length) {
                for (const optFeatProgression of cls.optionalfeatureProgression) {
                    this._addFauxOptionalFeatureFeatures_handleClassProgression(optfeatList, cls, null, optFeatProgression, );
                }
            }

            for (const sc of cls.subclasses) {
                if (sc.subclassFeatures && sc.optionalfeatureProgression?.length) {
                    for (const optFeatProgression of sc.optionalfeatureProgression) {
                        this._addFauxOptionalFeatureFeatures_handleClassProgression(optfeatList, cls, sc, optFeatProgression, );
                    }
                }
            }
        }
    }

    static _addFauxOptionalFeatureFeatures_handleClassProgression(optfeatList, cls, sc, optFeatProgression) {
        const fauxLoadeds = this._addFauxOptionalFeatureFeatures_getLoadeds(optfeatList, cls, optFeatProgression);

        let progression = optFeatProgression.progression;
        if (!(progression instanceof Array)) {
            if (progression["*"]) {
                progression = MiscUtil.copy(progression);
                progression[1] = progression["*"];
            }

            const populated = new Set(Object.keys(progression).map(it=>Number(it)).sort(SortUtil.ascSort));
            const nxt = [];
            const lvlMax = Math.max(...populated, Consts.CHAR_MAX_LEVEL);
            for (let i = 0; i < lvlMax; ++i) {
                nxt[i] = populated.has(i + 1) ? progression[i + 1] : nxt.length ? nxt.last() : 0;
            }
            progression = nxt;
        }

        let required = optFeatProgression.required;
        if (required && !(required instanceof Array)) {
            const populated = new Set(Object.keys(required).map(it=>Number(it)).sort(SortUtil.ascSort));
            const nxt = [];
            const lvlMax = Math.max(...populated, Consts.CHAR_MAX_LEVEL);
            for (let i = 0; i < lvlMax; ++i) {
                nxt[i] = populated.has(i + 1) ? required[i + 1] : [];
            }
            required = nxt;
        }

        const propFeatures = sc ? "subclassFeatures" : "classFeatures";
        const propFeature = sc ? "subclassFeature" : "classFeature";
        const fnUnpackUidFeature = sc ? DataUtil.class.unpackUidSubclassFeature : DataUtil.class.unpackUidClassFeature;

        let cntPrev = 0;
        progression.forEach((cntOptFeats,ixLvl)=>{
            if (cntOptFeats === cntPrev)
                return;
            const cntDelta = cntOptFeats - cntPrev;
            if (!~cntDelta)
                return;
            const lvl = ixLvl + 1;
            const requiredUidsUnpacked = (required?.[ixLvl] || []).map(it=>DataUtil.proxy.unpackUid("optionalfeature", it, "optfeature", {
                isLower: true
            }));

            const feature = this._addFauxOptionalFeatureFeatures_getFauxFeature(cls, sc, optFeatProgression, lvl, fauxLoadeds, cntDelta, requiredUidsUnpacked);

            const ixInsertBefore = (sc || cls)[propFeatures].findIndex(it=>{
                return (it.level || fnUnpackUidFeature(it[propFeature] || it).level) > lvl;
            }
            );
            if (~ixInsertBefore)
                (sc || cls)[propFeatures].splice(ixInsertBefore, 0, feature);
            else
                (sc || cls)[propFeatures].push(feature);

            cntPrev = cntOptFeats;
        }
        );
    }

    static _addFauxOptionalFeatureFeatures_getLoadeds(optfeatList, clsSc, optFeatProgression) {
        const availOptFeats = optfeatList.filter(it=>optFeatProgression.featureType instanceof Array && (optFeatProgression.featureType || []).some(ft=>it.featureType.includes(ft)));
        const optionsMeta = {
            setId: CryptUtil.uid(),
            name: optFeatProgression.name
        };
        return availOptFeats.map(it=>{
            return {
                type: "optionalfeature",
                entry: `{@optfeature ${it.name}|${it.source}}`,
                entity: MiscUtil.copy(it),
                optionsMeta,
                page: UrlUtil.PG_OPT_FEATURES,
                source: it.source,
                hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES](it),
                isRequiredOption: false,
            };
        }
        );
    }

    static _addFauxOptionalFeatureFeatures_getFauxFeature(cls, sc, optFeatProgression, lvl, fauxLoadeds, cntOptions, requiredUidsUnpacked) {
        const loadeds = MiscUtil.copy(fauxLoadeds).filter(l=>!ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES]({
            name: l.entity.name,
            source: l.entity.source
        }), "optionalfeature", l.entity.source, {
            isNoCount: true
        }, ));

        loadeds.forEach(l=>{
            l.isRequiredOption = requiredUidsUnpacked.some(it=>it.name === l.entity.name.toLowerCase() && it.source === l.entity.source.toLowerCase());
            l.optionsMeta.count = cntOptions;
            PageFilterClassesFoundry.populateEntityTempData({
                entity: l.entity,
                ancestorClassName: cls.name,
                ancestorSubclassName: sc?.name,
                level: lvl,
                ancestorType: "optionalfeature",
                displayName: `${optFeatProgression.name}: ${l.entity.name}`,
                foundrySystem: {
                    requirements: cls.name ? `${cls.name}${sc ? ` (${sc.name})` : ""} ${lvl}` : null,
                },
            });
        }
        );

        const out = {
            name: optFeatProgression.name,
            level: lvl,
            loadeds: loadeds,
        };

        if (sc) {
            Object.assign(out, {
                source: sc.source,
                subclassFeature: `${optFeatProgression.name}|${cls.name}|${cls.source}|${sc.shortName}|${sc.source}|${lvl}|${Parser.SRC_5ETOOLS_TMP}`,
                hash: UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"]({
                    name: optFeatProgression.name,
                    subclassName: sc.name,
                    subclassSource: sc.source,
                    className: cls.name,
                    classSource: cls.source,
                    level: lvl,
                    source: Parser.SRC_5ETOOLS_TMP,
                }),
            }, );
        } else {
            Object.assign(out, {
                source: cls.source,
                classFeature: `${optFeatProgression.name}|${cls.name}|${cls.source}|${lvl}|${Parser.SRC_5ETOOLS_TMP}`,
                hash: UrlUtil.URL_TO_HASH_BUILDER["classFeature"]({
                    name: optFeatProgression.name,
                    className: cls.name,
                    classSource: cls.source,
                    level: lvl,
                    source: Parser.SRC_5ETOOLS_TMP,
                }),
            }, );
        }

        return out;
    }

    static getExistingClassItems(actor, cls) {
        if (!cls)
            return [];

        return actor.items.filter(actItem=>{
            if (actItem.type !== "class")
                return false;

            const {page, source, hash, propDroppable} = MiscUtil.get(actItem, "flags", SharedConsts.MODULE_ID) || {};
            if (page === UrlUtil.PG_CLASSES && propDroppable === "class" && source === cls.source && hash === UrlUtil.URL_TO_HASH_BUILDER["class"](cls))
                return true;

            return (actItem.name || "").toLowerCase().trim() === cls.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(actItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(cls.source).toLowerCase());
        }
        );
    }

    static getExistingSubclassItems(actor, cls, sc) {
        if (!cls || !sc)
            return [];

        return actor.items.filter(actItem=>{
            if (actItem.type !== "subclass")
                return false;

            const {page, source, hash, propDroppable} = MiscUtil.get(actItem, "flags", SharedConsts.MODULE_ID) || {};
            if (page === UrlUtil.PG_CLASSES && propDroppable === "subclass" && source === sc.source && hash === UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc))
                return true;

            return (actItem.name || "").toLowerCase().trim() === sc.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(actItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(sc.source).toLowerCase());
        }
        );
    }

    static getClassFromExistingClassItem(existingClassItem, classes) {
        if (!existingClassItem || existingClassItem.type !== "class" || !classes?.length)
            return null;

        classes = [...classes].sort(this._sortByOfficialAndRecent.bind(this));

        return classes.find(cls=>cls.name.toLowerCase().trim() === existingClassItem.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(existingClassItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(cls.source).toLowerCase()), );
    }

    static getSubclassFromExistingSubclassItem(existingSubclassItem, cls, subclasses) {
        if (!existingSubclassItem || existingSubclassItem.type !== "subclass" || !subclasses?.length)
            return null;

        subclasses = subclasses.filter(it=>it.className === cls.name && it.classSource === cls.source);

        subclasses = [...subclasses].sort(this._sortByOfficialAndRecent.bind(this));

        return subclasses.find(sc=>sc.name.toLowerCase().trim() === existingSubclassItem.name.toLowerCase().trim() || sc.shortName.toLowerCase().trim() === existingSubclassItem.name.toLowerCase().trim(), );
    }

    static _sortByOfficialAndRecent(a, b) {
        const isNonStandardSourceA = SourceUtil.isNonstandardSource(a.source);
        const isNonStandardSourceB = SourceUtil.isNonstandardSource(b.source);

        if (isNonStandardSourceA === isNonStandardSourceB) {
            return SortUtil.ascSortDateString(Parser.sourceJsonToDate(a.source), Parser.sourceJsonToDate(b.source)) || SortUtil.ascSortLower(a.name, b.name);
        }

        return isNonStandardSourceA ? 1 : -1;
    }

    static getClassSubclassFeatureReferences(obj) {
        const refsClassFeature = [];
        const refsSubclassFeature = [];

        MiscUtil.getWalker({
            isNoModification: true
        }).walk(obj, {
            object: (obj)=>{
                if (obj.type === "refClassFeature") {
                    refsClassFeature.push(MiscUtil.copy(obj));
                    return;
                }

                if (obj.type === "refSubclassFeature") {
                    refsSubclassFeature.push(MiscUtil.copy(obj));
                }
            }
            ,
        }, );

        return {
            refsClassFeature,
            refsSubclassFeature
        };
    }

    static getClassSubclassItemTuples({classItems, subclassItems}) {
        if (!classItems?.length)
            return [];

        subclassItems = subclassItems || [];

        return classItems.map(classItem=>({
            classItem,
            subclassItem: subclassItems.find(it=>it.system.classIdentifier === classItem.system.identifier),
        }));
    }

    static getToolProficiencyData(profs) {
        if (!profs)
            return null;
        if (profs.toolProficiencies)
            return profs.toolProficiencies;
        if (!profs.tools)
            return null;

        const out = {};
        profs.tools.forEach(str=>{
            const itemUid = UtilActors.getItemUIdFromToolProficiency(str);
            if (!itemUid)
                return;
            const mappedTool = UtilActors.getMappedTool(itemUid);
            if (!mappedTool)
                return;
            const unmappedTool = UtilActors.getUnmappedTool(mappedTool);
            if (!unmappedTool)
                return;
            out[unmappedTool] = true;
        }
        );

        return [out];
    }
}

Charactermancer_Class_Util.ExistingFeatureChecker = class {
    constructor(actor) {
        this._actor = actor;

        this._existingSheetFeatures = {};
        this._existingImportFeatures = {};

        actor.items.filter(it=>it.type === "feat").forEach(it=>{
            const cleanSource = (UtilDocumentSource.getDocumentSource(it).source || "").trim().toLowerCase();
            Charactermancer_Class_Util.ExistingFeatureChecker._getNameAliases(it.name).forEach(alias=>this._existingSheetFeatures[alias] = cleanSource);

            const {page, source, hash} = it.flags?.[SharedConsts.MODULE_ID] || {};
            if (page && source && hash)
                this.addImportFeature(page, source, hash);
        }
        );
    }

    static _getNameAliases(name) {
        const cleanName = name.trim().toLowerCase();
        const out = [cleanName, ];

        const mTrailingParens = /^(.*?)\(.*\)$/.exec(cleanName);
        if (mTrailingParens)
            out.push(mTrailingParens[1].trim());

        if (cleanName.includes(": ")) {
            const cleanNamePostColon = cleanName.split(":").slice(1).join(":").trim();
            out.push(cleanNamePostColon);
            const mTrailingParensPostColon = /^(.*?)\(.*\)$/.exec(cleanNamePostColon);
            if (mTrailingParensPostColon)
                out.push(mTrailingParensPostColon[1].trim());
        }

        return out;
    }

    isExistingFeature(name, page, source, hash) {
        if (MiscUtil.get(this._existingImportFeatures, page, source, hash))
            return true;

        const searchNameAliases = Charactermancer_Class_Util.ExistingFeatureChecker._getNameAliases(name);
        if (!searchNameAliases.some(it=>this._existingSheetFeatures[it]))
            return false;

        if (!Config.get("import", "isStrictMatching"))
            return true;

        const searchSource = Parser.sourceJsonToAbv(source).trim().toLowerCase();
        return searchNameAliases.some(it=>this._existingSheetFeatures[it] === searchSource);
    }

    addImportFeature(page, source, hash) {
        MiscUtil.set(this._existingImportFeatures, page, source, hash, true);
    }
}
;

class Charactermancer_ProficiencySelect extends BaseComponent {
}

Charactermancer_ProficiencySelect.PropGroup = class {
    constructor({prop, propTrackerPulse, propTracker}) {
        this.prop = prop;
        this.propTrackerPulse = propTrackerPulse;
        this.propTracker = propTracker;
    }
}
;

class Charactermancer_OtherProficiencySelect extends Charactermancer_ProficiencySelect {
    static async pGetUserInput(opts) {
        opts = opts || {};

        if (!opts.available)
            return {
                isFormComplete: true,
                data: {}
            };

        const comp = new this({
            ...opts,
            existing: this.getExisting(opts.existingFvtt),
            existingFvtt: opts.existingFvtt,
        });
        if (comp.isNoChoice())
            return comp.pGetFormData();

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            width: 640,
            isAutoResize: true,
        });
    }

    static getExistingFvttFromActor(actor) {
        return {
            skillProficiencies: MiscUtil.get(actor, "_source", "system", "skills"),
            toolProficiencies: MiscUtil.get(actor, "_source", "system", "tools"),
            languageProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "languages"),
            armorProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "armorProf"),
            weaponProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "weaponProf"),
            savingThrowProficiencies: MiscUtil.get(actor, "_source", "system", "abilities"),
        };
    }

    static getExisting(existingFvtt) {
        return {
            skillProficiencies: this._getExistingSkillToolProficiencies({
                existingProficienciesSetFvtt: existingFvtt.skillProficiencies,
                mapAbvToFull: UtilActors.SKILL_ABV_TO_FULL,
            }),
            toolProficiencies: this._getExistingSkillToolProficiencies({
                existingProficienciesSetFvtt: existingFvtt.toolProficiencies,
                mapAbvToFull: UtilActors.SKILL_ABV_TO_FULL,
            }),
            languageProficiencies: this._getExistingProficiencies({
                existingProficienciesSetFvtt: existingFvtt?.languageProficiencies,
                vetToFvttProfs: UtilActors.VALID_LANGUAGES,
                allProfsVet: Parser.LANGUAGES_ALL,
            }),
            armorProficiencies: this._getExistingProficiencies({
                existingProficienciesSetFvtt: existingFvtt?.armorProficiencies,
                vetToFvttProfs: UtilActors.VALID_ARMOR_PROFICIENCIES,
                allProfsVet: UtilActors.ARMOR_PROFICIENCIES,
            }),
            weaponProficiencies: this._getExistingProficiencies({
                existingProficienciesSetFvtt: existingFvtt?.weaponProficiencies,
                vetToFvttProfs: UtilActors.VALID_WEAPON_PROFICIENCIES,
                allProfsVet: UtilActors.WEAPON_PROFICIENCIES,
            }),
            savingThrowProficiencies: this._getExistingSavingThrowProficiencies(existingFvtt),
        };
    }

    static isNoChoice(available) {
        return this._isNoChoice({
            available
        });
    }

    static _isNoChoice({available, isAlreadyMapped}) {
        if (!available?.length)
            return true;
        if (isAlreadyMapped && !this._isValidAvailableData(available))
            throw new Error(`Proficiency data was not valid! Data was:\n${JSON.stringify(available)}`);

        if (!isAlreadyMapped)
            available = Charactermancer_OtherProficiencySelect._getNormalizedAvailableProficiencies(available);

        return available.length === 1 && !available[0].choose;
    }

    static _isValidAvailableData(available) {
        if (!(available instanceof Array))
            return false;

        for (const profSet of available) {
            const badKeys = Object.keys(profSet).filter(it=>it !== "static" && it !== "choose");
            if (badKeys.length)
                return false;

            if ((profSet.static || []).filter(it=>!it.prop).length)
                return false;
            if ((profSet.choose || []).filter(it=>it.from && it.from.some(from=>!from.prop)).length)
                return false;
            if ((profSet.choose || []).filter(it=>it.fromFilter && !it.prop).length)
                return false;
        }

        return true;
    }

    static getMappedSkillProficiencies(skillProficiencies) {
        if (!skillProficiencies)
            return skillProficiencies;
        return skillProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anySkill = it.any;
                delete it.any;
            }
            if (it.choose?.from && CollectionUtil.setEq(new Set(it.choose.from), new Set(Renderer.generic.FEATURE__ALL_SKILLS))) {
                it.anySkill = it.choose.count ?? 1;
                delete it.choose;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "skillProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedLanguageProficiencies(languageProficiencies) {
        if (!languageProficiencies)
            return languageProficiencies;
        return languageProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyLanguage = it.any;
                delete it.any;
            }
            if (it.anyStandard) {
                it.anyStandardLanguage = it.anyStandard;
                delete it.anyStandard;
            }
            if (it.anyExotic) {
                it.anyExoticLanguage = it.anyExotic;
                delete it.anyExotic;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "languageProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "languageProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedToolProficiencies(toolProficiencies) {
        if (!toolProficiencies)
            return toolProficiencies;
        return toolProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyTool = it.any;
                delete it.any;
            }
            if (it.anyArtisans) {
                it.anyArtisansTool = it.anyArtisans;
                delete it.anyArtisans;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "toolProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "toolProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedArmorProficiencies(armorProficiencies) {
        if (!armorProficiencies)
            return armorProficiencies;
        return armorProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyArmor = it.any;
                delete it.any;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "armorProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "armorProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedWeaponProficiencies(weaponProficiencies) {
        if (!weaponProficiencies)
            return weaponProficiencies;
        return weaponProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyWeapon = it.any;
                delete it.any;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "weaponProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "weaponProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedSavingThrowProficiencies(savingThrowProficiencies) {
        if (!savingThrowProficiencies)
            return savingThrowProficiencies;
        return savingThrowProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anySavingThrow = it.any;
                delete it.any;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "savingThrowProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "savingThrowProficiencies"
            });
            return it;
        }
        );
    }

    static _getMappedProficiencies_expandChoose({proficienciesSet, prop}) {
        if (!proficienciesSet.choose)
            return;
        if (proficienciesSet.choose.fromFilter)
            proficienciesSet.choose.prop = prop;
        if (proficienciesSet.choose.from) {
            proficienciesSet.choose.from = proficienciesSet.choose.from.map(it=>{
                if (typeof it !== "string")
                    return it;
                return {
                    prop,
                    name: it
                };
            }
            );
        }
        proficienciesSet.choose = [proficienciesSet.choose];
    }

    static _getMappedProficiencies_expandStatic({proficienciesSet, prop, ignoredKeys}) {
        Object.entries(proficienciesSet).forEach(([k,v])=>{
            if ((ignoredKeys && ignoredKeys.has(k)) || Charactermancer_OtherProficiencySelect._MAPPED_IGNORE_KEYS.has(k))
                return;

            if (typeof v === "boolean") {
                proficienciesSet[k] = {
                    prop
                };
                return;
            }
            if (typeof v === "number") {
                proficienciesSet[k] = {
                    prop,
                    count: v
                };
                return;
            }

            throw new Error(`Unhandled type "${typeof v}" for value of proficiency "${k}"`);
        }
        );
    }

    static _getExistingFvttProficiencySetsMeta(existingFvtt) {
        return {
            existingProficienciesFvttSet: new Set(existingFvtt?.value || []),
            existingProficienciesFvttSetCustom: new Set((existingFvtt?.custom || "").split(";").map(it=>it.trim().toLowerCase()).filter(Boolean)),
        };
    }

    constructor(opts) {
        opts = opts || {};
        super();

        this._existing = opts.existing;
        this._available = Charactermancer_OtherProficiencySelect._getNormalizedAvailableProficiencies(opts.available);
        this._titlePrefix = opts.titlePrefix;
        this._featureSourceTracker = opts.featureSourceTracker || new Charactermancer_FeatureSourceTracker();
        this._$elesPreFromGroups = opts.$elesPreFromGroups;
        this._$elesPostFromGroups = opts.$elesPostFromGroups;

        this._lastMetas = [];
        this._hkExisting = null;
    }

    static _getNormalizedAvailableProficiencies(availProfs) {
        return availProfs.map(availProfSet=>{
            const out = {};

            Object.entries(availProfSet).forEach(([k,v])=>{
                if (!v)
                    return;

                switch (k) {
                case "choose":
                    {
                        v.forEach(choose=>{
                            const mappedCount = choose.count != null && !isNaN(choose.count) ? Number(choose.count) : 1;
                            if (mappedCount <= 0)
                                return;

                            const mappedFroms = (choose?.from || []).map(it=>Renderer.generic.getMappedAnyProficiency({
                                keyAny: it,
                                countRaw: mappedCount
                            }) || this._getNormalizedProficiency(null, it)).filter(Boolean);

                            const mappedFromFilter = (choose?.fromFilter || "").trim();

                            if (!mappedFroms.length && !mappedFromFilter)
                                return;
                            if (mappedFroms.length && mappedFromFilter)
                                throw new Error(`Invalid proficiencies! Only one of "from" and "fromFilter" may be provided. Data was:\n${JSON.stringify(choose)}`);

                            const tgt = (out.choose = out.choose || []);

                            if (mappedFromFilter) {
                                if (!choose.type && !choose.prop)
                                    throw new Error(`"fromFilter" did not have an associated "type"!`);
                                tgt.push({
                                    fromFilter: mappedFromFilter,
                                    count: mappedCount,
                                    prop: choose.prop || this._getNormalizedProficiencyPropFromType(choose.type)
                                });
                                return;
                            }

                            if (!mappedFroms.length)
                                return;

                            const subOut = {
                                from: [],
                                count: mappedCount
                            };
                            mappedFroms.forEach(it=>{
                                if (it.from) {
                                    subOut.from = [...subOut.from, ...it.from];
                                    if (it.groups)
                                        Object.assign((subOut.groups = subOut.groups || {}), it.groups);
                                    return;
                                }

                                subOut.from.push(it);
                            }
                            );
                            tgt.push(subOut);
                        }
                        );

                        break;
                    }

                case "anySkill":
                case "anyTool":
                case "anyArtisansTool":
                case "anyMusicalInstrument":
                case "anyLanguage":
                case "anyStandardLanguage":
                case "anyExoticLanguage":
                case "anyWeapon":
                case "anyArmor":
                case "anySavingThrow":
                    {
                        const mappedAny = Renderer.generic.getMappedAnyProficiency({
                            keyAny: k,
                            countRaw: v
                        });
                        if (!mappedAny)
                            break;
                        (out.choose = out.choose || []).push(mappedAny);
                        break;
                    }

                default:
                    {
                        if (k === "static")
                            throw new Error(`Property handling for "static" is unimplemented!`);

                        if (v?.prop) {
                            (out.static = out.static || []).push({
                                name: k,
                                prop: v.prop
                            });
                            break;
                        }
                        if (v?.type) {
                            (out.static = out.static || []).push({
                                name: k,
                                prop: this._getNormalizedProficiencyPropFromType(v.type)
                            });
                            break;
                        }

                        const normalized = this._getNormalizedProficiency(k, v);
                        if (normalized)
                            (out.static = out.static || []).push(normalized);
                    }
                }
            }
            );

            if (out.static && out.choose) {
                out.choose.forEach(choose=>{
                    if (choose.fromFilter)
                        return;

                    choose.from = choose.from.filter(({name, prop})=>!out.static.some(({name: nameStatic, prop: propStatic})=>nameStatic === name && propStatic === prop));
                }
                );
            }

            return out;
        }
        );
    }

    static _getNormalizedProficiency(k, v) {
        if (!v){return null;}

        let name = v?.name ?? k ?? v;
        if (!name || typeof name !== "string"){return null;}
        name = name.trim();

        if (v?.prop) {
            return {
                name,
                prop: v.prop
            };
        }

        if (v?.type) {
            const prop = this._getNormalizedProficiencyPropFromType(v.type);
            return {
                name,
                prop
            };
        }

        if (Charactermancer_OtherProficiencySelect._VALID_SKILLS.has(name))
            return {
                name,
                prop: "skillProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_TOOLS.has(name))
            return {
                name,
                prop: "toolProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_LANGUAGES.has(name))
            return {
                name,
                prop: "languageProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_WEAPONS.has(name))
            return {
                name,
                prop: "weaponProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_ARMORS.has(name))
            return {
                name,
                prop: "armorProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_SAVING_THROWS.has(name))
            return {
                name,
                prop: "savingThrowProficiencies"
            };

        console.warn(...LGT, `Could not discern the type of proficiency "${name}"\u2014you may need to specify it directly with "type".`);

        return null;
    }

    static _getNormalizedProficiencyPropFromType(type) {
        type = type.trim().toLowerCase();
        switch (type) {
        case "skill":
            return "skillProficiencies";
        case "tool":
            return "toolProficiencies";
        case "language":
            return "languageProficiencies";
        case "weapon":
            return "weaponProficiencies";
        case "armor":
            return "armorProficiencies";
        case "savingThrow":
            return "savingThrowProficiencies";
        default:
            throw new Error(`Type "${type}" did not have an associated proficiency property!`);
        }
    }

    static _getTagFromProp(prop) {
        switch (prop) {
        case "armorProficiencies":
            return "@item";
        case "weaponProficiencies":
            return "@item";
        default:
            throw new Error(`Cannot get @tag from prop "${prop}"`);
        }
    }

    _getTitle() {
        const props = this._getAllPossibleProps();
        return `${props.map(prop=>this.constructor._getPropDisplayName({
            prop
        })).join("/")} Proficiency`;
    }

    _getTitlePlural() {
        const props = this._getAllPossibleProps();
        return `${props.map(prop=>this.constructor._getPropDisplayName({
            prop,
            isPlural: true
        })).join("/")} Proficiencies`;
    }

    _getAllPossibleProps() {
        const propSet = new Set();

        this._available.forEach(profSet=>{
            const subSet = this.constructor._getAllPossiblePropsForProfSet(profSet);
            subSet.forEach(prop=>propSet.add(prop));
        }
        );

        return [...propSet];
    }

    static _getAllPossiblePropsForProfSet(profSet) {
        const out = new Set();
        (profSet.static || []).forEach(it=>out.add(it.prop));
        (profSet.choose || []).forEach(it=>{
            if (it.prop)
                return out.add(it.prop);
            it.from.forEach(from=>out.add(from.prop));
        }
        );
        return out;
    }

    get modalTitle() {
        return this._getTitlePlural();
    }

    render($wrp) {
        const $stgSelGroup = this._render_$getStgSelGroup();

        const $stgGroup = $$`<div class="ve-flex-col"></div>`;

        const hkIxSet = ()=>{
            $stgGroup.empty();

            if (this._featureSourceTracker && this._hkExisting) {
                Object.values(Charactermancer_OtherProficiencySelect._PROP_GROUPS).forEach(({propTrackerPulse})=>this._featureSourceTracker.removeHook(this, propTrackerPulse, this._hkExisting));
            }
            this._lastMetas.forEach(it=>it.cleanup());
            this._lastMetas = [];

            const selProfs = this._available[this._state.ixSet];

            //TEMPFIX
            //if (this._featureSourceTracker){this._doSetTrackerState();}

            const $ptsExistingStatic = selProfs.static?.length ? this._render_renderPtStatic($stgGroup, selProfs.static) : null;

            if ($ptsExistingStatic && selProfs.choose?.length){$stgGroup.append(`<hr class="hr-2">`);}

            const $ptsExistingChoose = (selProfs.choose || []).map(({count, from, groups, fromFilter, prop},i)=>{
                if (this._$elesPreFromGroups?.[i])
                    $stgGroup.append(this._$elesPreFromGroups?.[i]);

                const $outPtsExisting = fromFilter ? this._render_renderPtChooseFromFilter($stgGroup, {
                    ix: i,
                    count,
                    fromFilter,
                    prop
                }) : this._render_renderPtChooseFrom($stgGroup, {
                    ix: i,
                    count,
                    from,
                    groups
                });

                if (this._$elesPostFromGroups?.[i])
                    $stgGroup.append(this._$elesPostFromGroups?.[i]);

                if (selProfs.choose.length > 1 && (i < selProfs.choose.length - 1)) {
                    $stgGroup.append(`<hr class="hr-2">`);
                }

                return $outPtsExisting;
            }
            );

            this._hkExisting = ()=>this._hk_pUpdatePtsExisting($ptsExistingStatic, $ptsExistingChoose);
            if (this._featureSourceTracker) {
                Object.values(Charactermancer_OtherProficiencySelect._PROP_GROUPS).forEach(({propTrackerPulse})=>this._featureSourceTracker.addHook(this, propTrackerPulse, this._hkExisting));
            }
            this._hkExisting();
        }
        ;
        this._addHookBase("ixSet", hkIxSet);
        hkIxSet();

        $$`
			${$stgSelGroup}
			${$stgGroup}
		`.appendTo($wrp);
    }

    _doSetTrackerState() {
        const formData = this._getFormData();
        this._featureSourceTracker.setState(this, Object.keys(Charactermancer_OtherProficiencySelect._PROP_GROUPS).mergeMap(prop=>({
            [prop]: formData.data?.[prop]
        })), );
    }

    static _render_getStaticKeyFullText({name, prop}) {
        switch (prop) {
        case "weaponProficiencies":
            return name.split("|")[0].toTitleCase();

        case "armorProficiencies":
            {
                switch (name) {
                case "light":
                case "medium":
                case "heavy":
                    return name.toTitleCase();
                case "shield|phb":
                    return "Shields";
                default:
                    return name.split("|")[0].toTitleCase();
                }
            }

        case "savingThrowProficiencies":
            return Parser.attAbvToFull(name).toTitleCase();

        default:
            return name.toTitleCase();
        }
    }

    static _render_getStaticKeyFullTextOther({prop}) {
        switch (prop) {
        case "skillProficiencies":
            return "(Other skill proficiency)";
        case "toolProficiencies":
            return "(Other tool proficiency)";
        case "languageProficiencies":
            return "(Other language proficiency)";
        case "weaponProficiencies":
            return "(Other weapon proficiency)";
        case "armorProficiencies":
            return "(Other armor proficiency)";
        case "savingThrowProficiencies":
            return "(Other saving throw proficiency)";
        default:
            throw new Error(`Unhandled prop "${prop}"`);
        }
    }

    static async _pGetParentGroup({prop, name}) {
        switch (prop) {
        case "weaponProficiencies":
            return UtilDataConverter.pGetItemWeaponType(name);
        default:
            return null;
        }
    }

    static _getRenderedStatic({prop, name}) {
        switch (prop) {
        case "skillProficiencies":
            return this._getRenderedStatic_skillProficiencies(name);
        case "languageProficiencies":
            return this._getRenderedStatic_languageProficiencies(name);
        case "toolProficiencies":
            return this._getRenderedStatic_toolProficiencies(name);
        case "armorProficiencies":
            return this._getRenderedStatic_armorProficiencies(name);
        case "weaponProficiencies":
            return Renderer.get().render(`{@item ${name.split("|").map(sub=>sub.toTitleCase()).join("|")}}`);
        case "savingThrowProficiencies":
            return Parser.attAbvToFull(name).toTitleCase();
        default:
            return name.toTitleCase();
        }
    }

    static _getRenderedStatic_skillProficiencies(name) {
        const atb = Parser.skillToAbilityAbv(name);
        const ptAbility = `<div class="ml-1 ve-small ve-muted" title="${Parser.attAbvToFull(atb)}">(${atb.toTitleCase()})</div>`;

        return `<div class="ve-inline-flex-v-center">${Renderer.get().render(`{@skill ${name.toTitleCase()}}`)}${ptAbility}</div>`;
    }

    static _getRenderedStatic_languageProficiencies(name) {
        if (name === "other"){return name.toTitleCase();}
        if (UtilActors.LANGUAGES_PRIMORDIAL.includes(name))
            {return Renderer.get().render(`{@language primordial||${name.toTitleCase()}}`);}
        return Renderer.get().render(`{@language ${name.toTitleCase()}}`);
    }

    static _getRenderedStatic_toolProficiencies(name) {
        if (UtilActors.TOOL_PROFICIENCIES_TO_UID[name])
            return Renderer.get().render(`{@item ${UtilActors.TOOL_PROFICIENCIES_TO_UID[name].toTitleCase()}}`);
        return name.toTitleCase();
    }

    static _getRenderedStatic_armorProficiencies(key) {
        if (key === "light" || key === "medium" || key === "heavy")
            return key.toTitleCase();
        if (key === "shield|phb")
            return Renderer.get().render(`{@item shield|phb|Shields}`);
        return Renderer.get().render(`{@item ${key.split("|").map(sub=>sub.toTitleCase()).join("|")}}`);
    }

    static _getPropDisplayName({prop}) {
        switch (prop) {
        case "skillProficiencies":
            return `Skill`;
        case "toolProficiencies":
            return `Tool`;
        case "languageProficiencies":
            return `Language`;
        case "weaponProficiencies":
            return `Weapon`;
        case "armorProficiencies":
            return `Armor`;
        case "savingThrowProficiencies":
            return `Saving Throw`;
        default:
            throw new Error(`Unhandled prop "${prop}"`);
        }
    }

    _render_$getStgSelGroup() {
        if (this._available.length <= 1)
            return null;

        const $selIxSet = ComponentUiUtil.$getSelEnum(this, "ixSet", {
            placeholder: `Select ${this._getTitle()} Set`,
            values: this._available.map((_,i)=>i),
            fnDisplay: ix=>{
                const selProfs = this._available[ix];

                const out = [];

                if (selProfs.static) {
                    const pt = MiscUtil.copy(selProfs.static).sort((a,b)=>SortUtil.ascSortLower(a.name, b.name)).map(({name, prop})=>{
                        if (name === "other")
                            return this.constructor._render_getStaticKeyFullTextOther({
                                prop
                            });
                        return this.constructor._render_getStaticKeyFullText({
                            name,
                            prop
                        });
                    }
                    ).join(", ");
                    out.push(pt);
                }

                if (selProfs.choose) {
                    selProfs.choose.forEach(fromBlock=>{
                        if (fromBlock.name) {
                            out.push(`Choose ${fromBlock.name.toLowerCase()}`);
                            return;
                        }

                        if (fromBlock.fromFilter) {
                            out.push(`Choose ${Parser.numberToText(fromBlock.count)} from filtered selection`);
                            return;
                        }

                        if (fromBlock.groups) {
                            out.push(`Choose ${Parser.numberToText(fromBlock.count)} from ${Object.values(fromBlock.groups).map(({name})=>name).joinConjunct(", ", " or ")}`);
                            return;
                        }

                        out.push(`Choose ${Parser.numberToText(fromBlock.count || 1)} from ${fromBlock.from.map(({name})=>name.toTitleCase()).join(", ")}`);
                    }
                    );
                }

                return out.filter(Boolean).join("; ") || "(Nothing)";
            }
            ,
        }, );

        if (this._featureSourceTracker) {
            const hk = ()=>{
                const formData = this._getFormData().data;
                const trackerState = Object.keys(formData.data || {}).filter(k=>Charactermancer_OtherProficiencySelect._PROP_GROUPS[k]).mergeMap(it=>it);
                this._featureSourceTracker.setState(this, trackerState);
            }
            ;
            this._addHookBase("ixSet", hk);
        }

        return $$`<div class="w-100 mb-2 ve-flex-vh-center">
			${$selIxSet}
		</div>`;
    }

    _getAllValuesMaybeInUseLookup() {
        const out = {};

        const activeSet = this._available[this._state.ixSet] || {};

        if (activeSet.static) {
            activeSet.static.forEach(({name, prop})=>{
                out[prop] = out[prop] || new Set();
                out[prop].add(name);
            }
            );
        }

        if (activeSet.choose) {
            activeSet.choose.forEach(({from, fromFilter})=>{
                if (fromFilter) {
                    const prefix = `${this._getStateKeyPrefix()}_chooseFilter_`;
                    Object.entries(this._state).filter(([k,v])=>k.startsWith(prefix) && v).forEach(([,{prop, name}])=>{
                        if (!name)
                            throw new Error(`"fromFilter" choice had no "name"--this should never occur!`);
                        out[prop] = out[prop] || new Set();
                        out[prop].add(name);
                    }
                    );
                    return;
                }

                from.forEach(({name, prop})=>{
                    out[prop] = out[prop] || new Set();
                    out[prop].add(name);
                }
                );
            }
            );
        }

        return out;
    }

    _getStateKeyPrefix() {
        return "otherProfSelect";
    }

    _getPropsChooseFromFilter({ixChoose, ixCount}) {
        return {
            propState: `${this._getStateKeyPrefix()}_chooseFilter_${ixChoose}_${ixCount}`,
        };
    }

    _getPropsChooseFrom({ixChoose}) {
        return {
            propState: `${this._getStateKeyPrefix()}_${ixChoose}`,
        };
    }

    async _hk_pUpdatePtsExisting($ptsExistingStatic, $ptsExistingChooseFrom) {
        try {
            await this._pLock("updateExisting");
            await this._hk_pUpdatePtsExisting_({
                $ptsExistingStatic,
                $ptsExistingChooseFrom
            });
        } finally {
            this._unlock("updateExisting");
        }
    }

    async _hk_pUpdatePtsExisting_({$ptsExistingStatic, $ptsExistingChooseFrom}) {
        const allValueLookupEntries = Object.entries(this._getAllValuesMaybeInUseLookup());

        if ($ptsExistingStatic)
            await this._hk_pUpdatePtsExisting_part({
                allValueLookupEntries,
                $ptsExisting: $ptsExistingStatic
            });
        if (!$ptsExistingChooseFrom)
            return;
        for (const $ptsExisting of $ptsExistingChooseFrom)
            await this._hk_pUpdatePtsExisting_part({
                allValueLookupEntries,
                $ptsExisting
            });
    }

    async _hk_pUpdatePtsExisting_part({allValueLookupEntries, $ptsExisting}) {
        for (const [prop,allProfs] of allValueLookupEntries) {
            const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(prop, {
                ignore: this
            }) : null;

            for (const v of allProfs) {
                const parentGroup = await this.constructor._pGetParentGroup({
                    prop,
                    name: v
                });

                if (!$ptsExisting[prop]?.[v] && !parentGroup)
                    continue;

                let maxExisting = this._existing?.[prop]?.[v] || (parentGroup && this._existing?.[prop]?.[parentGroup]) || 0;

                if (otherStates)
                    otherStates.forEach(otherState=>maxExisting = Math.max(maxExisting, otherState[v] || 0, (parentGroup ? otherState[parentGroup] : 0) || 0));

                const helpText = maxExisting === 0 ? "" : `${UtilActors.PROF_TO_TEXT[maxExisting]} from Another Source`;

                $ptsExisting[prop][v].title(helpText).toggleClass("ml-1", !!maxExisting).html(maxExisting ? `(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[maxExisting]}"></i>)` : "");
            }
        }
    }

    _render_renderPtStatic($stgGroup, profsStatic) {
        const $ptsExisting = {};

        const byProp = {};
        profsStatic.forEach(({prop, name})=>MiscUtil.set(byProp, prop, name, true));
        const isMultiProp = this.constructor._getAllPossiblePropsForProfSet(this._available[this._state.ixSet]).size > 1;

        const $wrps = Object.entries(byProp).map(([prop,profsStaticSet])=>{
            const ptPropType = isMultiProp ? ` (${this.constructor._getPropDisplayName({
                prop
            })} Proficiency)` : "";
            const profsStaticSetKeys = Object.keys(profsStaticSet);
            return profsStaticSetKeys.sort(SortUtil.ascSortLower).map((name,i)=>{
                const $ptExisting = $(`<div class="ve-small veapp__msg-warning inline-block"></div>`);
                MiscUtil.set($ptsExisting, prop, name, $ptExisting);
                const isNotLast = i < profsStaticSetKeys.length - 1;
                return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${this.constructor._getRenderedStatic({
                    prop,
                    name
                })}${ptPropType}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
            }
            );
        }
        ).flat();

        $$`<div class="block">
			${$wrps}
		</div>`.appendTo($stgGroup);

        return $ptsExisting;
    }

    _render_renderPtChooseFrom($stgGroup, {ix, count, from, groups}) {
        const {propState} = this._getPropsChooseFrom({
            ixChoose: ix
        });

        const $ptsExisting = {};
        const compOpts = {
            count,
            fnDisplay: ({prop, name})=>{
                const $ptExisting = $(`<div class="ve-small veapp__msg-warning"></div>`);
                MiscUtil.set($ptsExisting, prop, name, $ptExisting);

                return $$`<div class="ve-flex-v-center w-100">
					<div class="ve-flex-v-center">${this.constructor._getRenderedStatic({
                    prop,
                    name
                })}</div>
					${$ptExisting}
				</div>`;
            }
            ,
        };

        const fromProps = new Set(from.map(({prop})=>prop));

        const byPropThenGroup = {};

        from.forEach(({name, prop, group})=>{
            group = group ?? "_";
            MiscUtil.set(byPropThenGroup, prop, group, name, Charactermancer_OtherProficiencySelect._PROFICIENT);
        }
        );

        const isMultiProp = Object.keys(byPropThenGroup).length > 1;
        const isGrouped = Object.values(byPropThenGroup).some(groupMeta=>Object.keys(groupMeta).some(group=>group !== "_"));

        if (isMultiProp || isGrouped) {
            const valueGroups = [];
            Object.entries(byPropThenGroup).forEach(([prop,groupMeta])=>{
                Object.entries(groupMeta).forEach(([groupId,names])=>{
                    const groupDetails = groups?.[groupId];

                    valueGroups.push({
                        name: [(isMultiProp ? `${this.constructor._getPropDisplayName({
                            prop
                        })} Proficiencies` : ""), groupDetails?.name, ].filter(Boolean).join(""),
                        text: groupDetails?.hint,
                        values: Object.keys(names).map(name=>({
                            prop,
                            name
                        })),
                    });
                }
                );
            }
            );

            compOpts.valueGroups = valueGroups;
        } else {
            compOpts.values = from;
        }

        const meta = ComponentUiUtil.getMetaWrpMultipleChoice(this, propState, compOpts, );

        let hkSetTrackerInfo = null;
        if (this._featureSourceTracker) {
            hkSetTrackerInfo = ()=>this._doSetTrackerState();
            this._addHookBase(meta.propPulse, hkSetTrackerInfo);
        }

        this._lastMetas.push({
            cleanup: ()=>{
                meta.cleanup();
                if (hkSetTrackerInfo)
                    this._removeHookBase(meta.propPulse, hkSetTrackerInfo);
            }
            ,
        });

        const header = fromProps.size === 1 ? (`${this.constructor._getPropDisplayName({
            prop: [...fromProps][0]
        })} ${count === 1 ? "Proficiency" : "Proficiencies"}`) : (count === 1 ? this._getTitle() : this._getTitlePlural());
        $stgGroup.append(`<div class="mb-1">${this._titlePrefix ? `${this._titlePrefix}: ` : ""}Choose ${Parser.numberToText(count)} ${header}:</div>`);
        meta.$ele.appendTo($stgGroup);

        return $ptsExisting;
    }

    _render_renderPtChooseFromFilter($stgGroup, {ix, fromFilter, count, prop}) {
        const $ptsExisting = {};

        const $row = $(`<div class="ve-flex-v-center"></div>`);

        [...new Array(count)].forEach((_,i)=>{
            const {propState} = this._getPropsChooseFromFilter({
                ixChoose: ix,
                ixCount: i
            });

            const $ptExisting = $(`<div class="ve-small veapp__msg-warning"></div>`);

            const $disp = $(`<div class="ve-flex-v-center"></div>`);
            const hkChosen = (propHk,valueHk,prevValueHk)=>{
                const isFirstRun = !propHk;
                if (!isFirstRun) {
                    if (prevValueHk) {
                        const {prop: propPrev, name: namePrev} = prevValueHk;
                        const uidPrev = (namePrev || "").toLowerCase();
                        MiscUtil.delete($ptsExisting, propPrev, uidPrev, $ptExisting);
                    }

                    if (valueHk) {
                        const {prop, name} = valueHk || {};
                        const uid = (name || "").toLowerCase();
                        MiscUtil.set($ptsExisting, prop, uid, $ptExisting);
                    }
                }

                $disp.html(this._state[propState] != null ? `<div>${Renderer.get().render(`{${this.constructor._getTagFromProp(prop)} ${this._state[propState].name.toLowerCase()}}`)}</div>` : `<div class="italic ve-muted">(select a ${this.constructor._getPropDisplayName({
                    prop
                }).toLowerCase()} proficiency)</div>`, );

                if (!isFirstRun && this._featureSourceTracker)
                    this._doSetTrackerState();
            }
            ;
            this._addHookBase(propState, hkChosen);
            this._lastMetas.push({
                cleanup: ()=>this._removeHookBase(propState, hkChosen)
            });
            hkChosen();

            const $btnFilter = $(`<button class="btn btn-default btn-xxs mx-1" title="Choose a ${this.constructor._getPropDisplayName({
                prop
            })} Proficiency"><span class="fas fa-fw fa-search"></span></button>`).click(async()=>{
                const selecteds = await this._pGetFilterChoice({
                    prop,
                    fromFilter
                });
                if (selecteds == null || !selecteds.length)
                    return;

                const selected = selecteds[0];
                this._state[propState] = {
                    prop,
                    name: `${selected.name}|${selected.values.sourceJson}`.toLowerCase()
                };
            }
            );

            $$`<div class="ve-flex-v-center mr-1">${$btnFilter}${$disp}${$ptExisting}</div>`.appendTo($row);
        }
        );

        $$`<div class="py-1 ve-flex-v-center">
			${$row}
		</div>`.appendTo($stgGroup);

        return $ptsExisting;
    }

    _pGetFilterChoice({prop, fromFilter}) {
        switch (prop) {
        case "armorProficiencies":
        case "weaponProficiencies":
            {
                const modalFilterItems = new ModalFilterItemsFvtt({
                    filterExpression: fromFilter,
                    namespace: "Charactermancer_OtherProficiencySelect.items",
                    isRadio: true,
                });
                return modalFilterItems.pGetUserSelection({
                    filterExpression: fromFilter
                });
            }

        default:
            throw new Error(`Filter choices for "${prop}" are unimplemented!`);
        }
    }

    isNoChoice() {
        return this.constructor._isNoChoice({
            available: this._available,
            isAlreadyMapped: true
        });
    }

    _getFormData() {
        let isFormComplete = true;
        const out = {};

        const selProfs = this._available[this._state.ixSet];

        (selProfs.static || []).forEach(({prop, name})=>MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT));

        (selProfs.choose || []).forEach(({count, from, groups, fromFilter, prop},ixChoose)=>{
            if (fromFilter) {
                [...new Array(count)].forEach((_,ixCount)=>{
                    const {propState} = this._getPropsChooseFromFilter({
                        ixChoose,
                        ixCount
                    });

                    if (!this._state[propState])
                        return isFormComplete = false;

                    const {prop, name} = this._state[propState];
                    MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT);
                }
                );

                return;
            }

            const {propState} = this._getPropsChooseFrom({
                ixChoose
            });

            const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, propState);
            ixs.map(ix=>from[ix]).forEach(({prop, name})=>MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT));

            if (!this._state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable(propState)])
                isFormComplete = false;
        }
        );

        return {
            isFormComplete,
            data: out,
        };
    }

    pGetFormData() {
        return this._getFormData();
    }

    _getDefaultState() {
        return {
            ixSet: 0,
        };
    }

    static _getExistingProficiencies({existingProficienciesSetFvtt, vetToFvttProfs, allProfsVet}) {
        const {existingProficienciesFvttSet, existingProficienciesFvttSetCustom} = this._getExistingFvttProficiencySetsMeta(existingProficienciesSetFvtt);

        const existing = {};

        Object.entries(vetToFvttProfs).filter(([_,fvtt])=>existingProficienciesFvttSet.has(fvtt)).forEach(([vet,fvtt])=>{
            existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
            existingProficienciesFvttSet.delete(fvtt);
        }
        );

        allProfsVet.forEach(vet=>{
            if (existingProficienciesFvttSet.has(vet)) {
                existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
                existingProficienciesFvttSet.delete(vet);
            } else if (existingProficienciesFvttSetCustom.has(vet)) {
                existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
                existingProficienciesFvttSetCustom.delete(vet);
            }
        }
        );

        if (existingProficienciesFvttSet.size || existingProficienciesFvttSetCustom.size) {
            existing.other = existingProficienciesFvttSet.size + existingProficienciesFvttSetCustom.size;
        }

        return existing;
    }

    static _getExistingSkillToolProficiencies({existingProficienciesSetFvtt, mapAbvToFull}) {
        const existing = {};

        Object.entries(existingProficienciesSetFvtt || {}).forEach(([abv,data])=>{
            if (!data.value)
                return;
            existing[mapAbvToFull[abv]] = data.value;
        }
        );

        return existing;
    }

    static _getExistingSavingThrowProficiencies(existingFvtt) {
        const existing = {};

        Object.entries(existingFvtt?.savingThrowProficiencies || {}).forEach(([ab,data])=>{
            if (!data.proficient)
                return;
            existing[ab] = data.proficient;
        }
        );

        return existing;
    }
}
Charactermancer_OtherProficiencySelect._PROFICIENT = 1;
Charactermancer_OtherProficiencySelect._PROP_GROUPS = {
    "skillProficiencies": {
        propTrackerPulse: "pulseSkillProficiencies",
    },
    "toolProficiencies": {
        propTrackerPulse: "pulseToolProficiencies",
    },
    "languageProficiencies": {
        propTrackerPulse: "pulseLanguageProficiencies",
    },
    "weaponProficiencies": {
        propTrackerPulse: "pulseWeaponProficiencies",
    },
    "armorProficiencies": {
        propTrackerPulse: "pulseArmorProficiencies",
    },
    "savingThrowProficiencies": {
        propTrackerPulse: "pulseSavingThrowProficiencies",
    },
};

Charactermancer_OtherProficiencySelect._MAPPED_IGNORE_KEYS = new Set(["choose", "any", "anySkill", "anyTool", "anyArtisansTool", "anyMusicalInstrument", "anyLanguage", "anyStandardLanguage", "anyExoticLanguage", "anyWeapon", "anyArmor", "anySavingThrow", ]);

Charactermancer_OtherProficiencySelect._VALID_SKILLS = new Set([...Renderer.generic.FEATURE__SKILLS_ALL, "anySkill", ]);
Charactermancer_OtherProficiencySelect._VALID_TOOLS = new Set([...Renderer.generic.FEATURE__TOOLS_ALL, "anyTool", "anyArtisansTool", "anyMusicalInstrument", ]);
Charactermancer_OtherProficiencySelect._VALID_LANGUAGES = new Set([...Renderer.generic.FEATURE__LANGUAGES_ALL, "anyLanguage", "anyStandardLanguage", "anyExoticLanguage", ]);
Charactermancer_OtherProficiencySelect._VALID_WEAPONS = new Set([...UtilActors.WEAPON_PROFICIENCIES, "anyWeapon", ]);
Charactermancer_OtherProficiencySelect._VALID_ARMORS = new Set([...UtilActors.ARMOR_PROFICIENCIES, "anyArmor", ]);
Charactermancer_OtherProficiencySelect._VALID_SAVING_THROWS = new Set([...Parser.ABIL_ABVS, "anySavingThrow", ]);

class Charactermancer_SkillSaveProficiencySelect extends Charactermancer_ProficiencySelect {
    static async pGetUserInput(opts) {
        opts = opts || {};

        if (!opts.available)
            return {
                isFormComplete: true,
                data: {}
            };

        const comp = new this({
            ...opts,
            existing: this.getExisting(opts.existingFvtt),
            existingFvtt: opts.existingFvtt,
        });
        if (comp.isNoChoice())
            return comp.pGetFormData();

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            isAutoResize: true
        });
    }

    static getExisting(existingFvtt) {
        throw new Error(`Unimplemented!`);
    }

    static isNoChoice(available) {
        if (!available?.length)
            return true;
        return available.length === 1 && !available[0].choose;
    }

    constructor(opts) {
        opts = opts || {};
        super();

        this._propGroup = opts.propGroup;
        this._existing = opts.existing;
        this._existingFvtt = opts.existingFvtt;
        this._available = opts.available;
        this._titlePrefix = opts.titlePrefix;
        this._featureSourceTracker = opts.featureSourceTracker;
        this._modalTitle = opts.modalTitle;
        this._title = opts.title;
        this._titlePlural = opts.titlePlural;

        this._hkUpdateExisting = null;
        this._$stgGroup = null;
        this._lastMeta = null;
    }

    get modalTitle() {
        return this._modalTitle;
    }

    _getStaticDisplay(prof, {isPlainText=false}={}) {
        throw new Error(`Unimplemented!`);
    }
    _getMultiChoiceDisplay($ptsExisting, profOrObj) {
        throw new Error(`Unimplemented!`);
    }
    _getMultiChoiceTitle(cpyProfSet, count) {
        throw new Error(`Unimplemented!`);
    }

    _getNonStaticDisplay(key, value, {isPlainText=false}={}) {
        switch (key) {
        case "choose":
            return this._getChooseFromDisplay(key, value, {
                isPlainText
            });
        default:
            throw new Error(`Unhandled non-static key "${key}" (value was ${JSON.stringify(value)})`);
        }
    }

    _getChooseFromDisplay(key, value, {isPlainText=false}={}) {
        return `Choose ${value.count || 1} from ${value.from.map(it=>this._getStaticDisplay(it, {
            isPlainText
        })).join(", ")}`;
    }

    render($wrp) {
        const $stgSelGroup = this._render_$getStgSelGroup();
        this._$stgGroup = $$`<div class="ve-flex-col"></div>`;

        this._addHookBase("ixSet", this._hk_ixSet.bind(this));
        this._hk_ixSet();

        $$($wrp)`
			${$stgSelGroup}
			${this._$stgGroup}
		`;
    }

    _render_$getStgSelGroup() {
        if (this._available.length <= 1)
            return null;

        const $selIxSet = ComponentUiUtil.$getSelEnum(this, "ixSet", {
            values: this._available.map((_,i)=>i),
            fnDisplay: ix=>{
                const v = this._available[ix];

                const out = [];

                out.push(Object.keys(v).sort(SortUtil.ascSortLower).filter(it=>this._isStaticKey(it)).map(k=>this._getStaticDisplay(k, {
                    isPlainText: true
                })).join(", "), );

                Object.keys(v).filter(it=>!this._isStaticKey(it)).forEach(k=>out.push(this._getNonStaticDisplay(k, v[k], {
                    isPlainText: true
                })));

                return out.filter(Boolean).join("; ") || "(Nothing)";
            }
            ,
        }, );

        if (this._featureSourceTracker)
            this._addHookBase("ixSet", ()=>this._doSetTrackerState());

        return $$`<div class="w-100 mb-2 ve-flex-vh-center">
			${$selIxSet}
		</div>`;
    }

    _doSetTrackerState() {
        this._featureSourceTracker.setState(this, {
            [this._propGroup.propTracker]: this._getFormData().data?.[this._propGroup.prop]
        });
    }

    static _getSortedProfSet(profSet) {
        if (!profSet)
            return profSet;

        profSet = MiscUtil.copy(profSet);

        if (profSet.choose?.from) {
            profSet.choose.from.sort((a,b)=>{
                if (typeof a === "object" && typeof b === "object")
                    return 0;
                if (typeof a === "object")
                    return 1;
                if (typeof b === "object")
                    return -1;
                return SortUtil.ascSortLower(a, b);
            }
            );
        }

        return profSet;
    }

    _render_renderPtStatic($stgGroup, profSet) {
        const $ptsExisting = {};

        const profList = this._getStaticKeys_profSet().filter(key=>profSet[key]);

        const $wrps = profList.map((it,i)=>{
            const $ptExisting = $(`<div class="ve-small veapp__msg-warning inline-block"></div>`);
            ($ptsExisting[it] = $ptsExisting[it] || []).push($ptExisting);
            const isNotLast = i < profList.length - 1;
            return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${this._getStaticDisplay(it)}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
        }
        );

        $$`<div class="block">
			${$wrps}
		</div>`.appendTo($stgGroup);

        return $ptsExisting;
    }

    _getStaticKeys_all() {
        throw new Error("Unimplemented!");
    }

    _getStaticKeys_profSet() {
        throw new Error("Unimplemented!");
    }

    _hk_ixSet() {
        this._$stgGroup.empty();

        if (this._featureSourceTracker && this._hkUpdateExisting)
            this._featureSourceTracker.removeHook(this, this._propGroup.propTrackerPulse, this._hkUpdateExisting);
        if (this._lastMeta)
            this._lastMeta.cleanup();

        const profSet = this._available[this._state.ixSet];

        if (this._featureSourceTracker)
            this._doSetTrackerState();

        this._hk_ixSet_renderPts(profSet);

        if (this._featureSourceTracker)
            this._featureSourceTracker.addHook(this, this._propGroup.propTrackerPulse, this._hkUpdateExisting);
        this._hkUpdateExisting();
    }

    _hk_ixSet_renderPts(profSet) {
        const $ptsExistingStatic = Object.keys(profSet).some(it=>this._isStaticKey(it)) ? this._render_renderPtStatic(this._$stgGroup, profSet) : null;

        if ($ptsExistingStatic && profSet.choose)
            this._$stgGroup.append(`<hr class="hr-2 hr--dotted">`);
        const $ptsExistingChooseFrom = profSet.choose ? this._render_renderPtChooseFrom(this._$stgGroup, profSet) : null;

        this._hkUpdateExisting = ()=>this._hk_updatePtsExisting($ptsExistingStatic, $ptsExistingChooseFrom);
    }

    _isStaticKey(key) {
        return this._getStaticKeys_all().includes(key);
    }

    _hk_updatePtsExisting($ptsExistingStatic, $ptsExistingChoose) {
        const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(this._propGroup.propTracker, {
            ignore: this
        }) : null;

        const $ptsExistings = [$ptsExistingStatic, $ptsExistingChoose].filter(Boolean);

        this._getStaticKeys_all().forEach(prof=>{
            $ptsExistings.forEach($ptsExisting=>{
                if (!$ptsExisting[prof])
                    return;

                let maxExisting = this._existing?.[prof] || 0;

                if (otherStates)
                    otherStates.forEach(otherState=>maxExisting = Math.max(maxExisting, otherState[prof] || 0));

                if (maxExisting) {
                    const helpText = maxExisting === 1 ? `Proficient from Another Source` : maxExisting === 2 ? `Proficient with Expertise from Another Source` : `Half-Proficient from Another Source`;

                    $ptsExisting[prof].forEach($ptExisting=>{
                        $ptExisting.title(helpText).addClass("ml-1").html(`(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[maxExisting]}"></i>)`);
                    }
                    );
                } else {
                    $ptsExisting[prof].forEach($ptExisting=>{
                        $ptExisting.title("").removeClass("ml-1").html("");
                    }
                    );
                }
            }
            );
        }
        );
    }

    _render_renderPtChooseFrom($stgGroup, profSet) {
        const count = profSet.choose.count || 1;

        const cpyProfSet = this.constructor._getSortedProfSet(profSet);

        const $ptsExisting = {};
        const multiChoiceMeta = ComponentUiUtil.getMetaWrpMultipleChoice(this, "proficiencyChoice", {
            count,
            values: cpyProfSet.choose.from,
            fnDisplay: profOrObj=>this._getMultiChoiceDisplay($ptsExisting, profOrObj),
        }, );

        let hkSetTrackerInfo = null;
        if (this._featureSourceTracker) {
            hkSetTrackerInfo = ()=>this._doSetTrackerState();
            this._addHookBase(multiChoiceMeta.propPulse, hkSetTrackerInfo);
        }

        $stgGroup.append(`<div class="mb-1">${this._getMultiChoiceTitle(cpyProfSet, count)}:</div>`);
        multiChoiceMeta.$ele.appendTo($stgGroup);

        this._lastMeta = {
            cleanup: ()=>{
                multiChoiceMeta.cleanup();
                if (hkSetTrackerInfo)
                    this._removeHookBase(multiChoiceMeta.propPulse, hkSetTrackerInfo);
            }
            ,
        };

        return $ptsExisting;
    }

    isNoChoice() {
        return this.constructor.isNoChoice(this._available);
    }

    _getFormData() {
        const out = {};

        const profSet = this._available[this._state.ixSet];

        const cpyProfSet = this.constructor._getSortedProfSet(profSet);

        this._getStaticKeys_all().filter(name=>cpyProfSet[name]).map(name=>out[name] = 1);

        if (cpyProfSet.choose) {
            const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, "proficiencyChoice");
            ixs.map(it=>cpyProfSet.choose.from[it]).forEach(name=>out[name] = 1);
        }

        return {
            isFormComplete: !!this._state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable("proficiencyChoice")],
            data: {
                [this._propGroup.prop]: out,
            },
        };
    }

    pGetFormData() {
        return this._getFormData();
    }

    _getDefaultState() {
        return {
            ixSet: 0,
        };
    }
}
class Charactermancer_ImmResVulnSelect extends BaseComponent {
    static async pGetUserInput(opts) {
        opts = opts || {};

        if (!opts.available)
            return {
                isFormComplete: true,
                data: {}
            };

        const comp = new this({
            ...opts,
            existing: this.getExisting(opts.existingFvtt),
            existingFvtt: opts.existingFvtt,
        });
        if (comp.isNoChoice())
            return comp.pGetFormData();

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            isAutoResize: true
        });
    }

    static getExisting() {
        throw new TypeError(`Unimplemented!`);
    }

    static isNoChoice(available) {
        let cntChoices = 0;
        UtilDataConverter.WALKER_READONLY_GENERIC.walk(available, {
            object: (obj)=>{
                if (obj.choose)
                    cntChoices++;
            }
        });
        return cntChoices === 0;
    }

    constructor(opts) {
        opts = opts || {};
        super();

        this._existing = opts.existing;
        this._available = opts.available;
        this._prop = opts.prop;
        this._modalTitle = opts.modalTitle;
        this._titlePlural = opts.titlePlural;
        this._titleSingle = opts.titleSingle;

        this._lastChoiceMeta = null;

        Object.assign(this.__state.readonly_selectedValues, this._getOutputObject());
    }

    get modalTitle() {
        return this._modalTitle;
    }

    render($wrp) {
        this._lastChoiceMeta = {
            isActive: true,
            children: []
        };
        this._render_recurse($wrp, MiscUtil.copy(this._available), this._lastChoiceMeta, false);
    }

    _render_recurse($wrp, arr, outMeta, isChoices) {
        const arrStrings = arr.filter(it=>typeof it === "string").sort(SortUtil.ascSortLower);

        if (!isChoices) {
            const staticValues = arrStrings.map(it=>{
                outMeta.children.push({
                    isActive: true,
                    value: it
                });
                return it.toTitleCase();
            }
            );
            $wrp.append(`<div>${staticValues.join(", ")}</div>`);
        } else {
            arrStrings.forEach(it=>{
                const $cb = $(`<input type="checkbox" class="ml-1 mr-2">`).change(()=>{
                    if ($cb.prop("checked")) {
                        const numChecked = outMeta.children.filter(it=>it.isChoosable && it.isActive()).length;
                        if (numChecked > outMeta.count) {
                            const toDeActive = outMeta.lastChecked || outMeta.children.filter(it=>it.isChoosable).last();
                            toDeActive.setActive(false);
                        }
                        outMeta.lastChecked = node;
                    } else {
                        if (outMeta.lastChecked === node)
                            outMeta.lastChecked = null;
                    }

                    this._state.readonly_selectedValues = this._getOutputObject();
                }
                );

                const node = {
                    isActive: ()=>$cb.prop("checked") ? it : null,
                    value: it,
                    isChoosable: true,
                    setActive: (val)=>$cb.prop("checked", val),
                };
                outMeta.children.push(node);

                return $$`<label class="py-1 stripe-even ve-flex-v-center">
						${$cb}
						<span>${it.toTitleCase()}</span>
					</label>`.appendTo($wrp);
            }
            );
        }

        arr.filter(it=>typeof it !== "string").forEach((it,i)=>{
            if (!it.choose)
                throw new Error(`Unhandled immune/resist/vulnerability properties "${Object.keys(it).join(", ")}"`);

            if (isChoices) {

                const $btnSetActive = $(`<button class="btn btn-primary btn-5et btn-xs">Set Group Active</button>`).click(()=>{
                    outMeta.children.forEach(it=>it.isActive = false);
                    nxtMeta.isActive = true;
                    this._state.readonly_selectedValues = this._getOutputObject();
                }
                );

                const nxtMeta = {
                    isActive: false,
                    children: []
                };

                const $wrpChoice = $(`<div class="ve-flex-col my-1"></div>`);
                this._render_recurse($wrpChoice, it.choose.from, nxtMeta, true);

                $$`<div class="ve-flex-col pl-2 stripe-even">
						<div class="ve-flex-v-center my-1">${$btnSetActive}</div>
						${$wrpChoice}
					</div>`;

                return;
            }

            const count = it.choose.count || 1;
            const nxtMeta = {
                isActive: true,
                children: [],
                count,
                lastChecked: null
            };
            outMeta.children.push(nxtMeta);

            const $wrpChoice = $(`<div class="ve-flex-col py-1 pt-0">
					${arrStrings.length || i > 0 ? `<hr class="hr-2 hr--dotted">` : ""}
					<div class="py-1">Choose ${count} ${count === 1 ? this._titleSingle : this._titlePlural}:</div>
				</div>`).appendTo($wrp);
            this._render_recurse($wrpChoice, it.choose.from, nxtMeta, true);
        }
        );
    }

    isNoChoice() {
        return this.constructor.isNoChoice(this._available);
    }

    _getOutputSet() {
        const outSet = new Set(this._existing[this._prop] || []);
        if (this._lastChoiceMeta)
            this._getOutputSet_recurse(outSet, this._lastChoiceMeta);
        else
            UtilDataConverter.WALKER_READONLY_GENERIC.walk(this._available, {
                string: (str)=>{
                    outSet.add(str);
                }
            });

        return outSet;
    }

    _getOutputSet_recurse(outSet, node) {
        if (!node.isActive)
            return;
        const isNodeActive = node.isActive === true || node.isActive();
        if (!isNodeActive)
            return;

        if (node.value)
            outSet.add(node.value);
        if (node.children)
            node.children.forEach(it=>this._getOutputSet_recurse(outSet, it));
    }

    _getOutputObject() {
        return [...this._getOutputSet()].sort(SortUtil.ascSortLower).mergeMap(it=>({
            [it]: true
        }));
    }

    pGetFormData() {
        let isFormComplete = true;

        return {
            isFormComplete,
            data: {
                [this._prop]: MiscUtil.copy(this._state.readonly_selectedValues),
            },
        };
    }

    _getDefaultState() {
        return {
            readonly_selectedValues: {},
        };
    }
}

class Charactermancer_DamageImmunitySelect extends Charactermancer_ImmResVulnSelect {
    static getExisting(existingFvtt) {
        return MiscUtil.copy([existingFvtt?.immune?.value || []]);
    }

    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Damage Immunities`,
            titlePlural: `Damage Immunities`,
            titleSingle: `Damage Immunity`,
            prop: "immune",
        });
    }
}

class Charactermancer_DamageResistanceSelect extends Charactermancer_ImmResVulnSelect {
    static getExisting(existingFvtt) {
        return MiscUtil.copy([existingFvtt?.resist?.value || []]);
    }

    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Damage Resistances`,
            titlePlural: `Damage Resistances`,
            titleSingle: `Damage Resistance`,
            prop: "resist",
        });
    }
}

class Charactermancer_DamageVulnerabilitySelect extends Charactermancer_ImmResVulnSelect {
    static getExisting(existingFvtt) {
        return MiscUtil.copy([existingFvtt?.vulnerable?.value || []]);
    }

    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Damage Vulnerabilities`,
            titlePlural: `Damage Vulnerabilities`,
            titleSingle: `Damage Vulnerability`,
            prop: "vulnerable",
        });
    }
}

class Charactermancer_ConditionImmunitySelect extends Charactermancer_ImmResVulnSelect {
    static getExisting(existingFvtt) {
        return [existingFvtt?.conditionImmune?.value || []].map(it=>it === "diseased" ? "disease" : it);
    }

    constructor(opts) {
        opts = opts || {};
        super({
            ...opts,
            modalTitle: `Condition Immunities`,
            titlePlural: `Condition Immunities`,
            titleSingle: `Condition Immunity`,
            prop: "conditionImmune",
        });
    }
}

class Charactermancer_ExpertiseSelect extends Charactermancer_SkillSaveProficiencySelect {
    static getExisting(existingFvtt) {
        const existingSkills = Object.entries(Charactermancer_OtherProficiencySelect.getExisting({
            skillProficiencies: existingFvtt.skillProficiencies
        })?.skillProficiencies || {}).filter(([,profLevel])=>Number(profLevel) === 2).mergeMap(([prof,profLevel])=>({
            [prof]: profLevel
        }));

        const existingTools = Object.entries(Charactermancer_OtherProficiencySelect.getExisting({
            skillProficiencies: existingFvtt.toolProficiencies
        })?.toolProficiencies || {}).filter(([,profLevel])=>Number(profLevel) === 2).mergeMap(([prof,profLevel])=>({
            [prof]: profLevel
        }));

        return {
            ...existingSkills,
            ...existingTools
        };
    }

    static getExistingFvttFromActor(actor) {
        return {
            skillProficiencies: MiscUtil.get(actor, "_source", "system", "skills"),
            toolProficiencies: MiscUtil.get(actor, "_source", "system", "tools"),
        };
    }

    static isNoChoice(available) {
        if (!available?.length)
            return true;
        return available.length === 1 && !available[0].choose && !available[0].anyProficientSkill && !available[0].anyProficientTool;
    }

    constructor(opts) {
        super({
            ...opts,
            propGroup: new Charactermancer_ProficiencySelect.PropGroup({
                prop: "expertise",
                propTrackerPulse: "pulseExpertise",
                propTracker: "expertise",
            }),
            modalTitle: "Expertise",
            title: "Expertise",
            titlePlural: "Expertise",
        });
    }

    _getStaticDisplay(key, {isPlainText=false}={}) {
        if (isPlainText)
            return key.toTitleCase();

        if (Parser.SKILL_TO_ATB_ABV[key])
            return Renderer.get().render(`{@skill ${key.toTitleCase()}}`);
        return key.toTitleCase();
    }

    _getNonStaticDisplay(key, value, {isPlainText=false}={}) {
        switch (key) {
        case "anyProficientSkill":
            return `Choose ${value || 1} existing skill ${value > 1 ? "proficiencies" : "proficiency"}`;
        case "anyProficientTool":
            return `Choose ${value || 1} existing tool ${value > 1 ? "proficiencies" : "proficiency"}`;
        default:
            return super._getNonStaticDisplay(key, value, {
                isPlainText
            });
        }
    }

    _getStaticKeys_all() {
        return this._available.map(profSet=>this._getStaticKeys_profSet({
            profSet
        })).flat().unique();
    }

    _getStaticKeys_profSet({profSet=null}={}) {
        profSet = profSet || this._available[this._state.ixSet];
        return Object.keys(profSet).filter(it=>this._isStaticKey(it));
    }

    _isStaticKey(key) {
        return !["anyProficientSkill", "anyProficientTool"].includes(key);
    }

    _isSkillKey(key) {
        return key === "anyProficientSkill" || Object.keys(Parser.SKILL_TO_ATB_ABV).includes(key);
    }

    _hk_ixSet_renderPts(profSet) {
        this._lastMeta = {
            cleanup: ()=>{
                this._lastMeta._fnsCleanup.forEach(fn=>fn());
            }
            ,
            _fnsCleanup: [],
        };

        const $ptsExistingStatic = Object.keys(profSet).some(it=>this._isStaticKey(it)) ? this._render_renderPtStatic(this._$stgGroup, profSet) : null;
        let needsHr = $ptsExistingStatic != null;

        if (needsHr && profSet.anyProficientSkill) {
            needsHr = false;
            this._$stgGroup.append(`<hr class="hr-2 hr--dotted">`);
        }
        const $ptsExistingChooseAnyProficientSkill = profSet.anyProficientSkill ? this._render_renderPtChooseAnyProficientSkill(this._$stgGroup, profSet) : null;
        needsHr = needsHr || $ptsExistingChooseAnyProficientSkill != null;

        if (needsHr && profSet.anyProficientTool) {
            needsHr = false;
            this._$stgGroup.append(`<hr class="hr-2 hr--dotted">`);
        }
        const $ptsExistingChooseAnyProficientTool = profSet.anyProficientTool ? this._render_renderPtChooseAnyProficientTool(this._$stgGroup, profSet) : null;

        this._hkUpdateExisting = ()=>this._hk_updatePtsExisting($ptsExistingStatic, $ptsExistingChooseAnyProficientSkill, $ptsExistingChooseAnyProficientTool);
    }

    _getProps(prop, ix) {
        return {
            propAnyProficientSkill: `${prop}_ix_skill_${ix}`,
            propAnyProficientTool: `${prop}_ix_tool_${ix}`,
        };
    }

    _render_$getPtExisting() {
        return $(`<div class="ve-small veapp__msg-warning inline-block ml-1 no-shrink" title="Expertise from Another Source">(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[2]}"></i>)</div>`);
    }

    _render_renderPtStatic($stgGroup, profSet) {
        const $ptsExisting = [];

        const profList = this._getStaticKeys_profSet().filter(key=>profSet[key]);

        const $wrps = profList.map((it,i)=>{
            const $ptExisting = this._render_$getPtExisting();

            $ptsExisting.push({
                prof: it,
                $ptExisting,
            });

            const isNotLast = i < profList.length - 1;
            return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${this._getStaticDisplay(it)}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
        }
        );

        $$`<div class="block">
			${$wrps}
		</div>`.appendTo($stgGroup);

        return $ptsExisting;
    }

    _render_renderPtChooseAnyProficientSkill($stgGroup, profSet) {
        return this._render_renderPtChooseAnyProficient({
            $stgGroup,
            profSet,
            propProfSet: "anyProficientSkill",
            propIxProps: "propAnyProficientSkill",
            fnGetValues: this._getAvailableSkills.bind(this),
            propPulse: "pulseSkillProficiencies",
            titleRow: "Existing Skill",
        });
    }

    _render_renderPtChooseAnyProficientTool($stgGroup, profSet) {
        return this._render_renderPtChooseAnyProficient({
            $stgGroup,
            profSet,
            propProfSet: "anyProficientTool",
            propIxProps: "propAnyProficientTool",
            fnGetValues: this._getAvailableTools.bind(this),
            propPulse: "pulseToolProficiencies",
            titleRow: "Existing Tool",
        });
    }

    _render_renderPtChooseAnyProficient({$stgGroup, profSet, propProfSet, propIxProps, fnGetValues, propPulse, titleRow, }, ) {
        const numChoices = Number(profSet[propProfSet] || 1);

        const $wrp = $(`<div class="ve-flex-col"></div>`).appendTo($stgGroup);

        const $ptsExisting = [];

        for (let i = 0; i < numChoices; ++i) {
            const ixProps = this._getProps(propProfSet, i);

            const selMeta = ComponentUiUtil.$getSelEnum(this, ixProps[propIxProps], {
                values: fnGetValues(),
                isAllowNull: true,
                asMeta: true,
                fnDisplay: it=>it.toTitleCase(),
            }, );
            this._lastMeta._fnsCleanup.push(selMeta.unhook);

            const $ptExisting = this._render_$getPtExisting();
            $ptsExisting.push({
                prop: ixProps[propIxProps],
                $ptExisting,
            });

            const hk = ()=>selMeta.setValues(fnGetValues(), {
                isResetOnMissing: true
            });
            if (this._featureSourceTracker) {
                this._featureSourceTracker.addHook(this, propPulse, hk);
                this._lastMeta._fnsCleanup.push(()=>this._featureSourceTracker.removeHook(this, propPulse, hk));

                const hkSetTrackerInfo = ()=>this._doSetTrackerState();
                this._addHookBase(ixProps[propIxProps], hkSetTrackerInfo);
                this._lastMeta._fnsCleanup.push(()=>this._removeHookBase(ixProps[propIxProps], hkSetTrackerInfo));
            }
            hk();

            this._lastMeta._fnsCleanup.push(()=>delete this._state[ixProps[propIxProps]]);

            $$`<div class="ve-flex-v-center ${i ? "mt-2" : ""}">
					<div class="mr-2 no-wrap">${titleRow}:</div>
					${selMeta.$sel}
					${$ptExisting}
				</div>`.appendTo($wrp);
        }

        return $ptsExisting;
    }

    _getAvailableSkills() {
        return this._getAvailableByType({
            propExistingFvtt: "skillProficiencies",
            propFeatureTracker: "skillProficiencies",
        });
    }

    _getAvailableTools() {
        return this._getAvailableByType({
            propExistingFvtt: "toolProficiencies",
            propFeatureTracker: "toolProficiencies",
        });
    }

    _getAvailableByType({propExistingFvtt, propFeatureTracker, }, ) {
        const existingAnyProfLevel = Charactermancer_OtherProficiencySelect.getExisting({
            [propExistingFvtt]: this._existingFvtt[propExistingFvtt],
        });

        const out = new Set(Object.entries(existingAnyProfLevel[propExistingFvtt]).filter(([,profLevel])=>profLevel >= 1).map(([prof])=>prof));

        if (this._featureSourceTracker) {
            (this._featureSourceTracker.getStatesForKey(propFeatureTracker, {
                ignore: this
            }) || []).forEach(otherState=>{
                Object.entries(otherState).filter(([,isAvailable])=>isAvailable).forEach(([prof])=>out.add(prof));
            }
            );
        }

        return [...out].sort(SortUtil.ascSortLower);
    }

    _hk_updatePtsExisting($ptsExistingStatic, $ptsExistingChooseAnyProficientSkill, $ptsExistingChooseAnyProficientTool) {
        const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(this._propGroup.propTracker, {
            ignore: this
        }) : null;

        const ptsExistingMetas = [$ptsExistingStatic, $ptsExistingChooseAnyProficientSkill, $ptsExistingChooseAnyProficientTool].filter(Boolean).flat();

        ptsExistingMetas.forEach(ptExistingMeta=>{
            const prof = ptExistingMeta.prof ?? this._state[ptExistingMeta.prop];

            if (prof == null) {
                ptExistingMeta.$ptExisting.hideVe();
                return;
            }

            let maxExisting = this._existing?.[prof] || 0;

            if (otherStates)
                otherStates.forEach(otherState=>maxExisting = Math.max(maxExisting, otherState[prof] || 0));

            ptExistingMeta.$ptExisting.toggleVe(maxExisting === 2);
        }
        );
    }

    _doSetTrackerState() {
        const formData = this._getFormData();
        this._featureSourceTracker.setState(this, {
            [this._propGroup.propTracker]: formData.data?.[this._propGroup.prop],
            "skillProficiencies": formData.data?.skillProficiencies,
            "toolProficiencies": formData.data?.toolProficiencies,
        });
    }

    _getFormData() {
        const outSkills = {};
        const outTools = {};
        const outExpertise = {};

        let isFormComplete = true;

        const profSet = this._available[this._state.ixSet];

        Object.entries(profSet).forEach(([k,v])=>{
            if (k === "anyProficientSkill" || k === "anyProficientTool") {
                const numChoices = Number(v || 1);
                for (let i = 0; i < numChoices; ++i) {
                    const {propAnyProficientSkill, propAnyProficientTool} = this._getProps(k, i);
                    const prop = this._isSkillKey(k) ? propAnyProficientSkill : propAnyProficientTool;
                    const chosenProf = this._state[prop];
                    if (chosenProf == null) {
                        isFormComplete = false;
                        continue;
                    }
                    (this._isSkillKey(k) ? outSkills : outTools)[chosenProf] = outExpertise[chosenProf] = 2;
                }
                return;
            }

            (this._isSkillKey(k) ? outSkills : outTools)[k] = outExpertise[k] = 2;
        }
        );

        return {
            isFormComplete,
            data: {
                skillProficiencies: outSkills,
                toolProficiencies: outTools,
                expertise: outExpertise,
            },
        };
    }

    pGetFormData() {
        return this._getFormData();
    }

    _getDefaultState() {
        return {
            ixSet: 0,
        };
    }
}

class Charactermancer_ResourceSelect extends BaseComponent {
    static isNoChoice() {
        return true;
    }

    static async pApplyFormDataToActor(actor, formData) {
        if (!formData?.data?.length)
            return;

        const itemLookup = {};
        actor.items.contents.forEach(it=>itemLookup[it.name.toLowerCase().trim()] = it);

        const toCreate = [];

        formData.data.forEach(res=>{
            const existing = itemLookup[res.name.toLowerCase().trim()];

            if (existing)
                return;

            toCreate.push({
                name: res.name,
                type: "feat",
                data: this._getItemDataData({
                    res
                }),
                img: this._getItemDataImg({
                    res
                }),
            });
        }
        );

        await UtilDocuments.pCreateEmbeddedDocuments(actor, toCreate, {
            ClsEmbed: Item,
            isRender: false,
        }, );
    }

    render() {}

    static _getItemDataData({res}) {
        switch (res.type) {
        case "dicePool":
            return this._getItemDataData_dicePool({
                res
            });
        default:
            throw new Error(`Unhandled resource type "${res.type}"`);
        }
    }

    static _getItemDataData_dicePool({res}) {
        return {
            actionType: "other",
            formula: `${res.number}d${res.faces}`,
            activation: {
                type: "special",
            },
            uses: {
                value: 0,
                max: res.count,
                per: UtilDataConverter.getFvttUsesPer(res.recharge),
            },
        };
    }

    static _IMAGES = {
        "Superiority Die": `icons/sundries/gaming/dice-runed-brown.webp`,
        "Psionic Energy Die": "icons/sundries/gaming/dice-pair-white-green.webp",
    };
    static _getItemDataImg({res}) {
        if (this._IMAGES[res.name])
            return this._IMAGES[res.name];

        if (/\b(?:dice|die)\b/i.test((res.name || "")))
            return `icons/sundries/gaming/dice-runed-brown.webp`;

        return `modules/${SharedConsts.MODULE_ID}/media/icon/mighty-force.svg`;
    }

    constructor({resources, className, classSource, subclassShortName, subclassSource}) {
        super();
        this._resources = resources;
        this._className = className;
        this._classSource = classSource;
        this._subclassShortName = subclassShortName;
        this._subclassSource = subclassSource;

        this._mappedResources = this._getMappedResources();
    }

    _getMappedResources() {
        return (this._resources || []).map(res=>{
            switch (res.type) {
            case "dicePool":
                return this._getMappedResources_dicePool({
                    res
                });
            default:
                throw new Error(`Unhandled resource type "${res.type}"`);
            }
        }
        );
    }

    _getMappedResources_dicePool({res}) {
        res = MiscUtil.copy(res);
        res.number = this._getMappedResources_getReplacedVars(res.number || 1);
        res.faces = this._getMappedResources_getReplacedVars(res.faces);
        res.count = this._getMappedResources_getReplacedVars(res.count || 1);
        return res;
    }

    _getMappedResources_getReplacedVars(val) {
        return `${val}`.replace(/\bPB\b/g, "@attributes.prof").replace(/<\$(?<variable>[^$]+)\$>/g, (...m)=>{
            switch (m.last().variable) {
            case "level":
                return `@classes.${Parser.stringToSlug(this._className || "unknown")}.levels`;
            default:
                return m[0];
            }
        }
        );
    }

    pGetFormData() {
        return {
            isFormComplete: true,
            data: MiscUtil.copy(this._mappedResources || []),
        };
    }
}

class Charactermancer_SenseSelect extends BaseComponent {
    static isNoChoice() {
        return true;
    }

    static getExistingFvttFromActor(actor) {
        return {
            senses: MiscUtil.get(actor, "_source", "system", "attributes", "senses"),
        };
    }

    static getExisting(existingFvtt) {
        return Object.keys(CONFIG.DND5E.senses).filter(sense=>existingFvtt?.senses[sense]).mergeMap(sense=>({
            [sense]: existingFvtt?.senses[sense]
        }));
    }

    render() {}

    constructor({senses, existing, existingFvtt}) {
        super();
        this._senses = senses;
        this._existing = existing;
        this._existingFvtt = existingFvtt;
    }

    static getFormDataFromRace(race) {
        return {
            isFormComplete: true,
            data: {
                darkvision: race.darkvision,
                blindsight: race.blindsight,
                truesight: race.truesight,
                tremorsense: race.tremorsense,
            },
        };
    }

    pGetFormData() {
        return {
            isFormComplete: true,
            data: MiscUtil.copy(this._senses[0] || {}),
        };
    }
}

class Charactermancer_FeatureOptionsSelect extends BaseComponent {
    static async pGetUserInput(opts) {
        const comp = new this({
            ...opts,
            featureSourceTracker: opts.featureSourceTracker || new Charactermancer_FeatureSourceTracker(),
            isModal: true,
        });
        if (await comp.pIsNoChoice()) {
            comp.render($(document.createElement("div")));
            return comp.pGetFormData();
        }

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            width: 640,
            height: Util.getMaxWindowHeight(),
            isAutoResize: true,
        });
    }

    static async pDoApplyProficiencyFormDataToActorUpdate(actor, actorUpdate, formData) {
        const formDataData = formData.data;
        if (!formDataData)
            return;

        const {DataConverter} = await Promise.resolve().then(function() {
            return DataConverter$1;
        });

        actorUpdate.system = actorUpdate.system || {};

        for (const formData of formDataData.formDatasSkillToolLanguageProficiencies || []) {
            DataConverter.doApplySkillFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "skills"),
                formData: formData,
                actorData: actorUpdate.system,
            });

            DataConverter.doApplyLanguageProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "languages"),
                formData,
                actorData: actorUpdate.system,
            });

            DataConverter.doApplyToolProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "tools"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasSkillProficiencies || []) {
            DataConverter.doApplySkillFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "skills"),
                formData: formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasLanguageProficiencies || []) {
            DataConverter.doApplyLanguageProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "languages"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasToolProficiencies || []) {
            DataConverter.doApplyToolProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "tools"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasWeaponProficiencies || []) {
            DataConverter.doApplyWeaponProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "weaponProf"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasArmorProficiencies || []) {
            DataConverter.doApplyArmorProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "armorProf"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasSavingThrowProficiencies || []) {
            DataConverter.doApplySavingThrowProficienciesFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "abilities"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasDamageImmunities || []) {
            DataConverter.doApplyDamageImmunityFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "di"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasDamageResistances || []) {
            DataConverter.doApplyDamageResistanceFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "dr"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasDamageVulnerabilities || []) {
            DataConverter.doApplyDamageVulnerabilityFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "dv"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasConditionImmunities || []) {
            DataConverter.doApplyConditionImmunityFormDataToActorUpdate({
                existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "ci"),
                formData,
                actorData: actorUpdate.system,
            });
        }

        for (const formData of formDataData.formDatasExpertise || []) {
            DataConverter.doApplyExpertiseFormDataToActorUpdate({
                existingProfsActor: {
                    skillProficiencies: MiscUtil.get(actor, "_source", "system", "skills"),
                    toolProficiencies: MiscUtil.get(actor, "_source", "system", "tools"),
                },
                formData: formData,
                actorData: actorUpdate.system,
            });
        }
    }

    static async pDoApplyResourcesFormDataToActor({actor, formData}) {
        const formDataData = formData.data;

        if (!formDataData?.formDatasResources?.length)
            return;

        for (const formDataResources of formDataData.formDatasResources) {
            await Charactermancer_ResourceSelect.pApplyFormDataToActor(actor, formDataResources, );
        }
    }

    static async pDoApplySensesFormDataToActor({actor, actorUpdate, formData, configGroup}) {
        const formDataData = formData.data;
        if (!formDataData || !formDataData.formDatasSenses?.length)
            return;

        const {DataConverter} = await Promise.resolve().then(function() {
            return DataConverter$1;
        });

        actorUpdate.prototypeToken = actorUpdate.prototypeToken || {};
        actorUpdate.system = actorUpdate.system || {};

        for (const formData of formDataData.formDatasSenses || []) {
            DataConverter.doApplySensesFormDataToActorUpdate({
                existingSensesActor: MiscUtil.get(actor, "_source", "system", "attributes", "senses"),
                existingTokenActor: MiscUtil.get(actor, "_source", "prototypeToken"),
                formData: formData,
                actorData: actorUpdate.system,
                actorToken: actorUpdate.prototypeToken,
                configGroup,
            });
        }
    }

    static async pDoApplyAdditionalSpellsFormDataToActor({actor, formData, abilityAbv, parentAbilityAbv=null, taskRunner=null}) {
        const formDataData = formData.data;
        if (!formDataData || !formDataData.formDatasAdditionalSpells?.length)
            return;

        for (const formDataAdditionalSpells of formDataData.formDatasAdditionalSpells) {
            await Charactermancer_AdditionalSpellsSelect.pApplyFormDataToActor(actor, formDataAdditionalSpells, {
                taskRunner,
                abilityAbv,
                parentAbilityAbv,
            }, );
        }
    }

    constructor(opts) {
        super();

        this._optionsSet = opts.optionsSet;
        this._actor = opts.actor;
        this._level = opts.level;
        this._existingFeatureChecker = opts.existingFeatureChecker;
        this._featureSourceTracker = opts.featureSourceTracker;
        this._isModal = !!opts.isModal;
        this._modalFilterSpells = opts.modalFilterSpells;
        this._isSkipCharactermancerHandled = !!opts.isSkipCharactermancerHandled;
        this._isSkipRenderingFirstFeatureTitle = !!opts.isSkipRenderingFirstFeatureTitle;

        if (this._isOptions()) {
            this._optionsSet.sort((a,b)=>SortUtil.ascSortLower(a.entity.name, b.entity.name) || SortUtil.ascSortLower(Parser.sourceJsonToAbv(a.entity.source), Parser.sourceJsonToAbv(b.entity.source)));
        }

        this._lastMeta = null;
        this._lastSubMetas = [];

        this._subCompsSkillToolLanguageProficiencies = [];
        this._subCompsSkillProficiencies = [];
        this._subCompsLanguageProficiencies = [];
        this._subCompsToolProficiencies = [];
        this._subCompsWeaponProficiencies = [];
        this._subCompsArmorProficiencies = [];
        this._subCompsSavingThrowProficiencies = [];
        this._subCompsDamageImmunities = [];
        this._subCompsDamageResistances = [];
        this._subCompsDamageVulnerabilities = [];
        this._subCompsConditionImmunities = [];
        this._subCompsExpertise = [];
        this._subCompsResources = [];
        this._subCompsSenses = [];
        this._subCompsAdditionalSpells = [];

        this._prevSubCompsSkillToolLanguageProficiencies = null;
        this._prevSubCompsSkillProficiencies = null;
        this._prevSubCompsLanguageProficiencies = null;
        this._prevSubCompsToolProficiencies = null;
        this._prevSubCompsWeaponProficiencies = null;
        this._prevSubCompsArmorProficiencies = null;
        this._prevSubCompsSavingThrowProficiencies = null;
        this._prevSubCompsDamageImmunities = [];
        this._prevSubCompsDamageResistances = [];
        this._prevSubCompsDamageVulnerabilities = [];
        this._prevSubCompsConditionImmunities = [];
        this._prevSubCompsExpertise = [];
        this._prevSubCompsResources = [];
        this._prevSubCompsSenses = null;
        this._prevSubCompsAdditionalSpells = null;
    }

    get optionSet_() {
        return this._optionsSet;
    }

    _isOptions() {
        return !!(this._optionsSet[0] && this._optionsSet[0].optionsMeta);
    }

    unregisterFeatureSourceTracking() {
        if (this._featureSourceTracker)
            this._featureSourceTracker.unregister(this);
        this._unregisterSubComps();
    }

    async _pIsSubChoiceForceDisplay(selectedLoadeds) {
        const isSubChoice_sideDataChooseSystem = await this._pHasChoiceInSideData_chooseSystem(selectedLoadeds);
        const isSubChoice_sideDataChooseFlags = await this._pHasChoiceInSideData_chooseFlags(selectedLoadeds);
        const isForceDisplay_entryDataSkillToolLanguageProficiencies = await this._pIsForceDisplay_skillToolLanguageProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataSkillProficiencies = await this._pIsForceDisplay_skillProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataLanguageProficiencies = await this._pIsForceDisplay_languageProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataToolProficiencies = await this._pIsForceDisplay_toolProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataWeaponProficiencies = await this._pIsForceDisplay_weaponProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataArmorProficiencies = await this._pIsForceDisplay_armorProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataSavingThrowProficiencies = await this._pIsForceDisplay_savingThrowProficiencies(selectedLoadeds);
        const isForceDisplay_entryDataDamageImmunities = await this._pIsForceDisplay_damageImmunities(selectedLoadeds);
        const isForceDisplay_entryDataDamageResistances = await this._pIsForceDisplay_damageResistances(selectedLoadeds);
        const isForceDisplay_entryDataDamageVulnerabilities = await this._pIsForceDisplay_damageVulnerabilities(selectedLoadeds);
        const isForceDisplay_entryDataConditionImmunities = await this._pIsForceDisplay_conditionImmunities(selectedLoadeds);
        const isForceDisplay_entryDataExpertise = await this._pIsForceDisplay_expertise(selectedLoadeds);
        const isForceDisplay_entryDataResources = await this._pIsForceDisplay_resources(selectedLoadeds);
        const isForceDisplay_entryDataSenses = await this._pIsForceDisplay_senses(selectedLoadeds);
        const isForceDisplay_entryDataAdditionalSpells = await this._pIsForceDisplay_additionalSpells(selectedLoadeds);

        return [isSubChoice_sideDataChooseSystem, isSubChoice_sideDataChooseFlags, isForceDisplay_entryDataSkillToolLanguageProficiencies, isForceDisplay_entryDataSkillProficiencies, isForceDisplay_entryDataLanguageProficiencies, isForceDisplay_entryDataToolProficiencies, isForceDisplay_entryDataWeaponProficiencies, isForceDisplay_entryDataArmorProficiencies, isForceDisplay_entryDataSavingThrowProficiencies, isForceDisplay_entryDataDamageImmunities, isForceDisplay_entryDataDamageResistances, isForceDisplay_entryDataDamageVulnerabilities, isForceDisplay_entryDataConditionImmunities, isForceDisplay_entryDataExpertise, isForceDisplay_entryDataResources, isForceDisplay_entryDataSenses, isForceDisplay_entryDataAdditionalSpells, ].some(Boolean);
    }

    async _pIsSubChoiceAvailable(selectedLoadeds) {
        const isSubChoice_sideDataChooseSystem = await this._pHasChoiceInSideData_chooseSystem(selectedLoadeds);
        const isSubChoice_sideDataChooseFlags = await this._pHasChoiceInSideData_chooseFlags(selectedLoadeds);
        const isAvailable_entryDataSkillToolLanguageProficiencies = await this._pIsAvailable_skillToolLanguageProficiencies(selectedLoadeds);
        const isAvailable_entryDataSkillProficiencies = await this._pIsAvailable_skillProficiencies(selectedLoadeds);
        const isAvailable_entryDataLanguageProficiencies = await this._pIsAvailable_languageProficiencies(selectedLoadeds);
        const isAvailable_entryDataToolProficiencies = await this._pIsAvailable_toolProficiencies(selectedLoadeds);
        const isAvailable_entryDataWeaponProficiencies = await this._pIsAvailable_weaponProficiencies(selectedLoadeds);
        const isAvailable_entryDataArmorProficiencies = await this._pIsAvailable_armorProficiencies(selectedLoadeds);
        const isAvailable_entryDataSavingThrowProficiencies = await this._pIsAvailable_savingThrowProficiencies(selectedLoadeds);
        const isAvailable_entryDataDamageImmunities = await this._pIsAvailable_damageImmunities(selectedLoadeds);
        const isAvailable_entryDataDamageResistances = await this._pIsAvailable_damageResistances(selectedLoadeds);
        const isAvailable_entryDataDamageVulnerabilities = await this._pIsAvailable_damageVulnerabilities(selectedLoadeds);
        const isAvailable_entryDataConditionImmunities = await this._pIsAvailable_conditionImmunities(selectedLoadeds);
        const isAvailable_entryDataExpertise = await this._pIsAvailable_expertise(selectedLoadeds);
        const isAvailable_entryDataResources = await this._pIsAvailable_resources(selectedLoadeds);
        const isAvailable_entryDataSenses = await this._pIsAvailable_senses(selectedLoadeds);
        const isAvailable_entryDataAdditionalSpells = await this._pIsAvailable_additionalSpells(selectedLoadeds);

        return [isSubChoice_sideDataChooseSystem, isSubChoice_sideDataChooseFlags, isAvailable_entryDataSkillToolLanguageProficiencies, isAvailable_entryDataSkillProficiencies, isAvailable_entryDataLanguageProficiencies, isAvailable_entryDataToolProficiencies, isAvailable_entryDataWeaponProficiencies, isAvailable_entryDataArmorProficiencies, isAvailable_entryDataSavingThrowProficiencies, isAvailable_entryDataDamageImmunities, isAvailable_entryDataDamageResistances, isAvailable_entryDataDamageVulnerabilities, isAvailable_entryDataConditionImmunities, isAvailable_entryDataExpertise, isAvailable_entryDataResources, isAvailable_entryDataSenses, isAvailable_entryDataAdditionalSpells, ].some(Boolean);
    }

    static _ENTITY_TYPE_TO_SIDE_DATA_META = {
        "backgroundFeature": {
            file: "SideDataInterfaceBackgroundFeature",
            sideDataInterface: "SideDataInterfaceBackgroundFeature"
        },
        "charoption": {
            file: "SideDataInterfaceCharCreationOption",
            sideDataInterface: "SideDataInterfaceCharCreationOption"
        },
        "classFeature": {
            file: "SideDataInterfaceClassSubclassFeature",
            sideDataInterface: "SideDataInterfaceClassSubclassFeature"
        },
        "subclassFeature": {
            file: "SideDataInterfaceClassSubclassFeature",
            sideDataInterface: "SideDataInterfaceClassSubclassFeature"
        },
        "feat": {
            file: "SideDataInterfaceFeat",
            sideDataInterface: "SideDataInterfaceFeat"
        },
        "optionalfeature": {
            file: "SideDataInterfaceOptionalfeature",
            sideDataInterface: "SideDataInterfaceOptionalfeature"
        },
        "raceFeature": {
            file: "SideDataInterfaceRaceFeature",
            sideDataInterface: "SideDataInterfaceRaceFeature"
        },
        "reward": {
            file: "SideDataInterfaceReward",
            sideDataInterface: "SideDataInterfaceReward"
        },
        "vehicleUpgrade": {
            file: "SideDataInterfaceVehicleUpgrade",
            sideDataInterface: "SideDataInterfaceVehicleUpgrade"
        },
    };

    async _pHasChoiceInSideData_chooseSystem(optionsSet) {
        return this._pHasChoiceInSideData_chooseSystemOrFlags({
            optionsSet,
            propChoose: "chooseSystem"
        });
    }

    async _pHasChoiceInSideData_chooseFlags(optionsSet) {
        return this._pHasChoiceInSideData_chooseSystemOrFlags({
            optionsSet,
            propChoose: "chooseFlags"
        });
    }

    async _pHasChoiceInSideData_chooseSystemOrFlags({optionsSet, propChoose}) {
        optionsSet = optionsSet || this._optionsSet;

        if (this._isSkipCharactermancerHandled)
            return false;

        for (const loaded of optionsSet) {
            const {entity, type} = loaded;

            const sideDataConverterMeta = this.constructor._ENTITY_TYPE_TO_SIDE_DATA_META[type];

            if (sideDataConverterMeta) {
                if (!sideDataConverterMeta.file.startsWith("SideDataInterface"))
                    throw new Error(`Expected side-data interface to start with "SideDataInterface"!`);
                const mod = await __variableDynamicImportRuntime2__(`./SideDataInterface/SideDataInterface${sideDataConverterMeta.file.replace(/^SideDataInterface/, "")}.js`);

                const sideData = await mod[sideDataConverterMeta.sideDataInterface].pGetSideLoaded(entity);
                if (sideData?.[propChoose]?.length)
                    return true;
            }
        }
        return false;
    }

    async _pHasSubChoice_entryData_skillToolLanguageProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "skillToolLanguageProficiencies",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_entryData_skillProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "skillProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_entryData_languageProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "languageProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_entryData_toolProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "toolProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_entryData_weaponProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "weaponProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_entryData_armorProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "armorProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_entryData_savingThrowProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "savingThrowProficiencies",
            isRequireChoice: true,
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSavingThrowProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pHasSubChoice_damageImmunities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_DamageImmunitySelect,
            prop: "immune",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_damageResistances(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_DamageResistanceSelect,
            prop: "resist",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_damageVulnerabilities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_DamageVulnerabilitySelect,
            prop: "vulnerable",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_conditionImmunities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ConditionImmunitySelect,
            prop: "conditionImmune",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_expertise(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ExpertiseSelect,
            prop: "expertise",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_resources(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ResourceSelect,
            prop: "resources",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_entryData_senses(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_SenseSelect,
            prop: "senses",
            isRequireChoice: true,
        });
    }

    async _pHasSubChoice_entryData_additionalSpells(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_AdditionalSpellsSelect,
            prop: "additionalSpells",
            isRequireChoice: true,
        });
    }

    async _pHasEntryData_prop({optionsSet, CompClass, prop, isRequireChoice, fnGetMappedProficiencies}) {
        optionsSet = optionsSet || this._optionsSet;

        if (this._isSkipCharactermancerHandled)
            return false;

        for (const loaded of optionsSet) {
            const {entity} = loaded;

            let proficiencies = entity?.[prop] || entity?.entryData?.[prop];
            if (proficiencies) {
                if (fnGetMappedProficiencies)
                    proficiencies = fnGetMappedProficiencies(proficiencies);

                if (!isRequireChoice)
                    return true;
                else {
                    const isNoChoice = CompClass.isNoChoice(proficiencies);
                    if (!isNoChoice)
                        return true;
                }
            }
        }
        return false;
    }

    async _pIsForceDisplay_skillToolLanguageProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "skillToolLanguageProficiencies",
        });
    }

    async _pIsForceDisplay_skillProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "skillProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_languageProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "languageProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_toolProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "toolProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_weaponProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "weaponProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_armorProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "armorProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_savingThrowProficiencies(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_OtherProficiencySelect,
            prop: "savingThrowProficiencies",
            fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSavingThrowProficiencies.bind(Charactermancer_OtherProficiencySelect),
        });
    }

    async _pIsForceDisplay_damageImmunities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ConditionImmunitySelect,
            prop: "immune",
        });
    }

    async _pIsForceDisplay_damageResistances(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_DamageResistanceSelect,
            prop: "resist",
        });
    }

    async _pIsForceDisplay_damageVulnerabilities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_DamageVulnerabilitySelect,
            prop: "vulnerable",
        });
    }

    async _pIsForceDisplay_conditionImmunities(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ConditionImmunitySelect,
            prop: "conditionImmune",
        });
    }

    async _pIsForceDisplay_expertise(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ExpertiseSelect,
            prop: "expertise",
        });
    }

    async _pIsForceDisplay_resources(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ResourceSelect,
            prop: "resources",
            isRequireChoice: true,
        });
    }

    _pIsForceDisplay_senses(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_SenseSelect,
            prop: "senses",
            isRequireChoice: true,
        });
    }

    _pIsForceDisplay_additionalSpells(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_AdditionalSpellsSelect,
            prop: "additionalSpells",
        });
    }

    _pIsAvailable_skillToolLanguageProficiencies(...args) {
        return this._pIsForceDisplay_skillToolLanguageProficiencies(...args);
    }
    _pIsAvailable_skillProficiencies(...args) {
        return this._pIsForceDisplay_skillProficiencies(...args);
    }
    _pIsAvailable_languageProficiencies(...args) {
        return this._pIsForceDisplay_languageProficiencies(...args);
    }
    _pIsAvailable_toolProficiencies(...args) {
        return this._pIsForceDisplay_toolProficiencies(...args);
    }
    _pIsAvailable_weaponProficiencies(...args) {
        return this._pIsForceDisplay_weaponProficiencies(...args);
    }
    _pIsAvailable_armorProficiencies(...args) {
        return this._pIsForceDisplay_armorProficiencies(...args);
    }
    _pIsAvailable_savingThrowProficiencies(...args) {
        return this._pIsForceDisplay_savingThrowProficiencies(...args);
    }
    _pIsAvailable_damageImmunities(...args) {
        return this._pIsForceDisplay_damageImmunities(...args);
    }
    _pIsAvailable_damageResistances(...args) {
        return this._pIsForceDisplay_damageResistances(...args);
    }
    _pIsAvailable_damageVulnerabilities(...args) {
        return this._pIsForceDisplay_damageVulnerabilities(...args);
    }
    _pIsAvailable_conditionImmunities(...args) {
        return this._pIsForceDisplay_conditionImmunities(...args);
    }
    _pIsAvailable_expertise(...args) {
        return this._pIsForceDisplay_expertise(...args);
    }

    async _pIsAvailable_resources(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_ResourceSelect,
            prop: "resources",
        });
    }

    _pIsAvailable_senses(optionsSet) {
        return this._pHasEntryData_prop({
            optionsSet,
            CompClass: Charactermancer_SenseSelect,
            prop: "senses",
        });
    }

    _pIsAvailable_additionalSpells(...args) {
        return this._pIsForceDisplay_additionalSpells(...args);
    }

    async _pGetLoadedsSideDataRaws(optionsSet) {
        optionsSet = optionsSet || this._optionsSet;
        const out = [];
        for (const loaded of optionsSet) {
            const {entity, type} = loaded;

            switch (type) {
            case "classFeature":
            case "subclassFeature":
                {
                    const {SideDataInterfaceClassSubclassFeature} = await Promise.resolve().then(function() {
                        return SideDataInterfaceClassSubclassFeature$1;
                    });
                    const sideData = await SideDataInterfaceClassSubclassFeature.pGetSideLoaded(entity);
                    out.push(sideData);
                    break;
                }

            default:
                {
                    out.push(null);
                    break;
                }
            }
        }
        return out;
    }

    async pIsNoChoice() {
        if (this._isOptions())
            return false;
        if (await this._pHasChoiceInSideData_chooseSystem())
            return false;
        if (await this._pHasChoiceInSideData_chooseFlags())
            return false;
        if (await this._pHasSubChoice_entryData_skillToolLanguageProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_skillProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_languageProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_toolProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_weaponProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_armorProficiencies())
            return false;
        if (await this._pHasSubChoice_entryData_savingThrowProficiencies())
            return false;
        if (await this._pHasSubChoice_damageImmunities())
            return false;
        if (await this._pHasSubChoice_damageResistances())
            return false;
        if (await this._pHasSubChoice_damageVulnerabilities())
            return false;
        if (await this._pHasSubChoice_conditionImmunities())
            return false;
        if (await this._pHasSubChoice_expertise())
            return false;
        if (await this._pHasSubChoice_resources())
            return false;
        if (await this._pHasSubChoice_entryData_senses())
            return false;
        if (await this._pHasSubChoice_entryData_additionalSpells())
            return false;
        return true;
    }

    async pIsForceDisplay() {
        if (await this._pIsForceDisplay_skillToolLanguageProficiencies())
            return true;
        if (await this._pIsForceDisplay_skillProficiencies())
            return true;
        if (await this._pIsForceDisplay_languageProficiencies())
            return true;
        if (await this._pIsForceDisplay_toolProficiencies())
            return true;
        if (await this._pIsForceDisplay_weaponProficiencies())
            return true;
        if (await this._pIsForceDisplay_armorProficiencies())
            return true;
        if (await this._pIsForceDisplay_savingThrowProficiencies())
            return true;
        if (await this._pIsForceDisplay_damageImmunities())
            return true;
        if (await this._pIsForceDisplay_damageResistances())
            return true;
        if (await this._pIsForceDisplay_damageVulnerabilities())
            return true;
        if (await this._pIsForceDisplay_conditionImmunities())
            return true;
        if (await this._pIsForceDisplay_expertise())
            return true;
        if (await this._pIsForceDisplay_resources())
            return true;
        if (await this._pIsForceDisplay_senses())
            return true;
        if (await this._pIsForceDisplay_additionalSpells())
            return true;
        return false;
    }

    async pIsAvailable() {
        if (await this._pIsAvailable_skillToolLanguageProficiencies())
            return true;
        if (await this._pIsAvailable_skillProficiencies())
            return true;
        if (await this._pIsAvailable_languageProficiencies())
            return true;
        if (await this._pIsAvailable_toolProficiencies())
            return true;
        if (await this._pIsAvailable_weaponProficiencies())
            return true;
        if (await this._pIsAvailable_armorProficiencies())
            return true;
        if (await this._pIsAvailable_savingThrowProficiencies())
            return true;
        if (await this._pIsAvailable_damageImmunities())
            return true;
        if (await this._pIsAvailable_damageResistances())
            return true;
        if (await this._pIsAvailable_damageVulnerabilities())
            return true;
        if (await this._pIsAvailable_conditionImmunities())
            return true;
        if (await this._pIsAvailable_expertise())
            return true;
        if (await this._pIsAvailable_resources())
            return true;
        if (await this._pIsAvailable_senses())
            return true;
        if (await this._pIsAvailable_additionalSpells())
            return true;
        return false;
    }

    _getTrackableFeatures() {
        const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, "ixsChosen");
        const selectedLoadeds = ixs.map(ix=>this._optionsSet[ix]);

        return selectedLoadeds.map(({page, hash})=>({
            page,
            hash
        }));
    }

    findAndCopyStateFrom(comps) {
        if (!comps?.length)
            return;

        const comp = comps.find(it=>CollectionUtil.deepEquals(it.optionSet_, this.optionSet_));
        if (comp) {
            this._proxyAssignSimple("state", MiscUtil.copy(comp.__state));
            this._prevSubCompsSkillToolLanguageProficiencies = comp._subCompsSkillToolLanguageProficiencies;
            this._prevSubCompsSkillProficiencies = comp._subCompsSkillProficiencies;
            this._prevSubCompsLanguageProficiencies = comp._subCompsLanguageProficiencies;
            this._prevSubCompsToolProficiencies = comp._subCompsToolProficiencies;
            this._prevSubCompsWeaponProficiencies = comp._subCompsWeaponProficiencies;
            this._prevSubCompsArmorProficiencies = comp._subCompsArmorProficiencies;
            this._prevSubCompsSavingThrowProficiencies = comp._subCompsSavingThrowProficiencies;
            this._prevSubCompsDamageImmunities = comp._prevSubCompsDamageImmunities;
            this._prevSubCompsDamageResistances = comp._prevSubCompsDamageResistances;
            this._prevSubCompsDamageVulnerabilities = comp._prevSubCompsDamageVulnerabilities;
            this._prevSubCompsConditionImmunities = comp._prevSubCompsConditionImmunities;
            this._prevSubCompsExpertise = comp._prevSubCompsExpertise;
            this._prevSubCompsResources = comp._prevSubCompsResources;
            this._prevSubCompsSenses = comp._subCompsSenses;
            this._prevSubCompsAdditionalSpells = comp._subCompsAdditionalSpells;
        }
    }

    async pGetFormData() {
        if (await this.pIsNoChoice() && !await this.pIsAvailable()) {
            const sideDatas = await this._pGetLoadedsSideDataRaws();
            const cpyOptionsSet = MiscUtil.copy(this._optionsSet);
            cpyOptionsSet.forEach((loaded,i)=>{
                const sideData = sideDatas[i];
                if (!sideData)
                    return;

                const {entity} = loaded;
                if (sideData.data)
                    entity.foundryAdditionalSystem = MiscUtil.copy(sideData.data);
                if (sideData.flags)
                    entity.foundryAdditionalFlags = MiscUtil.copy(sideData.flags);
                if (sideData.effects)
                    entity.effectsRaw = MiscUtil.copy(sideData.effects);
            }
            );

            return {
                isFormComplete: true,
                data: {
                    features: cpyOptionsSet,
                },
            };
        }

        await this._pGate("ixsChosen");

        const selectedLoadeds = this._getSelectedLoadeds();

        const sideDatas = await this._pGetLoadedsSideDataRaws(selectedLoadeds);
        const cpySelectedLoadeds = MiscUtil.copy(selectedLoadeds);

        const outSkillToolLanguageProficiencies = [];
        const outSkillProficiencies = [];
        const outLanguageProficiencies = [];
        const outToolProficiencies = [];
        const outWeaponProficiencies = [];
        const outArmorProficiencies = [];
        const outSavingThrowProficiencies = [];
        const outDamageImmunities = [];
        const outDamageResistances = [];
        const outDamageVulnerabilities = [];
        const outConditionImmunities = [];
        const outExpertise = [];
        const outResources = [];
        const outSenses = [];
        const outAdditionalSpells = [];

        for (let i = 0; i < cpySelectedLoadeds.length; ++i) {
            const loaded = cpySelectedLoadeds[i];

            const sideData = sideDatas[i];

            const {entity} = loaded;

            if (sideData) {
                if (sideData.data)
                    entity.foundryAdditionalSystem = MiscUtil.copy(sideData.data);
                if (sideData.flags)
                    entity.foundryAdditionalFlags = MiscUtil.copy(sideData.flags);
                if (sideData.effects)
                    entity.effectsRaw = MiscUtil.copy(sideData.effects);

                const selectedChooseDataSystem = this._getFormData_getChooseSystemOrChooseFlags({
                    sideData,
                    ixCpySelectedLoaded: i,
                    propChoose: "chooseSystem",
                    propCompProp: "propChooseSystem",
                });
                if (selectedChooseDataSystem) {
                    entity.foundryAdditionalSystem = entity.foundryAdditionalSystem || {};
                    Object.assign(entity.foundryAdditionalSystem, MiscUtil.copy(selectedChooseDataSystem.system));
                }

                const selectedChooseDataFlags = this._getFormData_getChooseSystemOrChooseFlags({
                    sideData,
                    ixCpySelectedLoaded: i,
                    propChoose: "chooseFlags",
                    propCompProp: "propChooseFlags",
                });
                if (selectedChooseDataFlags) {
                    entity.foundryAdditionalFlags = entity.foundryAdditionalFlags || {};
                    foundry.utils.mergeObject(entity.foundryAdditionalFlags, MiscUtil.copy(selectedChooseDataFlags.flags));
                }
            }

            if (!this._isSkipCharactermancerHandled) {
                if ((entity?.skillToolLanguageProficiencies || entity?.entryData?.skillToolLanguageProficiencies) && this._subCompsSkillToolLanguageProficiencies[i]) {
                    const formData = await this._subCompsSkillToolLanguageProficiencies[i].pGetFormData();
                    outSkillToolLanguageProficiencies.push(formData);
                }

                if ((entity?.skillProficiencies || entity?.entryData?.skillProficiencies) && this._subCompsSkillProficiencies[i]) {
                    const formData = await this._subCompsSkillProficiencies[i].pGetFormData();
                    outSkillProficiencies.push(formData);
                }

                if ((entity?.languageProficiencies || entity?.entryData?.languageProficiencies) && this._subCompsLanguageProficiencies[i]) {
                    const formData = await this._subCompsLanguageProficiencies[i].pGetFormData();
                    outLanguageProficiencies.push(formData);
                }

                if ((entity?.toolProficiencies || entity?.entryData?.toolProficiencies) && this._subCompsToolProficiencies[i]) {
                    const formData = await this._subCompsToolProficiencies[i].pGetFormData();
                    outToolProficiencies.push(formData);
                }

                if ((entity?.weaponProficiencies || entity?.entryData?.weaponProficiencies) && this._subCompsWeaponProficiencies[i]) {
                    const formData = await this._subCompsWeaponProficiencies[i].pGetFormData();
                    outWeaponProficiencies.push(formData);
                }

                if ((entity?.armorProficiencies || entity?.entryData?.armorProficiencies) && this._subCompsArmorProficiencies[i]) {
                    const formData = await this._subCompsArmorProficiencies[i].pGetFormData();
                    outArmorProficiencies.push(formData);
                }

                if ((entity?.savingThrowProficiencies || entity?.entryData?.savingThrowProficiencies) && this._subCompsSavingThrowProficiencies[i]) {
                    const formData = await this._subCompsSavingThrowProficiencies[i].pGetFormData();
                    outSavingThrowProficiencies.push(formData);
                }

                if ((entity?.immune || entity?.entryData?.immune) && this._subCompsDamageImmunities[i]) {
                    const formData = await this._subCompsDamageImmunities[i].pGetFormData();
                    outDamageImmunities.push(formData);
                }

                if ((entity?.resist || entity?.entryData?.resist) && this._subCompsDamageResistances[i]) {
                    const formData = await this._subCompsDamageResistances[i].pGetFormData();
                    outDamageResistances.push(formData);
                }

                if ((entity?.vulnerable || entity?.entryData?.vulnerable) && this._subCompsDamageVulnerabilities[i]) {
                    const formData = await this._subCompsDamageVulnerabilities[i].pGetFormData();
                    outDamageVulnerabilities.push(formData);
                }

                if ((entity?.conditionImmune || entity?.entryData?.conditionImmune) && this._subCompsConditionImmunities[i]) {
                    const formData = await this._subCompsConditionImmunities[i].pGetFormData();
                    outConditionImmunities.push(formData);
                }

                if ((entity?.expertise || entity?.entryData?.expertise) && this._subCompsExpertise[i]) {
                    const formData = await this._subCompsExpertise[i].pGetFormData();
                    outExpertise.push(formData);
                }

                if ((entity?.resources || entity?.entryData?.resources) && this._subCompsResources[i]) {
                    const formData = await this._subCompsResources[i].pGetFormData();
                    outResources.push(formData);
                }

                if ((entity?.senses || entity?.entryData?.senses) && this._subCompsSenses[i]) {
                    const formData = await this._subCompsSenses[i].pGetFormData();
                    outSenses.push(formData);
                }

                if ((entity?.additionalSpells || entity?.entryData?.additionalSpells) && this._subCompsAdditionalSpells[i]) {
                    const formData = await this._subCompsAdditionalSpells[i].pGetFormData();
                    outAdditionalSpells.push(formData);
                }
            }
        }

        return {
            isFormComplete: true,
            data: {
                features: cpySelectedLoadeds,
                formDatasSkillToolLanguageProficiencies: outSkillToolLanguageProficiencies,
                formDatasSkillProficiencies: outSkillProficiencies,
                formDatasLanguageProficiencies: outLanguageProficiencies,
                formDatasToolProficiencies: outToolProficiencies,
                formDatasWeaponProficiencies: outWeaponProficiencies,
                formDatasArmorProficiencies: outArmorProficiencies,
                formDatasSavingThrowProficiencies: outSavingThrowProficiencies,
                formDatasDamageImmunities: outDamageImmunities,
                formDatasDamageResistances: outDamageResistances,
                formDatasDamageVulnerabilities: outDamageVulnerabilities,
                formDatasConditionImmunities: outConditionImmunities,
                formDatasExpertise: outExpertise,
                formDatasResources: outResources,
                formDatasSenses: outSenses,
                formDatasAdditionalSpells: outAdditionalSpells,
            },
        };
    }

    _getFormData_getChooseSystemOrChooseFlags({sideData, ixCpySelectedLoaded, propChoose, propCompProp}) {
        if (!sideData[propChoose])
            return null;

        const compProps = this._getProps(ixCpySelectedLoaded);

        const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, compProps[propCompProp]);
        const selectedChoose = ixs.map(ix=>sideData[propChoose][ix]);

        if (!selectedChoose.length)
            return null;

        return selectedChoose[0];
    }

    _getOptionsNameAndCount() {
        const {name, count} = this._optionsSet[0].optionsMeta;
        const required = this._optionsSet.map((it,ix)=>({
            it,
            ix
        })).filter(({it})=>it.isRequiredOption).map(({ix})=>ix);
        const dispCount = count - required.length;

        return {
            name,
            count,
            dispCount,
            required
        };
    }

    get modalTitle() {
        if (!this._isOptions())
            return null;

        const {dispCount, name} = this._getOptionsNameAndCount();
        return `Choose ${dispCount === 1 ? "" : `${dispCount} `}Option${dispCount === 1 ? "" : "s"}: ${name}${this._level != null ? ` (Level ${this._level})` : ""}`;
    }

    static _getLoadedTmpUid(loaded) {
        return `${loaded.page}__${loaded.hash}`;
    }

    _getSelectedLoadeds() {
        if (this._isOptions()) {
            const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, "ixsChosen");
            const {required} = this._getOptionsNameAndCount();
            return [...ixs, ...required].map(ix=>this._optionsSet[ix]);
        } else {
            return this._optionsSet;
        }
    }

    render($wrp) {
        const $stgSubChoiceData = $$`<div class="w-100 ve-flex-col mt-2"></div>`.hideVe();

        this._render_options();

        $$`<div class="ve-flex-col min-h-0 overflow-y-auto">
			${this._lastMeta?.$ele}
			${$stgSubChoiceData}
		</div>`.appendTo($wrp);

        this._addHookBase(ComponentUiUtil.getMetaWrpMultipleChoice_getPropPulse("ixsChosen"), ()=>this._render_pHkIxsChosen({
            $stgSubChoiceData
        }), );
        return this._render_pHkIxsChosen({
            $stgSubChoiceData
        });
    }

    async pRender($wrp) {
        return this.render($wrp);
    }

    async _render_pHkIxsChosen({$stgSubChoiceData}) {
        try {
            await this._pLock("ixsChosen");
            await this._render_pHkIxsChosen_({
                $stgSubChoiceData
            });
        } finally {
            this._unlock("ixsChosen");
        }
    }

    async _render_pHkIxsChosen_({$stgSubChoiceData}) {
        const {prefixSubComps} = this._getProps();
        Object.keys(this._state).filter(k=>k.startsWith(prefixSubComps)).forEach(k=>delete this._state[k]);

        const selectedLoadeds = this._getSelectedLoadeds();

        if (!selectedLoadeds.length)
            return this._render_noSubChoices({
                $stgSubChoiceData
            });

        const isSubChoiceForceDisplay = await this._pIsSubChoiceForceDisplay(selectedLoadeds);
        const isSubChoiceAvailable = await this._pIsSubChoiceAvailable(selectedLoadeds);
        if (!isSubChoiceForceDisplay && !isSubChoiceAvailable)
            return this._render_noSubChoices({
                $stgSubChoiceData
            });

        $stgSubChoiceData.empty();
        this._unregisterSubComps();

        const sideDataRaws = await this._pGetLoadedsSideDataRaws(selectedLoadeds);
        const ptrIsFirstSection = {
            _: true
        };

        for (let i = 0; i < selectedLoadeds.length; ++i) {
            const loaded = selectedLoadeds[i];

            if (!(await this._pIsSubChoiceForceDisplay([selectedLoadeds[i]]) || await this._pIsSubChoiceAvailable([selectedLoadeds[i]])))
                continue;

            const isSubChoice_sideDataChooseSystem = await this._pHasChoiceInSideData_chooseSystem([selectedLoadeds[i]]);
            const isSubChoice_sideDataChooseFlags = await this._pHasChoiceInSideData_chooseFlags([selectedLoadeds[i]]);

            const isForceDisplay_entryDataSkillToolLanguageProficiencies = await this._pIsForceDisplay_skillToolLanguageProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataSkillProficiencies = await this._pIsForceDisplay_skillProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataLanguageProficiencies = await this._pIsForceDisplay_languageProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataToolProficiencies = await this._pIsForceDisplay_toolProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataWeaponProficiencies = await this._pIsForceDisplay_weaponProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataArmorProficiencies = await this._pIsForceDisplay_armorProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataSavingThrowProficiencies = await this._pIsForceDisplay_savingThrowProficiencies([selectedLoadeds[i]]);
            const isForceDisplay_entryDataDamageImmunities = await this._pIsForceDisplay_damageImmunities([selectedLoadeds[i]]);
            const isForceDisplay_entryDataDamageResistances = await this._pIsForceDisplay_damageResistances([selectedLoadeds[i]]);
            const isForceDisplay_entryDataDamageVulnerabilities = await this._pIsForceDisplay_damageVulnerabilities([selectedLoadeds[i]]);
            const isForceDisplay_entryDataConditionImmunities = await this._pIsForceDisplay_conditionImmunities([selectedLoadeds[i]]);
            const isForceDisplay_entryDataExpertise = await this._pIsForceDisplay_expertise([selectedLoadeds[i]]);
            const isForceDisplay_entryDataResources = await this._pIsForceDisplay_resources([selectedLoadeds[i]]);
            const isForceDisplay_entryDataSenses = await this._pIsForceDisplay_senses([selectedLoadeds[i]]);
            const isForceDisplay_entryDataAdditionalSpells = await this._pIsForceDisplay_additionalSpells([selectedLoadeds[i]]);

            const isAvailable_entryDataSkillToolLanguageProficiencies = await this._pIsAvailable_skillToolLanguageProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataSkillProficiencies = await this._pIsAvailable_skillProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataLanguageProficiencies = await this._pIsAvailable_languageProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataToolProficiencies = await this._pIsAvailable_toolProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataWeaponProficiencies = await this._pIsAvailable_weaponProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataArmorProficiencies = await this._pIsAvailable_armorProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataSavingThrowProficiencies = await this._pIsAvailable_savingThrowProficiencies([selectedLoadeds[i]]);
            const isAvailable_entryDataDamageImmunities = await this._pIsAvailable_damageImmunities([selectedLoadeds[i]]);
            const isAvailable_entryDataDamageResistances = await this._pIsAvailable_damageResistances([selectedLoadeds[i]]);
            const isAvailable_entryDataDamageVulnerabilities = await this._pIsAvailable_damageVulnerabilities([selectedLoadeds[i]]);
            const isAvailable_entryDataConditionImmunities = await this._pIsAvailable_conditionImmunities([selectedLoadeds[i]]);
            const isAvailable_entryDataExpertise = await this._pIsAvailable_expertise([selectedLoadeds[i]]);
            const isAvailable_entryDataResources = await this._pIsAvailable_resources([selectedLoadeds[i]]);
            const isAvailable_entryDataSenses = await this._pIsAvailable_senses([selectedLoadeds[i]]);
            const isAvailable_entryDataAdditionalSpells = await this._pIsAvailable_additionalSpells([selectedLoadeds[i]]);

            const {entity, type} = loaded;

            if (i !== 0 || !this._isSkipRenderingFirstFeatureTitle)
                $stgSubChoiceData.append(this._render_getSubCompTitle(entity));

            if (isSubChoice_sideDataChooseSystem) {
                const sideDataRaw = sideDataRaws[i];
                if (sideDataRaw?.chooseSystem) {
                    ptrIsFirstSection._ = false;
                    this._render_renderSubComp_chooseSystem(i, $stgSubChoiceData, entity, type, sideDataRaw);
                }
            }

            if (isSubChoice_sideDataChooseFlags) {
                const sideDataRaw = sideDataRaws[i];
                if (sideDataRaw?.chooseFlags) {
                    ptrIsFirstSection._ = false;
                    this._render_renderSubComp_chooseFlags(i, $stgSubChoiceData, entity, type, sideDataRaw);
                }
            }

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsSkillToolLanguageProficiencies",
                propPrevSubComps: "_prevSubCompsSkillToolLanguageProficiencies",
                isAvailable: isAvailable_entryDataSkillToolLanguageProficiencies,
                isForceDisplay: isForceDisplay_entryDataSkillToolLanguageProficiencies,
                prop: "skillToolLanguageProficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                fnGetExistingFvtt: Charactermancer_OtherProficiencySelect.getExistingFvttFromActor.bind(Charactermancer_OtherProficiencySelect),
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsSkillProficiencies",
                propPrevSubComps: "_prevSubCompsSkillProficiencies",
                isAvailable: isAvailable_entryDataSkillProficiencies,
                isForceDisplay: isForceDisplay_entryDataSkillProficiencies,
                prop: "skillProficiencies",
                title: "Skill Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "skills"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsLanguageProficiencies",
                propPrevSubComps: "_prevSubCompsLanguageProficiencies",
                isAvailable: isAvailable_entryDataLanguageProficiencies,
                isForceDisplay: isForceDisplay_entryDataLanguageProficiencies,
                prop: "languageProficiencies",
                title: "Language Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "traits", "languages"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsToolProficiencies",
                propPrevSubComps: "_prevSubCompsToolProficiencies",
                isAvailable: isAvailable_entryDataToolProficiencies,
                isForceDisplay: isForceDisplay_entryDataToolProficiencies,
                prop: "toolProficiencies",
                title: "Tool Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "tools"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsWeaponProficiencies",
                propPrevSubComps: "_prevSubCompsWeaponProficiencies",
                isAvailable: isAvailable_entryDataWeaponProficiencies,
                isForceDisplay: isForceDisplay_entryDataWeaponProficiencies,
                prop: "weaponProficiencies",
                title: "Weapon Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "traits", "weaponProf"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsArmorProficiencies",
                propPrevSubComps: "_prevSubCompsArmorProficiencies",
                isAvailable: isAvailable_entryDataArmorProficiencies,
                isForceDisplay: isForceDisplay_entryDataArmorProficiencies,
                prop: "armorProficiencies",
                title: "Armor Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "traits", "armorProf"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsSavingThrowProficiencies",
                propPrevSubComps: "_prevSubCompsSavingThrowProficiencies",
                isAvailable: isAvailable_entryDataSavingThrowProficiencies,
                isForceDisplay: isForceDisplay_entryDataSavingThrowProficiencies,
                prop: "savingThrowProficiencies",
                title: "Saving Throw Proficiencies",
                ptrIsFirstSection,
                CompClass: Charactermancer_OtherProficiencySelect,
                propPathActorExistingProficiencies: ["system", "abilities"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
                fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSavingThrowProficiencies.bind(Charactermancer_OtherProficiencySelect),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsDamageImmunities",
                propPrevSubComps: "_prevSubCompsDamageImmunities",
                isAvailable: isAvailable_entryDataDamageImmunities,
                isForceDisplay: isForceDisplay_entryDataDamageImmunities,
                prop: "immune",
                title: "Damage Immunities",
                ptrIsFirstSection,
                CompClass: Charactermancer_DamageImmunitySelect,
                propPathActorExistingProficiencies: ["system", "traits", "di"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsDamageResistances",
                propPrevSubComps: "_prevSubCompsDamageResistances",
                isAvailable: isAvailable_entryDataDamageResistances,
                isForceDisplay: isForceDisplay_entryDataDamageResistances,
                prop: "resist",
                title: "Damage Resistances",
                ptrIsFirstSection,
                CompClass: Charactermancer_DamageResistanceSelect,
                propPathActorExistingProficiencies: ["system", "traits", "dr"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsDamageVulnerabilities",
                propPrevSubComps: "_prevSubCompsDamageVulnerabilities",
                isAvailable: isAvailable_entryDataDamageVulnerabilities,
                isForceDisplay: isForceDisplay_entryDataDamageVulnerabilities,
                prop: "vulnerable",
                title: "Damage Vulnerabilities",
                ptrIsFirstSection,
                CompClass: Charactermancer_DamageVulnerabilitySelect,
                propPathActorExistingProficiencies: ["system", "traits", "dv"],
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsConditionImmunities",
                propPrevSubComps: "_prevSubCompsConditionImmunities",
                isAvailable: isAvailable_entryDataConditionImmunities,
                isForceDisplay: isForceDisplay_entryDataConditionImmunities,
                prop: "conditionImmune",
                title: "Condition Immunities",
                CompClass: Charactermancer_ConditionImmunitySelect,
                propPathActorExistingProficiencies: ["system", "traits", "ci"],
                ptrIsFirstSection,
                fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsExpertise",
                propPrevSubComps: "_prevSubCompsExpertise",
                isAvailable: isAvailable_entryDataExpertise,
                isForceDisplay: isForceDisplay_entryDataExpertise,
                prop: "expertise",
                title: "Expertise",
                ptrIsFirstSection,
                fnSetComp: this._render_pHkIxsChosen_setCompExpertise.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsResources",
                propPrevSubComps: "_prevSubCompsResources",
                isAvailable: isAvailable_entryDataResources,
                isForceDisplay: isForceDisplay_entryDataResources,
                prop: "resources",
                ptrIsFirstSection,
                fnSetComp: this._render_pHkIxsChosen_setCompResources.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsSenses",
                propPrevSubComps: "_prevSubCompsSenses",
                isAvailable: isAvailable_entryDataSenses,
                isForceDisplay: isForceDisplay_entryDataSenses,
                prop: "senses",
                ptrIsFirstSection,
                fnSetComp: this._render_pHkIxsChosen_setCompSenses.bind(this),
            });

            this._render_pHkIxsChosen_comp({
                ix: i,
                $stgSubChoiceData,
                selectedLoadeds,
                propSubComps: "_subCompsAdditionalSpells",
                propPrevSubComps: "_prevSubCompsAdditionalSpells",
                isAvailable: isAvailable_entryDataAdditionalSpells,
                isForceDisplay: isForceDisplay_entryDataAdditionalSpells,
                prop: "additionalSpells",
                ptrIsFirstSection,
                fnSetComp: this._render_pHkIxsChosen_setCompAdditionalSpells.bind(this),
            });
        }

        this._prevSubCompsSkillToolLanguageProficiencies = null;
        this._prevSubCompsSkillProficiencies = null;
        this._prevSubCompsLanguageProficiencies = null;
        this._prevSubCompsToolProficiencies = null;
        this._prevSubCompsWeaponProficiencies = null;
        this._prevSubCompsArmorProficiencies = null;
        this._prevSubCompsSavingThrowProficiencies = null;
        this._prevSubCompsDamageImmunities = null;
        this._prevSubCompsDamageResistances = null;
        this._prevSubCompsDamageVulnerabilities = null;
        this._prevSubCompsConditionImmunities = null;
        this._prevSubCompsExpertise = null;
        this._prevSubCompsResources = null;
        this._prevSubCompsSenses = null;
        this._prevSubCompsAdditionalSpells = null;

        $stgSubChoiceData.toggleVe(isSubChoiceForceDisplay);
    }

    _render_pHkIxsChosen_comp({ix, $stgSubChoiceData, propSubComps, propPrevSubComps, isAvailable, isForceDisplay, selectedLoadeds, prop, title, CompClass, propPathActorExistingProficiencies, ptrIsFirstSection, fnSetComp, fnGetMappedProficiencies, fnGetExistingFvtt, }, ) {
        this[propSubComps][ix] = null;
        if (!isAvailable)
            return;

        const {entity} = selectedLoadeds[ix];

        if (!entity?.[prop] && !entity?.entryData?.[prop])
            return;

        fnSetComp({
            ix,
            propSubComps,
            prop,
            CompClass,
            propPathActorExistingProficiencies,
            entity,
            fnGetMappedProficiencies,
            fnGetExistingFvtt,
        });

        if (this[propPrevSubComps] && this[propPrevSubComps][ix]) {
            this[propSubComps][ix]._proxyAssignSimple("state", MiscUtil.copy(this[propPrevSubComps][ix].__state));
        }

        if (!isForceDisplay)
            return;

        if (!title)
            title = this[propSubComps][ix]?.modalTitle;

        if (title)
            $stgSubChoiceData.append(`${ptrIsFirstSection._ ? "" : `<div class="w-100 mt-1 mb-2"></div>`}<div class="bold mb-2">${title}</div>`);
        this[propSubComps][ix].render($stgSubChoiceData);
        ptrIsFirstSection._ = false;
    }

    _render_pHkIxsChosen_setCompOtherProficiencies({ix, propSubComps, prop, CompClass, propPathActorExistingProficiencies, entity, fnGetMappedProficiencies, fnGetExistingFvtt, }, ) {
        const availableRaw = entity[prop] || entity.entryData[prop];
        const existingFvtt = fnGetExistingFvtt ? fnGetExistingFvtt() : {
            [prop]: MiscUtil.get(this._actor, ...propPathActorExistingProficiencies)
        };
        this[propSubComps][ix] = new CompClass({
            featureSourceTracker: this._featureSourceTracker,
            existing: CompClass.getExisting(existingFvtt),
            existingFvtt,
            available: fnGetMappedProficiencies ? fnGetMappedProficiencies(availableRaw) : availableRaw,
        });
    }

    _render_pHkIxsChosen_setCompExpertise({ix, propSubComps, prop, entity, }, ) {
        const existingFvtt = Charactermancer_ExpertiseSelect.getExistingFvttFromActor(this._actor);
        this[propSubComps][ix] = new Charactermancer_ExpertiseSelect({
            featureSourceTracker: this._featureSourceTracker,
            existing: Charactermancer_ExpertiseSelect.getExisting(existingFvtt),
            existingFvtt,
            available: entity[prop] || entity.entryData[prop],
        });
    }

    _render_pHkIxsChosen_setCompResources({ix, propSubComps, prop, entity, }, ) {
        this[propSubComps][ix] = new Charactermancer_ResourceSelect({
            resources: entity[prop] || entity.entryData[prop],
            className: entity.className,
            classSource: entity.classSource,
            subclassShortName: entity.subclassShortName,
            subclassSource: entity.subclassSource,
        });
    }

    _render_pHkIxsChosen_setCompSenses({ix, propSubComps, prop, entity, }, ) {
        const existingFvtt = Charactermancer_SenseSelect.getExistingFvttFromActor(this._actor);
        this[propSubComps][ix] = new Charactermancer_SenseSelect({
            existing: Charactermancer_SenseSelect.getExisting(existingFvtt),
            existingFvtt,
            senses: entity[prop] || entity.entryData[prop],
        });
    }

    _render_pHkIxsChosen_setCompAdditionalSpells({ix, propSubComps, prop, entity, }, ) {
        this[propSubComps][ix] = Charactermancer_AdditionalSpellsSelect.getComp({
            additionalSpells: entity[prop] || entity.entryData[prop],
            modalFilterSpells: this._modalFilterSpells,

            curLevel: 0,
            targetLevel: Consts.CHAR_MAX_LEVEL,
            spellLevelLow: 0,
            spellLevelHigh: 9,
        });
    }

    _getProps(ix) {
        return {
            prefixSubComps: "subComp_",
            propChooseSystem: `subComp_${ix}_chooseSystem`,
            propChooseFlags: `subComp_${ix}_chooseFlags`,
        };
    }

    _unregisterSubComps() {
        if (!this._featureSourceTracker)
            return;

        this._subCompsSkillToolLanguageProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsSkillProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsLanguageProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsToolProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsWeaponProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsArmorProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsSavingThrowProficiencies.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsDamageImmunities.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsDamageResistances.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsDamageVulnerabilities.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsConditionImmunities.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsExpertise.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsResources.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsSenses.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
        this._subCompsAdditionalSpells.filter(Boolean).forEach(comp=>this._featureSourceTracker.unregister(comp));
    }

    _render_noSubChoices({$stgSubChoiceData}) {
        this._lastSubMetas.forEach(it=>it.unhook());
        this._lastSubMetas = [];

        this._unregisterSubComps();

        this._subCompsSkillToolLanguageProficiencies = [];
        this._subCompsSkillProficiencies = [];
        this._subCompsLanguageProficiencies = [];
        this._subCompsToolProficiencies = [];
        this._subCompsWeaponProficiencies = [];
        this._subCompsArmorProficiencies = [];
        this._subCompsSavingThrowProficiencies = [];
        this._subCompsDamageImmunities = [];
        this._subCompsDamageResistances = [];
        this._subCompsDamageVulnerabilities = [];
        this._subCompsConditionImmunities = [];
        this._subCompsExpertise = [];
        this._subCompsResources = [];
        this._subCompsSenses = [];
        this._subCompsAdditionalSpells = [];

        $stgSubChoiceData.empty().hideVe();
    }

    _render_options() {
        if (!this._isOptions())
            return;

        const {count, required} = this._getOptionsNameAndCount();

        const $ptsExisting = {};
        this._lastMeta = ComponentUiUtil.getMetaWrpMultipleChoice(this, "ixsChosen", {
            values: this._optionsSet,
            ixsRequired: required,
            count,
            fnDisplay: v=>{
                const ptName = Renderer.get().render(v.entry);

                const $ptExisting = $(`<div class="ml-1 ve-small ve-muted"></div>`);
                $ptsExisting[this.constructor._getLoadedTmpUid(v)] = $ptExisting;

                return $$`<div class="w-100 split-v-center">
						<div class="mr-2 ve-flex-v-center">${ptName}${$ptExisting}</div>
						<div class="${Parser.sourceJsonToColor(v.entity.source)} pr-1" title="${Parser.sourceJsonToFull(v.entity.source)}">${Parser.sourceJsonToAbv(v.entity.source)}</div>
					</div>`;
            }
            ,
        }, );

        const hkUpdatePtsExisting = ()=>{
            const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey("features", {
                ignore: this
            }) : null;

            this._optionsSet.forEach(v=>{
                const tmpUid = this.constructor._getLoadedTmpUid(v);

                if (!$ptsExisting[tmpUid])
                    return;

                let isExists = this._existingFeatureChecker && this._existingFeatureChecker.isExistingFeature(UtilEntityGeneric.getName(v.entity), v.page, v.source, v.hash);

                if (otherStates)
                    isExists = isExists || otherStates.some(arr=>arr.some(it=>it.page === v.page && it.hash === v.hash));

                $ptsExisting[tmpUid].title(isExists ? `Gained from Another Source` : "").html(isExists ? `(<i class="fas fa-fw fa-check"></i>)` : "").toggleClass("ml-1", isExists);
            }
            );
        }
        ;
        if (this._featureSourceTracker)
            this._featureSourceTracker.addHook(this, "pulseFeatures", hkUpdatePtsExisting);
        hkUpdatePtsExisting();

        if (this._featureSourceTracker) {
            const hkSetTrackerState = ()=>this._featureSourceTracker.setState(this, {
                features: this._getTrackableFeatures()
            });
            this._addHookBase(this._lastMeta.propPulse, hkSetTrackerState);
            hkSetTrackerState();
        }
    }

    _render_getSubCompTitle(entity) {
        const titleIntro = [entity.className, entity.subclassShortName ? `(${entity.subclassShortName})` : "", entity.level ? `Level ${entity.level}` : "", ].filter(Boolean).join(" ");
        const title = `${titleIntro}${titleIntro ? ": " : ""}${entity.name}`;
        return `${this._isModal ? "" : `<hr class="hr-2">`}<div class="mb-2 bold w-100">${title}</div>`;
    }

    _render_renderSubComp_chooseSystem(ix, $stgSubChoice, entity, type, sideData) {
        return this._render_renderSubComp_chooseSystemChooseFlags({
            ix,
            $stgSubChoice,
            entity,
            type,
            sideData,
            propChoose: "chooseSystem",
            propCompProp: "propChooseSystem",
            propIsRenderEntries: "isChooseSystemRenderEntries",
        });
    }

    _render_renderSubComp_chooseFlags(ix, $stgSubChoice, entity, type, sideData) {
        return this._render_renderSubComp_chooseSystemChooseFlags({
            ix,
            $stgSubChoice,
            entity,
            type,
            sideData,
            propChoose: "chooseFlags",
            propCompProp: "propChooseFlags",
            propIsRenderEntries: "isChooseFlagsRenderEntries",
        });
    }

    _render_renderSubComp_chooseSystemChooseFlags({ix, $stgSubChoice, entity, type, sideData, propChoose, propCompProp, propIsRenderEntries}) {
        const compProps = this._getProps(ix);

        const htmlDescription = sideData[propIsRenderEntries] ? Vetools.withUnpatchedDiceRendering(()=>`${(entity.entries || []).map(ent=>`<div>${Renderer.get().render(ent)}</div>`).join("")}`) : null;

        const choiceMeta = ComponentUiUtil.getMetaWrpMultipleChoice(this, compProps[propCompProp], {
            count: 1,
            fnDisplay: val=>val.name,
            values: sideData[propChoose],
        }, );

        this._lastSubMetas.push(choiceMeta);

        $$`<div class="ve-flex-col w-100">
			${htmlDescription}
			${choiceMeta.$ele}
		</div>`.appendTo($stgSubChoice);
    }

    _getDefaultState() {
        return {
            ixsChosen: [],
        };
    }
}
//#endregion

//#region UIUtil
let UiUtil$1 = class UiUtil {
    static strToInt(string, fallbackEmpty=0, opts) {
        return UiUtil$1._strToNumber(string, fallbackEmpty, opts, true);
    }

    static strToNumber(string, fallbackEmpty=0, opts) {
        return UiUtil$1._strToNumber(string, fallbackEmpty, opts, false);
    }

    static _strToNumber(string, fallbackEmpty=0, opts, isInt) {
        opts = opts || {};
        let out;
        string = string.trim();
        if (!string)
            out = fallbackEmpty;
        else {
            const num = UiUtil$1._parseStrAsNumber(string, isInt);
            out = isNaN(num) || !isFinite(num) ? opts.fallbackOnNaN !== undefined ? opts.fallbackOnNaN : 0 : num;
        }
        if (opts.max != null)
            out = Math.min(out, opts.max);
        if (opts.min != null)
            out = Math.max(out, opts.min);
        return out;
    }

    static strToBool(string, fallbackEmpty=null, opts) {
        opts = opts || {};
        if (!string)
            return fallbackEmpty;
        string = string.trim().toLowerCase();
        if (!string)
            return fallbackEmpty;
        return string === "true" ? true : string === "false" ? false : opts.fallbackOnNaB;
    }

    static intToBonus(int, {isPretty=false}={}) {
        return `${int >= 0 ? "+" : int < 0 ? (isPretty ? "\u2012" : "-") : ""}${Math.abs(int)}`;
    }

    static getEntriesAsText(entryArray) {
        if (!entryArray || !entryArray.length)
            return "";
        if (!(entryArray instanceof Array))
            return UiUtil$1.getEntriesAsText([entryArray]);

        return entryArray.map(it=>{
            if (typeof it === "string" || typeof it === "number")
                return it;

            return JSON.stringify(it, null, 2).split("\n").map(it=>`  ${it}`);
        }
        ).flat().join("\n");
    }

    static getTextAsEntries(text) {
        try {
            const lines = text.split("\n").filter(it=>it.trim()).map(it=>{
                if (/^\s/.exec(it))
                    return it;
                return `"${it.replace(/"/g, `\\"`)}",`;
            }
            ).map(it=>{
                if (/[}\]]$/.test(it.trim()))
                    return `${it},`;
                return it;
            }
            );
            const json = `[\n${lines.join("")}\n]`.replace(/(.*?)(,)(:?\s*]|\s*})/g, "$1$3");
            return JSON.parse(json);
        } catch (e) {
            const lines = text.split("\n").filter(it=>it.trim());
            const slice = lines.join(" \\ ").substring(0, 30);
            JqueryUtil.doToast({
                content: `Could not parse entries! Error was: ${e.message}<br>Text was: ${slice}${slice.length === 30 ? "..." : ""}`,
                type: "danger",
            });
            return lines;
        }
    }

    static getShowModal(opts) {
        opts = opts || {};

        const doc = (opts.window || window).document;

        UiUtil$1._initModalEscapeHandler({
            doc
        });
        UiUtil$1._initModalMouseupHandlers({
            doc
        });
        if (doc.activeElement)
            doc.activeElement.blur();
        let resolveModal;
        const pResolveModal = new Promise(resolve=>{
            resolveModal = resolve;
        }
        );

        const pHandleCloseClick = async(isDataEntered,...args)=>{
            if (opts.cbClose)
                await opts.cbClose(isDataEntered, ...args);
            resolveModal([isDataEntered, ...args]);

            if (opts.isIndestructible)
                wrpOverlay.detach();
            else
                wrpOverlay.remove();

            ContextUtil.closeAllMenus();

            doTeardown();
        }
        ;

        const doTeardown = ()=>{
            UiUtil$1._popFromModalStack(modalStackMeta);
            if (!UiUtil$1._MODAL_STACK.length)
                doc.body.classList.remove(`ui-modal__body-active`);
        }
        ;

        const doOpen = ()=>{
            wrpOverlay.appendTo(doc.body);
            doc.body.classList.add(`ui-modal__body-active`);
        }
        ;

        const wrpOverlay = e_({
            tag: "div",
            clazz: "ui-modal__overlay"
        });
        if (opts.zIndex != null)
            wrpOverlay.style.zIndex = `${opts.zIndex}`;
        if (opts.overlayColor != null)
            wrpOverlay.style.backgroundColor = `${opts.overlayColor}`;

        const overlayBlind = opts.isFullscreenModal ? e_({
            tag: "div",
            clazz: `ui-modal__overlay-blind w-100 h-100 ve-flex-col`,
        }).appendTo(wrpOverlay) : null;

        const wrpScroller = e_({
            tag: "div",
            clazz: `ui-modal__scroller ve-flex-col`,
        });

        const modalWindowClasses = [opts.isWidth100 ? `w-100` : "", opts.isHeight100 ? "h-100" : "", opts.isUncappedHeight ? "ui-modal__inner--uncap-height" : "", opts.isUncappedWidth ? "ui-modal__inner--uncap-width" : "", opts.isMinHeight0 ? `ui-modal__inner--no-min-height` : "", opts.isMinWidth0 ? `ui-modal__inner--no-min-width` : "", opts.isMaxWidth640p ? `ui-modal__inner--max-width-640p` : "", opts.isFullscreenModal ? `ui-modal__inner--mode-fullscreen my-0 pt-0` : "", opts.hasFooter ? `pb-0` : "", ].filter(Boolean);

        const btnCloseModal = opts.isFullscreenModal ? e_({
            tag: "button",
            clazz: `btn btn-danger btn-xs`,
            html: `<span class="glyphicon glyphicon-remove></span>`,
            click: pHandleCloseClick(false),
        }) : null;

        const modalFooter = opts.hasFooter ? e_({
            tag: "div",
            clazz: `no-shrink w-100 ve-flex-col ui-modal__footer ${opts.isFullscreenModal ? `ui-modal__footer--fullscreen mt-1` : "mt-auto"}`,
        }) : null;

        const modal = e_({
            tag: "div",
            clazz: `ui-modal__inner ve-flex-col ${modalWindowClasses.join(" ")}`,
            children: [!opts.isEmpty && opts.title ? e_({
                tag: "div",
                clazz: `split-v-center no-shrink ${opts.isHeaderBorder ? `ui-modal__header--border` : ""} ${opts.isFullscreenModal ? `ui-modal__header--fullscreen mb-1` : ""}`,
                children: [opts.title ? e_({
                    tag: "h4",
                    clazz: `my-2`,
                    html: opts.title.qq(),
                }) : null,
                opts.$titleSplit ? opts.$titleSplit[0] : null,
                btnCloseModal, ].filter(Boolean),
            }) : null,
            !opts.isEmpty ? wrpScroller : null,
            modalFooter, ].filter(Boolean),
        }).appendTo(opts.isFullscreenModal ? overlayBlind : wrpOverlay);

        wrpOverlay.addEventListener("mouseup", async evt=>{
            if (evt.target !== wrpOverlay)
                return;
            if (evt.target !== UiUtil$1._MODAL_LAST_MOUSEDOWN)
                return;
            if (opts.isPermanent)
                return;
            evt.stopPropagation();
            evt.preventDefault();
            return pHandleCloseClick(false);
        }
        );

        if (!opts.isClosed)
            doOpen();

        const modalStackMeta = {
            isPermanent: opts.isPermanent,
            pHandleCloseClick,
            doTeardown,
        };
        if (!opts.isClosed)
            UiUtil$1._pushToModalStack(modalStackMeta);

        const out = {
            $modal: $(modal),
            $modalInner: $(wrpScroller),
            $modalFooter: $(modalFooter),
            doClose: pHandleCloseClick,
            doTeardown,
            pGetResolved: ()=>pResolveModal,
        };

        if (opts.isIndestructible || opts.isClosed) {
            out.doOpen = ()=>{
                UiUtil$1._pushToModalStack(modalStackMeta);
                doOpen();
            }
            ;
        }

        return out;
    }

    static async pGetShowModal(opts) {
        return UiUtil$1.getShowModal(opts);
    }

    static _pushToModalStack(modalStackMeta) {
        if (!UiUtil$1._MODAL_STACK.includes(modalStackMeta)) {
            UiUtil$1._MODAL_STACK.push(modalStackMeta);
        }
    }

    static _popFromModalStack(modalStackMeta) {
        const ixStack = UiUtil$1._MODAL_STACK.indexOf(modalStackMeta);
        if (~ixStack)
            UiUtil$1._MODAL_STACK.splice(ixStack, 1);
    }

    static _initModalEscapeHandler({doc}) {
        if (UiUtil$1._MODAL_STACK)
            return;
        UiUtil$1._MODAL_STACK = [];

        doc.addEventListener("keydown", evt=>{
            if (evt.which !== 27)
                return;
            if (!UiUtil$1._MODAL_STACK.length)
                return;
            if (EventUtil.isInInput(evt))
                return;

            const outerModalMeta = UiUtil$1._MODAL_STACK.last();
            if (!outerModalMeta)
                return;
            evt.stopPropagation();
            if (!outerModalMeta.isPermanent)
                return outerModalMeta.pHandleCloseClick(false);
        }
        );
    }

    static _initModalMouseupHandlers({doc}) {
        doc.addEventListener("mousedown", evt=>{
            UiUtil$1._MODAL_LAST_MOUSEDOWN = evt.target;
        }
        );
    }

    static isAnyModalOpen() {
        return !!UiUtil$1._MODAL_STACK?.length;
    }

    static addModalSep($modalInner) {
        $modalInner.append(`<hr class="hr-2">`);
    }

    static $getAddModalRow($modalInner, tag="div") {
        return $(`<${tag} class="ui-modal__row"></${tag}>`).appendTo($modalInner);
    }

    static $getAddModalRowHeader($modalInner, headerText, opts) {
        opts = opts || {};
        const $row = UiUtil$1.$getAddModalRow($modalInner, "h5").addClass("bold");
        if (opts.$eleRhs)
            $$`<div class="split ve-flex-v-center w-100 pr-1"><span>${headerText}</span>${opts.$eleRhs}</div>`.appendTo($row);
        else
            $row.text(headerText);
        if (opts.helpText)
            $row.title(opts.helpText);
        return $row;
    }

    static $getAddModalRowCb($modalInner, labelText, objectWithProp, propName, helpText) {
        const $row = UiUtil$1.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--cb`);
        if (helpText)
            $row.title(helpText);
        $row.append(`<span>${labelText}</span>`);
        const $cb = $(`<input type="checkbox">`).appendTo($row).keydown(evt=>{
            if (evt.key === "Escape")
                $cb.blur();
        }
        ).prop("checked", objectWithProp[propName]).on("change", ()=>objectWithProp[propName] = $cb.prop("checked"));
        return $cb;
    }

    static $getAddModalRowCb2({$wrp, comp, prop, text, title=null}) {
        const $cb = ComponentUiUtil$1.$getCbBool(comp, prop);

        const $row = $$`<label class="split-v-center py-1 veapp__ele-hoverable">
			<span>${text}</span>
			${$cb}
		</label>`.appendTo($wrp);
        if (title)
            $row.title(title);

        return $cb;
    }

    static $getAddModalRowSel($modalInner, labelText, objectWithProp, propName, values, opts) {
        opts = opts || {};
        const $row = UiUtil$1.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--sel`);
        if (opts.helpText)
            $row.title(opts.helpText);
        $row.append(`<span>${labelText}</span>`);
        const $sel = $(`<select class="form-control input-xs w-30">`).appendTo($row);
        values.forEach((val,i)=>$(`<option value="${i}"></option>`).text(opts.fnDisplay ? opts.fnDisplay(val) : val).appendTo($sel));
        const ix = values.indexOf(objectWithProp[propName]);
        $sel.val(`${~ix ? ix : 0}`).change(()=>objectWithProp[propName] = values[$sel.val()]);
        return $sel;
    }

    static _parseStrAsNumber(str, isInt) {
        const wrpTree = Renderer.dice.lang.getTree3(str);
        if (!wrpTree)
            return NaN;
        const out = wrpTree.tree.evl({});
        if (!isNaN(out) && isInt)
            return Math.round(out);
        return out;
    }

    static bindTypingEnd({$ipt, fnKeyup, fnKeypress, fnKeydown, fnClick}={}) {
        let timerTyping;
        $ipt.on("keyup search paste", evt=>{
            clearTimeout(timerTyping);
            timerTyping = setTimeout(()=>{
                fnKeyup(evt);
            }
            , UiUtil$1.TYPE_TIMEOUT_MS);
        }
        ).on("blur", evt=>{
            clearTimeout(timerTyping);
            fnKeyup(evt);
        }
        ).on("keypress", evt=>{
            if (fnKeypress)
                fnKeypress(evt);
        }
        ).on("keydown", evt=>{
            if (fnKeydown)
                fnKeydown(evt);
            clearTimeout(timerTyping);
        }
        ).on("click", ()=>{
            if (fnClick)
                fnClick();
        }
        ).on("instantKeyup", ()=>{
            clearTimeout(timerTyping);
            fnKeyup();
        }
        );
    }

    static async pDoForceFocus(ele, {timeout=250}={}) {
        if (!ele)
            return;
        ele.focus();

        const forceFocusStart = Date.now();
        while ((Date.now() < forceFocusStart + timeout) && document.activeElement !== ele) {
            await MiscUtil.pDelay(33);
            ele.focus();
        }
    }
}
;
UiUtil$1.SEARCH_RESULTS_CAP = 75;
UiUtil$1.TYPE_TIMEOUT_MS = 100;
UiUtil$1._MODAL_STACK = null;
UiUtil$1._MODAL_LAST_MOUSEDOWN = null;
globalThis.UiUtil = UiUtil$1;
//#endregion

//#region ComponentUiUtil
class ComponentUiUtil {
    static trackHook(hooks, prop, hook) {
        hooks[prop] = hooks[prop] || [];
        hooks[prop].push(hook);
    }

    static $getDisp(comp, prop, {html, $ele, fnGetText}={}) {
        $ele = ($ele || $(html || `<div></div>`));

        const hk = ()=>$ele.text(fnGetText ? fnGetText(comp._state[prop]) : comp._state[prop]);
        comp._addHookBase(prop, hk);
        hk();

        return $ele;
    }

    static $getIptInt(component, prop, fallbackEmpty=0, opts) {
        return ComponentUiUtil._$getIptNumeric(component, prop, UiUtil$1.strToInt, fallbackEmpty, opts);
    }

    static $getIptNumber(component, prop, fallbackEmpty=0, opts) {
        return ComponentUiUtil._$getIptNumeric(component, prop, UiUtil$1.strToNumber, fallbackEmpty, opts);
    }

    static _$getIptNumeric(component, prop, fnConvert, fallbackEmpty=0, opts) {
        opts = opts || {};
        opts.offset = opts.offset || 0;

        const setIptVal = ()=>{
            if (opts.isAllowNull && component._state[prop] == null) {
                return $ipt.val(null);
            }

            const num = (component._state[prop] || 0) + opts.offset;
            const val = opts.padLength ? `${num}`.padStart(opts.padLength, "0") : num;
            $ipt.val(val);
        }
        ;

        const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal text-right">`)).disableSpellcheck().keydown(evt=>{
            if (evt.key === "Escape")
                $ipt.blur();
        }
        ).change(()=>{
            const raw = $ipt.val().trim();
            const cur = component._state[prop];

            if (opts.isAllowNull && !raw)
                return component._state[prop] = null;

            if (raw.startsWith("=")) {
                component._state[prop] = fnConvert(raw.slice(1), fallbackEmpty, opts) - opts.offset;
            } else {
                const mUnary = prevValue != null && prevValue < 0 ? /^[+/*^]/.exec(raw) : /^[-+/*^]/.exec(raw);
                if (mUnary) {
                    let proc = raw;
                    proc = proc.slice(1).trim();
                    const mod = fnConvert(proc, fallbackEmpty, opts);
                    const full = `${cur}${mUnary[0]}${mod}`;
                    component._state[prop] = fnConvert(full, fallbackEmpty, opts) - opts.offset;
                } else {
                    component._state[prop] = fnConvert(raw, fallbackEmpty, opts) - opts.offset;
                }
            }

            if (cur === component._state[prop])
                setIptVal();
        }
        );

        let prevValue;
        const hook = ()=>{
            prevValue = component._state[prop];
            setIptVal();
        }
        ;
        if (opts.hookTracker)
            ComponentUiUtil.trackHook(opts.hookTracker, prop, hook);
        component._addHookBase(prop, hook);
        hook();

        if (opts.asMeta)
            return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
        else
            return $ipt;
    }

    static $getIptStr(component, prop, opts) {
        opts = opts || {};

        if ((opts.decorationLeft || opts.decorationRight) && !opts.asMeta)
            throw new Error(`Input must be created with "asMeta" option`);

        const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`)).keydown(evt=>{
            if (evt.key === "Escape")
                $ipt.blur();
        }
        ).disableSpellcheck();
        UiUtil.bindTypingEnd({
            $ipt,
            fnKeyup: ()=>{
                const nxtVal = opts.isNoTrim ? $ipt.val() : $ipt.val().trim();
                component._state[prop] = opts.isAllowNull && !nxtVal ? null : nxtVal;
            }
            ,
        });

        if (opts.placeholder)
            $ipt.attr("placeholder", opts.placeholder);

        if (opts.autocomplete && opts.autocomplete.length)
            $ipt.typeahead({
                source: opts.autocomplete
            });
        const hook = ()=>{
            if (component._state[prop] == null)
                $ipt.val(null);
            else {
                if ($ipt.val().trim() !== component._state[prop])
                    $ipt.val(component._state[prop]);
            }
        }
        ;
        component._addHookBase(prop, hook);
        hook();

        if (opts.asMeta)
            return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
        else
            return $ipt;
    }

    static _getIptDecoratedMeta(component, prop, $ipt, hook, opts) {
        const out = {
            $ipt,
            unhook: ()=>component._removeHookBase(prop, hook)
        };

        if (opts.decorationLeft || opts.decorationRight) {
            let $decorLeft;
            let $decorRight;

            if (opts.decorationLeft) {
                $ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--left`);
                $decorLeft = ComponentUiUtil._$getDecor(component, prop, $ipt, opts.decorationLeft, "left", opts);
            }

            if (opts.decorationRight) {
                $ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--right`);
                $decorRight = ComponentUiUtil._$getDecor(component, prop, $ipt, opts.decorationRight, "right", opts);
            }

            out.$wrp = $$`<div class="relative w-100">${$ipt}${$decorLeft}${$decorRight}</div>`;
        }

        return out;
    }

    static _$getDecor(component, prop, $ipt, decorType, side, opts) {
        switch (decorType) {
        case "search":
            {
                return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>`);
            }
        case "clear":
            {
                return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} ve-flex-vh-center clickable" title="Clear"><span class="glyphicon glyphicon-remove"></span></div>`).click(()=>$ipt.val("").change().keydown().keyup());
            }
        case "ticker":
            {
                const isValidValue = val=>{
                    if (opts.max != null && val > opts.max)
                        return false;
                    if (opts.min != null && val < opts.min)
                        return false;
                    return true;
                }
                ;

                const handleClick = (delta)=>{
                    const nxt = component._state[prop] + delta;
                    if (!isValidValue(nxt))
                        return;
                    component._state[prop] = nxt;
                    $ipt.focus();
                }
                ;

                const $btnUp = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">+</button>`).click(()=>handleClick(1));

                const $btnDown = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">\u2012</button>`).click(()=>handleClick(-1));

                return $$`<div class="ui-ideco__wrp ui-ideco__wrp--${side} ve-flex-vh-center ve-flex-col">
					${$btnUp}
					${$btnDown}
				</div>`;
            }
        case "spacer":
            {
                return "";
            }
        default:
            throw new Error(`Unimplemented!`);
        }
    }

    static $getIptEntries(component, prop, opts) {
        opts = opts || {};

        const $ipt = (opts.$ele || $(`<textarea class="form-control input-xs form-control--minimal resize-vertical"></textarea>`)).keydown(evt=>{
            if (evt.key === "Escape")
                $ipt.blur();
        }
        ).change(()=>component._state[prop] = UiUtil$1.getTextAsEntries($ipt.val().trim()));
        const hook = ()=>$ipt.val(UiUtil$1.getEntriesAsText(component._state[prop]));
        component._addHookBase(prop, hook);
        hook();
        return $ipt;
    }

    static $getIptColor(component, prop, opts) {
        opts = opts || {};

        const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal ui__ipt-color" type="color">`)).change(()=>component._state[prop] = $ipt.val());
        const hook = ()=>$ipt.val(component._state[prop]);
        component._addHookBase(prop, hook);
        hook();
        return $ipt;
    }

    static getBtnBool(component, prop, opts) {
        opts = opts || {};

        let ele = opts.ele;
        if (opts.html)
            ele = e_({
                outer: opts.html
            });

        const activeClass = opts.activeClass || "active";
        const stateName = opts.stateName || "state";
        const stateProp = opts.stateProp || `_${stateName}`;

        const btn = (ele ? e_({
            ele
        }) : e_({
            ele: ele,
            tag: "button",
            clazz: "btn btn-xs btn-default",
            text: opts.text || "Toggle",
        })).onClick(()=>component[stateProp][prop] = !component[stateProp][prop]).onContextmenu(evt=>{
            evt.preventDefault();
            component[stateProp][prop] = !component[stateProp][prop];
        }
        );

        const hk = ()=>{
            btn.toggleClass(activeClass, opts.isInverted ? !component[stateProp][prop] : !!component[stateProp][prop]);
            if (opts.activeTitle || opts.inactiveTitle)
                btn.title(component[stateProp][prop] ? (opts.activeTitle || opts.title || "") : (opts.inactiveTitle || opts.title || ""));
            if (opts.fnHookPost)
                opts.fnHookPost(component[stateProp][prop]);
        }
        ;
        component._addHook(stateName, prop, hk);
        hk();

        return btn;
    }

    static $getBtnBool(component, prop, opts) {
        const nxtOpts = {
            ...opts
        };
        if (nxtOpts.$ele) {
            nxtOpts.ele = nxtOpts.$ele[0];
            delete nxtOpts.$ele;
        }
        return $(this.getBtnBool(component, prop, nxtOpts));
    }

    static $getCbBool(component, prop, opts) {
        opts = opts || {};

        const stateName = opts.stateName || "state";
        const stateProp = opts.stateProp || `_${stateName}`;

        const cb = e_({
            tag: "input",
            type: "checkbox",
            keydown: evt=>{
                if (evt.key === "Escape")
                    cb.blur();
            }
            ,
            change: ()=>{
                if (opts.isTreatIndeterminateNullAsPositive && component[stateProp][prop] == null) {
                    component[stateProp][prop] = false;
                    return;
                }

                component[stateProp][prop] = cb.checked;
            }
            ,
        });

        const hook = ()=>{
            cb.checked = !!component[stateProp][prop];
            if (opts.isDisplayNullAsIndeterminate)
                cb.indeterminate = component[stateProp][prop] == null;
        }
        ;
        component._addHook(stateName, prop, hook);
        hook();

        const $cb = $(cb);

        return opts.asMeta ? ({
            $cb,
            unhook: ()=>component._removeHook(stateName, prop, hook)
        }) : $cb;
    }

    /**Create a dropdown menu with options to click on (used to create a class dropdown menu at least) */
    static $getSelSearchable(comp, prop, opts) {
        opts = opts || {};

        //UI Dropdown element
        const $iptDisplay = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
        .addClass("ui-sel2__ipt-display").attr("tabindex", "-1").click(()=>{
            if (opts.isDisabled){return;}
            $iptSearch.focus().select();
        }
        ).prop("disabled", !!opts.isDisabled);
        //$iptDisplay.disableSpellcheck();
        $iptDisplay.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");

        const handleSearchChange = ()=>{
            const cleanTerm = this._$getSelSearchable_getSearchString($iptSearch.val());
            metaOptions.forEach(it=>{
                it.isVisible = it.searchTerm.includes(cleanTerm);
                it.$ele.toggleVe(it.isVisible && !it.isForceHidden);
            }
            );
        };

        const handleSearchChangeDebounced = MiscUtil.debounce(handleSearchChange, 30);

        const $iptSearch = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`)).addClass("absolute ui-sel2__ipt-search").keydown(evt=>{
            if (opts.isDisabled)
                return;

            switch (evt.key) {
            case "Escape":
                evt.stopPropagation();
                return $iptSearch.blur();

            case "ArrowDown":
                {
                    evt.preventDefault();
                    const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                    if (!visibleMetaOptions.length)
                        return;
                    visibleMetaOptions[0].$ele.focus();
                    break;
                }

            case "Enter":
            case "Tab":
                {
                    const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                    if (!visibleMetaOptions.length)
                        return;
                    comp._state[prop] = visibleMetaOptions[0].value;
                    $iptSearch.blur();
                    break;
                }

            default:
                handleSearchChangeDebounced();
            }
        }
        ).change(()=>handleSearchChangeDebounced()).click(()=>{
            if (opts.isDisabled)
                return;
            $iptSearch.focus().select();
        }
        ).prop("disabled", !!opts.isDisabled)//.disableSpellcheck();
        .attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");

        //This object will be the parent of our choices in the dropdown menu
        const $wrpChoices = $(`<div class="absolute ui-sel2__wrp-options overflow-y-scroll"></div>`);
        const $wrp = $(`<div class="ve-flex relative ui-sel2__wrp w-100 overflow-x-vis">
			${$iptDisplay[0].outerHTML}
			${$iptSearch[0].outerHTML}
		</div>`);

        

        const procValues = opts.isAllowNull ? [null, ...opts.values] : opts.values;
        //Create dropdown options here
        const metaOptions = procValues.map((v,i)=>{
            const display = v == null ? (opts.displayNullAs || "\u2014") : opts.fnDisplay ? opts.fnDisplay(v) : v;
            const additionalStyleClasses = opts.fnGetAdditionalStyleClasses ? opts.fnGetAdditionalStyleClasses(v) : null;

            //V is an index that points to a class

            //Here we create an option in the dropdown menu
            const $ele = $(`<div class="ve-flex-v-center py-1 px-1 clickable ui-sel2__disp-option
                ${v == null ? `italic` : ""} ${additionalStyleClasses ? additionalStyleClasses.join(" ") : ""}" tabindex="0">${display}</div>`)
            .click(()=>{ //When an option is clicked
                console.log("BTN CLICKED");
                if (opts.isDisabled){return;}
                //here is where _state first gets set with the [propIxClass] thingy
                //this should probably trigger an event (because _state is a proxy and can run events when something is setted)
                comp._state[prop] = v; 
                $(document.activeElement).blur();
                $wrp.addClass("no-events");
                setTimeout(()=>$wrp.removeClass("no-events"), 50);
            })
            .keydown(evt=>{
                if (opts.isDisabled)
                    return;

                switch (evt.key) {
                case "Escape":
                    evt.stopPropagation();
                    return $ele.blur();

                case "ArrowDown":
                    {
                        evt.preventDefault();
                        const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                        if (!visibleMetaOptions.length)
                            return;
                        const ixCur = visibleMetaOptions.indexOf(out);
                        const nxt = visibleMetaOptions[ixCur + 1];
                        if (nxt)
                            nxt.$ele.focus();
                        break;
                    }

                case "ArrowUp":
                    {
                        evt.preventDefault();
                        const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                        if (!visibleMetaOptions.length)
                            return;
                        const ixCur = visibleMetaOptions.indexOf(out);
                        const prev = visibleMetaOptions[ixCur - 1];
                        if (prev)
                            return prev.$ele.focus();
                        $iptSearch.focus();
                        break;
                    }

                case "Enter":
                    {
                        comp._state[prop] = v;
                        $ele.blur();
                        break;
                    }
                }
            }
            ).appendTo($wrpChoices);


            //TEMPFIX
            const isForceHidden = false; //opts.isHiddenPerValue && !!(opts.isAllowNull ? opts.isHiddenPerValue[i - 1] : opts.isHiddenPerValue[i]);
            if (isForceHidden){$ele.hideVe();}
            
            
        
            $wrp.append($wrpChoices);

            const out = {
                value: v,
                isVisible: true,
                isForceHidden,
                searchTerm: this._$getSelSearchable_getSearchString(display),
                $ele,
            };
            
            return out;
        });

        const fnUpdateHidden = (isHiddenPerValue,isHideNull=false)=>{
            let metaOptions_ = metaOptions;

            if (opts.isAllowNull) {
                metaOptions_[0].isForceHidden = isHideNull;
                metaOptions_ = metaOptions_.slice(1);
            }

            metaOptions_.forEach((it,i)=>it.isForceHidden = !!isHiddenPerValue[i]);
            handleSearchChange();
        };

        const hk = ()=>{
            if (comp._state[prop] == null)
                $iptDisplay.addClass("italic").addClass("ve-muted").val(opts.displayNullAs || "\u2014");
            else
                $iptDisplay.removeClass("italic").removeClass("ve-muted").val(opts.fnDisplay ? opts.fnDisplay(comp._state[prop]) : comp._state[prop]);

            metaOptions.forEach(it=>it.$ele.removeClass("active"));
            const metaActive = metaOptions.find(it=>it.value == null ? comp._state[prop] == null : it.value === comp._state[prop]);
            if (metaActive)
                metaActive.$ele.addClass("active");
        };
        comp._addHookBase(prop, hk);
        hk();
        
        const arrow = $(`<div class="ui-sel2__disp-arrow absolute no-events bold">
            <span class="glyphicon glyphicon-menu-down"></span>
        </div>`);
        $wrp.append(arrow);

        return opts.asMeta ? ({
            $wrp,
            unhook: ()=>comp._removeHookBase(prop, hk),
            $iptDisplay,
            $iptSearch,
            fnUpdateHidden,
        }) : $wrp;
    }

    static _$getSelSearchable_getSearchString(str) {
        if (str == null)
            return "";
        return CleanUtil.getCleanString(str.trim().toLowerCase().replace(/\s+/g, " "));
    }

    static $getSelEnum(component, prop, {values, $ele, html, isAllowNull, fnDisplay, displayNullAs, asMeta, propProxy="state", isSetIndexes=false}={}) {
        const _propProxy = `_${propProxy}`;

        let values_;

        let $sel = $ele || (html ? $(html) : null);
        if (!$sel) {
            const sel = document.createElement("select");
            sel.className = "form-control input-xs";
            $sel = $(sel);
        }

        $sel.change(()=>{
            const ix = Number($sel.val());
            if (~ix)
                return void (component[_propProxy][prop] = isSetIndexes ? ix : values_[ix]);

            if (isAllowNull)
                return void (component[_propProxy][prop] = null);
            component[_propProxy][prop] = isSetIndexes ? 0 : values_[0];
        }
        );

        const setValues_handleResetOnMissing = ({isResetOnMissing, nxtValues})=>{
            if (!isResetOnMissing)
                return;

            if (component[_propProxy][prop] == null)
                return;

            if (isSetIndexes) {
                if (component[_propProxy][prop] >= 0 && component[_propProxy][prop] < nxtValues.length) {
                    if (isAllowNull)
                        return component[_propProxy][prop] = null;
                    return component[_propProxy][prop] = 0;
                }

                return;
            }

            if (!nxtValues.includes(component[_propProxy][prop])) {
                if (isAllowNull)
                    return component[_propProxy][prop] = null;
                return component[_propProxy][prop] = nxtValues[0];
            }
        }
        ;

        const setValues = (nxtValues,{isResetOnMissing=false, isForce=false}={})=>{
            if (!isForce && CollectionUtil.deepEquals(values_, nxtValues))
                return;
            values_ = nxtValues;
            $sel.empty();
            if (isAllowNull) {
                const opt = document.createElement("option");
                opt.value = "-1";
                opt.text = displayNullAs || "\u2014";
                $sel.append(opt);
            }
            values_.forEach((it,i)=>{
                const opt = document.createElement("option");
                opt.value = `${i}`;
                opt.text = fnDisplay ? fnDisplay(it) : it;
                $sel.append(opt);
            }
            );

            setValues_handleResetOnMissing({
                isResetOnMissing,
                nxtValues
            });

            hook();
        }
        ;

        const hook = ()=>{
            if (isSetIndexes) {
                const ix = component[_propProxy][prop] == null ? -1 : component[_propProxy][prop];
                $sel.val(`${ix}`);
                return;
            }

            const searchFor = component[_propProxy][prop] === undefined ? null : component[_propProxy][prop];
            const ix = values_.indexOf(searchFor);
            $sel.val(`${ix}`);
        }
        ;
        component._addHookBase(prop, hook);

        setValues(values);

        if (!asMeta)
            return $sel;

        return {
            $sel,
            unhook: ()=>component._removeHookBase(prop, hook),
            setValues,
        };
    }

    static $getPickEnum(component, prop, opts) {
        return this._$getPickEnumOrString(component, prop, opts);
    }

    static $getPickString(component, prop, opts) {
        return this._$getPickEnumOrString(component, prop, {
            ...opts,
            isFreeText: true
        });
    }

    static _$getPickEnumOrString(component, prop, opts) {
        opts = opts || {};

        const getSubcompValues = ()=>{
            const initialValuesArray = (opts.values || []).concat(opts.isFreeText ? MiscUtil.copyFast((component._state[prop] || [])) : []);
            const initialValsCompWith = opts.isCaseInsensitive ? component._state[prop].map(it=>it.toLowerCase()) : component._state[prop];
            return initialValuesArray.map(v=>opts.isCaseInsensitive ? v.toLowerCase() : v).mergeMap(v=>({
                [v]: component._state[prop] && initialValsCompWith.includes(v)
            }));
        }
        ;

        const initialVals = getSubcompValues();

        let $btnAdd;
        if (opts.isFreeText) {
            $btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add ml-auto">+</button>`).click(async()=>{
                const input = await InputUiUtil$1.pGetUserString();
                if (input == null || input === VeCt.SYM_UI_SKIP)
                    return;
                const inputClean = opts.isCaseInsensitive ? input.trim().toLowerCase() : input.trim();
                pickComp.getPod().set(inputClean, true);
            }
            );
        } else {
            const menu = ContextUtil.getMenu(opts.values.map(it=>new ContextUtil.Action(opts.fnDisplay ? opts.fnDisplay(it) : it,()=>pickComp.getPod().set(it, true),)));

            $btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add">+</button>`).click(evt=>ContextUtil.pOpenMenu(evt, menu));
        }

        const pickComp = BaseComponent$1.fromObject(initialVals);
        pickComp.render = function($parent) {
            $parent.empty();

            Object.entries(this._state).forEach(([k,v])=>{
                if (v === false)
                    return;

                const $btnRemove = $(`<button class="btn btn-danger ui-pick__btn-remove ve-text-center">×</button>`).click(()=>this._state[k] = false);
                const txt = `${opts.fnDisplay ? opts.fnDisplay(k) : k}`;
                $$`<div class="ve-flex mx-1 mb-1 ui-pick__disp-pill max-w-100 min-w-0"><div class="px-1 ui-pick__disp-text ve-flex-v-center text-clip-ellipsis" title="${txt.qq()}">${txt}</div>${$btnRemove}</div>`.appendTo($parent);
            }
            );
        }
        ;

        const $wrpPills = $(`<div class="ve-flex ve-flex-wrap max-w-100 min-w-0"></div>`);
        const $wrp = $$`<div class="ve-flex-v-center w-100">${$btnAdd}${$wrpPills}</div>`;
        pickComp._addHookAll("state", ()=>{
            component._state[prop] = Object.keys(pickComp._state).filter(k=>pickComp._state[k]);
            pickComp.render($wrpPills);
        }
        );
        pickComp.render($wrpPills);

        const hkParent = ()=>pickComp._proxyAssignSimple("state", getSubcompValues(), true);
        component._addHookBase(prop, hkParent);

        return $wrp;
    }

    static $getCbsEnum(component, prop, opts) {
        opts = opts || {};

        const $wrp = $(`<div class="ve-flex-col w-100"></div>`);
        const metas = opts.values.map(it=>{
            const $cb = $(`<input type="checkbox">`).keydown(evt=>{
                if (evt.key === "Escape")
                    $cb.blur();
            }
            ).change(()=>{
                let didUpdate = false;
                const ix = (component._state[prop] || []).indexOf(it);
                if (~ix)
                    component._state[prop].splice(ix, 1);
                else {
                    if (component._state[prop])
                        component._state[prop].push(it);
                    else {
                        didUpdate = true;
                        component._state[prop] = [it];
                    }
                }
                if (!didUpdate)
                    component._state[prop] = [...component._state[prop]];
            }
            );

            $$`<label class="split-v-center my-1 stripe-odd ${opts.isIndent ? "ml-4" : ""}"><div class="no-wrap ve-flex-v-center">${opts.fnDisplay ? opts.fnDisplay(it) : it}</div>${$cb}</label>`.appendTo($wrp);

            return {
                $cb,
                value: it
            };
        }
        );

        const hook = ()=>metas.forEach(meta=>meta.$cb.prop("checked", component._state[prop] && component._state[prop].includes(meta.value)));
        component._addHookBase(prop, hook);
        hook();

        return opts.asMeta ? {
            $wrp,
            unhook: ()=>component._removeHookBase(prop, hook)
        } : $wrp;
    }

    static getMetaWrpMultipleChoice(comp, prop, opts) {
        opts = opts || {};
        this._getMetaWrpMultipleChoice_doValidateOptions(opts);

        const rowMetas = [];
        const $eles = [];
        const ixsSelectionOrder = [];
        const $elesSearchable = {};

        const propIsAcceptable = this.getMetaWrpMultipleChoice_getPropIsAcceptable(prop);
        const propPulse = this.getMetaWrpMultipleChoice_getPropPulse(prop);
        const propIxMax = this._getMetaWrpMultipleChoice_getPropValuesLength(prop);

        const cntRequired = ((opts.required || []).length) + ((opts.ixsRequired || []).length);
        const count = opts.count != null ? opts.count - cntRequired : null;
        const countIncludingRequired = opts.count != null ? count + cntRequired : null;
        const min = opts.min != null ? opts.min - cntRequired : null;
        const max = opts.max != null ? opts.max - cntRequired : null;

        const valueGroups = opts.valueGroups || [{
            values: opts.values
        }];

        let ixValue = 0;
        valueGroups.forEach((group,i)=>{
            if (i !== 0)
                $eles.push($(`<hr class="w-100 hr-2 hr--dotted">`));

            if (group.name) {
                const $wrpName = $$`<div class="split-v-center py-1">
					<div class="ve-flex-v-center"><span class="mr-2">‒</span><span>${group.name}</span></div>
					${opts.valueGroupSplitControlsLookup?.[group.name]}
				</div>`;
                $eles.push($wrpName);
            }

            if (group.text)
                $eles.push($(`<div class="ve-flex-v-center py-1"><div class="ml-1 mr-3"></div><i>${group.text}</i></div>`));

            group.values.forEach(v=>{
                const ixValueFrozen = ixValue;

                const propIsActive = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixValueFrozen);
                const propIsRequired = this.getMetaWrpMultipleChoice_getPropIsRequired(prop, ixValueFrozen);

                const isHardRequired = (opts.required && opts.required.includes(v)) || (opts.ixsRequired && opts.ixsRequired.includes(ixValueFrozen));
                const isRequired = isHardRequired || comp._state[propIsRequired];

                if (comp._state[propIsActive] && !comp._state[propIsRequired])
                    ixsSelectionOrder.push(ixValueFrozen);

                let hk;
                const $cb = isRequired ? $(`<input type="checkbox" disabled checked title="This option is required.">`) : ComponentUiUtil.$getCbBool(comp, propIsActive);

                if (isRequired)
                    comp._state[propIsActive] = true;

                if (!isRequired) {
                    hk = ()=>{
                        const ixIx = ixsSelectionOrder.findIndex(it=>it === ixValueFrozen);
                        if (~ixIx)
                            ixsSelectionOrder.splice(ixIx, 1);
                        if (comp._state[propIsActive])
                            ixsSelectionOrder.push(ixValueFrozen);

                        const activeRows = rowMetas.filter(it=>comp._state[it.propIsActive]);

                        if (count != null) {
                            if (activeRows.length > countIncludingRequired) {
                                const ixFirstSelected = ixsSelectionOrder.splice(ixsSelectionOrder.length - 2, 1)[0];
                                if (ixFirstSelected != null) {
                                    const propIsActiveOther = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixFirstSelected);
                                    comp._state[propIsActiveOther] = false;

                                    comp._state[propPulse] = !comp._state[propPulse];
                                }
                                return;
                            }
                        }

                        let isAcceptable = false;
                        if (count != null) {
                            if (activeRows.length === countIncludingRequired)
                                isAcceptable = true;
                        } else {
                            if (activeRows.length >= (min || 0) && activeRows.length <= (max || Number.MAX_SAFE_INTEGER))
                                isAcceptable = true;
                        }

                        comp._state[propIsAcceptable] = isAcceptable;

                        comp._state[propPulse] = !comp._state[propPulse];
                    }
                    ;
                    comp._addHookBase(propIsActive, hk);
                    hk();
                }

                const displayValue = opts.fnDisplay ? opts.fnDisplay(v, ixValueFrozen) : v;

                rowMetas.push({
                    $cb,
                    displayValue,
                    value: v,
                    propIsActive,
                    unhook: ()=>{
                        if (hk)
                            comp._removeHookBase(propIsActive, hk);
                    }
                    ,
                });

                const $ele = $$`<label class="ve-flex-v-center py-1 stripe-even">
					<div class="col-1 ve-flex-vh-center">${$cb}</div>
					<div class="col-11 ve-flex-v-center">${displayValue}</div>
				</label>`;
                $eles.push($ele);

                if (opts.isSearchable) {
                    const searchText = `${opts.fnGetSearchText ? opts.fnGetSearchText(v, ixValueFrozen) : v}`.toLowerCase().trim();
                    ($elesSearchable[searchText] = $elesSearchable[searchText] || []).push($ele);
                }

                ixValue++;
            }
            );
        }
        );

        ixsSelectionOrder.sort((a,b)=>SortUtil.ascSort(a, b));

        comp.__state[propIxMax] = ixValue;

        let $iptSearch;
        if (opts.isSearchable) {
            const compSub = BaseComponent$1.fromObject({
                search: ""
            });
            $iptSearch = ComponentUiUtil.$getIptStr(compSub, "search");
            const hkSearch = ()=>{
                const cleanSearch = compSub._state.search.trim().toLowerCase();
                if (!cleanSearch) {
                    Object.values($elesSearchable).forEach($eles=>$eles.forEach($ele=>$ele.removeClass("ve-hidden")));
                    return;
                }

                Object.entries($elesSearchable).forEach(([searchText,$eles])=>$eles.forEach($ele=>$ele.toggleVe(searchText.includes(cleanSearch))));
            }
            ;
            compSub._addHookBase("search", hkSearch);
            hkSearch();
        }

        const unhook = ()=>rowMetas.forEach(it=>it.unhook());
        return {
            $ele: $$`<div class="ve-flex-col w-100 overflow-y-auto">${$eles}</div>`,
            $iptSearch,
            rowMetas,
            propIsAcceptable,
            propPulse,
            unhook,
            cleanup: ()=>{
                unhook();
                Object.keys(comp._state).filter(it=>it.startsWith(`${prop}__`)).forEach(it=>delete comp._state[it]);
            }
            ,
        };
    }

    static getMetaWrpMultipleChoice_getPropIsAcceptable(prop) {
        return `${prop}__isAcceptable`;
    }
    static getMetaWrpMultipleChoice_getPropPulse(prop) {
        return `${prop}__pulse`;
    }
    static _getMetaWrpMultipleChoice_getPropValuesLength(prop) {
        return `${prop}__length`;
    }
    static getMetaWrpMultipleChoice_getPropIsActive(prop, ixValue) {
        return `${prop}__isActive_${ixValue}`;
    }
    static getMetaWrpMultipleChoice_getPropIsRequired(prop, ixValue) {
        return `${prop}__isRequired_${ixValue}`;
    }

    static getMetaWrpMultipleChoice_getSelectedIxs(comp, prop) {
        const out = [];
        const len = comp._state[this._getMetaWrpMultipleChoice_getPropValuesLength(prop)] || 0;
        for (let i = 0; i < len; ++i) {
            if (comp._state[this.getMetaWrpMultipleChoice_getPropIsActive(prop, i)])
                out.push(i);
        }
        return out;
    }

    static getMetaWrpMultipleChoice_getSelectedValues(comp, prop, {values, valueGroups}) {
        const selectedIxs = this.getMetaWrpMultipleChoice_getSelectedIxs(comp, prop);
        if (values)
            return selectedIxs.map(ix=>values[ix]);

        const selectedIxsSet = new Set(selectedIxs);
        const out = [];
        let ixValue = 0;
        valueGroups.forEach(group=>{
            group.values.forEach(v=>{
                if (selectedIxsSet.has(ixValue))
                    out.push(v);
                ixValue++;
            }
            );
        }
        );
        return out;
    }

    static _getMetaWrpMultipleChoice_doValidateOptions(opts) {
        if ((Number(!!opts.values) + Number(!!opts.valueGroups)) !== 1)
            throw new Error(`Exactly one of "values" and "valueGroups" must be specified!`);

        if (opts.count != null && (opts.min != null || opts.max != null))
            throw new Error(`Chooser must be either in "count" mode or "min/max" mode!`);
        if (opts.count == null && opts.min == null && opts.max == null)
            opts.count = 1;
    }

    static $getSliderRange(comp, opts) {
        opts = opts || {};
        const slider = new ComponentUiUtil.RangeSlider({
            comp,
            ...opts
        });
        return slider.$get();
    }

    static $getSliderNumber(comp, prop, {min, max, step, $ele, asMeta, }={}, ) {
        const $slider = ($ele || $(`<input type="range">`)).change(()=>comp._state[prop] = Number($slider.val()));

        if (min != null)
            $slider.attr("min", min);
        if (max != null)
            $slider.attr("max", max);
        if (step != null)
            $slider.attr("step", step);

        const hk = ()=>$slider.val(comp._state[prop]);
        comp._addHookBase(prop, hk);
        hk();

        return asMeta ? ({
            $slider,
            unhook: ()=>comp._removeHookBase(prop, hk)
        }) : $slider;
    }
}

ComponentUiUtil.RangeSlider = class {
    constructor({comp, propMin, propMax, propCurMin, propCurMax, fnDisplay, fnDisplayTooltip, sparseValues, }, ) {
        this._comp = comp;
        this._propMin = propMin;
        this._propMax = propMax;
        this._propCurMin = propCurMin;
        this._propCurMax = propCurMax;
        this._fnDisplay = fnDisplay;
        this._fnDisplayTooltip = fnDisplayTooltip;
        this._sparseValues = sparseValues;

        this._isSingle = !this._propCurMax;

        const compCpyState = {
            [this._propMin]: this._comp._state[this._propMin],
            [this._propCurMin]: this._comp._state[this._propCurMin],
            [this._propMax]: this._comp._state[this._propMax],
        };
        if (!this._isSingle)
            compCpyState[this._propCurMax] = this._comp._state[this._propCurMax];
        this._compCpy = BaseComponent$1.fromObject(compCpyState);

        this._comp._addHook("state", this._propMin, ()=>this._compCpy._state[this._propMin] = this._comp._state[this._propMin]);
        this._comp._addHook("state", this._propCurMin, ()=>this._compCpy._state[this._propCurMin] = this._comp._state[this._propCurMin]);
        this._comp._addHook("state", this._propMax, ()=>this._compCpy._state[this._propMax] = this._comp._state[this._propMax]);

        if (!this._isSingle)
            this._comp._addHook("state", this._propCurMax, ()=>this._compCpy._state[this._propCurMax] = this._comp._state[this._propCurMax]);

        this._cacheRendered = null;
        this._dispTrackOuter = null;
        this._dispTrackInner = null;
        this._thumbLow = null;
        this._thumbHigh = null;
        this._dragMeta = null;
    }

    $get() {
        const out = this.get();
        return $(out);
    }

    get() {
        this.constructor._init();
        this.constructor._ALL_SLIDERS.add(this);

        if (this._cacheRendered)
            return this._cacheRendered;

        const dispValueLeft = this._isSingle ? this._getSpcSingleValue() : this._getDispValue({
            isVisible: true,
            side: "left"
        });
        const dispValueRight = this._getDispValue({
            isVisible: true,
            side: "right"
        });

        this._dispTrackInner = this._isSingle ? null : e_({
            tag: "div",
            clazz: "ui-slidr__track-inner h-100 absolute",
        });

        this._thumbLow = this._getThumb();
        this._thumbHigh = this._isSingle ? null : this._getThumb();

        this._dispTrackOuter = e_({
            tag: "div",
            clazz: `relative w-100 ui-slidr__track-outer`,
            children: [this._dispTrackInner, this._thumbLow, this._thumbHigh, ].filter(Boolean),
        });

        const wrpTrack = e_({
            tag: "div",
            clazz: `ve-flex-v-center w-100 h-100 ui-slidr__wrp-track clickable`,
            mousedown: evt=>{
                const thumb = this._getClosestThumb(evt);
                this._handleMouseDown(evt, thumb);
            }
            ,
            children: [this._dispTrackOuter, ],
        });

        const wrpTop = e_({
            tag: "div",
            clazz: "ve-flex-v-center w-100 ui-slidr__wrp-top",
            children: [dispValueLeft, wrpTrack, dispValueRight, ].filter(Boolean),
        });

        const wrpPips = e_({
            tag: "div",
            clazz: `w-100 ve-flex relative clickable h-100 ui-slidr__wrp-pips`,
            mousedown: evt=>{
                const thumb = this._getClosestThumb(evt);
                this._handleMouseDown(evt, thumb);
            }
            ,
        });

        const wrpBottom = e_({
            tag: "div",
            clazz: "w-100 ve-flex-vh-center ui-slidr__wrp-bottom",
            children: [this._isSingle ? this._getSpcSingleValue() : this._getDispValue({
                side: "left"
            }), wrpPips, this._getDispValue({
                side: "right"
            }), ].filter(Boolean),
        });

        const hkChangeValue = ()=>{
            const curMin = this._compCpy._state[this._propCurMin];
            const pctMin = this._getLeftPositionPercentage({
                value: curMin
            });
            this._thumbLow.style.left = `calc(${pctMin}% - ${this.constructor._W_THUMB_PX / 2}px)`;
            const toDisplayLeft = this._fnDisplay ? `${this._fnDisplay(curMin)}`.qq() : curMin;
            const toDisplayLeftTooltip = this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMin)}`.qq() : null;
            if (!this._isSingle) {
                dispValueLeft.html(toDisplayLeft).tooltip(toDisplayLeftTooltip);
            }

            if (!this._isSingle) {
                this._dispTrackInner.style.left = `${pctMin}%`;

                const curMax = this._compCpy._state[this._propCurMax];
                const pctMax = this._getLeftPositionPercentage({
                    value: curMax
                });
                this._dispTrackInner.style.right = `${100 - pctMax}%`;
                this._thumbHigh.style.left = `calc(${pctMax}% - ${this.constructor._W_THUMB_PX / 2}px)`;
                dispValueRight.html(this._fnDisplay ? `${this._fnDisplay(curMax)}`.qq() : curMax).tooltip(this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMax)}`.qq() : null);
            } else {
                dispValueRight.html(toDisplayLeft).tooltip(toDisplayLeftTooltip);
            }
        }
        ;

        const hkChangeLimit = ()=>{
            const pips = [];

            if (!this._sparseValues) {
                const numPips = this._compCpy._state[this._propMax] - this._compCpy._state[this._propMin];
                let pipIncrement = 1;
                if (numPips > ComponentUiUtil.RangeSlider._MAX_PIPS)
                    pipIncrement = Math.ceil(numPips / ComponentUiUtil.RangeSlider._MAX_PIPS);

                let i, len;
                for (i = this._compCpy._state[this._propMin],
                len = this._compCpy._state[this._propMax] + 1; i < len; i += pipIncrement) {
                    pips.push(this._getWrpPip({
                        isMajor: i === this._compCpy._state[this._propMin] || i === (len - 1),
                        value: i,
                    }));
                }

                if (i !== this._compCpy._state[this._propMax])
                    pips.push(this._getWrpPip({
                        isMajor: true,
                        value: this._compCpy._state[this._propMax]
                    }));
            } else {
                const len = this._sparseValues.length;
                this._sparseValues.forEach((val,i)=>{
                    pips.push(this._getWrpPip({
                        isMajor: i === 0 || i === (len - 1),
                        value: val,
                    }));
                }
                );
            }

            wrpPips.empty();
            e_({
                ele: wrpPips,
                children: pips,
            });

            hkChangeValue();
        }
        ;

        this._compCpy._addHook("state", this._propMin, hkChangeLimit);
        this._compCpy._addHook("state", this._propMax, hkChangeLimit);
        this._compCpy._addHook("state", this._propCurMin, hkChangeValue);
        if (!this._isSingle)
            this._compCpy._addHook("state", this._propCurMax, hkChangeValue);

        hkChangeLimit();

        const wrp = e_({
            tag: "div",
            clazz: "ve-flex-col w-100 ui-slidr__wrp",
            children: [wrpTop, wrpBottom, ],
        });

        return this._cacheRendered = wrp;
    }

    destroy() {
        this.constructor._ALL_SLIDERS.delete(this);
        if (this._cacheRendered)
            this._cacheRendered.remove();
    }

    _getDispValue({isVisible, side}) {
        return e_({
            tag: "div",
            clazz: `overflow-hidden ui-slidr__disp-value no-shrink no-grow ve-flex-vh-center bold no-select ${isVisible ? `ui-slidr__disp-value--visible` : ""} ui-slidr__disp-value--${side}`,
        });
    }

    _getSpcSingleValue() {
        return e_({
            tag: "div",
            clazz: `px-2`,
        });
    }

    _getThumb() {
        const thumb = e_({
            tag: "div",
            clazz: "ui-slidr__thumb absolute clickable",
            mousedown: evt=>this._handleMouseDown(evt, thumb),
        }).attr("draggable", true);

        return thumb;
    }

    _getWrpPip({isMajor, value}={}) {
        const style = this._getWrpPip_getStyle({
            value
        });

        const pip = e_({
            tag: "div",
            clazz: `ui-slidr__pip ${isMajor ? `ui-slidr__pip--major` : `absolute`}`,
        });

        const dispLabel = e_({
            tag: "div",
            clazz: "absolute ui-slidr__pip-label ve-flex-vh-center ve-small no-wrap",
            html: isMajor ? this._fnDisplay ? `${this._fnDisplay(value)}`.qq() : value : "",
            title: isMajor && this._fnDisplayTooltip ? `${this._fnDisplayTooltip(value)}`.qq() : null,
        });

        return e_({
            tag: "div",
            clazz: "ve-flex-col ve-flex-vh-center absolute no-select",
            children: [pip, dispLabel, ],
            style,
        });
    }

    _getWrpPip_getStyle({value}) {
        return `left: ${this._getLeftPositionPercentage({
            value
        })}%`;
    }

    _getLeftPositionPercentage({value}) {
        if (this._sparseValues) {
            const ix = this._sparseValues.sort(SortUtil.ascSort).indexOf(value);
            if (!~ix)
                throw new Error(`Value "${value}" was not in the list of sparse values!`);
            return (ix / (this._sparseValues.length - 1)) * 100;
        }

        const min = this._compCpy._state[this._propMin];
        const max = this._compCpy._state[this._propMax];
        return ((value - min) / (max - min)) * 100;
    }

    _getRelativeValue(evt, {trackOriginX, trackWidth}) {
        const xEvt = EventUtil.getClientX(evt) - trackOriginX;

        if (this._sparseValues) {
            const ixMax = this._sparseValues.length - 1;
            const rawVal = Math.round((xEvt / trackWidth) * ixMax);
            return this._sparseValues[Math.min(ixMax, Math.max(0, rawVal))];
        }

        const min = this._compCpy._state[this._propMin];
        const max = this._compCpy._state[this._propMax];

        const rawVal = min + Math.round((xEvt / trackWidth) * (max - min), );

        return Math.min(max, Math.max(min, rawVal));
    }

    _getClosestThumb(evt) {
        if (this._isSingle)
            return this._thumbLow;

        const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();
        const value = this._getRelativeValue(evt, {
            trackOriginX,
            trackWidth
        });

        if (value < this._compCpy._state[this._propCurMin])
            return this._thumbLow;
        if (value > this._compCpy._state[this._propCurMax])
            return this._thumbHigh;

        const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);
        if (distToMax < distToMin)
            return this._thumbHigh;
        return this._thumbLow;
    }

    _getDistsToCurrentMinAndMax(value) {
        if (this._isSingle)
            throw new Error(`Can not get distance to max value for singleton slider!`);

        const distToMin = Math.abs(this._compCpy._state[this._propCurMin] - value);
        const distToMax = Math.abs(this._compCpy._state[this._propCurMax] - value);
        return {
            distToMin,
            distToMax
        };
    }

    _handleClick(evt, value) {
        evt.stopPropagation();
        evt.preventDefault();

        if (value < this._compCpy._state[this._propCurMin])
            this._compCpy._state[this._propCurMin] = value;

        if (value > this._compCpy._state[this._propCurMax])
            this._compCpy._state[this._propCurMax] = value;

        const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);

        if (distToMax < distToMin)
            this._compCpy._state[this._propCurMax] = value;
        else
            this._compCpy._state[this._propCurMin] = value;
    }

    _handleMouseDown(evt, thumb) {
        evt.preventDefault();
        evt.stopPropagation();

        const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();

        thumb.addClass(`ui-slidr__thumb--hover`);

        this._dragMeta = {
            trackOriginX,
            trackWidth,
            thumb,
        };

        this._handleMouseMove(evt);
    }

    _handleMouseUp() {
        const wasActive = this._doDragCleanup();

        if (wasActive) {
            const nxtState = {
                [this._propMin]: this._compCpy._state[this._propMin],
                [this._propMax]: this._compCpy._state[this._propMax],
                [this._propCurMin]: this._compCpy._state[this._propCurMin],
            };
            if (!this._isSingle)
                nxtState[this._propCurMax] = this._compCpy._state[this._propCurMax];

            this._comp._proxyAssignSimple("state", nxtState);
        }
    }

    _handleMouseMove(evt) {
        if (!this._dragMeta)
            return;

        const val = this._getRelativeValue(evt, this._dragMeta);

        if (this._dragMeta.thumb === this._thumbLow) {
            if (val > this._compCpy._state[this._propCurMax])
                return;
            this._compCpy._state[this._propCurMin] = val;
        } else if (this._dragMeta.thumb === this._thumbHigh) {
            if (val < this._compCpy._state[this._propCurMin])
                return;
            this._compCpy._state[this._propCurMax] = val;
        }
    }

    _doDragCleanup() {
        const isActive = this._dragMeta != null;

        if (this._dragMeta?.thumb)
            this._dragMeta.thumb.removeClass(`ui-slidr__thumb--hover`);

        this._dragMeta = null;

        return isActive;
    }

    static _init() {
        if (this._isInit)
            return;
        document.addEventListener("mousemove", evt=>{
            for (const slider of this._ALL_SLIDERS) {
                slider._handleMouseMove(evt);
            }
        }
        );

        document.addEventListener("mouseup", evt=>{
            for (const slider of this._ALL_SLIDERS) {
                slider._handleMouseUp(evt);
            }
        }
        );
    }
}
;
ComponentUiUtil.RangeSlider._isInit = false;
ComponentUiUtil.RangeSlider._ALL_SLIDERS = new Set();
ComponentUiUtil.RangeSlider._W_THUMB_PX = 16;
ComponentUiUtil.RangeSlider._W_LABEL_PX = 24;
ComponentUiUtil.RangeSlider._MAX_PIPS = 40;
//#endregion

//#region FilterBox
//TEMP ProxyBase seems to just be a MixedProxyBase
class FilterBox extends ProxyBase
//extends ProxyBase
{
    static TITLE_BTN_RESET = "Reset filters. SHIFT to reset everything.";

    static selectFirstVisible(entryList) {
        if (Hist.lastLoadedId == null && !Hist.initialLoad) {
            Hist._freshLoad();
        }

    }

    constructor(opts) {
        super();

        this._$iptSearch = opts.$iptSearch;
        this._$wrpFormTop = opts.$wrpFormTop;
        this._$btnReset = opts.$btnReset;
        this._$btnOpen = opts.$btnOpen;
        this._$wrpMiniPills = opts.$wrpMiniPills;
        this._$btnToggleSummaryHidden = opts.$btnToggleSummaryHidden;
        this._filters = opts.filters;
        this._isCompact = opts.isCompact;
        this._namespace = opts.namespace;

        this._doSaveStateThrottled = MiscUtil.throttle(()=>this._pDoSaveState(), 50);
        this.__meta = this._getDefaultMeta();
        if (this._isCompact)
            this.__meta.isSummaryHidden = true;

        this._meta = this._getProxy("meta", this.__meta);
        this.__minisHidden = {};
        this._minisHidden = this._getProxy("minisHidden", this.__minisHidden);
        this.__combineAs = {};
        this._combineAs = this._getProxy("combineAs", this.__combineAs);
        this._modalMeta = null;
        this._isRendered = false;

        this._cachedState = null;

        this._compSearch = BaseComponent.fromObject({
            search: ""
        });
        this._metaIptSearch = null;

        this._filters.forEach(f=>f.filterBox = this);

        this._eventListeners = {};
    }

    get filters() {
        return this._filters;
    }

    teardown() {
        this._filters.forEach(f=>f._doTeardown());
        if (this._modalMeta)
            this._modalMeta.doTeardown();
    }

    on(identifier, fn) {
        const [eventName,namespace] = identifier.split(".");
        (this._eventListeners[eventName] = this._eventListeners[eventName] || []).push({
            namespace,
            fn
        });
        return this;
    }

    off(identifier, fn=null) {
        const [eventName,namespace] = identifier.split(".");
        this._eventListeners[eventName] = (this._eventListeners[eventName] || []).filter(it=>{
            if (fn != null)
                return it.namespace !== namespace || it.fn !== fn;
            return it.namespace !== namespace;
        }
        );
        if (!this._eventListeners[eventName].length)
            delete this._eventListeners[eventName];
        return this;
    }

    fireChangeEvent() {
        this._doSaveStateThrottled();
        this.fireEvent(FilterBox.EVNT_VALCHANGE);
    }

    fireEvent(eventName) {
        (this._eventListeners[eventName] || []).forEach(it=>it.fn());
    }

    _getNamespacedStorageKey() {
        return `${FilterBox._STORAGE_KEY}${this._namespace ? `.${this._namespace}` : ""}`;
    }
    getNamespacedHashKey(k) {
        return `${k || "_".repeat(FilterUtil.SUB_HASH_PREFIX_LENGTH)}${this._namespace ? `.${this._namespace}` : ""}`;
    }

    async pGetStoredActiveSources() {
        const stored = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
        if (stored) {
            const sourceFilterData = stored.filters[FilterBox.SOURCE_HEADER];
            if (sourceFilterData) {
                const state = sourceFilterData.state;
                const blue = [];
                const white = [];
                Object.entries(state).forEach(([src,mode])=>{
                    if (mode === 1)
                        blue.push(src);
                    else if (mode !== -1)
                        white.push(src);
                }
                );
                if (blue.length)
                    return blue;
                else
                    return white;
            }
        }
        return null;
    }

    registerMinisHiddenHook(prop, hook) {
        this._addHook("minisHidden", prop, hook);
    }

    isMinisHidden(header) {
        return !!this._minisHidden[header];
    }

    async pDoLoadState() {
        const toLoad = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
        if (toLoad == null)
            return;
        this._setStateFromLoaded(toLoad, {
            isUserSavedState: true
        });
    }

    _setStateFromLoaded(state, {isUserSavedState=false}={}) {
        state.box = state.box || {};
        this._proxyAssign("meta", "_meta", "__meta", state.box.meta || {}, true);
        this._proxyAssign("minisHidden", "_minisHidden", "__minisHidden", state.box.minisHidden || {}, true);
        this._proxyAssign("combineAs", "_combineAs", "__combineAs", state.box.combineAs || {}, true);
        this._filters.forEach(it=>it.setStateFromLoaded(state.filters, {
            isUserSavedState
        }));
    }

    _getSaveableState() {
        const filterOut = {};
        this._filters.forEach(it=>Object.assign(filterOut, it.getSaveableState()));
        return {
            box: {
                meta: {
                    ...this.__meta
                },
                minisHidden: {
                    ...this.__minisHidden
                },
                combineAs: {
                    ...this.__combineAs
                },
            },
            filters: filterOut,
        };
    }

    async _pDoSaveState() {
        await StorageUtil.pSetForPage(this._getNamespacedStorageKey(), this._getSaveableState());
    }

    trimState_() {
        this._filters.forEach(f=>f.trimState_());
    }

    render() {
        if (this._isRendered) {
            this._filters.map(f=>f.update());
            return;
        }
        this._isRendered = true;

        if (this._$wrpFormTop || this._$wrpMiniPills) {
            if (!this._$wrpMiniPills) {
                this._$wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`).insertAfter(this._$wrpFormTop);
            } else {
                this._$wrpMiniPills.addClass("fltr__mini-view");
            }
        }

        if (this._$btnReset) {
            this._$btnReset.title(FilterBox.TITLE_BTN_RESET).click((evt)=>this.reset(evt.shiftKey));
        }

        if (this._$wrpFormTop || this._$btnToggleSummaryHidden) {
            if (!this._$btnToggleSummaryHidden) {
                this._$btnToggleSummaryHidden = $(`<button class="btn btn-default ${this._isCompact ? "p-2" : ""}" title="Toggle Filter Summary"><span class="glyphicon glyphicon-resize-small"></span></button>`).prependTo(this._$wrpFormTop);
            } else if (!this._$btnToggleSummaryHidden.parent().length) {
                this._$btnToggleSummaryHidden.prependTo(this._$wrpFormTop);
            }
            this._$btnToggleSummaryHidden.click(()=>{
                this._meta.isSummaryHidden = !this._meta.isSummaryHidden;
                this._doSaveStateThrottled();
            }
            );
            const summaryHiddenHook = ()=>{
                this._$btnToggleSummaryHidden.toggleClass("active", !!this._meta.isSummaryHidden);
                this._$wrpMiniPills.toggleClass("ve-hidden", !!this._meta.isSummaryHidden);
            }
            ;
            this._addHook("meta", "isSummaryHidden", summaryHiddenHook);
            summaryHiddenHook();
        }

        if (this._$wrpFormTop || this._$btnOpen) {
            if (!this._$btnOpen) {
                this._$btnOpen = $(`<button class="btn btn-default ${this._isCompact ? "px-2" : ""}">Filter</button>`).prependTo(this._$wrpFormTop);
            } else if (!this._$btnOpen.parent().length) {
                this._$btnOpen.prependTo(this._$wrpFormTop);
            }
            this._$btnOpen.click(()=>this.show());
        }

        const sourceFilter = this._filters.find(it=>it.header === FilterBox.SOURCE_HEADER);
        if (sourceFilter) {
            const selFnAlt = (val)=>!SourceUtil.isNonstandardSource(val) && !PrereleaseUtil.hasSourceJson(val) && !BrewUtil2.hasSourceJson(val);
            const hkSelFn = ()=>{
                if (this._meta.isBrewDefaultHidden)
                    sourceFilter.setTempFnSel(selFnAlt);
                else
                    sourceFilter.setTempFnSel(null);
                sourceFilter.updateMiniPillClasses();
            }
            ;
            this._addHook("meta", "isBrewDefaultHidden", hkSelFn);
            hkSelFn();
        }

        if (this._$wrpMiniPills)
            this._filters.map((f,i)=>f.$renderMinis({
                filterBox: this,
                isFirst: i === 0,
                $wrpMini: this._$wrpMiniPills
            }));
    }

    async _render_pRenderModal() {
        this._isModalRendered = true;

        this._modalMeta = await UiUtil.pGetShowModal({
            isHeight100: true,
            isWidth100: true,
            isUncappedHeight: true,
            isIndestructible: true,
            isClosed: true,
            isEmpty: true,
            title: "Filter",
            cbClose: (isDataEntered)=>this._pHandleHide(!isDataEntered),
        });

        const $children = this._filters.map((f,i)=>f.$render({
            filterBox: this,
            isFirst: i === 0,
            $wrpMini: this._$wrpMiniPills
        }));

        this._metaIptSearch = ComponentUiUtil.$getIptStr(this._compSearch, "search", {
            decorationRight: "clear",
            asMeta: true,
            html: `<input class="form-control input-xs" placeholder="Search...">`
        }, );
        this._compSearch._addHookBase("search", ()=>{
            const searchTerm = this._compSearch._state.search.toLowerCase();
            this._filters.forEach(f=>f.handleSearch(searchTerm));
        }
        );

        const $btnShowAllFilters = $(`<button class="btn btn-xs btn-default">Show All</button>`).click(()=>this.showAllFilters());
        const $btnHideAllFilters = $(`<button class="btn btn-xs btn-default">Hide All</button>`).click(()=>this.hideAllFilters());

        const $btnReset = $(`<button class="btn btn-xs btn-default mr-3" title="${FilterBox.TITLE_BTN_RESET}">Reset</button>`).click(evt=>this.reset(evt.shiftKey));

        const $btnSettings = $(`<button class="btn btn-xs btn-default mr-3"><span class="glyphicon glyphicon-cog"></span></button>`).click(()=>this._pOpenSettingsModal());

        const $btnSaveAlt = $(`<button class="btn btn-xs btn-primary" title="Save"><span class="glyphicon glyphicon-ok"></span></button>`).click(()=>this._modalMeta.doClose(true));

        const $wrpBtnCombineFilters = $(`<div class="btn-group mr-3"></div>`);
        const $btnCombineFilterSettings = $(`<button class="btn btn-xs btn-default"><span class="glyphicon glyphicon-cog"></span></button>`).click(()=>this._pOpenCombineAsModal());

        const btnCombineFiltersAs = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default`,
            click: ()=>this._meta.modeCombineFilters = FilterBox._COMBINE_MODES.getNext(this._meta.modeCombineFilters),
            title: `"AND" requires every filter to match. "OR" requires any filter to match. "Custom" allows you to specify a combination (every "AND" filter must match; only one "OR" filter must match) .`,
        }).appendTo($wrpBtnCombineFilters[0]);

        const hook = ()=>{
            btnCombineFiltersAs.innerText = this._meta.modeCombineFilters === "custom" ? this._meta.modeCombineFilters.uppercaseFirst() : this._meta.modeCombineFilters.toUpperCase();
            if (this._meta.modeCombineFilters === "custom")
                $wrpBtnCombineFilters.append($btnCombineFilterSettings);
            else
                $btnCombineFilterSettings.detach();
            this._doSaveStateThrottled();
        }
        ;
        this._addHook("meta", "modeCombineFilters", hook);
        hook();

        const $btnSave = $(`<button class="btn btn-primary fltr__btn-close mr-2">Save</button>`).click(()=>this._modalMeta.doClose(true));

        const $btnCancel = $(`<button class="btn btn-default fltr__btn-close">Cancel</button>`).click(()=>this._modalMeta.doClose(false));

        $$(this._modalMeta.$modal)`<div class="split mb-2 mt-2 ve-flex-v-center mobile__ve-flex-col">
			<div class="ve-flex-v-baseline mobile__ve-flex-col">
				<h4 class="m-0 mr-2 mobile__mb-2">Filters</h4>
				${this._metaIptSearch.$wrp.addClass("mobile__mb-2")}
			</div>
			<div class="ve-flex-v-center mobile__ve-flex-col">
				<div class="ve-flex-v-center mobile__m-1">
					<div class="mr-2">Combine as</div>
					${$wrpBtnCombineFilters}
				</div>
				<div class="ve-flex-v-center mobile__m-1">
					<div class="btn-group mr-2 ve-flex-h-center">
						${$btnShowAllFilters}
						${$btnHideAllFilters}
					</div>
					${$btnReset}
					${$btnSettings}
					${$btnSaveAlt}
				</div>
			</div>
		</div>
		<hr class="w-100 m-0 mb-2">

		<hr class="mt-1 mb-1">
		<div class="ui-modal__scroller smooth-scroll px-1">
			${$children}
		</div>
		<hr class="my-1 w-100">
		<div class="w-100 ve-flex-vh-center my-1">${$btnSave}${$btnCancel}</div>`;
    }

    async _pOpenSettingsModal() {
        const {$modalInner} = await UiUtil.pGetShowModal({
            title: "Settings"
        });

        UiUtil.$getAddModalRowCb($modalInner, "Deselect Homebrew Sources by Default", this._meta, "isBrewDefaultHidden");

        UiUtil.addModalSep($modalInner);

        UiUtil.$getAddModalRowHeader($modalInner, "Hide summary for filter...", {
            helpText: "The summary is the small red and blue button panel which appear below the search bar."
        });
        this._filters.forEach(f=>UiUtil.$getAddModalRowCb($modalInner, f.header, this._minisHidden, f.header));

        UiUtil.addModalSep($modalInner);

        const $rowResetAlwaysSave = UiUtil.$getAddModalRow($modalInner, "div").addClass("pr-2");
        $rowResetAlwaysSave.append(`<span>Always Save on Close</span>`);
        $(`<button class="btn btn-xs btn-default">Reset</button>`).appendTo($rowResetAlwaysSave).click(async()=>{
            await StorageUtil.pRemove(FilterBox._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED);
            JqueryUtil.doToast("Saved!");
        }
        );
    }

    async _pOpenCombineAsModal() {
        const {$modalInner} = await UiUtil.pGetShowModal({
            title: "Filter Combination Logic"
        });
        const $btnReset = $(`<button class="btn btn-xs btn-default">Reset</button>`).click(()=>{
            Object.keys(this._combineAs).forEach(k=>this._combineAs[k] = "and");
            $sels.forEach($sel=>$sel.val("0"));
        }
        );
        UiUtil.$getAddModalRowHeader($modalInner, "Combine filters as...", {
            $eleRhs: $btnReset
        });
        const $sels = this._filters.map(f=>UiUtil.$getAddModalRowSel($modalInner, f.header, this._combineAs, f.header, ["and", "or"], {
            fnDisplay: (it)=>it.toUpperCase()
        }));
    }

    getValues({nxtStateOuter=null}={}) {
        const outObj = {};
        this._filters.forEach(f=>Object.assign(outObj, f.getValues({
            nxtState: nxtStateOuter?.filters
        })));
        return outObj;
    }

    addEventListener(type, listener) {
        (this._$wrpFormTop ? this._$wrpFormTop[0] : this._$btnOpen[0]).addEventListener(type, listener);
    }

    _mutNextState_reset_meta({tgt}) {
        Object.assign(tgt, this._getDefaultMeta());
    }

    _mutNextState_minisHidden({tgt}) {
        Object.assign(tgt, this._getDefaultMinisHidden(tgt));
    }

    _mutNextState_combineAs({tgt}) {
        Object.assign(tgt, this._getDefaultCombineAs(tgt));
    }

    _reset_meta() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_reset_meta({
            tgt: nxtBoxState.meta
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    _reset_minisHidden() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_minisHidden({
            tgt: nxtBoxState.minisHidden
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    _reset_combineAs() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_combineAs({
            tgt: nxtBoxState.combineAs
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    reset(isResetAll) {
        this._filters.forEach(f=>f.reset({
            isResetAll
        }));
        if (isResetAll) {
            this._reset_meta();
            this._reset_minisHidden();
            this._reset_combineAs();
        }
        this.render();
        this.fireChangeEvent();
    }

    async show() {
        if (!this._isModalRendered)
            await this._render_pRenderModal();
        this._cachedState = this._getSaveableState();
        this._modalMeta.doOpen();
        if (this._metaIptSearch?.$ipt)
            this._metaIptSearch.$ipt.focus();
    }

    async _pHandleHide(isCancel=false) {
        if (this._cachedState && isCancel) {
            const curState = this._getSaveableState();
            const hasChanges = !CollectionUtil.deepEquals(curState, this._cachedState);

            if (hasChanges) {
                const isSave = await InputUiUtil.pGetUserBoolean({
                    title: "Unsaved Changes",
                    textYesRemember: "Always Save",
                    textYes: "Save",
                    textNo: "Discard",
                    storageKey: FilterBox._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED,
                    isGlobal: true,
                });
                if (isSave) {
                    this._cachedState = null;
                    this.fireChangeEvent();
                    return;
                } else
                    this._setStateFromLoaded(this._cachedState, {
                        isUserSavedState: true
                    });
            }
        } else {
            this.fireChangeEvent();
        }

        this._cachedState = null;
    }

    showAllFilters() {
        this._filters.forEach(f=>f.show());
    }

    hideAllFilters() {
        this._filters.forEach(f=>f.hide());
    }

    unpackSubHashes(subHashes, {force=false}={}) {
        const unpacked = {};
        subHashes.forEach(s=>{
            const unpackedPart = UrlUtil.unpackSubHash(s, true);
            if (Object.keys(unpackedPart).length > 1)
                throw new Error(`Multiple keys in subhash!`);
            const k = Object.keys(unpackedPart)[0];
            unpackedPart[k] = {
                clean: unpackedPart[k],
                raw: s
            };
            Object.assign(unpacked, unpackedPart);
        }
        );

        const urlHeaderToFilter = {};
        this._filters.forEach(f=>{
            const childFilters = f.getChildFilters();
            if (childFilters.length)
                childFilters.forEach(f=>urlHeaderToFilter[f.header.toLowerCase()] = f);
            urlHeaderToFilter[f.header.toLowerCase()] = f;
        }
        );

        const urlHeadersUpdated = new Set();
        const subHashesConsumed = new Set();
        let filterInitialSearch;

        const filterBoxState = {};
        const statePerFilter = {};
        const prefixLen = this.getNamespacedHashKey().length;
        Object.entries(unpacked).forEach(([hashKey,data])=>{
            const rawPrefix = hashKey.substring(0, prefixLen);
            const prefix = rawPrefix.substring(0, FilterUtil.SUB_HASH_PREFIX_LENGTH);

            const urlHeader = hashKey.substring(prefixLen);

            if (FilterUtil.SUB_HASH_PREFIXES.has(prefix) && urlHeaderToFilter[urlHeader]) {
                (statePerFilter[urlHeader] = statePerFilter[urlHeader] || {})[prefix] = data.clean;
                urlHeadersUpdated.add(urlHeader);
                subHashesConsumed.add(data.raw);
                return;
            }

            if (Object.values(FilterBox._SUB_HASH_PREFIXES).includes(prefix)) {
                if (prefix === VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX)
                    filterInitialSearch = data.clean[0];
                else
                    filterBoxState[prefix] = data.clean;
                subHashesConsumed.add(data.raw);
                return;
            }

            if (FilterUtil.SUB_HASH_PREFIXES.has(prefix))
                throw new Error(`Could not find filter with header ${urlHeader} for subhash ${data.raw}`);
        }
        );

        if (!subHashesConsumed.size && !force)
            return null;

        return {
            urlHeaderToFilter,
            filterBoxState,
            statePerFilter,
            urlHeadersUpdated,
            unpacked,
            subHashesConsumed,
            filterInitialSearch,
        };
    }

    setFromSubHashes(subHashes, {force=false, $iptSearch=null}={}) {
        const unpackedSubhashes = this.unpackSubHashes(subHashes, {
            force
        });

        if (unpackedSubhashes == null)
            return subHashes;

        const {unpacked, subHashesConsumed, filterInitialSearch, } = unpackedSubhashes;

        const {box: nxtStateBox, filters: nxtStatesFilters} = this.getNextStateFromSubHashes({
            unpackedSubhashes
        });

        this._setBoxStateFromNextBoxState(nxtStateBox);

        this._filters.flatMap(f=>[f, ...f.getChildFilters(), ]).filter(filter=>nxtStatesFilters[filter.header]).forEach(filter=>filter.setStateFromNextState(nxtStatesFilters));

        if (filterInitialSearch && ($iptSearch || this._$iptSearch))
            ($iptSearch || this._$iptSearch).val(filterInitialSearch).change().keydown().keyup().trigger("instantKeyup");

        const [link] = Hist.getHashParts();

        const outSub = [];
        Object.values(unpacked).filter(v=>!subHashesConsumed.has(v.raw)).forEach(v=>outSub.push(v.raw));

        Hist.setSuppressHistory(true);
        Hist.replaceHistoryHash(`${link}${outSub.length ? `${HASH_PART_SEP}${outSub.join(HASH_PART_SEP)}` : ""}`);

        this.fireChangeEvent();
        Hist.hashChange({
            isBlankFilterLoad: true
        });
        return outSub;
    }

    getNextStateFromSubHashes({unpackedSubhashes}) {
        const {urlHeaderToFilter, filterBoxState, statePerFilter, urlHeadersUpdated, } = unpackedSubhashes;

        const nxtStateBox = this._getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState);

        const nxtStateFilters = {};

        Object.entries(statePerFilter).forEach(([urlHeader,state])=>{
            const filter = urlHeaderToFilter[urlHeader];
            Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(state));
        }
        );

        Object.keys(urlHeaderToFilter).filter(k=>!urlHeadersUpdated.has(k)).forEach(k=>{
            const filter = urlHeaderToFilter[k];
            Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(null));
        }
        );

        return {
            box: nxtStateBox,
            filters: nxtStateFilters
        };
    }

    _getNextBoxState_base() {
        return {
            meta: MiscUtil.copyFast(this.__meta),
            minisHidden: MiscUtil.copyFast(this.__minisHidden),
            combineAs: MiscUtil.copyFast(this.__combineAs),
        };
    }

    _getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState) {
        const nxtBoxState = this._getNextBoxState_base();

        let hasMeta = false;
        let hasMinisHidden = false;
        let hasCombineAs = false;

        Object.entries(filterBoxState).forEach(([k,vals])=>{
            const mappedK = this.getNamespacedHashKey(Parser._parse_bToA(FilterBox._SUB_HASH_PREFIXES, k));
            switch (mappedK) {
            case "meta":
                {
                    hasMeta = true;
                    const data = vals.map(v=>UrlUtil.mini.decompress(v));
                    Object.keys(this._getDefaultMeta()).forEach((k,i)=>nxtBoxState.meta[k] = data[i]);
                    break;
                }
            case "minisHidden":
                {
                    hasMinisHidden = true;
                    Object.keys(nxtBoxState.minisHidden).forEach(k=>nxtBoxState.minisHidden[k] = false);
                    vals.forEach(v=>{
                        const [urlHeader,isHidden] = v.split("=");
                        const filter = urlHeaderToFilter[urlHeader];
                        if (!filter)
                            throw new Error(`Could not find filter with name "${urlHeader}"`);
                        nxtBoxState.minisHidden[filter.header] = !!Number(isHidden);
                    }
                    );
                    break;
                }
            case "combineAs":
                {
                    hasCombineAs = true;
                    Object.keys(nxtBoxState.combineAs).forEach(k=>nxtBoxState.combineAs[k] = "and");
                    vals.forEach(v=>{
                        const [urlHeader,ixCombineMode] = v.split("=");
                        const filter = urlHeaderToFilter[urlHeader];
                        if (!filter)
                            throw new Error(`Could not find filter with name "${urlHeader}"`);
                        nxtBoxState.combineAs[filter.header] = FilterBox._COMBINE_MODES[ixCombineMode] || FilterBox._COMBINE_MODES[0];
                    }
                    );
                    break;
                }
            }
        }
        );

        if (!hasMeta)
            this._mutNextState_reset_meta({
                tgt: nxtBoxState.meta
            });
        if (!hasMinisHidden)
            this._mutNextState_minisHidden({
                tgt: nxtBoxState.minisHidden
            });
        if (!hasCombineAs)
            this._mutNextState_combineAs({
                tgt: nxtBoxState.combineAs
            });

        return nxtBoxState;
    }

    _setBoxStateFromNextBoxState(nxtBoxState) {
        this._proxyAssignSimple("meta", nxtBoxState.meta, true);
        this._proxyAssignSimple("minisHidden", nxtBoxState.minisHidden, true);
        this._proxyAssignSimple("combineAs", nxtBoxState.combineAs, true);
    }

    getSubHashes(opts) {
        opts = opts || {};
        const out = [];
        const boxSubHashes = this.getBoxSubHashes();
        if (boxSubHashes)
            out.push(boxSubHashes);
        out.push(...this._filters.map(f=>f.getSubHashes()).filter(Boolean));
        if (opts.isAddSearchTerm && this._$iptSearch) {
            const searchTerm = UrlUtil.encodeForHash(this._$iptSearch.val().trim());
            if (searchTerm)
                out.push(UrlUtil.packSubHash(this._getSubhashPrefix("search"), [searchTerm]));
        }
        return out.flat();
    }

    getBoxSubHashes() {
        const out = [];

        const defaultMeta = this._getDefaultMeta();

        const anyNotDefault = Object.keys(defaultMeta).find(k=>this._meta[k] !== defaultMeta[k]);
        if (anyNotDefault) {
            const serMeta = Object.keys(defaultMeta).map(k=>UrlUtil.mini.compress(this._meta[k] === undefined ? defaultMeta[k] : this._meta[k]));
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("meta"), serMeta));
        }

        const setMinisHidden = Object.entries(this._minisHidden).filter(([k,v])=>!!v).map(([k])=>`${k.toUrlified()}=1`);
        if (setMinisHidden.length) {
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("minisHidden"), setMinisHidden));
        }

        const setCombineAs = Object.entries(this._combineAs).filter(([k,v])=>v !== FilterBox._COMBINE_MODES[0]).map(([k,v])=>`${k.toUrlified()}=${FilterBox._COMBINE_MODES.indexOf(v)}`);
        if (setCombineAs.length) {
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("combineAs"), setCombineAs));
        }

        return out.length ? out : null;
    }

    getFilterTag({isAddSearchTerm=false}={}) {
        const parts = this._filters.map(f=>f.getFilterTagPart()).filter(Boolean);
        if (isAddSearchTerm && this._$iptSearch) {
            const term = this._$iptSearch.val().trim();
            if (term)
                parts.push(`search=${term}`);
        }
        return `{@filter |${UrlUtil.getCurrentPage().replace(/\.html$/, "")}|${parts.join("|")}}`;
    }

    getDisplayState({nxtStateOuter=null}={}) {
        return this._filters.map(filter=>filter.getDisplayStatePart({
            nxtState: nxtStateOuter?.filters
        })).filter(Boolean).join("; ");
    }

    setFromValues(values) {
        this._filters.forEach(it=>it.setFromValues(values));
        this.fireChangeEvent();
    }

    toDisplay(boxState, ...entryVals) {
        return this._toDisplay(boxState, this._filters, entryVals);
    }

    toDisplayByFilters(boxState, ...filterToValueTuples) {
        return this._toDisplay(boxState, filterToValueTuples.map(it=>it.filter), filterToValueTuples.map(it=>it.value), );
    }

    _toDisplay(boxState, filters, entryVals) {
        switch (this._meta.modeCombineFilters) {
        case "and":
            return this._toDisplay_isAndDisplay(boxState, filters, entryVals);
        case "or":
            return this._toDisplay_isOrDisplay(boxState, filters, entryVals);
        case "custom":
            {
                if (entryVals.length !== filters.length)
                    throw new Error(`Number of filters and number of values did not match!`);

                const andFilters = [];
                const andValues = [];
                const orFilters = [];
                const orValues = [];

                for (let i = 0; i < filters.length; ++i) {
                    const f = filters[i];
                    if (!this._combineAs[f.header] || this._combineAs[f.header] === "and") {
                        andFilters.push(f);
                        andValues.push(entryVals[i]);
                    } else {
                        orFilters.push(f);
                        orValues.push(entryVals[i]);
                    }
                }

                return this._toDisplay_isAndDisplay(boxState, andFilters, andValues) && this._toDisplay_isOrDisplay(boxState, orFilters, orValues);
            }
        default:
            throw new Error(`Unhandled combining mode "${this._meta.modeCombineFilters}"`);
        }
    }

    _toDisplay_isAndDisplay(boxState, filters, vals) {
        return filters.map((f,i)=>f.toDisplay(boxState, vals[i])).every(it=>it);
    }

    _toDisplay_isOrDisplay(boxState, filters, vals) {
        const res = filters.map((f,i)=>{
            if (!f.isActive(boxState))
                return null;
            return f.toDisplay(boxState, vals[i]);
        }
        ).filter(it=>it != null);
        return res.length === 0 || res.find(it=>it);
    }

    _getSubhashPrefix(prop) {
        if (FilterBox._SUB_HASH_PREFIXES[prop])
            return this.getNamespacedHashKey(FilterBox._SUB_HASH_PREFIXES[prop]);
        throw new Error(`Unknown property "${prop}"`);
    }

    _getDefaultMeta() {
        const out = MiscUtil.copy(FilterBox._DEFAULT_META);
        if (this._isCompact)
            out.isSummaryHidden = true;
        return out;
    }

    _getDefaultMinisHidden(minisHidden) {
        if (!minisHidden)
            throw new Error(`Missing "minisHidden" argument!`);
        return Object.keys(minisHidden).mergeMap(k=>({
            [k]: false
        }));
    }

    _getDefaultCombineAs(combineAs) {
        if (!combineAs)
            throw new Error(`Missing "combineAs" argument!`);
        return Object.keys(combineAs).mergeMap(k=>({
            [k]: "and"
        }));
    }
}
;
FilterBox.EVNT_VALCHANGE = "valchange";
FilterBox.SOURCE_HEADER = "Source";
FilterBox._PILL_STATES = ["ignore", "yes", "no"];
FilterBox._COMBINE_MODES = ["and", "or", "custom"];
FilterBox._STORAGE_KEY = "filterBoxState";
FilterBox._DEFAULT_META = {
    modeCombineFilters: "and",
    isSummaryHidden: false,
    isBrewDefaultHidden: false,
};
FilterBox._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED = "filterAlwaysSaveUnchanged";

FilterBox._SUB_HASH_BOX_META_PREFIX = "fbmt";
FilterBox._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX = "fbmh";
FilterBox._SUB_HASH_BOX_COMBINE_AS_PREFIX = "fbca";
FilterBox._SUB_HASH_PREFIXES = {
    meta: FilterBox._SUB_HASH_BOX_META_PREFIX,
    minisHidden: FilterBox._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX,
    combineAs: FilterBox._SUB_HASH_BOX_COMBINE_AS_PREFIX,
    search: VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX,
};
//#endregion

//#region ContentGetter
class ContentGetter{
    static _getBase(){
        

        const class_barbarian = String.raw`{
        "class": [
            {
                "name": "Barbarian",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "hd": {
                    "number": 1,
                    "faces": 12
                },
                "proficiency": [
                    "str",
                    "con"
                ],
                "startingProficiencies": {
                    "armor": [
                        "light",
                        "medium",
                        "{@item shield|phb|shields}"
                    ],
                    "weapons": [
                        "simple",
                        "martial"
                    ],
                    "skills": [
                        {
                            "choose": {
                                "from": [
                                    "animal handling",
                                    "athletics",
                                    "intimidation",
                                    "nature",
                                    "perception",
                                    "survival"
                                ],
                                "count": 2
                            }
                        }
                    ]
                },
                "startingEquipment": {
                    "additionalFromBackground": true,
                    "default": [
                        "(a) a {@item greataxe|phb} or (b) any {@filter martial melee weapon|items|source=phb|category=basic|type=martial weapon;melee weapon=u~u~sand}",
                        "(a) two {@item handaxe|phb|handaxes} or (b) any {@filter simple weapon|items|source=phb|category=basic|type=simple weapon}",
                        "An {@item explorer's pack|phb}, and four {@item javelin|phb|javelins}"
                    ],
                    "goldAlternative": "{@dice 2d4 × 10|2d4 × 10|Starting Gold}",
                    "defaultData": [
                        {
                            "a": [
                                "greataxe|phb"
                            ],
                            "b": [
                                {
                                    "equipmentType": "weaponMartialMelee"
                                }
                            ]
                        },
                        {
                            "a": [
                                {
                                    "item": "handaxe|phb",
                                    "quantity": 2
                                }
                            ],
                            "b": [
                                {
                                    "equipmentType": "weaponSimple"
                                }
                            ]
                        },
                        {
                            "_": [
                                "explorer's pack|phb",
                                {
                                    "item": "javelin|phb",
                                    "quantity": 4
                                }
                            ]
                        }
                    ]
                },
                "multiclassing": {
                    "requirements": {
                        "str": 13
                    },
                    "proficienciesGained": {
                        "armor": [
                            "{@item shield|phb|shields}"
                        ],
                        "weapons": [
                            "simple",
                            "martial"
                        ]
                    }
                },
                "classTableGroups": [
                    {
                        "colLabels": [
                            "Rages",
                            "Rage Damage"
                        ],
                        "rows": [
                            [
                                "2",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "2",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "3",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "3",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "3",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "5",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "5",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "5",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "5",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "5",
                                {
                                    "type": "bonus",
                                    "value": 4
                                }
                            ],
                            [
                                "6",
                                {
                                    "type": "bonus",
                                    "value": 4
                                }
                            ],
                            [
                                "6",
                                {
                                    "type": "bonus",
                                    "value": 4
                                }
                            ],
                            [
                                "6",
                                {
                                    "type": "bonus",
                                    "value": 4
                                }
                            ],
                            [
                                "Unlimited",
                                {
                                    "type": "bonus",
                                    "value": 4
                                }
                            ]
                        ]
                    }
                ],
                "classFeatures": [
                    "Rage|Barbarian||1",
                    "Unarmored Defense|Barbarian||1",
                    "Danger Sense|Barbarian||2",
                    "Reckless Attack|Barbarian||2",
                    {
                        "classFeature": "Primal Path|Barbarian||3",
                        "gainSubclassFeature": true
                    },
                    "Primal Knowledge|Barbarian||3|TCE",
                    "Ability Score Improvement|Barbarian||4",
                    "Extra Attack|Barbarian||5",
                    "Fast Movement|Barbarian||5",
                    {
                        "classFeature": "Path Feature|Barbarian||6",
                        "gainSubclassFeature": true
                    },
                    "Feral Instinct|Barbarian||7",
                    "Instinctive Pounce|Barbarian||7|TCE",
                    "Ability Score Improvement|Barbarian||8",
                    "Brutal Critical (1 die)|Barbarian||9",
                    {
                        "classFeature": "Path feature|Barbarian||10",
                        "gainSubclassFeature": true
                    },
                    "Relentless Rage|Barbarian||11",
                    "Ability Score Improvement|Barbarian||12",
                    "Brutal Critical (2 dice)|Barbarian||13",
                    {
                        "classFeature": "Path feature|Barbarian||14",
                        "gainSubclassFeature": true
                    },
                    "Persistent Rage|Barbarian||15",
                    "Ability Score Improvement|Barbarian||16",
                    "Brutal Critical (3 dice)|Barbarian||17",
                    "Indomitable Might|Barbarian||18",
                    "Ability Score Improvement|Barbarian||19",
                    "Primal Champion|Barbarian||20"
                ],
                "subclassTitle": "Primal Path",
                "fluff": [
                    {
                        "name": "Barbarian",
                        "type": "section",
                        "entries": [
                            "A tall human tribesman strides through a blizzard, draped in fur and hefting his axe. He laughs as he charges toward the frost giant who dared poach his people's elk herd.",
                            "A half-orc snarls at the latest challenger to her authority over their savage tribe, ready to break his neck with her bare hands as she did to the last six rivals.",
                            "Frothing at the mouth, a dwarf slams his helmet into the face of his drow foe, then turns to drive his armored elbow into the gut of another.",
                            "These barbarians, different as they might be, are defined by their rage: unbridled, unquenchable, and unthinking fury. More than a mere emotion, their anger is the ferocity of a cornered predator, the unrelenting assault of a storm, the churning turmoil of the sea.",
                            "For some, their rage springs from a communion with fierce animal spirits. Others draw from a roiling reservoir of anger at a world full of pain. For every barbarian, rage is a power that fuels not just a battle frenzy but also uncanny reflexes, resilience, and feats of strength.",
                            {
                                "type": "entries",
                                "name": "Primal Instinct",
                                "entries": [
                                    "People of towns and cities take pride in how their civilized ways set them apart from animals, as if denying one's own nature was a mark of superiority. To a barbarian, though, civilization is no virtue, but a sign of weakness. The strong embrace their animal nature\u2014keen instincts, primal physicality, and ferocious rage. Barbarians are uncomfortable when hedged in by walls and crowds. They thrive in the wilds of their homelands: the tundra, jungle, or grasslands where their tribes live and hunt.",
                                    "Barbarians come alive in the chaos of combat. They can enter a berserk state where rage takes over, giving them superhuman strength and resilience. A barbarian can draw on this reservoir of fury only a few times without resting, but those few rages are usually sufficient to defeat whatever threats arise."
                                ]
                            },
                            {
                                "type": "entries",
                                "name": "A Life of Danger",
                                "entries": [
                                    "Not every member of the tribes deemed \"barbarians\" by scions of civilized society has the barbarian class. A true barbarian among these people is as uncommon as a skilled fighter in a town, and he or she plays a similar role as a protector of the people and a leader in times of war. Life in the wild places of the world is fraught with peril: rival tribes, deadly weather, and terrifying monsters. Barbarians charge headlong into that danger so that their people don't have to.",
                                    "Their courage in the face of danger makes barbarians perfectly suited for adventuring. Wandering is often a way of life for their native tribes, and the rootless life of the adventurer is little hardship for a barbarian. Some barbarians miss the close-knit family structures of the tribe, but eventually find them replaced by the bonds formed among the members of their adventuring parties."
                                ]
                            },
                            {
                                "type": "entries",
                                "name": "Creating a Barbarian",
                                "entries": [
                                    "When creating a barbarian character, think about where your character comes from and his or her place in the world. Talk with your DM about an appropriate origin for your barbarian. Did you come from a distant land, making you a stranger in the area of the campaign? Or is the campaign set in a rough-and-tumble frontier where barbarians are common?",
                                    "What led you to take up the adventuring life? Were you lured to settled lands by the promise of riches? Did you join forces with soldiers of those lands to face a shared threat? Did monsters or an invading horde drive you out of your homeland, making you a rootless refugee? Perhaps you were a prisoner of war, brought in chains to \"civilized\" lands and only now able to win your freedom. Or you might have been cast out from your people because of a crime you committed, a taboo you violated, or a coup that removed you from a position of authority.",
                                    {
                                        "type": "entries",
                                        "name": "Quick Build",
                                        "entries": [
                                            "You can make a barbarian quickly by following these suggestions. First, put your highest ability score in Strength, followed by Constitution. Second, choose the {@background outlander} background."
                                        ]
                                    }
                                ]
                            }
                        ],
                        "source": "PHB",
                        "page": 46
                    },
                    {
                        "type": "section",
                        "entries": [
                            {
                                "type": "quote",
                                "entries": [
                                    "I have witnessed the indomitable performance of barbarians on the field of battle, and it makes me wonder what force lies at the heart of their rage."
                                ],
                                "by": "Seret, archwizard"
                            },
                            "The anger felt by a normal person resembles the rage of a barbarian in the same way that a gentle breeze is akin to a furious thunderstorm. The barbarian's driving force comes from a place that transcends mere emotion, making its manifestation all the more terrible. Whether the impetus for the fury comes entirely from within or from forging a link with a spirit animal, a raging barbarian becomes able to perform supernatural feats of strength and endurance. The outburst is temporary, but while it lasts, it takes over body and mind, driving the barbarian on despite peril and injury, until the last enemy falls.",
                            "It can be tempting to play a barbarian character that is a straightforward application of the classic archetype\u2014a brute, and usually a dimwitted one at that, who rushes in where others fear to tread. But not all the barbarians in the world are cut from that cloth, so you can certainly put your own spin on things. Either way, consider adding some flourishes to make your barbarian stand out from all others; see the following sections for some ideas.",
                            {
                                "type": "entries",
                                "name": "Personal Totems",
                                "entries": [
                                    "Barbarians tend to travel light, carrying little in the way of personal effects or other unnecessary gear. The few possessions they do carry often include small items that have special significance. A personal totem is significant because it has a mystical origin or is tied to an important moment in the character's life\u2014perhaps a remembrance from the barbarian's past or a harbinger of what lies ahead.",
                                    "A personal totem of this sort might be associated with a barbarian's spirit animal, or might actually be the totem object for the animal, but such a connection is not essential. One who has a bear totem spirit, for instance, could still carry an eagle's feather as a personal totem.",
                                    "Consider creating one or more personal totems for your character\u2014objects that hold a special link to your character's past or future. Think about how a totem might affect your character's actions.",
                                    {
                                        "type": "table",
                                        "caption": "Personal Totems",
                                        "colLabels": [
                                            "{@dice d6}",
                                            "Totem"
                                        ],
                                        "colStyles": [
                                            "col-1 text-center",
                                            "col-11"
                                        ],
                                        "rows": [
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 1
                                                    }
                                                },
                                                "A tuft of fur from a solitary wolf that you befriended during a hunt"
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 2
                                                    }
                                                },
                                                "Three eagle feathers given to you by a wise shaman, who told you they would play a role in determining your fate"
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 3
                                                    }
                                                },
                                                "A necklace made from the claws of a young cave bear that you slew singlehandedly as a child"
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 4
                                                    }
                                                },
                                                "A small leather pouch holding three stones that represent your ancestors"
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 5
                                                    }
                                                },
                                                "A few small bones from the first beast you killed, tied together with colored wool"
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 6
                                                    }
                                                },
                                                "An egg-sized stone in the shape of your spirit animal that appeared one day in your belt pouch"
                                            ]
                                        ]
                                    }
                                ]
                            },
                            {
                                "type": "entries",
                                "name": "Tattoos",
                                "entries": [
                                    "The members of many barbarian clans decorate their bodies with tattoos, each of which represents a significant moment in the life of the bearer or the bearer's ancestors, or which symbolizes a feeling or an attitude. As with personal totems, a barbarian's tattoos might or might not be related to an animal spirit.",
                                    "Each tattoo a barbarian displays contributes to that individual's identity. If your character wears tattoos, what do they look like, and what do they represent?",
                                    {
                                        "type": "table",
                                        "caption": "Tattoos",
                                        "colLabels": [
                                            "{@dice d6}",
                                            "Tattoo"
                                        ],
                                        "colStyles": [
                                            "col-1 text-center",
                                            "col-11"
                                        ],
                                        "rows": [
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 1
                                                    }
                                                },
                                                "The wings of an eagle are spread wide across your upper back."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 2
                                                    }
                                                },
                                                "Etched on the backs of your hands are the paws of a cave bear."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 3
                                                    }
                                                },
                                                "The symbols of your clan are displayed in viny patterns along your arms."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 4
                                                    }
                                                },
                                                "The antlers of an elk are inked across your back."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 5
                                                    }
                                                },
                                                "Images of your spirit animal are tattooed along your weapon arm and hand."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 6
                                                    }
                                                },
                                                "The eyes of a wolf are marked on your back to help you see and ward off evil spirits."
                                            ]
                                        ]
                                    }
                                ]
                            },
                            {
                                "type": "entries",
                                "name": "Superstitions",
                                "entries": [
                                    "Barbarians vary widely in how they understand life. Some follow gods and look for guidance from those deities in the cycles of nature and the animals they encounter. These barbarians believe that spirits inhabit the plants and animals of the world, and the barbarians look to them for omens and power.",
                                    "Other barbarians trust only in the blood that runs in their veins and the steel they hold in their hands. They have no use for the invisible world, instead relying on their senses to hunt and survive like the wild beasts they emulate.",
                                    "Both of these attitudes can give rise to superstitions. These beliefs are often passed down within a family or shared among the members of a clan or a hunting group.",
                                    "If your barbarian character has any superstitions, were they ingrained in you by your family, or are they the result of personal experience?",
                                    {
                                        "type": "table",
                                        "caption": "Superstition",
                                        "colLabels": [
                                            "{@dice d6}",
                                            "Superstition"
                                        ],
                                        "colStyles": [
                                            "col-1 text-center",
                                            "col-11"
                                        ],
                                        "rows": [
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 1
                                                    }
                                                },
                                                "If you disturb the bones of the dead, you inherit all the troubles that plagued them in life."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 2
                                                    }
                                                },
                                                "Never trust a wizard. They're all devils in disguise, especially the friendly ones."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 3
                                                    }
                                                },
                                                "Dwarves have lost their spirits, and are almost like the undead. That's why they live underground."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 4
                                                    }
                                                },
                                                "Magical things bring trouble. Never sleep with a magic object within ten feet of you."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 5
                                                    }
                                                },
                                                "When you walk through a graveyard, be sure to wear silver, or a ghost might jump into your body."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 6
                                                    }
                                                },
                                                "If an elf looks you in the eyes, she's trying to read your thoughts."
                                            ]
                                        ]
                                    }
                                ]
                            }
                        ],
                        "source": "XGE",
                        "page": 8
                    }
                ]
            }
        ],
        "subclass": [
            {
                "name": "Path of the Berserker",
                "shortName": "Berserker",
                "source": "PHB",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 49,
                "srd": true,
                "subclassFeatures": [
                    "Path of the Berserker|Barbarian||Berserker||3",
                    "Mindless Rage|Barbarian||Berserker||6",
                    "Intimidating Presence|Barbarian||Berserker||10",
                    "Retaliation|Barbarian||Berserker||14"
                ]
            },
            {
                "name": "Path of the Totem Warrior",
                "shortName": "Totem Warrior",
                "source": "PHB",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 50,
                "additionalSpells": [
                    {
                        "innate": {
                            "3": {
                                "ritual": [
                                    "beast sense",
                                    "speak with animals"
                                ]
                            },
                            "10": {
                                "ritual": [
                                    "commune with nature"
                                ]
                            }
                        }
                    }
                ],
                "subclassFeatures": [
                    "Path of the Totem Warrior|Barbarian||Totem Warrior||3",
                    "Aspect of the Beast|Barbarian||Totem Warrior||6",
                    "Spirit Walker|Barbarian||Totem Warrior||10",
                    "Totemic Attunement|Barbarian||Totem Warrior||14"
                ]
            },
            {
                "name": "Path of the Battlerager",
                "shortName": "Battlerager",
                "source": "SCAG",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 121,
                "subclassFeatures": [
                    "Path of the Battlerager|Barbarian||Battlerager|SCAG|3",
                    "Reckless Abandon|Barbarian||Battlerager|SCAG|6",
                    "Battlerager Charge|Barbarian||Battlerager|SCAG|10",
                    "Spiked Retribution|Barbarian||Battlerager|SCAG|14"
                ]
            },
            {
                "name": "Path of the Ancestral Guardian",
                "shortName": "Ancestral Guardian",
                "source": "XGE",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 9,
                "spellcastingAbility": "wis",
                "additionalSpells": [
                    {
                        "innate": {
                            "10": [
                                "augury",
                                "clairvoyance"
                            ]
                        }
                    }
                ],
                "subclassFeatures": [
                    "Path of the Ancestral Guardian|Barbarian||Ancestral Guardian|XGE|3",
                    "Spirit Shield|Barbarian||Ancestral Guardian|XGE|6",
                    "Consult the Spirits|Barbarian||Ancestral Guardian|XGE|10",
                    "Vengeful Ancestors|Barbarian||Ancestral Guardian|XGE|14"
                ]
            },
            {
                "name": "Path of the Storm Herald",
                "shortName": "Storm Herald",
                "source": "XGE",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 10,
                "subclassFeatures": [
                    "Path of the Storm Herald|Barbarian||Storm Herald|XGE|3",
                    "Storm Soul|Barbarian||Storm Herald|XGE|6",
                    "Shielding Storm|Barbarian||Storm Herald|XGE|10",
                    "Raging Storm|Barbarian||Storm Herald|XGE|14"
                ]
            },
            {
                "name": "Path of the Zealot",
                "shortName": "Zealot",
                "source": "XGE",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 11,
                "subclassFeatures": [
                    "Path of the Zealot|Barbarian||Zealot|XGE|3",
                    "Fanatical Focus|Barbarian||Zealot|XGE|6",
                    "Zealous Presence|Barbarian||Zealot|XGE|10",
                    "Rage beyond Death|Barbarian||Zealot|XGE|14"
                ]
            },
            {
                "name": "Path of the Beast",
                "shortName": "Beast",
                "source": "TCE",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 24,
                "subclassFeatures": [
                    "Path of the Beast|Barbarian||Beast|TCE|3",
                    "Bestial Soul|Barbarian||Beast|TCE|6",
                    "Infectious Fury|Barbarian||Beast|TCE|10",
                    "Call the Hunt|Barbarian||Beast|TCE|14"
                ]
            },
            {
                "name": "Path of Wild Magic",
                "shortName": "Wild Magic",
                "source": "TCE",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 25,
                "subclassFeatures": [
                    "Path of Wild Magic|Barbarian||Wild Magic|TCE|3",
                    "Bolstering Magic|Barbarian||Wild Magic|TCE|6",
                    "Unstable Backlash|Barbarian||Wild Magic|TCE|10",
                    "Controlled Surge|Barbarian||Wild Magic|TCE|14"
                ]
            },
            {
                "name": "Path of the Juggernaut",
                "shortName": "Juggernaut",
                "source": "TDCSR",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 165,
                "subclassFeatures": [
                    "Path of the Juggernaut|Barbarian|PHB|Juggernaut|TDCSR|3",
                    "Demolishing Might|Barbarian|PHB|Juggernaut|TDCSR|6",
                    "Resolute Stance|Barbarian|PHB|Juggernaut|TDCSR|6",
                    "Thunderous Blows (10th Level)|Barbarian|PHB|Juggernaut|TDCSR|10",
                    "Hurricane Strike|Barbarian|PHB|Juggernaut|TDCSR|10",
                    "Unstoppable|Barbarian|PHB|Juggernaut|TDCSR|14"
                ]
            },
            {
                "name": "Path of the Giant",
                "shortName": "Giant",
                "source": "BGG",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 1,
                "spellcastingAbility": "wis",
                "additionalSpells": [
                    {
                        "innate": {
                            "3": [
                                "druidcraft#c"
                            ]
                        }
                    },
                    {
                        "innate": {
                            "3": [
                                "thaumaturgy#c"
                            ]
                        }
                    }
                ],
                "subclassFeatures": [
                    "Path of the Giant|Barbarian||Giant|BGG|3",
                    "Elemental Cleaver|Barbarian||Giant|BGG|6",
                    "Mighty Impel|Barbarian||Giant|BGG|10",
                    "Demiurgic Colossus|Barbarian||Giant|BGG|14"
                ]
            }
        ],
        "classFeature": [
            {
                "name": "Rage",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 1,
                "entries": [
                    "In battle, you fight with primal ferocity. On your turn, you can enter a rage as a bonus action.",
                    "While raging, you gain the following benefits if you aren't wearing heavy armor:",
                    {
                        "type": "list",
                        "items": [
                            "You have advantage on Strength checks and Strength saving throws.",
                            "When you make a melee weapon attack using Strength, you gain a +2 bonus to the damage roll. This bonus increases as you level.",
                            "You have resistance to bludgeoning, piercing, and slashing damage."
                        ]
                    },
                    "If you are able to cast spells, you can't cast them or concentrate on them while raging.",
                    "Your rage lasts for 1 minute. It ends early if you are knocked {@condition unconscious} or if your turn ends and you haven't attacked a hostile creature since your last turn or taken damage since then. You can also end your rage on your turn as a bonus action.",
                    "Once you have raged the maximum number of times for your barbarian level, you must finish a long rest before you can rage again. You may rage 2 times at 1st level, 3 at 3rd, 4 at 6th, 5 at 12th, and 6 at 17th."
                ]
            },
            {
                "name": "Unarmored Defense",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 1,
                "entries": [
                    "While you are not wearing any armor, your Armor Class equals 10 + your Dexterity modifier + your Constitution modifier. You can use a shield and still gain this benefit."
                ]
            },
            {
                "name": "Danger Sense",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 2,
                "entries": [
                    "At 2nd level, you gain an uncanny sense of when things nearby aren't as they should be, giving you an edge when you dodge away from danger. You have advantage on Dexterity saving throws against effects that you can see, such as traps and spells. To gain this benefit, you can't be {@condition blinded}, {@condition deafened}, or {@condition incapacitated}."
                ]
            },
            {
                "name": "Reckless Attack",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 2,
                "entries": [
                    "Starting at 2nd level, you can throw aside all concern for defense to attack with fierce desperation. When you make your first attack on your turn, you can decide to attack recklessly. Doing so gives you advantage on melee weapon attack rolls using Strength during this turn, but attack rolls against you have advantage until your next turn."
                ]
            },
            {
                "name": "Primal Knowledge",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 3,
                "isClassFeatureVariant": true,
                "entries": [
                    "{@i 3rd-level barbarian {@variantrule optional class features|tce|optional feature}}",
                    "When you reach 3rd level and again at 10th level, you gain proficiency in one skill of your choice from the list of skills available to barbarians at 1st level."
                ]
            },
            {
                "name": "Primal Path",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 3,
                "entries": [
                    "At 3rd level, you choose a path that shapes the nature of your rage from the list of available paths. Your choice grants you features at 3rd level and again at 6th, 10th, and 14th levels."
                ]
            },
            {
                "name": "Ability Score Improvement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 4,
                "entries": [
                    "When you reach 4th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                    "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                ]
            },
            {
                "name": "Extra Attack",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 5,
                "entries": [
                    "Beginning at 5th level, you can attack twice, instead of once, whenever you take the {@action Attack} action on your turn."
                ]
            },
            {
                "name": "Fast Movement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 5,
                "entries": [
                    "Starting at 5th level, your speed increases by 10 feet while you aren't wearing heavy armor."
                ]
            },
            {
                "name": "Path Feature",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 6,
                "entries": [
                    "At 6th level, you gain a feature from your Primal Path."
                ]
            },
            {
                "name": "Feral Instinct",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 7,
                "entries": [
                    "By 7th level, your instincts are so honed that you have advantage on initiative rolls.",
                    "Additionally, if you are {@quickref Surprise|PHB|3|0|surprised} at the beginning of combat and aren't {@condition incapacitated}, you can act normally on your first turn, but only if you enter your rage before doing anything else on that turn."
                ]
            },
            {
                "name": "Instinctive Pounce",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 7,
                "isClassFeatureVariant": true,
                "entries": [
                    "{@i 7th-level barbarian {@variantrule optional class features|tce|optional feature}}",
                    "As part of the bonus action you take to enter your rage, you can move up to half your speed."
                ]
            },
            {
                "name": "Ability Score Improvement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 8,
                "entries": [
                    "When you reach 8th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                    "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                ]
            },
            {
                "name": "Brutal Critical (1 die)",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 9,
                "entries": [
                    "Beginning at 9th level, you can roll one additional weapon damage die when determining the extra damage for a critical hit with a melee attack.",
                    "This increases to two additional dice at 13th level and three additional dice at 17th level."
                ]
            },
            {
                "name": "Path feature",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 10,
                "entries": [
                    "At 10th level, you gain a feature from your Primal Path."
                ]
            },
            {
                "name": "Relentless Rage",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 11,
                "entries": [
                    "Starting at 11th level, your rage can keep you fighting despite grievous wounds. If you drop to 0 hit points while you're raging and don't die outright, you can make a DC 10 Constitution saving throw. If you succeed, you drop to 1 hit point instead.",
                    "Each time you use this feature after the first, the DC increases by 5. When you finish a short or long rest, the DC resets to 10."
                ]
            },
            {
                "name": "Ability Score Improvement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 12,
                "entries": [
                    "When you reach 12th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                    "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                ]
            },
            {
                "name": "Brutal Critical (2 dice)",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 13,
                "entries": [
                    "At 13th level, you can roll two additional weapon damage dice when determining the extra damage for a critical hit with a melee attack.",
                    "This increases to three additional dice at 17th level."
                ]
            },
            {
                "name": "Path feature",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 14,
                "entries": [
                    "At 14th level, you gain a feature from your Primal Path."
                ]
            },
            {
                "name": "Persistent Rage",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 15,
                "entries": [
                    "Beginning at 15th level, your rage is so fierce that it ends early only if you fall {@condition unconscious} or if you choose to end it."
                ]
            },
            {
                "name": "Ability Score Improvement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 16,
                "entries": [
                    "When you reach 16th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                    "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                ]
            },
            {
                "name": "Brutal Critical (3 dice)",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 17,
                "entries": [
                    "At 17th level, you can roll three additional weapon damage dice when determining the extra damage for a critical hit with a melee attack."
                ]
            },
            {
                "name": "Indomitable Might",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 18,
                "entries": [
                    "Beginning at 18th level, if your total for a Strength check is less than your Strength score, you can use that score in place of the total."
                ]
            },
            {
                "name": "Ability Score Improvement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 19,
                "entries": [
                    "When you reach 19th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                    "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                ]
            },
            {
                "name": "Primal Champion",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 20,
                "entries": [
                    "At 20th level, you embody the power of the wilds. Your Strength and Constitution scores increase by 4. Your maximum for those scores is now 24."
                ]
            }
        ],
        "subclassFeature": [
            {
                "name": "Giant Power",
                "source": "BGG",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 3,
                "entries": [
                    "{@i 3rd-Level Path of the Giant Feature}",
                    "When you choose this path, you learn to speak, read, and write Giant or one other language of your choice if you already know Giant. Additionally, you learn a cantrip of your choice: either {@spell druidcraft} or {@spell thaumaturgy}. Wisdom is your spellcasting ability for this spell."
                ]
            },
            {
                "name": "Giant's Havoc",
                "source": "BGG",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 3,
                "entries": [
                    "{@i 3rd-Level Path of the Giant Feature}",
                    "Your rages pull strength from the primal might of giants, transforming you into a hulking force of destruction. While raging, you gain the following benefits:",
                    {
                        "type": "list",
                        "style": "list-hang-notitle",
                        "items": [
                            {
                                "type": "item",
                                "name": "Crushing Throw",
                                "entry": "When you make a successful ranged attack with a thrown weapon using Strength, you can add your Rage Damage bonus to the attack's damage roll."
                            },
                            {
                                "type": "item",
                                "name": "Giant Stature",
                                "entry": "Your reach increases by 5 feet, and if you are smaller than Large, you become Large, along with anything you are wearing. If there isn't enough room for you to increase your size, your size doesn't change."
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Path of the Giant",
                "source": "BGG",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 3,
                "entries": [
                    "Barbarians who walk the Path of the Giant draw strength from the same primal forces as giants. As they rage, these barbarians surge with elemental power and grow in size, taking on forms that evoke the glory of giants. Some barbarians look like oversized versions of themselves, perhaps with a hint of elemental energy flaring in their eyes and around their weapons. Others transform more dramatically, taking on the appearance of an actual giant or a form similar to an Elemental, wreathed in fire, frost, or lightning.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Giant Power|Barbarian||Giant|BGG|3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Giant's Havoc|Barbarian||Giant|BGG|3"
                    }
                ]
            },
            {
                "name": "Elemental Cleaver",
                "source": "BGG",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 6,
                "header": 2,
                "entries": [
                    "{@i 6th-Level Path of the Giant Feature}",
                    "Your bond with the elemental might of giants grows, and you learn to infuse weapons with primordial energy.",
                    "When you enter your rage, you can choose one weapon that you are holding and infuse it with one of the following damage types: acid, cold, fire, thunder, or lightning. While you wield the infused weapon during your rage, the weapon's damage type changes to the chosen type, it deals an extra {@dice 1d6} damage of the chosen type when it hits, and it gains the thrown property, with a normal range of 20 feet and a long range of 60 feet. If you throw the weapon, it reappears in your hand the instant after it hits or misses a target. The infused weapon's benefits are suppressed while a creature other than you wields it.",
                    "While raging and holding the infused weapon, you can use a bonus action to change the infused weapon's current damage type to another one from the damage type options above."
                ]
            },
            {
                "name": "Mighty Impel",
                "source": "BGG",
                "page": 12,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 10,
                "header": 2,
                "entries": [
                    "{@i 10th-Level Path of the Giant Feature}",
                    "Your connection to giant strength allows you to hurl both allies and enemies on the battlefield. As a bonus action while raging, you can choose one Medium or smaller creature within your reach and move it to an unoccupied space you can see within 30 feet of yourself. An unwilling creature must succeed on a Strength saving throw (DC equals 8 + your proficiency bonus + your Strength modifier) to avoid the effect.",
                    "If, at the end of this movement, the thrown creature isn't on a surface or liquid that can support it, the creature falls, taking damage as normal and landing {@condition prone}."
                ]
            },
            {
                "name": "Demiurgic Colossus",
                "source": "BGG",
                "page": 12,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 14,
                "header": 2,
                "entries": [
                    "{@i 14th-Level Path of the Giant Feature}",
                    "The primordial power of your rage intensifies. When you rage, your reach increases by 10 feet, your size can increase to Large or Huge (your choice), and you can use your Mighty Impel to move creatures that are Large or smaller.",
                    "In addition, the extra damage dealt by your Elemental Cleaver feature increases to {@dice 2d6}."
                ]
            },
            {
                "name": "Path of the Berserker",
                "source": "PHB",
                "page": 49,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Berserker",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "For some barbarians, rage is a means to an end\u2014that end being violence. The Path of the Berserker is a path of untrammeled fury, slick with blood. As you enter the berserker's rage, you thrill in the chaos of battle, heedless of your own health or well-being.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Frenzy|Barbarian||Berserker||3"
                    }
                ]
            },
            {
                "name": "Frenzy",
                "source": "PHB",
                "page": 49,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Berserker",
                "subclassSource": "PHB",
                "level": 3,
                "header": 1,
                "entries": [
                    "Starting when you choose this path at 3rd level, you can go into a frenzy when you rage. If you do so, for the duration of your rage you can make a single melee weapon attack as a bonus action on each of your turns after this one. When your rage ends, you suffer one level of {@condition exhaustion}."
                ]
            },
            {
                "name": "Mindless Rage",
                "source": "PHB",
                "page": 49,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Berserker",
                "subclassSource": "PHB",
                "level": 6,
                "header": 2,
                "entries": [
                    "Beginning at 6th level, you can't be {@condition charmed} or {@condition frightened} while raging. If you are {@condition charmed} or {@condition frightened} when you enter your rage, the effect is suspended for the duration of the rage."
                ]
            },
            {
                "name": "Intimidating Presence",
                "source": "PHB",
                "page": 49,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Berserker",
                "subclassSource": "PHB",
                "level": 10,
                "header": 2,
                "entries": [
                    "Beginning at 10th level, you can use your action to frighten someone with your menacing presence. When you do so, choose one creature that you can see within 30 feet of you. If the creature can see or hear you, it must succeed on a Wisdom saving throw (DC equal to 8 + your proficiency bonus + your Charisma modifier) or be {@condition frightened} of you until the end of your next turn. On subsequent turns, you can use your action to extend the duration of this effect on the {@condition frightened} creature until the end of your next turn. This effect ends if the creature ends its turn out of line of sight or more than 60 feet away from you.",
                    "If the creature succeeds on its saving throw, you can't use this feature on that creature again for 24 hours."
                ]
            },
            {
                "name": "Retaliation",
                "source": "PHB",
                "page": 49,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Berserker",
                "subclassSource": "PHB",
                "level": 14,
                "header": 2,
                "entries": [
                    "Starting at 14th level, when you take damage from a creature that is within 5 feet of you, you can use your reaction to make a melee weapon attack against that creature."
                ]
            },
            {
                "name": "Bear",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "While raging, you have resistance to all damage except psychic damage. The spirit of the bear makes you tough enough to stand up to any punishment."
                ]
            },
            {
                "name": "Eagle",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "While you're raging and aren't wearing heavy armor, other creatures have disadvantage on opportunity attack rolls against you, and you can use the {@action Dash} action as a bonus action on your turn. The spirit of the eagle makes you into a predator who can weave through the fray with ease."
                ]
            },
            {
                "name": "Path of the Totem Warrior",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "The Path of the Totem Warrior is a spiritual journey, as the barbarian accepts a spirit animal as guide, protector, and inspiration. In battle, your totem spirit fills you with supernatural might, adding magical fuel to your barbarian rage.",
                    "Most barbarian tribes consider a totem animal to be kin to a particular clan. In such cases, it is unusual for an individual to have more than one totem animal spirit, though exceptions exist.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Spirit Seeker|Barbarian||Totem Warrior||3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Totem Spirit|Barbarian||Totem Warrior||3"
                    }
                ]
            },
            {
                "name": "Wolf",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "While you're raging, your friends have advantage on melee attack rolls against any creature within 5 feet of you that is hostile to you. The spirit of the wolf makes you a leader of hunters."
                ]
            },
            {
                "name": "Spirit Seeker",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "header": 1,
                "entries": [
                    "Yours is a path that seeks attunement with the natural world, giving you a kinship with beasts. At 3rd level when you adopt this path, you gain the ability to cast the {@spell beast sense} and {@spell speak with animals} spells, but only as rituals, as described in {@book chapter 10|PHB|10|rituals}."
                ]
            },
            {
                "name": "Totem Spirit",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "header": 1,
                "entries": [
                    "At 3rd level, when you adopt this path, you choose a totem spirit and gain its feature. You must make or acquire a physical totem object\u2014an amulet or similar adornment\u2014that incorporates fur or feathers, claws, teeth, or bones of the totem animal. At your option, you also gain minor physical attributes that are reminiscent of your totem spirit. For example, if you have a bear totem spirit, you might be unusually hairy and thick-skinned, or if your totem is the eagle, your eyes turn bright yellow.",
                    "Your totem animal might be an animal related to those listed here but more appropriate to your homeland. For example, you could choose a hawk or vulture in place of an eagle.",
                    {
                        "type": "options",
                        "count": 1,
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Bear|Barbarian||Totem Warrior||3"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Eagle|Barbarian||Totem Warrior||3"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Elk|Barbarian|SCAG|Totem Warrior||3|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tiger|Barbarian|SCAG|Totem Warrior||3|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Wolf|Barbarian||Totem Warrior||3"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Bear",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "entries": [
                    "You gain the might of a bear. Your carrying capacity (including maximum load and maximum lift) is doubled, and you have advantage on Strength checks made to push, pull, lift, or break objects."
                ]
            },
            {
                "name": "Eagle",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "entries": [
                    "You gain the eyesight of an eagle. You can see up to 1 mile away with no difficulty, able to discern even fine details as though looking at something no more than 100 feet away from you. Additionally, dim light doesn't impose disadvantage on your Wisdom ({@skill Perception}) checks."
                ]
            },
            {
                "name": "Wolf",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "entries": [
                    "You gain the hunting sensibilities of a wolf. You can track other creatures while traveling at a fast pace, and you can move stealthily while traveling at a normal pace."
                ]
            },
            {
                "name": "Aspect of the Beast",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "header": 2,
                "entries": [
                    "At 6th level, you gain a magical benefit based on the totem animal of your choice. You can choose the same animal you selected at 3rd level or a different one.",
                    {
                        "type": "options",
                        "count": 1,
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Bear|Barbarian||Totem Warrior||6"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Eagle|Barbarian||Totem Warrior||6"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Elk|Barbarian|SCAG|Totem Warrior||6|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tiger|Barbarian|SCAG|Totem Warrior||6|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Wolf|Barbarian||Totem Warrior||6"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Spirit Walker",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 10,
                "header": 2,
                "entries": [
                    "At 10th level, you can cast the {@spell commune with nature} spell, but only as a ritual. When you do so, a spiritual version of one of the animals you chose for Totem Spirit or Aspect of the Beast appears to you to convey the information you seek."
                ]
            },
            {
                "name": "Bear",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "entries": [
                    "While you're raging, any creature within 5 feet of you that's hostile to you has disadvantage on attack rolls against targets other than you or another character with this feature. An enemy is immune to this effect if it can't see or hear you or if it can't be {@condition frightened}."
                ]
            },
            {
                "name": "Eagle",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "entries": [
                    "While raging, you have a flying speed equal to your current walking speed. This benefit works only in short bursts; you fall if you end your turn in the air and nothing else is holding you aloft."
                ]
            },
            {
                "name": "Wolf",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "entries": [
                    "While you're raging, you can use a bonus action on your turn to knock a Large or smaller creature {@condition prone} when you hit it with melee weapon attack."
                ]
            },
            {
                "name": "Totemic Attunement",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "header": 2,
                "entries": [
                    "At 14th level, you gain a magical benefit based on a totem animal of your choice. You can choose the same animal you selected previously or a different one.",
                    {
                        "type": "options",
                        "count": 1,
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Bear|Barbarian||Totem Warrior||14"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Eagle|Barbarian||Totem Warrior||14"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Elk|Barbarian|SCAG|Totem Warrior||14|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tiger|Barbarian|SCAG|Totem Warrior||14|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Wolf|Barbarian||Totem Warrior||14"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Path of the Battlerager",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 3,
                "entries": [
                    "Known as Kuldjargh (literally \"axe idiot\") in Dwarvish, battleragers are dwarf followers of the gods of war and take the Path of the Battlerager. They specialize in wearing bulky, {@item spiked armor|scag} and throwing themselves into combat, striking with their body itself and giving themselves over to the fury of battle.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Restriction\u2014Dwarves Only|Barbarian||Battlerager|SCAG|3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Battlerager Armor|Barbarian||Battlerager|SCAG|3"
                    }
                ]
            },
            {
                "name": "Battlerager Armor",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 3,
                "header": 1,
                "entries": [
                    "When you choose this path at 3rd level, you gain the ability to use {@item spiked armor|scag} as a weapon.",
                    "While you are wearing {@item spiked armor|scag} and are raging, you can use a bonus action to make one melee weapon attack with your armor spikes at a target within 5 feet of you. If the attack hits, the spikes deal {@damage 1d4} piercing damage. You use your Strength modifier for the attack and damage rolls.",
                    "Additionally, when you use the {@action Attack} action to grapple a creature, the target takes 3 piercing damage if your grapple check succeeds."
                ]
            },
            {
                "name": "Restriction\u2014Dwarves Only",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 3,
                "header": 1,
                "entries": [
                    "Only dwarves can follow the Path of the Battlerager. The battlerager fills a particular niche in dwarven society and culture.",
                    "Your DM can lift this restriction to better suit the campaign. The restriction exists for the Forgotten Realms. It might not apply to your DM's setting or your DM's version of the Realms."
                ]
            },
            {
                "name": "Reckless Abandon",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 6,
                "header": 2,
                "entries": [
                    "Beginning at 6th level, when you use Reckless Attack while raging, you also gain temporary hit points equal to your Constitution modifier (minimum of 1). They vanish if any of them are left when your rage ends."
                ]
            },
            {
                "name": "Battlerager Charge",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 10,
                "header": 2,
                "entries": [
                    "Beginning at 10th level, you can take the {@action Dash} action as a bonus action while you are raging."
                ]
            },
            {
                "name": "Spiked Retribution",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 14,
                "header": 2,
                "entries": [
                    "Starting at 14th level, when a creature within 5 feet of you hits you with a melee attack, the attacker takes 3 piercing damage if you are raging, aren't {@condition incapacitated}, and are wearing {@item spiked armor|scag}."
                ]
            },
            {
                "name": "Path of the Beast",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Beast",
                "subclassSource": "TCE",
                "level": 3,
                "entries": [
                    "Barbarians who walk the Path of the Beast draw their rage from a bestial spark burning within their souls. That beast bursts forth in the throes of rage, physically transforming the barbarian.",
                    "Such a barbarian might be inhabited by a primal spirit or be descended from shape-shifters. You can choose the origin of your feral might or determine it by rolling on the Origin of the Beast table.",
                    {
                        "type": "table",
                        "caption": "Origin of the Beast",
                        "colLabels": [
                            "d4",
                            "Origin"
                        ],
                        "colStyles": [
                            "col-2 text-center",
                            "col-10"
                        ],
                        "rows": [
                            [
                                "1",
                                "One of your parents is a lycanthrope, and you've inherited some of their curse."
                            ],
                            [
                                "2",
                                "You are descended from an archdruid and inherited the ability to partially change shape."
                            ],
                            [
                                "3",
                                "A fey spirit gifted you with the ability to adopt different bestial aspects."
                            ],
                            [
                                "4",
                                "An ancient animal spirit dwells within you, allowing you to walk this path."
                            ]
                        ]
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Form of the Beast|Barbarian||Beast|TCE|3"
                    }
                ]
            },
            {
                "name": "Form of the Beast",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Beast",
                "subclassSource": "TCE",
                "level": 3,
                "header": 1,
                "entries": [
                    "{@i 3rd-level Path of the Beast feature}",
                    "When you enter your rage, you can transform, revealing the bestial power within you. Until the rage ends, you manifest a natural weapon. It counts as a simple melee weapon for you, and you add your Strength modifier to the attack and damage rolls when you attack with it, as normal.",
                    "You choose the weapon's form each time you rage:",
                    {
                        "type": "list",
                        "style": "list-hang-notitle",
                        "items": [
                            {
                                "type": "item",
                                "name": "Bite",
                                "entry": "Your mouth transforms into a bestial muzzle or great mandibles (your choice). It deals {@damage 1d8} piercing damage on a hit. Once on each of your turns when you damage a creature with this bite, you regain a number of hit points equal to your proficiency bonus, provided you have less than half your hit points when you hit."
                            },
                            {
                                "type": "item",
                                "name": "Claws",
                                "entry": "Each of your hands transforms into a claw, which you can use as a weapon if it's empty. It deals {@damage 1d6} slashing damage on a hit. Once on each of your turns when you attack with a claw using the {@action Attack} action, you can make one additional claw attack as part of the same action."
                            },
                            {
                                "type": "item",
                                "name": "Tail",
                                "entry": "You grow a lashing, spiny tail, which deals {@damage 1d8} piercing damage on a hit and has the reach property. If a creature you can see within 10 feet of you hits you with an attack roll, you can use your reaction to swipe your tail and roll a {@dice d8}, applying a bonus to your AC equal to the number rolled, potentially causing the attack to miss you."
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Bestial Soul",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Beast",
                "subclassSource": "TCE",
                "level": 6,
                "header": 2,
                "entries": [
                    "{@i 6th-level Path of the Beast feature}",
                    "The feral power within you increases, causing the natural weapons of your Form of the Beast to count as magical for the purpose of overcoming resistance and immunity to nonmagical attacks and damage.",
                    "You can also alter your form to help you adapt to your surroundings. When you finish a short or long rest, choose one of the following benefits, which lasts until you finish your next short or long rest:",
                    {
                        "type": "list",
                        "items": [
                            "You gain a swimming speed equal to your walking speed, and you can breathe underwater.",
                            "You gain a climbing speed equal to your walking speed, and you can climb difficult surfaces, including upside down on ceilings, without needing to make an ability check.",
                            "When you jump, you can make a Strength ({@skill Athletics}) check and extend your jump by a number of feet equal to the check's total. You can make this special check only once per turn."
                        ]
                    }
                ]
            },
            {
                "name": "Infectious Fury",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Beast",
                "subclassSource": "TCE",
                "level": 10,
                "header": 2,
                "entries": [
                    "{@i 10th-level Path of the Beast feature}",
                    "When you hit a creature with your natural weapons while you are raging, the beast within you can curse your target with rabid fury. The target must succeed on a Wisdom saving throw (DC equal to 8 + your Constitution modifier + your proficiency bonus) or suffer one of the following effects (your choice):",
                    {
                        "type": "list",
                        "items": [
                            "The target must use its reaction to make a melee attack against another creature of your choice that you can see.",
                            "The target takes {@damage 2d12} psychic damage."
                        ]
                    },
                    "You can use this feature a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                ]
            },
            {
                "name": "Call the Hunt",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Beast",
                "subclassSource": "TCE",
                "level": 14,
                "header": 2,
                "entries": [
                    "{@i 14th-level Path of the Beast feature}",
                    "The beast within you grows so powerful that you can spread its ferocity to others and gain resilience from them joining your hunt. When you enter your rage, you can choose a number of other willing creatures you can see within 30 feet of you equal to your Constitution modifier (minimum of one creature).",
                    "You gain 5 temporary hit points for each creature that accepts this feature. Until the rage ends, the chosen creatures can each use the following benefit once on each of their turns: when the creature hits a target with an attack roll and deals damage to it, the creature can roll a {@dice d6} and gain a bonus to the damage equal to the number rolled.",
                    "You can use this feature a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                ]
            },
            {
                "name": "Path of Wild Magic",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 3,
                "entries": [
                    "Many places in the multiverse abound with beauty, intense emotion, and rampant magic; the Feywild, the Upper Planes, and other realms of supernatural power radiate with such forces and can profoundly influence people. As folk of deep feeling, barbarians are especially susceptible to these wild influences, with some barbarians being transformed by the magic. These magic-suffused barbarians walk the Path of Wild Magic. Elf, tiefling, aasimar, and genasi barbarians often seek this path, eager to manifest the otherworldly magic of their ancestors.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Magic Awareness|Barbarian||Wild Magic|TCE|3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Wild Surge|Barbarian||Wild Magic|TCE|3"
                    }
                ]
            },
            {
                "name": "Magic Awareness",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 3,
                "header": 1,
                "entries": [
                    "{@i 3rd-level Path of Wild Magic feature}",
                    "As an action, you can open your awareness to the presence of concentrated magic. Until the end of your next turn, you know the location of any spell or magic item within 60 feet of you that isn't behind total cover. When you sense a spell, you learn which school of magic it belongs to.",
                    "You can use this feature a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                ]
            },
            {
                "name": "Wild Surge",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 3,
                "header": 1,
                "entries": [
                    "{@i 3rd-level Path of Wild Magic feature}",
                    "The magical energy roiling inside you sometimes erupts from you. When you enter your rage, roll on the Wild Magic table to determine the magical effect produced.",
                    "If the effect requires a saving throw, the DC equals 8 + your proficiency bonus + your Constitution modifier.",
                    {
                        "type": "table",
                        "caption": "Wild Magic",
                        "colLabels": [
                            "d8",
                            "Magical Effect"
                        ],
                        "colStyles": [
                            "col-2 text-center",
                            "col-10"
                        ],
                        "rows": [
                            [
                                "1",
                                "Shadowy tendrils lash around you. Each creature of your choice that you can see within 30 feet of you must succeed on a Constitution saving throw or take {@damage 1d12} necrotic damage. You also gain {@dice 1d12} temporary hit points."
                            ],
                            [
                                "2",
                                "You teleport up to 30 feet to an unoccupied space you can see. Until your rage ends, you can use this effect again on each of your turns as a bonus action."
                            ],
                            [
                                "3",
                                "An intangible spirit, which looks like a {@creature flumph} or a {@creature pixie} (your choice), appears within 5 feet of one creature of your choice that you can see within 30 feet of you. At the end of the current turn, the spirit explodes, and each creature within 5 feet of it must succeed on a Dexterity saving throw or take {@damage 1d6} force damage. Until your rage ends, you can use this effect again, summoning another spirit, on each of your turns as a bonus action."
                            ],
                            [
                                "4",
                                "Magic infuses one weapon of your choice that you are holding. Until your rage ends, the weapon's damage type changes to force, and it gains the light and thrown properties, with a normal range of 20 feet and a long range of 60 feet. If the weapon leaves your hand, the weapon reappears in your hand at the end of the current turn."
                            ],
                            [
                                "5",
                                "Whenever a creature hits you with an attack roll before your rage ends, that creature takes {@damage 1d6} force damage, as magic lashes out in retribution."
                            ],
                            [
                                "6",
                                "Until your rage ends, you are surrounded by multi colored, protective lights; you gain a +1 bonus to AC, and while within 10 feet of you, your allies gain the same bonus."
                            ],
                            [
                                "7",
                                "Flowers and vines temporarily grow around you. Until your rage ends, the ground within 15 feet of you is {@quickref difficult terrain||3} for your enemies."
                            ],
                            [
                                "8",
                                "A bolt of light shoots from your chest. Another creature of your choice that you can see within 30 feet of you must succeed on a Constitution saving throw or take {@damage 1d6} radiant damage and be {@condition blinded} until the start of your next turn. Until your rage ends, you can use this effect again on each of your turns as a bonus action."
                            ]
                        ],
                        "data": {
                            "tableInclude": true
                        }
                    }
                ]
            },
            {
                "name": "Bolstering Magic",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 6,
                "header": 2,
                "entries": [
                    "{@i 6th-level Path of Wild Magic feature}",
                    "You can harness your wild magic to bolster yourself or a companion. As an action, you can touch one creature (which can be yourself) and confer one of the following benefits of your choice to that creature:",
                    {
                        "type": "list",
                        "items": [
                            "For 10 minutes, the creature can roll a {@dice d3} whenever making an attack roll or an ability check and add the number rolled to the {@dice d20} roll.",
                            "Roll a {@dice d3}. The creature regains one expended spell slot, the level of which equals the number rolled or lower (the creature's choice). Once a creature receives this benefit, that creature can't receive it again until after a long rest."
                        ]
                    },
                    "You can take this action a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                ]
            },
            {
                "name": "Unstable Backlash",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 10,
                "header": 2,
                "entries": [
                    "{@i 10th-level Path of Wild Magic feature}",
                    "When you are imperiled during your rage, the magic within you can lash out; immediately after you take damage or fail a saving throw while raging, you can use your reaction to roll on the Wild Magic table and immediately produce the effect rolled. This effect replaces your current Wild Magic effect."
                ]
            },
            {
                "name": "Controlled Surge",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 14,
                "header": 2,
                "entries": [
                    "{@i 14th-level Path of Wild Magic feature}",
                    "Whenever you roll on the Wild Magic table, you can roll the die twice and choose which of the two effects to unleash. If you roll the same number on both dice, you can ignore the number and choose any effect on the table."
                ]
            },
            {
                "name": "Path of the Juggernaut",
                "source": "TDCSR",
                "page": 165,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 3,
                "entries": [
                    "Barbarians who follow the Path of the Juggernaut stand so resolutely that none can deter them, and they swing their weapons with such force that all who stand against them are flung aside. In might and in spirit, juggernauts are immovable object and unstoppable force all at once.",
                    "Juggernaut barbarians can be found all over Tal'Dorei, and are common among the goliath warriors of the {@book Rivermaw herd|TDCSR|3|Rivermaw Herd} that wanders the {@book Dividing Plains|TDCSR|3|Dividing Plains}. Some {@book dwarves|TDCSR|4|dwarves} and humanoid survivalists of the {@book Cliffkeep Mountains|TDCSR|3|Cliffkeep Mountains} adopt this fighting style as an extension of their rugged determinism. And a number of stalwart juggernauts hail from the jungles of the {@book Rifenmist Peninsula|TDCSR|3|Rifenmist Peninsula}, having cast off the oppressive yoke of the {@book Iron Authority|TDCSR|3|Tz'Arrm, Helm of the Emperor}.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Thunderous Blows|Barbarian|PHB|Juggernaut|TDCSR|3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Spirit of the Mountain|Barbarian|PHB|Juggernaut|TDCSR|3"
                    }
                ]
            },
            {
                "name": "Spirit of the Mountain",
                "source": "TDCSR",
                "page": 166,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 3,
                "header": 1,
                "entries": [
                    "At 3rd level, you harness your fury to anchor your feet to the ground, becoming a bulwark of strength. While you are raging, you can't be knocked {@condition prone} or moved along the ground against your will."
                ]
            },
            {
                "name": "Thunderous Blows",
                "source": "TDCSR",
                "page": 165,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 3,
                "header": 1,
                "entries": [
                    "Starting when you choose this path at 3rd level, your rage instills you with the strength to shove and smash your way through your foes, making any battlefield your domain. When you hit a creature with a melee attack while you're raging, you can push that creature up to 5 feet away from you in a direction of your choice. A creature that is Huge or larger makes a Strength {@quickref saving throws|PHB|2|1|saving throw} with a DC equal to 8 + your proficiency bonus + your Strength modifier. On a success, the creature is not pushed.",
                    {
                        "type": "inset",
                        "name": "Rules Tip: Forced Movement",
                        "page": 166,
                        "entries": [
                            "Usually when one creature moves out of a hostile creature's reach, the hostile creature can use its reaction to make an {@action opportunity attack}. However, forced movement\u2014such as being pushed by a Path of the Juggernaut barbarian's {@subclassFeature Thunderous Blows|Barbarian|PHB|Juggernaut|TDCSR|3} feature\u2014doesn't provoke {@action opportunity attack|PHB|opportunity attacks}.",
                            "Likewise, a juggernaut barbarian's {@subclassFeature Hurricane Strike|Barbarian|PHB|Juggernaut|TDCSR|10} feature allows an ally to make a melee weapon attack as a reaction only if the foe ends its forced movement within 5 feet of the ally. If a foe is pushed through other spaces within 5 feet of your allies, those allies can't make normal {@action opportunity attack|PHB|opportunity attacks} against the foe."
                        ]
                    }
                ]
            },
            {
                "name": "Demolishing Might",
                "source": "TDCSR",
                "page": 166,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 6,
                "header": 2,
                "entries": [
                    "Starting at 6th level, your melee weapon attacks deal an extra {@damage 1d8} damage to constructs, and deal double damage to objects and structures."
                ]
            },
            {
                "name": "Resolute Stance",
                "source": "TDCSR",
                "page": 166,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 6,
                "header": 2,
                "entries": [
                    "Also at 6th level, you can temporarily refocus your combat ability to make yourself a bulwark of defense. At the start of your turn (no action required), you can assume a defensive stance that lasts until the start of your next turn. While in this stance, you can't be {@condition grappled}, attack rolls against you have {@quickref Advantage and Disadvantage|PHB|2|0|disadvantage}, and your weapon attacks are made with {@quickref Advantage and Disadvantage|PHB|2|0|disadvantage}."
                ]
            },
            {
                "name": "Hurricane Strike",
                "source": "TDCSR",
                "page": 166,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 10,
                "header": 2,
                "entries": [
                    "Starting at 10th level, your blows can hurl foes through the air and into the attacks of your allies. As a reaction when you push a creature at least 5 feet, you can then leap into an unoccupied space next to the creature. If you do so, the creature must succeed on a Strength {@quickref saving throws|PHB|2|1|saving throw} with a DC equal to 8 + your proficiency bonus + your Strength modifier or be knocked {@condition prone}. This leap costs no movement and does not provoke {@action opportunity attack|PHB|opportunity attacks}.",
                    "Additionally, whenever you push a creature into a space within 5 feet of one of your allies, the ally can use its reaction to make a melee weapon attack against that creature."
                ]
            },
            {
                "name": "Thunderous Blows (10th Level)",
                "source": "TDCSR",
                "page": 165,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 10,
                "header": 2,
                "entries": [
                    "Starting at 10th level, you can push a creature up to 10 feet when you hit it with a melee attack while you're raging."
                ]
            },
            {
                "name": "Unstoppable",
                "source": "TDCSR",
                "page": 166,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 14,
                "header": 2,
                "entries": [
                    "At 14th level, your fury in battle makes you unstoppable. While you're raging, your speed cannot be reduced, and you are immune to the {@condition frightened}, {@condition paralyzed}, {@condition prone}, and {@condition stunned} conditions.",
                    "If you are {@condition frightened}, {@condition paralyzed}, or {@condition stunned}, you can still use a bonus action to enter a rage (even if you can't otherwise take actions). You aren't affected by any of these conditions while you're raging."
                ]
            },
            {
                "name": "Path of the Ancestral Guardian",
                "source": "XGE",
                "page": 9,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Ancestral Guardian",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "Some barbarians hail from cultures that revere their ancestors. These tribes teach that the warriors of the past linger in the world as mighty spirits, who can guide and protect the living. When a barbarian who follows this path rages, the barbarian contacts the spirit world and calls on these guardian spirits for aid.",
                    "Barbarians who draw on their ancestral guardians can better fight to protect their tribes and their allies. In order to cement ties to their ancestral guardians, barbarians who follow this path cover themselves in elaborate tattoos that celebrate their ancestors' deeds. These tattoos tell sagas of victories against terrible monsters and other fearsome rivals.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Ancestral Protectors|Barbarian||Ancestral Guardian|XGE|3"
                    }
                ]
            },
            {
                "name": "Ancestral Protectors",
                "source": "XGE",
                "page": 9,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Ancestral Guardian",
                "subclassSource": "XGE",
                "level": 3,
                "header": 1,
                "entries": [
                    "Starting when you choose this path at 3rd level, spectral warriors appear when you enter your rage. While you're raging, the first creature you hit with an attack on your turn becomes the target of the warriors, which hinder its attacks. Until the start of your next turn, that target has disadvantage on any attack roll that isn't against you, and when the target hits a creature other than you with an attack, that creature has resistance to the damage dealt by the attack. The effect on the target ends early if your rage ends."
                ]
            },
            {
                "name": "Spirit Shield",
                "source": "XGE",
                "page": 9,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Ancestral Guardian",
                "subclassSource": "XGE",
                "level": 6,
                "header": 2,
                "entries": [
                    "Beginning at 6th level, the guardian spirits that aid you can provide supernatural protection to those you defend. If you are raging and another creature you can see within 30 feet of you takes damage, you can use your reaction to reduce that damage by {@dice 2d6}.",
                    "When you reach certain levels in this class, you can reduce the damage by more: by {@dice 3d6} at 10th level and by {@dice 4d6} at 14th level."
                ]
            },
            {
                "name": "Consult the Spirits",
                "source": "XGE",
                "page": 9,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Ancestral Guardian",
                "subclassSource": "XGE",
                "level": 10,
                "header": 2,
                "entries": [
                    "At 10th level, you gain the ability to consult with your ancestral spirits. When you do so, you cast the {@spell augury} or {@spell clairvoyance} spell, without using a spell slot or material components. Rather than creating a spherical sensor, this use of {@spell clairvoyance} invisibly summons one of your ancestral spirits to the chosen location. Wisdom is your spellcasting ability for these spells.",
                    "After you cast either spell in this way, you can't use this feature again until you finish a short or long rest."
                ]
            },
            {
                "name": "Vengeful Ancestors",
                "source": "XGE",
                "page": 9,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Ancestral Guardian",
                "subclassSource": "XGE",
                "level": 14,
                "header": 2,
                "entries": [
                    "At 14th level, your ancestral spirits grow powerful enough to retaliate. When you use your Spirit Shield to reduce the damage of an attack, the attacker takes an amount of force damage equal to the damage that your Spirit Shield prevents."
                ]
            },
            {
                "name": "Path of the Storm Herald",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "All barbarians harbor a fury within. Their rage grants them superior strength, durability, and speed. Barbarians who follow the Path of the Storm Herald learn to transform that rage into a mantle of primal magic, which swirls around them. When in a fury, a barbarian of this path taps into the forces of nature to create powerful magical effects.",
                    "Storm heralds are typically elite champions who train alongside druids, rangers, and others sworn to protect nature. Other storm heralds hone their craft in lodges in regions wracked by storms, in the frozen reaches at the world's end, or deep in the hottest deserts.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Storm Aura|Barbarian||Storm Herald|XGE|3"
                    }
                ]
            },
            {
                "name": "Storm Aura",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 3,
                "header": 1,
                "entries": [
                    "Starting at 3rd level, you emanate a stormy, magical aura while you rage. The aura extends 10 feet from you in every direction, but not through total cover.",
                    "Your aura has an effect that activates when you enter your rage, and you can activate the effect again on each of your turns as a bonus action. Choose desert, sea, or tundra. Your aura's effect depends on that chosen environment, as detailed below. You can change your environment choice whenever you gain a level in this class.",
                    "If your aura's effects require a saving throw, the DC equals 8 + your proficiency bonus + your Constitution modifier.",
                    {
                        "type": "options",
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Desert|Barbarian|XGE|Storm Herald|XGE|3"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Sea|Barbarian|XGE|Storm Herald|XGE|3"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tundra|Barbarian|XGE|Storm Herald|XGE|3"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Storm Soul",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 6,
                "header": 2,
                "entries": [
                    "At 6th level, the storm grants you benefits even when your aura isn't active. The benefits are based on the environment you chose for your Storm Aura.",
                    {
                        "type": "options",
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Desert|Barbarian|XGE|Storm Herald|XGE|6"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Sea|Barbarian|XGE|Storm Herald|XGE|6"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tundra|Barbarian|XGE|Storm Herald|XGE|6"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Shielding Storm",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 10,
                "header": 2,
                "entries": [
                    "At 10th level, you learn to use your mastery of the storm to protect others. Each creature of your choice has the damage resistance you gained from the Storm Soul feature while the creature is in your Storm Aura."
                ]
            },
            {
                "name": "Raging Storm",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 14,
                "header": 2,
                "entries": [
                    "At 14th level, the power of the storm you channel grows mightier, lashing out at your foes. The effect is based on the environment you chose for your Storm Aura.",
                    {
                        "type": "options",
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Desert|Barbarian|XGE|Storm Herald|XGE|14"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Sea|Barbarian|XGE|Storm Herald|XGE|14"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tundra|Barbarian|XGE|Storm Herald|XGE|14"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Path of the Zealot",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "Some deities inspire their followers to pitch themselves into a ferocious battle fury. These barbarians are zealots\u2014warriors who channel their rage into powerful displays of divine power.",
                    "A variety of gods across the worlds of D&D inspire their followers to embrace this path. Tempus from the Forgotten Realms and Hextor and Erythnul of Greyhawk are all prime examples. In general, the gods who inspire zealots are deities of combat, destruction, and violence. Not all are evil, but few are good.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Divine Fury|Barbarian||Zealot|XGE|3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Warrior of the Gods|Barbarian||Zealot|XGE|3"
                    }
                ]
            },
            {
                "name": "Divine Fury",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 3,
                "header": 1,
                "entries": [
                    "Starting when you choose this path at 3rd level, you can channel divine fury into your weapon strikes. While you're raging, the first creature you hit on each of your turns with a weapon attack takes extra damage equal to {@dice 1d6} + half your barbarian level. The extra damage is necrotic or radiant; you choose the type of damage when you gain this feature."
                ]
            },
            {
                "name": "Warrior of the Gods",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 3,
                "header": 1,
                "entries": [
                    "At 3rd level, your soul is marked for endless battle. If a spell, such as {@spell raise dead}, has the sole effect of restoring you to life (but not undeath), the caster doesn't need material components to cast the spell on you."
                ]
            },
            {
                "name": "Fanatical Focus",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 6,
                "header": 2,
                "entries": [
                    "Starting at 6th level, the divine power that fuels your rage can protect you. If you fail a saving throw while you're raging, you can reroll it, and you must use the new roll. You can use this ability only once per rage."
                ]
            },
            {
                "name": "Zealous Presence",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 10,
                "header": 2,
                "entries": [
                    "At 10th level, you learn to channel divine power to inspire zealotry in others. As a bonus action, you unleash a battle cry infused with divine energy. Up to ten other creatures of your choice within 60 feet of you that can hear you gain advantage on attack rolls and saving throws until the start of your next turn.",
                    "Once you use this feature, you can't use it again until you finish a long rest."
                ]
            },
            {
                "name": "Rage beyond Death",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 14,
                "header": 2,
                "entries": [
                    "Beginning at 14th level, the divine power that fuels your rage allows you to shrug off fatal blows.",
                    "While you're raging, having 0 hit points doesn't knock you {@condition unconscious}. You still must make death saving throws, and you suffer the normal effects of taking damage while at 0 hit points. However, if you would die due to failing death saving throws, you don't die until your rage ends, and you die then only if you still have 0 hit points."
                ]
            },
            {
                "name": "Elk",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "While you're raging and aren't wearing heavy armor, your walking speed increases by 15 feet. The spirit of the elk makes you extraordinarily swift."
                ]
            },
            {
                "name": "Tiger",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "While raging, you can add 10 feet to your long jump distance and 3 feet to your high jump distance. The spirit of the tiger empowers your leaps."
                ]
            },
            {
                "name": "Elk",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "entries": [
                    "Whether mounted or on foot, your travel pace is doubled, as is the travel pace of up to ten companions while they're within 60 feet of you and you're not {@condition incapacitated}. The elk spirit helps you roam far and fast."
                ]
            },
            {
                "name": "Tiger",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "entries": [
                    "You gain proficiency in two skills from the following list: {@skill Athletics}, {@skill Acrobatics}, {@skill Stealth}, and {@skill Survival}. The cat spirit hones your survival instincts."
                ]
            },
            {
                "name": "Elk",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "entries": [
                    "While raging, you can use a bonus action during your move to pass through the space of a Large or smaller creature. That creature must succeed on a Strength saving throw (DC 8 + your Strength bonus + your proficiency bonus) or be knocked {@condition prone} and take bludgeoning damage equal to {@dice 1d12} + your Strength modifier."
                ]
            },
            {
                "name": "Tiger",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "entries": [
                    "While you're raging, if you move at least 20 feet in a straight line toward a Large or smaller target right before making a melee weapon attack against it, you can use a bonus action to make an additional melee weapon attack against it."
                ]
            },
            {
                "name": "Desert",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "When this effect is activated, all other creatures in your aura take 2 fire damage each. The damage increases when you reach certain levels in this class, increasing to 3 at 5th level, 4 at 10th level, 5 at 15th level, and 6 at 20th level."
                ]
            },
            {
                "name": "Sea",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "When this effect is activated, you can choose one other creature you can see in your aura. The target must make a Dexterity saving throw. The target takes {@damage 1d6} lightning damage on a failed save, or half as much damage on a successful one. The damage increases when you reach certain levels in this class, increasing to {@dice 2d6} at 10th level, {@dice 3d6} at 15th level, and {@dice 4d6} at 20th level."
                ]
            },
            {
                "name": "Tundra",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "When this effect is activated, each creature of your choice in your aura gains 2 temporary hit points, as icy spirits inure it to suffering. The temporary hit points increase when you reach certain levels in this class, increasing to 3 at 5th level, 4 at 10th level, 5 at 15th level, and 6 at 20th level."
                ]
            },
            {
                "name": "Desert",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 6,
                "entries": [
                    "You gain resistance to fire damage, and you don't suffer the effects of extreme heat, as described in the Dungeon Master's Guide. Moreover, as an action, you can touch a flammable object that isn't being worn or carried by anyone else and set it on fire."
                ]
            },
            {
                "name": "Sea",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 6,
                "entries": [
                    "You gain resistance to lightning damage, and you can breathe underwater. You also gain a swimming speed of 30 feet."
                ]
            },
            {
                "name": "Tundra",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 6,
                "entries": [
                    "You gain resistance to cold damage, and you don't suffer the effects of extreme cold, as described in the Dungeon Master's Guide. Moreover, as an action, you can touch water and turn a 5-foot cube of it into ice, which melts after 1 minute. This action fails if a creature is in the cube."
                ]
            },
            {
                "name": "Desert",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 14,
                "entries": [
                    "Immediately after a creature in your aura hits you with an attack, you can use your reaction to force that creature to make a Dexterity saving throw. On a failed save, the creature takes fire damage equal to half your barbarian level."
                ]
            },
            {
                "name": "Sea",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 14,
                "entries": [
                    "When you hit a creature in your aura with an attack, you can use your reaction to force that creature to make a Strength saving throw. On a failed save, the creature is knocked {@condition prone}, as if struck by a wave."
                ]
            },
            {
                "name": "Tundra",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 14,
                "entries": [
                    "Whenever the effect of your Storm Aura is activated, you can choose one creature you can see in the aura. That creature must succeed on a Strength saving throw, or its speed is reduced to 0 until the start of your next turn, as magical frost covers it."
                ]
            }
        ]
    }
        `;

        const class_bard = String.raw`{
            "class": [
                {
                    "name": "Bard",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "hd": {
                        "number": 1,
                        "faces": 8
                    },
                    "proficiency": [
                        "dex",
                        "cha"
                    ],
                    "spellcastingAbility": "cha",
                    "casterProgression": "full",
                    "cantripProgression": [
                        2,
                        2,
                        2,
                        3,
                        3,
                        3,
                        3,
                        3,
                        3,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4
                    ],
                    "spellsKnownProgression": [
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        14,
                        15,
                        15,
                        16,
                        18,
                        19,
                        19,
                        20,
                        22,
                        22,
                        22
                    ],
                    "additionalSpells": [
                        {
                            "name": "Magical Secrets",
                            "known": {
                                "10": [
                                    {
                                        "choose": "level=0;1;2;3;4;5"
                                    },
                                    {
                                        "choose": "level=0;1;2;3;4;5"
                                    }
                                ],
                                "14": [
                                    {
                                        "choose": "level=0;1;2;3;4;5;6;7"
                                    },
                                    {
                                        "choose": "level=0;1;2;3;4;5;6;7"
                                    }
                                ],
                                "18": [
                                    {
                                        "choose": ""
                                    },
                                    {
                                        "choose": ""
                                    }
                                ]
                            }
                        }
                    ],
                    "startingProficiencies": {
                        "armor": [
                            "light"
                        ],
                        "weapons": [
                            "simple",
                            "{@item hand crossbow|phb|hand crossbows}",
                            "{@item longsword|phb|longswords}",
                            "{@item rapier|phb|rapiers}",
                            "{@item shortsword|phb|shortswords}"
                        ],
                        "tools": [
                            "three {@item musical instrument|PHB|musical instruments} of your choice"
                        ],
                        "toolProficiencies": [
                            {
                                "anyMusicalInstrument": 3
                            }
                        ],
                        "skills": [
                            {
                                "any": 3
                            }
                        ]
                    },
                    "startingEquipment": {
                        "additionalFromBackground": true,
                        "default": [
                            "(a) a {@item rapier|phb}, (b) a {@item longsword|phb}, or (c) any {@filter simple weapon|items|source=phb|category=basic|type=simple weapon}",
                            "(a) a {@item diplomat's pack|phb} or (b) an {@item entertainer's pack|phb}",
                            "(a) a {@item lute|phb} or (b) any other {@filter musical instrument|items|miscellaneous=mundane|type=instrument}",
                            "{@item Leather armor|phb}, and a {@item dagger|phb}"
                        ],
                        "goldAlternative": "{@dice 5d4 × 10|5d4 × 10|Starting Gold}",
                        "defaultData": [
                            {
                                "a": [
                                    "rapier|phb"
                                ],
                                "b": [
                                    "longsword|phb"
                                ],
                                "c": [
                                    {
                                        "equipmentType": "weaponSimple"
                                    }
                                ]
                            },
                            {
                                "a": [
                                    "diplomat's pack|phb"
                                ],
                                "b": [
                                    "entertainer's pack|phb"
                                ]
                            },
                            {
                                "a": [
                                    "lute|phb"
                                ],
                                "b": [
                                    {
                                        "equipmentType": "instrumentMusical"
                                    }
                                ]
                            },
                            {
                                "_": [
                                    "Leather armor|phb",
                                    "dagger|phb"
                                ]
                            }
                        ]
                    },
                    "multiclassing": {
                        "requirements": {
                            "cha": 13
                        },
                        "proficienciesGained": {
                            "armor": [
                                "light"
                            ],
                            "skills": [
                                {
                                    "choose": {
                                        "from": [
                                            "athletics",
                                            "acrobatics",
                                            "sleight of hand",
                                            "stealth",
                                            "arcana",
                                            "history",
                                            "investigation",
                                            "nature",
                                            "religion",
                                            "animal handling",
                                            "insight",
                                            "medicine",
                                            "perception",
                                            "survival",
                                            "deception",
                                            "intimidation",
                                            "performance",
                                            "persuasion"
                                        ],
                                        "count": 1
                                    }
                                }
                            ],
                            "tools": [
                                "one {@item musical instrument|PHB} of your choice"
                            ],
                            "toolProficiencies": [
                                {
                                    "anyMusicalInstrument": 1
                                }
                            ]
                        }
                    },
                    "classTableGroups": [
                        {
                            "colLabels": [
                                "{@filter Cantrips Known|spells|level=0|class=bard}",
                                "{@filter Spells Known|spells|class=bard}"
                            ],
                            "rows": [
                                [
                                    2,
                                    4
                                ],
                                [
                                    2,
                                    5
                                ],
                                [
                                    2,
                                    6
                                ],
                                [
                                    3,
                                    7
                                ],
                                [
                                    3,
                                    8
                                ],
                                [
                                    3,
                                    9
                                ],
                                [
                                    3,
                                    10
                                ],
                                [
                                    3,
                                    11
                                ],
                                [
                                    3,
                                    12
                                ],
                                [
                                    4,
                                    14
                                ],
                                [
                                    4,
                                    15
                                ],
                                [
                                    4,
                                    15
                                ],
                                [
                                    4,
                                    16
                                ],
                                [
                                    4,
                                    18
                                ],
                                [
                                    4,
                                    19
                                ],
                                [
                                    4,
                                    19
                                ],
                                [
                                    4,
                                    20
                                ],
                                [
                                    4,
                                    22
                                ],
                                [
                                    4,
                                    22
                                ],
                                [
                                    4,
                                    22
                                ]
                            ]
                        },
                        {
                            "title": "Spell Slots per Spell Level",
                            "colLabels": [
                                "{@filter 1st|spells|level=1|class=bard}",
                                "{@filter 2nd|spells|level=2|class=bard}",
                                "{@filter 3rd|spells|level=3|class=bard}",
                                "{@filter 4th|spells|level=4|class=bard}",
                                "{@filter 5th|spells|level=5|class=bard}",
                                "{@filter 6th|spells|level=6|class=bard}",
                                "{@filter 7th|spells|level=7|class=bard}",
                                "{@filter 8th|spells|level=8|class=bard}",
                                "{@filter 9th|spells|level=9|class=bard}"
                            ],
                            "rowsSpellProgression": [
                                [
                                    2,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    3,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    2,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    2,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    1,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    2,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    1,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    1,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    1,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    1,
                                    1
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    3,
                                    1,
                                    1,
                                    1,
                                    1
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    1
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    3,
                                    2,
                                    2,
                                    1,
                                    1
                                ]
                            ]
                        }
                    ],
                    "classFeatures": [
                        "Bardic Inspiration|Bard||1",
                        "Spellcasting|Bard||1",
                        "Jack of All Trades|Bard||2",
                        "Song of Rest (d6)|Bard||2",
                        "Magical Inspiration|Bard||2|TCE",
                        {
                            "classFeature": "Bard College|Bard||3",
                            "gainSubclassFeature": true
                        },
                        "Expertise|Bard||3",
                        "Ability Score Improvement|Bard||4",
                        "Bardic Versatility|Bard||4|TCE",
                        "Bardic Inspiration (d8)|Bard||5",
                        "Font of Inspiration|Bard||5",
                        "Countercharm|Bard||6",
                        {
                            "classFeature": "Bard College feature|Bard||6",
                            "gainSubclassFeature": true
                        },
                        "Ability Score Improvement|Bard||8",
                        "Song of Rest (d8)|Bard||9",
                        "Bardic Inspiration (d10)|Bard||10",
                        "Expertise|Bard||10",
                        "Magical Secrets|Bard||10",
                        "Ability Score Improvement|Bard||12",
                        "Song of Rest (d10)|Bard||13",
                        "Magical Secrets|Bard||14",
                        {
                            "classFeature": "Bard College feature|Bard||14",
                            "gainSubclassFeature": true
                        },
                        "Bardic Inspiration (d12)|Bard||15",
                        "Ability Score Improvement|Bard||16",
                        "Song of Rest (d12)|Bard||17",
                        "Magical Secrets|Bard||18",
                        "Ability Score Improvement|Bard||19",
                        "Superior Inspiration|Bard||20"
                    ],
                    "subclassTitle": "Bard College",
                    "fluff": [
                        {
                            "name": "Bard",
                            "type": "section",
                            "entries": [
                                "Humming as she traces her fingers over an ancient monument in a long-forgotten ruin, a half-elf in rugged leathers finds knowledge springing into her mind, conjured forth by the magic of her song\u2014knowledge of the people who constructed the monument and the mythic saga it depicts.",
                                "A stern human warrior bangs his sword rhythmically against his scale mail, setting the tempo for his war chant and exhorting his companions to bravery and heroism. The magic of his song fortifies and emboldens them.",
                                "Laughing as she tunes her cittern, a gnome weaves her subtle magic over the assembled nobles, ensuring that her companions' words will be well received.",
                                "Whether scholar, skald, or scoundrel, a bard weaves magic through words and music to inspire allies, demoralize foes, manipulate minds, create illusions, and even heal wounds.",
                                {
                                    "type": "entries",
                                    "name": "Music and Magic",
                                    "entries": [
                                        "In the worlds of D&D, words and music are not just vibrations of air, but vocalizations with power all their own. The bard is a master of song, speech, and the magic they contain. Bards say that the multiverse was spoken into existence, that the words of the gods gave it shape, and that echoes of these primordial Words of Creation still resound throughout the cosmos. The music of bards is an attempt to snatch and harness those echoes, subtly woven into their spells and powers.",
                                        "The greatest strength of bards is their sheer versatility. Many bards prefer to stick to the sidelines in combat, using their magic to inspire their allies and hinder their foes from a distance. But bards are capable of defending themselves in melee if necessary, using their magic to bolster their swords and armor. Their spells lean toward charms and illusions rather than blatantly destructive spells. They have a wide-ranging knowledge of many subjects and a natural aptitude that lets them do almost anything well. Bards become masters of the talents they set their minds to perfecting, from musical performance to esoteric knowledge."
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "Learning from Experience",
                                    "entries": [
                                        "True bards are not common in the world. Not every minstrel singing in a tavern or jester cavorting in a royal court is a bard. Discovering the magic hidden in music requires hard study and some measure of natural talent that most troubadours and jongleurs lack. It can be hard to spot the difference between these performers and true bards, though. A bard's life is spent wandering across the land gathering lore, telling stories, and living on the gratitude of audiences, much like any other entertainer. But a depth of knowledge, a level of musical skill, and a touch of magic set bards apart from their fellows.",
                                        "Only rarely do bards settle in one place for long, and their natural desire to travel\u2014to find new tales to tell, new skills to learn, and new discoveries beyond the horizon\u2014makes an adventuring career a natural calling. Every adventure is an opportunity to learn, practice a variety of skills, enter long-forgotten tombs, discover lost works of magic, decipher old tomes, travel to strange places, or encounter exotic creatures. Bards love to accompany heroes to witness their deeds firsthand. A bard who can tell an awe-inspiring story from personal experience earns renown among other bards. Indeed, after telling so many stories about heroes accomplishing mighty deeds, many bards take these themes to heart and assume heroic roles themselves."
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "Creating a Bard",
                                    "entries": [
                                        "Bards thrive on stories, whether those stories are true or not. Your character's background and motivations are not as important as the stories that he or she tells about them. Perhaps you had a secure and mundane childhood. There's no good story to be told about that, so you might paint yourself as an orphan raised by a hag in a dismal swamp. Or your childhood might be worthy of a story. Some bards acquire their magical music through extraordinary means, including the inspiration of fey or other supernatural creatures.",
                                        "Did you serve an apprenticeship, studying under a master, following the more experienced bard until you were ready to strike out on your own? Or did you attend a college where you studied bardic lore and practiced your musical magic? Perhaps you were a young runaway or orphan, befriended by a wandering bard who became your mentor. Or you might have been a spoiled noble child tutored by a master. Perhaps you stumbled into the clutches of a hag, making a bargain for a musical gift in addition to your life and freedom, but at what cost?",
                                        {
                                            "type": "entries",
                                            "name": "Quick Build",
                                            "entries": [
                                                "You can make a bard quickly by following these suggestions. First, Charisma should be your highest ability score, followed by Dexterity. Second, choose the {@background entertainer} background. Third, choose the {@spell dancing lights} and {@spell vicious mockery} cantrips, along with the following 1st-level spells: {@spell charm person}, {@spell detect magic}, {@spell healing word}, and {@spell thunderwave}."
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "source": "PHB",
                            "page": 51
                        },
                        {
                            "type": "section",
                            "entries": [
                                {
                                    "type": "quote",
                                    "entries": [
                                        "Music is the fruit of the divine tree that vibrates with the Words of Creation. But the question I ask you is, can a bard go to the root of this tree? Can one tap into the source of that power? Ah, then what manner of music they would bring to this world!"
                                    ],
                                    "by": "Fletcher Danairia, master bard"
                                },
                                "Bards bring levity during grave times; they impart wisdom to offset ignorance; and they make the ridiculous seem sublime. Bards are preservers of ancient history, their songs and tales perpetuating the memory of great events down through time\u2014knowledge so important that it is memorized and passed along as oral history, to survive even when no written record remains.",
                                "It is also the bard's role to chronicle smaller and more contemporary events\u2014the stories of today's heroes, including their feats of valor as well as their less than impressive failures.",
                                "Of course, the world has many people who can carry a tune or tell a good story, and there's much more to any adventuring bard than a glib tongue and a melodious voice. Yet what truly sets bards apart from others\u2014and from one another\u2014are the style and substance of their performances.",
                                "To grab and hold the attention of an audience, bards are typically flamboyant and outgoing when they perform. The most famous of them are essentially the D&D world's equivalent of pop stars. If you're playing a bard, consider using one of your favorite musicians as a role model for your character.",
                                "You can add some unique aspects to your bard character by considering the suggestions that follow.",
                                {
                                    "type": "entries",
                                    "name": "Defining Work",
                                    "entries": [
                                        "Every successful bard is renowned for at least one piece of performance art, typically a song or a poem that is popular with everyone who hears it. These performances are spoken about for years by those who view them, and some spectators have had their lives forever changed because of the experience.",
                                        "If your character is just starting out, your ultimate defining work is likely in the future. But in order to make any sort of living at your profession, chances are you already have a piece or two in your repertoire that have proven to be audience pleasers.",
                                        {
                                            "type": "table",
                                            "caption": "Defining Work",
                                            "colLabels": [
                                                "{@dice d6}",
                                                "Defining Work"
                                            ],
                                            "colStyles": [
                                                "col-1 text-center",
                                                "col-11"
                                            ],
                                            "rows": [
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 1
                                                        }
                                                    },
                                                    "\"The Three Flambinis,\" a ribald song concerning mistaken identities and unfettered desire"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 2
                                                        }
                                                    },
                                                    "\"Waltz of the Myconids,\" an upbeat tune that children in particular enjoy"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 3
                                                        }
                                                    },
                                                    "\"Asmodeus's Golden Arse,\" a dramatic poem you claim was inspired by your personal visit to Avernus"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 4
                                                        }
                                                    },
                                                    "\"The Pirates of Luskan,\" your firsthand account of being kidnapped by sea reavers as a child"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 5
                                                        }
                                                    },
                                                    "\"A Hoop, Two Pigeons, and a Hell Hound,\" a subtle parody of an incompetent noble"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 6
                                                        }
                                                    },
                                                    "\"A Fool in the Abyss,\" a comedic poem about a jester's travels among demons"
                                                ]
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "Instrument",
                                    "entries": [
                                        "In a bard's quest for the ultimate performance and the highest acclaim, one's instrument is at least as important as one's vocal ability. The instrument's quality of manufacture is a critical factor, of course; the best ones make the best music, and some bards are continually on the lookout for an improvement. Perhaps just as important, though, is the instrument's own entertainment value; those that are bizarrely constructed or made of exotic materials are likely to leave a lasting impression on an audience.",
                                        "You might have an \"off the rack\" instrument, perhaps because it's all you can afford right now. Or, if your first instrument was gifted to you, it might be of a more elaborate sort. Are you satisfied with the instrument you have, or do you aspire to replace it with something truly distinctive?",
                                        {
                                            "type": "table",
                                            "caption": "Instrument",
                                            "colLabels": [
                                                "{@dice d6}",
                                                "Instrument"
                                            ],
                                            "colStyles": [
                                                "col-1 text-center",
                                                "col-11"
                                            ],
                                            "rows": [
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 1
                                                        }
                                                    },
                                                    "A masterfully crafted halfling fiddle"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 2
                                                        }
                                                    },
                                                    "A mithral {@item horn|PHB} made by elves"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 3
                                                        }
                                                    },
                                                    "A zither made with drow spider silk"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 4
                                                        }
                                                    },
                                                    "An orcish {@item drum|PHB}"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 5
                                                        }
                                                    },
                                                    "A wooden bullywug croak box"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 6
                                                        }
                                                    },
                                                    "A tinker's harp of gnomish design"
                                                ]
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "Embarrassment",
                                    "entries": [
                                        "Almost every bard has suffered at least one bad experience in front of an audience, and chances are you're no exception. No one becomes famous right away, after all; perhaps you had a few small difficulties early in your career, or maybe it took you a while to restore your reputation after one agonizing night when the fates conspired to bring about your theatrical ruin.",
                                        "The ways that a performance can go wrong are as varied as the fish in the sea. No matter what sort of disaster might occur, however, a bard has the courage and the confidence to rebound from it\u2014either pressing on with the show (if possible) or promising to come back tomorrow with a new performance that's guaranteed to please.",
                                        {
                                            "type": "table",
                                            "caption": "Embarrassment",
                                            "colLabels": [
                                                "{@dice d6}",
                                                "Embarrassment"
                                            ],
                                            "colStyles": [
                                                "col-1 text-center",
                                                "col-11"
                                            ],
                                            "rows": [
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 1
                                                        }
                                                    },
                                                    "The time when your comedic song, \"Big Tom's Hijinks\"\u2014which, by the way, you thought was brilliant\u2014did not go over well with Big Tom"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 2
                                                        }
                                                    },
                                                    "The matinee performance when a circus's owlbear got loose and terrorized the crowd"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 3
                                                        }
                                                    },
                                                    "When your opening song was your enthusiastic but universally hated rendition of \"Song of the Froghemoth\""
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 4
                                                        }
                                                    },
                                                    "The first and last public performance of \"Mirt, Man about Town\""
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 5
                                                        }
                                                    },
                                                    "The time on stage when your wig caught fire and you threw it down\u2014which set fire to the stage"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 6
                                                        }
                                                    },
                                                    "When you sat on your {@item lute|PHB} by mistake during the final stanza of \"Starlight Serenade\""
                                                ]
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "A Bard's Muse",
                                    "entries": [
                                        "Naturally, every bard has a repertoire of songs and stories. Some bards are generalists who can draw from a wide range of topics for each performance, and who take pride in their versatility. Others adopt a more personal approach to their art, driven by their attachment to a muse\u2014a particular concept that inspires much of what those bards do in front of an audience.",
                                        "A bard who follows a muse generally does so to gain a deeper understanding of what that muse represents and how to best convey that understanding to others through performance.",
                                        "If your bard character has a muse, it could be one of the three described here, or one of your own devising.",
                                        {
                                            "type": "entries",
                                            "entries": [
                                                {
                                                    "type": "entries",
                                                    "name": "Nature",
                                                    "entries": [
                                                        "You feel a kinship with the natural world, and its beauty and mystery inspire you. For you, a tree is deeply symbolic, its roots delving into the dark unknown to draw forth the power of the earth, while its branches reach toward the sun to nourish their flowers and fruit. Nature is the ancient witness who has seen every kingdom rise and fall, even those whose names have been forgotten and wait to be rediscovered. The gods of nature share their secrets with druids and sages, opening their hearts and minds to new ways of seeing, and as with those individuals, you find that your creativity blossoms while you wander in an open field of waving grass or walk in silent reverence through a grove of ancient oaks."
                                                    ]
                                                },
                                                {
                                                    "type": "entries",
                                                    "name": "Love",
                                                    "entries": [
                                                        "You are on a quest to identify the essence of true love. Though you do not disdain the superficial love of flesh and form, the deeper form of love that can inspire thousands or bring joy to one's every moment is what you are interested in. Love of this sort takes on many forms, and you can see its presence everywhere\u2014from the sparkling of a beautiful gem to the song of a simple fisher thanking the sea for its bounty. You are on the trail of love, that most precious and mysterious of emotions, and your search fills your stories and your songs with vitality and passion."
                                                    ]
                                                },
                                                {
                                                    "type": "entries",
                                                    "name": "Conflict",
                                                    "entries": [
                                                        "Drama embodies conflict, and the best stories have conflict as a key element. From the morning-after tale of a tavern brawl to the saga of an epic battle, from a lover's spat to a rift between powerful dynasties, conflict is what inspires tale-tellers like you to create your best work. Conflict can bring out the best in some people, causing their heroic nature to shine forth and transform the world, but it can cause others to gravitate toward darkness and fall under the sway of evil. You strive to experience or witness all forms of conflict, great and small, so as to study this eternal aspect of life and immortalize it in your words and music."
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "source": "XGE",
                            "page": 12
                        }
                    ]
                }
            ],
            "subclass": [
                {
                    "name": "College of Lore",
                    "shortName": "Lore",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 54,
                    "srd": true,
                    "additionalSpells": [
                        {
                            "name": "Additional Magical Secrets",
                            "known": {
                                "6": [
                                    {
                                        "choose": "level=0;1;2;3"
                                    },
                                    {
                                        "choose": "level=0;1;2;3"
                                    }
                                ]
                            }
                        }
                    ],
                    "subclassFeatures": [
                        "College of Lore|Bard||Lore||3",
                        "Additional Magical Secrets|Bard||Lore||6",
                        "Peerless Skill|Bard||Lore||14"
                    ]
                },
                {
                    "name": "College of Valor",
                    "shortName": "Valor",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 55,
                    "subclassFeatures": [
                        "College of Valor|Bard||Valor||3",
                        "Extra Attack|Bard||Valor||6",
                        "Battle Magic|Bard||Valor||14"
                    ]
                },
                {
                    "name": "College of Glamour",
                    "shortName": "Glamour",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 14,
                    "additionalSpells": [
                        {
                            "innate": {
                                "6": [
                                    "command"
                                ]
                            }
                        }
                    ],
                    "subclassFeatures": [
                        "College of Glamour|Bard||Glamour|XGE|3",
                        "Mantle of Majesty|Bard||Glamour|XGE|6",
                        "Unbreakable Majesty|Bard||Glamour|XGE|14"
                    ]
                },
                {
                    "name": "College of Swords",
                    "shortName": "Swords",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 15,
                    "optionalfeatureProgression": [
                        {
                            "name": "Fighting Style",
                            "featureType": [
                                "FS:B"
                            ],
                            "progression": {
                                "3": 1
                            }
                        }
                    ],
                    "subclassFeatures": [
                        "College of Swords|Bard||Swords|XGE|3",
                        "Extra Attack|Bard||Swords|XGE|6",
                        "Master's Flourish|Bard||Swords|XGE|14"
                    ]
                },
                {
                    "name": "College of Whispers",
                    "shortName": "Whispers",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 16,
                    "subclassFeatures": [
                        "College of Whispers|Bard||Whispers|XGE|3",
                        "Mantle of Whispers|Bard||Whispers|XGE|6",
                        "Shadow Lore|Bard||Whispers|XGE|14"
                    ]
                },
                {
                    "name": "College of Creation",
                    "shortName": "Creation",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 28,
                    "subclassFeatures": [
                        "College of Creation|Bard||Creation|TCE|3",
                        "Animating Performance|Bard||Creation|TCE|6",
                        "Creative Crescendo|Bard||Creation|TCE|14"
                    ]
                },
                {
                    "name": "College of Eloquence",
                    "shortName": "Eloquence",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 29,
                    "otherSources": [
                        {
                            "source": "MOT",
                            "page": 28
                        }
                    ],
                    "subclassFeatures": [
                        "College of Eloquence|Bard||Eloquence|TCE|3",
                        "Unfailing Inspiration|Bard||Eloquence|TCE|6",
                        "Universal Speech|Bard||Eloquence|TCE|6",
                        "Infectious Inspiration|Bard||Eloquence|TCE|14"
                    ]
                },
                {
                    "name": "College of Spirits",
                    "shortName": "Spirits",
                    "source": "VRGR",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 28,
                    "additionalSpells": [
                        {
                            "known": {
                                "3": [
                                    "guidance#c"
                                ]
                            }
                        }
                    ],
                    "subclassFeatures": [
                        "College of Spirits|Bard||Spirits|VRGR|3",
                        "Spirit Session|Bard||Spirits|VRGR|6",
                        "Mystical Connection|Bard||Spirits|VRGR|14"
                    ]
                },
                {
                    "name": "College of Tragedy",
                    "shortName": "Tragedy",
                    "source": "TDCSR",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 167,
                    "subclassFeatures": [
                        "College of Tragedy|Bard|PHB|Tragedy|TDCSR|3",
                        "Tale of Hubris|Bard|PHB|Tragedy|TDCSR|6",
                        "Impending Misfortune|Bard|PHB|Tragedy|TDCSR|6",
                        "Tale of Hubris (14th Level)|Bard|PHB|Tragedy|TDCSR|14",
                        "Nimbus of Pathos|Bard|PHB|Tragedy|TDCSR|14"
                    ]
                }
            ],
            "classFeature": [
                {
                    "name": "Bardic Inspiration",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 1,
                    "entries": [
                        "You can inspire others through stirring words or music. To do so, you use a bonus action on your turn to choose one creature other than yourself within 60 feet of you who can hear you. That creature gains one Bardic Inspiration die, a {@dice d6}.",
                        "Once within the next 10 minutes, the creature can roll the die and add the number rolled to one ability check, attack roll, or saving throw it makes. The creature can wait until after it rolls the {@dice d20} before deciding to use the Bardic Inspiration die, but must decide before the DM says whether the roll succeeds or fails. Once the Bardic Inspiration die is rolled, it is lost. A creature can have only one Bardic Inspiration die at a time.",
                        "You can use this feature a number of times equal to your Charisma modifier (a minimum of once). You regain any expended uses when you finish a long rest.",
                        "Your Bardic Inspiration die changes when you reach certain levels in this class. The die becomes a {@dice d8} at 5th level, a {@dice d10} at 10th level, and a {@dice d12} at 15th level."
                    ]
                },
                {
                    "name": "Spellcasting",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 1,
                    "entries": [
                        "You have learned to untangle and reshape the fabric of reality in harmony with your wishes and music. Your spells are part of your vast repertoire, magic that you can tune to different situations. See {@book chapter 10|PHB|10} for the general rules of spellcasting and {@book chapter 11|PHB|11} for the {@filter bard spell list|spells|class=bard}.",
                        {
                            "type": "entries",
                            "name": "Cantrips",
                            "entries": [
                                "You know two cantrips of your choice from the bard spell list. You learn additional bard cantrips of your choice at higher levels, learning a 3rd cantrip at 4th level and a 4th at 10th level."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spell Slots",
                            "entries": [
                                "The Bard table shows how many spell slots you have to cast your {@filter bard spells|spells|class=bard} of 1st level and higher. To cast one of these spells, you must expend a slot of the spell's level or higher. You regain all expended spell slots when you finish a long rest.",
                                "For example, if you know the 1st-level spell {@spell cure wounds} and have a 1st-level and a 2nd-level spell slot available, you can cast {@spell cure wounds} using either slot."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells Known of 1st Level and Higher",
                            "entries": [
                                "You know four 1st-level spells of your choice from the bard spell list.",
                                "You learn an additional bard spell of your choice at each level except 12th, 16th, 19th, and 20th. Each of these spells must be of a level for which you have spell slots. For instance, when you reach 3rd level in this class, you can learn one new spell of 1st or 2nd level.",
                                "Additionally, when you gain a level in this class, you can choose one of the bard spells you know and replace it with another spell from the bard spell list, which also must be of a level for which you have spell slots."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spellcasting Ability",
                            "entries": [
                                "Charisma is your spellcasting ability for your bard spells. Your magic comes from the heart and soul you pour into the performance of your music or oration. You use your Charisma whenever a spell refers to your spellcasting ability. In addition, you use your Charisma modifier when setting the saving throw DC for a bard spell you cast and when making an attack roll with one.",
                                {
                                    "type": "abilityDc",
                                    "name": "Spell",
                                    "attributes": [
                                        "cha"
                                    ]
                                },
                                {
                                    "type": "abilityAttackMod",
                                    "name": "Spell",
                                    "attributes": [
                                        "cha"
                                    ]
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Ritual Casting",
                            "entries": [
                                "You can cast any bard spell you know as a ritual if that spell has the ritual tag."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spellcasting Focus",
                            "entries": [
                                "You can use a {@item musical instrument|PHB} as a spellcasting focus for your bard spells."
                            ]
                        }
                    ]
                },
                {
                    "name": "Jack of All Trades",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 2,
                    "entries": [
                        "Starting at 2nd level, you can add half your proficiency bonus, rounded down, to any ability check you make that doesn't already include your proficiency bonus."
                    ]
                },
                {
                    "name": "Magical Inspiration",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 2,
                    "isClassFeatureVariant": true,
                    "entries": [
                        "{@i 2nd-level bard {@variantrule optional class features|tce|optional feature}}",
                        "If a creature has a Bardic Inspiration die from you and casts a spell that restores hit points or deals damage, the creature can roll that die and choose a target affected by the spell. Add the number rolled as a bonus to the hit points regained or the damage dealt. The Bardic Inspiration die is then lost."
                    ]
                },
                {
                    "name": "Song of Rest (d6)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 2,
                    "entries": [
                        "Beginning at 2nd level, you can use soothing music or oration to help revitalize your wounded allies during a short rest. If you or any friendly creatures who can hear your performance regain hit points by spending Hit Dice at the end of the short rest, each of those creatures regains an extra {@dice 1d6} hit points.",
                        "The extra hit points increase when you reach certain levels in this class: to {@dice 1d8} at 9th level, to {@dice 1d10} at 13th level, and to {@dice 1d12} at 17th level."
                    ]
                },
                {
                    "name": "Bard College",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 3,
                    "entries": [
                        "At 3rd level, you delve into the advanced techniques of a bard college of your choice from the list of available colleges. Your choice grants you features at 3rd level and again at 6th and 14th level."
                    ]
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 3,
                    "entries": [
                        "At 3rd level, choose two of your skill proficiencies. Your proficiency bonus is doubled for any ability check you make that uses either of the chosen proficiencies.",
                        "At 10th level, you can choose another two skill proficiencies to gain this benefit."
                    ]
                },
                {
                    "name": "Ability Score Improvement",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 4,
                    "entries": [
                        "When you reach 4th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                        "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                    ]
                },
                {
                    "name": "Bardic Versatility",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 4,
                    "isClassFeatureVariant": true,
                    "entries": [
                        "{@i 4th-level bard {@variantrule optional class features|tce|optional feature}}",
                        "Whenever you reach a level in this class that grants the Ability Score Improvement feature, you can do one of the following, representing a change in focus as you use your skills and magic:",
                        {
                            "type": "list",
                            "items": [
                                "Replace one of the skills you chose for the Expertise feature with one of your other skill proficiencies that isn't benefiting from Expertise.",
                                "Replace one cantrip you learned from this class's Spellcasting feature with another cantrip from the {@filter bard spell list|spells|level=0|class=bard}."
                            ]
                        }
                    ]
                },
                {
                    "name": "Bardic Inspiration (d8)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 5,
                    "entries": [
                        "At 5th level, your Bardic Inspiration die changes to a {@dice d8}."
                    ]
                },
                {
                    "name": "Font of Inspiration",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 5,
                    "entries": [
                        "Beginning when you reach 5th level, you regain all of your expended uses of Bardic Inspiration when you finish a short or long rest."
                    ]
                },
                {
                    "name": "Bard College feature",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 6,
                    "entries": [
                        "At 6th level, you gain a feature from your Bard College."
                    ]
                },
                {
                    "name": "Countercharm",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 6,
                    "entries": [
                        "At 6th level, you gain the ability to use musical notes or words of power to disrupt mind-influencing effects. As an action, you can start a performance that lasts until the end of your next turn. During that time, you and any friendly creatures within 30 feet of you have advantage on saving throws against being {@condition frightened} or {@condition charmed}. A creature must be able to hear you to gain this benefit. The performance ends early if you are {@condition incapacitated} or silenced or if you voluntarily end it (no action required)."
                    ]
                },
                {
                    "name": "Ability Score Improvement",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 8,
                    "entries": [
                        "When you reach 8th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                        "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                    ]
                },
                {
                    "name": "Song of Rest (d8)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 9,
                    "entries": [
                        "At 9th level, the extra hit points gained from Song of Rest increases to {@dice 1d8}."
                    ]
                },
                {
                    "name": "Bardic Inspiration (d10)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 10,
                    "entries": [
                        "At 10th level, your Bardic Inspiration die changes to a {@dice d10}."
                    ]
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 10,
                    "entries": [
                        "At 10th level, you can choose another two skill proficiencies. Your proficiency bonus is doubled for any ability check you make that uses either of the chosen proficiencies."
                    ]
                },
                {
                    "name": "Magical Secrets",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 10,
                    "entries": [
                        "By 10th level, you have plundered magical knowledge from a wide spectrum of disciplines. Choose two spells from any classes, including this one. A spell you choose must be of a level you can cast, as shown on the Bard table, or a cantrip.",
                        "The chosen spells count as bard spells for you and are included in the number in the Spells Known column of the Bard table.",
                        "You learn two additional spells from any classes at 14th level and again at 18th level."
                    ]
                },
                {
                    "name": "Ability Score Improvement",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 12,
                    "entries": [
                        "When you reach 12th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                        "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                    ]
                },
                {
                    "name": "Song of Rest (d10)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 13,
                    "entries": [
                        "At 13th level, the extra hit points gained from Song of Rest increases to {@dice 1d10}."
                    ]
                },
                {
                    "name": "Bard College feature",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 14,
                    "entries": [
                        "At 14th level, you gain a feature from your Bard College."
                    ]
                },
                {
                    "name": "Magical Secrets",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 14,
                    "entries": [
                        "At 14th level, choose two additional spells from any classes, including this one. A spell you choose must be of a level you can cast, as shown on the Bard table, or a cantrip.",
                        "The chosen spells count as bard spells for you and are included in the number in the Spells Known column of the Bard table."
                    ]
                },
                {
                    "name": "Bardic Inspiration (d12)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 15,
                    "entries": [
                        "At 15th level, your Bardic Inspiration die changes to a {@dice d12}."
                    ]
                },
                {
                    "name": "Ability Score Improvement",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 16,
                    "entries": [
                        "When you reach 16th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                        "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                    ]
                },
                {
                    "name": "Song of Rest (d12)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 17,
                    "entries": [
                        "At 17th level, the extra hit points gained from Song of Rest increases to {@dice 1d12}."
                    ]
                },
                {
                    "name": "Magical Secrets",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 18,
                    "entries": [
                        "At 18th level, choose two additional spells from any class, including this one. A spell you choose must be of a level you can cast, as shown on the Bard table, or a cantrip.",
                        "The chosen spells count as bard spells for you and are included in the number in the Spells Known column of the Bard table."
                    ]
                },
                {
                    "name": "Ability Score Improvement",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 19,
                    "entries": [
                        "When you reach 19th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                        "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                    ]
                },
                {
                    "name": "Superior Inspiration",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 20,
                    "entries": [
                        "At 20th level, when you roll initiative and have no uses of Bardic Inspiration left, you regain one use."
                    ]
                }
            ],
            "subclassFeature": [
                {
                    "name": "College of Lore",
                    "source": "PHB",
                    "page": 54,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entries": [
                        "Bards of the College of Lore know something about most things, collecting bits of knowledge from sources as diverse as scholarly tomes and peasant tales. Whether singing folk ballads in taverns or elaborate compositions in royal courts, these bards use their gifts to hold audiences spellbound. When the applause dies down, the audience members might find themselves questioning everything they held to be true, from their faith in the priesthood of the local temple to their loyalty to the king.",
                        "The loyalty of these bards lies in the pursuit of beauty and truth, not in fealty to a monarch or following the tenets of a deity. A noble who keeps such a bard as a herald or advisor knows that the bard would rather be honest than politic.",
                        "The college's members gather in libraries and sometimes in actual colleges, complete with classrooms and dormitories, to share their lore with one another. They also meet at festivals or affairs of state, where they can expose corruption, unravel lies, and poke fun at self-important figures of authority.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Bonus Proficiencies|Bard||Lore||3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Cutting Words|Bard||Lore||3"
                        }
                    ]
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "page": 54,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Lore at 3rd level, you gain proficiency with three skills of your choice."
                    ]
                },
                {
                    "name": "Cutting Words",
                    "source": "PHB",
                    "page": 54,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "Also at 3rd level, you learn how to use your wit to distract, confuse, and otherwise sap the confidence and competence of others. When a creature that you can see within 60 feet of you makes an attack roll, an ability check, or a damage roll, you can use your reaction to expend one of your uses of Bardic Inspiration, rolling a Bardic Inspiration die and subtracting the number rolled from the creature's roll. You can choose to use this feature after the creature makes its roll, but before the DM determines whether the attack roll or ability check succeeds or fails, or before the creature deals its damage. The creature is immune if it can't hear you or if it's immune to being {@condition charmed}."
                    ]
                },
                {
                    "name": "Additional Magical Secrets",
                    "source": "PHB",
                    "page": 54,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "At 6th level, you learn two spells of your choice from any class. A spell you choose must be of a level you can cast, as shown on the Bard table, or a cantrip. The chosen spells count as bard spells for you but don't count against the number of bard spells you know."
                    ]
                },
                {
                    "name": "Peerless Skill",
                    "source": "PHB",
                    "page": 54,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "Starting at 14th level, when you make an ability check, you can expend one use of Bardic Inspiration. Roll a Bardic Inspiration die and add the number rolled to your ability check. You can choose to do so after you roll the die for the ability check, but before the DM tells you whether you succeed or fail."
                    ]
                },
                {
                    "name": "College of Valor",
                    "source": "PHB",
                    "page": 55,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entries": [
                        "Bards of the College of Valor are daring skalds whose tales keep alive the memory of the great heroes of the past, and thereby inspire a new generation of heroes. These bards gather in mead halls or around great bonfires to sing the deeds of the mighty, both past and present. They travel the land to witness great events firsthand and to ensure that the memory of those events doesn't pass from the world. With their songs, they inspire others to reach the same heights of accomplishment as the heroes of old.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Bonus Proficiencies|Bard||Valor||3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Combat Inspiration|Bard||Valor||3"
                        }
                    ]
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "page": 55,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Valor at 3rd level, you gain proficiency with medium armor, shields, and martial weapons."
                    ]
                },
                {
                    "name": "Combat Inspiration",
                    "source": "PHB",
                    "page": 55,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "Also at 3rd level, you learn to inspire others in battle. A creature that has a Bardic Inspiration die from you can roll that die and add the number rolled to a weapon damage roll it just made. Alternatively, when an attack roll is made against the creature, it can use its reaction to roll the Bardic Inspiration die and add the number rolled to its AC against that attack, after seeing the roll but before knowing whether it hits or misses."
                    ]
                },
                {
                    "name": "Extra Attack",
                    "source": "PHB",
                    "page": 55,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "Starting at 6th level, you can attack twice, instead of once, whenever you take the {@action Attack} action on your turn."
                    ]
                },
                {
                    "name": "Battle Magic",
                    "source": "PHB",
                    "page": 55,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "At 14th level, you have mastered the art of weaving spellcasting and weapon use into a single harmonious act. When you use your action to cast a bard spell, you can make one weapon attack as a bonus action."
                    ]
                },
                {
                    "name": "College of Creation",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entries": [
                        "Bards believe the cosmos is a work of art-the creation of the first dragons and gods. That creative work included harmonies that continue to resound through existence today, a power known as the Song of Creation. The bards of the College of Creation draw on that primeval song through dance, music, and poetry, and their teachers share this lesson:",
                        "\"Before the sun and the moon, there was the Song, and its music awoke the first dawn. Its melodies so delighted the stones and trees that some of them gained a voice of their own. And now they sing too. Learn the Song, students, and you too can teach the mountains to sing and dance.\"",
                        "Dwarves and gnomes often encourage their bards to become students of the Song of Creation. And among dragonborn, the Song of Creation is revered, for legends portray Bahamut and Tiamat-the greatest of dragons-as two of the song's first singers.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Mote of Potential|Bard||Creation|TCE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Performance of Creation|Bard||Creation|TCE|3"
                        }
                    ]
                },
                {
                    "name": "Mote of Potential",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Creation feature}",
                        "Whenever you give a creature a Bardic Inspiration die, you can utter a note from the Song of Creation to create a Tiny mote of potential, which orbits within 5 feet of that creature. The mote is intangible and invulnerable, and it lasts until the Bardic Inspiration die is lost. The mote looks like a musical note, a star, a flower, or another symbol of art or life that you choose.",
                        "When the creature uses the Bardic Inspiration die, the mote provides an additional effect based on whether the die benefits an ability check, an attack roll, or a saving throw, as detailed below:",
                        {
                            "type": "list",
                            "style": "list-hang-notitle",
                            "items": [
                                {
                                    "type": "item",
                                    "name": "Ability Check",
                                    "entry": "When the creature rolls the Bardic Inspiration die to add it to an ability check, the creature can roll the Bardic Inspiration die again and choose which roll to use, as the mote pops and emits colorful, harmless sparks for a moment."
                                },
                                {
                                    "type": "item",
                                    "name": "Attack Roll",
                                    "entry": "Immediately after the creature rolls the Bardic Inspiration die to add it to an attack roll against a target, the mote thunderously shatters. The target and each creature of your choice that you can see within 5 feet of it must succeed on a Constitution saving throw against your spell save DC or take thunder damage equal to the number rolled on the Bardic Inspiration die."
                                },
                                {
                                    "type": "item",
                                    "name": "Saving Throw",
                                    "entry": "Immediately after the creature rolls the Bardic Inspiration die and adds it to a saving throw, the mote vanishes with the sound of soft music, causing the creature to gain temporary hit points equal to the number rolled on the Bardic Inspiration die plus your Charisma modifier (minimum of 1 temporary hit point)."
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Performance of Creation",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Creation feature}",
                        "As an action, you can channel the magic of the Song of Creation to create one nonmagical item of your choice in an unoccupied space within 10 feet of you. The item must appear on a surface or in a liquid that can support it. The gp value of the item can't be more than 20 times your bard level, and the item must be Medium or smaller. The item glimmers softly, and a creature can faintly hear music when touching it. The created item disappears after a number of hours equal to your proficiency bonus. For examples of items you can create, see the equipment chapter of the {@book Player's Handbook|PHB|5}.",
                        "Once you create an item with this feature, you can't do so again until you finish a long rest, unless you expend a spell slot of 2nd level or higher to use this feature again. You can have only one item created by this feature at a time; if you use this action and already have an item from this feature, the first one immediately vanishes.",
                        "The size of the item you can create with this feature increases by one size category when you reach 6th level (Large) and 14th level (Huge)."
                    ]
                },
                {
                    "name": "Animating Performance",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "{@i 6th-level College of Creation feature}",
                        "As an action, you can animate one Large or smaller nonmagical item within 30 feet of you that isn't being worn or carried. The animate item uses the {@creature Dancing Item|TCE} stat block, which uses your proficiency bonus (PB). The item is friendly to you and your companions and obeys your commands. It lives for 1 hour, until it is reduced to 0 hit points, or until you die.",
                        "In combat, the item shares your initiative count, but it takes its turn immediately after yours. It can move and use its reaction on its own, but the only action it takes on its turn is the {@action Dodge} action, unless you take a bonus action on your turn to command it to take another action. That action can be one in its stat block or some other action. If you are {@condition incapacitated}, the item can take any action of its choice, not just {@action Dodge}.",
                        "When you use your Bardic Inspiration feature, you can command the item as part of the same bonus action you use for Bardic Inspiration.",
                        "Once you animate an item with this feature, you can't do so again until you finish a long rest, unless you expend a spell slot of 3rd level or higher to use this feature again. You can have only one item animated by this feature at a time; if you use this action and already have a {@creature dancing item|TCE} from this feature, the first one immediately becomes inanimate."
                    ]
                },
                {
                    "name": "Creative Crescendo",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "{@i 14th-level College of Creation feature}",
                        "When you use your Performance of Creation feature, you can create more than one item at once. The number of items equals your Charisma modifier (minimum of two items). If you create an item that would exceed that number, you choose which of the previously created items disappears. Only one of these items can be of the maximum size you can create; the rest must be Small or Tiny.",
                        "You are no longer limited by gp value when creating items with Performance of Creation."
                    ]
                },
                {
                    "name": "College of Eloquence",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entries": [
                        "Adherents of the College of Eloquence master the art of oratory. Persuasion is regarded as a high art, and a well-reasoned, well-spoken argument often proves more persuasive than facts. These bards wield a blend of logic and theatrical wordplay, winning over skeptics and detractors with logical arguments and plucking at heartstrings to appeal to the emotions of audiences.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Silver Tongue|Bard||Eloquence|TCE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Unsettling Words|Bard||Eloquence|TCE|3"
                        }
                    ]
                },
                {
                    "name": "Silver Tongue",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Eloquence feature}",
                        "You are a master at saying the right thing at the right time. When you make a Charisma ({@skill Persuasion}) or Charisma ({@skill Deception}) check, you can treat a {@dice d20} roll of 9 or lower as a 10."
                    ]
                },
                {
                    "name": "Unsettling Words",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Eloquence feature}",
                        "You can spin words laced with magic that unsettle a creature and cause it to doubt itself. As a bonus action, you can expend one use of your Bardic Inspiration and choose one creature you can see within 60 feet of you. Roll the Bardic Inspiration die. The creature must subtract the number rolled from the next saving throw it makes before the start of your next turn."
                    ]
                },
                {
                    "name": "Unfailing Inspiration",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "{@i 6th-level College of Eloquence feature}",
                        "Your inspiring words are so persuasive that others feel driven to succeed. When a creature adds one of your Bardic Inspiration dice to its ability check, attack roll, or saving throw and the roll fails, the creature can keep the Bardic Inspiration die."
                    ]
                },
                {
                    "name": "Universal Speech",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "{@i 6th-level College of Eloquence feature}",
                        "You have gained the ability to make your speech intelligible to any creature. As an action, choose one or more creatures within 60 feet of you, up to a number equal to your Charisma modifier (minimum of one creature). The chosen creatures can magically understand you, regardless of the language you speak, for 1 hour.",
                        "Once you use this feature, you can't use it again until you finish a long rest, unless you expend a spell slot to use it again."
                    ]
                },
                {
                    "name": "Infectious Inspiration",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "{@i 14th-level College of Eloquence feature}",
                        "When you successfully inspire someone, the power of your eloquence can now spread to someone else. When a creature within 60 feet of you adds one of your Bardic Inspiration dice to its ability check, attack roll, or saving throw and the roll succeeds, you can use your reaction to encourage a different creature (other than yourself) that can hear you within 60 feet of you, giving it a Bardic Inspiration die without expending any of your Bardic Inspiration uses.",
                        "You can use this reaction a number of times equal to your Charisma modifier (minimum of once), and you regain all expended uses when you finish a long rest."
                    ]
                },
                {
                    "name": "College of Tragedy",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 3,
                    "entries": [
                        "Not all grand stories conclude in triumphant victory. Many tales end with death and despair, and bards of the College of Tragedy know that sorrow and pathos are emotions just as potent as joy and delight. These bards specialize in the power of tragic storytelling, weaving words and spells together to dramatic and devastating effect.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Poetry in Misery|Bard|PHB|Tragedy|TDCSR|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Sorrowful Fate|Bard|PHB|Tragedy|TDCSR|3"
                        }
                    ]
                },
                {
                    "name": "Poetry in Misery",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Tragedy at 3rd level, you learn to harness the beauty in failure, finding inspiration in even the direst twists of fate. Whenever you or an ally within 30 feet of you rolls a 1 on the {@dice d20} for an attack roll, an ability check, or a {@quickref saving throws|PHB|2|1|saving throw}, you can use your reaction to soliloquize and regain one expended use of your Bardic Inspiration feature."
                    ]
                },
                {
                    "name": "Sorrowful Fate",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "Starting at 3rd level, you exploit a foe's peril to instill deep feelings of sorrow and doom. When you or an ally you can see forces a creature to make a {@quickref saving throws|PHB|2|1|saving throw}, you can expend one use of your Bardic Inspiration to change the type of {@quickref saving throws|PHB|2|1|saving throw} to a Charisma save instead.",
                        "If the target fails this save, roll a Bardic Inspiration die. The target takes psychic damage equal to the result, and is plagued with regret for 1 minute. If the target is reduced to 0 hit points during this time and can speak, they are magically compelled to utter darkly poetic final words before succumbing to their injuries.",
                        "Once you use this feature, you can't use it again until you finish a {@quickref resting|PHB|2|0|short or long rest}."
                    ]
                },
                {
                    "name": "Impending Misfortune",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "Also at 6th level, your words can twist the power of fate to create triumph from the promise of future despair. When you make an attack roll or a {@quickref saving throws|PHB|2|1|saving throw}, you can gain a +10 bonus to the roll, but the next attack roll or {@quickref saving throws|PHB|2|1|saving throw} you make takes a \u221210 penalty. If not used, this penalty disappears when you finish a {@quickref resting|PHB|2|0|short or long rest}.",
                        "You can't use this feature again until you finish a {@quickref resting|PHB|2|0|short or long rest}, or until you are reduced to 0 hit points."
                    ]
                },
                {
                    "name": "Tale of Hubris",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "At 6th level, you learn to weave a magical narrative that draws out the fatal arrogance of your foes. When a creature scores a critical hit against you or an ally within 60 feet of you that you can see, you can use your reaction and expend one use of your Bardic Inspiration to target the attacking creature and evoke the story of their downfall. For 1 minute or until the target suffers a critical hit, any weapon attack against the target scores a critical hit on a roll of 18\u201320."
                    ]
                },
                {
                    "name": "Nimbus of Pathos",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "Upon reaching 14th level, you can touch a willing creature as an action and empower it with tragic heroism. For 1 minute, the creature is surrounded by mournful music and ghostly singing, granting it the following benefits and drawbacks:",
                        {
                            "type": "list",
                            "items": [
                                "The creature has a +4 bonus to AC.",
                                "It has {@quickref Advantage and Disadvantage|PHB|2|0|advantage} on attack rolls and {@quickref saving throws|PHB|2|1}.",
                                "When the creature hits a target with a weapon attack or spell attack, that target takes an extra {@damage 1d10} radiant damage.",
                                "Any weapon attack against the creature scores a critical hit on a roll of 18\u201320."
                            ]
                        },
                        "When this effect ends, the creature immediately drops to 0 hit points and is dying. Once you use this feature, you can't use it again until you finish a {@quickref resting|PHB|2|0|long rest}."
                    ]
                },
                {
                    "name": "Tale of Hubris (14th Level)",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "At 14th level, the critical hit range of this feature increases to 17\u201320."
                    ]
                },
                {
                    "name": "College of Spirits",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "entries": [
                        "Bards of the College of Spirits seek tales with inherent power\u2014be they legends, histories, or fictions\u2014and bring their subjects to life. Using occult trappings, these bards conjure spiritual embodiments of powerful forces to change the world once more. Such spirits are capricious, though, and what a bard summons isn't always entirely under their control.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Guiding Whispers|Bard||Spirits|VRGR|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Spiritual Focus|Bard||Spirits|VRGR|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Tales from Beyond|Bard||Spirits|VRGR|3"
                        }
                    ]
                },
                {
                    "name": "Guiding Whispers",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Spirits feature}",
                        "You can reach out to spirits to guide you and others. You learn the {@spell guidance} cantrip, which doesn't count against the number of bard cantrips you know. For you, it has a range of 60 feet when you cast it."
                    ]
                },
                {
                    "name": "Spiritual Focus",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Spirits feature}",
                        "You employ tools that aid you in channeling spirits, be they historical figures or fictional archetypes. You can use the following objects as a spellcasting focus for your bard spells: a candle, crystal ball, skull, spirit board, or {@deck tarokka deck|CoS}.",
                        "Starting at 6th level, when you cast a bard spell that deals damage or restores hit points through the Spiritual Focus, roll a {@dice d6}, and you gain a bonus to one damage or healing roll of the spell equal to the number rolled."
                    ]
                },
                {
                    "name": "Tales from Beyond",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Spirits feature}",
                        "You reach out to spirits who tell their tales through you. While you are holding your Spiritual Focus, you can use a bonus action to expend one use of your Bardic Inspiration and roll on the Spirit Tales table using your Bardic Inspiration die to determine the tale the spirits direct you to tell. You retain the tale in mind until you bestow the tale's effect or you finish a short or long rest.",
                        "You can use an action to choose one creature you can see within 30 feet of you (this can be you) to be the target of the tale's effect. Once you do so, you can't bestow the tale's effect again until you roll it again.",
                        "You can retain only one of these tales in mind at a time, and rolling on the Spirit Tales table immediately ends the effect of the previous tale.",
                        "If the tale requires a saving throw, the DC equals your spell save DC.",
                        {
                            "type": "table",
                            "caption": "Spirit Tales",
                            "colLabels": [
                                "Bardic Insp. Die",
                                "Tale Told Through You"
                            ],
                            "colStyles": [
                                "col-2 text-center",
                                "col-10"
                            ],
                            "rows": [
                                [
                                    "1",
                                    "Tale of the Clever Animal. For the next 10 minutes, whenever the target makes an Intelligence, a Wisdom, or a Charisma check, the target can roll an extra die immediately after rolling the {@dice d20} and add the extra die's number to the check. The extra die is the same type as your Bardic Inspiration die."
                                ],
                                [
                                    "2",
                                    "Tale of the Renowned Duelist. You make a melee spell attack against the target. On a hit, the target takes force damage equal to two rolls of your Bardic Inspiration die + your Charisma modifier."
                                ],
                                [
                                    "3",
                                    "Tale of the Beloved Friends. The target and another creature of its choice it can see within 5 feet of it gains temporary hit points equal to a roll of your Bardic Inspiration die + your Charisma modifier."
                                ],
                                [
                                    "4",
                                    "Tale of the Runaway. The target can immediately use its reaction to teleport up to 30 feet to an unoccupied space it can see. When the target teleports, it can choose a number of creatures it can see within 30 feet of it up to your Charisma modifier (minimum of 0) to immediately use the same reaction."
                                ],
                                [
                                    "5",
                                    "Tale of the Avenger. For 1 minute, any creature that hits the target with a melee attack takes force damage equal to a roll of your Bardic Inspiration die."
                                ],
                                [
                                    "6",
                                    "Tale of the Traveler. The target gains temporary hit points equal to a roll of your Bardic Inspiration die + your bard level. While it has these temporary hit points, the target's walking speed increases by 10 feet and it gains a +1 bonus to its AC."
                                ],
                                [
                                    "7",
                                    "Tale of the Beguiler. The target must succeed on a Wisdom saving throw or take psychic damage equal to two rolls of your Bardic Inspiration die, and the target is {@condition incapacitated} until the end of its next turn."
                                ],
                                [
                                    "8",
                                    "Tale of the Phantom. The target becomes {@condition invisible} until the end of its next turn or until it hits a creature with an attack. If the target hits a creature with an attack during this invisibility, the creature it hits takes necrotic damage equal to a roll of your Bardic Inspiration die and is {@condition frightened} of the target until the end of the {@condition frightened} creature's next turn."
                                ],
                                [
                                    "9",
                                    "Tale of the Brute. Each creature of the target's choice it can see within 30 feet of it must make a Strength saving throw. On a failed save, a creature takes thunder damage equal to three rolls of your Bardic Inspiration die and is knocked {@condition prone}. A creature that succeeds on its saving throw takes half as much damage and isn't knocked {@condition prone}."
                                ],
                                [
                                    "10",
                                    "Tale of the Dragon. The target spews fire from the mouth in a 30-foot cone. Each creature in that area must make a Dexterity saving throw, taking fire damage equal to four rolls of your Bardic Inspiration die on a failed save, or half as much damage on a successful one."
                                ],
                                [
                                    "11",
                                    "Tale of the Angel. The target regains hit points equal to two rolls of your Bardic Inspiration die + your Charisma modifier, and you end one condition from the following list affecting the target: {@condition blinded}, {@condition deafened}, {@condition paralyzed}, {@condition petrified}, or {@condition poisoned}."
                                ],
                                [
                                    "12",
                                    "Tale of the Mind-Bender. You evoke an incomprehensible fable from an otherworldly being. The target must succeed on an Intelligence saving throw or take psychic damage equal to three rolls of your Bardic Inspiration die and be {@condition stunned} until the end of its next turn."
                                ]
                            ]
                        }
                    ]
                },
                {
                    "name": "Spirit Session",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "{@i 6th-level College of Spirits feature}",
                        "Spirits provide you with supernatural insights. You can conduct an hour-long ritual channeling spirits (which can be done during a short or long rest) using your Spiritual Focus. You can conduct the ritual with a number of willing creatures equal to your proficiency bonus (including yourself). At the end of the ritual, you temporarily learn {@filter one spell of your choice from any class|spells|school=d;n|level=0;1;2;3;4;5;6}.",
                        "The spell you choose must be of a level equal to the number of creatures that conducted the ritual or less, the spell must be of a level you can cast, and it must be in the school of divination or necromancy. The chosen spell counts as a bard spell for you but doesn't count against the number of bard spells you know.",
                        "Once you perform the ritual, you can't do so again until you start a long rest, and you know the chosen spell until you start a long rest."
                    ]
                },
                {
                    "name": "Mystical Connection",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "{@i 14th-level College of Spirits feature}",
                        "You now have the ability to nudge the spirits of Tales from Beyond toward certain tales. Whenever you roll on the Spirit Tales table, you can roll the die twice and choose which of the two effects to bestow. If you roll the same number on both dice, you can ignore the number and choose any effect on the table.",
                        {
                            "type": "inset",
                            "name": "Spirit Tales",
                            "entries": [
                                "Storytellers, like bards of the College of Spirits, often give voice to tales inspired by some greater theme or body of work. When determining what stories you tell, consider what unites them. Do they all feature characters from a specific group, like archetypes from the {@deck tarokka deck|CoS}, figures from constellations, childhood imaginary friends, or characters in a particular storybook? Or are your inspirations more general, incorporating historic champions, mythological heroes, or urban legends? Use the tales you tell to define your niche as a storytelling adventurer."
                            ]
                        }
                    ]
                },
                {
                    "name": "College of Glamour",
                    "source": "XGE",
                    "page": 14,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "The College of Glamour is the home of bards who mastered their craft in the vibrant realm of the Feywild or under the tutelage of someone who dwelled there. Tutored by satyrs, eladrin, and other fey, these bards learn to use their magic to delight and captivate others.",
                        "The bards of this college are regarded with a mixture of awe and fear. Their performances are the stuff of legend. These bards are so eloquent that a speech or song that one of them performs can cause captors to release the bard unharmed and can lull a furious dragon into complacency. The same magic that allows them to quell beasts can also bend minds. Villainous bards of this college can leech off a community for weeks, misusing their magic to turn their hosts into thralls. Heroic bards of this college instead use this power to gladden the downtrodden and undermine oppressors.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Mantle of Inspiration|Bard||Glamour|XGE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Enthralling Performance|Bard||Glamour|XGE|3"
                        }
                    ]
                },
                {
                    "name": "Enthralling Performance",
                    "source": "XGE",
                    "page": 14,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "Starting at 3rd level, you can charge your performance with seductive, fey magic.",
                        "If you perform for at least 1 minute, you can attempt to inspire wonder in your audience by singing, reciting a poem, or dancing. At the end of the performance, choose a number of humanoids within 60 feet of you who watched and listened to all of it, up to a number equal to your Charisma modifier (minimum of one). Each target must succeed on a Wisdom saving throw against your spell save DC or be {@condition charmed} by you. While {@condition charmed} in this way, the target idolizes you, it speaks glowingly of you to anyone who talks to it, and it hinders anyone who opposes you, although it avoids violence unless it was already inclined to fight on your behalf. This effect ends on a target after 1 hour, if it takes any damage, if you attack it, or if it witnesses you attacking or damaging any of its allies.",
                        "If a target succeeds on its saving throw, the target has no hint that you tried to charm it.",
                        "Once you use this feature, you can't use it again until you finish a short or long rest."
                    ]
                },
                {
                    "name": "Mantle of Inspiration",
                    "source": "XGE",
                    "page": 14,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Glamour at 3rd level, you gain the ability to weave a song of fey magic that imbues your allies with vigor and speed.",
                        "As a bonus action, you can expend one use of your Bardic Inspiration to grant yourself a wondrous appearance. When you do so, choose a number of creatures you can see and that can see you within 60 feet of you, up to a number equal to your Charisma modifier (minimum of one). Each of them gains 5 temporary hit points. When a creature gains these temporary hit points, it can immediately use its reaction to move up to its speed, without provoking opportunity attacks.",
                        "The number of temporary hit points increases when you reach certain levels in this class, increasing to 8 at 5th level, 11 at 10th level, and 14 at 15th level."
                    ]
                },
                {
                    "name": "Mantle of Majesty",
                    "source": "XGE",
                    "page": 14,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "At 6th level, you gain the ability to cloak yourself in a fey magic that makes others want to serve you. As a bonus action, you cast {@spell command}, without expending a spell slot, and you take on an appearance of unearthly beauty for 1 minute or until your {@status concentration} ends (as if you were {@status concentration||concentrating} on a spell). During this time, you can cast {@spell command} as a bonus action on each of your turns, without expending a spell slot.",
                        "Any creature {@condition charmed} by you automatically fails its saving throw against the {@spell command} you cast with this feature.",
                        "Once you use this feature, you can't use it again until you finish a long rest."
                    ]
                },
                {
                    "name": "Unbreakable Majesty",
                    "source": "XGE",
                    "page": 14,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "At 14th level, your appearance permanently gains an otherworldly aspect that makes you look more lovely and fierce.",
                        "In addition, as a bonus action, you can assume a magically majestic presence for 1 minute or until you are {@condition incapacitated}. For the duration, whenever any creature tries to attack you for the first time on a turn, the attacker must make a Charisma saving throw against your spell save DC. On a failed save, it can't attack you on this turn, and it must choose a new target for its attack or the attack is wasted. On a successful save, it can attack you on this turn, but it has disadvantage on any saving throw it makes against your spells on your next turn.",
                        "Once you assume this majestic presence, you can't do so again until you finish a short or long rest."
                    ]
                },
                {
                    "name": "College of Swords",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "Bards of the College of Swords are called blades, and they entertain through daring feats of weapon prowess. Blades perform stunts such as sword swallowing, knife throwing and juggling, and mock combats. Though they use their weapons to entertain, they are also highly trained and skilled warriors in their own right.",
                        "Their talent with weapons inspires many blades to lead double lives. One blade might use a circus troupe as cover for nefarious deeds such as assassination, robbery, and blackmail. Other blades strike at the wicked, bringing justice to bear against the cruel and powerful. Most troupes are happy to accept a blade's talent for the excitement it adds to a performance, but few entertainers fully trust a blade in their ranks.",
                        "Blades who abandon their lives as entertainers have often run into trouble that makes maintaining their secret activities impossible. A blade caught stealing or engaging in vigilante justice is too great a liability for most troupes. With their weapon skills and magic, these blades either take up work as enforcers for thieves' guilds or strike out on their own as adventurers.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Bonus Proficiencies|Bard||Swords|XGE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Fighting Style|Bard||Swords|XGE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Blade Flourish|Bard||Swords|XGE|3"
                        }
                    ]
                },
                {
                    "name": "Blade Flourish",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "At 3rd level, you learn to perform impressive displays of martial prowess and speed.",
                        "Whenever you take the {@action Attack} action on your turn, your walking speed increases by 10 feet until the end of the turn, and if a weapon attack that you make as part of this action hits a creature, you can use one of the following Blade Flourish options of your choice. You can use only one Blade Flourish option per turn.",
                        {
                            "type": "options",
                            "entries": [
                                {
                                    "type": "refSubclassFeature",
                                    "subclassFeature": "Defensive Flourish|Bard|XGE|Swords|XGE|3"
                                },
                                {
                                    "type": "refSubclassFeature",
                                    "subclassFeature": "Slashing Flourish|Bard|XGE|Swords|XGE|3"
                                },
                                {
                                    "type": "refSubclassFeature",
                                    "subclassFeature": "Mobile Flourish|Bard|XGE|Swords|XGE|3"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Swords at 3rd level, you gain proficiency with medium armor and the {@item scimitar|phb}.",
                        "If you're proficient with a simple or martial melee weapon, you can use it as a spellcasting focus for your bard spells."
                    ]
                },
                {
                    "name": "Fighting Style",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "At 3rd level, you adopt a style of fighting as your specialty. Choose one of the following options. You can't take a Fighting Style option more than once, even if something in the game lets you choose again.",
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Dueling"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Two-Weapon Fighting"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Extra Attack",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "Starting at 6th level, you can attack twice, instead of once, whenever you take the {@action Attack} action on your turn."
                    ]
                },
                {
                    "name": "Master's Flourish",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "Starting at 14th level, whenever you use a Blade Flourish option, you can roll a {@dice d6} and use it instead of expending a Bardic Inspiration die."
                    ]
                },
                {
                    "name": "College of Whispers",
                    "source": "XGE",
                    "page": 16,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "Most folk are happy to welcome a bard into their midst. Bards of the College of Whispers use this to their advantage. They appear to be like other bards, sharing news, singing songs, and telling tales to the audiences they gather. In truth, the College of Whispers teaches its students that they are wolves among sheep. These bards use their knowledge and magic to uncover secrets and turn them against others through extortion and threats.",
                        "Many other bards hate the College of Whispers, viewing it as a parasite that uses a bard's reputation to acquire wealth and power. For this reason, members of this college rarely reveal their true nature. They typically claim to follow some other college, or they keep their actual calling secret in order to infiltrate and exploit royal courts and other settings of power.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Psychic Blades|Bard||Whispers|XGE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Words of Terror|Bard||Whispers|XGE|3"
                        }
                    ]
                },
                {
                    "name": "Psychic Blades",
                    "source": "XGE",
                    "page": 16,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Whispers at 3rd level, you gain the ability to make your weapon attacks magically toxic to a creature's mind.",
                        "When you hit a creature with a weapon attack, you can expend one use of your Bardic Inspiration to deal an extra {@damage 2d6} psychic damage to that target. You can do so only once per round on your turn.",
                        "The psychic damage increases when you reach certain levels in this class, increasing to {@dice 3d6} at 5th level, {@dice 5d6} at 10th level, and {@dice 8d6} at 15th level."
                    ]
                },
                {
                    "name": "Words of Terror",
                    "source": "XGE",
                    "page": 16,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "At 3rd level, you learn to infuse innocent-seeming words with an insidious magic that can inspire terror.",
                        "If you speak to a humanoid alone for at least 1 minute, you can attempt to seed paranoia in its mind. At the end of the conversation, the target must succeed on a Wisdom saving throw against your spell save DC or be {@condition frightened} of you or another creature of your choice. The target is {@condition frightened} in this way for 1 hour, until it is attacked or damaged, or until it witnesses its allies being attacked or damaged.",
                        "If the target succeeds on its saving throw, the target has no hint that you tried to frighten it.",
                        "Once you use this feature, you can't use it again until you finish a short or long rest."
                    ]
                },
                {
                    "name": "Mantle of Whispers",
                    "source": "XGE",
                    "page": 16,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "At 6th level, you gain the ability to adopt a humanoid's persona. When a humanoid dies within 30 feet of you, you can magically capture its shadow using your reaction. You retain this shadow until you use it or you finish a long rest.",
                        "You can use the shadow as an action. When you do so, it vanishes, magically transforming into a disguise that appears on you. You now look like the dead person, but healthy and alive. This disguise lasts for 1 hour or until you end it as a bonus action.",
                        "While you're in the disguise, you gain access to all information that the humanoid would freely share with a casual acquaintance. Such information includes general details on its background and personal life, but doesn't include secrets. The information is enough that you can pass yourself off as the person by drawing on its memories.",
                        "Another creature can see through this disguise by succeeding on a Wisdom ({@skill Insight}) check contested by your Charisma ({@skill Deception}) check. You gain a +5 bonus to your check.",
                        "Once you capture a shadow with this feature, you can't capture another one with it until you finish a short or long rest."
                    ]
                },
                {
                    "name": "Shadow Lore",
                    "source": "XGE",
                    "page": 16,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "At 14th level, you gain the ability to weave dark magic into your words and tap into a creature's deepest fears.",
                        "As an action, you magically whisper a phrase that only one creature of your choice within 30 feet of you can hear. The target must make a Wisdom saving throw against your spell save DC. It automatically succeeds if it doesn't share a language with you or if it can't hear you. On a successful saving throw, your whisper sounds like unintelligible mumbling and has no effect.",
                        "On a failed saving throw, the target is {@condition charmed} by you for the next 8 hours or until you or your allies attack it, damage it, or force it to make a saving throw. It interprets the whispers as a description of its most mortifying secret. You gain no knowledge of this secret, but the target is convinced you know it.",
                        "The {@condition charmed} creature obeys your commands for fear that you will reveal its secret. It won't risk its life for you or fight for you, unless it was already inclined to do so. It grants you favors and gifts it would offer to a close friend.",
                        "When the effect ends, the creature has no understanding of why it held you in such fear.",
                        "Once you use this feature, you can't use it again until you finish a long rest."
                    ]
                },
                {
                    "name": "Defensive Flourish",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "XGE",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "You can expend one use of your Bardic Inspiration to cause the weapon to deal extra damage to the target you hit. The damage equals the number you roll on the Bardic Inspiration die. You also add the number rolled to your AC until the start of your next turn."
                    ]
                },
                {
                    "name": "Mobile Flourish",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "XGE",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "You can expend one use of your Bardic Inspiration to cause the weapon to deal extra damage to the target you hit. The damage equals the number you roll on the Bardic Inspiration die. You can also push the target up to 5 feet away from you, plus a number of feet equal to the number you roll on that die. You can then immediately use your reaction to move up to your walking speed to an unoccupied space within 5 feet of the target."
                    ]
                },
                {
                    "name": "Slashing Flourish",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "XGE",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "You can expend one use of your Bardic Inspiration to cause the weapon to deal extra damage to the target you hit and to any other creature of your choice that you can see within 5 feet of you. The damage equals the number you roll on the Bardic Inspiration die."
                    ]
                }
            ]
        }
        `;

        const races = String.raw`{
            "_meta": {
                "internalCopies": [
                    "race"
                ]
            },
            "race": [
                {
                    "name": "Aarakocra",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 20,
                        "fly": 50
                    },
                    "ability": [
                        {
                            "dex": 2,
                            "wis": 2
                        }
                    ],
                    "traitTags": [
                        "Natural Weapon",
                        "NPC Race"
                    ],
                    "languageProficiencies": [
                        {
                            "auran": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Dive Attack",
                            "entries": [
                                "If you are flying and dive at least 30 ft. straight toward a target and then hit it with a melee weapon attack, the attack deals an extra {@dice 1d6} damage to the target."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Talons",
                            "entries": [
                                "You are proficient with your unarmed strikes, which deal {@damage 1d4} slashing damage on a hit."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Language",
                            "entries": [
                                "You can speak, read, and write Auran."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Aarakocra",
                    "source": "EEPC",
                    "page": 5,
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 165
                        }
                    ],
                    "reprintedAs": [
                        "Aarakocra|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 25,
                        "fly": 50
                    },
                    "ability": [
                        {
                            "dex": 2,
                            "wis": 1
                        }
                    ],
                    "age": {
                        "mature": 3,
                        "max": 30
                    },
                    "traitTags": [
                        "Natural Weapon"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true,
                            "auran": true
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/aarakocra.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Aarakocra reach maturity by age 3. Compared to humans, aarakocra don't usually live longer than 30 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most aarakocra are good and rarely choose sides when it comes to law and chaos. Tribal leaders and warriors might be lawful, while explorers and adventurers might tend toward chaotic."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Aarakocra are about 5 feet tall. They have thin, lightweight bodies that weigh between 80 and 100 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Flight",
                            "entries": [
                                "You have a flying speed of 50 feet. To use this speed, you can't be wearing medium or heavy armor."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Talons",
                            "entries": [
                                "Your talons are natural weapons, which you can use to make unarmed strikes. If you hit with them, you deal slashing damage equal to {@damage 1d4} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Language",
                            "entries": [
                                "You can speak, read, and write Common, Aarakocra, and Auran."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Aarakocra",
                    "source": "MPMM",
                    "page": 5,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "fly": true
                    },
                    "traitTags": [
                        "Natural Weapon"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": [
                                    "gust of wind"
                                ]
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Flight",
                            "entries": [
                                "Because of your wings, you have a flying speed equal to your walking speed. You can't use this flying speed if you're wearing medium or heavy armor."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Talons",
                            "entries": [
                                "You have talons that you can use to make unarmed strikes. When you hit with them, the strike deals {@damage 1d6} + your Strength modifier slashing damage, instead of the bludgeoning damage normal for an unarmed strike."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Wind Caller",
                            "entries": [
                                "Starting at 3rd level, you can cast the {@spell gust of wind} spell with this trait, without requiring a material component. Once you cast the spell with this trait, you can't do so again until you finish a long rest. You can also cast the spell using any spell slots you have of 2nd level or higher.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for when you cast {@spell gust of wind} with this trait (choose when you select this race)."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Aasimar",
                    "source": "DMG",
                    "page": 286,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "wis": 1,
                            "cha": 2
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "darkvision": 60,
                    "languageProficiencies": [
                        {
                            "common": true,
                            "celestial": true
                        }
                    ],
                    "resist": [
                        "necrotic",
                        "radiant"
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/aasimar.mp3"
                    },
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "lesser restoration"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "daylight"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "light#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Aasimar mature at the same rate as humans but live a few years longer."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Aasimar are built like well-proportioned humans. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Thanks to your celestial heritage, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of grey."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Celestial Resistance",
                            "entries": [
                                "You have resistance to necrotic and radiant damage."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Celestial Legacy",
                            "entries": [
                                "You know the {@spell light} cantrip. Once you reach 3rd level, you can cast the {@spell lesser restoration} spell once with this trait, and you regain the ability to do so when you finish a long rest. Once you reach 5th level, you can cast the {@spell daylight} spell once with this trait, and you regain the ability to do so when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Language",
                            "entries": [
                                "You can speak, read, and write Common and Celestial."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Aasimar",
                    "source": "MPMM",
                    "page": 7,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "age": {
                        "max": 180
                    },
                    "darkvision": 60,
                    "resist": [
                        "necrotic",
                        "radiant"
                    ],
                    "additionalSpells": [
                        {
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "light#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Celestial Resistance",
                            "entries": [
                                "You have resistance to necrotic damage and radiant damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Healing Hands",
                            "entries": [
                                "As an action, you can touch a creature and roll a number of d4s equal to your proficiency bonus. The creature regains a number of hit points equal to the total rolled. Once you use this trait, you can't use it again until you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Light Bearer",
                            "entries": [
                                "You know the {@spell light} cantrip. Charisma is your spellcasting ability for it."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Celestial Revelation",
                            "entries": [
                                "When you reach 3rd level, choose one of the revelation options below. Thereafter, you can use a bonus action to unleash the celestial energy within yourself, gaining the benefits of that revelation. Your transformation lasts for 1 minute or until you end it as a bonus action. Once you transform using your revelation below, you can't use it again until you finish a long rest.",
                                {
                                    "type": "list",
                                    "items": [
                                        {
                                            "type": "item",
                                            "name": "Necrotic Shroud",
                                            "entry": "Your eyes briefly become pools of darkness, and ghostly, flightless wings sprout from your back temporarily. Creatures other than your allies within 10 feet of you that can see you must succeed on a Charisma saving throw (DC 8 + your proficiency bonus + your Charisma modifier) or become {@condition frightened} of you until the end of your next turn. Until the transformation ends, once on each of your turns, you can deal extra necrotic damage to one target when you deal damage to it with an attack or a spell. The extra damage equals your proficiency bonus."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Radiant Consumption",
                                            "entry": "Searing light temporarily radiates from your eyes and mouth. For the duration, you shed bright light in a 10-foot radius and dim light for an additional 10 feet, and at the end of each of your turns, each creature within 10 feet of you takes radiant damage equal to your proficiency bonus. Until the transformation ends, once on each of your turns, you can deal extra radiant damage to one target when you deal damage to it with an attack or a spell. The extra damage equals your proficiency bonus."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Radiant Soul",
                                            "entry": "Two luminous, spectral wings sprout from your back temporarily. Until the transformation ends, you have a flying speed equal to your walking speed, and once on each of your turns, you can deal extra radiant damage to one target when you deal damage to it with an attack or a spell. The extra damage equals your proficiency bonus."
                                        }
                                    ],
                                    "style": "list-hang-notitle"
                                }
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true,
                    "_versions": [
                        {
                            "name": "Aasimar; Necrotic Shroud",
                            "source": "MPMM",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Celestial Revelation",
                                    "items": {
                                        "name": "Celestial Revelation (Necrotic Shroud)",
                                        "type": "entries",
                                        "entries": [
                                            "When you reach 3rd level, you can use a bonus action to transform yourself. Your transformation lasts for 1 minute or until you end it as a bonus action. Once you transform using your revelation, you can't use it again until you finish a long rest.",
                                            "Your eyes briefly become pools of darkness, and ghostly, flightless wings sprout from your back temporarily. Creatures other than your allies within 10 feet of you that can see you must succeed on a Charisma saving throw (DC 8 + your proficiency bonus + your Charisma modifier) or become {@condition frightened} of you until the end of your next turn. Until the transformation ends, once on each of your turns, you can deal extra necrotic damage to one target when you deal damage to it with an attack or a spell. The extra damage equals your proficiency bonus."
                                        ]
                                    }
                                }
                            }
                        },
                        {
                            "name": "Aasimar; Radiant Consumption",
                            "source": "MPMM",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Celestial Revelation",
                                    "items": {
                                        "name": "Celestial Revelation (Radiant Consumption)",
                                        "type": "entries",
                                        "entries": [
                                            "When you reach 3rd level, you can use a bonus action to transform yourself. Your transformation lasts for 1 minute or until you end it as a bonus action. Once you transform using your revelation, you can't use it again until you finish a long rest.",
                                            "Searing light temporarily radiates from your eyes and mouth. For the duration, you shed bright light in a 10-foot radius and dim light for an additional 10 feet, and at the end of each of your turns, each creature within 10 feet of you takes radiant damage equal to your proficiency bonus. Until the transformation ends, once on each of your turns, you can deal extra radiant damage to one target when you deal damage to it with an attack or a spell. The extra damage equals your proficiency bonus."
                                        ]
                                    }
                                }
                            }
                        },
                        {
                            "name": "Aasimar; Radiant Soul",
                            "source": "MPMM",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Celestial Revelation",
                                    "items": {
                                        "name": "Celestial Revelation (Radiant Soul)",
                                        "type": "entries",
                                        "entries": [
                                            "When you reach 3rd level, you can use a bonus action to transform yourself. Your transformation lasts for 1 minute or until you end it as a bonus action. Once you transform using your revelation, you can't use it again until you finish a long rest.",
                                            "Two luminous, spectral wings sprout from your back temporarily. Until the transformation ends, you have a flying speed equal to your walking speed, and once on each of your turns, you can deal extra radiant damage to one target when you deal damage to it with an attack or a spell. The extra damage equals your proficiency bonus."
                                        ]
                                    }
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "Aasimar",
                    "source": "VGM",
                    "page": 104,
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 166
                        }
                    ],
                    "reprintedAs": [
                        "Aasimar|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "cha": 2
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 56,
                        "heightMod": "2d10",
                        "baseWeight": 110,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 160
                    },
                    "darkvision": 60,
                    "languageProficiencies": [
                        {
                            "common": true,
                            "celestial": true
                        }
                    ],
                    "resist": [
                        "necrotic",
                        "radiant"
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/aasimar.mp3"
                    },
                    "additionalSpells": [
                        {
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "light#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Aasimar mature at the same rate as humans, but they can live up to 160 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Aasimar have the same range of height and weight as humans."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Blessed with a radiant soul, your vision can easily cut through darkness. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Celestial Resistance",
                            "entries": [
                                "You have resistance to necrotic damage and radiant damage."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Healing Hands",
                            "entries": [
                                "As an action, you can touch a creature and cause it to regain a number of hit points equal to your level. Once you use this trait, you can't use it again until you finish a long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Light Bearer",
                            "entries": [
                                "You know the {@spell light} cantrip. Charisma is your spellcasting ability for it."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Celestial."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Aetherborn",
                    "source": "PSK",
                    "page": 17,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "cha": 2,
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "con",
                                    "int",
                                    "wis"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "age": {
                        "mature": 0,
                        "max": 3
                    },
                    "darkvision": 60,
                    "skillProficiencies": [
                        {
                            "intimidation": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "anyStandard": 2
                        }
                    ],
                    "resist": [
                        "necrotic"
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Aetherborn come into being as adults and live no more than a few years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "As a rule, aetherborn are driven by hedonism and self-interest, making them neutral at best and thoroughly evil at worst. Neutral aetherborn might devote much of their time (and wealth) to parties and social activity, while evil aetherborn are usually involved in the criminal underworld."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Aetherborn are about the same size as humans, ranging from 5 to 6 feet tall. They are quite light\u2014only about 100 pounds\u2014and their weight diminishes as they age and more and more of their substance returns to the aethersphere. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Thanks to your heritage, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Born of Aether",
                            "entries": [
                                "You have resistance to necrotic damage."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Menacing",
                            "entries": [
                                "You have proficiency in the {@skill Intimidation} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and two other languages of your choice."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "inset",
                            "name": "Gift of the Aetherborn",
                            "entries": [
                                "An unknown aetherborn, desperately seeking a means to extend their short life, discovered a process of transformation that prolonged their existence\u2014by giving them the ability to feed on the life essence of other beings. Since then, other aetherborn have learned and carried out this monstrous transformation, and aetherborn with this \"gift\" have become a small minority among an already small population.",
                                "A gifted aetherborn has the ability to drain the life essence of other beings. Similar to the way heat is transferred from a warm object to a cold one, a gifted aetherborn need only touch another living being with a clawed hand to draw life essence out, fueling their own continued existence while draining strength and vitality from their victim.",
                                "For many aetherborn, living as they do for indulgence and instant gratification, the concepts of \"want\" and \"need\" are virtually synonymous. But Aetherborn with this gift understand what it is to truly need, for they develop a hunger for life essence that far exceeds any desires they might have felt before their transformation. A gifted aetherborn who abstains from this feeding deteriorates even more rapidly than other aetherborn, while enduring unspeakable agony caused by the deprivation of life energy.",
                                "At the DM's option, an aetherborn character can research methods of achieving this dark \"gift.\" The process is similar to inventing and manufacturing a rare magic item (see \"{@book Inventing and Manufacturing Devices|PS-K|1|Inventing and Manufacturing Devices}\" earlier in this document). But rather than aether, the process requires a variety of rare unguents and unusual ingredients that make up the cost of researching and undergoing the transformation.",
                                "An aetherborn with this gift gains the Drain Life ability: a natural attack that deals {@dice 1d6} necrotic damage and restores the same number of hit points to the aetherborn. However, if the aetherborn goes for 7 days without dealing this damage, their hit point maximum is reduced by {@dice 1d6} per week. This reduction can't be removed until the aetherborn has used their Drain Life ability and completed a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true,
                    "_versions": [
                        {
                            "name": "Variant; Gifted Aetherborn",
                            "source": "PSK",
                            "_mod": {
                                "entries": {
                                    "mode": "appendArr",
                                    "items": {
                                        "name": "Drain Life",
                                        "type": "entries",
                                        "entries": [
                                            "You gain a natural attack that deals {@dice 1d6} necrotic damage and restores the same number of hit points to you. However, if you goes for 7 days without dealing this damage, your hit point maximum is reduced by {@dice 1d6} per week. This reduction can't be removed until you have used your Drain Life ability and completed a long rest."
                                        ]
                                    }
                                }
                            },
                            "traitTags": [
                                "Natural Weapon"
                            ]
                        }
                    ]
                },
                {
                    "name": "Astral Elf",
                    "source": "AAG",
                    "page": 10,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "humanoid"
                    ],
                    "creatureTypeTags": [
                        "elf"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "age": {
                        "max": 750
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Improved Resting"
                    ],
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "known": {
                                "1": [
                                    "dancing lights#c"
                                ]
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            }
                        },
                        {
                            "known": {
                                "1": [
                                    "light#c"
                                ]
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            }
                        },
                        {
                            "known": {
                                "1": [
                                    "sacred flame#c"
                                ]
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Humanoid. You are also considered an elf for any prerequisite or effect that requires you to be an elf."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Astral Fire",
                            "entries": [
                                "You know one of the following cantrips of your choice: {@spell dancing lights}, {@spell light}, or {@spell sacred flame}. Intelligence, Wisdom, or Charisma is your spellcasting ability for it (choose when you select this race)."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of yourself as if it were bright light, and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition charmed} condition on yourself."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Keen Senses",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Starlight Step",
                            "entries": [
                                "As a bonus action, you can magically teleport up to 30 feet to an unoccupied space you can see. You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Astral Trance",
                            "entries": [
                                "You don't need to sleep, and magic can't put you to sleep. You can finish a long rest in 4 hours if you spend those hours in a trancelike meditation, during which you remain conscious.",
                                "Whenever you finish this trance, you gain proficiency in one skill of your choice and with one weapon or tool of your choice, selected from the {@book Player's Handbook|PHB}. You mystically acquire these proficiencies by drawing them from shared elven memory and the experiences of entities on the Astral Plane, and you retain them until you finish your next long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Autognome",
                    "source": "AAG",
                    "page": 11,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "construct"
                    ],
                    "size": [
                        "S"
                    ],
                    "speed": 30,
                    "traitTags": [
                        "Improved Resting",
                        "Natural Armor"
                    ],
                    "toolProficiencies": [
                        {
                            "any": 2
                        }
                    ],
                    "resist": [
                        "poison"
                    ],
                    "conditionImmune": [
                        "disease"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Construct."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Armored Casing",
                            "entries": [
                                "You are encased in thin metal or some other durable material. While you aren't wearing armor, your base Armor Class is 13 + your Dexterity modifier."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Built for Success",
                            "entries": [
                                "You can add a {@dice d4} to one attack roll, ability check, or saving throw you make, and you can do so after seeing the {@dice d20} roll but before the effects of the roll are resolved. You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Healing Machine",
                            "entries": [
                                "If the {@spell mending} spell is cast on you, you can spend a Hit Die, roll it, and regain a number of hit points equal to the roll plus your Constitution modifier (minimum of 1 hit point).",
                                "In addition, your creator designed you to benefit from several spells that preserve life but that normally don't affect Constructs: {@spell cure wounds}, {@spell healing word}, {@spell mass cure wounds}, {@spell mass healing word}, and {@spell spare the dying}."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Mechanical Nature",
                            "entries": [
                                "You have resistance to poison damage and immunity to disease, and you have advantage on saving throws against being {@condition paralyzed} or {@condition poisoned}. You don't need to eat, drink, or breathe."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Sentry's Rest",
                            "entries": [
                                "When you take a long rest, you spend at least 6 hours in an inactive, motionless state, instead of sleeping. In this state, you appear inert, but you remain conscious."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Specialized Design",
                            "entries": [
                                "You gain two tool proficiencies of your choice, selected from the {@book Player's Handbook|PHB}."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Aven",
                    "source": "PSA",
                    "page": 15,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 25,
                        "fly": 30
                    },
                    "ability": [
                        {
                            "dex": 2
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Like humans, aven reach adulthood in their late teens and can theoretically live into their 80s. Of course, most find a glorious (or inglorious) death long before that point."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most aven lean toward some form of neutrality. Ibis-headed aven, focused more on knowledge than any other virtue, are usually neutral. Hawk-headed aven are inclined toward lawful neutral."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Aven stand from 5 to 6 feet tall, but their bodies are slender and their bones are partially hollow to facilitate their flight. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Flight",
                            "entries": [
                                "You have a flying speed of 30 feet. You can't use your flying speed while you wear medium or heavy armor. (If your campaign uses the variant rule for encumbrance, you can't use your flying speed if you are encumbered.) "
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Aven."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Aven",
                    "source": "PSD",
                    "page": 6,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 25,
                        "fly": 30
                    },
                    "ability": [
                        {
                            "dex": 2,
                            "wis": 2
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Like humans, aven reach adulthood in their late teens and can live into their 80s."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Aven are inclined toward the lawful good alignment of the Church of Serra"
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Aven stand from 5 to 6 feet tall, but their bodies are slender and their bones are partially hollow to facilitate their flight. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Flight",
                            "entries": [
                                "You have a flying speed of 30 feet. You can't use your flying speed while you wear medium or heavy armor. (If your campaign uses the variant rule for {@variantrule encumbrance|PHB}, you can't use your flying speed if you are encumbered.) "
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and {@language Aven|PSD}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Hawkeyed",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill. In addition, attacking at long range doesn't impose disadvantage on your ranged weapon attack rolls."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Bugbear",
                    "source": "ERLW",
                    "page": 25,
                    "reprintedAs": [
                        "Bugbear|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "dex": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 72,
                        "heightMod": "2d12",
                        "baseWeight": 200,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 16,
                        "max": 80
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Monstrous Race",
                        "Powerful Build"
                    ],
                    "skillProficiencies": [
                        {
                            "stealth": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "goblin": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Bugbears reach adulthood at age 16 and live up to 80 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Bugbears live on the fringes of society even in Darguun, where they value self-sufficiency and violence. They are generally chaotic, organizing in loose tribes under charismatic and powerful leaders."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Long-Limbed",
                            "entries": [
                                "When you make a melee attack on your turn, your reach for it is 5 feet greater than normal."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Powerful Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Sneaky",
                            "entries": [
                                "You are proficient in the {@skill Stealth} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Surprise Attack",
                            "entries": [
                                "If you surprise a creature and hit it with an attack on your first turn in combat, the attack deals an extra {@dice 2d6} damage to it. You can use this trait only once per combat."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Goblin."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluffImages": true
                },
                {
                    "name": "Bugbear",
                    "source": "MPMM",
                    "page": 8,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "humanoid"
                    ],
                    "creatureTypeTags": [
                        "goblinoid"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "traitTags": [
                        "Powerful Build"
                    ],
                    "skillProficiencies": [
                        {
                            "stealth": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Humanoid. You are also considered a goblinoid for any prerequisite or effect that requires you to be a goblinoid."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition charmed} condition on yourself."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Long-Limbed",
                            "entries": [
                                "When you make a melee attack on your turn, your reach for it is 5 feet greater than normal."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Powerful Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Sneaky",
                            "entries": [
                                "You are proficient in the {@skill Stealth} skill. In addition, without squeezing, you can move through and stop in a space large enough for a Small creature."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Surprise Attack",
                            "entries": [
                                "If you hit a creature with an attack roll, the creature takes an extra {@damage 2d6} damage if it hasn't taken a turn yet in the current combat."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Bugbear",
                    "source": "VGM",
                    "page": 119,
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 174
                        }
                    ],
                    "reprintedAs": [
                        "Bugbear|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "dex": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 72,
                        "heightMod": "2d12",
                        "baseWeight": 200,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 16,
                        "max": 80
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Monstrous Race",
                        "Powerful Build"
                    ],
                    "skillProficiencies": [
                        {
                            "stealth": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "goblin": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Bugbears reach adulthood at age 16 and live up to 80 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Bugbears are between 6 and 8 feet tall and weigh between 250 and 350 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Long-Limbed",
                            "entries": [
                                "When you make a melee attack on your turn, your reach for it is 5 feet greater than normal."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Powerful Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Sneaky",
                            "entries": [
                                "You are proficient in the {@skill Stealth} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Surprise Attack",
                            "entries": [
                                "If you surprise a creature and hit it with an attack on your first turn in combat, the attack deals an extra {@dice 2d6} damage to it. You can use this trait only once per combat."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Goblin."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Bullywug",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 20,
                        "swim": 40
                    },
                    "ability": [
                        {
                            "int": -2,
                            "cha": -2
                        }
                    ],
                    "traitTags": [
                        "Amphibious",
                        "NPC Race"
                    ],
                    "languageProficiencies": [
                        {
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Amphibious",
                            "entries": [
                                "You can breathe air and water."
                            ]
                        },
                        {
                            "name": "Speak with Frogs and Toads",
                            "type": "entries",
                            "entries": [
                                "You can communicate simple concepts to frogs and toads when you speak in Bullywug."
                            ]
                        },
                        {
                            "name": "Swamp Camouflage",
                            "type": "entries",
                            "entries": [
                                "You have advantage on Dexterity ({@skill Stealth}) checks made to hide in swampy terrain."
                            ]
                        },
                        {
                            "name": "Standing Leap",
                            "type": "entries",
                            "entries": [
                                "Your long jump is up to 20 feet and your high jump is up to 10 feet, with or without a running start."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Bullywug."
                            ]
                        }
                    ]
                },
                {
                    "name": "Centaur",
                    "source": "GGR",
                    "page": 15,
                    "reprintedAs": [
                        "Centaur|MPMM"
                    ],
                    "creatureTypes": [
                        "fey"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 40,
                    "ability": [
                        {
                            "str": 2,
                            "wis": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 72,
                        "heightMod": "1d10",
                        "baseWeight": 600,
                        "weightMod": "2d12"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "traitTags": [
                        "Natural Weapon",
                        "Powerful Build"
                    ],
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "animal handling",
                                    "medicine",
                                    "nature",
                                    "survival"
                                ]
                            }
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "sylvan": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Centaurs mature and age at about the same rate as humans."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Centaurs are inclined toward neutrality. Those who join the Selesnya are more often neutral good, while those who join the Gruul are typically chaotic neutral."
                            ]
                        },
                        {
                            "name": "Size",
                            "entries": [
                                "Centaurs stand between 6 and 7 feet tall, with their equine bodies reaching about 4 feet at the withers. Your size is Medium."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fey",
                            "entries": [
                                "Your creature type is fey, rather than humanoid."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Charge",
                            "entries": [
                                "If you move at least 30 feet straight toward a target and then hit it with a melee weapon attack on the same turn, you can immediately follow that attack with a bonus action, making one attack against the target with your hooves."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Hooves",
                            "entries": [
                                "Your hooves are natural melee weapons, which you can use to make unarmed strikes. If you hit with them, you deal bludgeoning damage equal to {@damage 1d4} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Equine Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push or drag.",
                                "In addition, any climb that requires hands and feet is especially difficult for you because of your equine legs. When you make such a climb, each foot of movement costs you 4 extra feet, instead of the normal 1 extra foot."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Survivor",
                            "entries": [
                                "You have proficiency in one of the following skills of your choice: {@skill Animal Handling}, {@skill Medicine}, {@skill Nature}, or {@skill Survival}."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Sylvan. Sylvan is widely spoken in the Selesnya Conclave, for it is rich in vocabulary to describe natural phenomena and spiritual forces."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Centaur",
                    "source": "MOT",
                    "page": 18,
                    "reprintedAs": [
                        "Centaur|MPMM"
                    ],
                    "_copy": {
                        "name": "Centaur",
                        "source": "GGR",
                        "_mod": {
                            "entries": [
                                {
                                    "mode": "replaceArr",
                                    "replace": "Alignment",
                                    "items": {
                                        "name": "Alignment",
                                        "type": "entries",
                                        "entries": [
                                            "Centaurs are inclined toward neutrality. Lagonna centaurs tend to be more lawful, while Pheres centaurs are more often chaotic."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Size",
                                    "items": {
                                        "name": "Size",
                                        "type": "entries",
                                        "entries": [
                                            "Centaurs stand between 6 and 7 feet tall, with their equine bodies reaching about 4 feet at the withers. Pheres centaurs tend to be slightly larger than Lagonna centaurs. Your size is Medium."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Languages",
                                    "items": {
                                        "name": "Languages",
                                        "type": "entries",
                                        "entries": [
                                            "You can speak, read, and write Common and Sylvan."
                                        ]
                                    }
                                }
                            ]
                        }
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Centaur",
                    "source": "MPMM",
                    "page": 9,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "fey"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 40,
                    "traitTags": [
                        "Natural Weapon",
                        "Powerful Build"
                    ],
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "animal handling",
                                    "medicine",
                                    "nature",
                                    "survival"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Fey."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Charge",
                            "entries": [
                                "If you move at least 30 feet straight toward a target and then hit it with a melee weapon attack on the same turn, you can immediately follow that attack with a bonus action, making one attack against the target with your hooves."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Equine Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push or drag.",
                                "In addition, any climb that requires hands and feet is especially difficult for you because of your equine legs. When you make such a climb, each foot of movement costs you 4 extra feet instead of the normal 1 extra foot."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hooves",
                            "entries": [
                                "You have hooves that you can use to make unarmed strikes. When you hit with them, the strike deals {@damage 1d6} + your Strength modifier bludgeoning damage, instead of the bludgeoning damage normal for an unarmed strike."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Natural Affinity",
                            "entries": [
                                "Your fey connection to nature gives you an intuitive connection to the natural world and the animals within it. You therefore have proficiency in one of the following skills of your choice: {@skill Animal Handling}, {@skill Medicine}, {@skill Nature}, or {@skill Survival}."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Changeling",
                    "source": "ERLW",
                    "page": 17,
                    "reprintedAs": [
                        "Changeling|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "cha": 2,
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "con",
                                    "int",
                                    "wis"
                                ],
                                "count": 1
                            }
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 61,
                        "heightMod": "2d4",
                        "baseWeight": 115,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "deception",
                                    "insight",
                                    "intimidation",
                                    "persuasion"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "anyStandard": 2
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "entries": [
                                "Changelings mature slightly faster than humans but share a similar lifespan\u2014typically a century or less. While a changeling can transform to conceal their age, the effects of aging affect them similarly to humans."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Alignment",
                            "entries": [
                                "Changelings tend toward pragmatic neutrality, and few changelings embrace evil."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Your size is Medium."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shapechanger",
                            "entries": [
                                "As an action, you can change your appearance and your voice. You determine the specifics of the changes, including your coloration, hair length, and sex. You can also adjust your height and weight, but not so much that your size changes. You can make yourself appear as a member of another race, though none of your game statistics change. You can't duplicate the appearance of a creature you've never seen, and you must adopt a form that has the same basic arrangement of limbs that you have. Your clothing and equipment aren't changed by this trait.",
                                "You stay in the new form until you use an action to revert to your true form or until you die."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Changeling Instincts",
                            "entries": [
                                "You gain proficiency with two of the following skills of your choice: {@skill Deception}, {@skill Insight}, {@skill Intimidation}, and {@skill Persuasion}."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and two other languages of your choice."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Changeling",
                    "source": "MPMM",
                    "page": 10,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "fey"
                    ],
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "deception",
                                    "insight",
                                    "intimidation",
                                    "performance",
                                    "persuasion"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Fey."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Changeling Instincts",
                            "entries": [
                                "Thanks to your connection to the fey realm, you gain proficiency with two of the following skills of your choice: {@skill Deception}, {@skill Insight}, {@skill Intimidation}, {@skill Performance}, or {@skill Persuasion}."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shapechanger",
                            "entries": [
                                "As an action, you change your appearance and your voice. You determine the specifics of the changes, including your coloration, hair length, and sex. You can also adjust your height between Medium and Small. You can make yourself appear as a member of another race, though none of your game statistics change. You can't duplicate the appearance of an individual you've never seen, and you must adopt a form that has the same basic arrangement of limbs that you have. Your clothing and equipment aren't changed by this trait.",
                                "You stay in the new form until you use an action to revert to your true form or until you die."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Custom Lineage",
                    "source": "TCE",
                    "page": 8,
                    "lineage": true,
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "con",
                                    "int",
                                    "wis",
                                    "cha"
                                ],
                                "amount": 2
                            }
                        }
                    ],
                    "darkvision": 60,
                    "feats": [
                        {
                            "any": 1
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "any": 1
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "anyStandard": 1
                        }
                    ],
                    "entries": [
                        "Instead of choosing one of the game's races for your character at 1st level, you can use the following traits to represent your character's lineage, giving you full control over how your character's origin shaped them:",
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a humanoid. You determine your appearance and whether you resemble any of your kin."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Small or Medium (your choice)."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Feat",
                            "entries": [
                                "You gain one {@5etools feat|feats.html} of your choice for which you qualify."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Variable Trait",
                            "entries": [
                                "You gain one of the following options of your choice: (a) {@sense darkvision} with a range of 60 feet or (b) proficiency in one skill of your choice."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and one other language that you and your DM agree is appropriate for your character."
                            ]
                        },
                        "Your race is considered to be a Custom Lineage for any game feature that requires a certain race, such as elf or dwarf."
                    ],
                    "_versions": [
                        {
                            "name": "Custom Lineage; Darkvision",
                            "source": "TCE",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variable Trait",
                                    "items": {
                                        "name": "Variable Trait; Darkvision",
                                        "type": "entries",
                                        "entries": [
                                            "You gain {@sense darkvision} with a range of 60 feet."
                                        ]
                                    }
                                }
                            },
                            "skillProficiencies": null
                        },
                        {
                            "name": "Custom Lineage; Skill Proficiency",
                            "source": "TCE",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variable Trait",
                                    "items": {
                                        "name": "Variable Trait; Skill Proficiency",
                                        "type": "entries",
                                        "entries": [
                                            "You gain proficiency in one skill of your choice."
                                        ]
                                    }
                                }
                            },
                            "darkvision": null
                        }
                    ]
                },
                {
                    "name": "Deep Gnome",
                    "source": "MPMM",
                    "page": 11,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "humanoid"
                    ],
                    "creatureTypeTags": [
                        "gnome"
                    ],
                    "size": [
                        "S"
                    ],
                    "speed": 30,
                    "age": {
                        "max": 500
                    },
                    "darkvision": 120,
                    "traitTags": [
                        "Magic Resistance"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "disguise self"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "nondetection"
                                        ]
                                    }
                                }
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Humanoid. You are also considered a gnome for any prerequisite or effect that requires you to be a gnome."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 120 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Gift of the Svirfneblin",
                            "entries": [
                                "Starting at 3rd level, you can cast the {@spell disguise self} spell with this trait. Starting at 5th level, you can also cast the {@spell nondetection} spell with it, without requiring a material component. Once you cast either of these spells with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast these using spell slots you have of the appropriate level.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Gnomish Magic Resistance",
                            "entries": [
                                "You have advantage on Intelligence, Wisdom, and Charisma saving throws against spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Svirfneblin Camouflage",
                            "entries": [
                                "When you make a Dexterity ({@skill Stealth}) check, you can make the check with advantage. You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Dhampir",
                    "source": "VRGR",
                    "page": 16,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": {
                        "walk": 35,
                        "climb": true
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Natural Weapon"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you gain this lineage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Ancestral Legacy",
                            "entries": [
                                "If you replace a race with this lineage, you can keep the following elements of that race: any skill proficiencies you gained from it and any climbing, flying, or swimming speed you gained from it.",
                                "If you don't keep any of those elements or you choose this lineage at character creation, you gain proficiency in two skills of your choice."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Deathless Nature",
                            "entries": [
                                "You don't need to breathe."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spider Climb",
                            "entries": [
                                "You have a climbing speed equal to your walking speed. In addition, at 3rd level, you can move up, down, and across vertical surfaces and upside down along ceilings, while leaving your hands free."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Vampiric Bite",
                            "entries": [
                                "Your fanged bite is a natural weapon, which counts as a simple melee weapon with which you are proficient. You add your Constitution modifier, instead of your Strength modifier, to the attack and damage rolls when you attack with this bite. It deals {@damage 1d4} piercing damage on a hit. While you are missing half or more of your hit points, you have advantage on attack rolls you make with this bite.",
                                "When you attack with this bite and hit a creature that isn't a Construct or an Undead, you can empower yourself in one of the following ways of your choice:",
                                {
                                    "type": "list",
                                    "items": [
                                        "You regain hit points equal to the piercing damage dealt by the bite.",
                                        "You gain a bonus to the next ability check or attack roll you make; the bonus equals the piercing damage dealt by the bite"
                                    ]
                                },
                                "You can empower yourself with this bite a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Dragonborn",
                    "source": "PHB",
                    "page": 32,
                    "srd": true,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "cha": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 66,
                        "heightMod": "2d8",
                        "baseWeight": 175,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 15,
                        "max": 80
                    },
                    "traitTags": [
                        "Uncommon Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "draconic": true
                        }
                    ],
                    "resist": [
                        {
                            "choose": {
                                "from": [
                                    "acid",
                                    "cold",
                                    "fire",
                                    "lightning",
                                    "poison"
                                ]
                            }
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/dragonborn.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Young dragonborn grow quickly. They walk hours after hatching, attain the size and development of a 10-year-old human child by the age of 3, and reach adulthood by 15. They live to be around 80."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Dragonborn are taller and heavier than humans, standing well over 6 feet tall and averaging almost 250 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Draconic Ancestry",
                            "entries": [
                                "You have draconic ancestry. Choose one type of dragon from the Draconic Ancestry table. Your breath weapon and damage resistance are determined by the dragon type, as shown in the table.",
                                {
                                    "type": "table",
                                    "caption": "Draconic Ancestry",
                                    "colLabels": [
                                        "Dragon",
                                        "Damage Type",
                                        "Breath Weapon"
                                    ],
                                    "colStyles": [
                                        "col-3 text-center",
                                        "col-3 text-center",
                                        "col-6"
                                    ],
                                    "rows": [
                                        [
                                            "Black",
                                            "Acid",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Blue",
                                            "Lightning",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Brass",
                                            "Fire",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Bronze",
                                            "Lightning",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Copper",
                                            "Acid",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Gold",
                                            "Fire",
                                            "15 ft. cone (Dex. save)"
                                        ],
                                        [
                                            "Green",
                                            "Poison",
                                            "15 ft. cone (Con. save)"
                                        ],
                                        [
                                            "Red",
                                            "Fire",
                                            "15 ft. cone (Dex. save)"
                                        ],
                                        [
                                            "Silver",
                                            "Cold",
                                            "15 ft. cone (Con. save)"
                                        ],
                                        [
                                            "White",
                                            "Cold",
                                            "15 ft. cone (Con. save)"
                                        ]
                                    ]
                                }
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Breath Weapon",
                            "entries": [
                                "You can use your action to exhale destructive energy. Your draconic ancestry determines the size, shape, and damage type of the exhalation.",
                                "When you use your breath weapon, each creature in the area of the exhalation must make a saving throw, the type of which is determined by your draconic ancestry. The DC for this saving throw equals 8 + your Constitution modifier + your proficiency bonus. A creature takes {@dice 2d6} damage on a failed save, and half as much damage on a successful one. The damage increases to {@dice 3d6} at 6th level, {@dice 4d6} at 11th level, and {@dice 5d6} at 16th level.",
                                "After you use your breath weapon, you can't use it again until you complete a short or long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Damage Resistance",
                            "entries": [
                                "You have resistance to the damage type associated with your draconic ancestry."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Draconic. Draconic is thought to be one of the oldest languages and is often used in the study of magic. The language sounds harsh to most other creatures and includes numerous hard consonants and sibilants."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Dragonborn (Chromatic)",
                    "source": "FTD",
                    "page": 10,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "resist": [
                        {
                            "choose": {
                                "from": [
                                    "acid",
                                    "lightning",
                                    "poison",
                                    "fire",
                                    "cold"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Chromatic Ancestry",
                            "entries": [
                                "You have a chromatic dragon ancestor, granting you a special magical affinity. Choose one kind of dragon from the Chromatic Ancestry table. This determines the damage type for your other traits, as shown in the table.",
                                {
                                    "type": "table",
                                    "caption": "Chromatic Ancestry",
                                    "colLabels": [
                                        "Dragon",
                                        "Damage Type"
                                    ],
                                    "colStyles": [
                                        "col-6 text-center",
                                        "col-6 text-center"
                                    ],
                                    "rows": [
                                        [
                                            "Black",
                                            "Acid"
                                        ],
                                        [
                                            "Blue",
                                            "Lightning"
                                        ],
                                        [
                                            "Green",
                                            "Poison"
                                        ],
                                        [
                                            "Red",
                                            "Fire"
                                        ],
                                        [
                                            "White",
                                            "Cold"
                                        ]
                                    ]
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Breath Weapon",
                            "entries": [
                                "When you take the {@action Attack} action on your turn, you can replace one of your attacks with an exhalation of magical energy in a 30-foot line that is 5 feet wide. Each creature in that area must make a Dexterity saving throw (DC = 8 + your Constitution modifier + your proficiency bonus). On a failed save, the creature takes {@damage 1d10} damage of the type associated with your Chromatic Ancestry. On a successful save, it takes half as much damage. This damage increases by {@dice 1d10} when you reach 5th level ({@dice 2d10}), 11th level ({@dice 3d10}), and 17th level ({@dice 4d10}).",
                                "You can use your Breath Weapon a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Draconic Resistance",
                            "entries": [
                                "You have resistance to the damage type associated with your Chromatic Ancestry."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Chromatic Warding",
                            "entries": [
                                "Starting at 5th level, as an action, you can channel your draconic energy to protect yourself. For 1 minute, you become immune to the damage type associated with your Chromatic Ancestry. Once you use this trait, you can't do so again until you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true,
                    "_versions": [
                        {
                            "_template": {
                                "name": "Dragonborn (Chromatic; {{color}})",
                                "source": "FTD",
                                "_mod": {
                                    "entries": [
                                        {
                                            "mode": "removeArr",
                                            "names": "Chromatic Ancestry"
                                        },
                                        {
                                            "mode": "replaceArr",
                                            "replace": "Breath Weapon",
                                            "items": {
                                                "type": "entries",
                                                "name": "Breath Weapon",
                                                "entries": [
                                                    "When you take the {@action Attack} action on your turn, you can replace one of your attacks with an exhalation of magical energy in a 30-foot line that is 5 feet wide. Each creature in that area must make a Dexterity saving throw (DC = 8 + your Constitution modifier + your proficiency bonus). On a failed save, the creature takes {@damage 1d10} {{damageType}} damage. On a successful save, it takes half as much damage. This damage increases by {@dice 1d10} when you reach 5th level ({@dice 2d10}), 11th level ({@dice 3d10}), and 17th level ({@dice 4d10}).",
                                                    "You can use your Breath Weapon a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                                                ]
                                            }
                                        },
                                        {
                                            "mode": "replaceArr",
                                            "replace": "Draconic Resistance",
                                            "items": {
                                                "type": "entries",
                                                "name": "Draconic Resistance",
                                                "entries": [
                                                    "You have resistance to {{damageType}} damage."
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            "_implementations": [
                                {
                                    "_variables": {
                                        "color": "Black",
                                        "damageType": "acid"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Blue",
                                        "damageType": "lightning"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Green",
                                        "damageType": "poison"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Red",
                                        "damageType": "fire"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "White",
                                        "damageType": "cold"
                                    }
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Dragonborn (Gem)",
                    "source": "FTD",
                    "page": 11,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "resist": [
                        {
                            "choose": {
                                "from": [
                                    "force",
                                    "radiant",
                                    "psychic",
                                    "thunder",
                                    "necrotic"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Gem Ancestry",
                            "entries": [
                                "You have a gem dragon ancestor, granting you a special magical affinity. Choose one kind of dragon from the Gem Ancestry table. This determines the damage type for your other traits, as shown in the table.",
                                {
                                    "type": "table",
                                    "caption": "Gem Ancestry",
                                    "colLabels": [
                                        "Dragon",
                                        "Damage Type"
                                    ],
                                    "colStyles": [
                                        "col-6 text-center",
                                        "col-6 text-center"
                                    ],
                                    "rows": [
                                        [
                                            "Amethyst",
                                            "Force"
                                        ],
                                        [
                                            "Crystal",
                                            "Radiant"
                                        ],
                                        [
                                            "Emerald",
                                            "Psychic"
                                        ],
                                        [
                                            "Sapphire",
                                            "Thunder"
                                        ],
                                        [
                                            "Topaz",
                                            "Necrotic"
                                        ]
                                    ]
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Breath Weapon",
                            "entries": [
                                "When you take the {@action Attack} action on your turn, you can replace one of your attacks with an exhalation of magical energy in a 15-foot cone. Each creature in that area must make a Dexterity saving throw (DC = 8 + your Constitution modifier + your proficiency bonus). On a failed save, the creature takes {@damage 1d10} damage of the type associated with your Gem Ancestry. On a successful save, it takes half as much damage. This damage increases by {@dice 1d10} when you reach 5th level ({@dice 2d10}), 11th level ({@dice 3d10}), and 17th level ({@dice 4d10}).",
                                "You can use your Breath Weapon a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Draconic Resistance",
                            "entries": [
                                "You have resistance to the damage type associated with your Gem Ancestry."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Psionic Mind",
                            "entries": [
                                "You can send telepathic messages to any creature you can see within 30 feet of you. You don't need to share a language with the creature for it to understand these messages, but it must be able to understand at least one language to comprehend them."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Gem Flight",
                            "entries": [
                                "Starting at 5th level, you can use a bonus action to manifest spectral wings on your body. These wings last for 1 minute. For the duration, you gain a flying speed equal to your walking speed and can hover. Once you use this trait, you can't do so again until you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true,
                    "_versions": [
                        {
                            "_template": {
                                "name": "Dragonborn (Gem; {{color}})",
                                "source": "FTD",
                                "_mod": {
                                    "entries": [
                                        {
                                            "mode": "removeArr",
                                            "names": "Gem Ancestry"
                                        },
                                        {
                                            "mode": "replaceArr",
                                            "replace": "Breath Weapon",
                                            "items": {
                                                "type": "entries",
                                                "name": "Breath Weapon",
                                                "entries": [
                                                    "When you take the {@action Attack} action on your turn, you can replace one of your attacks with an exhalation of magical energy in a 15-foot cone. Each creature in that area must make a Dexterity saving throw (DC = 8 + your Constitution modifier + your proficiency bonus). On a failed save, the creature takes {@damage 1d10} {{damageType}} damage. On a successful save, it takes half as much damage. This damage increases by {@dice 1d10} when you reach 5th level ({@dice 2d10}), 11th level ({@dice 3d10}), and 17th level ({@dice 4d10}).",
                                                    "You can use your Breath Weapon a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                                                ]
                                            }
                                        },
                                        {
                                            "mode": "replaceArr",
                                            "replace": "Draconic Resistance",
                                            "items": {
                                                "type": "entries",
                                                "name": "Draconic Resistance",
                                                "entries": [
                                                    "You have resistance to {{damageType}} damage."
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            "_implementations": [
                                {
                                    "_variables": {
                                        "color": "Amethyst",
                                        "damageType": "force"
                                    },
                                    "resist": [
                                        "force"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Crystal",
                                        "damageType": "radiant"
                                    },
                                    "resist": [
                                        "radiant"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Emerald",
                                        "damageType": "psychic"
                                    },
                                    "resist": [
                                        "psychic"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Sapphire",
                                        "damageType": "thunder"
                                    },
                                    "resist": [
                                        "thunder"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Topaz",
                                        "damageType": "necrotic"
                                    },
                                    "resist": [
                                        "necrotic"
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Dragonborn (Metallic)",
                    "source": "FTD",
                    "page": 12,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "resist": [
                        {
                            "choose": {
                                "from": [
                                    "fire",
                                    "lightning",
                                    "acid",
                                    "cold"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Metallic Ancestry",
                            "entries": [
                                "You have a metallic dragon ancestor, granting you a special magical affinity. Choose one kind of dragon from the Metallic Ancestry table. This determines the damage type for your other traits, as shown in the table.",
                                {
                                    "type": "table",
                                    "caption": "Metallic Ancestry",
                                    "colLabels": [
                                        "Dragon",
                                        "Damage Type"
                                    ],
                                    "colStyles": [
                                        "col-6 text-center",
                                        "col-6 text-center"
                                    ],
                                    "rows": [
                                        [
                                            "Brass",
                                            "Fire"
                                        ],
                                        [
                                            "Bronze",
                                            "Lightning"
                                        ],
                                        [
                                            "Copper",
                                            "Acid"
                                        ],
                                        [
                                            "Gold",
                                            "Fire"
                                        ],
                                        [
                                            "Silver",
                                            "Cold"
                                        ]
                                    ]
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Breath Weapon",
                            "entries": [
                                "When you take the {@action Attack} action on your turn, you can replace one of your attacks with an exhalation of magical energy in a 15-foot cone. Each creature in that area must make a Dexterity saving throw (DC = 8 + your Constitution modifier + your proficiency bonus). On a failed save, the creature takes {@damage 1d10} damage of the type associated with your Metallic Ancestry. On a successful save, it takes half as much damage. This damage increases by {@dice 1d10} when you reach 5th level ({@dice 2d10}), 11th level ({@dice 3d10}), and 17th level ({@dice 4d10}).",
                                "You can use your Breath Weapon a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Draconic Resistance",
                            "entries": [
                                "You have resistance to the damage type associated with your Metallic Ancestry."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Metallic Breath Weapon",
                            "entries": [
                                "At 5th level, you gain a second breath weapon. When you take the {@action Attack} action on your turn, you can replace one of your attacks with an exhalation in a 15-foot cone. The save DC for this breath is 8 + your Constitution modifier + your proficiency bonus. Whenever you use this trait, choose one:",
                                {
                                    "type": "list",
                                    "style": "list-hang-notitle",
                                    "items": [
                                        {
                                            "type": "item",
                                            "name": "Enervating Breath",
                                            "entries": [
                                                "Each creature in the cone must succeed on a Constitution saving throw or become {@condition incapacitated} until the start of your next turn."
                                            ]
                                        },
                                        {
                                            "type": "item",
                                            "name": "Repulsion Breath",
                                            "entries": [
                                                "Each creature in the cone must succeed on a Strength saving throw or be pushed 20 feet away from you and be knocked {@condition prone}."
                                            ]
                                        }
                                    ]
                                },
                                "Once you use your Metallic Breath Weapon, you can't do so again until you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true,
                    "_versions": [
                        {
                            "_template": {
                                "name": "Dragonborn (Metallic; {{color}})",
                                "source": "FTD",
                                "_mod": {
                                    "entries": [
                                        {
                                            "mode": "removeArr",
                                            "names": "Metallic Ancestry"
                                        },
                                        {
                                            "mode": "replaceArr",
                                            "replace": "Breath Weapon",
                                            "items": {
                                                "type": "entries",
                                                "name": "Breath Weapon",
                                                "entries": [
                                                    "When you take the {@action Attack} action on your turn, you can replace one of your attacks with an exhalation of magical energy in a 15-foot cone. Each creature in that area must make a Dexterity saving throw (DC = 8 + your Constitution modifier + your proficiency bonus). On a failed save, the creature takes {@damage 1d10} {{damageType}} damage. On a successful save, it takes half as much damage. This damage increases by {@dice 1d10} when you reach 5th level ({@dice 2d10}), 11th level ({@dice 3d10}), and 17th level ({@dice 4d10}).",
                                                    "You can use your Breath Weapon a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                                                ]
                                            }
                                        },
                                        {
                                            "mode": "replaceArr",
                                            "replace": "Draconic Resistance",
                                            "items": {
                                                "type": "entries",
                                                "name": "Draconic Resistance",
                                                "entries": [
                                                    "You have resistance to {{damageType}} damage."
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            "_implementations": [
                                {
                                    "_variables": {
                                        "color": "Brass",
                                        "damageType": "fire"
                                    },
                                    "resist": [
                                        "fire"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Bronze",
                                        "damageType": "lightning"
                                    },
                                    "resist": [
                                        "lightning"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Copper",
                                        "damageType": "acid"
                                    },
                                    "resist": [
                                        "acid"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Gold",
                                        "damageType": "fire"
                                    },
                                    "resist": [
                                        "fire"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Silver",
                                        "damageType": "cold"
                                    },
                                    "resist": [
                                        "cold"
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Duergar",
                    "source": "MPMM",
                    "page": 12,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "humanoid"
                    ],
                    "creatureTypeTags": [
                        "dwarf"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "age": {
                        "max": 350
                    },
                    "darkvision": 120,
                    "resist": [
                        "poison"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "enlarge/reduce"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "invisibility"
                                        ]
                                    }
                                }
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Humanoid. You are also considered a dwarf for any prerequisite or effect that requires you to be a dwarf."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 120 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Duergar Magic",
                            "entries": [
                                "Starting at 3rd level, you can cast the {@spell enlarge/reduce} spell on yourself with this trait, without requiring a material component. Starting at 5th level, you can also cast the {@spell invisibility} spell on yourself with this trait, without requiring a material component. Once you cast either of these spells with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast these spells using spell slots you have of the appropriate level.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Dwarven Resilience",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition poisoned} condition on yourself. You also have resistance to poison damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Psionic Fortitude",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition charmed} or {@condition stunned} condition on yourself."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Dwarf",
                    "source": "PHB",
                    "page": 18,
                    "srd": true,
                    "basicRules": true,
                    "size": [
                        "M"
                    ],
                    "speed": 25,
                    "ability": [
                        {
                            "con": 2
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 350
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Tool Proficiency"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "dwarvish": true
                        }
                    ],
                    "weaponProficiencies": [
                        {
                            "battleaxe|phb": true,
                            "handaxe|phb": true,
                            "light hammer|phb": true,
                            "warhammer|phb": true
                        }
                    ],
                    "resist": [
                        "poison"
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/dwarf.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Dwarves mature at the same rate as humans, but they're considered young until they reach the age of 50. On average, they live about 350 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Dwarves stand between 4 and 5 feet tall and average about 150 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Speed",
                            "entries": [
                                "Your speed is not reduced by wearing heavy armor."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Accustomed to life underground, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Dwarven Resilience",
                            "entries": [
                                "You have advantage on saving throws against poison, and you have resistance against poison damage."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Dwarven Combat Training",
                            "entries": [
                                "You have proficiency with the {@item battleaxe|phb}, {@item handaxe|phb}, {@item light hammer|phb}, and {@item warhammer|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Tool Proficiency",
                            "entries": [
                                "You gain proficiency with the artisan's tools of your choice: {@item Smith's tools|phb}, {@item brewer's supplies|phb}, or {@item mason's tools|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Stonecunning",
                            "entries": [
                                "Whenever you make an Intelligence ({@skill History}) check related to the origin of stonework, you are considered proficient in the {@skill History} skill and add double your proficiency bonus to the check, instead of your normal proficiency bonus."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Dwarvish. Dwarvish is full of hard consonants and guttural sounds, and those characteristics spill over into whatever other language a dwarf might speak."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Dwarf (Kaladesh)",
                    "source": "PSK",
                    "page": 19,
                    "size": [
                        "M"
                    ],
                    "speed": 25,
                    "ability": [
                        {
                            "con": 2,
                            "wis": 1
                        }
                    ],
                    "age": {
                        "mature": 50,
                        "max": 350
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Tool Proficiency"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "dwarvish": true
                        }
                    ],
                    "resist": [
                        "poison"
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Dwarves mature at the same rate as humans, but they're considered young until they reach the age of 50. On average, they live about 350 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most dwarves are lawful, believing firmly in the benefits of a well-ordered society. They tend toward good as well, with a strong sense of fair play and a belief that everyone deserves to share in the benefits of a just order."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Dwarves stand around 5 feet tall and average about 150 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Speed",
                            "entries": [
                                "Your base walking speed is 25 feet. Your speed is not reduced by wearing heavy armor."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Accustomed to life underground in your race's ancient past, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Dwarven Resilience",
                            "entries": [
                                "You have advantage on saving throws against poison, and you have resistance against poison damage."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Dwarven Toughness",
                            "entries": [
                                "Your hit point maximum increases by 1, and it increases by 1 every time you gain a level."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Artisan's Expertise",
                            "entries": [
                                "You gain proficiency with two kinds of {@filter artisan's tools|items|source=phb|miscellaneous=mundane|type=artisan's tools} of your choice. Your proficiency bonus is doubled for any ability check you make that uses either of the chosen proficiencies. In addition, whenever you make an Intelligence ({@skill History}) check related to the origin of any architectural construction (including buildings, public works such as canals and aqueducts, and the massive cogwork that underlies much of the construction of Ghirapur), you are considered proficient in the {@skill History} skill and add double your proficiency bonus to the check, instead of your normal proficiency bonus."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and {@language Dwarvish}. {@language Dwarvish} is full of hard consonants and guttural sounds, and those characteristics spill over into whatever other language a dwarf might speak."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Eladrin",
                    "source": "MPMM",
                    "page": 13,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "humanoid"
                    ],
                    "creatureTypeTags": [
                        "elf"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "age": {
                        "max": 750
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Improved Resting",
                        "Tool Proficiency",
                        "Weapon Proficiency"
                    ],
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "entries": [
                        "{@i Choose your eladrin's season: autumn, winter, spring, or summer. When finishing a long rest, you can change your season. See the \"Info\" tab for more information.}",
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Humanoid. You are also considered an elf for any prerequisite or effect that requires you to be an elf."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition charmed} condition on yourself."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fey Step",
                            "entries": [
                                "As a bonus action, you can magically teleport up to 30 feet to an unoccupied space you can see. You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest.",
                                "When you reach 3rd level, your Fey Step gain an additional effect based on your season; if the effect requires a saving throw, the DC equals 8 + your proficiency bonus + your Intelligence, Wisdom, or Charisma modifier (choose when you select this race):",
                                {
                                    "type": "list",
                                    "items": [
                                        {
                                            "type": "item",
                                            "name": "Autumn",
                                            "entry": "Immediately after you use your Fey Step, up to two creatures of your choice that you can see within 10 feet of you must succeed on a Wisdom saving throw or be {@condition charmed} by you for 1 minute, or until you or your companions deal any damage to the creatures."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Winter",
                                            "entry": "When you use your Fey Step, one creature of your choice that you can see within 5 feet of you before you teleport must succeed on a Wisdom saving throw or be {@condition frightened} of you until the end of your next turn."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Spring",
                                            "entry": "When you use your Fey Step, you can touch one willing creature within 5 feet of you. That creature then teleports instead of you, appearing in an unoccupied space of your choice that you can see within 30 feet of you."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Summer",
                                            "entry": "Immediately after you use your Fey Step, each creature of your choice that you can see within 5 feet of you takes fire damage equal to your proficiency bonus."
                                        }
                                    ],
                                    "style": "list-hang-notitle"
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Keen Senses",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Trance",
                            "entries": [
                                "You don't need to sleep, and magic can't put you to sleep. You can finish a long rest in 4 hours if you spend those hours in a trancelike meditation, during which you retain consciousness.",
                                "Whenever you finish this trance, you can change your season, and you can gain two proficiencies that you don't have, each one with a weapon or a tool of your choice selected from the Player's Handbook. You mystically acquire these proficiencies by drawing them from shared elven memory, and you retain them until you finish your next long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Elf",
                    "source": "PHB",
                    "page": 21,
                    "srd": true,
                    "basicRules": true,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "dex": 2
                        }
                    ],
                    "age": {
                        "mature": 100,
                        "max": 750
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Improved Resting"
                    ],
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "elvish": true
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/elf.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Although elves reach physical maturity at about the same age as humans, the elven understanding of adulthood goes beyond physical growth to encompass worldly experience. An elf typically claims adulthood and an adult name around the age of 100 and can live to be 750 years old."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Elves range from under 5 to over 6 feet tall and have slender builds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Accustomed to twilit forests and the night sky, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Keen Senses",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws against being {@condition charmed}, and magic can't put you to sleep."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Trance",
                            "entries": [
                                "Elves don't need to sleep. Instead, they meditate deeply, remaining semiconscious, for 4 hours a day. (The Common word for such meditation is \"trance.\") While meditating, you can dream after a fashion; such dreams are actually mental exercises that have become reflexive through years of practice. After resting in this way, you gain the same benefit that a human does from 8 hours of sleep.",
                                "{@note If you meditate during a long rest, you finish the rest after only 4 hours. You otherwise obey all the rules for a long rest; only the duration is changed.}"
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Elvish. Elvish is fluid, with subtle intonations and intricate grammar. Elven literature is rich and varied, and their songs and poems are famous among other races. Many bards learn their language so they can add Elvish ballads to their repertoires."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Elf (Kaladesh)",
                    "source": "PSK",
                    "page": 20,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "dex": 2,
                            "wis": 1
                        }
                    ],
                    "age": {
                        "mature": 100,
                        "max": 750
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Improved Resting"
                    ],
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "elvish": true
                        }
                    ],
                    "weaponProficiencies": [
                        {
                            "longsword|phb": true,
                            "shortsword|phb": true,
                            "shortbow|phb": true,
                            "longbow|phb": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Although elves reach physical maturity at about the same age as humans, the elven understanding of adulthood goes beyond physical growth to encompass worldly experience. An elf typically claims adulthood and an adult name around the age of 100 and can live to be 750 years old."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Elves love freedom, variety, and self-expression, so they lean strongly toward the gentler aspects of chaos. They value and protect others' freedom as well as their own, and they are more often good than not."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Elves range from under 5 to over 6 feet tall and have slender builds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Accustomed to twilit forests and the night sky, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Keen Senses",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Elf Weapon Training",
                            "entries": [
                                "You have proficiency with the {@item longsword|phb}, {@item shortsword|phb}, {@item shortbow|phb}, and {@item longbow|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws against being {@condition charmed}, and magic can't put you to sleep."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Trance",
                            "entries": [
                                "Elves don't need to sleep. Instead, they meditate deeply, remaining semiconscious, for 4 hours a day. (The Common word for such meditation is \"trance.\") While meditating, you can dream after a fashion; such dreams are actually mental exercises that have become reflexive through years of practice. After resting in this way, you gain the same benefit that a human does from 8 hours of sleep.",
                                "{@note If you meditate during a long rest, you finish the rest after only 4 hours. You otherwise obey all the rules for a long rest; only the duration is changed.}"
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Elvish. Elvish is fluid, with subtle intonations and intricate grammar. Elven literature is rich and varied, and their songs and poems are famous among other races. Many bards learn their language so they can add Elvish ballads to their repertoires."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Elf Culture",
                            "entries": [
                                "The elves of Kaladesh don't organize themselves into nations or tribes. Still, they recognize three distinct cultural groups among their kind\u2014though in truth these groupings are more like attitudes or alignments with regard to the rest of society and the use of technology. Choose one of these cultures."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Elf (Zendikar)",
                    "source": "PSZ",
                    "page": 18,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "wis": 2
                        }
                    ],
                    "age": {
                        "mature": 100,
                        "max": 750
                    },
                    "darkvision": 60,
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "elvish": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Although elves reach physical maturity at about the same age as humans, the elven understanding of adulthood goes beyond physical growth to encompass worldly experience. An elf typically claims adulthood and an adult name around the age of 100 and can live to be 750 years old."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Elves love freedom, variety, and self-expression, so they lean strongly toward the gentler aspects of chaos. They value and protect others' freedom as well as their own, and they are more often good than not."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Elves range from under 5 to over 6 feet tall and have slender builds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Accustomed to twilit forests and the night sky, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Keen Senses",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws against being {@condition charmed}, and magic can't put you to sleep."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Elvish. Elvish is fluid, with subtle intonations and intricate grammar. Elven literature is rich and varied, and their songs and poems are famous among other races. Many bards learn their language so they can add Elvish ballads to their repertoires."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Fairy",
                    "source": "MPMM",
                    "page": 14,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "fey"
                    ],
                    "size": [
                        "S"
                    ],
                    "speed": {
                        "walk": 30,
                        "fly": true
                    },
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "faerie fire"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "enlarge/reduce"
                                        ]
                                    }
                                }
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "druidcraft#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Fey."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fairy Magic",
                            "entries": [
                                "You know the {@spell druidcraft} cantrip. Starting at 3rd level, you can cast the {@spell faerie fire} spell with this trait. Starting at 5th level, you can also cast the {@spell enlarge/reduce} spell with this trait. Once you cast {@spell faerie fire} or {@spell enlarge/reduce} with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast either of those spells using any spell slots you have of the appropriate level.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Flight",
                            "entries": [
                                "Because of your wings, you have a flying speed equal to your walking speed. You can't use this flying speed if you're wearing medium or heavy armor."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Fairy",
                    "source": "WBtW",
                    "page": 12,
                    "reprintedAs": [
                        "Fairy|MPMM"
                    ],
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "fey"
                    ],
                    "size": [
                        "S"
                    ],
                    "speed": {
                        "walk": 30,
                        "fly": true
                    },
                    "additionalSpells": [
                        {
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "druidcraft#c"
                                ]
                            },
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "faerie fire"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "enlarge/reduce"
                                        ]
                                    }
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Fey."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Flight",
                            "entries": [
                                "Because of your wings, you have a flying speed equal to your walking speed. You can't use this flying speed if you're wearing medium or heavy armor."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fairy Magic",
                            "entries": [
                                "You know the {@spell druidcraft} cantrip.",
                                "Starting at 3rd level, you can cast the {@spell faerie fire} spell with this trait. Starting at 5th level, you can also cast the {@spell enlarge/reduce} spell with this trait. Once you cast {@spell faerie fire} or {@spell enlarge/reduce} with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast either of those spells using any spell slots you have of the appropriate level.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Firbolg",
                    "source": "MPMM",
                    "page": 15,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "age": {
                        "max": 500
                    },
                    "traitTags": [
                        "Powerful Build"
                    ],
                    "additionalSpells": [
                        {
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "innate": {
                                "1": [
                                    "detect magic",
                                    "disguise self"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Firbolg Magic",
                            "entries": [
                                "You can cast {@spell detect magic} and {@spell disguise self} spells with this trait. When you use this version of {@spell disguise self}, you can seem up to 3 feet shorter or taller. Once you cast either of these spells with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast these spells using any spell slots you have.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hidden Step",
                            "entries": [
                                "As a bonus action, you can magically turn {@condition invisible} until the start of your next turn or until you attack, make a damage roll, or force someone to make a saving throw. You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Powerful Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Speech of Beast and Leaf",
                            "entries": [
                                "You have the ability to communicate in a limited manner with Beasts, Plants, and vegetation. They can understand the meaning of your words, though you have no special ability to understand them in return. You have advantage on all Charisma checks you make to influence them."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Firbolg",
                    "source": "VGM",
                    "page": 107,
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 169
                        }
                    ],
                    "reprintedAs": [
                        "Firbolg|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "wis": 2,
                            "str": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 74,
                        "heightMod": "2d12",
                        "baseWeight": 175,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 30,
                        "max": 500
                    },
                    "traitTags": [
                        "Powerful Build"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "elvish": true,
                            "giant": true
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/firbolg.mp3"
                    },
                    "additionalSpells": [
                        {
                            "ability": "wis",
                            "known": {
                                "1": {
                                    "rest": {
                                        "1": [
                                            "detect magic",
                                            "disguise self"
                                        ]
                                    }
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "As humanoids related to the fey, firbolg have long lifespans. A firbolg reaches adulthood around 30, and the oldest of them can live for 500 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Firbolg are between 7 and 8 feet tall and weigh between 240 and 300 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Firbolg Magic",
                            "entries": [
                                "You can cast {@spell detect magic} and {@spell disguise self} with this trait, using Wisdom as your spellcasting ability for them. Once you cast either spell, you can't cast it again with this trait until you finish a short or long rest. When you use this version of {@spell disguise self}, you can seem up to 3 feet shorter than normal, allowing you to more easily blend in with humans and elves."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Hidden Step",
                            "entries": [
                                "As a bonus action, you can magically turn {@condition invisible} until the start of your next turn or until you attack, make a damage roll, or force someone to make a saving throw. Once you use this trait, you can't use it again until you finish a short or long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Powerful Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Speech of Beast and Leaf",
                            "entries": [
                                "You have the ability to communicate in a limited manner with beasts and plants. They can understand the meaning of your words, though you have no special ability to understand them in return. You have advantage on all Charisma checks you make to influence them."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common, Elvish, and Giant."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Genasi",
                    "source": "EEPC",
                    "page": 9,
                    "additionalSources": [
                        {
                            "source": "EGW",
                            "page": 170
                        }
                    ],
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 170
                        }
                    ],
                    "reprintedAs": [
                        "Genasi|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "con": 2
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 56,
                        "heightMod": "2d10",
                        "baseWeight": 110,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 120
                    },
                    "languageProficiencies": [
                        {
                            "common": true,
                            "primordial": true
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/genasi.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Genasi mature at about the same rate as humans and reach adulthood in their late teens. They live somewhat longer than humans do, up to 120 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Independent and self-reliant, genasi tend toward a neutral alignment."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Genasi are as varied as their mortal parents but are generally built like humans, standing anywhere from 5 feet to over 6 feet tall. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Primordial. Primordial is a guttural language, filled with harsh syllables and hard consonants."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Genasi",
                    "source": "MPMM",
                    "page": 16,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "age": {
                        "max": 120
                    },
                    "darkvision": 60,
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Giff",
                    "source": "AAG",
                    "page": 12,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": true
                    },
                    "traitTags": [
                        "Powerful Build"
                    ],
                    "weaponProficiencies": [
                        {
                            "firearms": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Astral Spark",
                            "entries": [
                                "Your psychic connection to the Astral Plane enables you to mystically access a spark of divine power, which you can channel through your weapons. When you hit a target with a {@filter simple or martial weapon|items|source=phb|category=basic|type=martial weapon;simple weapon}, you can cause the target to take extra force damage equal to your proficiency bonus.",
                                "You can use this trait a number of times equal to your proficiency bonus, but you can use it no more than once per turn. You regain all expended uses when you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Firearms Mastery",
                            "entries": [
                                "You have a mystical connection to firearms that traces back to the gods of the giff, who delighted in such weapons. You have proficiency with all firearms and ignore the loading property of any firearm. In addition, attacking at long range with a firearm doesn't impose disadvantage on your attack roll."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hippo Build",
                            "entries": [
                                "You have advantage on Strength-based ability checks and Strength saving throws. In addition, you count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Gith",
                    "source": "MTF",
                    "page": 96,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "int": 1
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Gith reach adulthood in their late teens and live for about a century."
                            ]
                        },
                        {
                            "name": "Size",
                            "type": "entries",
                            "entries": [
                                "Gith are taller and leaner than humans, with most a slender 6 feet in height."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Gith."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true
                },
                {
                    "name": "Githyanki",
                    "source": "MPMM",
                    "page": 18,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "traitTags": [
                        "Weapon Proficiency"
                    ],
                    "skillProficiencies": [
                        {
                            "any": 1
                        }
                    ],
                    "toolProficiencies": [
                        {
                            "any": 1
                        }
                    ],
                    "resist": [
                        "psychic"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "jump"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "misty step"
                                        ]
                                    }
                                }
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "mage hand#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Astral Knowledge",
                            "entries": [
                                "You can mystically access a reservoir of experiences of entities connected to the Astral Plane. Whenever you finish a long rest, you gain proficiency in one skill of your choice and with one weapon or tool of your choice, selected from the Player's Handbook, as you momentarily project your consciousness into the Astral Plane. These proficiencies last until the end of your next long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Githyanki Psionics",
                            "entries": [
                                "You know the {@spell mage hand} cantrip, and the hand is {@condition invisible} when you cast the cantrip with this trait.",
                                "Starting at 3rd level, you can cast the {@spell jump} spell with this trait. Starting at 5th level, you can also cast {@spell misty step} with it. Once you cast {@spell jump} or {@spell misty step} with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast either of those spells using any spell slots you have of the appropriate level.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race). None of these spells require spell components when you cast them with this trait."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Psychic Resilience",
                            "entries": [
                                "You have resistance to psychic damage."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Githzerai",
                    "source": "MPMM",
                    "page": 19,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "resist": [
                        "psychic"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "shield"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "detect thoughts"
                                        ]
                                    }
                                }
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "mage hand#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Githzerai Psionics",
                            "entries": [
                                "You know the {@spell mage hand} cantrip, and the hand is {@condition invisible} when you cast the cantrip with this trait.",
                                "Starting at 3rd level, you can cast the {@spell shield} spell with this trait. Starting at 5th level, you can also cast the {@spell detect thoughts} spell with it. Once you cast {@spell shield} or {@spell detect thoughts} spell with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast either of those spells using any spell slots you have of the appropriate level.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race). None of these spells require spell components when you cast them with this trait."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Mental Discipline",
                            "entries": [
                                "Your innate psychic defenses grant you advantage on saving throws you make to avoid or end the {@condition charmed} and {@condition frightened} conditions on yourself."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Psychic Resilience",
                            "entries": [
                                "You have resistance to psychic damage."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Gnoll",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "int": -2
                        }
                    ],
                    "darkvision": 60,
                    "traitTags": [
                        "Natural Weapon",
                        "NPC Race"
                    ],
                    "entries": [
                        {
                            "name": "Bite",
                            "entries": [
                                "Your fanged maw is a natural weapon, which you can use to make unarmed strikes. If you hit with it, you deal piercing damage equal to {@damage 1d4} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Rampage",
                            "entries": [
                                "When you reduce a creature to 0 hit points with a melee attack on your turn, you can take a bonus action to move up to half your speed and make a bite attack."
                            ]
                        }
                    ]
                },
                {
                    "name": "Gnome",
                    "source": "PHB",
                    "page": 35,
                    "srd": true,
                    "size": [
                        "S"
                    ],
                    "speed": 25,
                    "ability": [
                        {
                            "int": 2
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 35,
                        "heightMod": "2d4",
                        "baseWeight": 35
                    },
                    "age": {
                        "mature": 40,
                        "max": 500
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Uncommon Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "gnomish": true
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/gnome.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Gnomes mature at the same rate humans do, and most are expected to settle down into an adult life by around age 40. They can live 350 to almost 500 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Gnomes are between 3 and 4 feet tall and average about 40 pounds. Your size is Small."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Accustomed to life underground, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Gnome Cunning",
                            "entries": [
                                "You have advantage on all Intelligence, Wisdom, and Charisma saving throws against magic."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Gnomish. The Gnomish language, which uses the Dwarvish script, is renowned for its technical treatises and its catalogs of knowledge about the natural world."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Gnome (Deep)",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "S"
                    ],
                    "speed": 20,
                    "ability": [
                        {
                            "str": 1,
                            "dex": 2
                        }
                    ],
                    "darkvision": 120,
                    "traitTags": [
                        "NPC Race"
                    ],
                    "languageProficiencies": [
                        {
                            "gnomish": true,
                            "terran": true,
                            "undercommon": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "int",
                            "known": {
                                "1": [
                                    "nondetection",
                                    "blindness/deafness",
                                    "blur",
                                    "disguise self"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Innate Spellcasting",
                            "entries": [
                                "You have an innate ability to cast the following spells, requiring no material components:",
                                {
                                    "type": "list",
                                    "style": "list-hang-notitle",
                                    "items": [
                                        {
                                            "type": "itemSpell",
                                            "name": "At will:",
                                            "entry": "{@spell nondetection} (self only)"
                                        },
                                        {
                                            "type": "itemSpell",
                                            "name": "1/day each:",
                                            "entry": "{@spell blindness/deafness}, {@spell blur}, {@spell disguise self}"
                                        }
                                    ]
                                },
                                "Intelligence is your spellcasting ability for these spells."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Stone Camouflage",
                            "entries": [
                                "You have advantage on Dexterity ({@skill Stealth}) checks to hide in rocky terrain."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Gnome Cunning",
                            "entries": [
                                "You have advantage on Intelligence, Wisdom, and Charisma saving throws against magic."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Superior Darkvision",
                            "entries": [
                                "Accustomed to life underground, you have superior vision in dark and dim conditions. You can see in dim light within 120 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "data": {
                                "overwrite": "Darkvision"
                            },
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Gnomish, Terran, and Undercommon."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Goblin",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "S"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": -2,
                            "dex": 2
                        }
                    ],
                    "darkvision": 60,
                    "traitTags": [
                        "NPC Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "goblin": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Nimble Escape",
                            "entries": [
                                "You can take the {@action Disengage} or {@action Hide} action as a bonus action on each of your turns."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Accustomed to life underground, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Goblin."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Goblin",
                    "source": "ERLW",
                    "page": 26,
                    "_copy": {
                        "name": "Goblin",
                        "source": "VGM",
                        "_mod": {
                            "entries": [
                                {
                                    "mode": "appendArr",
                                    "items": {
                                        "name": "Alignment",
                                        "type": "entries",
                                        "entries": [
                                            "In Eberron, goblins are usually neutral. They tend to look out for themselves, preferably without drawing unwanted attention from any larger, more powerful people."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Size",
                                    "items": {
                                        "name": "Size",
                                        "type": "entries",
                                        "entries": [
                                            "Your size is Small."
                                        ]
                                    }
                                }
                            ]
                        },
                        "_preserve": {
                            "reprintedAs": true
                        }
                    },
                    "size": [
                        "S"
                    ],
                    "traitTags": null,
                    "hasFluffImages": true
                },
                {
                    "name": "Goblin",
                    "source": "GGR",
                    "page": 16,
                    "_copy": {
                        "name": "Goblin",
                        "source": "VGM",
                        "_mod": {
                            "entries": [
                                {
                                    "mode": "appendArr",
                                    "items": {
                                        "name": "Alignment",
                                        "type": "entries",
                                        "entries": [
                                            "Goblins are typically neutral evil, as they care only for their own needs. A few goblins might tend toward good or neutrality, but only rarely."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Age",
                                    "items": {
                                        "name": "Age",
                                        "type": "entries",
                                        "entries": [
                                            "Goblins reach adulthood around age 8. They age noticeably faster than humans, and though few goblins live to old age, the most cautious rarely live longer than 60 years."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Languages",
                                    "items": {
                                        "name": "Languages",
                                        "type": "entries",
                                        "entries": [
                                            "You can speak, read, and write Common and Goblin. In Ravnica, Goblin is a simplistic language with a limited vocabulary and fluid rules of grammar, unsuited for any sophisticated conversation."
                                        ]
                                    }
                                }
                            ]
                        },
                        "_preserve": {
                            "reprintedAs": true
                        }
                    },
                    "traitTags": null,
                    "hasFluff": true
                },
                {
                    "name": "Goblin",
                    "source": "MPMM",
                    "page": 20,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "humanoid"
                    ],
                    "creatureTypeTags": [
                        "goblinoid"
                    ],
                    "size": [
                        "S"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Humanoid. You are also considered a goblinoid for any prerequisite or effect that requires you to be a goblinoid."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were in dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition charmed} condition on yourself."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fury of the Small",
                            "entries": [
                                "When you damage a creature with an attack or a spell and the creature's size is larger than yours, you can cause the attack or spell to deal extra damage to the creature. The extra damage equals your proficiency bonus.",
                                "You can use this trait a number of times equal to your proficiency bonus, regaining all expended uses when you finish a long rest, and you can use it no more than once per turn."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Nimble Escape",
                            "entries": [
                                "You can take the {@action Disengage} or {@action Hide} action as a bonus action on each of your turns."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Goblin",
                    "source": "PSZ",
                    "page": 16,
                    "otherSources": [
                        {
                            "source": "PSX",
                            "page": 16
                        }
                    ],
                    "size": [
                        "S"
                    ],
                    "speed": 25,
                    "age": {
                        "mature": 12,
                        "max": 50
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Natural Armor"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "goblin": true
                        }
                    ],
                    "resist": [
                        "fire",
                        "psychic"
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Goblins mature faster than humans, reaching adulthood at around age 12. They also age noticeably faster than humans, and even the most cautious goblins rarely live longer than 50 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most goblins are wildly chaotic, though they have no particular inclination toward good or evil."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Goblins average about 3 feet tall and weigh about 40 pounds. Your size is Small."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Thanks to your heritage, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Goblin."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Goblin",
                    "source": "VGM",
                    "page": 119,
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 174
                        }
                    ],
                    "reprintedAs": [
                        "Goblin|MPMM"
                    ],
                    "size": [
                        "S"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "dex": 2,
                            "con": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 41,
                        "heightMod": "2d4",
                        "baseWeight": 35
                    },
                    "age": {
                        "mature": 8,
                        "max": 60
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Monstrous Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "goblin": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Goblins reach adulthood at age 8 and live up to 60 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Goblins are between 3 and 4 feet tall and weigh between 40 and 80 pounds. Your size is Small."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fury of the Small",
                            "entries": [
                                "When you damage a creature with an attack or a spell and the creature's size is larger than yours, you can cause the attack or spell to deal extra damage to the creature. The extra damage equals your level. Once you use this trait, you can't use it again until you finish a short or long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Nimble Escape",
                            "entries": [
                                "You can take the {@action Disengage} or {@action Hide} action as a bonus action on each of your turns."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Goblin."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Goblin (Dankwood)",
                    "source": "AWM",
                    "page": 35,
                    "_copy": {
                        "name": "Goblin",
                        "source": "VGM",
                        "_mod": {
                            "entries": [
                                {
                                    "mode": "appendArr",
                                    "items": {
                                        "name": "Alignment",
                                        "type": "entries",
                                        "entries": [
                                            "Dankwood goblins are typically neutral or neutral good, though some mischievous dankwood goblins are chaotic neutral."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Fury of the Small",
                                    "items": {
                                        "name": "Speak with Small Beasts",
                                        "type": "entries",
                                        "entries": [
                                            "Through sounds and gestures, you can communicate simple ideas with Small or smaller beasts. Dankwood goblins love animals and often keep squirrels, badgers, rabbits, moles, woodpeckers, and other creatures as beloved pets."
                                        ]
                                    }
                                }
                            ]
                        },
                        "_preserve": {
                            "reprintedAs": true
                        }
                    },
                    "ability": [
                        {
                            "dex": 2,
                            "wis": 1
                        }
                    ],
                    "heightAndWeight": null,
                    "hasFluff": true
                },
                {
                    "name": "Goliath",
                    "source": "MPMM",
                    "page": 21,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "traitTags": [
                        "Powerful Build"
                    ],
                    "skillProficiencies": [
                        {
                            "athletics": true
                        }
                    ],
                    "resist": [
                        "cold"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Little Giant",
                            "entries": [
                                "You have proficiency in the {@skill Athletics} skill, and you count as one size larger when determining your carrying weight and the weight you can push, drag, or lift."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Mountain Born",
                            "entries": [
                                "You have resistance to cold damage. You also naturally acclimate to high altitudes, even if you've never been to one. This includes elevations above 20,000 feet."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Stone's Endurance",
                            "entries": [
                                "You can supernaturally draw on unyielding stone to shrug off harm. When you take damage, you can use your reaction to roll a {@dice d12}. Add your Constitution modifier to the number rolled and reduce the damage by that total.",
                                "You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Goliath",
                    "source": "VGM",
                    "page": 108,
                    "otherSources": [
                        {
                            "source": "EEPC",
                            "page": 10
                        },
                        {
                            "source": "EGW",
                            "page": 175
                        },
                        {
                            "source": "IDRotF"
                        }
                    ],
                    "reprintedAs": [
                        "Goliath|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "con": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 74,
                        "heightMod": "2d10",
                        "baseWeight": 200,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "traitTags": [
                        "Powerful Build"
                    ],
                    "skillProficiencies": [
                        {
                            "athletics": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "giant": true
                        }
                    ],
                    "resist": [
                        "cold"
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/goliath.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Goliaths have lifespans comparable to humans. They enter adulthood in their late teens and usually live less than a century."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Goliaths are between 7 and 8 feet tall and weigh between 280 and 340 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Natural Athlete",
                            "entries": [
                                "You have proficiency in the {@skill Athletics} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Stone's Endurance",
                            "entries": [
                                "You can focus yourself to occasionally shrug off injury. When you take damage, you can use your reaction to roll a {@dice d12}. Add your Constitution modifier to the number rolled, and reduce the damage by that total. After you use this trait, you can't use it again until you finish a short or long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Powerful Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Mountain Born",
                            "entries": [
                                "You have resistance to cold damage. You're also acclimated to high altitude, including elevations above 20,000 feet."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Giant."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Grimlock",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "cha": -2
                        }
                    ],
                    "blindsight": 30,
                    "traitTags": [
                        "NPC Race"
                    ],
                    "languageProficiencies": [
                        {
                            "undercommon": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Blindsight",
                            "entries": [
                                "You have no eyes, and cannot be {@condition blinded}. You can perceive your surroundings within 30 ft., or 10 ft. while {@condition deafened}. You are considered blind beyond this radius."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Keen Hearing and Smell",
                            "entries": [
                                "You have advantage on Wisdom ({@skill Perception}) checks that rely on hearing or smell."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Stone Camouflage",
                            "entries": [
                                "You have advantage on Dexterity ({@skill Stealth}) checks made to hide in rocky terrain."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Undercommon."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Grung",
                    "source": "OGA",
                    "page": 4,
                    "size": [
                        "S"
                    ],
                    "speed": {
                        "walk": 25,
                        "climb": 25
                    },
                    "ability": [
                        {
                            "dex": 2,
                            "con": 1
                        }
                    ],
                    "age": {
                        "mature": 1,
                        "max": 50
                    },
                    "traitTags": [
                        "Amphibious"
                    ],
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "other": true
                        }
                    ],
                    "immune": [
                        "poison"
                    ],
                    "conditionImmune": [
                        "poisoned"
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Grungs mature to adulthood in a single year, but have been known to live up to 50 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most grungs are lawful, having been raised in a strict caste system. They tend toward evil as well, coming from a culture where social advancement occurs rarely, and most often because another member of your army has died and there is no one else of that caste to fill the vacancy."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Grungs stand between 2½ and 3½ feet tall and average about 30 pounds. Your size is Small."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Arboreal Alertness",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Amphibious",
                            "entries": [
                                "You can breathe air and water."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Poison Immunity",
                            "entries": [
                                "You're immune to poison damage and the {@condition poisoned} condition."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Poisonous Skin",
                            "entries": [
                                "Any creature that grapples you or otherwise comes into direct contact with your skin must succeed on a DC 12 Constitution saving throw or become {@condition poisoned} for 1 minute. A {@condition poisoned} creature no longer in direct contact with you can repeat the saving throw at the end of each of its turns, ending the effect on itself on a success.",
                                "You can also apply this poison to any piercing weapon as part of an attack with that weapon, though when you hit the poison reacts differently. The target must succeed on a DC 12 Constitution saving throw or take {@dice 2d4} poison damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Standing Leap",
                            "entries": [
                                "Your long jump is up to 25 feet and your high jump is up to 15 feet, with or without a running start."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Water Dependency",
                            "entries": [
                                "If you fail to immerse yourself in water for at least 1 hour during a day, you suffer one level of {@condition exhaustion} at the end of that day. You can only recover from this {@condition exhaustion} through magic or by immersing yourself in water for at least 1 hour."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Grung."
                            ]
                        }
                    ]
                },
                {
                    "name": "Hadozee",
                    "source": "AAG",
                    "page": 13,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "climb": true
                    },
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Dexterous Feet",
                            "entries": [
                                "As a bonus action, you can use your feet to manipulate an object, open or close a door or container, or pick up or set down a Tiny object."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Glide",
                            "entries": [
                                "When you fall at least 10 feet above the ground, you can use your reaction to extend your skin membranes to glide horizontally a number of feet equal to your walking speed, and you take 0 damage from the fall. You determine the direction of the glide."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hadozee Dodge",
                            "entries": [
                                "The magic that runs in your veins heightens your natural defenses. When you take damage, you can use your reaction to roll a {@dice d6}. Add your proficiency bonus to the number rolled, and reduce the damage you take by an amount equal to that total (minimum of 0 damage).",
                                "You can use this trait a number of times equal to your proficiency bonus. You regain all expended uses when you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Half-Elf",
                    "source": "PHB",
                    "page": 38,
                    "srd": true,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "cha": 2,
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "con",
                                    "int",
                                    "wis"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 57,
                        "heightMod": "2d8",
                        "baseWeight": 110,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 180
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Uncommon Race"
                    ],
                    "skillProficiencies": [
                        {
                            "any": 2
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "elvish": true,
                            "anyStandard": 1
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/half-elf.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Half-elves mature at the same rate humans do and reach adulthood around the age of 20. They live much longer than humans, however, often exceeding 180 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Half-elves are about the same size as humans, ranging from 5 to 6 feet tall. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Thanks to your elf blood, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws against being {@condition charmed}, and magic can't put you to sleep."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Skill Versatility",
                            "entries": [
                                "You gain proficiency in two skills of your choice."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common, Elvish, and one extra language of your choice."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Half-Orc",
                    "source": "PHB",
                    "page": 40,
                    "srd": true,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "con": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 58,
                        "heightMod": "2d10",
                        "baseWeight": 140,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 14,
                        "max": 75
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Uncommon Race"
                    ],
                    "skillProficiencies": [
                        {
                            "intimidation": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "orc": true
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/half-orc.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Half-orcs mature a little faster than humans, reaching adulthood around age 14. They age noticeably faster and rarely live longer than 75 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Half-orcs are somewhat larger and bulkier than humans, and they range from 5 to well over 6 feet tall. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Thanks to your orc blood, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Menacing",
                            "entries": [
                                "You gain proficiency in the {@skill Intimidation} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Relentless Endurance",
                            "entries": [
                                "When you are reduced to 0 hit points but not killed outright, you can drop to 1 hit point instead. You can't use this feature again until you finish a long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Savage Attacks",
                            "entries": [
                                "When you score a critical hit with a melee weapon attack, you can roll one of the weapon's damage dice one additional time and add it to the extra damage of the critical hit."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Orc. Orc is a harsh, grating language with hard consonants. It has no script of its own but is written in the Dwarvish script."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Halfling",
                    "source": "PHB",
                    "page": 26,
                    "srd": true,
                    "basicRules": true,
                    "size": [
                        "S"
                    ],
                    "speed": 25,
                    "ability": [
                        {
                            "dex": 2
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 31,
                        "heightMod": "2d4",
                        "baseWeight": 35
                    },
                    "age": {
                        "mature": 20,
                        "max": 250
                    },
                    "languageProficiencies": [
                        {
                            "common": true,
                            "halfling": true
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/halfling.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "A halfling reaches adulthood at the age of 20 and generally lives into the middle of his or her second century."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Halflings average about 3 feet tall and weigh about 40 pounds. Your size is Small."
                            ]
                        },
                        {
                            "name": "Lucky",
                            "entries": [
                                "When you roll a 1 on an attack roll, ability check, or saving throw, you can reroll the die and must use the new roll."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Brave",
                            "entries": [
                                "You have advantage on saving throws against being {@condition frightened}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Halfling Nimbleness",
                            "entries": [
                                "You can move through the space of any creature that is of a size larger than yours."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Halfling. The Halfling language isn't secret, but halflings are loath to share it with others. They write very little, so they don't have a rich body of literature. Their oral tradition, however, is very strong. Almost all halflings speak Common to converse with the people in whose lands they dwell or through which they are traveling."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Harengon",
                    "source": "MPMM",
                    "page": 22,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hare-Trigger",
                            "entries": [
                                "You can add your proficiency bonus to your initiative rolls."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Leporine Senses",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Lucky Footwork",
                            "entries": [
                                "When you fail a Dexterity saving throw, you can use your reaction to roll a {@dice d4} and add it to the save, potentially turning the failure into a success. You can't use this reaction if you're {@condition prone} or your speed is 0."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Rabbit Hop",
                            "entries": [
                                "As a bonus action, you can jump a number of feet equal to five times your proficiency bonus, without provoking opportunity attacks. You can use this trait only if your speed is greater than 0. You can use it a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Harengon",
                    "source": "WBtW",
                    "page": 13,
                    "reprintedAs": [
                        "Harengon|MPMM"
                    ],
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hare-Trigger",
                            "entries": [
                                "You can add your proficiency bonus to your initiative rolls."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Leporine Senses",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Lucky Footwork",
                            "entries": [
                                "When you fail a Dexterity saving throw, you can use your reaction to roll a {@dice d4} and add it to the save, potentially turning the failure into a success. You can't use this reaction if you're {@condition prone} or your speed is 0."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Rabbit Hop",
                            "entries": [
                                "As a bonus action, you can jump a number of feet equal to five times your proficiency bonus, without provoking opportunity attacks. You can use this trait only if your speed is greater than 0. You can use it a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Hexblood",
                    "source": "VRGR",
                    "page": 18,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "fey"
                    ],
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "skillProficiencies": [
                        {
                            "any": 2
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "disguise self",
                                    "hex"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Fey."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you gain this lineage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Ancestral Legacy",
                            "entries": [
                                "If you replace a race with this lineage, you can keep the following elements of that race: any skill proficiencies you gained from it and any climbing, flying, or swimming speed you gained from it.",
                                "If you don't keep any of those elements or you choose this lineage at character creation, you gain proficiency in two skills of your choice."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Eerie Token",
                            "entries": [
                                "As a bonus action, you can harmlessly remove a lock of your hair, one of your nails, or one of your teeth. This token is imbued with magic until you finish a long rest. While the token is imbued in this way, you can take these actions:",
                                {
                                    "type": "list",
                                    "style": "list-hang-notitle",
                                    "items": [
                                        {
                                            "type": "item",
                                            "name": "Telepathic Message",
                                            "entry": "As an action, you can send a telepathic message to the creature holding or carrying the token, as long as you are within 10 miles of it. The message can contain up to twenty-five words."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Remote Viewing",
                                            "entry": "If you are within 10 miles of the token, you can enter a trance as an action. The trance lasts for 1 minute, but it ends early if you dismiss it (no action required) or are {@condition incapacitated}. During this trance, you can see and hear from the token as if you were located where it is. While you are using your senses at the token's location, you are {@condition blinded} and {@condition deafened} in regard to your own surroundings. When the trance ends, the token is harmlessly destroyed."
                                        }
                                    ]
                                },
                                "Once you create a token using this feature, you can't do so again until you finish a long rest, at which point your missing part regrows."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hex Magic",
                            "entries": [
                                "You can cast the {@spell disguise self} and {@spell hex} spells with this trait. Once you cast either of these spells with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast these spells using any spell slots you have.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells (choose the ability when you gain this lineage).",
                                {
                                    "type": "inset",
                                    "name": "Becoming a Hag",
                                    "entries": [
                                        "Hags can undertake a ritual to irreversibly transform a hexblood they created into a new hag, either one of their own kind or that embodies the hexblood's nature. This requires that both the hag and hexblood be in the same place and consent to the lengthy ritual\u2014circumstances most hexbloods shun but might come to accept over the course of centuries. Once a hexblood undergoes this irreversible ritual, they emerge as a hag NPC no longer under the control of the hexblood's player, unless the DM rules otherwise."
                                    ]
                                }
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Hobgoblin",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "traitTags": [
                        "NPC Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "goblin": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Martial Advantage",
                            "entries": [
                                "Once per turn, you can deal an extra {@dice 2d6} damage to a creature you hit with a weapon attack if that creature is within 5 ft. of an ally of yours that isn't {@condition incapacitated}."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Goblin."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Hobgoblin",
                    "source": "ERLW",
                    "page": 26,
                    "_copy": {
                        "name": "Hobgoblin",
                        "source": "VGM",
                        "_mod": {
                            "entries": [
                                {
                                    "mode": "appendArr",
                                    "items": {
                                        "name": "Alignment",
                                        "entries": [
                                            "Hobgoblin society in Eberron is shaped by the ideal of a strict code of honor and rigid martial discipline. Most hobgoblins are lawful, tending toward harsh enforcement of their laws."
                                        ],
                                        "type": "entries"
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Size",
                                    "items": {
                                        "name": "Size",
                                        "entries": [
                                            "Your size is Medium."
                                        ],
                                        "type": "entries"
                                    }
                                }
                            ]
                        },
                        "_preserve": {
                            "reprintedAs": true
                        }
                    },
                    "hasFluffImages": true
                },
                {
                    "name": "Hobgoblin",
                    "source": "MPMM",
                    "page": 23,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "humanoid"
                    ],
                    "creatureTypeTags": [
                        "goblinoid"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Humanoid.You are also considered a goblinoid for any prerequisite or effect that requires you to be a goblinoid."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition charmed} condition on yourself."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fey Gift",
                            "entries": [
                                "You can use this trait to take the {@action Help} action as a bonus action, and you can do so a number of times equal to your proficiency bonus. You regain all expended uses when you finish a long rest.",
                                "Starting at 3rd level, choose one of the options below each time you take the {@action Help} action with this trait:",
                                {
                                    "type": "list",
                                    "items": [
                                        {
                                            "type": "item",
                                            "name": "Hospitality",
                                            "entry": "You and the creature you help each gain a number of temporary hit points equal to {@dice 1d6} plus your proficiency bonus."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Passage",
                                            "entry": "You and the creature you help each increase your walking speeds by 10 feet until the start of your next turn."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Spite",
                                            "entry": "Until the start of your next turn, the first time the creature you help hits a target with an attack roll, that target has disadvantage on the next attack roll it makes within the next minute."
                                        }
                                    ],
                                    "style": "list-hang-notitle"
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fortune from the Many",
                            "entries": [
                                "If you miss with an attack roll or fail an ability check or a saving throw, you can draw on your bonds of reciprocity to gain a bonus to the roll equal to the number of allies you can see within 30 feet of you (maximum bonus of +3). You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Hobgoblin",
                    "source": "VGM",
                    "page": 119,
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 175
                        }
                    ],
                    "reprintedAs": [
                        "Hobgoblin|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "con": 2,
                            "int": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 56,
                        "heightMod": "2d10",
                        "baseWeight": 110,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Monstrous Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "goblin": true
                        }
                    ],
                    "weaponProficiencies": [
                        {
                            "choose": {
                                "fromFilter": "type=martial weapon|miscellaneous=mundane",
                                "count": 2
                            }
                        }
                    ],
                    "armorProficiencies": [
                        {
                            "light": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Hobgoblins mature at the same rate as humans and have lifespans similar in length to theirs."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Hobgoblins are between 5 and 6 feet tall and weigh between 150 and 200 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Martial Training",
                            "entries": [
                                "You are proficient with two {@filter martial weapons|items|source=phb|category=basic|type=martial weapon} of your choice and with light armor."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Saving Face",
                            "entries": [
                                "Hobgoblins are careful not to show weakness in front of their allies, for fear of losing status. If you miss with an attack roll or fail an ability check or a saving throw, you can gain a bonus to the roll equal to the number of allies you can see within 30 feet of you (maximum bonus of +5). Once you use this trait, you can't use it again until you finish a short or long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Goblin."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Human",
                    "source": "PHB",
                    "page": 29,
                    "srd": true,
                    "basicRules": true,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "heightAndWeight": {
                        "baseHeight": 56,
                        "heightMod": "2d10",
                        "baseWeight": 110,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "languageProficiencies": [
                        {
                            "common": true,
                            "anyStandard": 1
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/human.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Humans reach adulthood in their late teens and live less than a century."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Humans vary widely in height and build, from barely 5 feet to well over 6 feet tall. Regardless of your position in that range, your size is Medium."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and one extra language of your choice. Humans typically learn the languages of other peoples they deal with, including obscure dialects. They are fond of sprinkling their speech with words borrowed from other tongues: Orc curses, Elvish musical expressions, Dwarvish military phrases, and so on."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Human (Amonkhet)",
                    "source": "PSA",
                    "page": 14,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "con",
                                    "int",
                                    "wis",
                                    "cha"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "feats": [
                        {
                            "any": 1
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "any": 1
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "anyStandard": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Humans reach adulthood in their late teens. Most human initiates have completed the trials and found a glorious or inglorious death before they turn 30. Viziers can enjoy longer service to their gods, in theory living up to a century."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Humans tend toward no particular alignment. The best and the worst are found among them."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Humans vary widely in height and build, from barely 5 feet to well over 6 feet tall. Regardless of your position in that range, your size is Medium"
                            ]
                        },
                        {
                            "name": "Skills",
                            "entries": [
                                "You gain proficiency in one skill of your choice."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Feat",
                            "entries": [
                                "You gain one {@5etools feat|feats.html} of your choice."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and one extra language of your choice."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Human (Innistrad)",
                    "source": "PSI",
                    "page": 8,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "languageProficiencies": [
                        {
                            "common": true,
                            "anyStandard": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Humans reach adulthood in their late teens and live less than a century."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Humans tend toward no particular alignment."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Humans vary widely in height and build, from barely 5 feet to well over 6 feet tall. Regardless of your position in that range, your size is Medium."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and one extra language of your choice."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Human (Ixalan)",
                    "source": "PSX",
                    "page": 11,
                    "_copy": {
                        "name": "Human",
                        "source": "PHB",
                        "_mod": {
                            "entries": [
                                {
                                    "mode": "appendArr",
                                    "items": {
                                        "name": "Alignment",
                                        "type": "entries",
                                        "entries": [
                                            "Humans tend toward no particular alignment. The best and the worst are found among them."
                                        ]
                                    }
                                },
                                {
                                    "mode": "appendArr",
                                    "items": {
                                        "name": "Speed",
                                        "type": "entries",
                                        "entries": [
                                            "Your base walking speed is 30 feet."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Languages",
                                    "items": {
                                        "name": "Languages",
                                        "type": "entries",
                                        "entries": [
                                            "You can speak, read, and write {@language Common} and one extra language of your choice. Or, if your campaign uses the optional rules for languages found in the previous section, your national origin determines your native language: {@language Itzocan|PSX} for the Sun Empire, {@language Coalition pidgin|PSX} for the Brazen Coalition, or {@language Vampire|PSX} for the Legion of Dusk. You still speak one additional language of your choice, and {@language Common Trade Pidgin|PSX|Common} if it exists in your campaign."
                                        ]
                                    }
                                }
                            ]
                        }
                    },
                    "ability": [
                        {
                            "str": 1,
                            "dex": 1,
                            "con": 1,
                            "int": 1,
                            "wis": 1,
                            "cha": 1
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "anyStandard": 1
                        },
                        {
                            "common": true,
                            "other": true,
                            "anyStandard": 1
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Human (Kaladesh)",
                    "source": "PSK",
                    "page": 22,
                    "_copy": {
                        "name": "Human",
                        "source": "PHB",
                        "_mod": {
                            "entries": [
                                {
                                    "mode": "appendArr",
                                    "items": {
                                        "name": "Alignment",
                                        "type": "entries",
                                        "entries": [
                                            "Humans tend toward no particular alignment."
                                        ]
                                    }
                                },
                                {
                                    "mode": "appendArr",
                                    "items": {
                                        "name": "Speed",
                                        "type": "entries",
                                        "entries": [
                                            "Your base walking speed is 30 feet."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Languages",
                                    "items": {
                                        "name": "Languages",
                                        "type": "entries",
                                        "entries": [
                                            "You can speak, read, and write Common and one extra language of your choice. Humans typically learn the languages of other peoples they deal with, including obscure dialects. They are fond of sprinkling their speech with words borrowed from other tongues: Dwarvish curses, Elvish musical expressions, {@race Vedalken|PSK} scholarly jargon, and so on."
                                        ]
                                    }
                                }
                            ]
                        }
                    },
                    "ability": [
                        {
                            "str": 1,
                            "dex": 1,
                            "con": 1,
                            "int": 1,
                            "wis": 1,
                            "cha": 1
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Human (Zendikar)",
                    "source": "PSZ",
                    "page": 9,
                    "_copy": {
                        "name": "Human",
                        "source": "PHB",
                        "_mod": {
                            "entries": {
                                "mode": "replaceArr",
                                "replace": "Languages",
                                "items": {
                                    "name": "Languages",
                                    "entries": [
                                        "You can speak, read, and write Common and one extra language of your choice. Humans typically learn the languages of other peoples they deal with, including obscure dialects. They are fond of sprinkling their speech with words borrowed from other tongues: vampire curses, Elvish musical expressions, merfolk scholarly jargon, and so on."
                                    ],
                                    "type": "entries"
                                }
                            }
                        }
                    },
                    "ability": [
                        {
                            "str": 1,
                            "dex": 1,
                            "con": 1,
                            "int": 1,
                            "wis": 1,
                            "cha": 1
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Kalashtar",
                    "source": "ERLW",
                    "page": 29,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "wis": 2,
                            "cha": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 64,
                        "heightMod": "2d6",
                        "baseWeight": 110,
                        "weightMod": "1d6"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true,
                            "anyStandard": 1
                        }
                    ],
                    "resist": [
                        "psychic"
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "entries": [
                                "Kalashtar mature and age at the same rate as humans."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Alignment",
                            "entries": [
                                "The noble spirit tied to a kalashtar drives it toward lawful and good behavior. Most kalashtar combine strong self-discipline with compassion for all beings, but some kalashtar resist the virtuous influence of their spirit."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Your size is Medium."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Dual Mind",
                            "entries": [
                                "You have advantage on all Wisdom saving throws."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Mental Discipline",
                            "entries": [
                                "You have resistance to psychic damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Mind Link",
                            "entries": [
                                "You can speak telepathically to any creature you can see, provided the creature is within a number of feet of you equal to 10 times your level. You don't need to share a language with the creature for it to understand your telepathic utterances, but the creature must be able to understand at least one language.",
                                "When you're using this trait to speak telepathically to a creature, you can use your action to give that creature the ability to speak telepathically with you for 1 hour or until you end this effect as an action. To use this ability, the creature must be able to see you and must be within this trait's range. You can give this ability to only one creature at a time; giving it to a creature takes it away from another creature who has it."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Severed from Dreams",
                            "entries": [
                                "Kalashtar sleep, but they don't connect to the plane of dreams as other creatures do. Instead, their minds draw from the memories of their otherworldly spirit while they sleep. As such, you are immune to spells and other magical effects that require you to dream, like {@spell dream}, but not to spells and other magical effects that put you to sleep, like {@spell sleep}."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common, Quori, and one other language of your choice."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Kender",
                    "source": "DSotDQ",
                    "page": 27,
                    "lineage": "VRGR",
                    "size": [
                        "S"
                    ],
                    "speed": 30,
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "insight",
                                    "investigation",
                                    "sleight of hand",
                                    "stealth",
                                    "survival"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Fearless",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition frightened} condition on yourself. When you fail a saving throw to avoid or end the {@condition frightened} condition on yourself, you can choose to succeed instead. Once you succeed on a saving throw in this way, you can't do so again until you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Kender Curiosity",
                            "entries": [
                                "Thanks to the mystical origin of your people, you gain proficiency with one of the following skills of your choice: {@skill Insight}, {@skill Investigation}, {@skill Sleight of Hand}, {@skill Stealth}, or {@skill Survival}."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Taunt",
                            "entries": [
                                "You have an extraordinary ability to fluster creatures. As a bonus action, you can unleash a string of provoking words at a creature within 60 feet of yourself that can hear and understand you. The target must succeed on a Wisdom saving throw, or it has disadvantage on attack rolls against targets other than you until the start of your next turn. The DC equals 8 + your proficiency bonus + your Intelligence, Wisdom, or Charisma modifier (choose when you select this race).",
                                "You can use this bonus action a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Kenku",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "dex": 2
                        }
                    ],
                    "darkvision": 60,
                    "traitTags": [
                        "NPC Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "auran": true
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/kenku.mp3"
                    },
                    "entries": [
                        {
                            "name": "Ambusher",
                            "entries": [
                                "In the first round of a combat, you have advantage on attack rolls against any creature who is {@quickref Surprise|PHB|3|0|surprised}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Mimicry",
                            "entries": [
                                "You can mimic any sounds you have heard, including voices. A creature that hears the sounds can tell they are imitations with a successful DC 14 Wisdom ({@skill Insight}) check."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can read and write Common and Auran, but you can only speak using your Mimicry trait."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Kenku",
                    "source": "MPMM",
                    "page": 24,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "skillProficiencies": [
                        {
                            "any": 2
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Your size is Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Expert Duplication",
                            "entries": [
                                "When you copy writing or craftwork produced by yourself or someone else, you have advantage on any ability checks you make to produce an exact duplicate."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Kenku Recall",
                            "entries": [
                                "Thanks to your supernaturally good memory, you have proficiency in two skills of your choice.",
                                "Moreover, when you make an ability check using any skill in which you have proficiency, you can give yourself advantage on the check before rolling the {@dice d20}. You can give yourself advantage in this way a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Mimicry",
                            "entries": [
                                "You can accurately mimic sounds you have heard, including voices. A creature that hears the sounds you make can tell they are imitations only with a successful Wisdom ({@skill Insight}) check against a DC of 8 + your proficiency bonus + your Charisma modifier."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Kenku",
                    "source": "VGM",
                    "page": 109,
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 177
                        }
                    ],
                    "reprintedAs": [
                        "Kenku|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "dex": 2,
                            "wis": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 52,
                        "heightMod": "2d8",
                        "baseWeight": 50,
                        "weightMod": "1d6"
                    },
                    "age": {
                        "mature": 12,
                        "max": 60
                    },
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "acrobatics",
                                    "deception",
                                    "sleight of hand",
                                    "stealth"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "auran": true
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/kenku.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Kenku have shorter lifespans than humans. They reach maturity at about 12 years old and can live to 60."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Kenku are around 5 feet tall and weigh between 90 and 120 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Expert Forgery",
                            "entries": [
                                "You can duplicate other creatures' handwriting and craftwork. You have advantage on all checks made to produce forgeries or duplicates of existing objects."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Kenku Training",
                            "entries": [
                                "You are proficient in your choice of two of the following skills: {@skill Acrobatics}, {@skill Deception}, {@skill Stealth}, and {@skill Sleight of Hand}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Mimicry",
                            "entries": [
                                "You can mimic sounds you have heard, including voices. A creature that hears the sounds can tell they are imitations with a successful Wisdom ({@skill Insight}) check opposed by your Charisma ({@skill Deception}) check."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can read and write Common and Auran, but you can only speak using your Mimicry trait."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Khenra",
                    "source": "PSA",
                    "page": 17,
                    "size": [
                        "M"
                    ],
                    "speed": 35,
                    "ability": [
                        {
                            "dex": 2,
                            "str": 1
                        }
                    ],
                    "age": {
                        "mature": 13,
                        "max": 60
                    },
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "weaponProficiencies": [
                        {
                            "longsword|phb": true,
                            "spear|phb": true,
                            "javelin|phb": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Khenra mature quickly, reaching adulthood in their early teens. Khenra initiates are usually the youngest in a crop, completing the trials by their late teens. Even without a violent death, they rarely live past 60."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most khenra lean toward chaotic alignments. They have no particular inclination toward good or evil."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Khenra have similar builds to humans. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Khenra Weapon Training",
                            "entries": [
                                "You have proficiency with the khopesh ({@item longsword|phb}), {@item spear|phb}, and {@item javelin|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Khenra Twins",
                            "entries": [
                                "If your twin is alive and you can see your twin, whenever you roll a 1 on an attack roll, ability check, or saving throw, you can reroll the die and must use the new roll. If your twin is dead (or if you were born without a twin), you can't be {@condition frightened}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Khenra."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Kobold",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "S"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "dex": 2,
                            "str": -4
                        }
                    ],
                    "darkvision": 60,
                    "traitTags": [
                        "NPC Race",
                        "Sunlight Sensitivity"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "draconic": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Pack Tactics",
                            "entries": [
                                "You have advantage on an attack roll against a creature if at least one of your allies is within 5 feet of the creature and the ally isn't {@condition incapacitated}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Sunlight Sensitivity",
                            "entries": [
                                "You have disadvantage on attack rolls and on Wisdom ({@skill Perception}) checks that rely on sight when you, the target of your attack, or whatever you are trying to perceive is in direct sunlight."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Accustomed to life underground, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Draconic."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Kobold",
                    "source": "MPMM",
                    "page": 25,
                    "lineage": "VRGR",
                    "size": [
                        "S"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "arcana",
                                    "investigation",
                                    "medicine",
                                    "sleight of hand",
                                    "survival"
                                ]
                            }
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "_": [
                                    {
                                        "choose": "level=0|class=Sorcerer",
                                        "count": 1
                                    }
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were in dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Draconic Cry",
                            "entries": [
                                "As a bonus action, you let out a cry at your enemies within 10 feet of you. Until the start of your next turn, you and your allies have advantage on attack rolls against any of those enemies who could hear you. You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Kobold Legacy",
                            "entries": [
                                "Kobold's connections to dragons can manifest in unpredictable ways in an individual kobold. Choose one of the following legacy options for your kobold.",
                                {
                                    "type": "list",
                                    "items": [
                                        {
                                            "type": "item",
                                            "name": "Craftiness",
                                            "entry": "You have proficiency in one of the following skills of your choice: {@skill Arcana}, {@skill Investigation}, {@skill Medicine}, {@skill Sleight of Hand}, or {@skill Survival}."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Defiance",
                                            "entry": "You have advantage on saving throws to avoid or end the {@condition frightened} condition on yourself."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Draconic Sorcery",
                                            "entry": "You know one {@filter cantrip of your choice from the sorcerer spell list|spells|level=0|class=Sorcerer}. Intelligence, Wisdom, or Charisma is your spellcasting ability for that cantrip (choose when you select this race)."
                                        }
                                    ],
                                    "style": "list-hang-notitle"
                                }
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true,
                    "_versions": [
                        {
                            "name": "Kobold; Craftiness",
                            "source": "MPMM",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Kobold Legacy",
                                    "items": {
                                        "name": "Kobold Legacy (Craftiness)",
                                        "type": "entries",
                                        "entries": [
                                            "You have proficiency in one of the following skills of your choice: {@skill Arcana}, {@skill Investigation}, {@skill Medicine}, {@skill Sleight of Hand}, or {@skill Survival}."
                                        ]
                                    }
                                }
                            },
                            "additionalSpells": null
                        },
                        {
                            "name": "Kobold; Defiance",
                            "source": "MPMM",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Kobold Legacy",
                                    "items": {
                                        "name": "Kobold Legacy (Defiance)",
                                        "type": "entries",
                                        "entries": [
                                            "You have advantage on saving throws to avoid or end the {@condition frightened} condition on yourself."
                                        ]
                                    }
                                }
                            },
                            "skillProficiencies": null,
                            "additionalSpells": null
                        },
                        {
                            "name": "Kobold; Draconic Sorcery",
                            "source": "MPMM",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Kobold Legacy",
                                    "items": {
                                        "name": "Kobold Legacy (Draconic Sorcery)",
                                        "type": "entries",
                                        "entries": [
                                            "You know one {@filter cantrip of your choice from the sorcerer spell list|spells|level=0|class=Sorcerer}. Intelligence, Wisdom, or Charisma is your spellcasting ability for that cantrip (choose when you select this race)."
                                        ]
                                    }
                                }
                            },
                            "skillProficiencies": null
                        }
                    ]
                },
                {
                    "name": "Kobold",
                    "source": "VGM",
                    "page": 119,
                    "reprintedAs": [
                        "Kobold|MPMM"
                    ],
                    "size": [
                        "S"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "dex": 2
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 25,
                        "heightMod": "2d4",
                        "baseWeight": 25
                    },
                    "age": {
                        "mature": 6,
                        "max": 120
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Monstrous Race",
                        "Sunlight Sensitivity"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "draconic": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Kobolds reach adulthood at age 6 and can live up to 120 years but rarely do so."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Kobolds are between 2 and 3 feet tall and weigh between 25 and 35 pounds. Your size is Small."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Grovel, Cower, and Beg",
                            "entries": [
                                "As an action on your turn, you can cower pathetically to distract nearby foes. Until the end of your next turn, your allies gain advantage on attack rolls against enemies within 10 feet of you that you can see. Once you use this trait, you can't use it again until you finish a short or long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Pack Tactics",
                            "entries": [
                                "You have advantage on an attack roll against a creature if at least one of your allies is within 5 feet of the creature and the ally isn't {@condition incapacitated}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Sunlight Sensitivity",
                            "entries": [
                                "You have disadvantage on attack rolls and on Wisdom ({@skill Perception}) checks that rely on sight when you, the target of your attack, or whatever you are trying to perceive is in direct sunlight."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Draconic."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Kor",
                    "source": "PSZ",
                    "page": 10,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "climb": 30
                    },
                    "ability": [
                        {
                            "dex": 2,
                            "wis": 1
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "skillProficiencies": [
                        {
                            "athletics": true,
                            "acrobatics": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Kor mature at the same rate as humans and live about as long."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most kor are lawful good, with a strong dedication to community and the traditions of their ancestors."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Kor average nearly 6 feet tall, but are much lighter and more slender than humans. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Brave",
                            "entries": [
                                "You have advantage on saving throws against being {@condition frightened}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Climbing",
                            "entries": [
                                "You also have a climbing speed of 30 feet as long as you are not encumbered or wearing heavy armor."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Kor Climbing",
                            "entries": [
                                "You have proficiency in the {@skill Athletics} and {@skill Acrobatics} skills."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common, and communicate in the silent speech of the Kor."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Lucky",
                            "entries": [
                                "When you roll a 1 on the {@dice d20} for an attack roll, ability check, or saving throw, you can reroll the die and must use the new roll."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Kuo-Toa",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": 30
                    },
                    "darkvision": 120,
                    "traitTags": [
                        "Amphibious",
                        "NPC Race",
                        "Sunlight Sensitivity"
                    ],
                    "languageProficiencies": [
                        {
                            "undercommon": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Amphibious",
                            "type": "entries",
                            "entries": [
                                "You can breathe air and water."
                            ]
                        },
                        {
                            "name": "Otherworldly Perception",
                            "type": "entries",
                            "entries": [
                                "You can sense the presence of any creature within 30 feet of you that is {@condition invisible} or on the Ethereal Plane. You can pinpoint such a creature that is moving."
                            ]
                        },
                        {
                            "name": "Slippery",
                            "type": "entries",
                            "entries": [
                                "You have advantage on ability checks and saving throws made to escape a grapple."
                            ]
                        },
                        {
                            "name": "Sunlight Sensitivity",
                            "type": "entries",
                            "entries": [
                                "While in sunlight, you have disadvantage on attack rolls, as well as on Wisdom ({@skill Perception}) checks that rely on sight."
                            ]
                        },
                        {
                            "name": "Superior Darkvision",
                            "entries": [
                                "You have superior vision in dark and dim conditions. You can see in dim light within 120 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Undercommon."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Leonin",
                    "source": "MOT",
                    "page": 20,
                    "size": [
                        "M"
                    ],
                    "speed": 35,
                    "ability": [
                        {
                            "str": 1,
                            "con": 2
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 66,
                        "heightMod": "2d10",
                        "baseWeight": 180,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "athletics",
                                    "intimidation",
                                    "perception",
                                    "survival"
                                ]
                            }
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Leonin mature and age at about the same rate as humans."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Leonin tend toward good alignments. Leonin who are focused on the pride lean toward lawful good."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Leonin are typically over 6 feet tall, with some standing over 7 feet. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Claws",
                            "entries": [
                                "Your claws are natural weapons, which you can use to make unarmed strikes. If you hit with them, you can deal slashing damage equal to {@damage 1d4} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Hunter's Instincts",
                            "entries": [
                                "You have proficiency in one of the following skills of your choice: {@skill Athletics}, {@skill Intimidation}, {@skill Perception}, or {@skill Survival}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Daunting Roar",
                            "entries": [
                                "As a bonus action, you can let out an especially menacing roar. Creatures of your choice within 10 feet of you that can hear you must succeed on a Wisdom saving throw or become {@condition frightened} of you until the end of your next turn. The DC of the save equals 8 + your proficiency bonus + your Constitution modifier. Once you use this trait, you can't use it again until you finish a short or long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Leonin."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Lizardfolk",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": 30
                    },
                    "ability": [
                        {
                            "str": 2,
                            "int": -2
                        }
                    ],
                    "traitTags": [
                        "Natural Armor",
                        "NPC Race"
                    ],
                    "languageProficiencies": [
                        {
                            "draconic": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Hold Breath",
                            "entries": [
                                "You can hold your breath for up to 15 minutes at a time."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Natural Armor",
                            "entries": [
                                "Your scales function as natural armor, granting you a +3 bonus to Armor Class."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Draconic."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Lizardfolk",
                    "source": "MPMM",
                    "page": 26,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": true
                    },
                    "traitTags": [
                        "Natural Armor",
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "animal handling",
                                    "medicine",
                                    "nature",
                                    "perception",
                                    "stealth",
                                    "survival"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Speed",
                            "entries": [
                                "Your walking speed is 30 feet, and you have a swimming speed equal to your walking speed."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Bite",
                            "entries": [
                                "You have a fanged maw that you can use to make unarmed strikes. When you hit with it, the strike deals {@damage 1d6} + your Strength modifier slashing damage, instead of the bludgeoning damage normal for an unarmed strike."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hold Breath",
                            "entries": [
                                "You can hold your breath for up to 15 minutes at a time."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hungry Jaws",
                            "entries": [
                                "You can throw yourself into a feeding frenzy. As a bonus action, you can make a special attack with your Bite. If the attack hits, it deals its normal damage, and you gain temporary hit points equal to your proficiency bonus. You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Natural Armor",
                            "entries": [
                                "You have tough, scaly skin. When you aren't wearing armor, your base AC is 13 + Dexterity modifier. You can use your natural armor to determine your AC if the armor you wear would leave you with a lower AC. A shield's benefits apply as normal while you use your natural armor."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Nature's Intuition",
                            "entries": [
                                "Thanks to your mystical connection to nature, you gain proficiency with two of the following skills of your choice: {@skill Animal Handling}, {@skill Medicine}, {@skill Nature}, {@skill Perception}, {@skill Stealth}, or {@skill Survival}."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Lizardfolk",
                    "source": "VGM",
                    "page": 111,
                    "reprintedAs": [
                        "Lizardfolk|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": 30
                    },
                    "ability": [
                        {
                            "con": 2,
                            "wis": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 57,
                        "heightMod": "2d10",
                        "baseWeight": 120,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 14,
                        "max": 60
                    },
                    "traitTags": [
                        "Natural Armor",
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "animal handling",
                                    "nature",
                                    "perception",
                                    "stealth",
                                    "survival"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "draconic": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Lizardfolk reach maturity around age 14 and rarely live longer than 60 years."
                            ]
                        },
                        {
                            "name": "Size",
                            "type": "entries",
                            "entries": [
                                "Lizardfolk are a little bulkier and taller than humans, and their colorful frills make them appear even larger. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Swim Speed",
                            "entries": [
                                "You have a swimming speed of 30 feet."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Bite",
                            "entries": [
                                "Your fanged maw is a natural weapon, which you can use to make unarmed strikes. If you hit with it, you deal piercing damage equal to {@dice 1d6} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Cunning Artisan",
                            "entries": [
                                "As part of a short rest, you can harvest bone and hide from a slain beast, construct, dragon, monstrosity, or plant creature of size small or larger to create one of the following items: a {@item shield|phb}, a {@item club|phb}, a {@item javelin|phb}, or {@dice 1d4} {@item dart|phb|darts} or {@item blowgun needle|phb|blowgun needles}. To use this trait, you need a blade, such as a {@item dagger|phb}, or appropriate {@filter artisan's tools|items|source=phb|miscellaneous=mundane|type=artisan's tools}, such as {@item leatherworker's tools|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Hold Breath",
                            "entries": [
                                "You can hold your breath for up to 15 minutes at a time."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Hunter's Lore",
                            "entries": [
                                "You gain proficiency with two of the following skills of your choice: {@skill Animal Handling}, {@skill Nature}, {@skill Perception}, {@skill Stealth}, and {@skill Survival}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Natural Armor",
                            "entries": [
                                "You have tough, scaly skin. When you aren't wearing armor, your AC is 13 + your Dexterity modifier. You can use your natural armor to determine your AC if the armor you wear would leave you with a lower AC. A shield's benefits apply as normal while you use your natural armor."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Hungry Jaws",
                            "entries": [
                                "In battle, you can throw yourself into a vicious feeding frenzy. As a bonus action, you can make a special attack with your bite. If the attack hits, it deals its normal damage, and you gain temporary hit points equal to your Constitution modifier (minimum of 1), and you can't use this trait again until you finish a short or long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Draconic."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Locathah",
                    "source": "LR",
                    "page": 24,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": 30
                    },
                    "ability": [
                        {
                            "str": 2,
                            "dex": 1
                        }
                    ],
                    "age": {
                        "mature": 10,
                        "max": 80
                    },
                    "traitTags": [
                        "Amphibious",
                        "Natural Armor"
                    ],
                    "skillProficiencies": [
                        {
                            "athletics": true,
                            "perception": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "aquan": true,
                            "common": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Locathah mature to adulthood by the age of 10 but have been known to live up to 80 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most locathah are true neutral or have some aspect of neutrality in their alignment. They tend toward good, coming from a culture where compassion for the downtrodden is a commonality."
                            ]
                        },
                        {
                            "name": "Natural Armor",
                            "entries": [
                                "You have tough, scaly skin. When you aren't wearing armor, your AC is 12 + your Dexterity modifier. You can use your natural armor to determine your AC if the armor you wear would leave you with a lower AC. A shield's benefits apply as normal while you use your natural armor."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Observant & Athletic",
                            "entries": [
                                "You have proficiency in the {@skill Athletics} and {@skill Perception} skills."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Leviathan Will",
                            "entries": [
                                "You have advantage on saving throws against being {@condition charmed}, {@condition frightened}, {@condition paralyzed}, {@condition poisoned}, {@condition stunned}, or put to sleep."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Limited Amphibiousness",
                            "entries": [
                                "You can breathe air and water, but you need to be submerged at least once every 4 hours to avoid suffocating."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Locathah stand between 5 and 6 feet tall and average about 150 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Language",
                            "entries": [
                                "You can speak, read, and write Aquan and Common."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Loxodon",
                    "source": "GGR",
                    "page": 17,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "con": 2,
                            "wis": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 79,
                        "heightMod": "2d10",
                        "baseWeight": 295,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 450
                    },
                    "traitTags": [
                        "Natural Armor",
                        "Powerful Build"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Age",
                            "entries": [
                                "Loxodons physically mature at the same rate as humans, but they live about 450 years. They highly value the weight of wisdom and experience and are considered young until they reach the age of 60."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Alignment",
                            "entries": [
                                "Most loxodons are lawful, believing in the value of a peaceful, ordered life. They also tend toward good."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Loxodons stand between 7 and 8 feet tall. Their massive bodies weigh between 300 and 400 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Powerful Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Loxodon Serenity",
                            "entries": [
                                "You have advantage on saving throws against being {@condition charmed} or {@condition frightened}."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Natural Armor",
                            "entries": [
                                "You have thick, leathery skin. When you aren't wearing armor, your AC is 12 + your Constitution modifier. You can use your natural armor to determine your AC if the armor you wear would leave you with a lower AC. A shield's benefits apply as normal while you use your natural armor.",
                                {
                                    "type": "inset",
                                    "name": "Tip: AC Calculations Don't Stack",
                                    "entries": [
                                        "When the game gives you more than one way to calculate your Armor Class, you can use only one of them. You choose the one to use. For example, if you have the loxodon's Natural Armor trait and the monk's Unarmored Defense feature, you don't mix them together. Instead, you choose which one determines your AC."
                                    ]
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Trunk",
                            "entries": [
                                "You can grasp things with your trunk, and you can use it as a snorkel. It has a reach of 5 feet, and it can lift a number of pounds equal to five times your Strength score. You can use it to do the following simple tasks: lift, drop, hold, push, or pull an object or a creature; open or close a door or a container; grapple someone; or make an unarmed strike. Your DM might allow other simple tasks to be added to that list of options.",
                                "Your trunk can't wield weapons or shields or do anything that requires manual precision, such as using tools or magic items or performing the somatic components of a spell."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Keen Smell",
                            "entries": [
                                "Thanks to your sensitive trunk, you have advantage on Wisdom ({@skill Perception}), Wisdom ({@skill Survival}), and Intelligence ({@skill Investigation}) checks that involve smell."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Loxodon."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Merfolk",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 10,
                        "swim": 40
                    },
                    "traitTags": [
                        "Amphibious",
                        "NPC Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "aquan": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Amphibious",
                            "entries": [
                                "You can breathe air and water."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Aquan."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Merfolk",
                    "source": "PSZ",
                    "page": 13,
                    "otherSources": [
                        {
                            "source": "PSX",
                            "page": 12
                        }
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": 30
                    },
                    "ability": [
                        {
                            "cha": 1
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "traitTags": [
                        "Amphibious"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true,
                            "anyStandard": 1
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Age",
                            "entries": [
                                "Merfolk mature at the same rate humans do and reach adulthood around the age of 20. They live considerably longer than humans, though, often reaching well over 100 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Alignment",
                            "entries": [
                                "Most merfolk are neutral, though merfolk of the Emeria and Cosi creeds have chaotic leanings."
                            ]
                        },
                        {
                            "name": "Amphibious",
                            "entries": [
                                "You can breathe air and water."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Merfolk are about the same size and build as humans. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Swimming",
                            "entries": [
                                "You have a swimming speed of 30 feet."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common, Merfolk, and one extra language of your choice."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Minotaur",
                    "source": "GGR",
                    "page": 18,
                    "reprintedAs": [
                        "Minotaur|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "con": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 64,
                        "heightMod": "2d8",
                        "baseWeight": 175,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 17,
                        "max": 150
                    },
                    "traitTags": [
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "intimidation",
                                    "persuasion"
                                ]
                            }
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "entries": [
                                "{@note These traits are also suitable for minotaurs in other D&D worlds where these people have avoided the demonic influence of Baphomet.}"
                            ]
                        },
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Minotaurs enter adulthood at around the age of 17 and can live up to 150 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most minotaurs who join the Boros Legion lean toward lawful alignments, while those associated with the Cult of Rakdos or the Gruul Clans tend toward chaotic alignments."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Minotaurs average over 6 feet in height, and they have stocky builds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Horns",
                            "entries": [
                                "Your horns are natural melee weapons, which you can use to make unarmed strikes. If you hit with them, you deal piercing damage equal to {@dice 1d6} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Goring Rush",
                            "entries": [
                                "Immediately after you use the {@action Dash} action on your turn and move at least 20 feet, you can make one melee attack with your horns as a bonus action."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Hammering Horns",
                            "entries": [
                                "Immediately after you hit a creature with a melee attack as part of the {@action Attack} action on your turn, you can use a bonus action to attempt to shove that target with your horns. The target must be no more than one size larger than you and within 5 feet of you. Unless it succeeds on a Strength saving throw against a DC equal to 8 + your proficiency bonus + your Strength modifier, you push it up to 10 feet away from you."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Imposing Presence",
                            "entries": [
                                "You have proficiency in one of the following skills of your choice: {@skill Intimidation} or {@skill Persuasion}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Minotaur."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Minotaur",
                    "source": "MOT",
                    "page": 22,
                    "reprintedAs": [
                        "Minotaur|MPMM"
                    ],
                    "_copy": {
                        "name": "Minotaur",
                        "source": "GGR",
                        "_mod": {
                            "entries": [
                                {
                                    "mode": "replaceArr",
                                    "replace": "Age",
                                    "items": {
                                        "name": "Age",
                                        "type": "entries",
                                        "entries": [
                                            "Minotaurs mature and age at about the same rate as humans."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Alignment",
                                    "items": {
                                        "name": "Alignment",
                                        "type": "entries",
                                        "entries": [
                                            "Minotaurs who leave the walls of Skophos have the opportunity to be free of its culture and pursue chaotic alignments, while those who remain within the polis and its tyrannical regime tend toward lawful alignments."
                                        ]
                                    }
                                }
                            ]
                        }
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Minotaur",
                    "source": "MPMM",
                    "page": 27,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "traitTags": [
                        "Natural Weapon"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Horns",
                            "entries": [
                                "You have horns that you can use to make unarmed strikes. When you hit with them, the strike deals {@damage 1d6} + your Strength modifier piercing damage, instead of the bludgeoning damage normal for an unarmed strike."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Goring Rush",
                            "entries": [
                                "Immediately after you take the {@action Dash} action on your turn and move at least 20 feet, you can make one melee attack with your Horns as a bonus action."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hammering Horns",
                            "entries": [
                                "Immediately after you hit a creature with a melee attack as part of the {@action Attack} action on your turn, you can use a bonus action to attempt to push that target with your horns. The target must be within 5 feet of you and no more than one size larger than you. Unless it succeeds on a Strength saving throw against a DC equal to 8 + your proficiency bonus + your Strength modifier, you can push it up to 10 feet away from you."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Labyrinthine Recall",
                            "entries": [
                                "You always know which direction is north, and you have advantage on any Wisdom ({@skill Survival}) check you make to navigate or track."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Minotaur (Amonkhet)",
                    "source": "PSA",
                    "page": 19,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "con": 1
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 40
                    },
                    "traitTags": [
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "intimidation": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Minotaurs develop more slowly than humans, reaching full maturity around the age of 20. They typically become acolytes at around 8 or 9 years old, making them among the older members of their crops. Once they reach maturity, though, minotaurs age quickly, rushing headlong through the trials (as they do all aspects of life) to complete them before they pass their peak. A minotaur allowed to die of old age would rarely live beyond 40."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most minotaurs lean toward chaotic alignments, and they have a slight inclination toward evil."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Minotaurs average over 6 feet in height, and they have strong, stocky builds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Natural Weapon",
                            "entries": [
                                "You can use your horns as a natural weapon to make unarmed strikes. If you hit with your horns, you deal bludgeoning damage equal to {@dice 1d6} + your Strength modifier."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Menacing",
                            "entries": [
                                "You gain proficiency in the {@skill Intimidation} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Relentless Endurance",
                            "entries": [
                                "When you are reduced to 0 hit points but not killed outright, you can drop to 1 hit point instead. You can't use this feature again until you finish a long rest."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Savage Attacks",
                            "entries": [
                                "When you score a critical hit with a melee weapon attack, you can roll one of the weapon's damage dice one additional time and add it to the extra damage of the critical hit."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Minotaur."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Naga",
                    "source": "PSA",
                    "page": 21,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "con": 2,
                            "int": 1
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "traitTags": [
                        "Language Proficiency",
                        "Natural Weapon",
                        "Tool Proficiency"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "toolProficiencies": [
                        {
                            "poisoner's kit": true
                        }
                    ],
                    "immune": [
                        "poison"
                    ],
                    "conditionImmune": [
                        "poisoned"
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Like humans, naga reach adulthood in their late teens. They show no signs of aging beyond that point except for growing larger, so in theory, a naga could live well over a century."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most naga are either neutral or neutral evil in alignment."
                            ]
                        },
                        {
                            "name": "Size",
                            "entries": [
                                "Naga stand about 5 feet tall when upright, but the total length of their bodies, head to tail, ranges from 10 to as much as 20 feet. Your size is Medium."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Speed Burst",
                            "entries": [
                                "By lowering your body to the ground and propelling yourself with your arms, you can move more quickly for a time. As a bonus action on your turn, if you have both hands free, you can increase your walking speed by 5 feet until the end of your turn."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Natural Weapons",
                            "entries": [
                                "Your fanged maw and constricting serpentine body are natural weapons, which you can use to make unarmed strikes.",
                                "If you hit with your bite, you deal piercing damage equal to {@damage 1d4} + your Strength modifier, and your target must make a Constitution saving throw (DC 8 + your proficiency bonus + your Constitution modifier). On a failed save, the target takes {@damage 1d4} poison damage.",
                                "If you hit with your constrict attack, you deal bludgeoning damage equal to {@dice 1d6} + your Strength modifier, and the target is {@condition grappled} (escape DC 8 + your proficiency bonus + your Strength modifier). Until this grapple ends, the target is {@condition restrained}, and you can't constrict another target."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Poison Immunity",
                            "entries": [
                                "You are immune to poison damage and can't be {@condition poisoned}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Poison Affinity",
                            "entries": [
                                "You gain proficiency with the {@item poisoner's kit|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Naga."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Orc",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "int": -2
                        }
                    ],
                    "darkvision": 60,
                    "traitTags": [
                        "NPC Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "orc": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Aggressive",
                            "entries": [
                                "As a bonus action, you can move up to your speed toward a hostile creature that you can see."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Accustomed to life underground, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Orc."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Orc",
                    "source": "EGW",
                    "page": 178,
                    "_copy": {
                        "name": "Orc",
                        "source": "ERLW",
                        "_mod": {
                            "entries": [
                                {
                                    "mode": "replaceArr",
                                    "replace": "Age",
                                    "items": {
                                        "name": "Age",
                                        "type": "entries",
                                        "entries": [
                                            "Orcs reach adulthood at age 16, and live up to 80 years."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Alignment",
                                    "items": {
                                        "name": "Alignment",
                                        "type": "entries",
                                        "entries": [
                                            "Orcs fear the curse of ruin that is said to plague their race, and tend strongly toward either chaos (accepting their fate), or toward law (rejecting it)."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Size",
                                    "items": {
                                        "name": "Size",
                                        "type": "entries",
                                        "entries": [
                                            "Orcs stand easily 8 feet tall and corded with powerful muscles, weighing up to 280 pounds. Your size is Medium."
                                        ]
                                    }
                                },
                                {
                                    "mode": "replaceArr",
                                    "replace": "Primal Intuition",
                                    "items": {
                                        "type": "entries",
                                        "name": "Primal Intuition",
                                        "entries": [
                                            "You have proficiency in two of the following skills of your choice: {@skill Animal Handling}, {@skill Insight}, {@skill Intimidation}, {@skill Medicine}, {@skill Perception}, and {@skill Survival}."
                                        ]
                                    }
                                }
                            ]
                        },
                        "_preserve": {
                            "reprintedAs": true
                        }
                    },
                    "heightAndWeight": null,
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "animal handling",
                                    "insight",
                                    "intimidation",
                                    "medicine",
                                    "perception",
                                    "survival"
                                ],
                                "count": 2
                            }
                        }
                    ]
                },
                {
                    "name": "Orc",
                    "source": "ERLW",
                    "page": 31,
                    "reprintedAs": [
                        "Orc|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "con": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 64,
                        "heightMod": "2d8",
                        "baseWeight": 175,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 12,
                        "max": 50
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Powerful Build"
                    ],
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "animal handling",
                                    "insight",
                                    "intimidation",
                                    "medicine",
                                    "nature",
                                    "perception",
                                    "survival"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "orc": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Orcs reach adulthood at age 12 and live up to 50 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Alignment",
                            "entries": [
                                "The orcs of Eberron are a passionate people, given to powerful emotion and deep faith. They are generally chaotic, but can be any alignment."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Aggressive",
                            "entries": [
                                "As a bonus action, you can move up to your movement speed toward a hostile creature you can see or hear. You must end this move closer to the enemy than you started."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Primal Intuition",
                            "entries": [
                                "You have proficiency in two of the following skills of your choice: {@skill Animal Handling}, {@skill Insight}, {@skill Intimidation}, {@skill Medicine}, {@skill Nature}, {@skill Perception}, and {@skill Survival}."
                            ]
                        },
                        {
                            "name": "Powerful Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Orc."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Orc",
                    "source": "MPMM",
                    "page": 28,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "traitTags": [
                        "Powerful Build"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Adrenaline Rush",
                            "entries": [
                                "You can take the {@action Dash} action as a bonus action. You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest.",
                                "Whenever you use this trait, you gain a number of temporary hit points equal to your proficiency bonus."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Powerful Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Relentless Endurance",
                            "entries": [
                                "When you are reduced to 0 hit points but not killed outright, you can drop to 1 hit point instead. Once you use this trait, you can't do so again until you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Orc",
                    "source": "VGM",
                    "page": 120,
                    "reprintedAs": [
                        "Orc|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "con": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 64,
                        "heightMod": "2d8",
                        "baseWeight": 175,
                        "weightMod": "2d6"
                    },
                    "age": {
                        "mature": 12,
                        "max": 50
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Monstrous Race",
                        "Powerful Build"
                    ],
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "animal handling",
                                    "insight",
                                    "intimidation",
                                    "medicine",
                                    "nature",
                                    "perception",
                                    "survival"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "orc": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Orcs reach adulthood at age 12 and live up to 50 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Orcs are usually over 6 feet tall and weigh between 230 and 280 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Aggressive",
                            "entries": [
                                "As a bonus action, you can move up to your movement speed toward a hostile creature you can see or hear. You must end this move closer to the enemy than you started."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Primal Intuition",
                            "entries": [
                                "You have proficiency in two of the following skills of your choice: {@skill Animal Handling}, {@skill Insight}, {@skill Intimidation}, {@skill Medicine}, {@skill Nature}, {@skill Perception}, and {@skill Survival}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Powerful Build",
                            "entries": [
                                "You count as one size larger when determining your carrying capacity and the weight you can push, drag, or lift."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Orc."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Orc (Ixalan)",
                    "source": "PSX",
                    "page": 15,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "con": 1
                        }
                    ],
                    "age": {
                        "mature": 14,
                        "max": 75
                    },
                    "darkvision": 60,
                    "skillProficiencies": [
                        {
                            "intimidation": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "orc": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Orcs mature a little faster than humans, reaching adulthood around age 14. They age noticeably faster and rarely live longer than 75 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most orcs lean toward chaotic alignments, and many serve on pirate ships that encourage an inclination toward evil."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Orcs average over 6 feet in height, and they have strong, stocky builds. Your size is Medium."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Menacing",
                            "entries": [
                                "You gain proficiency in the {@skill Intimidation} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Relentless Endurance",
                            "entries": [
                                "When you are reduced to 0 hit points but not killed outright, you can drop to 1 hit point instead. You can't use this feature again until you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Savage Attacks",
                            "entries": [
                                "When you score a critical hit with a melee weapon attack, you can roll one of the weapon's damage dice one additional time and add it to the extra damage of the critical hit."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write {@language Common Trade Pidgin|PSX|Common} (if it exists in your campaign) and {@language Orc|PHB}."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Owlin",
                    "source": "SCC",
                    "page": 29,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "fly": true
                    },
                    "darkvision": 120,
                    "skillProficiencies": [
                        {
                            "stealth": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 120 feet of yourself as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Flight",
                            "entries": [
                                "Thanks to your wings, you have a flying speed equal to your walking speed. You can't use this flying speed if you're wearing medium or heavy armor."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Silent Feathers",
                            "entries": [
                                "You have proficiency in the {@skill Stealth} skill."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Plasmoid",
                    "source": "AAG",
                    "page": 14,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "ooze"
                    ],
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "resist": [
                        "acid",
                        "poison"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are an Ooze."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Amorphous",
                            "entries": [
                                "You can squeeze through a space as narrow as 1 inch wide, provided you are wearing and carrying nothing. You have advantage on ability checks you make to initiate or escape a grapple."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of yourself as if it were bright light, and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hold Breath",
                            "entries": [
                                "You can hold your breath for 1 hour."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Natural Resilience",
                            "entries": [
                                "You have resistance to acid and poison damage, and you have advantage on saving throws against being {@condition poisoned}."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shape Self",
                            "entries": [
                                "As an action, you can reshape your body to give yourself a head, one or two arms, one or two legs, and makeshift hands and feet, or you can revert to a limbless blob. While you have a humanlike shape, you can wear clothing and armor made for a Humanoid of your size.",
                                "As a bonus action, you can extrude a pseudopod that is up to 6 inches wide and 10 feet long or reabsorb it into your body. As part of the same bonus action, you can use this pseudopod to manipulate an object, open or close a door or container, or pick up or set down a Tiny object. The pseudopod contains no sensory organs and can't attack, activate magic items, or lift more than 10 pounds."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Reborn",
                    "source": "VRGR",
                    "page": 20,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "traitTags": [
                        "Improved Resting"
                    ],
                    "resist": [
                        "poison"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you gain this lineage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Ancestral Legacy",
                            "entries": [
                                "If you replace a race with this lineage, you can keep the following elements of that race: any skill proficiencies you gained from it and any climbing, flying, or swimming speed you gained from it.",
                                "If you don't keep any of those elements or you choose this lineage at character creation, you gain proficiency in two skills of your choice."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Deathless Nature",
                            "entries": [
                                "You have escaped death, a fact represented by the following benefits:",
                                {
                                    "type": "list",
                                    "items": [
                                        "You have advantage on saving throws against disease and being {@condition poisoned}, and you have resistance to poison damage.",
                                        "You have advantage on death saving throws.",
                                        "You don't need to eat, drink, or breathe.",
                                        "You don't need to sleep, and magic can't put you to sleep. You can finish a long rest in 4 hours if you spend those hours in an inactive, motionless state, during which you retain consciousness."
                                    ]
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Knowledge from a Past Life",
                            "entries": [
                                "You temporarily remember glimpses of the past, perhaps faded memories from ages ago or a previous life. When you make an ability check that uses a skill, you can roll a {@dice d6} immediately after seeing the number on the {@dice d20} and add the number on the {@dice d6} to the check. You can use this feature a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Satyr",
                    "source": "MOT",
                    "page": 24,
                    "reprintedAs": [
                        "Satyr|MPMM"
                    ],
                    "creatureTypes": [
                        "fey"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 35,
                    "ability": [
                        {
                            "cha": 2,
                            "dex": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 56,
                        "heightMod": "2d8",
                        "baseWeight": 100,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "traitTags": [
                        "Magic Resistance",
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "performance": true,
                            "persuasion": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "sylvan": true
                        }
                    ],
                    "toolProficiencies": [
                        {
                            "musical instrument": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Satyrs mature and age at about the same rate as humans."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Satyrs delight in living a life free of the mantle of law. They gravitate toward being good, but some have devious streaks and enjoy causing dismay."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Satyrs range from just under 5 feet to about 6 feet in height, with generally slender builds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Fey",
                            "entries": [
                                "Your creature type is fey, rather than humanoid."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Ram",
                            "entries": [
                                "You can use your head and horns to make unarmed strikes. If you hit with them, you deal bludgeoning damage equal to {@damage 1d4} + your Strength modifier."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Magic Resistance",
                            "entries": [
                                "You have advantage on saving throws against spells and other magical effects."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Mirthful Leaps",
                            "entries": [
                                "Whenever you make a long or high jump, you can roll a {@dice d8} and add the number rolled to the number of feet you cover, even when making a standing jump. This extra distance costs movement as normal."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Reveler",
                            "entries": [
                                "You have proficiency in the {@skill Performance} and {@skill Persuasion} skills, and you have proficiency with one {@item musical instrument|PHB} of your choice."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Sylvan."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Satyr",
                    "source": "MPMM",
                    "page": 29,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "fey"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 35,
                    "traitTags": [
                        "Magic Resistance",
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "performance": true,
                            "persuasion": true
                        }
                    ],
                    "toolProficiencies": [
                        {
                            "musical instrument": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Fey."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Ram",
                            "entries": [
                                "You can use your head and horns to make unarmed strikes. When you hit with them, the strike deals {@damage 1d6} + your Strength modifier bludgeoning damage, instead of the bludgeoning damage normal for an unarmed strike."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Magic Resistance",
                            "entries": [
                                "You have advantage on saving throws against spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Mirthful Leaps",
                            "entries": [
                                "Whenever you make a long jump or a high jump, you can roll a {@dice d8} and add the number rolled to the number of feet you cover, even when making a standing jump. This extra distance costs movement as usual."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Reveler",
                            "entries": [
                                "As an embodiment of revelry, you have proficiency in the {@skill Performance} and {@skill Persuasion} skills, and you have proficiency with one {@item musical instrument|PHB} of your choice."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Sea Elf",
                    "source": "MPMM",
                    "page": 30,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "humanoid"
                    ],
                    "creatureTypeTags": [
                        "elf"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": true
                    },
                    "age": {
                        "max": 750
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Amphibious",
                        "Improved Resting",
                        "Tool Proficiency",
                        "Weapon Proficiency"
                    ],
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "resist": [
                        "cold"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Humanoid. You are also considered an elf for any prerequisite or effect that requires you to be an elf."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Speed",
                            "entries": [
                                "Your walking speed is 30 feet, and you have a swimming speed equal to your walking speed."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Child of the Sea",
                            "entries": [
                                "You can breathe air and water, and you have a resistance to cold damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition charmed} condition on yourself."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Friend of the Sea",
                            "entries": [
                                "Aquatic animals have an extraordinary affinity with your people. You can communicate simple ideas to any Beast that has a swimming speed. It can understand your words, though you have no special ability to understand it in return."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Keen Senses",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Trance",
                            "entries": [
                                "You don't need to sleep, and magic can't put you to sleep. You can finish a long rest in 4 hours if you spend those hours in a trancelike meditation, during which you retain consciousness.",
                                "Whenever you finish this trance, you can gain two proficiencies that you don't have, each one with a weapon or a tool of your choice selected from the Player's Handbook. You mystically acquire these proficiencies by drawing them from shared elven memory, and you retain them until you finish your next long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Shadar-Kai",
                    "source": "MPMM",
                    "page": 31,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "humanoid"
                    ],
                    "creatureTypeTags": [
                        "elf"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "age": {
                        "max": 750
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Improved Resting",
                        "Tool Proficiency",
                        "Weapon Proficiency"
                    ],
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "resist": [
                        "necrotic"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Humanoid. You are also considered an elf for any prerequisite or effect that requires you to be an elf."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Blessing of the Raven Queen",
                            "entries": [
                                "As a bonus action, you can magically teleport up to 30 feet to an unoccupied space you can see. You can use this trait a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest.",
                                "Starting at 3rd level, you also gain resistance to all damage when you teleport using this trait. The resistance lasts until the start of your next turn. During that time, you appear ghostly and translucent."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Fey Ancestry",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition charmed} condition on yourself."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Keen Senses",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Necrotic Resistance",
                            "entries": [
                                "You have resistance to necrotic damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Trance",
                            "entries": [
                                "You don't need to sleep, and magic can't put you to sleep. You can finish a long rest in 4 hours if you spend those hours in a trancelike meditation, during which you retain consciousness.",
                                "Whenever you finish this trance, you can gain two proficiencies that you don't have, each one with a weapon or a tool of your choice selected from the Player's Handbook. You mystically acquire these proficiencies by drawing them from shared elven memory, and you retain them until you finish your next long rest."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Shifter",
                    "source": "ERLW",
                    "page": 33,
                    "reprintedAs": [
                        "Shifter|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "heightAndWeight": {
                        "baseHeight": 54,
                        "heightMod": "2d8",
                        "baseWeight": 90,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 10,
                        "max": 70
                    },
                    "darkvision": 60,
                    "languageProficiencies": [
                        {
                            "common": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Age",
                            "entries": [
                                "Shifters are quick to mature both physically and emotionally, reaching young adulthood at age 10. They rarely live to be more than 70 years old."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Alignment",
                            "entries": [
                                "Shifters tend toward neutrality, being more focused on survival than concepts of good and evil. A love of personal freedom can drive shifters toward chaotic alignments."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Your size is Medium."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Speed",
                            "entries": [
                                "Your base walking speed is 30 feet."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shifting",
                            "entries": [
                                "As a bonus action, you can assume a more bestial appearance. This transformation lasts for 1 minute, until you die, or until you revert to your normal appearance as a bonus action. When you shift, you gain temporary hit points equal to your level + your Constitution modifier (minimum of 1 temporary hit point). You also gain additional benefits that depend on your shifter subrace, described below.",
                                "Once you shift, you can't do so again until you finish a short or long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Shifter",
                    "source": "MPMM",
                    "page": 32,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "acrobatics",
                                    "athletics",
                                    "intimidation",
                                    "survival"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Bestial Instincts",
                            "entries": [
                                "Channeling the beast within, you have proficiency in one of the following skills of your choice: {@skill Acrobatics}, {@skill Athletics}, {@skill Intimidation}, or {@skill Survival}."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were in dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shifting",
                            "entries": [
                                "As a bonus action, you can assume a more bestial appearance. This transformation lasts for 1 minute, until you die, or until you revert to your normal appearance as a bonus action. When you shift, you gain temporary hit points equal to 2 × your proficiency bonus. You can shift a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest.",
                                "Whenever you shift, you gain an additional benefit based on one of the following options (choose when you select this race):",
                                {
                                    "type": "list",
                                    "items": [
                                        {
                                            "type": "item",
                                            "name": "Beasthide",
                                            "entry": "You gain {@dice 1d6} additional temporary hit points. While shifted, you have a +1 bonus to your Armor Class."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Longtooth",
                                            "entry": "When you shift and as a bonus action on your other turns while shifted, you can use your elongated fangs to make an unarmed strike. If you hit with your fangs, you can deal piercing damage equal to {@dice 1d6} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Swiftstride",
                                            "entry": "While shifted, your walking speed increases by 10 feet. Additionally, you can move up to 10 feet as a reaction when a creature ends its turn within 5 feet of you. This reactive movement doesn't provoke opportunity attacks."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Wildhunt",
                                            "entry": "While shifted, you have advantage on Wisdom checks, and no creature within 30 feet of you can make an attack roll with advantage against you unless you're {@condition incapacitated}."
                                        }
                                    ],
                                    "style": "list-hang-notitle"
                                }
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true,
                    "_versions": [
                        {
                            "name": "Shifter; Beasthide",
                            "source": "MPMM",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Shifting",
                                    "items": {
                                        "name": "Shifting (Beasthide)",
                                        "type": "entries",
                                        "entries": [
                                            "As a bonus action, you can assume a more bestial appearance. This transformation lasts for 1 minute, until you die, or until you revert to your normal appearance as a bonus action. When you shift, you gain temporary hit points equal to 2 × your proficiency bonus + {@dice 1d6}, and you regain all expended uses when you finish a long rest.",
                                            "While shifted, you have a +1 bonus to your Armor Class."
                                        ]
                                    }
                                }
                            }
                        },
                        {
                            "name": "Shifter; Longtooth",
                            "source": "MPMM",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Shifting",
                                    "items": {
                                        "name": "Shifting (Longtooth)",
                                        "type": "entries",
                                        "entries": [
                                            "As a bonus action, you can assume a more bestial appearance. This transformation lasts for 1 minute, until you die, or until you revert to your normal appearance as a bonus action. When you shift, you gain temporary hit points equal to 2 × your proficiency bonus, and you regain all expended uses when you finish a long rest.",
                                            "When you shift and as a bonus action on your other turns while shifted, you can use your elongated fangs to make an unarmed strike. If you hit with your fangs, you can deal piercing damage equal to {@dice 1d6} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike."
                                        ]
                                    }
                                }
                            }
                        },
                        {
                            "name": "Shifter; Swiftstride",
                            "source": "MPMM",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Shifting",
                                    "items": {
                                        "name": "Shifting (Swiftstride)",
                                        "type": "entries",
                                        "entries": [
                                            "As a bonus action, you can assume a more bestial appearance. This transformation lasts for 1 minute, until you die, or until you revert to your normal appearance as a bonus action. When you shift, you gain temporary hit points equal to 2 × your proficiency bonus, and you regain all expended uses when you finish a long rest.",
                                            "While shifted, your walking speed increases by 10 feet. Additionally, you can move up to 10 feet as a reaction when a creature ends its turn within 5 feet of you. This reactive movement doesn't provoke opportunity attacks."
                                        ]
                                    }
                                }
                            }
                        },
                        {
                            "name": "Shifter; Wildhunt",
                            "source": "MPMM",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Shifting",
                                    "items": {
                                        "name": "Shifting (Wildhunt)",
                                        "type": "entries",
                                        "entries": [
                                            "As a bonus action, you can assume a more bestial appearance. This transformation lasts for 1 minute, until you die, or until you revert to your normal appearance as a bonus action. When you shift, you gain temporary hit points equal to 2 × your proficiency bonus, and you regain all expended uses when you finish a long rest.",
                                            "While shifted, you have advantage on Wisdom checks, and no creature within 30 feet of you can make an attack roll with advantage against you unless you're {@condition incapacitated}."
                                        ]
                                    }
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "Simic Hybrid",
                    "source": "GGR",
                    "page": 20,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30
                    },
                    "ability": [
                        {
                            "con": 2,
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "int",
                                    "wis",
                                    "cha"
                                ],
                                "count": 1
                            }
                        }
                    ],
                    "darkvision": 60,
                    "traitTags": [
                        "Amphibious",
                        "Natural Armor",
                        "Natural Weapon"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "choose": {
                                "from": [
                                    "elvish",
                                    "other"
                                ],
                                "count": 1
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Age",
                            "entries": [
                                "Hybrids begin their lives as adult humans, elves, or vedalken. They age at a slightly accelerated rate, so their maximum life spans are probably reduced somewhat. The Guardian Project has not been operating long enough to observe the full effect of this phenomenon."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Alignment",
                            "entries": [
                                "Most hybrids share the generally neutral outlook of the Simic Combine. They are more interested in scientific research and the standing of their guild than in moral or ethical questions. Those who leave the Combine, however, often do so because their philosophical outlook and alignment are more in line with a different guild's."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Your size is Medium, within the normal range of your humanoid base race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and your choice of Elvish or Vedalken."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Animal Enhancement",
                            "entries": [
                                "Your body has been altered to incorporate certain animal characteristics. You choose one animal enhancement now and a second enhancement at 5th level.",
                                "At 1st level, choose one of the following options:",
                                {
                                    "type": "list",
                                    "style": "list-hang-notitle",
                                    "items": [
                                        {
                                            "type": "item",
                                            "name": "Manta Glide",
                                            "entry": "You have ray-like fins that you can use as wings to slow your fall or allow you to glide. When you fall and aren't {@condition incapacitated}, you can subtract up to 100 feet from the fall when calculating falling damage, and you can move up to 2 feet horizontally for every 1 foot you descend."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Nimble Climber",
                                            "entry": "You have a climbing speed equal to your walking speed."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Underwater Adaptation",
                                            "entry": "You can breathe air and water, and you have a swimming speed equal to your walking speed."
                                        }
                                    ]
                                },
                                "At 5th level, your body evolves further, developing new characteristics. Choose one of the options you didn't take at 1st level, or one of the following options:",
                                {
                                    "type": "list",
                                    "style": "list-hang-notitle",
                                    "items": [
                                        {
                                            "type": "item",
                                            "name": "Grappling Appendage",
                                            "entry": "You have two special appendages growing alongside your arms. Choose whether they're both claws or tentacles. As an action, you can use one of them to try to grapple a creature. Each one is also a natural weapon, which you can use to make an unarmed strike. If you hit with it, the target takes bludgeoning damage equal to {@dice 1d6} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike. Immediately after hitting, you can try to grapple the target as a bonus action. These appendages can't precisely manipulate anything and can't wield weapons, magic items, or other specialized equipment."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Carapace",
                                            "entry": "Your skin in places is covered by a thick shell. You gain a +1 bonus to AC when you're not wearing heavy armor."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Acid Spit",
                                            "entry": "As an action, you can spray acid from glands in your mouth, targeting one creature or object you can see within 30 feet of you. The target takes {@dice 2d10} acid damage unless it succeeds on a Dexterity saving throw against a DC equal to 8 + your Constitution modifier + your proficiency bonus. This damage increases by {@dice 1d10} when you reach 11th level ({@dice 3d10}) and 17th level ({@dice 4d10}). You can use this trait a number of times equal to your Constitution modifier (minimum of once), and you regain all expended uses of it when you finish a long rest."
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Siren",
                    "source": "PSX",
                    "page": 17,
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 25,
                        "fly": 30
                    },
                    "ability": [
                        {
                            "cha": 2
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "known": {
                                "1": [
                                    "friends#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most sirens lean toward chaotic alignment, cherishing the freedom and independence that comes from joining a pirate crew."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Sirens stand about 5 to 6 feet tall, but their bodies are slender and their bones partially hollow to facilitate their flight. Your size is Medium."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Siren's Song",
                            "entries": [
                                "You know the {@spell friends} cantrip and can cast it without material components."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Flight",
                            "entries": [
                                "You have a flying speed of 30 feet. You can't use your flying speed while you wear medium or heavy armor. (If your campaign uses the variant rule for {@variantrule encumbrance|PHB}, you can't use your flying speed if you are encumbered.)"
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write {@language Common Trade Pidgin|PSX|Common} (if it exists in your campaign) and {@language Siren|PSX}."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Skeleton",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "dex": 2,
                            "int": -4,
                            "cha": -4
                        }
                    ],
                    "darkvision": 60,
                    "traitTags": [
                        "Improved Resting",
                        "NPC Race"
                    ],
                    "immune": [
                        "poison"
                    ],
                    "vulnerable": [
                        "bludgeoning"
                    ],
                    "conditionImmune": [
                        "exhaustion",
                        "poisoned"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Brittle Bones",
                            "entries": [
                                "You are vulnerable to bludgeoning damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Undead Nature",
                            "entries": [
                                "You are immune to poison damage and {@condition exhaustion}, and you can't be {@condition poisoned}. You don't require air, food, drink, or sleep."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can't speak, but you can understand the languages you knew in life."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Tabaxi",
                    "source": "MPMM",
                    "page": 33,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "climb": true
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "perception": true,
                            "stealth": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Speed",
                            "entries": [
                                "Your walking speed is 30 feet, and you have a climbing speed equal to your walking speed."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Cat's Claws",
                            "entries": [
                                "You can use your claws to make unarmed strikes. When you hit with them, the strike deals {@damage 1d6} + your Strength modifier slashing damage, instead of the bludgeoning damage normal for an unarmed strike."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Cat's Talent",
                            "entries": [
                                "You have proficiency in the {@skill Perception} and {@skill Stealth} skills."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Feline Agility",
                            "entries": [
                                "Your reflexes and agility allow you to move with a burst of speed. When you move on your turn in combat, you can double your speed until the end of the turn. Once you use this trait, you can't use it again until you move 0 feet on one of your turns."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Tabaxi",
                    "source": "VGM",
                    "page": 113,
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 179
                        }
                    ],
                    "reprintedAs": [
                        "Tabaxi|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "climb": 20
                    },
                    "ability": [
                        {
                            "dex": 2,
                            "cha": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 58,
                        "heightMod": "2d10",
                        "baseWeight": 90,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "perception": true,
                            "stealth": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "anyStandard": 1
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/tabaxi.mp3"
                    },
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Tabaxi have lifespans equivalent to humans."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Tabaxi are taller on average than humans and relatively slender. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You have a cat's keen senses, especially in the dark. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Feline Agility",
                            "entries": [
                                "Your reflexes and agility allow you to move with a burst of speed. When you move on your turn in combat, you can double your speed until the end of the turn. Once you use this trait, you can't use it again until you move 0 feet on one of your turns."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Cat's Claws",
                            "entries": [
                                "Because of your claws, you have a climbing speed of 20 feet. In addition, your claws are natural weapons, which you can use to make unarmed strikes. If you hit with them, you deal slashing damage equal to {@damage 1d4} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Cat's Talents",
                            "entries": [
                                "You have proficiency in the {@skill Perception} and {@skill Stealth} skills."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and one other language of your choice."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Thri-kreen",
                    "source": "AAG",
                    "page": 15,
                    "lineage": "VRGR",
                    "creatureTypes": [
                        "monstrosity"
                    ],
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "traitTags": [
                        "Improved Resting",
                        "Natural Armor"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Creature Type",
                            "entries": [
                                "You are a Monstrosity."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Chameleon Carapace",
                            "entries": [
                                "While you aren't wearing armor, your carapace gives you a base Armor Class of 13 + your Dexterity modifier.",
                                "As an action, you can change the color of your carapace to match the color and texture of your surroundings, giving you advantage on Dexterity ({@skill Stealth}) checks made to {@action hide} in those surroundings."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of yourself as if it were bright light, and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Secondary Arms",
                            "entries": [
                                "You have two slightly smaller secondary arms below your primary pair of arms. The secondary arms can manipulate an object, open or close a door or container, pick up or set down a Tiny object, or wield a weapon that has the light property."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Sleepless",
                            "entries": [
                                "You do not require sleep and can remain conscious during a long rest, though you must still refrain from strenuous activity to gain the benefit of the rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Thri-kreen Telepathy",
                            "entries": [
                                "Without the assistance of magic, you can't speak the non-thri-kreen languages you know. Instead you use telepathy to convey your thoughts. You have the magical ability to transmit your thoughts mentally to willing creatures within 120 feet of yourself. A contacted creature doesn't need to share a language with you to understand your thoughts, but it must be able to understand at least one language. Your telepathic link to a creature is broken if you and the creature move more than 120 feet apart, if either of you is {@condition incapacitated}, or if either of you mentally breaks the contact (no action required)."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Tiefling",
                    "source": "PHB",
                    "page": 42,
                    "srd": true,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "cha": 2,
                            "int": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 57,
                        "heightMod": "2d8",
                        "baseWeight": 110,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Uncommon Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "infernal": true
                        }
                    ],
                    "resist": [
                        "fire"
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/tiefling.mp3"
                    },
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "hellish rebuke#2"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "darkness"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "thaumaturgy#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Tieflings mature at the same rate as humans but live a few years longer."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Tieflings are about the same size and build as humans. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Thanks to your infernal heritage, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Hellish Resistance",
                            "entries": [
                                "You have resistance to fire damage."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Infernal Legacy",
                            "entries": [
                                "You know the {@spell thaumaturgy} cantrip. Once you reach 3rd level, you can cast the {@spell hellish rebuke} spell as a 2nd-level spell with this trait; you regain the ability to cast it when you finish a long rest. Once you reach 5th level, you can also cast the {@spell darkness} spell once per day with this trait; you regain the ability to cast it when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Infernal."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Tortle",
                    "source": "MPMM",
                    "page": 34,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "traitTags": [
                        "Natural Armor",
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "animal handling",
                                    "medicine",
                                    "nature",
                                    "perception",
                                    "stealth",
                                    "survival"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Claws",
                            "entries": [
                                "You have claws that you can use to make unarmed strikes. When you hit with them, the strike deals {@damage 1d6} + your Strength modifier slashing damage, instead of the bludgeoning damage normal for an unarmed strike."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hold Breath",
                            "entries": [
                                "You can hold your breath for up to 1 hour."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Natural Armor",
                            "entries": [
                                "Your shell provides you a base AC of 17 (your Dexterity modifier doesn't affect this number). You can't wear light, medium, or heavy armor, but if you are using a shield, you can apply the shield's bonus as normal."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Nature's Intuition",
                            "entries": [
                                "Thanks to your mystical connection to nature, you gain proficiency with one of the following skills of your choice: {@skill Animal Handling}, {@skill Medicine}, {@skill Nature}, {@skill Perception}, {@skill Stealth}, or {@skill Survival}."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shell Defense",
                            "entries": [
                                "You can withdraw into your shell as an action. Until you emerge, you gain a +4 bonus to your AC, and you have advantage on Strength and Constitution saving throws. While in your shell, you are {@condition prone}, your speed is 0 and can't increase, you have disadvantage on Dexterity saving throws, you can't take reactions, and the only action you can take is a bonus action to emerge from your shell."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Tortle",
                    "source": "TTP",
                    "page": 3,
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 181
                        }
                    ],
                    "reprintedAs": [
                        "Tortle|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "wis": 1
                        }
                    ],
                    "age": {
                        "mature": 15,
                        "max": 50
                    },
                    "traitTags": [
                        "Natural Armor",
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "survival": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "aquan": true,
                            "common": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "entries": [
                                "{@note The Tortle Package is considered part of Xanathar's Guide to Everything for Adventurers League character creation.}"
                            ]
                        },
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Young tortles crawl for a few weeks after birth before learning to walk on two legs. They reach adulthood by the age of 15 and live an average of 50 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Tortles tend to lead orderly, ritualistic lives. They develop customs and routines, becoming more set in their ways as they age. Most are lawful good. A few can be selfish and greedy, tending more toward evil, but it's unusual for a tortle to shuck off order in favor of chaos."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Tortle adults stand 5 to 6 feet tall and average 450 pounds. Their shells account for roughly one-third of their weight. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Claws",
                            "entries": [
                                "Your claws are natural weapons, which you can use to make unarmed strikes. If you hit with them, you deal slashing damage equal to {@damage 1d4} + your Strength modifier, instead of bludgeoning damage normal for an unarmed strike."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Hold Breath",
                            "entries": [
                                "You can hold your breath for up to 1 hour at a time. Tortles aren't natural swimmers, but they can remain underwater for some time before needing to come up for air."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Natural Armor",
                            "entries": [
                                "Due to your shell and the shape of your body, you are ill-suited to wearing armor. Your shell provides ample protection, however; it gives you a base AC of 17 (your Dexterity modifier doesn't affect this number). You gain no benefit from wearing armor, but if you are using a shield, you can apply the shield's bonus as normal."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Shell Defense",
                            "entries": [
                                "You can withdraw into your shell as an action. Until you emerge, you gain a +4 bonus to AC, and you have advantage on Strength and Constitution saving throws. While in your shell, you are {@condition prone}, your speed is 0 and can't increase, you have disadvantage on Dexterity saving throws, you can't take reactions, and the only action you can take is a bonus action to emerge from your shell."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Survival Instinct",
                            "entries": [
                                "You gain proficiency in the {@skill Survival} skill. Tortles have finely honed survival instincts."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Aquan and Common."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Triton",
                    "source": "MOT",
                    "page": 26,
                    "_copy": {
                        "name": "Triton",
                        "source": "VGM",
                        "_mod": {
                            "entries": [
                                {
                                    "mode": "appendArr",
                                    "items": {
                                        "name": "Alignment",
                                        "type": "entries",
                                        "entries": [
                                            "Tritons tend toward neutrality. Their culture encourages them to be mindful of life's currents, knowing when to harness fate's tides and when to flow along with them."
                                        ]
                                    }
                                }
                            ]
                        },
                        "_preserve": {
                            "reprintedAs": true
                        }
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Triton",
                    "source": "MPMM",
                    "page": 35,
                    "lineage": "VRGR",
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": true
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Amphibious"
                    ],
                    "resist": [
                        "cold"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "1": {
                                    "daily": {
                                        "1": [
                                            "fog cloud"
                                        ]
                                    }
                                },
                                "3": {
                                    "daily": {
                                        "1": [
                                            "gust of wind"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "water walk"
                                        ]
                                    }
                                }
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Speed",
                            "entries": [
                                "Your walking speed is 30 feet, and you have a swimming speed equal to your walking speed."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Amphibious",
                            "entries": [
                                "You can breathe air and water."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Control Air and Water",
                            "entries": [
                                "You can cast {@spell fog cloud} with this trait. Starting at 3rd level, you can cast the {@spell gust of wind} spell with this trait. Starting at 5th level, you can also cast the {@spell water walk} spell with it. Once you cast any of these spells with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast these spells using any spell slots you have of the appropriate level.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Emissary of the Sea",
                            "entries": [
                                "You can communicate simple ideas to any Beast, Elemental, or Monstrosity that has a swimming speed. It can understand your words, though you have no special ability to understand it in return."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Guardian of the Depths",
                            "entries": [
                                "Adapted to the frigid ocean depths, you have resistance to cold damage."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Triton",
                    "source": "VGM",
                    "page": 115,
                    "reprintedAs": [
                        "Triton|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": 30
                    },
                    "ability": [
                        {
                            "str": 1,
                            "cha": 1,
                            "con": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 54,
                        "heightMod": "2d10",
                        "baseWeight": 90,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 15,
                        "max": 200
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Amphibious"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "primordial": true
                        }
                    ],
                    "resist": [
                        "cold"
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/triton.mp3"
                    },
                    "additionalSpells": [
                        {
                            "innate": {
                                "1": {
                                    "daily": {
                                        "1": [
                                            "fog cloud"
                                        ]
                                    }
                                },
                                "3": {
                                    "daily": {
                                        "1": [
                                            "gust of wind"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "wall of water|xge"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha"
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Tritons reach maturity around age 15 and can live up to 200 years."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Tritons are slightly shorter than humans, averaging about 5 feet tall. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Swim Speed",
                            "entries": [
                                "You have a swimming speed of 30 feet."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Amphibious",
                            "entries": [
                                "You can breathe air and water."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Control Air and Water",
                            "entries": [
                                "A child of the sea, you can call on the magic of elemental air and water. You can cast {@spell fog cloud} with this trait. Starting at 3rd level, you can cast {@spell gust of wind} with it, and starting at 5th level, you can also cast {@spell wall of water|xge} with it. Once you cast a spell with this trait, you can't cast that spell with it again until you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Darkvision",
                            "type": "entries",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ]
                        },
                        {
                            "name": "Emissary of the Sea",
                            "entries": [
                                "Aquatic beasts have an extraordinary affinity with your people. You can communicate simple ideas with beasts that can breathe water. They can understand the meaning of your words, though you have no special ability to understand them in return."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Guardians of the Depths",
                            "entries": [
                                "Adapted to even the most extreme ocean depths, you have resistance to cold damage."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Primordial."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Troglodyte",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 2,
                            "con": 2,
                            "int": -4,
                            "cha": -4
                        }
                    ],
                    "darkvision": 60,
                    "traitTags": [
                        "Natural Armor",
                        "NPC Race",
                        "Sunlight Sensitivity"
                    ],
                    "languageProficiencies": [
                        {
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Chameleon Skin",
                            "type": "entries",
                            "entries": [
                                "You have advantage on Dexterity ({@skill Stealth}) checks made to hide."
                            ]
                        },
                        {
                            "name": "Stench",
                            "type": "entries",
                            "entries": [
                                "Any creature other than a troglodyte that starts its turn within 5 ft. of you must succeed on a DC 12 Constitution saving throw or be {@condition poisoned} until the start of the creature's next turn. On a successful saving throw, the creature is immune to the stench of all troglodytes for 1 hour."
                            ]
                        },
                        {
                            "name": "Sunlight Sensitivity",
                            "type": "entries",
                            "entries": [
                                "While in sunlight, you have disadvantage on attack rolls, as well as on Wisdom ({@skill Perception}) checks that rely on sight."
                            ]
                        },
                        {
                            "name": "Natural Armor",
                            "entries": [
                                "Your thick hide grants you a +1 bonus to Armor Class."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Troglodyte."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Vampire",
                    "source": "PSZ",
                    "page": 14,
                    "otherSources": [
                        {
                            "source": "PSX",
                            "page": 14
                        }
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "cha": 2
                        }
                    ],
                    "darkvision": 60,
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "resist": [
                        "necrotic"
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Vampires don't mature and age in the same way that other races do. Every living vampire is either a bloodchief, infected by Ulamog's influence in the distant reaches of history, or was spawned by a bloodchief from a living human. Most vampires are thus very old, but few have any memory of their earliest years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Vampires have no innate tendency toward evil, but consuming the life energy of other creatures often pushes them to that end. Regardless of their moral bent, the strict hierarchies of their bloodchiefs inclines them toward a lawful alignment."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Vampires are about the same size and build as humans. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Blood Thirst",
                            "entries": [
                                "You can drain blood and life energy from a willing creature, or one that is {@condition grappled} by you, {@condition incapacitated}, or {@condition restrained}. Make a melee attack against the target. If you hit, you deal 1 piercing damage and {@dice 1d6} necrotic damage. The target's hit point maximum is reduced by an amount equal to the necrotic damage taken, and you regain hit points equal to that amount. The reduction lasts until the target finishes a long rest. The target dies if this effect reduces its hit point maximum to 0."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "Thanks to your heritage, you have superior vision in dark and dim conditions. You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Vampire."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Vampiric Resistance",
                            "entries": [
                                "You have resistance to necrotic damage."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Vedalken",
                    "source": "GGR",
                    "page": 21,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "int": 2,
                            "wis": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 64,
                        "heightMod": "2d10",
                        "baseWeight": 110,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 40,
                        "max": 500
                    },
                    "traitTags": [
                        "Skill Bonus Dice",
                        "Tool Bonus Dice"
                    ],
                    "skillProficiencies": [
                        {
                            "choose": {
                                "from": [
                                    "arcana",
                                    "history",
                                    "investigation",
                                    "medicine",
                                    "performance",
                                    "sleight of hand"
                                ]
                            }
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true,
                            "anyStandard": 1
                        }
                    ],
                    "toolProficiencies": [
                        {
                            "any": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Vedalken mature slower than humans do, reaching maturity around age 40. Their life span is typically 350 years, with some living to the age of 500."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Vedalken are usually lawful and non-evil."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Tall and slender, Vedalken stand 6 to 6½ feet tall on average and usually weigh less than 200 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Vedalken Dispassion",
                            "entries": [
                                "You have advantage on all Intelligence, Wisdom, and Charisma saving throws."
                            ]
                        },
                        {
                            "name": "Tireless Precision",
                            "entries": [
                                "You are proficient in one of the following skills of your choice: {@skill Arcana}, {@skill History}, {@skill Investigation}, {@skill Medicine}, {@skill Performance}, or {@skill Sleight of Hand}. You are also proficient with one {@book tool|phb|5|tools} of your choice.",
                                "Whenever you make an ability check with the chosen skill or tool, roll a {@dice d4} and add the number rolled to the check's total."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Partially Amphibious",
                            "entries": [
                                "By absorbing oxygen through your skin, you can breathe underwater for up to 1 hour. Once you've reached that limit, you can't use this trait again until you finish a long rest."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common, Vedalken, and one other language of your choice."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Vedalken",
                    "source": "PSK",
                    "page": 23,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "int": 2,
                            "wis": 1
                        }
                    ],
                    "age": {
                        "mature": 40,
                        "max": 500
                    },
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Vedalken mature at the same rate humans do, and most are expected to settle down into an adult life by around age 40. They can live 350 to almost 500 years."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Vedalken are most often lawful and rarely evil."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Vedalken are taller than humans but more slender. They average 6 to 6½ feet tall, but usually weigh less than 200 pounds. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Vedalken. The Vedalken language is renowned for its technical treatises and its catalogs of knowledge about the natural world and the aether that pervades it."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Vedalken Cunning",
                            "entries": [
                                "You have advantage on all Intelligence, Wisdom, and Charisma saving throws against magic."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Aether Lore",
                            "entries": [
                                "Whenever you make an Intelligence ({@skill History}) check related to magic items or aether-powered technological devices, you can add twice your proficiency bonus, instead of any proficiency bonus you normally apply."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Verdan",
                    "source": "AI",
                    "page": 72,
                    "size": [
                        "V"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "con": 1,
                            "cha": 2
                        }
                    ],
                    "age": {
                        "mature": 24,
                        "max": 200
                    },
                    "skillProficiencies": [
                        {
                            "persuasion": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "goblin": true,
                            "anyStandard": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Verdan reach adulthood at around the age of 24, and it is thought that they might live to nearly 200 years old. However, because no verdan has died of old age since the race's initial creation, their upper age limits remain subject to speculation."
                            ]
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Verdan are generally good, although their absence of racial identity and shared history can sometimes see individual verdan become untethered from any moral or ethical framework."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Verdan start out similar in size to the goblins they were created from, ranging from 3 to 4 feet in height. But at some point after reaching maturity, each verdan undergoes a sudden growth spurt of 2 feet or more. At 1st level, you are a Small creature. When you reach 5th level, you become a Medium creature."
                            ]
                        },
                        {
                            "name": "Black Blood Healing",
                            "entries": [
                                "The black blood that is a sign of your people's connection to That-Which-Endures boosts your natural healing. When you roll a 1 or 2 on any Hit Die you spend at the end of a short rest, you can reroll the die and must use the new roll."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Limited Telepathy",
                            "entries": [
                                "You can telepathically speak to any creature you can see within 30 feet of you. You don't need to share a language with the creature for it to understand your telepathy, but it must be able to understand at least one language. This process of communication is slow and limited, allowing you to transmit and receive only simple ideas and straightforward concepts."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Persuasive",
                            "entries": [
                                "Your people's lack of history makes you trustworthy and humble. You have proficiency in the {@skill Persuasion} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Telepathic Insight",
                            "entries": [
                                "Your mind's connection to the world around you strengthens your will. You have advantage on all Wisdom and Charisma saving throws."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Language",
                            "entries": [
                                "You speak, read, and write Common, Goblin, and one additional language of your choice. This language typically has some connection to one of the areas or cultures that has been part of your life."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Warforged",
                    "source": "ERLW",
                    "page": 35,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "con": 2,
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "int",
                                    "wis",
                                    "cha"
                                ],
                                "count": 1
                            }
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 70,
                        "heightMod": "2d6",
                        "baseWeight": 270,
                        "weightMod": "4"
                    },
                    "age": {
                        "mature": 2,
                        "max": 30
                    },
                    "traitTags": [
                        "Improved Resting",
                        "Natural Armor"
                    ],
                    "skillProficiencies": [
                        {
                            "any": 1
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "anyStandard": 1
                        }
                    ],
                    "toolProficiencies": [
                        {
                            "any": 1
                        }
                    ],
                    "resist": [
                        "poison"
                    ],
                    "conditionImmune": [
                        "disease"
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "entries": [
                                "A typical warforged is between two and thirty years old. The maximum warforged lifespan remains a mystery; so far, warforged have shown no signs of deterioration due to age. You are immune to magical aging effects."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Alignment",
                            "entries": [
                                "Most warforged take comfort in order and discipline, tending toward law and neutrality. But some have absorbed the morality, or lack thereof, of the beings with which they served."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Your size is Medium."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Constructed Resilience",
                            "entries": [
                                "You were created to have remarkable fortitude, represented by the following benefits:",
                                {
                                    "type": "list",
                                    "items": [
                                        "You have advantage on saving throws against being {@condition poisoned}, and you have resistance to poison damage.",
                                        "You don't need to eat, drink, or breathe.",
                                        "You are immune to disease.",
                                        "You don't need to sleep, and magic can't put you to sleep."
                                    ]
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Sentry's Rest",
                            "entries": [
                                "When you take a long rest, you must spend at least six hours in an inactive, motionless state, rather than sleeping. In this state, you appear inert, but it doesn't render you {@condition unconscious}, and you can see and hear as normal."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Integrated Protection",
                            "entries": [
                                "Your body has built-in defensive layers, which can be enhanced with armor:",
                                {
                                    "type": "list",
                                    "items": [
                                        "You gain a +1 bonus to Armor Class.",
                                        "You can don only armor with which you have proficiency. To don armor other than a shield, you must incorporate it into your body over the course of 1 hour, during which you remain in contact with the armor. To doff armor, you must spend 1 hour removing it. You can rest while donning or doffing armor in this way.",
                                        "While you live, the armor incorporated into your body can't be removed against your will."
                                    ]
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Specialized Design",
                            "entries": [
                                "You gain one skill proficiency and one tool proficiency of your choice."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and one other language of your choice."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Yuan-Ti",
                    "source": "MPMM",
                    "page": 36,
                    "lineage": "VRGR",
                    "size": [
                        "S",
                        "M"
                    ],
                    "speed": 30,
                    "darkvision": 60,
                    "traitTags": [
                        "Magic Resistance"
                    ],
                    "resist": [
                        "poison"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "1": [
                                    "animal friendship"
                                ],
                                "3": {
                                    "daily": {
                                        "1": [
                                            "suggestion"
                                        ]
                                    }
                                }
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "poison spray#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "You are Medium or Small. You choose the size when you select this race."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light and in darkness as if it were dim light. You discern colors in that darkness only as shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Magic Resistance",
                            "entries": [
                                "You have advantage on saving throws against spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Poison Resilience",
                            "entries": [
                                "You have advantage on saving throws you make to avoid or end the {@condition poisoned} condition on yourself. You also have resistance to poison damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Serpentine Spellcasting",
                            "entries": [
                                "You know the {@spell poison spray} cantrip. You can cast {@spell animal friendship} an unlimited number of times with this trait, but you can target only snakes with it. Starting at 3rd level, you can also cast {@spell suggestion} with this trait. Once you cast it, you can't do so again until you finish a long rest. You can also cast it using any spell slots you have of 2nd level or higher.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Yuan-ti Pureblood",
                    "source": "VGM",
                    "page": 120,
                    "reprintedAs": [
                        "Yuan-Ti|MPMM"
                    ],
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "cha": 2,
                            "int": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 56,
                        "heightMod": "2d10",
                        "baseWeight": 110,
                        "weightMod": "2d4"
                    },
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "darkvision": 60,
                    "traitTags": [
                        "Magic Resistance",
                        "Monstrous Race"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "abyssal": true,
                            "draconic": true
                        }
                    ],
                    "immune": [
                        "poison"
                    ],
                    "conditionImmune": [
                        "poisoned"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "1": [
                                    "animal friendship"
                                ],
                                "3": {
                                    "daily": {
                                        "1": [
                                            "suggestion"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "poison spray#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Purebloods mature at the same rate as humans and have lifespans similar in length to theirs."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Purebloods match humans in average size and weight. Your size is Medium."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Innate Spellcasting",
                            "entries": [
                                "You know the {@spell poison spray} cantrip. You can cast {@spell animal friendship} an unlimited number of times with this trait, but you can target only snakes with it. Starting at 3rd level, you can also cast {@spell suggestion} with this trait. Once you cast it, you can't do so again until you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Magic Resistance",
                            "entries": [
                                "You have advantage on saving throws against spells and other magical effects."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Poison Immunity",
                            "entries": [
                                "You are immune to poison damage and the {@condition poisoned} condition."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common, Abyssal, and Draconic."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Zombie",
                    "source": "DMG",
                    "page": 282,
                    "size": [
                        "M"
                    ],
                    "speed": 30,
                    "ability": [
                        {
                            "str": 1,
                            "con": 2,
                            "int": -6,
                            "wis": -4,
                            "cha": -4
                        }
                    ],
                    "darkvision": 60,
                    "traitTags": [
                        "Improved Resting",
                        "NPC Race"
                    ],
                    "immune": [
                        "poison"
                    ],
                    "conditionImmune": [
                        "poisoned"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Undead Fortitude",
                            "entries": [
                                "If damage reduces you to 0 hit points, you must make a Constitution saving throw with a DC of 5+the damage taken, unless the damage is radiant or from a critical hit. On a success, you drop to 1 hit point instead."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Undead Nature",
                            "entries": [
                                "You are immune to poison damage, and you can't be {@condition poisoned}. You don't require air, food, drink, or sleep."
                            ]
                        },
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can't speak, but you can understand the languages you knew in life."
                            ],
                            "type": "entries"
                        }
                    ]
                }
            ],
            "subrace": [
                {
                    "name": "Fallen",
                    "source": "VGM",
                    "raceName": "Aasimar",
                    "raceSource": "VGM",
                    "page": 105,
                    "ability": [
                        {
                            "str": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Necrotic Shroud",
                            "entries": [
                                "Starting at 3rd level, you can use your action to unleash the divine energy within yourself, causing your eyes to turn into pools of darkness and two skeletal, ghostly, flightless wings to sprout from your back. The instant you transform, other creatures within 10 feet of you that can see you must succeed on a Charisma saving throw (DC 8 + your proficiency bonus + your Charisma modifier) or become {@condition frightened} of you until the end of your next turn.",
                                "Your transformation lasts for 1 minute or until you end it as a bonus action. During it, once on each of your turns, you can deal extra necrotic damage to one target when you deal damage to it with an attack or a spell. The extra necrotic damage equals your level.",
                                "Once you use this trait, you can't use it again until you finish a long rest."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Protector",
                    "source": "VGM",
                    "raceName": "Aasimar",
                    "raceSource": "VGM",
                    "page": 105,
                    "ability": [
                        {
                            "wis": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Radiant Soul",
                            "entries": [
                                "Starting at 3rd level, you can use your action to unleash the divine energy within yourself, causing your eyes to glimmer and two luminous, incorporeal wings to sprout from your back.",
                                "Your transformation lasts for 1 minute or until you end it as a bonus action. During it, you have a flying speed of 30 feet, and once on each of your turns, you can deal extra radiant damage to one target when you deal damage to it with an attack or a spell. The extra radiant damage equals your level.",
                                "Once you use this trait, you can't use it again until you finish a long rest."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Scourge",
                    "source": "VGM",
                    "raceName": "Aasimar",
                    "raceSource": "VGM",
                    "page": 105,
                    "ability": [
                        {
                            "con": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Radiant Consumption",
                            "entries": [
                                "Starting at 3rd level, you can use your action to unleash the divine energy within yourself, causing a searing light to radiate from you, pour out of your eyes and mouth, and threaten to char you.",
                                "Your transformation lasts for 1 minute or until you end it as a bonus action. During it, you shed bright light in a 10-foot radius and dim light for an additional 10 feet, and at the end of each of your turns, you and each creature within 10 feet of you take radiant damage equal to half your level (rounded up). In addition, once on each of your turns, you can deal extra radiant damage to one target when you deal damage to it with an attack or a spell. The extra radiant damage equals your level.",
                                "Once you use this trait, you can't use it again until you finish a long rest."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Hawk-Headed",
                    "source": "PSA",
                    "raceName": "Aven",
                    "raceSource": "PSA",
                    "page": 16,
                    "ability": [
                        {
                            "wis": 2
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "perception": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Hawkeyed",
                            "entries": [
                                "You have proficiency in the {@skill Perception} skill. In addition, attacking at long range doesn't impose disadvantage on your ranged weapon attack rolls."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Ibis-Headed",
                    "source": "PSA",
                    "raceName": "Aven",
                    "raceSource": "PSA",
                    "page": 16,
                    "ability": [
                        {
                            "int": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Kefnet's Blessing",
                            "entries": [
                                "You can add half your proficiency bonus, rounded down, to any Intelligence check you make that doesn't already include your proficiency bonus."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "source": "PHB",
                    "raceName": "Dragonborn",
                    "raceSource": "PHB",
                    "page": 32,
                    "srd": true,
                    "hasFluff": true,
                    "hasFluffImages": true,
                    "_versions": [
                        {
                            "_template": {
                                "name": "Dragonborn ({{color}})",
                                "source": "PHB",
                                "_mod": {
                                    "entries": [
                                        {
                                            "mode": "removeArr",
                                            "names": "Draconic Ancestry"
                                        },
                                        {
                                            "mode": "replaceArr",
                                            "replace": "Breath Weapon",
                                            "items": {
                                                "type": "entries",
                                                "name": "Breath Weapon",
                                                "entries": [
                                                    "You can use your action to exhale destructive energy in a {{area}}.",
                                                    "When you use your breath weapon, each creature in the area of the exhalation must make a {{savingThrow}} saving throw. The DC for this saving throw equals 8 + your Constitution modifier + your proficiency bonus. A creature takes {@damage 2d6} {{damageType}} damage on a failed save, and half as much damage on a successful one. The damage increases to {@damage 3d6} at 6th level, {@damage 4d6} at 11th level, and {@damage 5d6} at 16th level.",
                                                    "After you use your breath weapon, you can't use it again until you complete a short or long rest."
                                                ]
                                            }
                                        },
                                        {
                                            "mode": "replaceArr",
                                            "replace": "Damage Resistance",
                                            "items": {
                                                "type": "entries",
                                                "name": "Damage Resistance",
                                                "entries": [
                                                    "You have resistance to {{damageType}} damage."
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            "_implementations": [
                                {
                                    "_variables": {
                                        "color": "Black",
                                        "damageType": "acid",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    },
                                    "resist": [
                                        "acid"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Blue",
                                        "damageType": "lightning",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    },
                                    "resist": [
                                        "lightning"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Brass",
                                        "damageType": "fire",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    },
                                    "resist": [
                                        "fire"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Bronze",
                                        "damageType": "lightning",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    },
                                    "resist": [
                                        "lightning"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Copper",
                                        "damageType": "acid",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    },
                                    "resist": [
                                        "acid"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Gold",
                                        "damageType": "fire",
                                        "area": "15-foot cone",
                                        "savingThrow": "Dexterity"
                                    },
                                    "resist": [
                                        "fire"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Green",
                                        "damageType": "poison",
                                        "area": "15-foot cone",
                                        "savingThrow": "Constitution"
                                    },
                                    "resist": [
                                        "poison"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Red",
                                        "damageType": "fire",
                                        "area": "15-foot cone",
                                        "savingThrow": "Dexterity"
                                    },
                                    "resist": [
                                        "fire"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "Silver",
                                        "damageType": "cold",
                                        "area": "15-foot cone",
                                        "savingThrow": "Constitution"
                                    },
                                    "resist": [
                                        "cold"
                                    ]
                                },
                                {
                                    "_variables": {
                                        "color": "White",
                                        "damageType": "cold",
                                        "area": "15-foot cone",
                                        "savingThrow": "Constitution"
                                    },
                                    "resist": [
                                        "cold"
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Draconblood",
                    "source": "EGW",
                    "raceName": "Dragonborn",
                    "raceSource": "PHB",
                    "page": 168,
                    "ability": [
                        {
                            "int": 2,
                            "cha": 1
                        }
                    ],
                    "darkvision": 60,
                    "resist": null,
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Forceful Presence",
                            "entries": [
                                "You can use your understanding of creative diplomacy or intimidation to guide a conversation in your favor. When you make a Charisma ({@skill Intimidation} or {@skill Persuasion}) check, you can do so with advantage. Once you use this trait, you can't do so again until you finish a short or long rest."
                            ],
                            "data": {
                                "overwrite": "Damage Resistance"
                            }
                        },
                        {
                            "name": "Draconic Ancestry",
                            "entries": [
                                "You have draconic ancestry. Choose one type of dragon from the Draconic Ancestry table. Your breath weapon is determined by the dragon type, as shown in the table.",
                                {
                                    "type": "table",
                                    "caption": "Draconic Ancestry",
                                    "colLabels": [
                                        "Dragon",
                                        "Damage Type",
                                        "Breath Weapon"
                                    ],
                                    "colStyles": [
                                        "col-3 text-center",
                                        "col-3 text-center",
                                        "col-6"
                                    ],
                                    "rows": [
                                        [
                                            "Black",
                                            "Acid",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Blue",
                                            "Lightning",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Brass",
                                            "Fire",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Bronze",
                                            "Lightning",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Copper",
                                            "Acid",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Gold",
                                            "Fire",
                                            "15 ft. cone (Dex. save)"
                                        ],
                                        [
                                            "Green",
                                            "Poison",
                                            "15 ft. cone (Con. save)"
                                        ],
                                        [
                                            "Red",
                                            "Fire",
                                            "15 ft. cone (Dex. save)"
                                        ],
                                        [
                                            "Silver",
                                            "Cold",
                                            "15 ft. cone (Con. save)"
                                        ],
                                        [
                                            "White",
                                            "Cold",
                                            "15 ft. cone (Con. save)"
                                        ]
                                    ]
                                }
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Draconic Ancestry"
                            }
                        }
                    ],
                    "overwrite": {
                        "ability": true,
                        "traitTags": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true,
                    "_versions": [
                        {
                            "_template": {
                                "name": "Dragonborn (Draconblood; {{color}})",
                                "source": "EGW",
                                "_mod": {
                                    "entries": [
                                        {
                                            "mode": "removeArr",
                                            "names": "Draconic Ancestry"
                                        },
                                        {
                                            "mode": "replaceArr",
                                            "replace": "Breath Weapon",
                                            "items": {
                                                "type": "entries",
                                                "name": "Breath Weapon",
                                                "entries": [
                                                    "You can use your action to exhale destructive energy in a {{area}}.",
                                                    "When you use your breath weapon, each creature in the area of the exhalation must make a {{savingThrow}} saving throw. The DC for this saving throw equals 8 + your Constitution modifier + your proficiency bonus. A creature takes {@damage 2d6} {{damageType}} damage on a failed save, and half as much damage on a successful one. The damage increases to {@damage 3d6} at 6th level, {@damage 4d6} at 11th level, and {@damage 5d6} at 16th level.",
                                                    "After you use your breath weapon, you can't use it again until you complete a short or long rest."
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            "_implementations": [
                                {
                                    "_variables": {
                                        "color": "Black",
                                        "damageType": "acid",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Blue",
                                        "damageType": "lightning",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Brass",
                                        "damageType": "fire",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Bronze",
                                        "damageType": "lightning",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Copper",
                                        "damageType": "acid",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Gold",
                                        "damageType": "fire",
                                        "area": "15-foot cone",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Green",
                                        "damageType": "poison",
                                        "area": "15-foot cone",
                                        "savingThrow": "Constitution"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Red",
                                        "damageType": "fire",
                                        "area": "15-foot cone",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Silver",
                                        "damageType": "cold",
                                        "area": "15-foot cone",
                                        "savingThrow": "Constitution"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "White",
                                        "damageType": "cold",
                                        "area": "15-foot cone",
                                        "savingThrow": "Constitution"
                                    }
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Ravenite",
                    "source": "EGW",
                    "raceName": "Dragonborn",
                    "raceSource": "PHB",
                    "page": 168,
                    "ability": [
                        {
                            "str": 2,
                            "con": 1
                        }
                    ],
                    "darkvision": 60,
                    "resist": null,
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Vengeful Assault",
                            "entries": [
                                "When you take damage from a creature in range of a weapon you are wielding, you can use your reaction to make an attack with the weapon against that creature. Once you use this trait, you can't do so again until you finish a short or long rest."
                            ],
                            "data": {
                                "overwrite": "Damage Resistance"
                            }
                        },
                        {
                            "name": "Draconic Ancestry",
                            "entries": [
                                "You have draconic ancestry. Choose one type of dragon from the Draconic Ancestry table. Your breath weapon is determined by the dragon type, as shown in the table.",
                                {
                                    "type": "table",
                                    "caption": "Draconic Ancestry",
                                    "colLabels": [
                                        "Dragon",
                                        "Damage Type",
                                        "Breath Weapon"
                                    ],
                                    "colStyles": [
                                        "col-3 text-center",
                                        "col-3 text-center",
                                        "col-6"
                                    ],
                                    "rows": [
                                        [
                                            "Black",
                                            "Acid",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Blue",
                                            "Lightning",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Brass",
                                            "Fire",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Bronze",
                                            "Lightning",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Copper",
                                            "Acid",
                                            "5 by 30 ft. line (Dex. save)"
                                        ],
                                        [
                                            "Gold",
                                            "Fire",
                                            "15 ft. cone (Dex. save)"
                                        ],
                                        [
                                            "Green",
                                            "Poison",
                                            "15 ft. cone (Con. save)"
                                        ],
                                        [
                                            "Red",
                                            "Fire",
                                            "15 ft. cone (Dex. save)"
                                        ],
                                        [
                                            "Silver",
                                            "Cold",
                                            "15 ft. cone (Con. save)"
                                        ],
                                        [
                                            "White",
                                            "Cold",
                                            "15 ft. cone (Con. save)"
                                        ]
                                    ]
                                }
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Draconic Ancestry"
                            }
                        }
                    ],
                    "overwrite": {
                        "ability": true,
                        "traitTags": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true,
                    "_versions": [
                        {
                            "_template": {
                                "name": "Dragonborn (Ravenite; {{color}})",
                                "source": "EGW",
                                "_mod": {
                                    "entries": [
                                        {
                                            "mode": "removeArr",
                                            "names": "Draconic Ancestry"
                                        },
                                        {
                                            "mode": "replaceArr",
                                            "replace": "Breath Weapon",
                                            "items": {
                                                "type": "entries",
                                                "name": "Breath Weapon",
                                                "entries": [
                                                    "You can use your action to exhale destructive energy in a {{area}}.",
                                                    "When you use your breath weapon, each creature in the area of the exhalation must make a {{savingThrow}} saving throw. The DC for this saving throw equals 8 + your Constitution modifier + your proficiency bonus. A creature takes {@damage 2d6} {{damageType}} damage on a failed save, and half as much damage on a successful one. The damage increases to {@damage 3d6} at 6th level, {@damage 4d6} at 11th level, and {@damage 5d6} at 16th level.",
                                                    "After you use your breath weapon, you can't use it again until you complete a short or long rest."
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            "_implementations": [
                                {
                                    "_variables": {
                                        "color": "Black",
                                        "damageType": "acid",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Blue",
                                        "damageType": "lightning",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Brass",
                                        "damageType": "fire",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Bronze",
                                        "damageType": "lightning",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Copper",
                                        "damageType": "acid",
                                        "area": "5-foot-wide, 30-foot-long line",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Gold",
                                        "damageType": "fire",
                                        "area": "15-foot cone",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Green",
                                        "damageType": "poison",
                                        "area": "15-foot cone",
                                        "savingThrow": "Constitution"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Red",
                                        "damageType": "fire",
                                        "area": "15-foot cone",
                                        "savingThrow": "Dexterity"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "Silver",
                                        "damageType": "cold",
                                        "area": "15-foot cone",
                                        "savingThrow": "Constitution"
                                    }
                                },
                                {
                                    "_variables": {
                                        "color": "White",
                                        "damageType": "cold",
                                        "area": "15-foot cone",
                                        "savingThrow": "Constitution"
                                    }
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Duergar",
                    "source": "MTF",
                    "raceName": "Dwarf",
                    "raceSource": "PHB",
                    "page": 81,
                    "otherSources": [
                        {
                            "source": "SCAG",
                            "page": 104
                        }
                    ],
                    "reprintedAs": [
                        "Duergar|MPMM"
                    ],
                    "ability": [
                        {
                            "str": 1
                        }
                    ],
                    "darkvision": 120,
                    "traitTags": [
                        "Sunlight Sensitivity"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "dwarvish": true,
                            "undercommon": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "enlarge/reduce"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "invisibility"
                                        ]
                                    }
                                }
                            },
                            "ability": "int"
                        }
                    ],
                    "entries": [
                        {
                            "name": "Superior Darkvision",
                            "entries": [
                                "Accustomed to life underground, you have superior vision in dark and dim conditions. You can see in dim light within 120 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "data": {
                                "overwrite": "Darkvision"
                            },
                            "type": "entries"
                        },
                        {
                            "name": "Duergar Resilience",
                            "entries": [
                                "You have advantage on saving throws against poison, and you have resistance against poison damage. You also have advantage on saving throws against illusions and against being {@condition charmed} or {@condition paralyzed}."
                            ],
                            "data": {
                                "overwrite": "Dwarven Resilience"
                            },
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common, Dwarvish, and Undercommon."
                            ],
                            "data": {
                                "overwrite": "Languages"
                            },
                            "type": "entries"
                        },
                        {
                            "name": "Duergar Magic",
                            "entries": [
                                "When you reach 3rd level, you can cast the {@spell Enlarge/Reduce} spell on yourself once with this trait, using only the spell's enlarge option. When you reach 5th level, you can cast the {@spell Invisibility} spell on yourself once with this trait. You don't need material components for either spell, and you can't cast them while you're in direct sunlight, although sunlight has no effect on them once cast. You regain the ability to cast these spells with this trait when you finish a long rest. Intelligence is your spellcasting ability for these spells."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Sunlight Sensitivity",
                            "entries": [
                                "You have disadvantage on attack rolls and Wisdom ({@skill Perception}) checks that rely on sight when you, the target of your attack, or whatever you are trying to perceive is in direct sunlight."
                            ],
                            "type": "entries"
                        }
                    ],
                    "overwrite": {
                        "languageProficiencies": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": false
                },
                {
                    "name": "Hill",
                    "source": "PHB",
                    "raceName": "Dwarf",
                    "raceSource": "PHB",
                    "page": 20,
                    "srd": true,
                    "basicRules": true,
                    "ability": [
                        {
                            "wis": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 44,
                        "heightMod": "2d4",
                        "baseWeight": 115,
                        "weightMod": "2d6"
                    },
                    "entries": [
                        {
                            "name": "Dwarven Toughness",
                            "entries": [
                                "Your hit point maximum increases by 1, and it increases by 1 every time you gain a level."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Mark of Warding",
                    "source": "ERLW",
                    "raceName": "Dwarf",
                    "raceSource": "PHB",
                    "page": 51,
                    "ability": [
                        {
                            "int": 1
                        }
                    ],
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice",
                        "Tool Bonus Dice"
                    ],
                    "additionalSpells": [
                        {
                            "expanded": {
                                "s1": [
                                    "alarm",
                                    "armor of agathys"
                                ],
                                "s2": [
                                    "arcane lock",
                                    "knock"
                                ],
                                "s3": [
                                    "glyph of warding",
                                    "magic circle"
                                ],
                                "s4": [
                                    "leomund's secret chest",
                                    "mordenkainen's faithful hound"
                                ],
                                "s5": [
                                    "antilife shell"
                                ]
                            },
                            "ability": "int",
                            "known": {
                                "1": [
                                    "alarm",
                                    "mage armor"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Warder's Intuition",
                            "entries": [
                                "When you make an Intelligence ({@skill Investigation}) check or an ability check using {@item thieves' tools|PHB}, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Wards and Seals",
                            "entries": [
                                "You can cast the {@spell alarm} and {@spell mage armor} spells with this trait. Starting at 3rd level, you can also cast the {@spell arcane lock} spell with it. Once you cast any of these spells with this trait, you can't cast that spell with it again until you finish a long rest. Intelligence is your spellcasting ability for these spells, and you don't need material components for them when you cast them with this trait."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Warding Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Warding Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell alarm}, {@spell armor of Agathys}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell arcane lock}, {@spell knock}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell glyph of warding}, {@spell magic circle}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell Leomund's secret chest}, {@spell Mordenkainen's faithful hound}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell antilife shell}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Mountain",
                    "source": "PHB",
                    "raceName": "Dwarf",
                    "raceSource": "PHB",
                    "page": 20,
                    "basicRules": true,
                    "ability": [
                        {
                            "str": 2
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 48,
                        "heightMod": "2d4",
                        "baseWeight": 130,
                        "weightMod": "2d6"
                    },
                    "armorProficiencies": [
                        {
                            "light": true,
                            "medium": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Dwarven Armor Training",
                            "entries": [
                                "You have proficiency with light and medium armor."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Drow",
                    "alias": [
                        "Dark"
                    ],
                    "source": "PHB",
                    "raceName": "Elf",
                    "raceSource": "PHB",
                    "page": 24,
                    "ability": [
                        {
                            "cha": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 53,
                        "heightMod": "2d6",
                        "baseWeight": 75,
                        "weightMod": "1d6"
                    },
                    "darkvision": 120,
                    "traitTags": [
                        "Sunlight Sensitivity"
                    ],
                    "weaponProficiencies": [
                        {
                            "rapier|phb": true,
                            "shortsword|phb": true,
                            "hand crossbow|phb": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "faerie fire"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "darkness"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "dancing lights#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Superior Darkvision",
                            "entries": [
                                "Accustomed to the depths of the Underdark, you have superior vision in dark and dim conditions. You can see in dim light within 120 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "data": {
                                "overwrite": "Darkvision"
                            },
                            "type": "entries"
                        },
                        {
                            "name": "Sunlight Sensitivity",
                            "entries": [
                                "You have disadvantage on attack rolls and on Wisdom ({@skill Perception}) checks that rely on sight when you, the target of your attack, or whatever you are trying to perceive is in direct sunlight."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Drow Magic",
                            "entries": [
                                "You know the {@spell dancing lights} cantrip. When you reach 3rd level, you can cast the {@spell faerie fire} spell once with this trait; you regain the ability to cast it when you finish a long rest. When you reach 5th level, you can also cast the {@spell darkness} spell once per day with this trait; you regain the ability to cast it when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Drow Weapon Training",
                            "entries": [
                                "You have proficiency with {@item rapier|phb|rapiers}, {@item shortsword|phb|shortswords}, and {@item hand crossbow|phb|hand crossbows}."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true
                },
                {
                    "name": "Eladrin",
                    "source": "DMG",
                    "raceName": "Elf",
                    "raceSource": "PHB",
                    "page": 286,
                    "ability": [
                        {
                            "int": 1
                        }
                    ],
                    "weaponProficiencies": [
                        {
                            "longsword|phb": true,
                            "shortsword|phb": true,
                            "shortbow|phb": true,
                            "longbow|phb": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "cha",
                            "known": {
                                "1": {
                                    "rest": {
                                        "1": [
                                            "misty step"
                                        ]
                                    }
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Elf Weapon Training",
                            "entries": [
                                "You have proficiency with the {@item longsword|phb}, {@item shortsword|phb}, {@item shortbow|phb}, and {@item longbow|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fey Step",
                            "entries": [
                                "You can cast the {@spell misty step} spell once using this trait. You regain the ability to do so when you finish a short or long rest."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Eladrin",
                    "source": "MTF",
                    "raceName": "Elf",
                    "raceSource": "PHB",
                    "page": 61,
                    "reprintedAs": [
                        "Eladrin|MPMM"
                    ],
                    "ability": [
                        {
                            "cha": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 54,
                        "heightMod": "2d12",
                        "baseWeight": 90,
                        "weightMod": "1d4"
                    },
                    "entries": [
                        "{@i Choose your eladrin's season: autumn, winter, spring, or summer. When finishing a long rest, you can change your season. See the \"Info\" tab for more information.}",
                        {
                            "name": "Fey Step",
                            "entries": [
                                "As a bonus action, you can magically teleport up to 30 feet to an unoccupied space you can see. Once you use this trait, you can't do so again until you finish a short or long rest.",
                                "When you reach 3rd level, your Fey Step gains an additional effect based on your season; if the effect requires a saving throw, the DC equals 8 + your proficiency bonus + your Charisma modifier:",
                                {
                                    "type": "list",
                                    "style": "list-hang-notitle",
                                    "items": [
                                        {
                                            "type": "item",
                                            "name": "Autumn",
                                            "entry": "Immediately after you use your Fey Step, up to two creatures of your choice that you can see within 10 feet of you must succeed on a Wisdom saving throw or be {@condition charmed} by you for 1 minute, or until you or your companions deal any damage to it."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Winter",
                                            "entry": "When you use your Fey Step, one creature of your choice that you can see within 5 feet of you before you teleport must succeed on a Wisdom saving throw or be {@condition frightened} of you until the end of your next turn."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Spring",
                                            "entry": "When you use your Fey Step, you can touch one willing creature within 5 feet of you. That creature then teleports instead of you, appearing in an unoccupied space of your choice that you can see within 30 feet of you."
                                        },
                                        {
                                            "type": "item",
                                            "name": "Summer",
                                            "entry": "Immediately after you use your Fey Step, each creature of your choice that you can see within 5 feet of you takes fire damage equal to your Charisma modifier (minimum of 1 damage)."
                                        }
                                    ]
                                }
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "High",
                    "source": "PHB",
                    "raceName": "Elf",
                    "raceSource": "PHB",
                    "page": 23,
                    "srd": true,
                    "basicRules": true,
                    "speed": 30,
                    "ability": [
                        {
                            "int": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 54,
                        "heightMod": "2d10",
                        "baseWeight": 90,
                        "weightMod": "1d4"
                    },
                    "languageProficiencies": [
                        {
                            "common": true,
                            "elvish": true,
                            "anyStandard": 1
                        }
                    ],
                    "weaponProficiencies": [
                        {
                            "longsword|phb": true,
                            "shortsword|phb": true,
                            "shortbow|phb": true,
                            "longbow|phb": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "int",
                            "known": {
                                "1": {
                                    "_": [
                                        {
                                            "choose": "level=0|class=Wizard"
                                        }
                                    ]
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Elf Weapon Training",
                            "entries": [
                                "You have proficiency with the {@item longsword|phb}, {@item shortsword|phb}, {@item shortbow|phb}, and {@item longbow|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Cantrip",
                            "entries": [
                                "You know one {@filter cantrip of your choice from the wizard spell list|spells|level=0|class=Wizard}. Intelligence is your spellcasting ability for it."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Extra Language",
                            "entries": [
                                "You can speak, read, and write one extra language of your choosing."
                            ],
                            "type": "entries"
                        }
                    ],
                    "overwrite": {
                        "languageProficiencies": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Mark of Shadow",
                    "source": "ERLW",
                    "raceName": "Elf",
                    "raceSource": "PHB",
                    "page": 49,
                    "ability": [
                        {
                            "cha": 1
                        }
                    ],
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "invisibility"
                                        ]
                                    }
                                }
                            },
                            "expanded": {
                                "s1": [
                                    "disguise self",
                                    "silent image"
                                ],
                                "s2": [
                                    "darkness",
                                    "pass without trace"
                                ],
                                "s3": [
                                    "clairvoyance",
                                    "major image"
                                ],
                                "s4": [
                                    "greater invisibility",
                                    "hallucinatory terrain"
                                ],
                                "s5": [
                                    "mislead"
                                ]
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "minor illusion#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Cunning Intuition",
                            "entries": [
                                "When you make a Charisma ({@skill Performance}) or Dexterity ({@skill Stealth}) check, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shape Shadows",
                            "entries": [
                                "You know the {@spell minor illusion} cantrip. Starting at 3rd level, you can cast the {@spell invisibility} spell once with this trait, and you regain the ability to cast it when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Shadow Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Shadow Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell disguise self}, {@spell silent image}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell darkness}, {@spell pass without trace}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell clairvoyance}, {@spell major image}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell greater invisibility}, {@spell hallucinatory terrain}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell mislead}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Pallid",
                    "source": "EGW",
                    "raceName": "Elf",
                    "raceSource": "PHB",
                    "page": 21,
                    "ability": [
                        {
                            "wis": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 54,
                        "heightMod": "2d10",
                        "baseWeight": 90,
                        "weightMod": "1d4"
                    },
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "sleep"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "invisibility"
                                        ]
                                    }
                                }
                            },
                            "ability": "wis",
                            "known": {
                                "1": [
                                    "light#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Incisive Sense",
                            "entries": [
                                "You have advantage on Intelligence ({@skill Investigation}) and Wisdom ({@skill Insight}) checks."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Blessing of the Moon Weaver",
                            "entries": [
                                "You know the {@spell light} cantrip. When you reach 3rd level, you can cast the {@spell sleep} spell once with this trait and regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell invisibility} spell (targeting yourself only) once with this trait and regain the ability to do so when you finish a long rest. Casting these spells with this trait doesn't require material components. Wisdom is your spellcasting ability for these spells."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Sea",
                    "source": "MTF",
                    "raceName": "Elf",
                    "raceSource": "PHB",
                    "page": 62,
                    "otherSources": [
                        {
                            "source": "EGW",
                            "page": 163
                        }
                    ],
                    "reprintedAs": [
                        "Sea Elf|MPMM"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": 30
                    },
                    "ability": [
                        {
                            "con": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 54,
                        "heightMod": "2d8",
                        "baseWeight": 90,
                        "weightMod": "1d4"
                    },
                    "traitTags": [
                        "Amphibious"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "elvish": true,
                            "aquan": true
                        }
                    ],
                    "weaponProficiencies": [
                        {
                            "spear|phb": true,
                            "trident|phb": true,
                            "light crossbow|phb": true,
                            "net|phb": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Sea Elf Training",
                            "entries": [
                                "You have proficiency with the {@item spear|phb}, {@item trident|phb}, {@item light crossbow|phb}, and {@item net|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Child of the Sea",
                            "entries": [
                                "You have a swimming speed of 30 feet, and you can breathe air and water."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Friend of the Sea",
                            "entries": [
                                "Using gestures and sounds, you can communicate simple ideas with any beast that has an innate swimming speed."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Extra Language",
                            "entries": [
                                "You can speak, read, and write Aquan."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true
                },
                {
                    "name": "Shadar-kai",
                    "source": "MTF",
                    "raceName": "Elf",
                    "raceSource": "PHB",
                    "page": 62,
                    "reprintedAs": [
                        "Shadar-Kai|MPMM"
                    ],
                    "ability": [
                        {
                            "con": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 56,
                        "heightMod": "2d8",
                        "baseWeight": 90,
                        "weightMod": "1d4"
                    },
                    "resist": [
                        "necrotic"
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Necrotic Resistance",
                            "entries": [
                                "You have resistance to necrotic damage."
                            ]
                        },
                        {
                            "name": "Blessing of the Raven Queen",
                            "entries": [
                                "As a bonus action, you can magically teleport up to 30 feet to an unoccupied space you can see. Once you use this trait, you can't do so again until you finish a long rest.",
                                "Starting at 3rd level, you also gain resistance to all damage when you teleport using this trait. The resistance lasts until the start of your next turn. During that time, you appear ghostly and translucent."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true
                },
                {
                    "name": "Wood",
                    "source": "PHB",
                    "raceName": "Elf",
                    "raceSource": "PHB",
                    "page": 24,
                    "basicRules": true,
                    "speed": 35,
                    "ability": [
                        {
                            "wis": 1
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 54,
                        "heightMod": "2d10",
                        "baseWeight": 100,
                        "weightMod": "1d4"
                    },
                    "weaponProficiencies": [
                        {
                            "longsword|phb": true,
                            "shortsword|phb": true,
                            "shortbow|phb": true,
                            "longbow|phb": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Elf Weapon Training",
                            "entries": [
                                "You have proficiency with the {@item longsword|phb}, {@item shortsword|phb}, {@item shortbow|phb}, and {@item longbow|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fleet of Foot",
                            "entries": [
                                "Your base walking speed increases to 35 feet."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Mask of the Wild",
                            "entries": [
                                "You can attempt to hide even when you are only lightly obscured by foliage, heavy rain, falling snow, mist, and other natural phenomena."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Bishatar and Tirahar",
                    "source": "PSK",
                    "raceName": "Elf (Kaladesh)",
                    "raceSource": "PSK",
                    "page": 21,
                    "speed": 35,
                    "entries": [
                        {
                            "name": "Fleet of Foot",
                            "entries": [
                                "Your ground speed increases to 35 feet."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Elf Culture"
                            }
                        },
                        {
                            "name": "Mask of the Wild",
                            "entries": [
                                "You can attempt to hide even when you are only lightly obscured by foliage, heavy rain, falling snow, mist, and other natural phenomena."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Vahadar",
                    "source": "PSK",
                    "raceName": "Elf (Kaladesh)",
                    "raceSource": "PSK",
                    "page": 21,
                    "additionalSpells": [
                        {
                            "ability": "wis",
                            "known": {
                                "1": {
                                    "_": [
                                        {
                                            "choose": "level=0|class=Druid"
                                        }
                                    ]
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Cantrip",
                            "entries": [
                                "You know one cantrip of your choice from the {@filter druid spell list|spells|class=druid|level=0}. Wisdom is your spellcasting ability for it."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Elf Culture"
                            }
                        },
                        {
                            "name": "Extra Language",
                            "entries": [
                                "You can speak, read, and write one extra language of your choosing."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Joraga Nation",
                    "source": "PSZ",
                    "raceName": "Elf (Zendikar)",
                    "raceSource": "PSZ",
                    "page": 19,
                    "speed": 35,
                    "ability": [
                        {
                            "dex": 1
                        }
                    ],
                    "weaponProficiencies": [
                        {
                            "longsword|phb": true,
                            "shortsword|phb": true,
                            "shortbow|phb": true,
                            "longbow|phb": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Mask of the Wild",
                            "entries": [
                                "You can attempt to hide even when you are only lightly obscured by foliage, heavy rain, falling snow, mist, and other natural phenomena."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Elf Weapon Training",
                            "entries": [
                                "You have proficiency with the {@item longsword|phb}, {@item shortsword|phb}, {@item shortbow|phb}, and {@item longbow|phb}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fleet of Foot",
                            "entries": [
                                "Your ground speed increases to 35 feet."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Mul Daya Nation",
                    "source": "PSZ",
                    "raceName": "Elf (Zendikar)",
                    "raceSource": "PSZ",
                    "page": 19,
                    "ability": [
                        {
                            "str": 1
                        }
                    ],
                    "darkvision": 120,
                    "traitTags": [
                        "Sunlight Sensitivity"
                    ],
                    "weaponProficiencies": [
                        {
                            "longsword|phb": true,
                            "shortsword|phb": true,
                            "shortbow|phb": true,
                            "longbow|phb": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "hex"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "darkness"
                                        ]
                                    }
                                }
                            },
                            "ability": "wis",
                            "known": {
                                "1": [
                                    "chill touch#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Mul Daya Magic",
                            "entries": [
                                "You know the {@spell chill touch} cantrip. When you reach 3rd level, you can cast the {@spell hex} spell once with this trait and regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell darkness} spell once with this trait and regain the ability to do so when you finish a long rest. Wisdom is your spellcasting ability for these spells."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Superior Darkvision",
                            "entries": [
                                "Your Darkvision has a radius of 120 feet."
                            ],
                            "data": {
                                "overwrite": "Darkvision"
                            },
                            "type": "entries"
                        },
                        {
                            "name": "Sunlight Sensitivity",
                            "entries": [
                                "You have disadvantage on attack rolls and on Wisdom ({@skill Perception}) checks that rely on sight when you, the target of your attack, or whatever you are trying to perceive is in direct sunlight."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Elf Weapon Training",
                            "entries": [
                                "You have proficiency with the {@item longsword|phb}, {@item shortsword|phb}, {@item shortbow|phb}, and {@item longbow|phb}."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Tajuru Nation",
                    "source": "PSZ",
                    "raceName": "Elf (Zendikar)",
                    "raceSource": "PSZ",
                    "page": 18,
                    "ability": [
                        {
                            "cha": 1
                        }
                    ],
                    "traitTags": [
                        "Skill Proficiency",
                        "Tool Proficiency"
                    ],
                    "skillToolLanguageProficiencies": [
                        {
                            "choose": [
                                {
                                    "from": [
                                        "anySkill",
                                        "anyTool"
                                    ],
                                    "count": 2
                                }
                            ]
                        }
                    ],
                    "entries": [
                        {
                            "name": "Skill Versatility",
                            "entries": [
                                "You have proficiency with any combination of two other skills or {@book tools|phb|5|tools} of your choice."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Air",
                    "source": "EEPC",
                    "raceName": "Genasi",
                    "raceSource": "EEPC",
                    "page": 9,
                    "reprintedAs": [
                        "Genasi (Air)|MPMM"
                    ],
                    "ability": [
                        {
                            "dex": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "con",
                            "known": {
                                "1": [
                                    "levitate"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Unending Breath",
                            "entries": [
                                "You can hold your breath indefinitely while you're not {@condition incapacitated}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Mingle with the Wind",
                            "entries": [
                                "You can cast the {@spell levitate} spell once with this trait, requiring no material components, and you regain the ability to cast it this way when you finish a long rest. Constitution is your spellcasting ability for this spell."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Earth",
                    "source": "EEPC",
                    "raceName": "Genasi",
                    "raceSource": "EEPC",
                    "page": 9,
                    "reprintedAs": [
                        "Genasi (Earth)|MPMM"
                    ],
                    "ability": [
                        {
                            "str": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "con",
                            "known": {
                                "1": [
                                    "pass without trace"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Earth Walk",
                            "entries": [
                                "You can move across {@quickref difficult terrain||3} made of earth or stone without expending extra movement."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Merge with Stone",
                            "entries": [
                                "You can cast the {@spell pass without trace} spell once with this trait, requiring no material components, and you regain the ability to cast it this way when you finish a long rest. Constitution is your spellcasting ability for this spell."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Fire",
                    "source": "EEPC",
                    "raceName": "Genasi",
                    "raceSource": "EEPC",
                    "page": 9,
                    "reprintedAs": [
                        "Genasi (Fire)|MPMM"
                    ],
                    "ability": [
                        {
                            "int": 1
                        }
                    ],
                    "darkvision": 60,
                    "resist": [
                        "fire"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "burning hands"
                                        ]
                                    }
                                }
                            },
                            "ability": "con",
                            "known": {
                                "1": [
                                    "produce flame#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. Your ties to the Elemental Plane of Fire make your darkvision unusual: everything you see in darkness is in a shade of red."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fire Resistance",
                            "entries": [
                                "You have resistance to fire damage."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Reach to the Blaze",
                            "entries": [
                                "You know the {@spell produce flame} cantrip. Once you reach 3rd level, you can cast the {@spell burning hands} spell once with this trait as a 1st-level spell, and you regain the ability to cast it this way when you finish a long rest. Constitution is your spellcasting ability for these spells."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Water",
                    "source": "EEPC",
                    "raceName": "Genasi",
                    "raceSource": "EEPC",
                    "page": 10,
                    "reprintedAs": [
                        "Genasi (Water)|MPMM"
                    ],
                    "speed": {
                        "walk": 30,
                        "swim": 30
                    },
                    "ability": [
                        {
                            "wis": 1
                        }
                    ],
                    "traitTags": [
                        "Amphibious"
                    ],
                    "resist": [
                        "acid"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "create or destroy water#2"
                                        ]
                                    }
                                }
                            },
                            "ability": "con",
                            "known": {
                                "1": [
                                    "shape water|xge#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Acid Resistance",
                            "entries": [
                                "You have resistance to acid damage."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Amphibious",
                            "entries": [
                                "You can breathe air and water."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Swim",
                            "entries": [
                                "You have a swimming speed of 30 feet."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Call to the Wave",
                            "entries": [
                                "You know the {@spell shape water|xge} cantrip. When you reach 3rd level, you can cast the {@spell create or destroy water} spell as a 2nd-level spell once with this trait, and you regain the ability to cast it this way when you finish a long rest. Constitution is your spellcasting ability for these spells."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Air",
                    "source": "MPMM",
                    "raceName": "Genasi",
                    "raceSource": "MPMM",
                    "page": 16,
                    "speed": 35,
                    "resist": [
                        "lightning"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "feather fall"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "levitate"
                                        ]
                                    }
                                }
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "shocking grasp#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Unending Breath",
                            "entries": [
                                "You can hold your breath indefinitely while you're not {@condition incapacitated}."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Lightning Resistance",
                            "entries": [
                                "You have resistance to lightning damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Mingle with the Wind",
                            "entries": [
                                "You know the {@spell shocking grasp} cantrip. Starting at 3rd level, you can cast the {@spell feather fall} spell with this trait, without requiring a material component. Starting 5th level, you can also cast the {@spell levitate} spell with this trait, without requiring a material component. Once you cast {@spell feather fall} or {@spell levitate} with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast either of those spells using any spell slots you have of the appropriate level.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Earth",
                    "source": "MPMM",
                    "raceName": "Genasi",
                    "raceSource": "MPMM",
                    "page": 17,
                    "additionalSpells": [
                        {
                            "innate": {
                                "5": [
                                    "pass without trace"
                                ]
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "blade ward#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Earth Walk",
                            "entries": [
                                "You can move across {@quickref difficult terrain||3} without expending extra movement if you are using your walking speed on the ground or a floor."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Merge with Stone",
                            "entries": [
                                "You know the {@spell blade ward} cantrip. You can cast it as normal, and you can also cast it as a bonus action a number of times equal to your proficiency bonus, regaining all expended uses when you finish a long rest.",
                                "Starting at 5th level, you can cast the {@spell pass without trace} spell with this trait, without requiring a material component. Once you cast that spell with this trait, you can't do so again until you finish a long rest. You can also cast it using any spell slots you have of 2nd level or higher.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Fire",
                    "source": "MPMM",
                    "raceName": "Genasi",
                    "raceSource": "MPMM",
                    "page": 17,
                    "resist": [
                        "fire"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "burning hands"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "flame blade"
                                        ]
                                    }
                                }
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "produce flame#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Fire Resistance",
                            "entries": [
                                "You have resistance to fire damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Reach to the Blaze",
                            "entries": [
                                "You know the {@spell produce flame} cantrip. Starting at 3rd level, you can cast the {@spell burning hands} spell with this trait. Starting at 5th level, you can also cast the {@spell flame blade} spell with this trait, without a material component. Once you cast {@spell burning hands} or {@spell flame blade} with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast either of those spells using any spell slots you have of the appropriate level.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Water",
                    "source": "MPMM",
                    "raceName": "Genasi",
                    "raceSource": "MPMM",
                    "page": 17,
                    "speed": {
                        "walk": 30,
                        "swim": true
                    },
                    "traitTags": [
                        "Amphibious"
                    ],
                    "resist": [
                        "acid"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "create or destroy water"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "water walk"
                                        ]
                                    }
                                }
                            },
                            "ability": {
                                "choose": [
                                    "int",
                                    "wis",
                                    "cha"
                                ]
                            },
                            "known": {
                                "1": [
                                    "acid splash#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Speed",
                            "entries": [
                                "Your walking speed is 30 feet, and you have a swimming speed equal to your walking speed."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Acid Resistance",
                            "entries": [
                                "You have resistance to acid damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Amphibious",
                            "entries": [
                                "You breathe air and water."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Call to the Wave",
                            "entries": [
                                "You know the {@spell acid splash} cantrip. Starting at 3rd level, you can cast the {@spell create or destroy water} spell with this trait. Starting at 5th level, you can also cast the {@spell water walk} spell with this trait, without requiring a material component. Once you cast {@spell create or destroy water} or {@spell water walk} with this trait, you can't cast that spell with it again until you finish a long rest. You can also cast either of those spells using any spell slots you have of the appropriate level.",
                                "Intelligence, Wisdom, or Charisma is your spellcasting ability for these spells when you cast them with this trait (choose when you select this race)."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Githyanki",
                    "source": "MTF",
                    "raceName": "Gith",
                    "raceSource": "MTF",
                    "page": 96,
                    "reprintedAs": [
                        "Githyanki|MPMM"
                    ],
                    "ability": [
                        {
                            "str": 2
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 60,
                        "heightMod": "2d12",
                        "baseWeight": 100,
                        "weightMod": "2d4"
                    },
                    "traitTags": [
                        "Skill Proficiency",
                        "Tool Proficiency"
                    ],
                    "weaponProficiencies": [
                        {
                            "shortsword|phb": true,
                            "longsword|phb": true,
                            "greatsword|phb": true
                        }
                    ],
                    "armorProficiencies": [
                        {
                            "light": true,
                            "medium": true
                        }
                    ],
                    "skillToolLanguageProficiencies": [
                        {
                            "choose": [
                                {
                                    "from": [
                                        "anySkill",
                                        "anyTool"
                                    ]
                                }
                            ]
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "jump"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "misty step"
                                        ]
                                    }
                                }
                            },
                            "ability": "int",
                            "known": {
                                "1": [
                                    "mage hand#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Githyanki tend toward lawful evil. They are aggressive and arrogant, and they remain the faithful servants of their lich-queen, Vlaakith. Renegade githyanki tend toward chaos."
                            ]
                        },
                        {
                            "name": "Decadent Mastery",
                            "entries": [
                                "You learn one language of your choice, and you are proficient with one skill or {@book tool|phb|5|tools} of your choice. In the timeless city of Tu'narath, githyanki have bountiful time to master odd bits of knowledge."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Martial Prodigy",
                            "entries": [
                                "You are proficient with light and medium armor and with {@item shortsword|phb|shortswords}, {@item longsword|phb|longswords}, and {@item greatsword|phb|greatswords}."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Githyanki Psionics",
                            "entries": [
                                "You know the {@spell mage hand} cantrip, and the hand is {@condition invisible} when you cast the cantrip with this trait.",
                                "When you reach 3rd level, you can cast {@spell jump} once with this trait, and you regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell misty step} spell once with this trait, and you regain the ability to do so when you finish a long rest.",
                                "Intelligence is your spellcasting ability for these spells. When you cast them with this trait, they don't require components."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Githzerai",
                    "source": "MTF",
                    "raceName": "Gith",
                    "raceSource": "MTF",
                    "page": 96,
                    "reprintedAs": [
                        "Githzerai|MPMM"
                    ],
                    "ability": [
                        {
                            "wis": 2
                        }
                    ],
                    "heightAndWeight": {
                        "baseHeight": 59,
                        "heightMod": "2d12",
                        "baseWeight": 90,
                        "weightMod": "1d4"
                    },
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "shield"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "detect thoughts"
                                        ]
                                    }
                                }
                            },
                            "ability": "wis",
                            "known": {
                                "1": [
                                    "mage hand#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Githzerai tend toward lawful neutral. Their rigorous training in psychic abilities requires an implacable mental discipline."
                            ]
                        },
                        {
                            "name": "Mental Discipline",
                            "entries": [
                                "You have advantage on saving throws against the {@condition charmed} and {@condition frightened} conditions. Under the tutelage of monastic masters, githzerai learn to govern their own minds."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Githzerai Psionics",
                            "entries": [
                                "You know the {@spell mage hand} cantrip, and the hand is {@condition invisible} when you cast the cantrip with this trait.",
                                "When you reach 3rd level, you can cast {@spell shield} once with this trait, and you regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell detect thoughts} spell once with this trait, and you regain the ability to do so when you finish a long rest.",
                                "Wisdom is your spellcasting ability for these spells. When you cast them with this trait, they don't require components."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true
                },
                {
                    "name": "Deep",
                    "source": "MTF",
                    "raceName": "Gnome",
                    "raceSource": "PHB",
                    "page": 113,
                    "reprintedAs": [
                        "Deep Gnome|MPMM"
                    ],
                    "ability": [
                        {
                            "dex": 1
                        }
                    ],
                    "age": {
                        "mature": 25,
                        "max": 250
                    },
                    "darkvision": 120,
                    "languageProficiencies": [
                        {
                            "common": true,
                            "gnomish": true,
                            "undercommon": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Deep gnomes are short-lived for gnomes. They mature at the same rate humans do and are considered full-grown adults by 25. They live 200 to 250 years, although hard toil and the dangers of the Underdark often claim them before their time."
                            ],
                            "data": {
                                "overwrite": "Age"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Unlike other gnomes, svirfneblin tend to weigh 80 to 120 pounds. Your size is Small."
                            ],
                            "data": {
                                "overwrite": "Size"
                            }
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Svirfneblin believe that survival depends on avoiding entanglements with other creatures and not making enemies, so they favor neutral alignments. They rarely wish others ill, and they are unlikely to take risks on behalf of others, except those dearest to them."
                            ],
                            "data": {
                                "overwrite": "Alignment"
                            }
                        },
                        {
                            "name": "Superior Darkvision",
                            "entries": [
                                "Accustomed to life underground, you have superior vision in dark and dim conditions. You can see in dim light within 120 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "data": {
                                "overwrite": "Darkvision"
                            },
                            "type": "entries"
                        },
                        {
                            "name": "Stone Camouflage",
                            "entries": [
                                "You have advantage on Dexterity ({@skill Stealth}) checks to hide in rocky terrain."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common, Gnomish, and Undercommon."
                            ],
                            "data": {
                                "overwrite": "Languages"
                            },
                            "type": "entries"
                        }
                    ],
                    "overwrite": {
                        "languageProficiencies": true
                    }
                },
                {
                    "name": "Deep/Svirfneblin",
                    "source": "SCAG",
                    "raceName": "Gnome",
                    "raceSource": "PHB",
                    "page": 115,
                    "otherSources": [
                        {
                            "source": "EEPC",
                            "page": 5
                        }
                    ],
                    "reprintedAs": [
                        "Deep Gnome|MPMM"
                    ],
                    "ability": [
                        {
                            "dex": 1
                        }
                    ],
                    "age": {
                        "mature": 25,
                        "max": 250
                    },
                    "darkvision": 120,
                    "languageProficiencies": [
                        {
                            "common": true,
                            "gnomish": true,
                            "undercommon": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Deep gnomes are short-lived for gnomes. They mature at the same rate humans do and are considered full-grown adults by 25. They live 200 to 250 years, although hard toil and the dangers of the Underdark often claim them before their time."
                            ],
                            "data": {
                                "overwrite": "Age"
                            }
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Svirfneblin believe that survival depends on avoiding entanglements with other creatures and not making enemies, so they favor neutral alignments. They rarely wish others ill, and they are unlikely to take risks on behalf of others."
                            ],
                            "data": {
                                "overwrite": "Alignment"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "A typical svirfneblin stands about 3 to 3½ feet tall and weighs 80 to 120 pounds. Your size is Small."
                            ],
                            "data": {
                                "overwrite": "Size"
                            }
                        },
                        {
                            "name": "Superior Darkvision",
                            "entries": [
                                "Accustomed to life underground, you have superior vision in dark and dim conditions. You can see in dim light within 120 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "data": {
                                "overwrite": "Darkvision"
                            },
                            "type": "entries"
                        },
                        {
                            "name": "Stone Camouflage",
                            "entries": [
                                "You have advantage on Dexterity ({@skill Stealth}) checks to hide in rocky terrain."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common, Gnomish, and Undercommon. The svirfneblin dialect is more guttural than surface Gnomish, and most svirfneblin know only a little bit of Common, but those who deal with outsiders (and that includes you as an adventurer) pick up enough Common to get by in other lands."
                            ],
                            "data": {
                                "overwrite": "Languages"
                            },
                            "type": "entries"
                        }
                    ],
                    "overwrite": {
                        "languageProficiencies": true
                    },
                    "hasFluff": true
                },
                {
                    "name": "Forest",
                    "source": "PHB",
                    "raceName": "Gnome",
                    "raceSource": "PHB",
                    "page": 37,
                    "ability": [
                        {
                            "dex": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "int",
                            "known": {
                                "1": [
                                    "minor illusion#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Natural Illusionist",
                            "entries": [
                                "You know the {@spell minor illusion} cantrip. Intelligence is your spellcasting ability for it."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Speak with Small Beasts",
                            "entries": [
                                "Through sounds and gestures, you can communicate simple ideas with Small or smaller beasts. Forest gnomes love animals and often keep squirrels, badgers, rabbits, moles, woodpeckers, and other creatures as beloved pets."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Mark of Scribing",
                    "source": "ERLW",
                    "raceName": "Gnome",
                    "raceSource": "PHB",
                    "page": 47,
                    "ability": [
                        {
                            "cha": 1
                        }
                    ],
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice",
                        "Tool Bonus Dice"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "1": {
                                    "rest": {
                                        "1": [
                                            "comprehend languages"
                                        ]
                                    }
                                },
                                "3": {
                                    "daily": {
                                        "1": [
                                            "magic mouth"
                                        ]
                                    }
                                }
                            },
                            "expanded": {
                                "s1": [
                                    "comprehend languages",
                                    "illusory script"
                                ],
                                "s2": [
                                    "animal messenger",
                                    "silence"
                                ],
                                "s3": [
                                    "sending",
                                    "tongues"
                                ],
                                "s4": [
                                    "arcane eye",
                                    "confusion"
                                ],
                                "s5": [
                                    "dream"
                                ]
                            },
                            "ability": "int",
                            "known": {
                                "1": [
                                    "message#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Gifted Scribe",
                            "entries": [
                                "When you make an Intelligence ({@skill History}) check or an ability check using {@item calligrapher's supplies|PHB}, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Scribe's Insight",
                            "entries": [
                                "You know the {@spell message} cantrip. You can also cast {@spell comprehend languages} once with this trait, and you regain the ability to cast it when you finish a short or long rest. Starting at 3rd level, you can cast the {@spell magic mouth} spell with this trait, and you regain the ability to cast it when you finish a long rest. Intelligence is your spellcasting ability for these spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Scribing Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Scribing Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell comprehend languages}, {@spell illusory script}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell animal messenger}, {@spell silence}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell sending}, {@spell tongues}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell arcane eye}, {@spell confusion}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell dream}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Rock",
                    "source": "PHB",
                    "raceName": "Gnome",
                    "raceSource": "PHB",
                    "page": 37,
                    "srd": true,
                    "ability": [
                        {
                            "con": 1
                        }
                    ],
                    "traitTags": [
                        "Tool Proficiency"
                    ],
                    "entries": [
                        {
                            "name": "Artificer's Lore",
                            "entries": [
                                "Whenever you make an Intelligence ({@skill History}) check related to magic items, alchemical objects, or technological devices, you can add twice your proficiency bonus, instead of any proficiency bonus you normally apply."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Tinker",
                            "entries": [
                                "You have proficiency with artisan's tools ({@item tinker's tools|phb}). Using those tools, you can spend 1 hour and 10 gp worth of materials to construct a Tiny clockwork device (AC 5, 1 hp). The device ceases to function after 24 hours (unless you spend 1 hour repairing it to keep the device functioning), or when you use your action to dismantle it; at that time, you can reclaim the materials used to create it. You can have up to three such devices active at a time.",
                                "When you create a device, choose one of the following options:",
                                {
                                    "type": "entries",
                                    "name": "Clockwork Toy",
                                    "entries": [
                                        "This toy is a clockwork animal, monster, or person, such as a frog, mouse, bird, dragon, or soldier. When placed on the ground, the toy moves 5 feet across the ground on each of your turns in a random direction. It makes noises as appropriate to the creature it represents."
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "Fire Starter",
                                    "entries": [
                                        "The device produces a miniature flame, which you can use to light a candle, torch, or campfire. Using the device requires your action."
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "Music Box",
                                    "entries": [
                                        "When opened, this music box plays a single song at a moderate volume. The box stops playing when it reaches the song's end or when it is closed."
                                    ]
                                }
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Ixalan",
                    "source": "PSX",
                    "raceName": "Goblin",
                    "raceSource": "PSZ",
                    "page": 16,
                    "otherSources": null,
                    "ability": [
                        {
                            "dex": 2
                        }
                    ],
                    "entries": [
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Most goblins are wildly chaotic, with no particular inclination toward good or evil but a strong tendency toward mischief."
                            ],
                            "data": {
                                "overwrite": "Alignment"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Agile Climber",
                            "entries": [
                                "You have a climbing speed of 25 feet. You can't use your climbing speed while you wear medium or heavy armor. (If your campaign uses the variant rule for {@variantrule encumbrance|PHB}, you can't use your climbing speed if you are encumbered.)"
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write {@language Common Trade Pidgin|PSX|Common} (if it exists in your campaign) and {@language Goblin|PHB}."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Languages"
                            }
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Zendikar; Grotag Tribe",
                    "source": "PSZ",
                    "raceName": "Goblin",
                    "raceSource": "PSZ",
                    "page": 17,
                    "otherSources": null,
                    "ability": [
                        {
                            "con": 2
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "animal handling": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Grit",
                            "entries": [
                                "You have resistance to fire damage and psychic damage. In addition, when you are wearing no armor, your AC is equal to 11 + your Dexterity modifier."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Grotag Tamer",
                            "entries": [
                                "You have proficiency in the {@skill Animal Handling} skill."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Zendikar; Lavastep Tribe",
                    "source": "PSZ",
                    "raceName": "Goblin",
                    "raceSource": "PSZ",
                    "page": 17,
                    "otherSources": null,
                    "ability": [
                        {
                            "con": 2
                        }
                    ],
                    "entries": [
                        {
                            "name": "Grit",
                            "entries": [
                                "You have resistance to fire damage and psychic damage. In addition, when you are wearing no armor, your AC is equal to 11 + your Dexterity modifier."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Lavastep Grit",
                            "entries": [
                                "You have advantage on Dexterity ({@skill Stealth}) checks made to hide in rocky or subterranean environments."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Zendikar; Tuktuk Tribe",
                    "source": "PSZ",
                    "raceName": "Goblin",
                    "raceSource": "PSZ",
                    "page": 17,
                    "otherSources": null,
                    "ability": [
                        {
                            "con": 2
                        }
                    ],
                    "traitTags": [
                        "Tool Proficiency"
                    ],
                    "entries": [
                        {
                            "name": "Grit",
                            "entries": [
                                "You have resistance to fire damage and psychic damage. In addition, when you are wearing no armor, your AC is equal to 11 + your Dexterity modifier."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Tuktuk Cunning",
                            "entries": [
                                "You have proficiency with {@item thieves' tools|phb}."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "source": "PHB",
                    "raceName": "Half-Elf",
                    "raceSource": "PHB",
                    "page": 38,
                    "srd": true,
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Variant; Aquatic Elf Descent",
                    "source": "SCAG",
                    "raceName": "Half-Elf",
                    "raceSource": "PHB",
                    "page": 116,
                    "speed": 30,
                    "entries": [
                        {
                            "type": "inset",
                            "name": "Variant Feature (Choose 1)",
                            "entries": [
                                {
                                    "name": "Skill Versatility",
                                    "entries": [
                                        "You gain proficiency in two skills of your choice."
                                    ],
                                    "type": "entries"
                                },
                                {
                                    "name": "Swim",
                                    "entries": [
                                        "You gain a swimming speed of 30 ft."
                                    ],
                                    "type": "entries"
                                }
                            ],
                            "data": {
                                "overwrite": "Skill Versatility"
                            }
                        }
                    ],
                    "_versions": [
                        {
                            "name": "Variant; Aquatic Elf Descent; Skill Versatility",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Skill Versatility",
                                        "type": "entries",
                                        "entries": [
                                            "You gain proficiency in two skills of your choice."
                                        ]
                                    }
                                }
                            },
                            "skillProficiencies": [
                                {
                                    "any": 2
                                }
                            ]
                        },
                        {
                            "name": "Variant; Aquatic Elf Descent; Swim Speed",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Swim Speed",
                                        "type": "entries",
                                        "entries": [
                                            "You gain a swimming speed of 30 ft."
                                        ]
                                    }
                                }
                            },
                            "speed": {
                                "walk": 30,
                                "swim": 30
                            },
                            "skillProficiencies": null,
                            "overwrite": {
                                "skillProficiencies": true
                            }
                        }
                    ]
                },
                {
                    "name": "Variant; Drow Descent",
                    "source": "SCAG",
                    "raceName": "Half-Elf",
                    "raceSource": "PHB",
                    "page": 116,
                    "skillProficiencies": [
                        {
                            "any": 2
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "faerie fire"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "darkness"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "dancing lights#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "inset",
                            "name": "Variant Feature (Choose 1)",
                            "entries": [
                                {
                                    "name": "Skill Versatility",
                                    "entries": [
                                        "You gain proficiency in two skills of your choice."
                                    ],
                                    "type": "entries"
                                },
                                {
                                    "name": "Drow Magic",
                                    "entries": [
                                        "You know the {@spell dancing lights} cantrip. When you reach 3rd level, you can cast the {@spell faerie fire} spell once per day; you must finish a long rest in order to cast the spell again using this trait. When you reach 5th level, you can also cast the {@spell darkness} spell once per day; you must finish a long rest in order to cast the spell again using this trait. Charisma is your spellcasting ability for these spells."
                                    ],
                                    "type": "entries"
                                }
                            ],
                            "data": {
                                "overwrite": "Skill Versatility"
                            }
                        }
                    ],
                    "overwrite": {
                        "skillProficiencies": true
                    },
                    "_versions": [
                        {
                            "name": "Variant; Drow Descent; Drow Magic",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Drow Magic",
                                        "type": "entries",
                                        "entries": [
                                            "You know the {@spell dancing lights} cantrip. When you reach 3rd level, you can cast the {@spell faerie fire} spell once per day; you must finish a long rest in order to cast the spell again using this trait. When you reach 5th level, you can also cast the {@spell darkness} spell once per day; you must finish a long rest in order to cast the spell again using this trait. Charisma is your spellcasting ability for these spells."
                                        ]
                                    }
                                }
                            },
                            "skillProficiencies": null
                        },
                        {
                            "name": "Variant; Drow Descent; Skill Versatility",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Skill Versatility",
                                        "type": "entries",
                                        "entries": [
                                            "You gain proficiency in two skills of your choice."
                                        ]
                                    }
                                }
                            },
                            "additionalSpells": null
                        }
                    ]
                },
                {
                    "name": "Variant; Mark of Detection",
                    "source": "ERLW",
                    "raceName": "Half-Elf",
                    "raceSource": "PHB",
                    "page": 40,
                    "ability": [
                        {
                            "wis": 2,
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "con",
                                    "int",
                                    "cha"
                                ],
                                "count": 1
                            }
                        }
                    ],
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice"
                    ],
                    "skillProficiencies": null,
                    "additionalSpells": [
                        {
                            "innate": {
                                "1": [
                                    "detect magic",
                                    "detect poison and disease"
                                ],
                                "3": {
                                    "daily": {
                                        "1": [
                                            "see invisibility"
                                        ]
                                    }
                                }
                            },
                            "expanded": {
                                "s1": [
                                    "detect evil and good",
                                    "detect poison and disease"
                                ],
                                "s2": [
                                    "detect thoughts",
                                    "find traps"
                                ],
                                "s3": [
                                    "clairvoyance",
                                    "nondetection"
                                ],
                                "s4": [
                                    "arcane eye",
                                    "divination"
                                ],
                                "s5": [
                                    "legend lore"
                                ]
                            },
                            "ability": "int"
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Deductive Intuition",
                            "entries": [
                                "When you make an Intelligence ({@skill Investigation}) or a Wisdom ({@skill Insight}) check, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ],
                            "data": {
                                "overwrite": "Skill Versatility"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Magical Detection",
                            "entries": [
                                "You can cast the {@spell detect magic} and {@spell detect poison and disease} spells with this trait. Starting at 3rd level, you can also cast the {@spell see invisibility} spell with it. Once you cast any of these spells with this trait, you can't cast that spell with it again until you finish a long rest. Wisdom is your spellcasting ability for these spells, and you don't require material components for them."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Detection Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Detection Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell detect evil and good}, {@spell detect poison and disease}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell detect thoughts}, {@spell find traps}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell clairvoyance}, {@spell nondetection}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell arcane eye}, {@spell divination}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell legend lore}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ],
                    "overwrite": {
                        "ability": true
                    }
                },
                {
                    "name": "Variant; Mark of Storm",
                    "source": "ERLW",
                    "raceName": "Half-Elf",
                    "raceSource": "PHB",
                    "page": 50,
                    "ability": [
                        {
                            "cha": 2,
                            "dex": 1
                        }
                    ],
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice",
                        "Tool Bonus Dice"
                    ],
                    "skillProficiencies": null,
                    "resist": [
                        "lightning"
                    ],
                    "additionalSpells": [
                        {
                            "expanded": {
                                "s1": [
                                    "feather fall",
                                    "fog cloud"
                                ],
                                "s2": [
                                    "gust of wind",
                                    "levitate"
                                ],
                                "s3": [
                                    "sleet storm",
                                    "wind wall"
                                ],
                                "s4": [
                                    "conjure minor elementals",
                                    "control water"
                                ],
                                "s5": [
                                    "conjure elemental"
                                ]
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "gust|xge#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Windwright's Intuition",
                            "entries": [
                                "When you make a Dexterity ({@skill Acrobatics}) check or any ability check involving {@item navigator's tools|PHB}, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ],
                            "data": {
                                "overwrite": "Skill Versatility"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Storm's Boon",
                            "entries": [
                                "You have resistance to lightning damage."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Headwinds",
                            "entries": [
                                "You know the {@spell gust|XGE} cantrip. Starting at 3rd level, you can cast the {@spell gust of wind} spell once with this trait, and you regain the ability to cast it when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Storm Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Storm Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell feather fall}, {@spell fog cloud}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell gust of wind}, {@spell levitate}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell sleet storm}, {@spell wind wall}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell conjure minor elementals}, {@spell control water}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell conjure elemental}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ],
                    "overwrite": {
                        "ability": true
                    }
                },
                {
                    "name": "Variant; Moon Elf or Sun Elf Descent",
                    "source": "SCAG",
                    "raceName": "Half-Elf",
                    "raceSource": "PHB",
                    "page": 116,
                    "skillProficiencies": [
                        {
                            "any": 2
                        }
                    ],
                    "weaponProficiencies": [
                        {
                            "longsword|phb": true,
                            "shortsword|phb": true,
                            "shortbow|phb": true,
                            "longbow|phb": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "int",
                            "known": {
                                "1": {
                                    "_": [
                                        {
                                            "choose": "level=0|class=Wizard"
                                        }
                                    ]
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "inset",
                            "name": "Variant Feature (Choose 1)",
                            "entries": [
                                {
                                    "name": "Skill Versatility",
                                    "entries": [
                                        "You gain proficiency in two skills of your choice."
                                    ],
                                    "type": "entries"
                                },
                                {
                                    "name": "Elf Weapon Training",
                                    "entries": [
                                        "You have proficiency with the {@item longsword|phb}, {@item shortsword|phb}, {@item shortbow|phb}, and {@item longbow|phb}."
                                    ],
                                    "type": "entries"
                                },
                                {
                                    "name": "Cantrip",
                                    "entries": [
                                        "You know one cantrip of your choice from the {@filter wizard spell list|spells|class=wizard|level=0}. Intelligence is your spellcasting ability for it."
                                    ],
                                    "type": "entries"
                                }
                            ],
                            "data": {
                                "overwrite": "Skill Versatility"
                            }
                        }
                    ],
                    "overwrite": {
                        "skillProficiencies": true
                    },
                    "_versions": [
                        {
                            "name": "Variant; Moon Elf or Sun Elf Descent; Cantrip",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Cantrip",
                                        "type": "entries",
                                        "entries": [
                                            "You know one cantrip of your choice from the {@filter wizard spell list|spells|class=wizard|level=0}. Intelligence is your spellcasting ability for it."
                                        ]
                                    }
                                }
                            },
                            "skillProficiencies": null,
                            "weaponProficiencies": null
                        },
                        {
                            "name": "Variant; Moon Elf or Sun Elf Descent; Elf Weapon Training",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Elf Weapon Training",
                                        "type": "entries",
                                        "entries": [
                                            "You have proficiency with the {@item longsword|phb}, {@item shortsword|phb}, {@item shortbow|phb}, and {@item longbow|phb}."
                                        ]
                                    }
                                }
                            },
                            "skillProficiencies": null,
                            "additionalSpells": null
                        },
                        {
                            "name": "Variant; Moon Elf or Sun Elf Descent; Skill Versatility",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Skill Versatility",
                                        "type": "entries",
                                        "entries": [
                                            "You gain proficiency in two skills of your choice."
                                        ]
                                    }
                                }
                            },
                            "weaponProficiencies": null,
                            "additionalSpells": null
                        }
                    ]
                },
                {
                    "name": "Variant; Wood Elf Descent",
                    "source": "SCAG",
                    "raceName": "Half-Elf",
                    "raceSource": "PHB",
                    "page": 116,
                    "skillProficiencies": [
                        {
                            "any": 2
                        }
                    ],
                    "weaponProficiencies": [
                        {
                            "longsword|phb": true,
                            "shortsword|phb": true,
                            "shortbow|phb": true,
                            "longbow|phb": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "inset",
                            "name": "Variant Feature (Choose 1)",
                            "entries": [
                                {
                                    "name": "Skill Versatility",
                                    "entries": [
                                        "You gain proficiency in two skills of your choice."
                                    ],
                                    "type": "entries"
                                },
                                {
                                    "name": "Elf Weapon Training",
                                    "entries": [
                                        "You have proficiency with the {@item longsword|phb}, {@item shortsword|phb}, {@item shortbow|phb}, and {@item longbow|phb}."
                                    ],
                                    "type": "entries"
                                },
                                {
                                    "name": "Fleet of Foot",
                                    "entries": [
                                        "Your base walking speed increases to 35 feet."
                                    ],
                                    "type": "entries"
                                },
                                {
                                    "name": "Mask of the Wild",
                                    "entries": [
                                        "You can attempt to hide even when you are only lightly obscured by foliage, heavy rain, falling snow, mist, and other natural phenomena."
                                    ],
                                    "type": "entries"
                                }
                            ],
                            "data": {
                                "overwrite": "Skill Versatility"
                            }
                        }
                    ],
                    "overwrite": {
                        "skillProficiencies": true
                    },
                    "_versions": [
                        {
                            "name": "Variant; Wood Elf Descent; Elf Weapon Training",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Elf Weapon Training",
                                        "type": "entries",
                                        "entries": [
                                            "You have proficiency with the {@item longsword|phb}, {@item shortsword|phb}, {@item shortbow|phb}, and {@item longbow|phb}."
                                        ]
                                    }
                                }
                            },
                            "skillProficiencies": null
                        },
                        {
                            "name": "Variant; Wood Elf Descent; Fleet of Foot",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Fleet of Foot",
                                        "type": "entries",
                                        "entries": [
                                            "Your base walking speed increases to 35 feet."
                                        ]
                                    }
                                }
                            },
                            "speed": 35,
                            "skillProficiencies": null,
                            "weaponProficiencies": null
                        },
                        {
                            "name": "Variant; Wood Elf Descent; Mask of the Wild",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Mask of the Wild",
                                        "type": "entries",
                                        "entries": [
                                            "You can attempt to hide even when you are only lightly obscured by foliage, heavy rain, falling snow, mist, and other natural phenomena."
                                        ]
                                    }
                                }
                            },
                            "skillProficiencies": null,
                            "weaponProficiencies": null
                        },
                        {
                            "name": "Variant; Wood Elf Descent; Skill Versatility",
                            "source": "SCAG",
                            "_mod": {
                                "entries": {
                                    "mode": "replaceArr",
                                    "replace": "Variant Feature (Choose 1)",
                                    "items": {
                                        "name": "Variant Feature; Skill Versatility",
                                        "type": "entries",
                                        "entries": [
                                            "You gain proficiency in two skills of your choice."
                                        ]
                                    }
                                }
                            },
                            "weaponProficiencies": null
                        }
                    ]
                },
                {
                    "source": "PHB",
                    "raceName": "Half-Orc",
                    "raceSource": "PHB",
                    "page": 40,
                    "srd": true,
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Variant; Mark of Finding",
                    "source": "ERLW",
                    "raceName": "Half-Orc",
                    "raceSource": "PHB",
                    "page": 41,
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "goblin": true
                        }
                    ],
                    "soundClip": {
                        "type": "internal",
                        "path": "races/half-orc.mp3"
                    },
                    "additionalSpells": [
                        {
                            "innate": {
                                "1": [
                                    "hunter's mark"
                                ],
                                "3": {
                                    "daily": {
                                        "1": [
                                            "locate object"
                                        ]
                                    }
                                }
                            },
                            "expanded": {
                                "s1": [
                                    "faerie fire",
                                    "longstrider"
                                ],
                                "s2": [
                                    "locate animals or plants",
                                    "locate object"
                                ],
                                "s3": [
                                    "clairvoyance",
                                    "speak with plants"
                                ],
                                "s4": [
                                    "divination",
                                    "locate creature"
                                ],
                                "s5": [
                                    "commune with nature"
                                ]
                            },
                            "ability": "wis"
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ],
                            "data": {
                                "overwrite": "Darkvision"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Hunter's Intuition",
                            "entries": [
                                "When you make a Wisdom ({@skill Perception}) or Wisdom ({@skill Survival}) check, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ],
                            "data": {
                                "overwrite": "Menacing"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Finder's Magic",
                            "entries": [
                                "You can cast the {@spell hunter's mark} spell with this trait. Starting at 3rd level, you can also cast the {@spell locate object} spell with it. Once you cast either spell with this trait, you can't cast that spell with it again until you finish a long rest. Wisdom is your spellcasting ability for these spells."
                            ],
                            "data": {
                                "overwrite": "Relentless Endurance"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Goblin."
                            ],
                            "data": {
                                "overwrite": "Languages"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Finding Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Finding Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell faerie fire}, {@spell longstrider}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell locate animals or plants}, {@spell locate object}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell clairvoyance}, {@spell speak with plants}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell divination}, {@spell locate creature}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell commune with nature}"
                                        ]
                                    ]
                                }
                            ],
                            "data": {
                                "overwrite": "Savage Attacks"
                            }
                        }
                    ]
                },
                {
                    "name": "Ghostwise",
                    "source": "SCAG",
                    "raceName": "Halfling",
                    "raceSource": "PHB",
                    "page": 110,
                    "ability": [
                        {
                            "wis": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Silent Speech",
                            "entries": [
                                "You can speak telepathically to any creature within 30 feet of you. The creature understands you only if the two of you share a language. You can speak telepathically in this way to one creature at a time."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Lightfoot",
                    "source": "PHB",
                    "raceName": "Halfling",
                    "raceSource": "PHB",
                    "page": 28,
                    "srd": true,
                    "basicRules": true,
                    "ability": [
                        {
                            "cha": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Naturally Stealthy",
                            "entries": [
                                "You can attempt to hide even when you are obscured only by a creature that is at least one size larger than you."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Lotusden",
                    "source": "EGW",
                    "raceName": "Halfling",
                    "raceSource": "PHB",
                    "page": 164,
                    "ability": [
                        {
                            "wis": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "entangle"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "spike growth"
                                        ]
                                    }
                                }
                            },
                            "ability": "wis",
                            "known": {
                                "1": [
                                    "druidcraft#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Child of the Wood",
                            "entries": [
                                "You know the {@spell druidcraft} cantrip. When you reach 3rd level, you can cast the {@spell entangle} spell once with this trait and regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell spike growth} spell once with this trait and regain the ability to do so when you finish a long rest. Casting these spells with this trait doesn't require material components. Wisdom is your spellcasting ability for these spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Timberwalk",
                            "entries": [
                                "Ability checks made to track you have disadvantage, and you can move across {@quickref difficult terrain||3} made of nonmagical plants and undergrowth without expending extra movement."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Mark of Healing",
                    "source": "ERLW",
                    "raceName": "Halfling",
                    "raceSource": "PHB",
                    "page": 43,
                    "ability": [
                        {
                            "wis": 1
                        }
                    ],
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice",
                        "Tool Bonus Dice"
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "1": [
                                    "cure wounds"
                                ],
                                "3": {
                                    "daily": {
                                        "1": [
                                            "lesser restoration"
                                        ]
                                    }
                                }
                            },
                            "expanded": {
                                "s1": [
                                    "cure wounds",
                                    "healing word"
                                ],
                                "s2": [
                                    "lesser restoration",
                                    "prayer of healing"
                                ],
                                "s3": [
                                    "aura of vitality",
                                    "mass healing word"
                                ],
                                "s4": [
                                    "aura of purity",
                                    "aura of life"
                                ],
                                "s5": [
                                    "greater restoration"
                                ]
                            },
                            "ability": "wis"
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Medical Intuition",
                            "entries": [
                                "When you make a Wisdom ({@skill Medicine}) check or an ability check using an {@item herbalism kit|phb}, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Healing Touch",
                            "entries": [
                                "You can cast the {@spell cure wounds} spell with this trait. Starting at 3rd level, you can also cast {@spell lesser restoration} with it. Once you cast either spell with this trait, you can't cast that spell with it again until you finish a long rest. Wisdom is your spellcasting ability for these spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Healing Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Healing Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell cure wounds}, {@spell healing word}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell lesser restoration}, {@spell prayer of healing}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell aura of vitality}, {@spell mass healing word}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell aura of purity}, {@spell aura of life}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell greater restoration}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Mark of Hospitality",
                    "source": "ERLW",
                    "raceName": "Halfling",
                    "raceSource": "PHB",
                    "page": 44,
                    "ability": [
                        {
                            "cha": 1
                        }
                    ],
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice",
                        "Tool Bonus Dice"
                    ],
                    "additionalSpells": [
                        {
                            "expanded": {
                                "s1": [
                                    "goodberry",
                                    "sleep"
                                ],
                                "s2": [
                                    "aid",
                                    "calm emotions"
                                ],
                                "s3": [
                                    "create food and water",
                                    "leomund's tiny hut"
                                ],
                                "s4": [
                                    "aura of purity",
                                    "mordenkainen's private sanctum"
                                ],
                                "s5": [
                                    "hallow"
                                ]
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "prestidigitation#c",
                                    "purify food and drink",
                                    "unseen servant"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Ever Hospitable",
                            "entries": [
                                "When you make a Charisma ({@skill Persuasion}) check or an ability check involving {@item brewer's supplies|PHB} or {@item cook's utensils|PHB}, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Innkeeper's Magic",
                            "entries": [
                                "You know the {@spell prestidigitation} cantrip. You can also cast the {@spell purify food and drink} and {@spell unseen servant} spells with this trait. Once you cast either spell with this trait, you can't cast that spell with it again until you finish long rest. Charisma is your spellcasting ability for these spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Hospitality Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Hospitality Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell goodberry}, {@spell sleep}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell aid}, {@spell calm emotions}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell create food and water}, {@spell Leomund's tiny hut}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell aura of purity}, {@spell Mordenkainen's private sanctum}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell hallow}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Stout",
                    "source": "PHB",
                    "raceName": "Halfling",
                    "raceSource": "PHB",
                    "page": 28,
                    "basicRules": true,
                    "ability": [
                        {
                            "con": 1
                        }
                    ],
                    "resist": [
                        "poison"
                    ],
                    "entries": [
                        {
                            "name": "Stout Resilience",
                            "entries": [
                                "You have advantage on saving throws against poison, and you have resistance against poison damage."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "source": "PHB",
                    "raceName": "Human",
                    "raceSource": "PHB",
                    "page": 29,
                    "basicRules": true,
                    "ability": [
                        {
                            "str": 1,
                            "dex": 1,
                            "con": 1,
                            "int": 1,
                            "wis": 1,
                            "cha": 1
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Keldon",
                    "source": "PSD",
                    "raceName": "Human",
                    "raceSource": "PHB",
                    "page": 19,
                    "ability": [
                        {
                            "str": 2,
                            "con": 1
                        }
                    ],
                    "age": {
                        "mature": 20,
                        "max": 100
                    },
                    "skillProficiencies": [
                        {
                            "athletics": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Keldons reach adulthood in their late teens and live less than a century."
                            ],
                            "data": {
                                "overwrite": "Age"
                            }
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Keldons tend toward chaotic alignments, and many walk a fine line between good and evil."
                            ],
                            "data": {
                                "overwrite": "Alignment"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Keldons are taller and heavier than the human norms of other cultures, standing almost universally above 6 feet tall and reaching heights above 7 feet. Your size is Medium."
                            ],
                            "data": {
                                "overwrite": "Size"
                            }
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and {@language Keldon|PSD}."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Languages"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Natural Athlete",
                            "entries": [
                                "You have proficiency in the {@skill Athletics} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Keldon Resilience",
                            "entries": [
                                "You have proficiency in Strength saving throws."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Icehaven Born",
                            "entries": [
                                "You are naturally adapted to {@hazard Extreme Cold|DMG|cold climates}, as described in chapter 5 of the {@i Dungeon Master's Guide}."
                            ]
                        }
                    ],
                    "overwrite": {
                        "languageProficiencies": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Mark of Handling",
                    "source": "ERLW",
                    "raceName": "Human",
                    "raceSource": "PHB",
                    "page": 42,
                    "ability": [
                        {
                            "wis": 2,
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "con",
                                    "int",
                                    "cha"
                                ],
                                "count": 1
                            }
                        }
                    ],
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice"
                    ],
                    "additionalSpells": [
                        {
                            "expanded": {
                                "s1": [
                                    "animal friendship",
                                    "speak with animals"
                                ],
                                "s2": [
                                    "beast sense",
                                    "calm emotions"
                                ],
                                "s3": [
                                    "beacon of hope",
                                    "conjure animals"
                                ],
                                "s4": [
                                    "aura of life",
                                    "dominate beast"
                                ],
                                "s5": [
                                    "awaken"
                                ]
                            },
                            "ability": "wis",
                            "known": {
                                "1": {
                                    "rest": {
                                        "1": [
                                            "animal friendship",
                                            "speak with animals"
                                        ]
                                    }
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Wild Intuition",
                            "entries": [
                                "When you make a Wisdom ({@skill Animal Handling}) or Intelligence ({@skill Nature}) check, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Primal Connection",
                            "entries": [
                                "You can cast the {@spell animal friendship} and {@spell speak with animals} spells with this trait, requiring no material component. Once you cast either spell with this trait, you can't cast that spell with it again until you finish a short or long rest. Wisdom is your spellcasting ability for these spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "The Bigger They Are",
                            "entries": [
                                "Starting at 3rd level, you can target a beast or monstrosity when you cast {@spell animal friendship} or {@spell speak with animals}, provided the creature's Intelligence score is 3 or lower."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Handling Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Handling Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell animal friendship}, {@spell speak with animals}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell beast sense}, {@spell calm emotions}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell beacon of hope}, {@spell conjure animals}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell aura of life}, {@spell dominate beast}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell awaken}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Mark of Making",
                    "source": "ERLW",
                    "raceName": "Human",
                    "raceSource": "PHB",
                    "page": 45,
                    "ability": [
                        {
                            "int": 2,
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "con",
                                    "wis",
                                    "cha"
                                ],
                                "count": 1
                            }
                        }
                    ],
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice",
                        "Tool Bonus Dice"
                    ],
                    "toolProficiencies": [
                        {
                            "anyArtisansTool": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "expanded": {
                                "s1": [
                                    "identify",
                                    "tenser's floating disk"
                                ],
                                "s2": [
                                    "continual flame",
                                    "magic weapon"
                                ],
                                "s3": [
                                    "conjure barrage",
                                    "elemental weapon"
                                ],
                                "s4": [
                                    "fabricate",
                                    "stone shape"
                                ],
                                "s5": [
                                    "creation"
                                ]
                            },
                            "ability": "int",
                            "known": {
                                "1": [
                                    "mending#c",
                                    "magic weapon"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Artisan's Intuition",
                            "entries": [
                                "When you make an {@skill Arcana} check or an ability check involving {@filter artisan's tools|items|source=phb|miscellaneous=mundane|type=artisan's tools}, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Maker's Gift",
                            "entries": [
                                "You gain proficiency with one type of artisan's tools of your choice."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spellsmith",
                            "entries": [
                                "You know the {@spell mending} cantrip. You can also cast the {@spell magic weapon} spell with this trait. When you do so, the spell lasts for 1 hour and doesn't require {@status concentration}. Once you cast the spell with this trait, you can't do so again until you finish a long rest. Intelligence is your spellcasting ability for these spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Making Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Making Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell identify}, {@spell Tenser's floating disk}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell continual flame}, {@spell magic weapon}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell conjure barrage}, {@spell elemental weapon}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell fabricate}, {@spell stone shape}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell creation}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Mark of Passage",
                    "source": "ERLW",
                    "raceName": "Human",
                    "raceSource": "PHB",
                    "page": 46,
                    "speed": 35,
                    "ability": [
                        {
                            "dex": 2,
                            "choose": {
                                "from": [
                                    "str",
                                    "con",
                                    "int",
                                    "wis",
                                    "cha"
                                ],
                                "count": 1
                            }
                        }
                    ],
                    "traitTags": [
                        "Dragonmark"
                    ],
                    "additionalSpells": [
                        {
                            "expanded": {
                                "s1": [
                                    "expeditious retreat",
                                    "jump"
                                ],
                                "s2": [
                                    "misty step",
                                    "pass without trace"
                                ],
                                "s3": [
                                    "blink",
                                    "phantom steed"
                                ],
                                "s4": [
                                    "dimension door",
                                    "freedom of movement"
                                ],
                                "s5": [
                                    "teleportation circle"
                                ]
                            },
                            "ability": "dex",
                            "known": {
                                "1": [
                                    "misty step"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Courier's Speed",
                            "entries": [
                                "Your base walking speed increases to 35 feet."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Intuitive Motion",
                            "entries": [
                                "When you make a Dexterity ({@skill Acrobatics}) check or any ability check to operate or maintain a {@filter land vehicle|items|source=phb;dmg|miscellaneous=mundane|type=vehicle (land)}, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Magical Passage",
                            "entries": [
                                "You can cast the {@spell misty step} spell once with this trait, and you regain the ability to cast it when you finish a long rest. Dexterity is your spellcasting ability for this spell."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Passage Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Passage Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell expeditious retreat}, {@spell jump}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell misty step}, {@spell pass without trace}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell blink}, {@spell phantom steed}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell dimension door}, {@spell freedom of movement}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell teleportation circle}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Mark of Sentinel",
                    "source": "ERLW",
                    "raceName": "Human",
                    "raceSource": "PHB",
                    "page": 48,
                    "ability": [
                        {
                            "con": 2,
                            "wis": 1
                        }
                    ],
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice"
                    ],
                    "additionalSpells": [
                        {
                            "expanded": {
                                "s1": [
                                    "compelled duel",
                                    "shield of faith"
                                ],
                                "s2": [
                                    "warding bond",
                                    "zone of truth"
                                ],
                                "s3": [
                                    "counterspell",
                                    "protection from energy"
                                ],
                                "s4": [
                                    "death ward",
                                    "guardian of faith"
                                ],
                                "s5": [
                                    "bigby's hand"
                                ]
                            },
                            "ability": "wis",
                            "known": {
                                "1": [
                                    "shield"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Sentinel's Intuition",
                            "entries": [
                                "When you make a Wisdom ({@skill Insight}) or Wisdom ({@skill Perception}) check, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Guardian's Shield",
                            "entries": [
                                "You can cast the {@spell shield} spell once with this trait, and you regain the ability to cast it after you finish a long rest. Wisdom is your spellcasting ability for this spell."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Vigilant Guardian",
                            "entries": [
                                "When a creature you can see within 5 feet of you is hit by an attack roll, you can use your reaction to swap places with that creature, and you are hit by the attack instead. Once you use this trait, you can't do so again until you finish a long rest."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Sentinel Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Sentinel Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell compelled duel}, {@spell shield of faith}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell warding bond}, {@spell zone of truth}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell counterspell}, {@spell protection from energy}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell death ward}, {@spell guardian of faith}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell Bigby's hand}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Variant",
                    "source": "PHB",
                    "raceName": "Human",
                    "raceSource": "PHB",
                    "page": 31,
                    "basicRules": true,
                    "ability": [
                        {
                            "choose": {
                                "from": [
                                    "str",
                                    "dex",
                                    "con",
                                    "int",
                                    "wis",
                                    "cha"
                                ],
                                "count": 2
                            }
                        }
                    ],
                    "feats": [
                        {
                            "any": 1
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "any": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Skills",
                            "entries": [
                                "You gain proficiency in one skill of your choice."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Feat",
                            "entries": [
                                "You gain one {@5etools feat|feats.html} of your choice."
                            ],
                            "type": "entries"
                        }
                    ]
                },
                {
                    "name": "Variant; Mark of Finding",
                    "source": "ERLW",
                    "raceName": "Human",
                    "raceSource": "PHB",
                    "page": 41,
                    "ability": [
                        {
                            "con": 1,
                            "wis": 2
                        }
                    ],
                    "darkvision": 60,
                    "traitTags": [
                        "Dragonmark",
                        "Skill Bonus Dice"
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "goblin": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "1": [
                                    "hunter's mark"
                                ],
                                "3": {
                                    "daily": {
                                        "1": [
                                            "locate object"
                                        ]
                                    }
                                }
                            },
                            "expanded": {
                                "s1": [
                                    "faerie fire",
                                    "longstrider"
                                ],
                                "s2": [
                                    "locate animals or plants",
                                    "locate object"
                                ],
                                "s3": [
                                    "clairvoyance",
                                    "speak with plants"
                                ],
                                "s4": [
                                    "divination",
                                    "locate creature"
                                ],
                                "s5": [
                                    "commune with nature"
                                ]
                            },
                            "ability": "wis"
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Darkvision",
                            "entries": [
                                "You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light. You can't discern color in darkness, only shades of gray."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Hunter's Intuition",
                            "entries": [
                                "When you make a Wisdom ({@skill Perception}) or Wisdom ({@skill Survival}) check, you can roll a {@dice d4} and add the number rolled to the ability check."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Finder's Magic",
                            "entries": [
                                "You can cast the {@spell hunter's mark} spell with this trait. Starting at 3rd level, you can also cast the {@spell locate object} spell with it. Once you cast either spell with this trait, you can't cast that spell with it again until you finish a long rest. Wisdom is your spellcasting ability for these spells."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write Common and Goblin."
                            ],
                            "data": {
                                "overwrite": "Languages"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Spells of the Mark",
                            "entries": [
                                "If you have the Spellcasting or the Pact Magic class feature, the spells on the Mark of Finding Spells table are added to the spell list of your spellcasting class.",
                                {
                                    "type": "table",
                                    "caption": "Mark of Finding Spells",
                                    "colLabels": [
                                        "Spell Level",
                                        "Spells"
                                    ],
                                    "colStyles": [
                                        "col-2 text-center",
                                        "col-10"
                                    ],
                                    "rows": [
                                        [
                                            "1st",
                                            "{@spell faerie fire}, {@spell longstrider}"
                                        ],
                                        [
                                            "2nd",
                                            "{@spell locate animals or plants}, {@spell locate object}"
                                        ],
                                        [
                                            "3rd",
                                            "{@spell clairvoyance}, {@spell speak with plants}"
                                        ],
                                        [
                                            "4th",
                                            "{@spell divination}, {@spell locate creature}"
                                        ],
                                        [
                                            "5th",
                                            "{@spell commune with nature}"
                                        ]
                                    ]
                                }
                            ]
                        }
                    ],
                    "overwrite": {
                        "traitTags": true,
                        "languageProficiencies": true
                    }
                },
                {
                    "name": "Gavony",
                    "source": "PSI",
                    "raceName": "Human (Innistrad)",
                    "raceSource": "PSI",
                    "page": 8,
                    "ability": [
                        {
                            "str": 1,
                            "dex": 1,
                            "con": 1,
                            "int": 1,
                            "wis": 1,
                            "cha": 1
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Kessig",
                    "source": "PSI",
                    "raceName": "Human (Innistrad)",
                    "raceSource": "PSI",
                    "page": 8,
                    "speed": 40,
                    "ability": [
                        {
                            "dex": 1,
                            "wis": 1
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "survival": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Forest Folk",
                            "entries": [
                                "You have proficiency in the {@skill Survival} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Fleet of Foot",
                            "entries": [
                                "Your base walking speed is 40 feet."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Sure-footed",
                            "entries": [
                                "When you use the {@action Dash} action, {@quickref difficult terrain||3} doesn't cost you extra movement on that turn."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Spring Attack",
                            "entries": [
                                "When you make a melee attack against a creature, you don't provoke opportunity attacks from that creature for the rest of your turn, whether you hit or not."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Nephalia",
                    "source": "PSI",
                    "raceName": "Human (Innistrad)",
                    "raceSource": "PSI",
                    "page": 8,
                    "ability": [
                        {
                            "int": 1,
                            "cha": 1
                        }
                    ],
                    "traitTags": [
                        "Skill Proficiency",
                        "Tool Proficiency"
                    ],
                    "skillToolLanguageProficiencies": [
                        {
                            "choose": [
                                {
                                    "from": [
                                        "anySkill",
                                        "anyTool"
                                    ],
                                    "count": 4
                                }
                            ]
                        }
                    ],
                    "entries": [
                        {
                            "name": "Breadth of Knowledge",
                            "entries": [
                                "You gain proficiency in any combination of four skills or with four {@book tools|phb|5|tools} of your choice."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Stensia",
                    "source": "PSI",
                    "raceName": "Human (Innistrad)",
                    "raceSource": "PSI",
                    "page": 8,
                    "ability": [
                        {
                            "str": 1,
                            "con": 1
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "intimidation": true
                        }
                    ],
                    "entries": [
                        {
                            "name": "Daunting",
                            "entries": [
                                "You have proficiency in the {@skill Intimidation} skill."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Tough",
                            "entries": [
                                "Your hit point maximum increases by 2, and it increases by 2 every time you gain a level."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Ixalan; Blue",
                    "source": "PSX",
                    "raceName": "Merfolk",
                    "raceSource": "PSZ",
                    "page": 12,
                    "otherSources": null,
                    "ability": [
                        {
                            "int": 2
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "history": true,
                            "nature": true
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true,
                            "anyStandard": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "wis",
                            "known": {
                                "1": {
                                    "_": [
                                        {
                                            "choose": "level=0|class=Wizard"
                                        }
                                    ]
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Cantrip",
                            "entries": [
                                "You know one cantrip of your choice from the {@filter wizard spell list|spells|class=wizard|level=0}. Intelligence is your spellcasting ability for it."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Lore of the Waters",
                            "entries": [
                                "You gain proficiency in the {@skill History} and {@skill Nature} skills."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write {@language Common Trade Pidgin|PSX|Common} (if it exists in your campaign), {@language Merfolk|PSX}, and one additional language of your choice."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Languages"
                            }
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Ixalan; Green",
                    "source": "PSX",
                    "raceName": "Merfolk",
                    "raceSource": "PSZ",
                    "page": 12,
                    "otherSources": null,
                    "ability": [
                        {
                            "wis": 2
                        }
                    ],
                    "languageProficiencies": [
                        {
                            "common": true,
                            "other": true,
                            "anyStandard": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "wis",
                            "known": {
                                "1": {
                                    "_": [
                                        {
                                            "choose": "level=0|class=Druid"
                                        }
                                    ]
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Cantrip",
                            "entries": [
                                "You know one cantrip of your choice from the {@filter druid spell list|spells|class=Druid|level=0}. Wisdom is your spellcasting ability for it."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Mask of the Wild",
                            "entries": [
                                "You can attempt to hide even when you are only lightly obscured by foliage, heavy rain, falling snow, mist, and other natural phenomena."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write {@language Common Trade Pidgin|PSX|Common} (if it exists in your campaign), {@language Merfolk|PSX}, and one additional language of your choice."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Languages"
                            }
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Zendikar; Cosi Creed",
                    "source": "PSZ",
                    "raceName": "Merfolk",
                    "raceSource": "PSZ",
                    "page": 13,
                    "otherSources": null,
                    "ability": [
                        {
                            "int": 1,
                            "cha": 2
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "sleight of hand": true,
                            "stealth": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "cha",
                            "known": {
                                "1": {
                                    "_": [
                                        {
                                            "choose": "level=0|class=Bard"
                                        }
                                    ]
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Cantrip",
                            "entries": [
                                "You know one cantrip of your choice from the {@filter bard spell list|spells|class=bard|level=0}. Charisma is your spellcasting ability for it."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Creed of the Trickster",
                            "entries": [
                                "You have proficiency in the {@skill Sleight of Hand} and {@skill Stealth} skills."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Zendikar; Emeria Creed",
                    "source": "PSZ",
                    "raceName": "Merfolk",
                    "raceSource": "PSZ",
                    "page": 13,
                    "otherSources": null,
                    "ability": [
                        {
                            "wis": 2
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "deception": true,
                            "persuasion": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "wis",
                            "known": {
                                "1": {
                                    "_": [
                                        {
                                            "choose": "level=0|class=Druid"
                                        }
                                    ]
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Cantrip",
                            "entries": [
                                "You know one cantrip of your choice from the {@filter druid spell list|spells|class=druid|level=0}. Wisdom is your spellcasting ability for it."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Wind Creed Manipulation",
                            "entries": [
                                "You have proficiency in the {@skill Deception} and {@skill Persuasion} skills."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Zendikar; Ula Creed",
                    "source": "PSZ",
                    "raceName": "Merfolk",
                    "raceSource": "PSZ",
                    "page": 13,
                    "otherSources": null,
                    "ability": [
                        {
                            "int": 2
                        }
                    ],
                    "traitTags": [
                        "Tool Proficiency"
                    ],
                    "skillProficiencies": [
                        {
                            "survival": true
                        }
                    ],
                    "additionalSpells": [
                        {
                            "ability": "int",
                            "known": {
                                "1": {
                                    "_": [
                                        {
                                            "choose": "level=0|class=Wizard"
                                        }
                                    ]
                                }
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Cantrip",
                            "entries": [
                                "You know one cantrip of your choice from the {@filter wizard spell list|spells|class=wizard|level=0}. Intelligence is your spellcasting ability for it."
                            ],
                            "type": "entries"
                        },
                        {
                            "name": "Water Creed Navigation",
                            "entries": [
                                "You have proficiency with {@item navigator's tools|phb} and in the {@skill Survival} skill."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Beasthide",
                    "source": "ERLW",
                    "raceName": "Shifter",
                    "raceSource": "ERLW",
                    "page": 34,
                    "ability": [
                        {
                            "con": 2,
                            "str": 1
                        }
                    ],
                    "traitTags": [
                        "Natural Armor"
                    ],
                    "skillProficiencies": [
                        {
                            "athletics": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Natural Athlete",
                            "entries": [
                                "You have proficiency in the {@skill Athletics} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shifting Feature",
                            "entries": [
                                "Whenever you shift, you gain {@dice 1d6} additional temporary hit points. While shifted, you have a +1 bonus to your Armor Class."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Longtooth",
                    "source": "ERLW",
                    "raceName": "Shifter",
                    "raceSource": "ERLW",
                    "page": 34,
                    "ability": [
                        {
                            "str": 2,
                            "dex": 1
                        }
                    ],
                    "traitTags": [
                        "Natural Weapon"
                    ],
                    "skillProficiencies": [
                        {
                            "intimidation": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Fierce",
                            "entries": [
                                "You have proficiency in the {@skill Intimidation} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shifting Feature",
                            "entries": [
                                "While shifted, you can use your elongated fangs to make an unarmed strike as a bonus action. If you hit with your fangs, you can deal piercing damage equal to {@dice 1d6} + your Strength modifier, instead of the bludgeoning damage normal for an unarmed strike."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Swiftstride",
                    "source": "ERLW",
                    "raceName": "Shifter",
                    "raceSource": "ERLW",
                    "page": 34,
                    "ability": [
                        {
                            "dex": 2,
                            "cha": 1
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "acrobatics": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Graceful",
                            "entries": [
                                "You have proficiency in the {@skill Acrobatics} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shifting Feature",
                            "entries": [
                                "While shifted, your walking speed increases by 10 feet. Additionally, you can move up to 10 feet as a reaction when a creature ends its turn within 5 feet of you. This reactive movement doesn't provoke opportunity attacks."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Wildhunt",
                    "source": "ERLW",
                    "raceName": "Shifter",
                    "raceSource": "ERLW",
                    "page": 34,
                    "ability": [
                        {
                            "wis": 2,
                            "dex": 1
                        }
                    ],
                    "skillProficiencies": [
                        {
                            "survival": true
                        }
                    ],
                    "entries": [
                        {
                            "type": "entries",
                            "name": "Natural Tracker",
                            "entries": [
                                "You have proficiency in the {@skill Survival} skill."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Shifting Feature",
                            "entries": [
                                "While shifted, you have advantage on Wisdom checks, and no creature within 30 feet of you can make an attack roll with advantage against you, unless you're {@condition incapacitated}."
                            ]
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "source": "PHB",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 42,
                    "srd": true,
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Asmodeus",
                    "source": "MTF",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 21,
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Baalzebul",
                    "source": "MTF",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 21,
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "ray of sickness#2"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "crown of madness"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "thaumaturgy#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Legacy of Maladomini",
                            "entries": [
                                "You know the {@spell thaumaturgy} cantrip. When you reach 3rd level, you can cast the {@spell ray of sickness} spell as a 2nd-level spell once with this trait and regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell crown of madness} spell once with this trait and regain the ability to do so when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Dispater",
                    "source": "MTF",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 21,
                    "ability": [
                        {
                            "cha": 2,
                            "dex": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "disguise self"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "detect thoughts"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "thaumaturgy#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Legacy of Dis",
                            "entries": [
                                "You know the {@spell thaumaturgy} cantrip. When you reach 3rd level, you can cast the {@spell disguise self} spell once with this trait and regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell detect thoughts} spell once with this trait and regain the ability to do so when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "overwrite": {
                        "ability": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Fierna",
                    "source": "MTF",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 21,
                    "ability": [
                        {
                            "cha": 2,
                            "wis": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "charm person#2"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "suggestion"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "friends#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Legacy of Phlegethos",
                            "entries": [
                                "You know the {@spell friends} cantrip. When you reach 3rd level, you can cast the {@spell charm person} spell as a 2nd-level spell once with this trait and regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell suggestion} spell once with this trait and regain the ability to do so when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "overwrite": {
                        "ability": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Glasya",
                    "source": "MTF",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 22,
                    "ability": [
                        {
                            "cha": 2,
                            "dex": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "disguise self"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "invisibility"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "minor illusion#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Legacy of Malbolge",
                            "entries": [
                                "You know the {@spell minor illusion} cantrip. When you reach 3rd level, you can cast the {@spell disguise self} spell once with this trait and regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell invisibility} spell once with this trait and regain the ability to do so when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "overwrite": {
                        "ability": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Levistus",
                    "source": "MTF",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 22,
                    "ability": [
                        {
                            "cha": 2,
                            "con": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "armor of agathys#2"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "darkness"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "ray of frost#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Legacy of Stygia",
                            "entries": [
                                "You know the {@spell ray of frost} cantrip. When you reach 3rd level, you can cast the {@spell armor of Agathys} spell as a 2nd-level spell once with this trait and regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell darkness} spell once with this trait and regain the ability to do so when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "overwrite": {
                        "ability": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Mammon",
                    "source": "MTF",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 22,
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "tenser's floating disk"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "arcane lock"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "mage hand#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Legacy of Minauros",
                            "entries": [
                                "You know the {@spell mage hand} cantrip. When you reach 3rd level, you can cast the {@spell Tenser's floating disk} spell once with this trait and regain the ability to do so when you finish a short or long rest. When you reach 5th level, you can cast the {@spell arcane lock} spell once with this trait, requiring no material component, and regain the ability to do so when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Mephistopheles",
                    "source": "MTF",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 23,
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "burning hands#2"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "flame blade"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "mage hand#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Legacy of Cania",
                            "entries": [
                                "You know the {@spell mage hand} cantrip. When you reach 3rd level, you can cast the {@spell burning hands} spell as a 2nd-level spell once with this trait and regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell flame blade} spell once with this trait and regain the ability to do so when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Variant; Devil's Tongue",
                    "source": "SCAG",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 118,
                    "ability": [
                        {
                            "int": 1,
                            "choose": {
                                "from": [
                                    "dex",
                                    "cha"
                                ],
                                "count": 1,
                                "amount": 2
                            }
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "charm person#2"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "enthrall"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "vicious mockery#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Appearance",
                            "entries": [
                                "Your tiefling might not look like other tieflings. Rather than having the physical characteristics described in the Player's Handbook, choose {@dice 1d4+1} of the following features: small horns; fangs or sharp teeth; a forked tongue; catlike eyes; six fingers on each hand; goatlike legs; cloven hoofs; a forked tail; leathery or scaly skin; red or dark blue skin; cast no shadow or reflection; exude a smell of brimstone."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Devil's Tongue",
                            "entries": [
                                "You know the {@spell vicious mockery} cantrip. When you reach 3rd level, you can cast the {@spell charm person} spell as a 2nd-level spell once with this trait. When you reach 5th level, you can cast the {@spell enthrall} spell once with this trait. You must finish a long rest to cast these spells once again with this trait. Charisma is your spellcasting ability for them. This trait replaces the Infernal Legacy trait."
                            ],
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "overwrite": {
                        "ability": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Variant; Hellfire",
                    "source": "SCAG",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 118,
                    "ability": [
                        {
                            "int": 1,
                            "choose": {
                                "from": [
                                    "dex",
                                    "cha"
                                ],
                                "count": 1,
                                "amount": 2
                            }
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "burning hands#2"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "darkness"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "thaumaturgy#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Appearance",
                            "entries": [
                                "Your tiefling might not look like other tieflings. Rather than having the physical characteristics described in the Player's Handbook, choose {@dice 1d4+1} of the following features: small horns; fangs or sharp teeth; a forked tongue; catlike eyes; six fingers on each hand; goatlike legs; cloven hoofs; a forked tail; leathery or scaly skin; red or dark blue skin; cast no shadow or reflection; exude a smell of brimstone."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Hellfire",
                            "entries": [
                                "You know the {@spell thaumaturgy} cantrip. Once you reach 3rd level, you can cast the {@spell burning hands} spell once per day as a 2nd-level spell; you must finish a long rest in order to cast the spell again using this trait. Once you reach 5th level, you can also cast the {@spell darkness} spell; you must finish a long rest in order to cast the spell again using this trait. Charisma is your spellcasting ability for these spells."
                            ],
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "overwrite": {
                        "ability": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Variant; Infernal Legacy",
                    "source": "SCAG",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 118,
                    "ability": [
                        {
                            "int": 1,
                            "choose": {
                                "from": [
                                    "dex",
                                    "cha"
                                ],
                                "count": 1,
                                "amount": 2
                            }
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "hellish rebuke"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "darkness"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "thaumaturgy#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Appearance",
                            "entries": [
                                "Your tiefling might not look like other tieflings. Rather than having the physical characteristics described in the Player's Handbook, choose {@dice 1d4+1} of the following features: small horns; fangs or sharp teeth; a forked tongue; catlike eyes; six fingers on each hand; goatlike legs; cloven hoofs; a forked tail; leathery or scaly skin; red or dark blue skin; cast no shadow or reflection; exude a smell of brimstone."
                            ],
                            "type": "entries"
                        }
                    ],
                    "overwrite": {
                        "ability": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Variant; Winged",
                    "source": "SCAG",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 118,
                    "speed": {
                        "walk": 30,
                        "fly": 30
                    },
                    "ability": [
                        {
                            "int": 1,
                            "choose": {
                                "from": [
                                    "dex",
                                    "cha"
                                ],
                                "count": 1,
                                "amount": 2
                            }
                        }
                    ],
                    "traitTags": [
                        "Uncommon Race"
                    ],
                    "additionalSpells": null,
                    "entries": [
                        {
                            "name": "Appearance",
                            "entries": [
                                "Your tiefling might not look like other tieflings. Rather than having the physical characteristics described in the Player's Handbook, choose {@dice 1d4+1} of the following features: small horns; fangs or sharp teeth; a forked tongue; catlike eyes; six fingers on each hand; goatlike legs; cloven hoofs; a forked tail; leathery or scaly skin; red or dark blue skin; cast no shadow or reflection; exude a smell of brimstone."
                            ],
                            "type": "entries"
                        },
                        {
                            "type": "entries",
                            "name": "Winged",
                            "entries": [
                                "You have bat-like wings sprouting from your shoulder blades. You have a flying speed of 30 feet while you aren't wearing heavy armor."
                            ],
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "overwrite": {
                        "ability": true,
                        "traitTags": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Zariel",
                    "source": "MTF",
                    "raceName": "Tiefling",
                    "raceSource": "PHB",
                    "page": 23,
                    "ability": [
                        {
                            "cha": 2,
                            "str": 1
                        }
                    ],
                    "additionalSpells": [
                        {
                            "innate": {
                                "3": {
                                    "daily": {
                                        "1": [
                                            "searing smite#2"
                                        ]
                                    }
                                },
                                "5": {
                                    "daily": {
                                        "1": [
                                            "branding smite"
                                        ]
                                    }
                                }
                            },
                            "ability": "cha",
                            "known": {
                                "1": [
                                    "thaumaturgy#c"
                                ]
                            }
                        }
                    ],
                    "entries": [
                        {
                            "name": "Legacy of Avernus",
                            "entries": [
                                "You know the {@spell thaumaturgy} cantrip. When you reach 3rd level, you can cast the {@spell searing smite} spell as a 2nd-level spell once with this trait and regain the ability to do so when you finish a long rest. When you reach 5th level, you can cast the {@spell branding smite} spell once with this trait and regain the ability to do so when you finish a long rest. Charisma is your spellcasting ability for these spells."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Infernal Legacy"
                            }
                        }
                    ],
                    "overwrite": {
                        "ability": true
                    },
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Ixalan",
                    "source": "PSX",
                    "raceName": "Vampire",
                    "raceSource": "PSZ",
                    "page": 14,
                    "otherSources": null,
                    "ability": [
                        {
                            "wis": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Age",
                            "type": "entries",
                            "entries": [
                                "Vampires don't mature and age in the same way that other races do."
                            ],
                            "data": {
                                "overwrite": "Age"
                            }
                        },
                        {
                            "name": "Alignment",
                            "type": "entries",
                            "entries": [
                                "Vampires might not have an innate tendency toward evil, but many of them end up there. Evil or not, their strict hierarchies incline them toward a lawful alignment."
                            ],
                            "data": {
                                "overwrite": "Alignment"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Size",
                            "entries": [
                                "Vampires are the same size and build as humans. Your size is Medium."
                            ],
                            "data": {
                                "overwrite": "Size"
                            }
                        },
                        {
                            "type": "entries",
                            "name": "Feast of Blood",
                            "entries": [
                                "When you drain blood with your Bloodthirst ability, you experience a surge of vitality. Your speed increases by 10 feet, and you gain advantage on Strength and Dexterity checks and saving throws for 1 minute."
                            ]
                        },
                        {
                            "name": "Languages",
                            "entries": [
                                "You can speak, read, and write {@language Common Trade Pidgin|PSX|Common} (if it exists in your campaign) and {@language Vampire|PSX}."
                            ],
                            "type": "entries",
                            "data": {
                                "overwrite": "Languages"
                            }
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                },
                {
                    "name": "Zendikar",
                    "source": "PSZ",
                    "raceName": "Vampire",
                    "raceSource": "PSZ",
                    "page": 14,
                    "otherSources": null,
                    "ability": [
                        {
                            "int": 1
                        }
                    ],
                    "entries": [
                        {
                            "name": "Null Transformation",
                            "entries": [
                                "A humanoid killed with your Bloodthirst ability becomes a {@creature Vampire Null|PSZ|null}."
                            ],
                            "type": "entries"
                        }
                    ],
                    "hasFluff": true,
                    "hasFluffImages": true
                }
            ]
        }
        `;
        
        let data = {class: [], subclass:[], classFeature:[], subclassFeature:[], race:[], subrace:[]};
        let jsons = [class_barbarian, class_bard, races];
        for(let str of jsons){
            let parsed = JSON.parse(str);
            data.class = data.class.concat(parsed.class);
            data.subclass = data.subclass.concat(parsed.subclass);
            data.classFeature = data.classFeature.concat(parsed.classFeature);
            data.subclassFeature = data.subclassFeature.concat(parsed.subclassFeature);
            data.race = data.race.concat(parsed.race);
            data.subrace = data.subrace.concat(parsed.subrace);
        }
        return data;
    }
    /**Grabs JSON information from a file filled with information used in specific circumstances, such as figuring out class feature options (which proficiencies you get to choose between)
     * when you level up as one of the base classes
     */
    static _getFoundryData(){
        const _foundry = `{
            "class": [
                {
                    "name": "Sorcerer",
                    "source": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "sorcery-points",
                                "type": "number",
                                "scale": {
                                    "2": {
                                        "value": 2
                                    },
                                    "3": {
                                        "value": 3
                                    },
                                    "4": {
                                        "value": 4
                                    },
                                    "5": {
                                        "value": 5
                                    },
                                    "6": {
                                        "value": 6
                                    },
                                    "7": {
                                        "value": 7
                                    },
                                    "8": {
                                        "value": 8
                                    },
                                    "9": {
                                        "value": 9
                                    },
                                    "10": {
                                        "value": 10
                                    },
                                    "11": {
                                        "value": 11
                                    },
                                    "12": {
                                        "value": 12
                                    },
                                    "13": {
                                        "value": 13
                                    },
                                    "14": {
                                        "value": 14
                                    },
                                    "15": {
                                        "value": 15
                                    },
                                    "16": {
                                        "value": 16
                                    },
                                    "17": {
                                        "value": 17
                                    },
                                    "18": {
                                        "value": 18
                                    },
                                    "19": {
                                        "value": 19
                                    },
                                    "20": {
                                        "value": 20
                                    }
                                }
                            },
                            "title": "Sorcery Points"
                        }
                    ]
                }
            ],
            "subclass": [
                {
                    "name": "Nature Domain",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "Trickery Domain",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "Death Domain",
                    "source": "DMG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "College of Whispers",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "psychic-blades",
                                "type": "dice",
                                "scale": {
                                    "3": {
                                        "n": 2,
                                        "die": 6
                                    },
                                    "5": {
                                        "n": 3,
                                        "die": 6
                                    },
                                    "10": {
                                        "n": 5,
                                        "die": 6
                                    },
                                    "15": {
                                        "n": 8,
                                        "die": 6
                                    }
                                }
                            },
                            "title": "Psychic Blades"
                        }
                    ]
                },
                {
                    "name": "Forge Domain",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "Order Domain",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                }
            ],
            "classFeature": [
                {
                    "name": "Unarmored Defense",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 1,
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Primal Knowledge",
                    "source": "TCE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "athletics",
                                        "intimidation",
                                        "nature",
                                        "perception",
                                        "survival"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Fast Movement",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 5,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ 10"
                                }
                            ]
                        }
                    ],
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Brutal Critical (1 die)",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 9,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.meleeCriticalDamageDice",
                                    "mode": "UPGRADE",
                                    "value": 1
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Brutal Critical (2 dice)",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 13,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.meleeCriticalDamageDice",
                                    "mode": "UPGRADE",
                                    "value": 2
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Brutal Critical (3 dice)",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 17,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.meleeCriticalDamageDice",
                                    "mode": "UPGRADE",
                                    "value": 3
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Primal Champion",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 20,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.abilities.str.value",
                                    "mode": "ADD",
                                    "value": "+ 4"
                                },
                                {
                                    "key": "data.abilities.con.value",
                                    "mode": "ADD",
                                    "value": "+ 4"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Jack of All Trades",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 2,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.jackOfAllTrades",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Harness Divine Power",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "level": 2,
                    "system": {
                        "uses.per": "day",
                        "uses.value": 1,
                        "uses.max": "1 + min(floor(@classes.cleric.levels / 6), 1) + min(floor(@classes.cleric.levels / 18), 1)"
                    }
                },
                {
                    "name": "Channel Divinity",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "level": 6,
                    "isIgnored": true
                },
                {
                    "name": "Channel Divinity",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "level": 18,
                    "isIgnored": true
                },
                {
                    "name": "Druidic",
                    "source": "PHB",
                    "className": "Druid",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "druidic": true
                            }
                        ]
                    }
                },
                {
                    "name": "Fighting Style",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "level": 1,
                    "isIgnored": true
                },
                {
                    "name": "Martial Arts",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 1,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Unarmed Strike (Monk)",
                                "source": "PHB",
                                "page": 76,
                                "srd": true,
                                "type": "M",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "entries": [
                                    {
                                        "type": "quote",
                                        "entries": [
                                            "Tether even a roasted chicken."
                                        ],
                                        "by": "Yamamoto Tsunetomo",
                                        "from": "Hagakure Kikigaki"
                                    }
                                ],
                                "foundrySystem": {
                                    "equipped": true,
                                    "damage.parts": [
                                        [
                                            "@scale.monk.die + @mod",
                                            "bludgeoning"
                                        ]
                                    ],
                                    "ability": "dex"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Unarmored Defense",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 1,
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Unarmored Movement",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 2,
                    "effects": [
                        {
                            "name": "Unarmored Movement",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.walk) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.burrow",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.burrow) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.climb",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.climb) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.fly",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.fly) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.swim",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.swim) * @scale.monk.unarmored-movement)"
                                }
                            ]
                        }
                    ],
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Diamond Soul",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 14,
                    "effects": [
                        {
                            "changes": [
                                {
                                    "key": "flags.dnd5e.diamondSoul",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Fighting Style",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "level": 2,
                    "isIgnored": true
                },
                {
                    "name": "Divine Health",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "level": 3,
                    "effects": [
                        {
                            "name": "Disease Immunity",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.traits.ci.value",
                                    "mode": "ADD",
                                    "value": "diseased"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Deft Explorer",
                    "source": "TCE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "any": 2
                            }
                        ],
                        "expertise": [
                            {
                                "anyProficientSkill": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Fighting Style",
                    "source": "PHB",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "level": 2,
                    "isIgnored": true
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            },
                            {
                                "anyProficientSkill": 1,
                                "thieves' tools": true
                            }
                        ]
                    }
                },
                {
                    "name": "Thieves' Cant",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "thieves' cant": true
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 6,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            },
                            {
                                "anyProficientSkill": 1,
                                "thieves' tools": true
                            }
                        ]
                    }
                },
                {
                    "name": "Reliable Talent",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 11,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.reliableTalent",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Blindsense",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 14,
                    "entryData": {
                        "senses": [
                            {
                                "blindsight": 10
                            }
                        ]
                    }
                },
                {
                    "name": "Slippery Mind",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 15,
                    "entryData": {
                        "savingThrowProficiencies": [
                            {
                                "wis": true
                            }
                        ]
                    }
                },
                {
                    "name": "Font of Magic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 2,
                    "system": {
                        "activation.type": null,
                        "uses.per": null,
                        "uses.value": null,
                        "uses.max": null
                    }
                },
                {
                    "name": "Sorcery Points",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 2,
                    "system": {
                        "uses.per": "lr",
                        "uses.max": "@scale.sorcerer.sorcery-points"
                    },
                    "img": "icons/magic/control/silhouette-hold-change-blue.webp"
                },
                {
                    "name": "Metamagic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 3,
                    "entries": [
                        "At 3rd level, you gain the ability to twist your spells to suit your needs. You gain two Metamagic options of your choice. You gain another one at 10th and 17th level.",
                        "You can use only one Metamagic option on a spell when you cast it, unless otherwise noted."
                    ]
                },
                {
                    "name": "Metamagic Options",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Metamagic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Metamagic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 17,
                    "isIgnored": true
                },
                {
                    "name": "Eldritch Invocations",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "level": 2,
                    "entries": [
                        "In your study of occult lore, you have unearthed eldritch invocations, fragments of forbidden knowledge that imbue you with an abiding magical ability.",
                        "At 2nd level, you gain two eldritch invocations of your choice. Your invocation options are detailed at the end of the class description. When you gain certain warlock levels, you gain additional invocations of your choice, as shown in the Invocations Known column of the Warlock table.",
                        "Additionally, when you gain a level in this class, you can choose one of the invocations you know and replace it with another invocation that you could learn at that level.",
                        "If an eldritch invocation has prerequisites, you must meet them to learn it. You can learn the invocation at the same time that you meet its prerequisites. A level prerequisite refers to your level in this class."
                    ]
                },
                {
                    "name": "Pact Boon",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Infusions Known",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "level": 2,
                    "isIgnored": true
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Expert Sidekick",
                    "classSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "light": true
                            }
                        ],
                        "savingThrowProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "dex",
                                        "int",
                                        "cha"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "skillProficiencies": [
                            {
                                "any": 5
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "TCE",
                    "className": "Expert Sidekick",
                    "classSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "TCE",
                    "className": "Expert Sidekick",
                    "classSource": "TCE",
                    "level": 15,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Spellcaster Sidekick",
                    "classSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "light": true
                            }
                        ],
                        "savingThrowProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "wis",
                                        "int",
                                        "cha"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "insight",
                                        "investigation",
                                        "medicine",
                                        "performance",
                                        "persuasion",
                                        "religion"
                                    ],
                                    "count": 2
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Warrior Sidekick",
                    "classSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "light": true,
                                "medium": true,
                                "heavy": true
                            }
                        ],
                        "savingThrowProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "str",
                                        "dex",
                                        "con"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "acrobatics",
                                        "animal handling",
                                        "athletics",
                                        "intimidation",
                                        "nature",
                                        "perception",
                                        "survival"
                                    ],
                                    "count": 2
                                }
                            }
                        ]
                    }
                }
            ],
            "subclassFeature": [
                {
                    "name": "Eagle",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Totem Warrior",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "activation.type": "bonus",
                        "activation.cost": 1
                    }
                },
                {
                    "name": "Call the Hunt",
                    "source": "TCE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Beast",
                    "subclassSource": "TCE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft"
                    }
                },
                {
                    "name": "Magic Awareness",
                    "source": "TCE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Wild Magic",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft"
                    }
                },
                {
                    "name": "Divine Fury",
                    "source": "XGE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Zealot",
                    "subclassSource": "XGE",
                    "level": 3,
                    "isChooseSystemRenderEntries": true,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "While you're raging, the first creature you hit on each of your turns with a weapon attack"
                    },
                    "chooseSystem": [
                        {
                            "name": "Necrotic Damage",
                            "system": {
                                "damage.parts": [
                                    [
                                        "1d6 + floor(@classes.barbarian.levels / 2)",
                                        "necrotic"
                                    ]
                                ]
                            }
                        },
                        {
                            "name": "Radiant Damage",
                            "system": {
                                "damage.parts": [
                                    [
                                        "1d6 + floor(@classes.barbarian.levels / 2)",
                                        "radiant"
                                    ]
                                ]
                            }
                        }
                    ]
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "any": 3
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "medium": true,
                                "shield|phb": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Performance of Creation",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "object",
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Animating Performance",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "object",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Unsettling Words",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Universal Speech",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 6,
                    "system": {
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Infectious Inspiration",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Tales from Beyond",
                    "source": "VRGR",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Enthralling Performance",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "activation.type": "minute",
                        "activation.cost": 1,
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "medium": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "scimitar|phb": true
                            }
                        ]
                    }
                },
                {
                    "name": "Fighting Style",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Psychic Blades",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "When you hit a creature with a weapon attack",
                        "damage.parts": [
                            [
                                "@scale.college-of-whispers.psychic-blades",
                                "psychic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Words of Terror",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "activation.type": "minute",
                        "activation.cost": 1,
                        "target.value": 1,
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Mantle of Whispers",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Shadow Lore",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Channel Divinity: Touch of Death",
                    "source": "DMG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Death",
                    "subclassSource": "DMG",
                    "level": 2,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "When the cleric hits a creature with a melee attack",
                        "damage.parts": [
                            [
                                "5 + (2 * @classes.cleric.levels)",
                                "necrotic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "DMG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Death",
                    "subclassSource": "DMG",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.death-domain.divine-strike",
                                "necrotic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Blessings of Knowledge",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 2
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Knowledge of the Ages",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "duration.value": 10,
                        "duration.units": "minute"
                    }
                },
                {
                    "name": "Channel Divinity: Read Thoughts",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Visions of the Past",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 17,
                    "system": {
                        "activation.type": "minute",
                        "activation.cost": 1
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Life",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ]
                    }
                },
                {
                    "name": "Disciple of Life",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Life",
                    "subclassSource": "PHB",
                    "level": 1,
                    "effects": [
                        {
                            "name": "Bonus Healing",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.bonuses.heal.damage",
                                    "mode": "ADD",
                                    "value": "+ @item.level + 2"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Channel Divinity: Radiance of the Dawn",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Light",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "damage.parts": [
                            [
                                "2d10 + @classes.cleric.levels",
                                "radiant"
                            ]
                        ],
                        "formula": ""
                    }
                },
                {
                    "name": "Corona of Light",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Light",
                    "subclassSource": "PHB",
                    "level": 17,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Acolyte of Nature",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "nature",
                                        "survival"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Charm Animals and Plants",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "damage.parts": [
                            [
                                "2d10 + @classes.cleric.levels",
                                "radiant"
                            ]
                        ]
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.nature-domain.divine-strike",
                                "cold"
                            ],
                            [
                                "@scale.nature-domain.divine-strike",
                                "fire"
                            ],
                            [
                                "@scale.nature-domain.divine-strike",
                                "lightning"
                            ]
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Tempest",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Invoke Duplicity",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Trickery",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Trickery",
                    "subclassSource": "PHB",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.order-domain.divine-strike",
                                "poison"
                            ]
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "War",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Acolyte of Strength",
                    "source": "PSA",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Strength (PSA)",
                    "subclassSource": "PSA",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "athletics",
                                        "nature",
                                        "survival"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Arcane Initiate",
                    "source": "SCAG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Arcana",
                    "subclassSource": "SCAG",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "arcana": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Arcane Abjuration",
                    "source": "SCAG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Arcana",
                    "subclassSource": "SCAG",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Order",
                    "subclassSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "intimidation",
                                        "persuasion"
                                    ]
                                }
                            }
                        ],
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Order's Demand",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Order",
                    "subclassSource": "TCE",
                    "level": 2,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Order",
                    "subclassSource": "TCE",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.order-domain.divine-strike",
                                "psychic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Emboldening Bond",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Peace",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Implement of Peace",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Peace",
                    "subclassSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "insight",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Twilight",
                    "subclassSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Eyes of Night",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Twilight",
                    "subclassSource": "TCE",
                    "level": 1,
                    "actorTokenMod": {
                        "dimSight": [
                            {
                                "mode": "setMax",
                                "value": 300
                            }
                        ]
                    },
                    "system": {
                        "target.type": "creature",
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TDCSR",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Blood",
                    "subclassSource": "TDCSR",
                    "level": 1,
                    "entryData": {
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Forge",
                    "subclassSource": "XGE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            }
                        ]
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Forge",
                    "subclassSource": "XGE",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.forge-domain.divine-strike",
                                "fire"
                            ]
                        ]
                    }
                },
                {
                    "name": "Saint of Forge and Fire",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Forge",
                    "subclassSource": "XGE",
                    "level": 17,
                    "entryData": {
                        "immune": [
                            "fire"
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Path to the Grave",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Grave",
                    "subclassSource": "XGE",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Sentinel at Death's Door",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Grave",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Keeper of Souls",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Grave",
                    "subclassSource": "XGE",
                    "level": 17,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Nature's Ward",
                    "source": "PHB",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Land",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "immune": [
                            "poison"
                        ],
                        "conditionImmune": [
                            "disease",
                            "poisoned"
                        ]
                    }
                },
                {
                    "name": "Halo of Spores",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Spores",
                    "subclassSource": "TCE",
                    "level": 2,
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "range.units": "self"
                    }
                },
                {
                    "name": "Spreading Spores",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Spores",
                    "subclassSource": "TCE",
                    "level": 10,
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "cube",
                        "range.value": 30,
                        "range.units": "ft",
                        "duration.value": 1,
                        "duration.units": "minute"
                    }
                },
                {
                    "name": "Fungal Body",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Spores",
                    "subclassSource": "TCE",
                    "level": 14,
                    "entryData": {
                        "conditionImmune": [
                            "blinded",
                            "deafened",
                            "frightened",
                            "poisoned"
                        ]
                    }
                },
                {
                    "name": "Summon Wildfire Spirit",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Wildfire",
                    "subclassSource": "TCE",
                    "level": 2,
                    "system": {
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Incarnation of Corruption",
                    "source": "TDCSR",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Blighted",
                    "subclassSource": "TDCSR",
                    "level": 14,
                    "entryData": {
                        "resist": [
                            "necrotic"
                        ]
                    }
                },
                {
                    "name": "Balm of the Summer Court",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Dreams",
                    "subclassSource": "XGE",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 120,
                        "range.units": "ft",
                        "uses.per": "charges",
                        "uses.value": 2,
                        "uses.max": "@classes.druid.levels",
                        "uses.recovery": "@classes.druid.levels",
                        "formula": "1d6",
                        "actionType": "healing"
                    }
                },
                {
                    "name": "Hearth of Moonlight and Shadow",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Dreams",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Hidden Paths",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Dreams",
                    "subclassSource": "XGE",
                    "level": 10,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Speech of the Woods",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Shepherd",
                    "subclassSource": "XGE",
                    "level": 2,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "sylvan": true
                            }
                        ]
                    }
                },
                {
                    "name": "Spirit Totem",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Shepherd",
                    "subclassSource": "XGE",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Unleash Incarnation",
                    "source": "EGW",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Echo Knight",
                    "subclassSource": "EGW",
                    "level": 3,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "Whenever you take the Attack action",
                        "activation.cost": 1
                    }
                },
                {
                    "name": "Combat Superiority",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "resources": [
                            {
                                "name": "Superiority Die",
                                "type": "dicePool",
                                "recharge": "restShort",
                                "count": "floor((<$level$> + 1) / 8) + 4",
                                "number": 1,
                                "faces": "8 + (sign(ceil((<$level$> - 2) / 8) - 1) * 2)"
                            }
                        ]
                    },
                    "system": {
                        "activation.type": null,
                        "uses.value": null,
                        "uses.max": null
                    }
                },
                {
                    "name": "Maneuver Options",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Student of War",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Additional Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 7,
                    "isIgnored": true
                },
                {
                    "name": "Additional Superiority Die",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 7,
                    "isIgnored": true
                },
                {
                    "name": "Additional Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Improved Combat Superiority (d10)",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Additional Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 15,
                    "isIgnored": true
                },
                {
                    "name": "Additional Superiority Die",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 15,
                    "isIgnored": true
                },
                {
                    "name": "Improved Combat Superiority (d12)",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 18,
                    "isIgnored": true
                },
                {
                    "name": "Improved Critical",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Champion",
                    "subclassSource": "PHB",
                    "level": 3,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.weaponCriticalThreshold",
                                    "mode": "OVERRIDE",
                                    "value": 19
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Remarkable Athlete",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Champion",
                    "subclassSource": "PHB",
                    "level": 7,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.remarkableAthlete",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Additional Fighting Style",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Champion",
                    "subclassSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Arcane Charge",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Eldritch Knight",
                    "subclassSource": "PHB",
                    "level": 15,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Rallying Cry",
                    "source": "SCAG",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Purple Dragon Knight (Banneret)",
                    "subclassSource": "SCAG",
                    "level": 3,
                    "system": {
                        "target.value": 3,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Royal Envoy",
                    "source": "SCAG",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Purple Dragon Knight (Banneret)",
                    "subclassSource": "SCAG",
                    "level": 7,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "insight",
                                        "intimidation",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ],
                        "expertise": [
                            {
                                "persuasion": true
                            }
                        ]
                    }
                },
                {
                    "name": "Inspiring Surge",
                    "source": "SCAG",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Purple Dragon Knight (Banneret)",
                    "subclassSource": "SCAG",
                    "level": 10,
                    "system": {
                        "target.value": 1,
                        "target.type": "ally",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Psionic Power",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Psi Warrior",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "resources": [
                            {
                                "name": "Psionic Energy Die",
                                "type": "dicePool",
                                "recharge": "restLong",
                                "count": "2 * PB",
                                "number": 1,
                                "faces": "(6 + ((ceil((<$level$> + 2) / 6) - 1) * 2))"
                            }
                        ]
                    }
                },
                {
                    "name": "Guarded Mind",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Psi Warrior",
                    "subclassSource": "TCE",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "psychic"
                        ]
                    }
                },
                {
                    "name": "Bulwark of Force",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Psi Warrior",
                    "subclassSource": "TCE",
                    "level": 15,
                    "system": {
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "giant": true
                            }
                        ]
                    }
                },
                {
                    "name": "Rune Carver",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entries": [
                        "{@i 3rd-level Rune Knight feature}",
                        "You can use magic runes to enhance your gear. You learn two runes of your choice, from among the runes described below, and each time you gain a level in this class, you can replace one rune you know with a different one from this feature. When you reach certain levels in this class, you learn additional runes, as shown in the Runes Known table.",
                        "Whenever you finish a long rest, you can touch a number of objects equal to the number of runes you know, and you inscribe a different rune onto each of the objects. To be eligible, an object must be a weapon, a suit of armor, a shield, a piece of jewelry, or something else you can wear or hold in a hand. Your rune remains on an object until you finish a long rest, and an object can bear only one of your runes at a time.",
                        {
                            "type": "table",
                            "caption": "Runes Known",
                            "colLabels": [
                                "Fighter Level",
                                "Number of Runes"
                            ],
                            "colStyles": [
                                "col-6 text-center",
                                "col-6 text-center"
                            ],
                            "rows": [
                                [
                                    "3rd",
                                    "2"
                                ],
                                [
                                    "7th",
                                    "3"
                                ],
                                [
                                    "10th",
                                    "4"
                                ],
                                [
                                    "15th",
                                    "5"
                                ]
                            ]
                        },
                        "If a rune has a level requirement, you must be at least that level in this class to learn the rune. If a rune requires a saving throw, your Rune Magic save DC equals 8 + your proficiency bonus + your Constitution modifier."
                    ]
                },
                {
                    "name": "Additional Rune Known",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 7,
                    "entries": [
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Cloud Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Fire Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Frost Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Stone Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Hill Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Storm Rune|TCE"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Runic Shield",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 7,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Additional Rune Known",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 10,
                    "entries": [
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Cloud Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Fire Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Frost Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Stone Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Hill Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Storm Rune|TCE"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Additional Rune Known",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 15,
                    "entries": [
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Cloud Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Fire Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Frost Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Stone Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Hill Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Storm Rune|TCE"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Arcane Archer Lore",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "nature"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Arcane Shot",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "uses.per": "sr",
                        "uses.value": 2,
                        "uses.max": 2
                    }
                },
                {
                    "name": "Arcane Shot Options",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "Arcane shots are all magical effects, and each one is associated with one of the schools of magic.",
                        "If an option requires a saving throw, your Arcane Shot save DC is calculated as follows:",
                        {
                            "type": "abilityDc",
                            "name": "Arcane Shot",
                            "attributes": [
                                "int"
                            ]
                        }
                    ]
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 7,
                    "isIgnored": true
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 15,
                    "isIgnored": true
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 18,
                    "isIgnored": true
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Cavalier",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "history",
                                        "insight",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Samurai",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "history",
                                        "insight",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Elegant Courtier",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Samurai",
                    "subclassSource": "XGE",
                    "level": 7,
                    "entryData": {
                        "savingThrowProficiencies": [
                            {
                                "wis": true
                            },
                            {
                                "choose": {
                                    "from": [
                                        "int",
                                        "cha"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Draconic Disciple",
                    "source": "FTD",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Ascendant Dragon",
                    "subclassSource": "FTD",
                    "level": 3,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Elemental Disciplines",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Extra Elemental Discipline",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 6,
                    "isIgnored": true
                },
                {
                    "name": "Extra Elemental Discipline",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 11,
                    "isIgnored": true
                },
                {
                    "name": "Extra Elemental Discipline",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 17,
                    "isIgnored": true
                },
                {
                    "name": "Shadow Step",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Shadow",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "space"
                    }
                },
                {
                    "name": "Hour of Reaping",
                    "source": "SCAG",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Long Death",
                    "subclassSource": "SCAG",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Implements of Mercy",
                    "source": "TCE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Mercy",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "insight": true,
                                "medicine": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "herbalism kit": true
                            }
                        ]
                    }
                },
                {
                    "name": "Mystical Erudition",
                    "source": "TDCSR",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Cobalt Soul",
                    "subclassSource": "TDCSR",
                    "level": 6,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "investigation",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Mystical Erudition (11th Level)",
                    "source": "TDCSR",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Cobalt Soul",
                    "subclassSource": "TDCSR",
                    "level": 11,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "investigation",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Mystical Erudition (17th Level)",
                    "source": "TDCSR",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Cobalt Soul",
                    "subclassSource": "TDCSR",
                    "level": 17,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "investigation",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Drunken Master",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "performance": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "brewer's supplies": true
                            }
                        ]
                    }
                },
                {
                    "name": "Path of the Kensei",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Kensei",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "calligrapher's supplies",
                                        "painter's supplies"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Radiant Sun Bolt",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Sun Soul",
                    "subclassSource": "XGE",
                    "level": 3,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Radiant Sun Bolt",
                                "source": "XGE",
                                "page": 35,
                                "type": "R",
                                "range": "30",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "entries": [
                                    "This special attack is a ranged spell attack with a range of 30 feet. You are proficient with it, and you add your Dexterity modifier to its attack and damage rolls.",
                                    "When you take the {@action Attack} action on your turn and use this special attack as part of it, you can spend 1 ki point to make this special attack twice as a bonus action. When you gain the Extra Attack feature, this special attack can be used for any of the attacks you make as part of the {@action Attack} action."
                                ],
                                "foundrySystem": {
                                    "equipped": true,
                                    "damage.parts": [
                                        [
                                            "@scale.monk.die + @mod",
                                            "radiant"
                                        ]
                                    ],
                                    "ability": "dex"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Searing Sunburst",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Sun Soul",
                    "subclassSource": "XGE",
                    "level": 11,
                    "system": {
                        "target.value": 20,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "range.value": 150,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Sun Shield",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Sun Soul",
                    "subclassSource": "XGE",
                    "level": 17,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Control Undead",
                    "source": "DMG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Oathbreaker",
                    "subclassSource": "DMG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Dreadful Aspect",
                    "source": "DMG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Oathbreaker",
                    "subclassSource": "DMG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Nature's Wrath",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Ancients",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Turn the Faithless",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Ancients",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Sacred Weapon",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Devotion",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 40,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Turn the Unholy",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Devotion",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Holy Nimbus",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Devotion",
                    "subclassSource": "PHB",
                    "level": 20,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Abjure Enemy",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Vengeance",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Vow of Enmity",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Vengeance",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Champion Challenge",
                    "source": "SCAG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Crown",
                    "subclassSource": "SCAG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Turn the Tide",
                    "source": "SCAG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Crown",
                    "subclassSource": "SCAG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Inspiring Smite",
                    "source": "TCE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Glory",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Glorious Defense",
                    "source": "TCE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Glory",
                    "subclassSource": "TCE",
                    "level": 15,
                    "system": {
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Vigilant Rebuke",
                    "source": "TCE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Watchers",
                    "subclassSource": "TCE",
                    "level": 15,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Conquering Presence",
                    "source": "XGE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Conquest",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Rebuke the Violent",
                    "source": "XGE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Redemption",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Draconic Gift",
                    "source": "FTD",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Drakewarden",
                    "subclassSource": "FTD",
                    "level": 3,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Otherworldly Glamour",
                    "source": "TCE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Fey Wanderer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "deception",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Beguiling Twist",
                    "source": "TCE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Fey Wanderer",
                    "subclassSource": "TCE",
                    "level": 7,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Umbral Sight",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Gloom Stalker",
                    "subclassSource": "XGE",
                    "level": 3,
                    "actorTokenMod": {
                        "_": [
                            {
                                "mode": "conditionals",
                                "conditionals": [
                                    {
                                        "condition": "!PLUT_CONTEXT?.actor?.data?.token?.dimSight",
                                        "mod": {
                                            "dimSight": [
                                                {
                                                    "mode": "set",
                                                    "value": 60
                                                }
                                            ]
                                        }
                                    },
                                    {
                                        "mod": {
                                            "dimSight": [
                                                {
                                                    "mode": "scalarAdd",
                                                    "scalar": 30
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        ]
                    }
                },
                {
                    "name": "Iron Mind",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Gloom Stalker",
                    "subclassSource": "XGE",
                    "level": 7,
                    "entryData": {
                        "savingThrowProficiencies": [
                            {
                                "wis": true
                            },
                            {
                                "choose": {
                                    "from": [
                                        "int",
                                        "cha"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Hunter's Sense",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Monster Slayer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Slayer's Prey",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Monster Slayer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Magic-User's Nemesis",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Monster Slayer",
                    "subclassSource": "XGE",
                    "level": 11,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Assassin",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "disguise kit": true,
                                "poisoner's kit": true
                            }
                        ]
                    }
                },
                {
                    "name": "Wails from the Grave",
                    "source": "TCE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Phantom",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Psionic Power",
                    "source": "TCE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Soulknife",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "resources": [
                            {
                                "name": "Psionic Energy Die",
                                "type": "dicePool",
                                "recharge": "restLong",
                                "count": "2 * PB",
                                "number": 1,
                                "faces": "(6 + (ceil((<$level$> + 2) / 6) - 1) * 2)"
                            }
                        ]
                    }
                },
                {
                    "name": "Master of Intrigue",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Mastermind",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "disguise kit": true,
                                "forgery kit": true,
                                "gaming set": true
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Master of Tactics",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Mastermind",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Survivalist",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Scout",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "expertise": [
                            {
                                "nature": true,
                                "survival": true
                            }
                        ]
                    }
                },
                {
                    "name": "Superior Mobility",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Scout",
                    "subclassSource": "XGE",
                    "level": 9,
                    "effects": [
                        {
                            "name": "Superior Mobility",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ 10"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Draconic Resilience",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 1,
                    "effects": [
                        {
                            "name": "Natural Armor",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.ac.calc",
                                    "mode": "OVERRIDE",
                                    "value": "draconic"
                                }
                            ]
                        },
                        {
                            "name": "HP Increase",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.hp.max",
                                    "mode": "ADD",
                                    "value": "+ @classes.sorcerer.levels"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Dragon Ancestor",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "draconic": true
                            }
                        ]
                    }
                },
                {
                    "name": "Dragon Wings",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 14,
                    "effects": [
                        {
                            "name": "Flying Speed",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.fly",
                                    "mode": "UPGRADE",
                                    "value": "@attributes.movement.walk"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Draconic Presence",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 18,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Telepathic Speech",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Aberrant Mind",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Warping Implosion",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Aberrant Mind",
                    "subclassSource": "TCE",
                    "level": 18,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Restore Balance",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Clockwork Soul",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bastion of Law",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Clockwork Soul",
                    "subclassSource": "TCE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Clockwork Cavalcade",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Clockwork Soul",
                    "subclassSource": "TCE",
                    "level": 18,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "cube"
                    }
                },
                {
                    "name": "Hound of Ill Omen",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Shadow",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Shadow Walk",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Shadow",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Wind Speaker",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Storm",
                    "subclassSource": "XGE",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "primordial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Heart of the Storm",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Storm",
                    "subclassSource": "XGE",
                    "level": 6,
                    "entryData": {
                        "resist": [
                            "lightning",
                            "thunder"
                        ]
                    },
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Wind Soul",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Storm",
                    "subclassSource": "XGE",
                    "level": 18,
                    "entryData": {
                        "immune": [
                            "lightning",
                            "thunder"
                        ]
                    }
                },
                {
                    "name": "Fey Presence",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 1,
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "cube"
                    }
                },
                {
                    "name": "Misty Escape",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Beguiling Defenses",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "conditionImmune": [
                            "charmed"
                        ]
                    }
                },
                {
                    "name": "Dark Delirium",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Awakened Mind",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Great Old One",
                    "subclassSource": "PHB",
                    "level": 1,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Thought Shield",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Great Old One",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "psychic"
                        ]
                    }
                },
                {
                    "name": "Gift of the Sea",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 1,
                    "effects": [
                        {
                            "name": "Gift of the Sea",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.swim",
                                    "mode": "UPGRADE",
                                    "value": "40"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Tentacle of the Deeps",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Oceanic Soul",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 6,
                    "entryData": {
                        "resist": [
                            "cold"
                        ]
                    }
                },
                {
                    "name": "Fathomless Plunge",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "radius",
                        "range.value": 1,
                        "range.units": "mi"
                    }
                },
                {
                    "name": "Sanctuary Vessel",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Genie",
                    "subclassSource": "TCE",
                    "level": 10,
                    "system": {
                        "target.value": 5,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Necrotic Husk",
                    "source": "VRGR",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Undead",
                    "subclassSource": "VRGR",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "necrotic"
                        ]
                    },
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Radiant Soul",
                    "source": "XGE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Celestial",
                    "subclassSource": "XGE",
                    "level": 6,
                    "entryData": {
                        "resist": [
                            "radiant"
                        ]
                    }
                },
                {
                    "name": "Searing Vengeance",
                    "source": "XGE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Celestial",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Hex Warrior",
                    "source": "XGE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Hexblade",
                    "subclassSource": "XGE",
                    "level": 1,
                    "entryData": {
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ],
                        "armorProficiencies": [
                            {
                                "shield|phb": true,
                                "medium": true
                            }
                        ]
                    }
                },
                {
                    "name": "Chronal Shift",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 2,
                    "system": {
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Temporal Awareness",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 2,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.init.total",
                                    "mode": "ADD",
                                    "value": "+ @abilities.int.mod"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Momentary Stasis",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 6,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Convergent Future",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 14,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Adjust Density",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Graviturgy",
                    "subclassSource": "EGW",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Violent Attraction",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Graviturgy",
                    "subclassSource": "EGW",
                    "level": 10,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Event Horizon",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Graviturgy",
                    "subclassSource": "EGW",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Arcane Ward",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Abjuration",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "activation.type": "special",
                        "activation.cost": null,
                        "uses.per": null,
                        "uses.max": "2 * @classes.wizard.levels + floor((@abilities.int.value - 10) / 2)"
                    }
                },
                {
                    "name": "Projected Ward",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Abjuration",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Benign Transposition",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Conjuration",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Hypnotic Gaze",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Enchantment",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 5,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Instinctive Charm",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Enchantment",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Inured to Undeath",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Necromancy",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "necrotic"
                        ]
                    }
                },
                {
                    "name": "Command Undead",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Necromancy",
                    "subclassSource": "PHB",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Training in War and Song (Bladesinging)",
                    "source": "TCE",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Bladesinging",
                    "subclassSource": "TCE",
                    "level": 2,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "performance": true
                            }
                        ],
                        "armorProficiencies": [
                            {
                                "light": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "choose": {
                                    "fromFilter": "type=melee weapon|property=!two-handed|rarity=none"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Deflecting Shroud",
                    "source": "XGE",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "War",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 3,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Tiger",
                    "source": "SCAG",
                    "className": "Barbarian",
                    "classSource": "SCAG",
                    "subclassShortName": "Totem Warrior",
                    "subclassSource": "PHB",
                    "level": 6,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "athletics",
                                        "acrobatics",
                                        "stealth",
                                        "survival"
                                    ],
                                    "count": 2
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Tool Proficiency",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Alchemist",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "alchemist's supplies": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Chemical Mastery",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Alchemist",
                    "subclassSource": "TCE",
                    "level": 15,
                    "entryData": {
                        "resist": [
                            "acid",
                            "poison"
                        ],
                        "conditionImmune": [
                            "poisoned"
                        ]
                    }
                },
                {
                    "name": "Armor Model",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "uses.value": null,
                        "uses.max": null,
                        "uses.per": null
                    }
                },
                {
                    "name": "Defensive Field",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "actionType": "heal",
                        "damage.parts": [
                            [
                                "@classes.artificer.levels",
                                "temphp"
                            ]
                        ]
                    }
                },
                {
                    "name": "Lightning Launcher",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Lightning Launcher",
                                "source": "TCE",
                                "page": 15,
                                "srd": true,
                                "type": "R",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "dmg1": "1d6",
                                "dmgType": "L",
                                "range": "90/300",
                                "entries": [
                                    "This weapon is part of the Infiltrator armor model. When you attack with that weapon, you can add your Intelligence modifier, instead of Strength or Dexterity, to the attack and damage rolls.",
                                    "Once on each of your turns when you hit a creature with the launcher, you can deal an extra {@damage 1d6} lightning damage to that target."
                                ],
                                "foundrySystem": {
                                    "ability": "int"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Powered Steps",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "effects": [
                        {
                            "name": "Powered Steps",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ 5"
                                }
                            ],
                            "disabled": true
                        }
                    ]
                },
                {
                    "name": "Thunder Gauntlets",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Thunder Gauntlets",
                                "source": "TCE",
                                "page": 15,
                                "srd": true,
                                "type": "M",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "dmg1": "1d8",
                                "dmgType": "T",
                                "entries": [
                                    "This weapon is part of the Guardian armor model. When you attack with that weapon, you can add your Intelligence modifier, instead of Strength or Dexterity, to the attack and damage rolls.",
                                    "A creature hit by the gauntlet has disadvantage on attack rolls against targets other than you until the start of your next turn, as the armor magically emits a distracting pulse when the creature attacks someone else."
                                ],
                                "foundrySystem": {
                                    "ability": "int"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Tools of the Trade",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Eldritch Cannon",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Artillerist",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "damage.parts": [
                            [
                                "2d8",
                                "fire"
                            ],
                            [
                                "2d8",
                                "force"
                            ]
                        ],
                        "formula": "1d8 + @abilities.int.mod"
                    }
                },
                {
                    "name": "Tool Proficiency",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Artillerist",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "woodcarver's tools": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Arcane Firearm",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Artillerist",
                    "subclassSource": "TCE",
                    "level": 5,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.bonuses.msak.damage",
                                    "mode": "ADD",
                                    "value": "+ 1d8"
                                },
                                {
                                    "key": "data.bonuses.rsak.damage",
                                    "mode": "ADD",
                                    "value": "+ 1d8"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Battle Ready",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Battle Smith",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Tool Proficiency",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Battle Smith",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                }
            ]
        }
        `;
        let parsed = JSON.parse(_foundry);
        return parsed;
    }
    static getClasses(){
        return ContentGetter._getBase().class;
    }
    static getSubclasses(){
        return ContentGetter._getBase().subclass;
    }
    static getRaces(filter=true){
        if(filter){return ContentGetter.getRaces(false).filter(f => !!f && !!f.name);}
        return ContentGetter._getBase().race;
    }
    static getSubraces(filter=true){
        if(filter){return ContentGetter.getSubraces(false).filter(f => !!f && !!f.name);}
        return ContentGetter._getBase().subrace;
    }
    static getFeaturesFromClass(cls){
        return this._getBase().classFeature.filter(f => f.className == cls.name && f.classSource == cls.source);
    }
    static getFeaturesFromSubclass(sc){
        return this._getBase().subclassFeature.filter(f =>
            f.className == sc.className &&
            f.classSource == sc.classSource &&
            f.subclassSource == sc.source &&
            f.subclassShortName == sc.shortName);
    }
    static getClassByNameAndSource(name, source){
        return ContentGetter.getClasses().filter(cls => cls.name == name && cls.source == source);
    }
    static getClassFeatureByUID(featureUID){
        const unpacked = MyDataUtil.unpackUidClassFeature(featureUID);
        const foundClasses = this.getClassByNameAndSource(unpacked.className, unpacked.classSource);
        if(foundClasses.length<1){console.error("Did not find any classes with name and source ", unpacked.className, unpacked.classSource);}
        if(foundClasses.length>1){console.error("Found too many classes with name and source ", unpacked.className, unpacked.classSource);}
        const cls = foundClasses[0];
        const allFeatures = ContentGetter.getFeaturesFromClass(cls);
        return allFeatures.filter(f => f.name == unpacked.name && f.level == unpacked.level)[0];
    }
    _cookData(){
        //Prep class feature info
        const isIgnoredLookup = {
            "elemental disciplines|monk||four elements||3":true,
            "fighting style|bard||swords|xge|3":true,
            "infusions known|artificer|tce|2":true,
            "maneuver options|fighter||battle master||3|tce":true,
            "maneuvers|fighter||battle master||3":true
        };
        const opts = {actor: this._actor, isIgnoredLookup: isIgnoredLookup};
        for(let j = 0; j < this._data.class.length; ++j)
        {
            let cls = this._data.class[j];
            //Make sure the classFeatures aren't just strings, look like this:
            //{classFeature: "string"}
            for(let i = 0; i < cls.classFeatures.length; ++i){
            let f = cls.classFeatures[i];
            if (typeof f !== "object") {cls.classFeatures[i] = {classFeature: f};}
            }
    
            //Now we need to flesh out some more data about the class features, using just the UID we can get a lot of such info.
            await (cls.classFeatures || []).pSerialAwaitMap(cf => MyDataUtil.pInitClassFeatureLoadeds({...opts, classFeature: cf, className: cls.name}));
    
            if (cls.classFeatures) {cls.classFeatures = cls.classFeatures.filter(it => !it.isIgnored);}
            this._data.class[j] = cls;
    
            /* for (const sc of cls.subclasses || []) {
            await (sc.subclassFeatures || []).pSerialAwaitMap(scf => this.pInitSubclassFeatureLoadeds({...opts, subclassFeature: scf, className: cls.name, subclassName: sc.name}));
    
            if (sc.subclassFeatures) sc.subclassFeatures = sc.subclassFeatures.filter(it => !it.isIgnored);
        } */
        }
    }
    /**Sligtly parses the class features a bit to prepare them with loadeds, a property needed to convert them to option sets later. */
    static async cookClassFeatures(cls){
        const isIgnoredLookup = {
            "elemental disciplines|monk||four elements||3":true,
            "fighting style|bard||swords|xge|3":true,
            "infusions known|artificer|tce|2":true,
            "maneuver options|fighter||battle master||3|tce":true,
            "maneuvers|fighter||battle master||3":true
        };
        const opts = {isIgnoredLookup: isIgnoredLookup};

        //We just need the UID of the classFeatures stored directly in the class
        for(let i = 0; i < cls.classFeatures.length; ++i){
            let f = cls.classFeatures[i];
            if (typeof f !== "object") {cls.classFeatures[i] = {classFeature: f};}
        }
    
        //Now we need to flesh out some more data about the class features, using just the UID we can get a lot of such info.
        await (cls.classFeatures || []).pSerialAwaitMap(cf => MyDataUtil.pInitClassFeatureLoadeds({...opts, classFeature: cf, className: cls.name}));

        if (cls.classFeatures) {cls.classFeatures = cls.classFeatures.filter(it => !it.isIgnored);}

        return cls.classFeatures;
    }
}
//#endregion

//#region UtilPrePreInit
class UtilPrePreInit {
    static _IS_GM = null;

    static isGM() {
        return true;
        //return UtilPrePreInit._IS_GM = UtilPrePreInit._IS_GM ?? game.data.users.find(it=>it._id === game.userId).role >= CONST.USER_ROLES.ASSISTANT;
    }
}
//#endregion

//#region ContextUtil
globalThis.ContextUtil = {
    _isInit: false,
    _menus: [],

    _init() {
        if (ContextUtil._isInit)
            return;
        ContextUtil._isInit = true;

        document.body.addEventListener("click", ()=>ContextUtil.closeAllMenus());
    },

    getMenu(actions) {
        ContextUtil._init();

        const menu = new ContextUtil.Menu(actions);
        ContextUtil._menus.push(menu);
        return menu;
    },

    deleteMenu(menu) {
        if (!menu)
            return;

        menu.remove();
        const ix = ContextUtil._menus.findIndex(it=>it === menu);
        if (~ix)
            ContextUtil._menus.splice(ix, 1);
    },

    pOpenMenu(evt, menu, {userData=null}={}) {
        evt.preventDefault();
        evt.stopPropagation();

        ContextUtil._init();

        ContextUtil._menus.filter(it=>it !== menu).forEach(it=>it.close());

        return menu.pOpen(evt, {
            userData
        });
    },

    closeAllMenus() {
        ContextUtil._menus.forEach(menu=>menu.close());
    },

    Menu: class {
        constructor(actions) {
            this._actions = actions;
            this._pResult = null;
            this.resolveResult_ = null;

            this.userData = null;

            this._$ele = null;
            this._metasActions = [];

            this._menusSub = [];
        }

        remove() {
            if (!this._$ele)
                return;
            this._$ele.remove();
            this._$ele = null;
        }

        width() {
            return this._$ele ? this._$ele.width() : undefined;
        }
        height() {
            return this._$ele ? this._$ele.height() : undefined;
        }

        pOpen(evt, {userData=null, offsetY=null, boundsX=null}={}) {
            evt.stopPropagation();
            evt.preventDefault();

            this._initLazy();

            if (this.resolveResult_)
                this.resolveResult_(null);
            this._pResult = new Promise(resolve=>{
                this.resolveResult_ = resolve;
            }
            );
            this.userData = userData;

            this._$ele.css({
                left: 0,
                top: 0,
                opacity: 0,
                pointerEvents: "none",
            }).showVe().css({
                left: this._getMenuPosition(evt, "x", {
                    bounds: boundsX
                }),
                top: this._getMenuPosition(evt, "y", {
                    offset: offsetY
                }),
                opacity: "",
                pointerEvents: "",
            });

            this._metasActions[0].$eleRow.focus();

            return this._pResult;
        }

        close() {
            if (!this._$ele)
                return;
            this._$ele.hideVe();

            this.closeSubMenus();
        }

        isOpen() {
            if (!this._$ele)
                return false;
            return !this._$ele.hasClass("ve-hidden");
        }

        _initLazy() {
            if (this._$ele) {
                this._metasActions.forEach(meta=>meta.action.update());
                return;
            }

            const $elesAction = this._actions.map(it=>{
                if (it == null)
                    return $(`<div class="my-1 w-100 ui-ctx__divider"></div>`);

                const rdMeta = it.render({
                    menu: this
                });
                this._metasActions.push(rdMeta);
                return rdMeta.$eleRow;
            }
            );

            this._$ele = $$`<div class="ve-flex-col ui-ctx__wrp py-2 absolute">${$elesAction}</div>`.hideVe().appendTo(document.body);
        }

        _getMenuPosition(evt, axis, {bounds=null, offset=null}={}) {
            const {fnMenuSize, fnGetEventPos, fnWindowSize, fnScrollDir} = axis === "x" ? {
                fnMenuSize: "width",
                fnGetEventPos: "getClientX",
                fnWindowSize: "width",
                fnScrollDir: "scrollLeft"
            } : {
                fnMenuSize: "height",
                fnGetEventPos: "getClientY",
                fnWindowSize: "height",
                fnScrollDir: "scrollTop"
            };

            const posMouse = EventUtil[fnGetEventPos](evt);
            const szWin = $(window)[fnWindowSize]();
            const posScroll = $(window)[fnScrollDir]();
            let position = posMouse + posScroll;

            if (offset)
                position += offset;

            const szMenu = this[fnMenuSize]();

            if (bounds != null) {
                const {trailingLower, leadingUpper} = bounds;

                const posTrailing = position;
                const posLeading = position + szMenu;

                if (posTrailing < trailingLower) {
                    position += trailingLower - posTrailing;
                } else if (posLeading > leadingUpper) {
                    position -= posLeading - leadingUpper;
                }
            }

            if (position + szMenu > szWin && szMenu < position)
                position -= szMenu;

            return position;
        }

        addSubMenu(menu) {
            this._menusSub.push(menu);
        }

        closeSubMenus(menuSubExclude=null) {
            this._menusSub.filter(menuSub=>menuSubExclude == null || menuSub !== menuSubExclude).forEach(menuSub=>menuSub.close());
        }
    }
    ,

    Action: function(text, fnAction, opts) {
        opts = opts || {};

        this.text = text;
        this.fnAction = fnAction;

        this.isDisabled = opts.isDisabled;
        this.title = opts.title;
        this.style = opts.style;

        this.fnActionAlt = opts.fnActionAlt;
        this.textAlt = opts.textAlt;
        this.titleAlt = opts.titleAlt;

        this.render = function({menu}) {
            const $btnAction = this._render_$btnAction({
                menu
            });
            const $btnActionAlt = this._render_$btnActionAlt({
                menu
            });

            return {
                action: this,
                $eleRow: $$`<div class="ui-ctx__row ve-flex-v-center ${this.style || ""}">${$btnAction}${$btnActionAlt}</div>`,
                $eleBtn: $btnAction,
            };
        }
        ;

        this._render_$btnAction = function({menu}) {
            const $btnAction = $(`<div class="w-100 min-w-0 ui-ctx__btn py-1 pl-5 ${this.fnActionAlt ? "" : "pr-5"}" ${this.isDisabled ? "disabled" : ""} tabindex="0">${this.text}</div>`).on("click", async evt=>{
                if (this.isDisabled)
                    return;

                evt.preventDefault();
                evt.stopPropagation();

                menu.close();

                const result = await this.fnAction(evt, {
                    userData: menu.userData
                });
                if (menu.resolveResult_)
                    menu.resolveResult_(result);
            }
            ).keydown(evt=>{
                if (evt.key !== "Enter")
                    return;
                $btnAction.click();
            }
            );
            if (this.title)
                $btnAction.title(this.title);

            return $btnAction;
        }
        ;

        this._render_$btnActionAlt = function({menu}) {
            if (!this.fnActionAlt)
                return null;

            const $btnActionAlt = $(`<div class="ui-ctx__btn ml-1 bl-1 py-1 px-4" ${this.isDisabled ? "disabled" : ""}>${this.textAlt ?? `<span class="glyphicon glyphicon-cog"></span>`}</div>`).on("click", async evt=>{
                if (this.isDisabled)
                    return;

                evt.preventDefault();
                evt.stopPropagation();

                menu.close();

                const result = await this.fnActionAlt(evt, {
                    userData: menu.userData
                });
                if (menu.resolveResult_)
                    menu.resolveResult_(result);
            }
            );
            if (this.titleAlt)
                $btnActionAlt.title(this.titleAlt);

            return $btnActionAlt;
        }
        ;

        this.update = function() {}
        ;
    },

    ActionLink: function(text, fnHref, opts) {
        ContextUtil.Action.call(this, text, null, opts);

        this.fnHref = fnHref;
        this._$btnAction = null;

        this._render_$btnAction = function() {
            this._$btnAction = $(`<a href="${this.fnHref()}" class="w-100 min-w-0 ui-ctx__btn py-1 pl-5 ${this.fnActionAlt ? "" : "pr-5"}" ${this.isDisabled ? "disabled" : ""} tabindex="0">${this.text}</a>`);
            if (this.title)
                this._$btnAction.title(this.title);

            return this._$btnAction;
        }
        ;

        this.update = function() {
            this._$btnAction.attr("href", this.fnHref());
        }
        ;
    },

    ActionSelect: function({values, fnOnChange=null, fnGetDisplayValue=null, }, ) {
        this._values = values;
        this._fnOnChange = fnOnChange;
        this._fnGetDisplayValue = fnGetDisplayValue;

        this._sel = null;

        this._ixInitial = null;

        this.render = function({menu}) {
            this._sel = this._render_sel({
                menu
            });

            if (this._ixInitial != null) {
                this._sel.val(`${this._ixInitial}`);
                this._ixInitial = null;
            }

            return {
                action: this,
                $eleRow: $$`<div class="ui-ctx__row ve-flex-v-center">${this._sel}</div>`,
            };
        }
        ;

        this._render_sel = function({menu}) {
            const sel = e_({
                tag: "select",
                clazz: "w-100 min-w-0 mx-5 py-1",
                tabindex: 0,
                children: this._values.map((val,i)=>{
                    return e_({
                        tag: "option",
                        value: i,
                        text: this._fnGetDisplayValue ? this._fnGetDisplayValue(val) : val,
                    });
                }
                ),
                click: async evt=>{
                    evt.preventDefault();
                    evt.stopPropagation();
                }
                ,
                keydown: evt=>{
                    if (evt.key !== "Enter")
                        return;
                    sel.click();
                }
                ,
                change: ()=>{
                    menu.close();

                    const ix = Number(sel.val() || 0);
                    const val = this._values[ix];

                    if (this._fnOnChange)
                        this._fnOnChange(val);
                    if (menu.resolveResult_)
                        menu.resolveResult_(val);
                }
                ,
            });

            return sel;
        }
        ;

        this.setValue = function(val) {
            const ix = this._values.indexOf(val);
            if (!this._sel)
                return this._ixInitial = ix;
            this._sel.val(`${ix}`);
        }
        ;

        this.update = function() {}
        ;
    },

    ActionSubMenu: class {
        constructor(name, actions) {
            this._name = name;
            this._actions = actions;
        }

        render({menu}) {
            const menuSub = ContextUtil.getMenu(this._actions);
            menu.addSubMenu(menuSub);

            const $eleRow = $$`<div class="ui-ctx__btn py-1 px-5 split-v-center">
				<div>${this._name}</div>
				<div class="pl-4"><span class="caret caret--right"></span></div>
			</div>`.on("click", async evt=>{
                evt.stopPropagation();
                if (menuSub.isOpen())
                    return menuSub.close();

                menu.closeSubMenus(menuSub);

                const bcr = $eleRow[0].getBoundingClientRect();

                await menuSub.pOpen(evt, {
                    offsetY: bcr.top - EventUtil.getClientY(evt),
                    boundsX: {
                        trailingLower: bcr.right,
                        leadingUpper: bcr.left,
                    },
                }, );

                menu.close();
            }
            );

            return {
                action: this,
                $eleRow,
            };
        }

        update() {}
    }
    ,
};
//#endregion
//#region StrUtil
globalThis.StrUtil = {
    COMMAS_NOT_IN_PARENTHESES_REGEX: /,\s?(?![^(]*\))/g,
    COMMA_SPACE_NOT_IN_PARENTHESES_REGEX: /, (?![^(]*\))/g,

    uppercaseFirst: function(string) {
        return string.uppercaseFirst();
    },
    TITLE_LOWER_WORDS: ["a", "an", "the", "and", "but", "or", "for", "nor", "as", "at", "by", "for", "from", "in", "into", "near", "of", "on", "onto", "to", "with", "over", "von"],
    TITLE_UPPER_WORDS: ["Id", "Tv", "Dm", "Ok", "Npc", "Pc", "Tpk", "Wip", "Dc"],
    TITLE_UPPER_WORDS_PLURAL: ["Ids", "Tvs", "Dms", "Oks", "Npcs", "Pcs", "Tpks", "Wips", "Dcs"],
    IRREGULAR_PLURAL_WORDS: {
        "cactus": "cacti",
        "child": "children",
        "die": "dice",
        "djinni": "djinn",
        "dwarf": "dwarves",
        "efreeti": "efreet",
        "elf": "elves",
        "fey": "fey",
        "foot": "feet",
        "goose": "geese",
        "ki": "ki",
        "man": "men",
        "mouse": "mice",
        "ox": "oxen",
        "person": "people",
        "sheep": "sheep",
        "slaad": "slaadi",
        "tooth": "teeth",
        "undead": "undead",
        "woman": "women",
    },

    padNumber: (n,len,padder)=>{
        return String(n).padStart(len, padder);
    }
    ,

    elipsisTruncate(str, atLeastPre=5, atLeastSuff=0, maxLen=20) {
        if (maxLen >= str.length)
            return str;

        maxLen = Math.max(atLeastPre + atLeastSuff + 3, maxLen);
        let out = "";
        let remain = maxLen - (3 + atLeastPre + atLeastSuff);
        for (let i = 0; i < str.length - atLeastSuff; ++i) {
            const c = str[i];
            if (i < atLeastPre)
                out += c;
            else if ((remain--) > 0)
                out += c;
        }
        if (remain < 0)
            out += "...";
        out += str.substring(str.length - atLeastSuff, str.length);
        return out;
    },

    toTitleCase(str) {
        return str.toTitleCase();
    },
    qq(str) {
        return (str = str || "").qq();
    },
};
//#endregion
//#region CleanUtil
globalThis.CleanUtil = {
    getCleanJson(data, {isMinify=false, isFast=true}={}) {
        data = MiscUtil.copy(data);
        data = MiscUtil.getWalker().walk(data, {
            string: (str)=>CleanUtil.getCleanString(str, {
                isFast
            })
        });
        let str = isMinify ? JSON.stringify(data) : `${JSON.stringify(data, null, "\t")}\n`;
        return str.replace(CleanUtil.STR_REPLACEMENTS_REGEX, (match)=>CleanUtil.STR_REPLACEMENTS[match]);
    },

    getCleanString(str, {isFast=true}={}) {
        str = str.replace(CleanUtil.SHARED_REPLACEMENTS_REGEX, (match)=>CleanUtil.SHARED_REPLACEMENTS[match]).replace(CleanUtil._SOFT_HYPHEN_REMOVE_REGEX, "");

        if (isFast)
            return str;

        const ptrStack = {
            _: ""
        };
        CleanUtil._getCleanString_walkerStringHandler(ptrStack, 0, str);
        return ptrStack._;
    },

    _getCleanString_walkerStringHandler(ptrStack, tagCount, str) {
        const tagSplit = Renderer.splitByTags(str);
        const len = tagSplit.length;
        for (let i = 0; i < len; ++i) {
            const s = tagSplit[i];
            if (!s)
                continue;
            if (s.startsWith("{@")) {
                const [tag,text] = Renderer.splitFirstSpace(s.slice(1, -1));

                ptrStack._ += `{${tag}${text.length ? " " : ""}`;
                this._getCleanString_walkerStringHandler(ptrStack, tagCount + 1, text);
                ptrStack._ += `}`;
            } else {
                if (tagCount) {
                    ptrStack._ += s;
                } else {
                    ptrStack._ += s.replace(CleanUtil._DASH_COLLAPSE_REGEX, "$1").replace(CleanUtil._ELLIPSIS_COLLAPSE_REGEX, "$1");
                }
            }
        }
    },
};
CleanUtil.SHARED_REPLACEMENTS = {
    "’": "'",
    "‘": "'",
    "": "'",
    "…": "...",
    "\u200B": "",
    "\u2002": " ",
    "ﬀ": "ff",
    "ﬃ": "ffi",
    "ﬄ": "ffl",
    "ﬁ": "fi",
    "ﬂ": "fl",
    "Ĳ": "IJ",
    "ĳ": "ij",
    "Ǉ": "LJ",
    "ǈ": "Lj",
    "ǉ": "lj",
    "Ǌ": "NJ",
    "ǋ": "Nj",
    "ǌ": "nj",
    "ﬅ": "ft",
    "“": `"`,
    "”": `"`,
    "\u201a": ",",
};
CleanUtil.STR_REPLACEMENTS = {
    "—": "\\u2014",
    "–": "\\u2013",
    "‑": "\\u2011",
    "−": "\\u2212",
    " ": "\\u00A0",
    " ": "\\u2007",
};
CleanUtil.SHARED_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.SHARED_REPLACEMENTS).join("|"),"g");
CleanUtil.STR_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.STR_REPLACEMENTS).join("|"),"g");
CleanUtil._SOFT_HYPHEN_REMOVE_REGEX = /\u00AD *\r?\n?\r?/g;
CleanUtil._ELLIPSIS_COLLAPSE_REGEX = /\s*(\.\s*\.\s*\.)/g;
CleanUtil._DASH_COLLAPSE_REGEX = /[ ]*([\u2014\u2013])[ ]*/g;

//#endregion

//#region ExcludeUtil
globalThis.ExcludeUtil = {
    isInitialised: false,
    _excludes: null,
    _cache_excludesLookup: null,
    _lock: null,

    async pInitialise({lockToken=null}={}) {
        try {
            await ExcludeUtil._lock.pLock({
                token: lockToken
            });
            await ExcludeUtil._pInitialise();
        } finally {
            ExcludeUtil._lock.unlock();
        }
    },

    async _pInitialise() {
        if (ExcludeUtil.isInitialised)
            return;

        ExcludeUtil.pSave = MiscUtil.throttle(ExcludeUtil._pSave, 50);
        try {
            ExcludeUtil._excludes = await StorageUtil.pGet(VeCt.STORAGE_EXCLUDES) || [];
            ExcludeUtil._excludes = ExcludeUtil._excludes.filter(it=>it.hash);
        } catch (e) {
            JqueryUtil.doToast({
                content: "Error when loading content blocklist! Purged blocklist data. (See the log for more information.)",
                type: "danger",
            });
            try {
                await StorageUtil.pRemove(VeCt.STORAGE_EXCLUDES);
            } catch (e) {
                setTimeout(()=>{
                    throw e;
                }
                );
            }
            ExcludeUtil._excludes = null;
            window.location.hash = "";
            setTimeout(()=>{
                throw e;
            }
            );
        }
        ExcludeUtil.isInitialised = true;
    },

    getList() {
        return MiscUtil.copyFast(ExcludeUtil._excludes || []);
    },

    async pSetList(toSet) {
        ExcludeUtil._excludes = toSet;
        ExcludeUtil._cache_excludesLookup = null;
        await ExcludeUtil.pSave();
    },

    async pExtendList(toAdd) {
        try {
            const lockToken = await ExcludeUtil._lock.pLock();
            await ExcludeUtil._pExtendList({
                toAdd,
                lockToken
            });
        } finally {
            ExcludeUtil._lock.unlock();
        }
    },

    async _pExtendList({toAdd, lockToken}) {
        await ExcludeUtil.pInitialise({
            lockToken
        });
        this._doBuildCache();

        const out = MiscUtil.copyFast(ExcludeUtil._excludes || []);
        MiscUtil.copyFast(toAdd || []).filter(({hash, category, source})=>{
            if (!hash || !category || !source)
                return false;
            const cacheUid = ExcludeUtil._getCacheUids(hash, category, source, true);
            return !ExcludeUtil._cache_excludesLookup[cacheUid];
        }
        ).forEach(it=>out.push(it));

        await ExcludeUtil.pSetList(out);
    },

    _doBuildCache() {
        if (ExcludeUtil._cache_excludesLookup)
            return;
        if (!ExcludeUtil._excludes)
            return;

        ExcludeUtil._cache_excludesLookup = {};
        ExcludeUtil._excludes.forEach(({source, category, hash})=>{
            const cacheUid = ExcludeUtil._getCacheUids(hash, category, source, true);
            ExcludeUtil._cache_excludesLookup[cacheUid] = true;
        }
        );
    },

    _getCacheUids(hash, category, source, isExact) {
        hash = (hash || "").toLowerCase();
        category = (category || "").toLowerCase();
        source = (source?.source || source || "").toLowerCase();

        const exact = `${hash}__${category}__${source}`;
        if (isExact)
            return [exact];

        return [`${hash}__${category}__${source}`, `*__${category}__${source}`, `${hash}__*__${source}`, `${hash}__${category}__*`, `*__*__${source}`, `*__${category}__*`, `${hash}__*__*`, `*__*__*`, ];
    },

    _excludeCount: 0,
    isExcluded(hash, category, source, opts) {
        if (!ExcludeUtil._excludes || !ExcludeUtil._excludes.length)
            return false;
        if (!source)
            throw new Error(`Entity had no source!`);
        opts = opts || {};

        this._doBuildCache();

        hash = (hash || "").toLowerCase();
        category = (category || "").toLowerCase();
        source = (source.source || source || "").toLowerCase();

        const isExcluded = ExcludeUtil._isExcluded(hash, category, source);
        if (!isExcluded)
            return isExcluded;

        if (!opts.isNoCount)
            ++ExcludeUtil._excludeCount;

        return isExcluded;
    },

    _isExcluded(hash, category, source) {
        for (const cacheUid of ExcludeUtil._getCacheUids(hash, category, source)) {
            if (ExcludeUtil._cache_excludesLookup[cacheUid])
                return true;
        }
        return false;
    },

    isAllContentExcluded(list) {
        return (!list.length && ExcludeUtil._excludeCount) || (list.length > 0 && list.length === ExcludeUtil._excludeCount);
    },
    getAllContentBlocklistedHtml() {
        return `<div class="initial-message">(All content <a href="blocklist.html">blocklisted</a>)</div>`;
    },

    async _pSave() {
        return StorageUtil.pSet(VeCt.STORAGE_EXCLUDES, ExcludeUtil._excludes);
    },

    async pSave() {},
};
//#endregion


//#region Jquery Extensions
globalThis.JqueryUtil = {
    _isEnhancementsInit: false,
    initEnhancements() {
        if (JqueryUtil._isEnhancementsInit)
            return;
        JqueryUtil._isEnhancementsInit = true;

        JqueryUtil.addSelectors();

        window.$$ = function(parts, ...args) {
            if (parts instanceof jQuery || parts instanceof HTMLElement) {
                return (...passed)=>{
                    const parts2 = [...passed[0]];
                    const args2 = passed.slice(1);
                    parts2[0] = `<div>${parts2[0]}`;
                    parts2.last(`${parts2.last()}</div>`);

                    const $temp = $$(parts2, ...args2);
                    $temp.children().each((i,e)=>$(e).appendTo(parts));
                    return parts;
                }
                ;
            } else {
                const $eles = [];
                let ixArg = 0;

                const handleArg = (arg)=>{
                    if (arg instanceof $) {
                        $eles.push(arg);
                        return `<${arg.tag()} data-r="true"></${arg.tag()}>`;
                    } else if (arg instanceof HTMLElement) {
                        return handleArg($(arg));
                    } else
                        return arg;
                }
                ;
                const raw = parts.reduce((html,p)=>{
                    const myIxArg = ixArg++;
                    if (args[myIxArg] == null)
                        return `${html}${p}`;
                    if (args[myIxArg]instanceof Array)
                        return `${html}${args[myIxArg].map(arg=>handleArg(arg)).join("")}${p}`;
                    else
                        return `${html}${handleArg(args[myIxArg])}${p}`;
                }
                );
                const $res = $(raw);

                if ($res.length === 1) {
                    if ($res.attr("data-r") === "true")
                        return $eles[0];
                    else
                        $res.find(`[data-r=true]`).replaceWith(i=>$eles[i]);
                } else {
                    const $tmp = $(`<div></div>`);
                    $tmp.append($res);
                    $tmp.find(`[data-r=true]`).replaceWith(i=>$eles[i]);
                    return $tmp.children();
                }

                return $res;
            }
        }
        ;

        $.fn.extend({
            disableSpellcheck: function() {
                return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");
            },
            tag: function() {
                return this.prop("tagName").toLowerCase();
            },
            title: function(...args) {
                return this.attr("title", ...args);
            },
            placeholder: function(...args) {
                return this.attr("placeholder", ...args);
            },
            disable: function() {
                return this.attr("disabled", true);
            },

            fastSetHtml: function(html) {
                if (!this.length)
                    return this;
                let tgt = this[0];
                while (tgt.children.length) {
                    tgt = tgt.children[0];
                }
                tgt.innerHTML = html;
                return this;
            },

            blurOnEsc: function() {
                return this.keydown(evt=>{
                    if (evt.which === 27)
                        this.blur();
                }
                );
            },

            hideVe: function() {
                return this.addClass("ve-hidden");
            },
            showVe: function() {
                return this.removeClass("ve-hidden");
            },
            toggleVe: function(val) {
                if (val === undefined)
                    return this.toggleClass("ve-hidden", !this.hasClass("ve-hidden"));
                else
                    return this.toggleClass("ve-hidden", !val);
            },
        });

        $.event.special.destroyed = {
            remove: function(o) {
                if (o.handler)
                    o.handler();
            },
        };
    },

    addSelectors() {
        $.expr[":"].textEquals = (el,i,m)=>$(el).text().toLowerCase().trim() === m[3].unescapeQuotes();

        $.expr[":"].containsInsensitive = (el,i,m)=>{
            const searchText = m[3];
            const textNode = $(el).contents().filter((i,e)=>e.nodeType === 3)[0];
            if (!textNode)
                return false;
            const match = textNode.nodeValue.toLowerCase().trim().match(`${searchText.toLowerCase().trim().escapeRegexp()}`);
            return match && match.length > 0;
        }
        ;
    },

    showCopiedEffect(eleOr$Ele, text="Copied!", bubble) {
        const $ele = eleOr$Ele instanceof $ ? eleOr$Ele : $(eleOr$Ele);

        const top = $(window).scrollTop();
        const pos = $ele.offset();

        const animationOptions = {
            top: "-=8",
            opacity: 0,
        };
        if (bubble) {
            animationOptions.left = `${Math.random() > 0.5 ? "-" : "+"}=${~~(Math.random() * 17)}`;
        }
        const seed = Math.random();
        const duration = bubble ? 250 + seed * 200 : 250;
        const offsetY = bubble ? 16 : 0;

        const $dispCopied = $(`<div class="clp__disp-copied ve-flex-vh-center py-2 px-4"></div>`);
        $dispCopied.html(text).css({
            top: (pos.top - 24) + offsetY - top,
            left: pos.left + ($ele.width() / 2),
        }).appendTo(document.body).animate(animationOptions, {
            duration,
            complete: ()=>$dispCopied.remove(),
            progress: (_,progress)=>{
                if (bubble) {
                    const diffProgress = 0.5 - progress;
                    animationOptions.top = `${diffProgress > 0 ? "-" : "+"}=40`;
                    $dispCopied.css("transform", `rotate(${seed > 0.5 ? "-" : ""}${seed * 500 * progress}deg)`);
                }
            }
            ,
        }, );
    },

    _dropdownInit: false,
    bindDropdownButton($ele) {
        if (!JqueryUtil._dropdownInit) {
            JqueryUtil._dropdownInit = true;
            document.addEventListener("click", ()=>[...document.querySelectorAll(`.open`)].filter(ele=>!(ele.className || "").split(" ").includes(`dropdown--navbar`)).forEach(ele=>ele.classList.remove("open")));
        }
        $ele.click(()=>setTimeout(()=>$ele.parent().addClass("open"), 1));
    },

    _WRP_TOAST: null,
    _ACTIVE_TOAST: [],
    doToast(options) {
        if (typeof window === "undefined")
            return;

        if (JqueryUtil._WRP_TOAST == null) {
            JqueryUtil._WRP_TOAST = e_({
                tag: "div",
                clazz: "toast__container no-events w-100 overflow-y-hidden ve-flex-col",
            });
            document.body.appendChild(JqueryUtil._WRP_TOAST);
        }

        if (typeof options === "string") {
            options = {
                content: options,
                type: "info",
            };
        }
        options.type = options.type || "info";

        options.isAutoHide = options.isAutoHide ?? true;
        options.autoHideTime = options.autoHideTime ?? 5000;

        const eleToast = e_({
            tag: "div",
            clazz: `toast toast--type-${options.type} events-initial relative my-2 mx-auto`,
            children: [e_({
                tag: "div",
                clazz: "toast__wrp-content",
                children: [options.content instanceof $ ? options.content[0] : options.content, ],
            }), e_({
                tag: "div",
                clazz: "toast__wrp-control",
                children: [e_({
                    tag: "button",
                    clazz: "btn toast__btn-close",
                    children: [e_({
                        tag: "span",
                        clazz: "glyphicon glyphicon-remove",
                    }), ],
                }), ],
            }), ],
            mousedown: evt=>{
                evt.preventDefault();
            }
            ,
            click: evt=>{
                evt.preventDefault();
                JqueryUtil._doToastCleanup(toastMeta);

                if (!evt.shiftKey)
                    return;
                [...JqueryUtil._ACTIVE_TOAST].forEach(toastMeta=>JqueryUtil._doToastCleanup(toastMeta));
            }
            ,
        });

        eleToast.prependTo(JqueryUtil._WRP_TOAST);

        const toastMeta = {
            isAutoHide: !!options.isAutoHide,
            eleToast
        };
        JqueryUtil._ACTIVE_TOAST.push(toastMeta);

        AnimationUtil.pRecomputeStyles().then(()=>{
            eleToast.addClass(`toast--animate`);

            if (options.isAutoHide) {
                setTimeout(()=>{
                    JqueryUtil._doToastCleanup(toastMeta);
                }
                , options.autoHideTime);
            }

            if (JqueryUtil._ACTIVE_TOAST.length >= 3) {
                JqueryUtil._ACTIVE_TOAST.filter(({isAutoHide})=>!isAutoHide).forEach(toastMeta=>{
                    JqueryUtil._doToastCleanup(toastMeta);
                }
                );
            }
        }
        );
    },

    _doToastCleanup(toastMeta) {
        toastMeta.eleToast.removeClass("toast--animate");
        JqueryUtil._ACTIVE_TOAST.splice(JqueryUtil._ACTIVE_TOAST.indexOf(toastMeta), 1);
        setTimeout(()=>toastMeta.eleToast.parentElement && toastMeta.eleToast.remove(), 85);
    },

    isMobile() {
        if (navigator?.userAgentData?.mobile)
            return true;
        return window.matchMedia("(max-width: 768px)").matches;
    },
};
//#endregion
//#region SourceUtil
globalThis.SourceUtil = {
    ADV_BOOK_GROUPS: [{
        group: "core",
        displayName: "Core"
    }, {
        group: "supplement",
        displayName: "Supplements"
    }, {
        group: "setting",
        displayName: "Settings"
    }, {
        group: "setting-alt",
        displayName: "Additional Settings"
    }, {
        group: "supplement-alt",
        displayName: "Extras"
    }, {
        group: "prerelease",
        displayName: "Prerelease"
    }, {
        group: "homebrew",
        displayName: "Homebrew"
    }, {
        group: "screen",
        displayName: "Screens"
    }, {
        group: "recipe",
        displayName: "Recipes"
    }, {
        group: "other",
        displayName: "Miscellaneous"
    }, ],

    _subclassReprintLookup: {},
    async pInitSubclassReprintLookup() {
        SourceUtil._subclassReprintLookup = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`);
    },

    isSubclassReprinted(className, classSource, subclassShortName, subclassSource) {
        const fromLookup = MiscUtil.get(SourceUtil._subclassReprintLookup, classSource, className, subclassSource, subclassShortName);
        return fromLookup ? fromLookup.isReprinted : false;
    },

    isSiteSource(source) {
        return !!Parser.SOURCE_JSON_TO_FULL[source];
    },

    isAdventure(source) {
        if (source instanceof FilterItem)
            source = source.item;
        return Parser.SOURCES_ADVENTURES.has(source);
    },

    isCoreOrSupplement(source) {
        if (source instanceof FilterItem)
            source = source.item;
        return Parser.SOURCES_CORE_SUPPLEMENTS.has(source);
    },

    isNonstandardSource(source) {
        if (source == null)
            return false;
        return ((typeof BrewUtil2 === "undefined" || !BrewUtil2.hasSourceJson(source)) && SourceUtil.isNonstandardSourceWotc(source)) || SourceUtil.isPrereleaseSource(source);
    },

    isPartneredSourceWotc(source) {
        if (source == null)
            return false;
        return Parser.SOURCES_PARTNERED_WOTC.has(source);
    },

    isPrereleaseSource(source) {
        if (source == null)
            return false;
        if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
            return true;
        return source.startsWith(Parser.SRC_UA_PREFIX) || source.startsWith(Parser.SRC_UA_ONE_PREFIX);
    },

    isNonstandardSourceWotc(source) {
        return SourceUtil.isPrereleaseSource(source) || source.startsWith(Parser.SRC_PS_PREFIX) || source.startsWith(Parser.SRC_AL_PREFIX) || source.startsWith(Parser.SRC_MCVX_PREFIX) || Parser.SOURCES_NON_STANDARD_WOTC.has(source);
    },

    FILTER_GROUP_STANDARD: 0,
    FILTER_GROUP_PARTNERED: 1,
    FILTER_GROUP_NON_STANDARD: 2,
    FILTER_GROUP_HOMEBREW: 3,

    getFilterGroup(source) {
        if (source instanceof FilterItem)
            source = source.item;
        if ((typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) || SourceUtil.isNonstandardSource(source))
            return SourceUtil.FILTER_GROUP_NON_STANDARD;
        if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
            return SourceUtil.FILTER_GROUP_HOMEBREW;
        if (SourceUtil.isPartneredSourceWotc(source))
            return SourceUtil.FILTER_GROUP_PARTNERED;
        return SourceUtil.FILTER_GROUP_STANDARD;
    },

    getAdventureBookSourceHref(source, page) {
        if (!source)
            return null;
        source = source.toLowerCase();

        let docPage, mappedSource;
        if (Parser.SOURCES_AVAILABLE_DOCS_BOOK[source]) {
            docPage = UrlUtil.PG_BOOK;
            mappedSource = Parser.SOURCES_AVAILABLE_DOCS_BOOK[source];
        } else if (Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source]) {
            docPage = UrlUtil.PG_ADVENTURE;
            mappedSource = Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source];
        }
        if (!docPage)
            return null;

        mappedSource = mappedSource.toLowerCase();

        return `${docPage}#${[mappedSource, page ? `page:${page}` : null].filter(Boolean).join(HASH_PART_SEP)}`;
    },

    getEntitySource(it) {
        return it.source || it.inherits?.source;
    },
};
//#endregion
//#region MiscUtil
globalThis.MiscUtil = {
    COLOR_HEALTHY: "#00bb20",
    COLOR_HURT: "#c5ca00",
    COLOR_BLOODIED: "#f7a100",
    COLOR_DEFEATED: "#cc0000",

    copy(obj, {isSafe=false, isPreserveUndefinedValueKeys=false}={}) {
        if (isSafe && obj === undefined)
            return undefined;
        return JSON.parse(JSON.stringify(obj));
    },

    copyFast(obj) {
        if ((typeof obj !== "object") || obj == null)
            return obj;

        if (obj instanceof Array)
            return obj.map(MiscUtil.copyFast);

        const cpy = {};
        for (const k of Object.keys(obj))
            cpy[k] = MiscUtil.copyFast(obj[k]);
        return cpy;
    },

    async pCopyTextToClipboard(text) {
        function doCompatibilityCopy() {
            const $iptTemp = $(`<textarea class="clp__wrp-temp"></textarea>`).appendTo(document.body).val(text).select();
            document.execCommand("Copy");
            $iptTemp.remove();
        }

        if (navigator && navigator.permissions) {
            try {
                const access = await navigator.permissions.query({
                    name: "clipboard-write"
                });
                if (access.state === "granted" || access.state === "prompt") {
                    await navigator.clipboard.writeText(text);
                } else
                    doCompatibilityCopy();
            } catch (e) {
                doCompatibilityCopy();
            }
        } else
            doCompatibilityCopy();
    },

    checkProperty(object, ...path) {
        for (let i = 0; i < path.length; ++i) {
            object = object[path[i]];
            if (object == null)
                return false;
        }
        return true;
    },

    get(object, ...path) {
        if (object == null)
            return null;
        for (let i = 0; i < path.length; ++i) {
            object = object[path[i]];
            if (object == null)
                return object;
        }
        return object;
    },

    set(object, ...pathAndVal) {
        if (object == null)
            return null;

        const val = pathAndVal.pop();
        if (!pathAndVal.length)
            return null;

        const len = pathAndVal.length;
        for (let i = 0; i < len; ++i) {
            const pathPart = pathAndVal[i];
            if (i === len - 1)
                object[pathPart] = val;
            else
                object = (object[pathPart] = object[pathPart] || {});
        }

        return val;
    },

    getOrSet(object, ...pathAndVal) {
        if (pathAndVal.length < 2)
            return null;
        const existing = MiscUtil.get(object, ...pathAndVal.slice(0, -1));
        if (existing != null)
            return existing;
        return MiscUtil.set(object, ...pathAndVal);
    },

    getThenSetCopy(object1, object2, ...path) {
        const val = MiscUtil.get(object1, ...path);
        return MiscUtil.set(object2, ...path, MiscUtil.copyFast(val, {
            isSafe: true
        }));
    },

    delete(object, ...path) {
        if (object == null)
            return object;
        for (let i = 0; i < path.length - 1; ++i) {
            object = object[path[i]];
            if (object == null)
                return object;
        }
        return delete object[path.last()];
    },

    deleteObjectPath(object, ...path) {
        const stack = [object];

        if (object == null)
            return object;
        for (let i = 0; i < path.length - 1; ++i) {
            object = object[path[i]];
            stack.push(object);
            if (object === undefined)
                return object;
        }
        const out = delete object[path.last()];

        for (let i = path.length - 1; i > 0; --i) {
            if (!Object.keys(stack[i]).length)
                delete stack[i - 1][path[i - 1]];
        }

        return out;
    },

    merge(obj1, obj2) {
        obj2 = MiscUtil.copyFast(obj2);

        Object.entries(obj2).forEach(([k,v])=>{
            if (obj1[k] == null) {
                obj1[k] = v;
                return;
            }

            if (typeof obj1[k] === "object" && typeof v === "object" && !(obj1[k]instanceof Array) && !(v instanceof Array)) {
                MiscUtil.merge(obj1[k], v);
                return;
            }

            obj1[k] = v;
        }
        );

        return obj1;
    },

    mix: (superclass)=>new MiscUtil._MixinBuilder(superclass),
    _MixinBuilder: function(superclass) {
        this.superclass = superclass;

        this.with = function(...mixins) {
            return mixins.reduce((c,mixin)=>mixin(c), this.superclass);
        }
        ;
    },

    clearSelection() {
        if (document.getSelection) {
            document.getSelection().removeAllRanges();
            document.getSelection().addRange(document.createRange());
        } else if (window.getSelection) {
            if (window.getSelection().removeAllRanges) {
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(document.createRange());
            } else if (window.getSelection().empty) {
                window.getSelection().empty();
            }
        } else if (document.selection) {
            document.selection.empty();
        }
    },

    randomColor() {
        let r;
        let g;
        let b;
        const h = RollerUtil.randomise(30, 0) / 30;
        const i = ~~(h * 6);
        const f = h * 6 - i;
        const q = 1 - f;
        switch (i % 6) {
        case 0:
            r = 1;
            g = f;
            b = 0;
            break;
        case 1:
            r = q;
            g = 1;
            b = 0;
            break;
        case 2:
            r = 0;
            g = 1;
            b = f;
            break;
        case 3:
            r = 0;
            g = q;
            b = 1;
            break;
        case 4:
            r = f;
            g = 0;
            b = 1;
            break;
        case 5:
            r = 1;
            g = 0;
            b = q;
            break;
        }
        return `#${`00${(~~(r * 255)).toString(16)}`.slice(-2)}${`00${(~~(g * 255)).toString(16)}`.slice(-2)}${`00${(~~(b * 255)).toString(16)}`.slice(-2)}`;
    },

    invertColor(hex, opts) {
        opts = opts || {};

        hex = hex.slice(1);
        let r = parseInt(hex.slice(0, 2), 16);
        let g = parseInt(hex.slice(2, 4), 16);
        let b = parseInt(hex.slice(4, 6), 16);

        const isDark = (r * 0.299 + g * 0.587 + b * 0.114) > 186;
        if (opts.dark && opts.light)
            return isDark ? opts.dark : opts.light;
        else if (opts.bw)
            return isDark ? "#000000" : "#FFFFFF";

        r = (255 - r).toString(16);
        g = (255 - g).toString(16);
        b = (255 - b).toString(16);
        return `#${[r, g, b].map(it=>it.padStart(2, "0")).join("")}`;
    },

    scrollPageTop() {
        document.body.scrollTop = document.documentElement.scrollTop = 0;
    },

    expEval(str) {
        return new Function(`return ${str.replace(/[^-()\d/*+.]/g, "")}`)();
    },

    parseNumberRange(input, min=Number.MIN_SAFE_INTEGER, max=Number.MAX_SAFE_INTEGER) {
        if (!input || !input.trim())
            return null;

        const errInvalid = input=>{
            throw new Error(`Could not parse range input "${input}"`);
        }
        ;

        const errOutOfRange = ()=>{
            throw new Error(`Number was out of range! Range was ${min}-${max} (inclusive).`);
        }
        ;

        const isOutOfRange = (num)=>num < min || num > max;

        const addToRangeVal = (range,num)=>range.add(num);

        const addToRangeLoHi = (range,lo,hi)=>{
            for (let i = lo; i <= hi; ++i)
                range.add(i);
        }
        ;

        const clean = input.replace(/\s*/g, "");
        if (!/^((\d+-\d+|\d+),)*(\d+-\d+|\d+)$/.exec(clean))
            errInvalid();

        const parts = clean.split(",");
        const out = new Set();

        for (const part of parts) {
            if (part.includes("-")) {
                const spl = part.split("-");
                const numLo = Number(spl[0]);
                const numHi = Number(spl[1]);

                if (isNaN(numLo) || isNaN(numHi) || numLo === 0 || numHi === 0 || numLo > numHi)
                    errInvalid();

                if (isOutOfRange(numLo) || isOutOfRange(numHi))
                    errOutOfRange();

                if (numLo === numHi)
                    addToRangeVal(out, numLo);
                else
                    addToRangeLoHi(out, numLo, numHi);
                continue;
            }

            const num = Number(part);
            if (isNaN(num) || num === 0)
                errInvalid();

            if (isOutOfRange(num))
                errOutOfRange();
            addToRangeVal(out, num);
        }

        return out;
    },

    findCommonPrefix(strArr, {isRespectWordBoundaries}={}) {
        if (isRespectWordBoundaries) {
            return MiscUtil._findCommonPrefixSuffixWords({
                strArr
            });
        }

        let prefix = null;
        strArr.forEach(s=>{
            if (prefix == null) {
                prefix = s;
                return;
            }

            const minLen = Math.min(s.length, prefix.length);
            for (let i = 0; i < minLen; ++i) {
                const cp = prefix[i];
                const cs = s[i];
                if (cp !== cs) {
                    prefix = prefix.substring(0, i);
                    break;
                }
            }
        }
        );
        return prefix;
    },

    findCommonSuffix(strArr, {isRespectWordBoundaries}={}) {
        if (!isRespectWordBoundaries)
            throw new Error(`Unimplemented!`);

        return MiscUtil._findCommonPrefixSuffixWords({
            strArr,
            isSuffix: true
        });
    },

    _findCommonPrefixSuffixWords({strArr, isSuffix}) {
        let prefixTks = null;
        let lenMax = -1;

        strArr.map(str=>{
            lenMax = Math.max(lenMax, str.length);
            return str.split(" ");
        }
        ).forEach(tks=>{
            if (isSuffix)
                tks.reverse();

            if (prefixTks == null)
                return prefixTks = [...tks];

            const minLen = Math.min(tks.length, prefixTks.length);
            while (prefixTks.length > minLen)
                prefixTks.pop();

            for (let i = 0; i < minLen; ++i) {
                const cp = prefixTks[i];
                const cs = tks[i];
                if (cp !== cs) {
                    prefixTks = prefixTks.slice(0, i);
                    break;
                }
            }
        }
        );

        if (isSuffix)
            prefixTks.reverse();

        if (!prefixTks.length)
            return "";

        const out = prefixTks.join(" ");
        if (out.length === lenMax)
            return out;

        return isSuffix ? ` ${prefixTks.join(" ")}` : `${prefixTks.join(" ")} `;
    },

    calculateBlendedColor(fgHexTarget, fgOpacity, bgHex) {
        const fgDcTarget = CryptUtil.hex2Dec(fgHexTarget);
        const bgDc = CryptUtil.hex2Dec(bgHex);
        return ((fgDcTarget - ((1 - fgOpacity) * bgDc)) / fgOpacity).toString(16);
    },

    debounce(func, wait, options) {
        let lastArgs;
        let lastThis;
        let maxWait;
        let result;
        let timerId;
        let lastCallTime;
        let lastInvokeTime = 0;
        let leading = false;
        let maxing = false;
        let trailing = true;

        wait = Number(wait) || 0;
        if (typeof options === "object") {
            leading = !!options.leading;
            maxing = "maxWait"in options;
            maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing"in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
            let args = lastArgs;
            let thisArg = lastThis;

            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
        }

        function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
            let timeSinceLastCall = time - lastCallTime;
            let timeSinceLastInvoke = time - lastInvokeTime;
            let result = wait - timeSinceLastCall;
            return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result;
        }

        function shouldInvoke(time) {
            let timeSinceLastCall = time - lastCallTime;
            let timeSinceLastInvoke = time - lastInvokeTime;

            return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
        }

        function timerExpired() {
            const time = Date.now();
            if (shouldInvoke(time)) {
                return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
            timerId = undefined;

            if (trailing && lastArgs)
                return invokeFunc(time);
            lastArgs = lastThis = undefined;
            return result;
        }

        function cancel() {
            if (timerId !== undefined)
                clearTimeout(timerId);
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
            return timerId === undefined ? result : trailingEdge(Date.now());
        }

        function debounced() {
            let time = Date.now();
            let isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;

            if (isInvoking) {
                if (timerId === undefined)
                    return leadingEdge(lastCallTime);
                if (maxing) {
                    timerId = setTimeout(timerExpired, wait);
                    return invokeFunc(lastCallTime);
                }
            }
            if (timerId === undefined)
                timerId = setTimeout(timerExpired, wait);
            return result;
        }

        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
    },

    throttle(func, wait, options) {
        let leading = true;
        let trailing = true;

        if (typeof options === "object") {
            leading = "leading"in options ? !!options.leading : leading;
            trailing = "trailing"in options ? !!options.trailing : trailing;
        }

        return this.debounce(func, wait, {
            leading,
            maxWait: wait,
            trailing
        });
    },

    pDelay(msecs, resolveAs) {
        return new Promise(resolve=>setTimeout(()=>resolve(resolveAs), msecs));
    },

    GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST: new Set(["caption", "type", "colLabels", "colLabelGroups", "name", "colStyles", "style", "shortName", "subclassShortName", "id", "path"]),

    getWalker(opts) {
        opts = opts || {};

        if (opts.isBreakOnReturn && !opts.isNoModification)
            throw new Error(`"isBreakOnReturn" may only be used in "isNoModification" mode!`);

        const keyBlocklist = opts.keyBlocklist || new Set();

        const getMappedPrimitive = (obj,primitiveHandlers,lastKey,stack,prop,propPre,propPost)=>{
            if (primitiveHandlers[propPre])
                MiscUtil._getWalker_runHandlers({
                    handlers: primitiveHandlers[propPre],
                    obj,
                    lastKey,
                    stack
                });
            if (primitiveHandlers[prop]) {
                const out = MiscUtil._getWalker_applyHandlers({
                    opts,
                    handlers: primitiveHandlers[prop],
                    obj,
                    lastKey,
                    stack
                });
                if (out === VeCt.SYM_WALKER_BREAK)
                    return out;
                if (!opts.isNoModification)
                    obj = out;
            }
            if (primitiveHandlers[propPost])
                MiscUtil._getWalker_runHandlers({
                    handlers: primitiveHandlers[propPost],
                    obj,
                    lastKey,
                    stack
                });
            return obj;
        }
        ;

        const doObjectRecurse = (obj,primitiveHandlers,stack)=>{
            for (const k of Object.keys(obj)) {
                if (keyBlocklist.has(k))
                    continue;

                const out = fn(obj[k], primitiveHandlers, k, stack);
                if (out === VeCt.SYM_WALKER_BREAK)
                    return VeCt.SYM_WALKER_BREAK;
                if (!opts.isNoModification)
                    obj[k] = out;
            }
        }
        ;

        const fn = (obj,primitiveHandlers,lastKey,stack)=>{
            if (obj === null)
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "null", "preNull", "postNull");

            switch (typeof obj) {
            case "undefined":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "undefined", "preUndefined", "postUndefined");
            case "boolean":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "boolean", "preBoolean", "postBoolean");
            case "number":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "number", "preNumber", "postNumber");
            case "string":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "string", "preString", "postString");
            case "object":
                {
                    if (obj instanceof Array) {
                        if (primitiveHandlers.preArray)
                            MiscUtil._getWalker_runHandlers({
                                handlers: primitiveHandlers.preArray,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            const out = new Array(obj.length);
                            for (let i = 0, len = out.length; i < len; ++i) {
                                out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
                                if (out[i] === VeCt.SYM_WALKER_BREAK)
                                    return out[i];
                            }
                            if (!opts.isNoModification)
                                obj = out;
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.array) {
                                const out = MiscUtil._getWalker_applyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (out === VeCt.SYM_WALKER_BREAK)
                                    return out;
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.array) {
                                const out = MiscUtil._getWalker_applyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (out === VeCt.SYM_WALKER_BREAK)
                                    return out;
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj != null) {
                                const out = new Array(obj.length);
                                for (let i = 0, len = out.length; i < len; ++i) {
                                    if (stack)
                                        stack.push(obj);
                                    out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
                                    if (stack)
                                        stack.pop();
                                    if (out[i] === VeCt.SYM_WALKER_BREAK)
                                        return out[i];
                                }
                                if (!opts.isNoModification)
                                    obj = out;
                            } else {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        }
                        if (primitiveHandlers.postArray)
                            MiscUtil._getWalker_runHandlers({
                                handlers: primitiveHandlers.postArray,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    }

                    if (primitiveHandlers.preObject)
                        MiscUtil._getWalker_runHandlers({
                            handlers: primitiveHandlers.preObject,
                            obj,
                            lastKey,
                            stack
                        });
                    if (opts.isDepthFirst) {
                        if (stack)
                            stack.push(obj);
                        const flag = doObjectRecurse(obj, primitiveHandlers, stack);
                        if (stack)
                            stack.pop();
                        if (flag === VeCt.SYM_WALKER_BREAK)
                            return flag;

                        if (primitiveHandlers.object) {
                            const out = MiscUtil._getWalker_applyHandlers({
                                opts,
                                handlers: primitiveHandlers.object,
                                obj,
                                lastKey,
                                stack
                            });
                            if (out === VeCt.SYM_WALKER_BREAK)
                                return out;
                            if (!opts.isNoModification)
                                obj = out;
                        }
                        if (obj == null) {
                            if (!opts.isAllowDeleteObjects)
                                throw new Error(`Object handler(s) returned null!`);
                        }
                    } else {
                        if (primitiveHandlers.object) {
                            const out = MiscUtil._getWalker_applyHandlers({
                                opts,
                                handlers: primitiveHandlers.object,
                                obj,
                                lastKey,
                                stack
                            });
                            if (out === VeCt.SYM_WALKER_BREAK)
                                return out;
                            if (!opts.isNoModification)
                                obj = out;
                        }
                        if (obj == null) {
                            if (!opts.isAllowDeleteObjects)
                                throw new Error(`Object handler(s) returned null!`);
                        } else {
                            if (stack)
                                stack.push(obj);
                            const flag = doObjectRecurse(obj, primitiveHandlers, stack);
                            if (stack)
                                stack.pop();
                            if (flag === VeCt.SYM_WALKER_BREAK)
                                return flag;
                        }
                    }
                    if (primitiveHandlers.postObject)
                        MiscUtil._getWalker_runHandlers({
                            handlers: primitiveHandlers.postObject,
                            obj,
                            lastKey,
                            stack
                        });
                    return obj;
                }
            default:
                throw new Error(`Unhandled type "${typeof obj}"`);
            }
        }
        ;

        return {
            walk: fn
        };
    },

    _getWalker_applyHandlers({opts, handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        const didBreak = handlers.some(h=>{
            const out = h(obj, lastKey, stack);
            if (opts.isBreakOnReturn && out)
                return true;
            if (!opts.isNoModification)
                obj = out;
        }
        );
        if (didBreak)
            return VeCt.SYM_WALKER_BREAK;
        return obj;
    },

    _getWalker_runHandlers({handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        handlers.forEach(h=>h(obj, lastKey, stack));
    },

    getAsyncWalker(opts) {
        opts = opts || {};
        const keyBlocklist = opts.keyBlocklist || new Set();

        const pFn = async(obj,primitiveHandlers,lastKey,stack)=>{
            if (obj == null) {
                if (primitiveHandlers.null)
                    return MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.null,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            }

            const pDoObjectRecurse = async()=>{
                await Object.keys(obj).pSerialAwaitMap(async k=>{
                    const v = obj[k];
                    if (keyBlocklist.has(k))
                        return;
                    const out = await pFn(v, primitiveHandlers, k, stack);
                    if (!opts.isNoModification)
                        obj[k] = out;
                }
                );
            }
            ;

            const to = typeof obj;
            switch (to) {
            case undefined:
                if (primitiveHandlers.preUndefined)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preUndefined,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.undefined) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.undefined,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postUndefined)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postUndefined,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "boolean":
                if (primitiveHandlers.preBoolean)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preBoolean,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.boolean) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.boolean,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postBoolean)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postBoolean,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "number":
                if (primitiveHandlers.preNumber)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preNumber,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.number) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.number,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postNumber)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postNumber,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "string":
                if (primitiveHandlers.preString)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preString,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.string) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.string,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postString)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postString,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "object":
                {
                    if (obj instanceof Array) {
                        if (primitiveHandlers.preArray)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.preArray,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            const out = await obj.pSerialAwaitMap(it=>pFn(it, primitiveHandlers, lastKey, stack));
                            if (!opts.isNoModification)
                                obj = out;
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.array) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.array) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj != null) {
                                const out = await obj.pSerialAwaitMap(it=>pFn(it, primitiveHandlers, lastKey, stack));
                                if (!opts.isNoModification)
                                    obj = out;
                            } else {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        }
                        if (primitiveHandlers.postArray)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.postArray,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    } else {
                        if (primitiveHandlers.preObject)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.preObject,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            await pDoObjectRecurse();
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.object) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.object,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteObjects)
                                    throw new Error(`Object handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.object) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.object,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteObjects)
                                    throw new Error(`Object handler(s) returned null!`);
                            } else {
                                await pDoObjectRecurse();
                            }
                        }
                        if (primitiveHandlers.postObject)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.postObject,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    }
                }
            default:
                throw new Error(`Unhandled type "${to}"`);
            }
        }
        ;

        return {
            pWalk: pFn
        };
    },

    async _getAsyncWalker_pApplyHandlers({opts, handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        await handlers.pSerialAwaitMap(async pH=>{
            const out = await pH(obj, lastKey, stack);
            if (!opts.isNoModification)
                obj = out;
        }
        );
        return obj;
    },

    async _getAsyncWalker_pRunHandlers({handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        await handlers.pSerialAwaitMap(pH=>pH(obj, lastKey, stack));
    },

    pDefer(fn) {
        return (async()=>fn())();
    },
};
//#endregion

//#region UtilDataConverter
class UtilDataConverter {
    static getNameWithSourcePart(ent, {displayName=null, isActorItem=false}={}) {
        return `${displayName || `${ent.type === "variant" ? "Variant: " : ""}${Renderer.stripTags(UtilEntityGeneric.getName(ent))}`}${!isActorItem && ent.source && Config.get("import", "isAddSourceToName") ? ` (${Parser.sourceJsonToAbv(ent.source)})` : ""}`;
    }

    static async pGetItemWeaponType(uid) {
        uid = uid.toLowerCase().trim();

        if (UtilDataConverter.WEAPONS_MARTIAL.includes(uid)){return "martial";}
        if (UtilDataConverter.WEAPONS_SIMPLE.includes(uid)){return "simple";}

        let[name,source] = Renderer.splitTagByPipe(uid);
        source = source || "phb";
        const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source});

        //TEMPFIX
        return null;
        const found = await DataLoader.pCacheAndGet(UrlUtil.PG_ITEMS, source, hash);
        return found?.weaponCategory;
    }

    static async _pGetClassSubclass_pInitCache({cache}) {
        cache = cache || {};
        if (!cache._allClasses && !cache._allSubclasses) {
            const classData = await DataUtil.class.loadJSON();
            const prerelease = await PrereleaseUtil.pGetBrewProcessed();
            const brew = await BrewUtil2.pGetBrewProcessed();

            cache._allClasses = [...(classData.class || []), ...(prerelease?.class || []), ...(brew?.class || []), ];

            cache._allSubclasses = [...(classData.subclass || []), ...(prerelease?.subclass || []), ...(brew?.subclass || []), ];
        }
        return cache;
    }

    static async pGetClassItemClassAndSubclass({sheetItem, subclassSheetItems, cache=null}={}) {
        cache = await this._pGetClassSubclass_pInitCache({
            cache
        });

        const nameLowerClean = sheetItem.name.toLowerCase().trim();
        const sourceLowerClean = (UtilDocumentSource.getDocumentSource(sheetItem).source || "").toLowerCase();

        const matchingClasses = cache._allClasses.filter(cls=>cls.name.toLowerCase() === nameLowerClean && (!Config.get("import", "isStrictMatching") || sourceLowerClean === Parser.sourceJsonToAbv(cls.source).toLowerCase()), );
        if (!matchingClasses.length)
            return {
                matchingClasses: [],
                matchingSubclasses: [],
                sheetItem
            };

        if (!subclassSheetItems?.length)
            return {
                matchingClasses,
                matchingSubclasses: [],
                sheetItem
            };

        const matchingSubclasses = matchingClasses.map(cls=>{
            const classSubclassSheetItems = subclassSheetItems.filter(scItem=>scItem.system.classIdentifier === sheetItem.system.identifier);
            return cache._allSubclasses.filter(sc=>{
                if (sc.className !== cls.name || sc.classSource !== cls.source)
                    return false;

                return classSubclassSheetItems.some(scItem=>sc.name.toLowerCase() === scItem.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(scItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(sc.source).toLowerCase()), );
            }
            );
        }
        ).flat();

        return {
            matchingClasses,
            matchingSubclasses,
            sheetItem
        };
    }

    static getSpellPointTotal({totalSpellcastingLevels}) {
        if (!totalSpellcastingLevels)
            return 0;

        const spellSlotCounts = UtilDataConverter.CASTER_TYPE_TO_PROGRESSION.full[totalSpellcastingLevels - 1] || UtilDataConverter.CASTER_TYPE_TO_PROGRESSION.full[0];

        return spellSlotCounts.map((countSlots,ix)=>{
            const spellLevel = ix + 1;
            return Parser.spLevelToSpellPoints(spellLevel) * countSlots;
        }
        ).sum();
    }

    static getPsiPointTotal({totalMysticLevels}) {
        if (!totalMysticLevels || isNaN(totalMysticLevels) || totalMysticLevels < 0)
            return 0;

        totalMysticLevels = Math.round(Math.min(totalMysticLevels, Consts.CHAR_MAX_LEVEL));

        return [4, 6, 14, 17, 27, 32, 38, 44, 57, 64, 64, 64, 64, 64, 64, 64, 64, 71, 71, 71][totalMysticLevels - 1];
    }

    static async pGetWithDescriptionPlugins(pFn, {actorId=null, tagHashItemIdMap=null}={}) {
        const hkLink = (entry,procHash)=>this._pGetWithDescriptionPlugins_fnPlugin(entry, procHash);

        const hkStr = (tag,text)=>{
            const inn = `{${tag} ${text}}`;
            const itemId = this._pGetWithDescriptionPlugins_getTagItemId({
                tag,
                text,
                tagHashItemIdMap
            });
            const out = this._getConvertedTagLinkString(inn, {
                actorId,
                itemId
            });
            if (inn === out)
                return null;
            return out;
        }
        ;

        const hkStrFont = (tag,text)=>{
            if (!game.user.isGM)
                return;

            const [,fontFamily] = Renderer.splitTagByPipe(text);

            if (UtilDataConverter._DESCRIPTION_FONTS_TRACKED[fontFamily])
                return;
            UtilDataConverter._DESCRIPTION_FONTS_TRACKED[fontFamily] = true;

            if (FontConfig.getAvailableFontChoices()[fontFamily])
                return;

            if (!Config.get("import", "isAutoAddAdditionalFonts")) {
                ui.notifications.warn(`The "${fontFamily}" font, used by recently-rendered content, is not available in your game. You may need to manually add it via the "Additional Fonts" setting, or text using the "${fontFamily}" font may not display correctly.`);
            }

            const url = BrewUtil2.getMetaLookup("fonts")?.[fontFamily] || PrereleaseUtil.getMetaLookup("fonts")?.[fontFamily];

            if (!url)
                return void ui.notifications.warn(`Failed to load font "${fontFamily}". You may need to manually add it via the "Additional Fonts" setting, or text using the "${fontFamily}" font may not display correctly.`);

            this._pDoLoadAdditionalFont(fontFamily, url).then(null);
        }
        ;

        const hkImg = (entry,url)=>{
            const out = Vetools.getImageSavedToServerUrl({
                originalUrl: url
            });
            Vetools.pSaveImageToServerAndGetUrl({
                originalUrl: url,
                force: true
            }).then(null).catch(()=>{}
            );
            return out;
        }
        ;

        Renderer.get().addPlugin("link_attributesHover", hkLink);
        Renderer.get().addPlugin("string_@font", hkStrFont);
        if (Config.get("import", "isRenderLinksAsTags"))
            Renderer.get().addPlugin("string_tag", hkStr);
        if (Config.get("import", "isSaveImagesToServer")) {
            Renderer.get().addPlugin("image_urlPostProcess", hkImg);
            Renderer.get().addPlugin("image_urlThumbnailPostProcess", hkImg);
        }

        let out;
        try {
            out = await pFn();
        } finally {
            Renderer.get().removePlugin("link_attributesHover", hkLink);
            Renderer.get().removePlugin("string_@font", hkStrFont);
            Renderer.get().removePlugin("string_tag", hkStr);
            Renderer.get().removePlugin("image_urlPostProcess", hkImg);
            Renderer.get().removePlugin("image_urlThumbnailPostProcess", hkImg);
        }

        return out;
    }

    static _DESCRIPTION_FONTS_TRACKED = {};
    static _HAS_NOTIFIED_FONTS_RELOAD = false;

    static async _pDoLoadAdditionalFont(family, url) {
        const hasNotified = this._HAS_NOTIFIED_FONTS_RELOAD;
        this._HAS_NOTIFIED_FONTS_RELOAD = true;

        const definitions = game.settings.get("core", FontConfig.SETTING);
        definitions[family] ??= {
            editor: true,
            fonts: []
        };
        const definition = definitions[family];
        definition.fonts.push({
            urls: [url],
            weight: 400,
            style: "normal"
        });
        await game.settings.set("core", FontConfig.SETTING, definitions);
        await FontConfig.loadFont(family, definition);

        if (hasNotified)
            return;

        ChatNotificationHandlers.getHandler("ReloadFonts").pDoPostChatMessage();
    }

    static _pGetWithDescriptionPlugins_getTagItemId({tag, text, tagHashItemIdMap}) {
        const tagName = tag.slice(1);
        if (!tagHashItemIdMap?.[tagName])
            return null;
        const defaultSource = Renderer.tag.TAG_LOOKUP[tagName]?.defaultSource;
        if (!defaultSource)
            return null;
        const page = Renderer.tag.getPage(tagName);
        if (!page)
            return null;
        const hashBuilder = UrlUtil.URL_TO_HASH_BUILDER[page];
        if (!hashBuilder)
            return null;
        let[name,source] = text.split("|");
        source = source || defaultSource;
        const hash = hashBuilder({
            name,
            source
        });
        return tagHashItemIdMap?.[tagName]?.[hash];
    }

    static _pGetWithDescriptionPlugins_fnPlugin(entry, procHash) {
        const page = entry.href.hover.page;
        const source = entry.href.hover.source;
        const hash = procHash;
        const preloadId = entry.href.hover.preloadId;
        return {
            attributesHoverReplace: [`data-plut-hover="${true}" data-plut-hover-page="${page.qq()}" data-plut-hover-source="${source.qq()}" data-plut-hover-hash="${hash.qq()}" ${preloadId ? `data-plut-hover-preload-id="${preloadId.qq()}"` : ""}`, ],
        };
    }

    static _getConvertedTagLinkString(str, {actorId, itemId}={}) {
        this._getConvertedTagLinkString_initLinkTagMetas();
        for (const {tag, re} of this._LINK_TAG_METAS_REPLACE)
            str = str.replace(re, (...m)=>this._replaceEntityLinks_getReplacement({
                tag,
                text: m.last().text,
                actorId,
                itemId
            }));
        for (const {tag, re} of this._LINK_TAG_METAS_REMOVE)
            str = str.replace(re, (...m)=>this._replaceEntityLinks_getRemoved({
                tag,
                text: m.last().text
            }));
        return str;
    }

    static _LINK_TAGS_TO_REMOVE = new Set(["quickref", ]);
    static _LINK_TAG_METAS_REPLACE = null;
    static _LINK_TAG_METAS_REMOVE = null;

    static _getConvertedTagLinkString_initLinkTagMetas() {
        if (!this._LINK_TAG_METAS_REPLACE) {
            this._LINK_TAG_METAS_REPLACE = Renderer.tag.TAGS.filter(it=>it.defaultSource).map(it=>it.tagName).filter(tag=>!this._LINK_TAGS_TO_REMOVE.has(tag)).map(tag=>({
                tag,
                re: this._getConvertedTagLinkString_getRegex({
                    tag
                })
            }));
        }

        if (!this._LINK_TAG_METAS_REMOVE) {
            this._LINK_TAG_METAS_REMOVE = Renderer.tag.TAGS.filter(it=>it.defaultSource).map(it=>it.tagName).filter(tag=>this._LINK_TAGS_TO_REMOVE.has(tag)).map(tag=>({
                tag,
                re: this._getConvertedTagLinkString_getRegex({
                    tag
                })
            }));
        }
    }

    static _getConvertedTagLinkString_getRegex({tag}) {
        return RegExp(`^{@${tag} (?<text>[^}]+)}$`, "g");
    }

    static getConvertedTagLinkEntries(entries) {
        if (!entries)
            return entries;

        return UtilDataConverter.WALKER_GENERIC.walk(MiscUtil.copy(entries), {
            string: str=>{
                const textStack = [""];
                this._getConvertedTagLinkEntries_recurse(str, textStack);
                return textStack.join("");
            }
            ,
        }, );
    }

    static _getConvertedTagLinkEntries_recurse(str, textStack) {
        const tagSplit = Renderer.splitByTags(str);
        const len = tagSplit.length;
        for (let i = 0; i < len; ++i) {
            const s = tagSplit[i];
            if (!s)
                continue;

            if (s.startsWith("{@")) {
                const converted = this._getConvertedTagLinkString(s);

                if (converted !== s) {
                    textStack[0] += (converted);
                    continue;
                }

                textStack[0] += s.slice(0, 1);
                this._getConvertedTagLinkEntries_recurse(s.slice(1, -1), textStack);
                textStack[0] += s.slice(-1);

                continue;
            }

            textStack[0] += s;
        }
    }

    static _replaceEntityLinks_getReplacement({tag, text, actorId, itemId}) {
        if (actorId && itemId) {
            const [,,displayText] = text.split("|");
            return `@UUID[Actor.${actorId}.Item.${itemId}]${displayText ? `{${displayText}}` : ""}`;
        }
        return `@${tag}[${text}]`;
    }

    static _replaceEntityLinks_getRemoved({tag, text}) {
        return Renderer.stripTags(`{@${tag} ${text}}`);
    }

    static async _pReplaceEntityLinks_pReplace({str, re, tag}) {
        let m;
        while ((m = re.exec(str))) {
            const prefix = str.slice(0, m.index);
            const suffix = str.slice(re.lastIndex);
            const replacement = this._replaceEntityLinks_getReplacement({
                tag,
                m
            });
            str = `${prefix}${replacement}${suffix}`;
            re.lastIndex = prefix.length + replacement.length;
        }
        return str;
    }

    static _RECHARGE_TYPES = {
        "round": null,
        "restShort": "sr",
        "restLong": "lr",
        "dawn": "dawn",
        "dusk": "dusk",
        "midnight": "day",

        "special": null,

        "week": null,
        "month": null,
        "year": null,
        "decade": null,
        "century": null,
    };

    static getFvttUsesPer(it, {isStrict=true}={}) {
        if (isStrict && !this._RECHARGE_TYPES[it])
            return null;
        return Parser._parse_aToB(this._RECHARGE_TYPES, it);
    }

    static getTempDocumentDefaultOwnership({documentType}) {
        if (game.user.isGM)
            return undefined;

        const clazz = CONFIG[documentType].documentClass;

        if (game.user.can(clazz.metadata.permissions.create))
            return undefined;

        return CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
    }
}
UtilDataConverter.WALKER_READONLY_GENERIC = MiscUtil.getWalker({
    isNoModification: true,
    keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST
});
UtilDataConverter.WALKER_GENERIC = MiscUtil.getWalker({
    keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST
});

UtilDataConverter.WEAPONS_MARTIAL = ["battleaxe|phb", "blowgun|phb", "flail|phb", "glaive|phb", "greataxe|phb", "greatsword|phb", "halberd|phb", "hand crossbow|phb", "heavy crossbow|phb", "lance|phb", "longbow|phb", "longsword|phb", "maul|phb", "morningstar|phb", "net|phb", "pike|phb", "rapier|phb", "scimitar|phb", "shortsword|phb", "trident|phb", "war pick|phb", "warhammer|phb", "whip|phb", ];
UtilDataConverter.WEAPONS_SIMPLE = ["club|phb", "dagger|phb", "dart|phb", "greatclub|phb", "handaxe|phb", "javelin|phb", "light crossbow|phb", "light hammer|phb", "mace|phb", "quarterstaff|phb", "shortbow|phb", "sickle|phb", "sling|phb", "spear|phb", ];

UtilDataConverter.CASTER_TYPE_TO_PROGRESSION = {
    "full": [[2, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0, 0], [4, 3, 2, 0, 0, 0, 0, 0, 0], [4, 3, 3, 0, 0, 0, 0, 0, 0], [4, 3, 3, 1, 0, 0, 0, 0, 0], [4, 3, 3, 2, 0, 0, 0, 0, 0], [4, 3, 3, 3, 1, 0, 0, 0, 0], [4, 3, 3, 3, 2, 0, 0, 0, 0], [4, 3, 3, 3, 2, 1, 0, 0, 0], [4, 3, 3, 3, 2, 1, 0, 0, 0], [4, 3, 3, 3, 2, 1, 1, 0, 0], [4, 3, 3, 3, 2, 1, 1, 0, 0], [4, 3, 3, 3, 2, 1, 1, 1, 0], [4, 3, 3, 3, 2, 1, 1, 1, 0], [4, 3, 3, 3, 2, 1, 1, 1, 1], [4, 3, 3, 3, 3, 1, 1, 1, 1], [4, 3, 3, 3, 3, 2, 1, 1, 1], [4, 3, 3, 3, 3, 2, 2, 1, 1], ],
    "artificer": [[2, 0, 0, 0, 0], [2, 0, 0, 0, 0], [3, 0, 0, 0, 0], [3, 0, 0, 0, 0], [4, 2, 0, 0, 0], [4, 2, 0, 0, 0], [4, 3, 0, 0, 0], [4, 3, 0, 0, 0], [4, 3, 2, 0, 0], [4, 3, 2, 0, 0], [4, 3, 3, 0, 0], [4, 3, 3, 0, 0], [4, 3, 3, 1, 0], [4, 3, 3, 1, 0], [4, 3, 3, 2, 0], [4, 3, 3, 2, 0], [4, 3, 3, 3, 1], [4, 3, 3, 3, 1], [4, 3, 3, 3, 2], [4, 3, 3, 3, 2], ],
    "1/2": [[0, 0, 0, 0, 0], [2, 0, 0, 0, 0], [3, 0, 0, 0, 0], [3, 0, 0, 0, 0], [4, 2, 0, 0, 0], [4, 2, 0, 0, 0], [4, 3, 0, 0, 0], [4, 3, 0, 0, 0], [4, 3, 2, 0, 0], [4, 3, 2, 0, 0], [4, 3, 3, 0, 0], [4, 3, 3, 0, 0], [4, 3, 3, 1, 0], [4, 3, 3, 1, 0], [4, 3, 3, 2, 0], [4, 3, 3, 2, 0], [4, 3, 3, 3, 1], [4, 3, 3, 3, 1], [4, 3, 3, 3, 2], [4, 3, 3, 3, 2], ],
    "1/3": [[0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 0, 0], [3, 0, 0, 0], [3, 0, 0, 0], [3, 0, 0, 0], [4, 2, 0, 0], [4, 2, 0, 0], [4, 2, 0, 0], [4, 3, 0, 0], [4, 3, 0, 0], [4, 3, 0, 0], [4, 3, 2, 0], [4, 3, 2, 0], [4, 3, 2, 0], [4, 3, 3, 0], [4, 3, 3, 0], [4, 3, 3, 0], [4, 3, 3, 1], [4, 3, 3, 1], ],
    "pact": [[1, 0, 0, 0, 0], [2, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 2, 0, 0], [0, 0, 2, 0, 0], [0, 0, 0, 2, 0], [0, 0, 0, 2, 0], [0, 0, 0, 0, 2], [0, 0, 0, 0, 2], [0, 0, 0, 0, 3], [0, 0, 0, 0, 3], [0, 0, 0, 0, 3], [0, 0, 0, 0, 3], [0, 0, 0, 0, 3], [0, 0, 0, 0, 3], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4], ],
};
//#endregion


//#region VeTools
globalThis.VeLock = function({name=null, isDbg=false}={}) {
    this._name = name;
    this._isDbg = isDbg;
    this._lockMeta = null;

    this._getCaller = ()=>{
        return (new Error()).stack.split("\n")[3].trim();
    }
    ;

    this.pLock = async({token=null}={})=>{
        if (token != null && this._lockMeta?.token === token) {
            ++this._lockMeta.depth;
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" add (now ${this._lockMeta.depth}) at ${this._getCaller()}`);
            return token;
        }

        while (this._lockMeta)
            await this._lockMeta.lock;

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" acquired at ${this._getCaller()}`);

        let unlock = null;
        const lock = new Promise(resolve=>unlock = resolve);
        this._lockMeta = {
            lock,
            unlock,
            token: CryptUtil.uid(),
            depth: 0,
        };

        return this._lockMeta.token;
    }
    ;

    this.unlock = ()=>{
        if (!this._lockMeta)
            return;

        if (this._lockMeta.depth > 0) {
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" sub (now ${this._lockMeta.depth - 1}) at ${this._getCaller()}`);
            return --this._lockMeta.depth;
        }

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" released at ${this._getCaller()}`);

        const lockMeta = this._lockMeta;
        this._lockMeta = null;
        lockMeta.unlock();
    }
    ;
}
;
class Vetools {
    static PRERELEASE_INDEX__SOURCE = {};
    static PRERELEASE_INDEX__PROP = {};
    static PRERELEASE_INDEX__META = {};

    static BREW_INDEX__SOURCE = {};
    static BREW_INDEX__PROP = {};
    static BREW_INDEX__META = {};

    static async pDoPreload() {
        if (Config.get("dataSources", "isNoPrereleaseBrewIndexes"))
            return;

        Vetools._pGetPrereleaseBrewIndices().then(({propPrerelease, sourcePrerelease, metaPrerelease, sourceBrew, propBrew, metaBrew})=>{
            Vetools.PRERELEASE_INDEX__PROP = propPrerelease;
            Vetools.PRERELEASE_INDEX__SOURCE = sourcePrerelease;
            Vetools.PRERELEASE_INDEX__META = metaPrerelease;

            Vetools.BREW_INDEX__PROP = propBrew;
            Vetools.BREW_INDEX__SOURCE = sourceBrew;
            Vetools.BREW_INDEX__META = metaBrew;

            console.log(...LGT, "Loaded prerelease/homebrew indexes.");
        }
        ).catch(e=>{
            Vetools.PRERELEASE_INDEX__SOURCE = {};
            Vetools.PRERELEASE_INDEX__PROP = {};
            Vetools.PRERELEASE_INDEX__META = {};

            Vetools.BREW_INDEX__PROP = {};
            Vetools.BREW_INDEX__SOURCE = {};
            Vetools.BREW_INDEX__META = {};

            ui.notifications.error(`Failed to load prerelease/homebrew indexes! ${VeCt.STR_SEE_CONSOLE}`);
            setTimeout(()=>{
                throw e;
            }
            );
        }
        );
    }

    static withUnpatchedDiceRendering(fn) {
        Renderer.getRollableEntryDice = Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE;
        const out = fn();
        Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
        return out;
    }

    static withCustomDiceRenderingPatch(fn, fnRender) {
        Renderer.getRollableEntryDice = fnRender;
        const out = fn();
        Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
        return out;
    }

    static getCleanDiceString(diceString) {
        return diceString.replace(/×/g, "*").replace(/÷/g, "/").replace(/#\$.*?\$#/g, "0");
    }

    static doMonkeyPatchPreConfig() {
        VeCt.STR_SEE_CONSOLE = "See the console (F12 or CTRL+SHIFT+J) for details.";

        StorageUtil.pSet = GameStorage.pSetClient.bind(GameStorage);
        StorageUtil.pGet = GameStorage.pGetClient.bind(GameStorage);
        StorageUtil.pRemove = GameStorage.pRemoveClient.bind(GameStorage);

        ["monster", "vehicle", "object", "trap", "race", "background"].forEach(prop=>{
            const propFullName = `${prop}Name`;
            const propFullSource = `${prop}Source`;
            (Renderer[prop].CHILD_PROPS_EXTENDED || Renderer[prop].CHILD_PROPS || ["feature"]).forEach(propChild=>{
                const propChildFull = `${prop}${propChild.uppercaseFirst()}`;
                if (UrlUtil.URL_TO_HASH_BUILDER[propChildFull])
                    return;
                UrlUtil.URL_TO_HASH_BUILDER[propChildFull] = it=>UrlUtil.encodeForHash([it.name, it[propFullName], it[propFullSource], it.source]);
            }
            );
        }
        );
    }

    static _CACHED_DATA_UTIL_LOAD_JSON = null;
    static _CACHED_DATA_UTIL_LOAD_RAW_JSON = null;

    static doMonkeyPatchPostConfig() {
        JqueryExtension.init();
        this._initSourceLookup();

        UtilsChangelog._RELEASE_URL = "https://github.com/TheGiddyLimit/plutonium-next/tags";

        const hkSetRendererUrls = ()=>{
            Renderer.get().setBaseUrl(Vetools.BASE_SITE_URL);

            if (Config.get("import", "isUseLocalImages")) {
                const localImageDirPath = `${Config.get("import", "localImageDirectoryPath")}/`.replace(/\/+$/, "/");
                Renderer.get().setBaseMediaUrl("img", localImageDirPath);
                return;
            }

            if (this._isCustomBaseSiteUrl()) {
                Renderer.get().setBaseMediaUrl("img", Vetools.BASE_SITE_URL);
                return;
            }

            Renderer.get().setBaseMediaUrl("img", null);
        }
        ;
        hkSetRendererUrls();

        UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, hkSetRendererUrls);

        Renderer.hover.MIN_Z_INDEX = Consts.Z_INDEX_MAX_FOUNDRY + 1;
        Renderer.hover._MAX_Z_INDEX = Renderer.hover.MIN_Z_INDEX + 10;

        Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE = Renderer.getRollableEntryDice;
        Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE = (entry,name,toDisplay,{isAddHandlers=true, pluginResults=null, }={},)=>{
            const cpy = MiscUtil.copy(entry);

            if (typeof cpy.toRoll !== "string") {
                cpy.toRoll = Renderer.legacyDiceToString(cpy.toRoll);
            }

            if (cpy.prompt) {
                const minAdditionalDiceLevel = Math.min(...Object.keys(cpy.prompt.options).map(it=>Number(it)).filter(it=>cpy.prompt.options[it]));
                cpy.toRoll = cpy.prompt.options[minAdditionalDiceLevel];
            }

            const toRollClean = this.getCleanDiceString(cpy.toRoll);

            if (Config.get("import", "isRendererDiceDisabled"))
                return toDisplay || toRollClean;

            const ptDisplay = toRollClean.toLowerCase().trim() !== toDisplay.toLowerCase().trim() ? `{${toDisplay}}` : "";

            if (cpy.autoRoll)
                return `[[${toRollClean}]]${ptDisplay}`;

            if (Config.get("import", "isRenderCustomDiceEnrichers") && entry.subtype === "damage") {
                return `[[/damage ${toRollClean} ${cpy.damageType ? `type=${cpy.damageType}` : ""}]]${ptDisplay}`;
            }

            return `[[/r ${toRollClean}]]${ptDisplay}`;
        }
        ;

        Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;

        const cachedRenderHoverMethods = {};
        const renderHoverMethods = ["$getHoverContent_stats", "$getHoverContent_fluff", "$getHoverContent_statsCode", "$getHoverContent_miscCode", "$getHoverContent_generic", ];
        renderHoverMethods.forEach(methodName=>{
            cachedRenderHoverMethods[methodName] = Renderer.hover[methodName];
            Renderer.hover[methodName] = (...args)=>{
                Renderer.getRollableEntryDice = Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE;
                const out = cachedRenderHoverMethods[methodName](...args);
                Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
                return out;
            }
            ;
        }
        );

        const cachedGetMakePredefinedHover = Renderer.hover.getMakePredefinedHover.bind(Renderer.hover);
        Renderer.hover.getMakePredefinedHover = (entry,opts)=>{
            const out = cachedGetMakePredefinedHover(entry, opts);
            out.html = `data-plut-hover="${true}" data-plut-hover-preload="${true}" data-plut-hover-preload-id="${out.id}" ${opts ? `data-plut-hover-preload-options="${JSON.stringify(opts).qq()}"` : ""}`;
            return out;
        }
        ;

        const cachedGetInlineHover = Renderer.hover.getInlineHover.bind(Renderer.hover);
        Renderer.hover.getInlineHover = (entry,opts)=>{
            const out = cachedGetInlineHover(entry, opts);
            out.html = `data-plut-hover="${true}" data-plut-hover-inline="${true}" data-plut-hover-inline-entry="${JSON.stringify(entry).qq()}" ${opts ? `data-plut-hover-inline-options="${JSON.stringify(opts).qq()}"` : ""}`;
            return out;
        }
        ;

        Renderer.dice.rollerClick = (evtMock,ele,packed,name)=>{
            const entry = JSON.parse(packed);
            if (entry.toRoll)
                (new Roll(entry.toRoll)).toMessage();
        }
        ;

        Renderer.dice.pRollEntry = (entry,rolledBy,opts)=>{
            if (entry.toRoll)
                (new Roll(entry.toRoll)).toMessage();
        }
        ;

        Renderer.dice.pRoll2 = async(str,rolledBy,opts)=>{
            const roll = new Roll(str);
            await roll.evaluate({
                async: true
            });
            await roll.toMessage();
            return roll.total;
        }
        ;

        Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS = Renderer.monster.doBindCompactContentHandlers;
        Renderer.monster.doBindCompactContentHandlers = (opts)=>{
            const nxtOpts = {
                ...opts
            };
            nxtOpts.fnRender = (...args)=>Vetools.withUnpatchedDiceRendering(()=>opts.fnRender(...args));
            return Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS(nxtOpts);
        }
        ;

        JqueryUtil.doToast = (options)=>{
            if (typeof options === "string") {
                options = {
                    content: options,
                    type: "info",
                };
            }
            options.type = options.type || "info";

            switch (options.type) {
            case "warning":
                return ui.notifications.warn(options.content);
            case "danger":
                return ui.notifications.error(options.content);
            default:
                return ui.notifications.info(options.content);
            }
        }
        ;

        UiUtil.pGetShowModal = opts=>UtilApplications.pGetShowApplicationModal(opts);
        InputUiUtil._pGetShowModal = opts=>UtilApplications.pGetShowApplicationModal(opts);

        this._CACHED_DATA_UTIL_LOAD_JSON = DataUtil.loadJSON.bind(DataUtil);
        this._CACHED_DATA_UTIL_LOAD_RAW_JSON = DataUtil.loadRawJSON.bind(DataUtil);

        DataUtil.loadJSON = async(url,...rest)=>Vetools._CACHED_DATA_UTIL_LOAD_JSON(this._getMaybeLocalUrl(url), ...rest);
        DataUtil.loadRawJSON = async(url,...rest)=>Vetools._CACHED_DATA_UTIL_LOAD_RAW_JSON(this._getMaybeLocalUrl(url), ...rest);

        Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET = DataLoader.pCacheAndGet.bind(DataLoader);
        DataLoader.pCacheAndGet = async function(page, source, ...others) {
            const sourceLower = `${source}`.toLowerCase();
            if (!Vetools._VET_SOURCE_LOOKUP[sourceLower]) {
                Vetools._pCachingLocalPrerelease = Vetools._pCachingLocalPrerelease || Vetools._pDoCacheLocalPrerelease();
                Vetools._pCachingLocalBrew = Vetools._pCachingLocalBrew || Vetools._pDoCacheLocalBrew();

                await Promise.all([Vetools._pCachingLocalPrerelease, Vetools._pCachingLocalBrew, ]);
            }

            return Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET(page, source, ...others);
        }
        ;

        PrereleaseUtil._storage = new StorageUtilMemory();
        BrewUtil2._storage = new StorageUtilMemory();
    }

    static _initSourceLookup() {
        Object.keys(Parser.SOURCE_JSON_TO_FULL).forEach(source=>Vetools._VET_SOURCE_LOOKUP[source.toLowerCase()] = true);
    }

    static _pCachingLocalPrerelease = null;
    static _pCachingLocalBrew = null;

    static async _pDoCacheLocalPrerelease() {
        await this.pGetLocalPrereleaseSources();
    }
    static async _pDoCacheLocalBrew() {
        await this.pGetLocalBrewSources();
    }

    static _getMaybeLocalUrl(url) {
        if (!url.includes("?"))
            url = `${url}?t=${Consts.RUN_TIME}`;

        const parts = url.split(Vetools._RE_HTTP_URL).filter(Boolean);
        parts[parts.length - 1] = parts.last().replace(/\/+/g, "/");
        url = parts.join("");

        if (!Config.get("dataSources", "isNoLocalData") && (url.startsWith(`${Vetools.BASE_SITE_URL}data/`) || url.startsWith(`${Vetools.BASE_SITE_URL}search/`)) && url !== this._getChangelogUrl()) {
            const urlPart = url.split(Vetools.BASE_SITE_URL).slice(1).join(Vetools.BASE_SITE_URL);
            return `modules/${SharedConsts.MODULE_ID}/${urlPart}`;
        } else {
            return url;
        }
    }

    static _CACHE_IMPORTER_SOURCE_SPECIAL = {};

    static async pLoadImporterSourceSpecial(source) {
        if (!source.special.cacheKey)
            return source.special.pGet();

        this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey] = this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey] || source.special.pGet();

        return this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey];
    }

    static _getChangelogUrl() {
        return `${Vetools.BASE_SITE_URL}data/changelog.json`;
    }
    static async pGetChangelog() {
        return DataUtil.loadJSON(this._getChangelogUrl());
    }

    static async pGetPackageIndex() {
        return DataUtil.loadJSON(Config.get("importAdventure", "indexUrl"));
    }

    static async pGetItems() {
        return {
            item: (await Renderer.item.pBuildList()).filter(it=>!it._isItemGroup)
        };
    }

    static async pGetPrereleaseItems(data) {
        return this._pGetPrereleaseBrewItems({
            data,
            pFnGetItems: Renderer.item.pGetItemsFromPrerelease.bind(Renderer.item)
        });
    }

    static async pGetBrewItems(data) {
        return this._pGetPrereleaseBrewItems({
            data,
            pFnGetItems: Renderer.item.pGetItemsFromBrew.bind(Renderer.item)
        });
    }

    static async _pGetPrereleaseBrewItems({data, pFnGetItems}) {
        const sources = new Set();
        ["item", "magicvariant", "baseitem"].forEach(prop=>{
            if (!data[prop])
                return;
            data[prop].forEach(ent=>sources.add(SourceUtil.getEntitySource(ent)));
        }
        );
        return (await pFnGetItems()).filter(ent=>sources.has(SourceUtil.getEntitySource(ent)));
    }

    static async pGetRaces(opts) {
        return DataUtil.race.loadJSON(opts);
    }

    static async pGetClasses() {
        return DataUtil.class.loadRawJSON();
    }

    static async pGetClassSubclassFeatures() {
        return DataUtil.class.loadRawJSON();
    }

    static async pGetRollableTables() {
        return DataUtil.table.loadJSON();
    }

    static async pGetDecks() {
        return DataUtil.deck.loadJSON();
    }

    static async _pGetAdventureBookIndex(filename, {prop, fnGetUrl}) {
        const url = `${Vetools.BASE_SITE_URL}data/${filename}`;
        const index = await DataUtil.loadJSON(url);
        index[prop].forEach(it=>{
            it._pubDate = new Date(it.published || "1970-01-01");
            it._url = fnGetUrl(it.id);
        }
        );
        return index;
    }

    static async pGetAdventureIndex() {
        return this._pGetAdventureBookIndex("adventures.json", {
            prop: "adventure",
            fnGetUrl: Vetools.getAdventureUrl.bind(Vetools)
        });
    }

    static async pGetBookIndex() {
        return this._pGetAdventureBookIndex("books.json", {
            prop: "book",
            fnGetUrl: Vetools.getBookUrl.bind(Vetools)
        });
    }

    static _getAdventureBookUrl(type, id) {
        return `${Vetools.BASE_SITE_URL}data/${type}/${type}-${id.toLowerCase()}.json`;
    }

    static getAdventureUrl(id) {
        return this._getAdventureBookUrl("adventure", id);
    }

    static getBookUrl(id) {
        return this._getAdventureBookUrl("book", id);
    }

    static pGetImageUrlFromFluff(fluff) {
        if (!fluff?.images?.length)
            return;

        const imgEntry = fluff.images[0];
        if (!imgEntry?.href)
            return;

        const urlsWarn = [];
        const out = fluff.images.first(imgEntry=>{
            const url = this._pGetImageUrlFromFluff_getUrlFromEntry({
                imgEntry
            });
            if (!this._isValidImageUrl({
                url
            })) {
                urlsWarn.push(url);
                return null;
            }
            return url;
        }
        );

        if (urlsWarn.length)
            ui.notifications.warn(`Image URL${urlsWarn.length === 1 ? "" : "s"} did not have valid extensions: ${urlsWarn.map(it=>`"${it}"`).join(", ")}`);

        return out;
    }

    static _pGetImageUrlFromFluff_getUrlFromEntry({imgEntry}) {
        if (imgEntry.href.type === "internal") {
            return imgEntry.href.path ? `${Vetools.getInternalImageUrl(imgEntry.href.path)}` : null;
        }

        if (imgEntry.href.type === "external") {
            return imgEntry.href.url ? imgEntry.href.url : null;
        }
    }

    static _isValidImageUrl({url}) {
        return foundry.data.validators.hasFileExtension(url, Object.keys(CONST.IMAGE_FILE_EXTENSIONS));
    }

    static async pHasTokenUrl(entityType, it, opts) {
        return (await Vetools._pGetTokenUrl(entityType, it, opts))?.hasToken;
    }

    static async pGetTokenUrl(entityType, it, opts) {
        return (await Vetools._pGetTokenUrl(entityType, it, opts))?.url;
    }

    static _isSaveableToServerUrl(originalUrl) {
        return originalUrl && typeof originalUrl === "string" && Vetools._RE_HTTP_URL.test(originalUrl);
    }
    static _isSaveTypedImagesToServer({imageType="image"}={}) {
        switch (imageType) {
        case "image":
            return Config.get("import", "isSaveImagesToServer");
        case "token":
            return Config.get("import", "isSaveTokensToServer");
        default:
            throw new Error(`Unhandled type "${imageType}"!`);
        }
    }

    static async _pGetTokenUrl(entityType, it, {isSilent=false}={}) {
        if (it.tokenUrl)
            return {
                url: it.tokenUrl,
                hasToken: true
            };

        const fallbackMeta = {
            url: this.getBlankTokenUrl(),
            hasToken: false,
        };

        switch (entityType) {
        case "monster":
        case "vehicle":
        case "object":
            {
                const fnGets = {
                    "monster": Renderer.monster.getTokenUrl,
                    "vehicle": Renderer.vehicle.getTokenUrl,
                    "object": Renderer.object.getTokenUrl,
                };
                const fnGet = fnGets[entityType];
                if (!fnGet)
                    throw new Error(`Missing getter!`);

                if (it.hasToken)
                    return {
                        url: fnGet(it),
                        hasToken: true
                    };
                if (it._versionBase_hasToken)
                    return {
                        url: fnGet({
                            name: it._versionBase_name,
                            source: it._versionBase_source
                        }),
                        hasToken: true
                    };

                return fallbackMeta;
            }
        case "trap":
            return fallbackMeta;
        default:
            {
                if (isSilent)
                    return null;
                throw new Error(`Unhandled entity type "${entityType}"`);
            }
        }
    }

    static getBlankTokenUrl() {
        return UrlUtil.link(`${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/blank.png`);
    }

    static getImageUrl(entry) {
        if (entry?.href.type === "internal")
            return Vetools.getInternalImageUrl(entry.href.path, {
                isSkipEncode: true
            });
        return entry.href?.url;
    }

    static getInternalImageUrl(path, {isSkipEncode=false}={}) {
        if (!path)
            return null;
        const fnEncode = isSkipEncode ? it=>it : encodeURI;

        const out = `${fnEncode(Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl)}img/${fnEncode(path)}`;

        if (isSkipEncode)
            return out;
        return out.replace(/'/g, "%27");
    }

    static async pOptionallySaveImageToServerAndGetUrl(originalUrl, {imageType="image"}={}) {
        if (this._isLocalUrl({
            originalUrl
        }))
            return originalUrl;
        if (!this._isSaveTypedImagesToServer({
            imageType
        }))
            return originalUrl;
        return this.pSaveImageToServerAndGetUrl({
            originalUrl
        });
    }

    static _isLocalUrl({originalUrl}) {
        return new URL(document.baseURI).origin === new URL(originalUrl,document.baseURI).origin;
    }

    static getImageSavedToServerUrl({originalUrl=null, path, isSaveToRoot=false}={}) {
        if (!path && !this._isSaveableToServerUrl(originalUrl))
            return originalUrl;

        const pathPart = (new URL(path ? `https://example.com/${path}` : originalUrl)).pathname;
        return `${isSaveToRoot ? "" : `${Config.get("import", "localImageDirectoryPath")}/`}${decodeURI(pathPart)}`.replace(/\/+/g, "/");
    }

    static _getImageSavedToServerUrlMeta({originalUrl=null, path, isSaveToRoot=false}) {
        const cleanOutPath = this.getImageSavedToServerUrl({
            originalUrl,
            path,
            isSaveToRoot
        });
        const serverUrlPathParts = cleanOutPath.split("/");
        const serverUrlDirParts = serverUrlPathParts.slice(0, -1);
        const serverUrlDir = serverUrlDirParts.join("/");

        return {
            serverUrl: cleanOutPath,
            serverUrlPathParts,
            serverUrlDir,
            serverUrlDirParts,
        };
    }

    static async pSaveImageToServerAndGetUrl({originalUrl=null, blob, force=false, path=null, isSaveToRoot=false}={}) {
        if (blob && originalUrl)
            throw new Error(`"blob" and "originalUrl" arguments are mutually exclusive!`);

        if (!blob && !this._isSaveableToServerUrl(originalUrl))
            return originalUrl;

        let out;
        try {
            await Vetools._LOCK_DOWNLOAD_IMAGE.pLock();
            out = await this._pSaveImageToServerAndGetUrl_({
                originalUrl,
                blob,
                force,
                path,
                isSaveToRoot
            });
        } finally {
            Vetools._LOCK_DOWNLOAD_IMAGE.unlock();
        }
        return out;
    }

    static async _pSaveImageToServerAndGetUrl_({originalUrl=null, blob, force=false, path=null, isSaveToRoot=false}={}) {
        if (blob && originalUrl)
            throw new Error(`"blob" and "originalUrl" arguments are mutually exclusive!`);

        const {serverUrl, serverUrlPathParts, serverUrlDir, serverUrlDirParts, } = this._getImageSavedToServerUrlMeta({
            originalUrl,
            path,
            isSaveToRoot
        });

        const {dirListing, isDirExists, isError: isErrorDirListing, } = await this.pGetDirectoryListing({
            originalUrl,
            path,
            isSaveToRoot
        });

        if (isErrorDirListing) {
            const msgStart = `Could not check for existing files when saving imported images to server!`;
            if (!force && blob)
                throw new Error(msgStart);

            const msg = `${msgStart}${force ? "" : ` The original image URL will be used instead.`}`;
            UtilNotifications.notifyOnce({
                type: "warn",
                message: msg
            });
            return force ? serverUrl : originalUrl;
        }

        if (dirListing?.files && dirListing?.files.map(it=>UtilFileBrowser.decodeUrl(it)).includes(serverUrl))
            return serverUrl;

        if (!this._canUploadFiles()) {
            if (!force && blob)
                throw new Error(`Your permission levels do not allow you to upload files!`);

            const msg = `You have the "Save Imported Images to Server" config option enabled, but your permission levels do not allow you to upload files!${force ? "" : ` The original image URL will be used instead.`}`;
            UtilNotifications.notifyOnce({
                type: "warn",
                message: msg
            });
            return force ? serverUrl : originalUrl;
        }

        if (!isDirExists) {
            try {
                await this._pSaveImageToServerAndGetUrl_pCreateDirectories(serverUrlDirParts);
            } catch (e) {
                const msgStart = `Could not create required directories when saving imported images to server!`;
                if (!force && blob)
                    throw new Error(msgStart);

                const msg = `${msgStart}${force ? "" : ` The original image URL will be used instead.`}`;
                UtilNotifications.notifyOnce({
                    type: "warn",
                    message: msg
                });
                return force ? serverUrl : originalUrl;
            }
        }

        try {
            blob = blob || await this._pSaveImageToServerAndGetUrl_pGetBlob(originalUrl);
        } catch (e) {
            const msg = `Failed to download image "${originalUrl}" when saving imported images to server!${force ? "" : ` The original image URL will be used instead.`} ${VeCt.STR_SEE_CONSOLE}`;
            UtilNotifications.notifyOnce({
                type: "warn",
                message: msg
            });
            console.error(...LGT, e);
            return force ? serverUrl : originalUrl;
        }

        const name = serverUrlPathParts.last();
        let mimeType = `image/${(name.split(".").last() || "").trim().toLowerCase()}`;
        if (mimeType === "image/jpg")
            mimeType = "image/jpeg";

        const resp = await FilePicker.upload("data", serverUrlDir, new File([blob],name,{
            lastModified: Date.now(),
            type: mimeType,
        },), {}, {
            notify: false,
        }, );
        if (resp?.path)
            return UtilFileBrowser.decodeUrl(resp.path);

        return force ? serverUrl : originalUrl;
    }

    static async _pSaveImageToServerAndGetUrl_pGetBlob(originalUrl) {
        const isBackend = await UtilBackend.pGetBackendVersion();

        try {
            const blobResp = await fetch(originalUrl);
            return blobResp.blob();
        } catch (e) {
            if (!isBackend)
                throw e;
            console.warn(...LGT, `Could not directly load image from ${originalUrl}\u2014falling back on alternate loader (backend mod).`);
        }

        const blobResp = await fetch(Config.backendEndpoint, {
            method: "post",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                type: "getBinaryData",
                url: originalUrl,
            }),
        }, );
        return blobResp.blob();
    }

    static async _pSaveImageToServerAndGetUrl_pCreateDirectories(serverUrlDirParts) {
        if (!serverUrlDirParts.length)
            return;
        for (let i = 0; i < serverUrlDirParts.length; ++i) {
            const dirPartSlice = serverUrlDirParts.slice(0, i + 1);
            try {
                await FilePicker.createDirectory("data", dirPartSlice.join("/"));
            } catch (e) {
                if (/EEXIST/.test(`${e}`))
                    continue;
                throw new Error(e);
            }
        }
    }

    static _canUploadFiles() {
        return game.isAdmin || (game.user && game.user.can("FILES_UPLOAD"));
    }

    static async pGetDirectoryListing({originalUrl=null, path=null, isSaveToRoot=false, isDirPath=false}) {
        if (originalUrl && isDirPath)
            throw new Error(`Arguments "originalUrl" and "isDirPath" are mutually exclusive`);
        if (!path && isDirPath)
            throw new Error(`Argument "isDirPath" requires the "path" argument to be passed!`);

        const {serverUrlDir} = this._getImageSavedToServerUrlMeta({
            originalUrl,
            path: path && isDirPath ? `${path}/stub` : path,
            isSaveToRoot,
        });

        let dirListing = null;
        let isDirExists = false;
        let isError = false;
        try {
            dirListing = await FilePicker.browse("data", serverUrlDir);
            if (dirListing?.target)
                isDirExists = true;
        } catch (e) {
            isError = !/Directory .*? does not exist/.test(`${e}`);
        }

        return {
            dirListing,
            isDirExists,
            isError,
        };
    }

    static async pGetAllSpells({isFilterNonStandard=false, additionalSourcesPrerelease=[], additionalSourcesBrew=[], isIncludeLoadedBrew=false, isIncludeLoadedPrerelease=false, isApplyBlocklist=false, }={}, ) {
        let spells = MiscUtil.copyFast(await DataUtil.spell.pLoadAll());

        if (isFilterNonStandard)
            spells = spells.filter(sp=>!SourceUtil.isNonstandardSource(sp.source));

        if (isIncludeLoadedPrerelease) {
            const prerelease = await PrereleaseUtil.pGetBrewProcessed();
            if (prerelease.spell?.length)
                spells = spells.concat(prerelease.spell);
        }

        if (isIncludeLoadedBrew) {
            const brew = await BrewUtil2.pGetBrewProcessed();
            if (brew.spell?.length)
                spells = spells.concat(brew.spell);
        }

        const pHandleAdditionalSources = async({additionalSources, pFnLoad})=>{
            for (const src of additionalSources) {
                const json = await pFnLoad(src);
                if (!json)
                    continue;
                if (json.spell?.length)
                    spells = spells.concat(json.spell);
            }
        }
        ;

        if (additionalSourcesPrerelease?.length)
            await pHandleAdditionalSources({
                additionalSources: additionalSourcesPrerelease,
                pFnLoad: DataUtil.pLoadPrereleaseBySource.bind(DataUtil)
            });
        if (additionalSourcesBrew?.length)
            await pHandleAdditionalSources({
                additionalSources: additionalSourcesBrew,
                pFnLoad: DataUtil.pLoadBrewBySource.bind(DataUtil)
            });

        if (isApplyBlocklist) {
            spells = spells.filter(sp=>!ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS](sp), "spell", sp.source, {
                isNoCount: true
            }, ), );
        }

        spells.forEach(sp=>Renderer.spell.initBrewSources(sp));

        return {
            spell: spells
        };
    }

    static async pGetAllCreatures(isFilterNonStandard=false) {
        let creatures = await DataUtil.monster.pLoadAll();

        if (isFilterNonStandard)
            creatures = creatures.filter(mon=>!SourceUtil.isNonstandardSource(mon.source));

        return {
            monster: creatures
        };
    }

    static async _pGetPrereleaseBrewIndices() {
        const out = {
            sourcePrerelease: {},
            propPrerelease: {},
            metaPrerelease: {},

            sourceBrew: {},
            propBrew: {},
            metaBrew: {},
        };

        try {
            const [sourceIndexPrerelease,propIndexPrerelease,metaIndexPrerelease,
            sourceIndexBrew,propIndexBrew,metaIndexBrew,] = await Promise.all([DataUtil.prerelease.pLoadSourceIndex(Config.get("dataSources", "basePrereleaseUrl")), DataUtil.prerelease.pLoadPropIndex(Config.get("dataSources", "basePrereleaseUrl")), DataUtil.prerelease.pLoadMetaIndex(Config.get("dataSources", "basePrereleaseUrl")),
            DataUtil.brew.pLoadSourceIndex(Config.get("dataSources", "baseBrewUrl")), DataUtil.brew.pLoadPropIndex(Config.get("dataSources", "baseBrewUrl")), DataUtil.brew.pLoadMetaIndex(Config.get("dataSources", "baseBrewUrl")), ]);

            out.sourcePrerelease = sourceIndexPrerelease;
            out.propPrerelease = propIndexPrerelease;
            out.metaPrerelease = metaIndexPrerelease;

            out.sourceBrew = sourceIndexBrew;
            out.propBrew = propIndexBrew;
            out.metaBrew = metaIndexBrew;
        } catch (e) {
            ui.notifications.error(`Failed to load prerelease/homebrew index! ${VeCt.STR_SEE_CONSOLE}`);
            setTimeout(()=>{
                throw e;
            }
            );
        }

        return out;
    }

    static async pGetPrereleaseSources(...dirs) {
        return this._pGetPrereleaseBrewSources({
            dirs,
            brewUtil: PrereleaseUtil,
            indexProp: Vetools.PRERELEASE_INDEX__PROP,
            indexMeta: Vetools.PRERELEASE_INDEX__META,
            configKey: "basePrereleaseUrl",
        });
    }

    static async pGetBrewSources(...dirs) {
        return this._pGetPrereleaseBrewSources({
            dirs,
            brewUtil: BrewUtil2,
            indexProp: Vetools.BREW_INDEX__PROP,
            indexMeta: Vetools.BREW_INDEX__META,
            configKey: "baseBrewUrl",
        });
    }

    static async _pGetPrereleaseBrewSources({dirs, brewUtil, indexProp, indexMeta, configKey}) {
        const urlRoot = Config.get("dataSources", configKey);

        let paths;
        if (dirs.includes("*")) {
            paths = Object.values(indexProp).map(obj=>Object.keys(obj)).flat().unique();
        } else {
            paths = dirs.map(dir=>Object.keys(indexProp[brewUtil.getDirProp(dir)] || {})).flat().unique();
        }

        return paths.map((path)=>{
            const metaName = UrlUtil.getFilename(path);
            return ({
                url: brewUtil.getFileUrl(path, urlRoot),
                name: this._getPrereleaseBrewName(path),
                abbreviations: indexMeta[metaName]?.a || [],
            });
        }
        ).sort((a,b)=>SortUtil.ascSortLower(a.name, b.name));
    }

    static _getPrereleaseBrewName(brewPath) {
        return brewPath.split("/").slice(-1).join("").replace(/\.json$/i, "");
    }

    static _LOCAL_PRERELEASE_SOURCE_SEEN_URLS = new Set();
    static async pGetLocalPrereleaseSources(...dirs) {
        return this._pGetLocalPrereleaseBrewSources({
            brewUtil: PrereleaseUtil,
            dirs,
            displayName: "prerelease",
            configKeyLocal: "localPrerelease",
            configKeyIsLoadIndex: "isLoadLocalPrereleaseIndex",
            configKeyIsUseIndex: "isUseLocalPrereleaseIndexJson",
            configKeyDirectoryPath: "localPrereleaseDirectoryPath",
            setSeenUrls: this._LOCAL_PRERELEASE_SOURCE_SEEN_URLS,
        });
    }

    static _LOCAL_BREW_SOURCE_SEEN_URLS = new Set();
    static async pGetLocalBrewSources(...dirs) {
        return this._pGetLocalPrereleaseBrewSources({
            brewUtil: BrewUtil2,
            dirs,
            displayName: "homebrew",
            configKeyLocal: "localHomebrew",
            configKeyIsLoadIndex: "isLoadLocalHomebrewIndex",
            configKeyIsUseIndex: "isUseLocalHomebrewIndexJson",
            configKeyDirectoryPath: "localHomebrewDirectoryPath",
            setSeenUrls: this._LOCAL_BREW_SOURCE_SEEN_URLS,
        });
    }

    static async _pGetLocalPrereleaseBrewSources({brewUtil, dirs, displayName, configKeyLocal, configKeyIsLoadIndex, configKeyIsUseIndex, configKeyDirectoryPath, setSeenUrls}) {
        try {
            const listLocal = await this._pGetLocalPrereleaseBrewList({
                displayName,
                configKeyIsLoadIndex,
                configKeyIsUseIndex,
                configKeyDirectoryPath,
            });

            const allFilenames = [...(listLocal || []), ...(Config.get("dataSources", configKeyLocal) || []), ];

            if (!allFilenames.length)
                return [];

            await allFilenames.pSerialAwaitMap(async name=>{
                if (setSeenUrls.has(name))
                    return;
                setSeenUrls.add(name);
                await brewUtil.pAddBrewFromUrl(name, {
                    isLazy: true
                });
            }
            );
            await brewUtil.pAddBrewsLazyFinalize();

            const brews = await allFilenames.pSerialAwaitMap(async name=>({
                url: name,
                data: await DataUtil.loadJSON(name),
                name: this._getPrereleaseBrewName(name),
            }));

            const desiredProps = new Set(dirs.map(dir=>brewUtil.getDirProp(dir)));

            return brews.filter(({data})=>{
                if (desiredProps.has("*"))
                    return true;

                const propsInBrew = new Set([...Object.keys(data || {}).filter(it=>!it.startsWith("_")), ...Object.keys(data?._meta?.includes || {}), ]);

                return [...desiredProps].some(it=>propsInBrew.has(it));
            }
            ).map(it=>{
                it.abbreviations = (it.data?._meta?.sources || []).map(it=>it.abbreviation).filter(Boolean);
                return it;
            }
            ).map(({name, url, abbreviations})=>({
                name,
                url,
                abbreviations
            }));
        } catch (e) {
            const msg = `Failed to load local homebrew index!`;
            console.error(...LGT, msg, e);
            ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
        }
        return [];
    }

    static async _pGetLocalPrereleaseBrewList({displayName, configKeyIsLoadIndex, configKeyIsUseIndex, configKeyDirectoryPath}) {
        if (!Config.get("dataSources", configKeyIsLoadIndex))
            return null;

        const isUseIndexJson = Config.get("dataSources", configKeyIsUseIndex);

        if (isUseIndexJson) {
            const indexUrl = `${Config.get("dataSources", configKeyDirectoryPath)}/index.json`.replace(/\/+/g, "/");
            const index = await DataUtil.loadJSON(indexUrl);
            if (!index?.toImport)
                return [];
            return index.toImport.map(it=>{
                if (Vetools._RE_HTTP_URL.test(it))
                    return it;

                return [...indexUrl.split("/").slice(0, -1), it].join("/");
            }
            );
        }

        try {
            const existingFiles = await FilePicker.browse("data", Config.get("dataSources", configKeyDirectoryPath));
            if (!existingFiles?.files?.length)
                return null;

            return existingFiles.files.map(it=>decodeURIComponent(it));
        } catch (e) {
            const ptReason = /You do not have permission to browse the host file system/i.test(e.message) ? `You do not have "Use File Browser" permissions!` : `Does the ${isUseIndexJson ? "file" : "directory"} "<data_dir>/${Config.get("dataSources", configKeyDirectoryPath)}${isUseIndexJson ? "/index.json" : ""}" exist?`;
            const msg = `Failed to load local ${displayName}${isUseIndexJson ? " index" : ""}! ${ptReason}`;
            console.error(...LGT, msg, e);
            ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
            return null;
        }
    }

    static async pGetSpellSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/spells/foundry.json`);
    }
    static async pGetOptionalFeatureSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-optionalfeatures.json`);
    }
    static async pGetClassSubclassSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/class/foundry.json`);
    }
    static async pGetRaceSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-races.json`);
    }
    static async pGetItemSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-items.json`);
    }
    static async pGetFeatSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-feats.json`);
    }
    static async pGetRewardSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-rewards.json`);
    }
    static async pGetActionSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-actions.json`);
    }
    static async pGetVehicleUpgradeSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-vehicles.json`);
    }
    static async pGetCreatureSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/bestiary/foundry.json`);
    }
    static async pGeBackgroundSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-backgrounds.json`);
    }
    static async pGetPsionicsSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-psionics.json`);
    }

    static async pGetConditionDiseaseSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-conditionsdiseases.json`);
    }
    static async pGetObjectSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-objects.json`);
    }
    static async pGetVehicleSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-vehicles.json`);
    }
    static async pGetCharCreationOptionSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-charcreationoptions.json`);
    }
    static async pGetCultBoonSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-cultsboons.json`);
    }
    static async pGetTrapHazardSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-trapshazards.json`);
    }
    static async pGetDeckSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-decks.json`);
    }
    static async pGetDeitySideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-deities.json`);
    }
    static async pGetTableSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-tables.json`);
    }
    static async pGetLanguageSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-languages.json`);
    }
    static async pGetRecipeSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-recipes.json`);
    }
    static async pGetVariantruleSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-variantrules.json`);
    }

    static async pGetCreatureFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }
    static async pGetObjectFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }
    static async pGetVehicleFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }
    static async pGetTrapFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }

    static getModuleDataUrl(filename) {
        return `modules/${SharedConsts.MODULE_ID}/data/${filename}`;
    }

    static async pGetIconLookup(entityType) {
        return DataUtil.loadJSON(this.getModuleDataUrl(`icon-${entityType}s.json`));
    }

    static get BASE_SITE_URL() {
        if (this._isCustomBaseSiteUrl()) {
            return Util.getCleanServerUrl(Config.get("dataSources", "baseSiteUrl"));
        }
        return Vetools._BASE_SITE_URL;
    }

    static _isCustomBaseSiteUrl() {
        const val = Config.get("dataSources", "baseSiteUrl");
        return !!(val && val.trim());
    }

    static get DATA_URL_FEATS() {
        return `${Vetools.BASE_SITE_URL}data/feats.json`;
    }
    static get DATA_URL_BACKGROUNDS() {
        return `${Vetools.BASE_SITE_URL}data/backgrounds.json`;
    }
    static get DATA_URL_VARIANTRULES() {
        return `${Vetools.BASE_SITE_URL}data/variantrules.json`;
    }
    static get DATA_URL_PSIONICS() {
        return `${Vetools.BASE_SITE_URL}data/psionics.json`;
    }
    static get DATA_URL_OPTIONALFEATURES() {
        return `${Vetools.BASE_SITE_URL}data/optionalfeatures.json`;
    }
    static get DATA_URL_CONDITIONSDISEASES() {
        return `${Vetools.BASE_SITE_URL}data/conditionsdiseases.json`;
    }
    static get DATA_URL_VEHICLES() {
        return `${Vetools.BASE_SITE_URL}data/vehicles.json`;
    }
    static get DATA_URL_REWARDS() {
        return `${Vetools.BASE_SITE_URL}data/rewards.json`;
    }
    static get DATA_URL_OBJECTS() {
        return `${Vetools.BASE_SITE_URL}data/objects.json`;
    }
    static get DATA_URL_DEITIES() {
        return `${Vetools.BASE_SITE_URL}data/deities.json`;
    }
    static get DATA_URL_RECIPES() {
        return `${Vetools.BASE_SITE_URL}data/recipes.json`;
    }
    static get DATA_URL_CHAR_CREATION_OPTIONS() {
        return `${Vetools.BASE_SITE_URL}data/charcreationoptions.json`;
    }
    static get DATA_URL_CULTSBOONS() {
        return `${Vetools.BASE_SITE_URL}data/cultsboons.json`;
    }
    static get DATA_URL_ACTIONS() {
        return `${Vetools.BASE_SITE_URL}data/actions.json`;
    }
    static get DATA_URL_LANGUAGES() {
        return `${Vetools.BASE_SITE_URL}data/languages.json`;
    }
    static get DATA_URL_TRAPS_HAZARDS() {
        return `${Vetools.BASE_SITE_URL}data/trapshazards.json`;
    }
}
Vetools._RE_HTTP_URL = /(^https?:\/\/)/;
Vetools._BASE_SITE_URL = "https://5etools-mirror-1.github.io/";
Vetools.BESTIARY_FLUFF_INDEX = null;
Vetools.BESTIARY_TOKEN_LOOKUP = null;
Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE = null;
Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE = null;
Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS = null;
Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET = null;
Vetools._LOCK_DOWNLOAD_IMAGE = new VeLock();
Vetools._VET_SOURCE_LOOKUP = {};
//#endregion

//#region SharedConsts
class SharedConsts {
    static MODULE_TITLE = "Plutonium";
    static MODULE_TITLE_FAKE = "SRD: Enhanced";
    static MODULE_ID = "plutonium";
    static MODULE_ID_FAKE = "srd5e";

    static PACK_NAME_CREATURES = "creatures";
    static PACK_NAME_SPELLS = "spells";
    static PACK_NAME_ITEMS = "items";

    static MODULE_LOCATION = `modules/${SharedConsts.MODULE_ID}`;

    static SYSTEM_ID_DND5E = "dnd5e";
}
//#endregion

//#region DataLoader


//#endregion

//#region Util
class Util {
    static _getLogTag() {
        return [`%cPlutonium`, `color: #337ab7; font-weight: bold;`, `|`, ];
    }

    static isDebug() {
        return !!CONFIG?.debug?.module?.[SharedConsts.MODULE_ID];
    }

    static _HEIGHT_MAX_OFFSET = 160;
    static getMaxWindowHeight(desiredHeight) {
        const targetHeight = Math.min(desiredHeight || Number.MAX_SAFE_INTEGER, document.documentElement.clientHeight - this._HEIGHT_MAX_OFFSET);
        return Math.max(this._HEIGHT_MAX_OFFSET, targetHeight);
    }

    static _WIDTH_MAX_OFFSET = 250;
    static getMaxWindowWidth(desiredWidth) {
        const targetWidth = Math.min(desiredWidth || Number.MAX_SAFE_INTEGER, document.documentElement.clientWidth - this._WIDTH_MAX_OFFSET);
        return Math.max(this._WIDTH_MAX_OFFSET, targetWidth);
    }

    static getWithoutParens(str) {
        return str.replace(/\([^)]+\)/g, "").trim();
    }
    static getTokens(str) {
        return str.split(/([ ,:;()"])/g).filter(Boolean);
    }
    static isPunctuation(token) {
        return /[,:;()"]/.test(token);
    }
    static isCapsFirst(word) {
        return /^[A-Z]/.test(word);
    }
    static getSentences(str) {
        return str.replace(/ +/g, " ").split(/[.?!]/g).map(it=>it.trim()).filter(Boolean);
    }

    static getRounded(n, dp) {
        return Number(n.toFixed(dp));
    }

    static trimObject(obj) {
        const walker = MiscUtil.getWalker({
            isAllowDeleteObjects: true,
            isDepthFirst: true,
        });

        return walker.walk(obj, {
            object: (it)=>{
                Object.entries(it).forEach(([k,v])=>{
                    if (v === undefined)
                        delete it[k];
                }
                );
                if (!Object.keys(it).length)
                    return undefined;
                return it;
            }
            ,
        }, );
    }

    static getCleanServerUrl(url) {
        return url.replace(/^(.*?)\/*$/, "$1/");
    }
}

const LGT = Util._getLogTag();
Util.Fvtt = class {
    static getOwnershipEnum({isIncludeDefault=false}={}) {
        return [isIncludeDefault ? {
            value: -1,
            name: "Default"
        } : null, ...Object.entries(CONST.DOCUMENT_OWNERSHIP_LEVELS).map(([name,value])=>({
            value,
            name: name.toTitleCase(),
        })), ].filter(Boolean);
    }

    static getMinimumRolesEnum() {
        return [...Object.entries(CONST.USER_ROLES).map(([name,value])=>({
            value,
            name: name.toTitleCase(),
        })), {
            value: CONST.USER_ROLES.GAMEMASTER + 1,
            name: `Cheater (Disable Feature)`,
        }, ];
    }

    static canUserCreateFolders() {
        return game.user.isGM;
    }
}
;
//#endregion
//#region UtilCompat
class UtilCompat {
    static isModuleActive(moduleId) {
        return !!game.modules.get(moduleId)?.active;
    }

    static _MODULE_LIB_WRAPPER = "lib-wrapper";
    static MODULE_DAE = "dae";
    static _MODULE_DRAG_UPLOAD = "dragupload";
    static MODULE_MIDI_QOL = "midi-qol";
    static MODULE_KANKA_FOUNDRY = "kanka-foundry";
    static MODULE_SMOL_FOUNDRY = "smol-foundry";
    static MODULE_PERMISSION_VIEWER = "permission_viewer";
    static _MODULE_TWILIGHT_UI = "twilight-ui";
    static MODULE_TIDY5E_SHEET = "tidy5e-sheet";
    static _MODULE_OBSIDIAN = "obsidian";
    static MODULE_BABELE = "babele";
    static MODULE_MONKS_LITTLE_DETAILS = "monks-little-details";
    static MODULE_MONKS_BLOODSPLATS = "monks-bloodsplats";
    static MODULE_MONKS_ENHANCED_JOURNAL = "monks-enhanced-journal";
    static MODULE_BETTER_ROLLTABLES = "better-rolltables";
    static _MODULE_BETTER_ROLLTABLES = "item-piles";
    static MODULE_PLUTONIUM_ADDON_AUTOMATION = "plutonium-addon-automation";
    static MODULE_LEVELS = "levels";
    static MODULE_MULTICLASS_SPELLBOOK_FILTER = "spell-class-filter-for-5e";
    static MODULE_ROLLDATA_AWARE_ACTIVE_EFFECTS = "fvtt-rolldata-aware-active-effects";
    static MODULE_QUICK_INSERT = "quick-insert";
    static MODULE_PF2E_TOKENS_BESTIARIES = "pf2e-tokens-bestiaries";
    static _MODULE_DFREDS_CONVENIENT_EFFECTS = "dfreds-convenient-effects";
    static MODULE_LEVELS_3D_PREVIEW = "levels-3d-preview";
    static _MODULE_CANVAS_3D_COMPENDIUM = "canvas3dcompendium";
    static _MODULE_CANVAS_3D_TOKEN_COMPENDIUM = "canvas3dtokencompendium";
    static _MODULE_FOUNDRY_SUMMONS = "foundry-summons";
    static _MODULE_TOKEN_ACTION_HUD = "token-action-hud";
    static _MODULE_TOKEN_ACTION_HUD_CORE = "token-action-hud-core";
    static MODULE_SIMPLE_CALENDAR = "foundryvtt-simple-calendar";

    static isLibWrapperActive() {
        return this.isModuleActive(UtilCompat._MODULE_LIB_WRAPPER);
    }
    static isDaeActive() {
        return this.isModuleActive(UtilCompat.MODULE_DAE);
    }
    static isDragUploadActive() {
        return this.isModuleActive(UtilCompat._MODULE_DRAG_UPLOAD);
    }
    static isPermissionViewerActive() {
        return this.isModuleActive(UtilCompat.MODULE_PERMISSION_VIEWER);
    }
    static isSmolFoundryActive() {
        return this.isModuleActive(UtilCompat.MODULE_SMOL_FOUNDRY);
    }
    static isTwilightUiActive() {
        return this.isModuleActive(UtilCompat._MODULE_TWILIGHT_UI);
    }
    static isTidy5eSheetActive() {
        return this.isModuleActive(UtilCompat.MODULE_TIDY5E_SHEET);
    }
    static isObsidianActive() {
        return this.isModuleActive(UtilCompat._MODULE_OBSIDIAN);
    }
    static isBabeleActive() {
        return this.isModuleActive(UtilCompat.MODULE_BABELE);
    }
    static isMonksLittleDetailsActive() {
        return this.isModuleActive(UtilCompat.MODULE_MONKS_LITTLE_DETAILS);
    }
    static isMonksBloodsplatsActive() {
        return this.isModuleActive(UtilCompat.MODULE_MONKS_BLOODSPLATS);
    }
    static isBetterRolltablesActive() {
        return this.isModuleActive(UtilCompat.MODULE_BETTER_ROLLTABLES);
    }
    static isItemPilesActive() {
        return this.isModuleActive(UtilCompat._MODULE_BETTER_ROLLTABLES);
    }
    static isPlutoniumAddonAutomationActive() {
        return this.isModuleActive(UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION);
    }
    static isMidiQolActive() {
        return this.isModuleActive(UtilCompat.MODULE_MIDI_QOL);
    }
    static isModuleMulticlassSpellbookFilterActive() {
        return this.isModuleActive(UtilCompat.MODULE_MULTICLASS_SPELLBOOK_FILTER);
    }
    static isQuickInsertActive() {
        return this.isModuleActive(UtilCompat.MODULE_QUICK_INSERT);
    }
    static isPf2eTokensBestiaryActive() {
        return this.isModuleActive(UtilCompat.MODULE_PF2E_TOKENS_BESTIARIES);
    }
    static isDfredsConvenientEffectsActive() {
        return this.isModuleActive(UtilCompat._MODULE_DFREDS_CONVENIENT_EFFECTS);
    }
    static isLevels3dPreviewActive() {
        return this.isModuleActive(UtilCompat.MODULE_LEVELS_3D_PREVIEW);
    }
    static _isCanvas3dCompendiumActive() {
        return this.isModuleActive(UtilCompat._MODULE_CANVAS_3D_COMPENDIUM);
    }
    static _iCanvas3dTokenCompendiumActive() {
        return this.isModuleActive(UtilCompat._MODULE_CANVAS_3D_TOKEN_COMPENDIUM);
    }
    static isFoundrySummonsActive() {
        return this.isModuleActive(UtilCompat._MODULE_FOUNDRY_SUMMONS);
    }
    static isTokenActionHudActive() {
        return this.isModuleActive(UtilCompat._MODULE_TOKEN_ACTION_HUD) || this.isModuleActive(UtilCompat._MODULE_TOKEN_ACTION_HUD_CORE);
    }
    static isSimpleCalendarActive() {
        return this.isModuleActive(UtilCompat.MODULE_SIMPLE_CALENDAR);
    }

    static isThreeDiTokensActive() {
        return this.isLevels3dPreviewActive() && this._isCanvas3dCompendiumActive() && this._iCanvas3dTokenCompendiumActive();
    }

    static getApi(moduleName) {
        if (!this.isModuleActive(moduleName))
            return null;
        return game.modules.get(moduleName).api;
    }

    static getName(moduleName) {
        if (!this.isModuleActive(moduleName))
            return null;
        return game.modules.get(moduleName).title;
    }

    static isDaeGeneratingArmorEffects() {
        if (!this.isDaeActive())
            return false;
        return !!UtilGameSettings.getSafe(UtilCompat.MODULE_DAE, "calculateArmor");
    }

    static getFeatureFlags({isReaction}) {
        const out = {};

        if (isReaction) {
            out.adnd5e = {
                itemInfo: {
                    type: "reaction"
                }
            };
        }

        return out;
    }

    static MonksLittleDetails = class {
        static isDefeated(token) {
            return ((token.combatant && token.isDefeated) || token.actor?.effects.some(it=>it.statuses.has(CONFIG.specialStatusEffects.DEFEATED)) || token.document.overlayEffect === CONFIG.controlIcons.defeated);
        }
    }
    ;

    static DfredsConvenientEffects = class {
        static getCustomEffectsItemId() {
            return UtilGameSettings.getSafe(UtilCompat._MODULE_DFREDS_CONVENIENT_EFFECTS, "customEffectsItemId");
        }
    }
    ;

    static FoundrySummons = class {
        static getBlankNpcIds() {
            return (UtilGameSettings.getSafe(UtilCompat._MODULE_FOUNDRY_SUMMONS, "blankNPC") || []).map(it=>it?.id).filter(Boolean);
        }
    }
    ;
}
//#endregion
//#region ConfigConsts
class ConfigConsts {
    static ["_flushCaches"]() {
      this._DEFAULT_CONFIG = null;
      this._DEFAULT_CONFIG_SORTED = null;
      this._DEFAULT_CONFIG_SORTED_FLAT = null;
    }
    static ['_IMPORTERS'] = {};
    static ["registerImporter"]({
      id: _0x17cd9e,
      name: _0x948c81
    }) {
      this._IMPORTERS[_0x17cd9e] = _0x948c81;
      this._flushCaches();
    }
    static ["_template_getImporterToggles"]() {
      return {
        'hiddenImporterIds': {
          'name': "Hidden Importers",
          'help': "Importers which should not be shown in the Import Wizard UI.",
          'default': {
            'background-features': true,
            'race-and-subrace-features': true
          },
          'type': 'multipleChoice',
          'choices': Object.entries(this._IMPORTERS).map(([_0x40fcfd, _0x286521]) => ({
            'name': _0x286521,
            'value': _0x40fcfd
          })).sort(({
            name: _0x5ca503
          }, {
            name: _0x44f71d
          }) => SortUtil.ascSortLower(_0x5ca503, _0x44f71d))
        }
      };
    }
    static ['_getModelBarAttributes'](_0x2c6d2c) {
      if (!_0x2c6d2c) {
        return [];
      }
      return Object.values(TokenDocument.implementation.getTrackedAttributeChoices(TokenDocument.implementation.getTrackedAttributes(_0x2c6d2c))).flat();
    }
    static ['_template_getEntityOwnership'](_0x1b27c6) {
      const _0x2971c8 = MiscUtil.copy(ConfigConsts._TEMPLATE_ENTITY_OWNERSHIP);
      _0x2971c8.values = Util.Fvtt.getOwnershipEnum();
      _0x2971c8.help = _0x1b27c6;
      return _0x2971c8;
    }
    static ["_template_getTokenSettings"]({
      actorType: _0x1701bd
    }) {
      return {
        'tokenNameDisplay': {
          'name': "Token Name Display Mode",
          'help': "The default Display Name mode for imported tokens.",
          'default': 0x14,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...Object.entries({
            ...CONST.TOKEN_DISPLAY_MODES
          }).sort(([, _0x11b4dd], [, _0x418ae3]) => SortUtil.ascSort(_0x11b4dd, _0x418ae3)).map(([_0x1c91ac, _0x536776]) => ({
            'value': _0x536776,
            'fnGetName': () => game.i18n.localize('TOKEN.DISPLAY_' + _0x1c91ac)
          }))]
        },
        'tokenDisposition': {
          'name': "Token Disposition",
          'help': "The default Token Disposition mode for imported tokens.",
          'default': -0x1,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...Object.entries(CONST.TOKEN_DISPOSITIONS).sort(([, _0x153b2c], [, _0x397446]) => SortUtil.ascSort(_0x153b2c, _0x397446)).map(([_0x2e1787, _0x29a452]) => ({
            'value': _0x29a452,
            'fnGetName': () => game.i18n.localize("TOKEN.DISPOSITION." + _0x2e1787)
          }))]
        },
        'tokenLockRotation': {
          'name': "Token Lock Rotation",
          'help': "The default Lock Rotation mode for imported tokens.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenIsAddVision': {
          'name': "Enable Token Vision",
          'help': "Enable vision for tokens.",
          'default': ConfigConsts.C_BOOL_ENABLED,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_BOOL_DISABLED,
            'name': "Disabled"
          }, {
            'value': ConfigConsts.C_BOOL_ENABLED,
            'name': 'Enabled'
          }]
        },
        'tokenSightRange': {
          'name': "Token Vision Range",
          'help': "How token Vision Range should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenSightVisionMode': {
          'name': "Token Vision Mode",
          'help': "How token Vision Mode should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenSightAngle': {
          'name': "Token Sight Angle",
          'help': "How token Sight Angle (Degrees) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenDetectionModes': {
          'name': "Token Detection Modes",
          'help': "How token Detection Modes should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenVisionSaturation': {
          'name': "Token Vision Saturation",
          'help': "How token vision Saturation should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenDimLight': {
          'name': "Token Dim Light Radius",
          'help': "How token Dim Light Radius (Distance) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenBrightLight': {
          'name': "Token Bright Light Radius",
          'help': "How token Bright Light Radius (Distance) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAngle': {
          'name': "Token Light Emission Angle",
          'help': "How token Light Emission (Angle) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightColor': {
          'name': "Token Light Color",
          'help': "How token Light Color should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAlpha': {
          'name': "Token Light Intensity",
          'help': "How token Color Intensity should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAnimationType': {
          'name': "Token Light Animation Type",
          'help': "How token Light Animation Type should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAnimationSpeed': {
          'name': "Token Light Animation Speed",
          'help': "How token Light Animation Speed should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAnimationIntensity': {
          'name': "Token Light Animation Intensity",
          'help': "How token Light Animation Intensity should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenBarDisplay': {
          'name': "Token Bar Display Mode",
          'help': "The default Display Bars mode for imported tokens.",
          'default': 0x28,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': 0x0,
            'name': "None"
          }, {
            'value': 0xa,
            'name': 'Control'
          }, {
            'value': 0x14,
            'name': "Owner Hover"
          }, {
            'value': 0x1e,
            'name': 'Hover'
          }, {
            'value': 0x28,
            'name': 'Owner'
          }, {
            'value': 0x32,
            'name': "Always"
          }]
        },
        'tokenBar1Attribute': {
          'name': "Token Bar 1 Attribute",
          'help': "The default token bar 1 attribute for imported tokens.",
          'default': "attributes.hp",
          'type': "enum",
          'values': () => [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...ConfigConsts._getModelBarAttributes(_0x1701bd)],
          'isNullable': true
        },
        'tokenBar2Attribute': {
          'name': "Token Bar 2 Attribute",
          'help': "The default token bar 2 attribute for imported tokens.",
          'default': null,
          'type': "enum",
          'values': () => [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...ConfigConsts._getModelBarAttributes(_0x1701bd)],
          'isNullable': true
        },
        'tokenScale': {
          'name': "Token Scale",
          'help': "The default token scale for imported tokens.",
          'default': null,
          'type': "number",
          'placeholder': "(Use default)",
          'min': 0.2,
          'max': 0x3,
          'isNullable': true
        },
        'isTokenMetric': {
          'name': "Convert Token Vision Ranges to Metric",
          'help': "Whether or not token vision range units should be converted to an approximate metric equivalent (5 feet ≈ 1.5 metres).",
          'default': false,
          'type': "boolean"
        }
      };
    }
    static ["_template_getSceneImportSettings"]() {
      return {
        'scenePadding': {
          'name': "Scene Padding",
          'help': "The amount of scene padding to apply when creating a scene.",
          'default': 0x0,
          'type': "number",
          'min': 0x0,
          'max': 0.5
        },
        'sceneBackgroundColor': {
          'name': "Scene Background Color",
          'help': "The background color to apply when creating a scene.",
          'default': "#222222",
          'type': "color"
        },
        'isSceneTokenVision': {
          'name': "Scene Token Vision",
          'help': "Whether or not token vision should be enabled for a created scene.",
          'default': true,
          'type': "boolean"
        },
        'isSceneFogExploration': {
          'name': "Scene Fog Exploration",
          'help': "Whether or not fog exploration should be enabled for a created scene.",
          'default': true,
          'type': "boolean"
        },
        'isSceneAddToNavigation': {
          'name': "Add Scenes to Navigation",
          'help': "Whether or not a created scene should be added to the navigation bar.",
          'default': false,
          'type': "boolean"
        },
        'isSceneGenerateThumbnail': {
          'name': "Generate Scene Thumbnails",
          'help': "Whether or not a thumbnail should be generated for a created scene. Note that this greatly slows down the scene creation process.",
          'default': true,
          'type': "boolean"
        },
        'isSceneGridMetric': {
          'name': "Convert Scene Grid Distances to Metric",
          'help': "Whether or not scene grid distances should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + "; " + ConfigConsts._DISP_METRIC_MILES + ').',
          'default': false,
          'type': "boolean"
        }
      };
    }
    static ["_template_getActiveEffectsDisabledTransferSettings"]({
      name: _0x535a83
    }) {
      return {
        'setEffectDisabled': {
          'name': "Override Effect &quot;Disabled&quot; Value",
          'help': "If set, overrides the \"Disabled\" value present on any effects tied to imported " + _0x535a83 + '.',
          'type': 'enum',
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'compatibilityModeValues': {
            [UtilCompat.MODULE_MIDI_QOL]: {
              'value': ConfigConsts.C_USE_PLUT_VALUE,
              'name': "Allow importer to set"
            }
          },
          'values': [{
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }, {
            'value': ConfigConsts.C_BOOL_DISABLED,
            'name': "Set to \"False\""
          }, {
            'value': ConfigConsts.C_BOOL_ENABLED,
            'name': "Set to \"True\""
          }]
        },
        'setEffectTransfer': {
          'name': "Override Effect &quot;Transfer&quot; Value",
          'help': "If set, overrides the \"Transfer to Actor\" value present on any effects tied to imported " + _0x535a83 + '.',
          'type': 'enum',
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'compatibilityModeValues': {
            [UtilCompat.MODULE_MIDI_QOL]: {
              'value': ConfigConsts.C_USE_PLUT_VALUE,
              'name': "Allow importer to set"
            }
          },
          'values': [{
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }, {
            'value': ConfigConsts.C_BOOL_DISABLED,
            'name': "Set to \"False\""
          }, {
            'value': ConfigConsts.C_BOOL_ENABLED,
            'name': "Set to \"True\""
          }]
        }
      };
    }
    static ["_template_getMinimumRole"]({
      name: _0x2cb847,
      help: _0x713a
    }) {
      const _0xdadcbd = MiscUtil.copy(ConfigConsts._TEMPALTE_MINIMUM_ROLE);
      _0xdadcbd.values = Util.Fvtt.getMinimumRolesEnum();
      _0xdadcbd.name = _0x2cb847;
      _0xdadcbd.help = _0x713a;
      return _0xdadcbd;
    }
    static ['_template_getModuleFauxCompendiumIndexSettings']({
      moduleName: _0x5afcb7
    }) {
      return {
        'isEnabled': {
          'name': "Enabled",
          'help': "If enabled, and the " + _0x5afcb7 + " module is active, Plutonium content will be indexed by " + _0x5afcb7 + '.',
          'default': true,
          'type': "boolean",
          'isReloadRequired': true
        },
        'isFilterSourcesUa': {
          'name': "Exclude UA/etc.",
          'help': "If Unearthed Arcana and other unofficial source content should be excluded from the index.",
          'default': true,
          'type': "boolean",
          'isReloadRequired': true
        }
      };
    }
    static ["_template_getActorImportOverwriteSettings"]() {
      return {
        'isDisableActorOverwriteWarning': {
          'name': "Disable Actor Overwrite Warning",
          'help': "Disable the warning confirmation dialogue shown when importing to an existing actor.",
          'default': false,
          'type': "boolean",
          'isPlayerEditable': true
        }
      };
    }
    static ["_template_getTargetTemplatePrompt"]({
      namePlural: _0x1f80cf
    }) {
      return {
        'isTargetTemplatePrompt': {
          'name': "Enable &quot;Template Prompt&quot;s",
          'help': "If enabled, the \"Template Prompt\" option will be set on imported " + _0x1f80cf + '.',
          'default': true,
          'type': "boolean",
          'isPlayerEditable': true
        }
      };
    }
    static ["_DEFAULT_CONFIG"] = null;
    static ["getDefaultConfig_"]() {
      return this._DEFAULT_CONFIG = this._DEFAULT_CONFIG || {
        'ui': {
          'name': 'UI',
          'settings': {
            'isStreamerMode': {
              'name': "Streamer Mode",
              'help': "Remove identifiable 5etools/Plutonium references from the UI, and replaces them with \"SRD Enhanced.\"",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true,
              'isPlayerEditable': true
            },
            'isShowPopout': {
              'name': "Enable Sheet Popout Buttons",
              'help': "Add a \"Popout\" button to sheet headers, which opens the sheet as a popup browser window.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isCompactWindowBar': {
              'name': "Compact Header Buttons",
              'help': "Re-style header buttons to better support the compact, no-text buttons used by Plutonium.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactDirectoryButtons': {
              'name': "Compact Directory Buttons",
              'help': "Reduce the height of \"Create X\"/\"Create Folder\" buttons in the directory, to offset the additional space requirements of Plutonium's UI.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactChat': {
              'name': "Compact Chat",
              'help': "Make various tweaks to the appearance of chat, in order to fit more on-screen. Hold down SHIFT while hovering over a message to expand it, revealing its header and delete button.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactScenes': {
              'name': "Compact Scenes Directory",
              'help': "Reduce the height of scene thumbnails in the Scenes Directory, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactActors': {
              'name': "Compact Actors Directory",
              'help': "Reduce the height of Actors Directory directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactItems': {
              'name': "Compact Items Directory",
              'help': "Reduce the height of Items Directory directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactJournal': {
              'name': "Compact Journal Entries",
              'help': "Reduce the height of Journal Entries directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactTables': {
              'name': "Compact Rollable Tables",
              'help': "Reduce the height of Rollable Tables directory items, to fit more on-screen.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isCompactCards': {
              'name': "Compact Card Stacks",
              'help': "Reduce the height of Card Stacks directory items, to fit more on-screen.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isCompactCompendiums': {
              'name': "Compact Compendium Packs",
              'help': "Reduce the height of Compendium Packs directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactMacros': {
              'name': "Compact Macros",
              'help': "Reduce the height of Macro directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isHidePlutoniumDirectoryButtons': {
              'name': "Hide Directory Buttons",
              'help': "Hide the Plutonium directory buttons.",
              'default': false,
              'type': 'boolean'
            },
            'isNameTabFromScene': {
              'name': "Prepend Active Scene Name to Browser Tab Name",
              'help': "Sets the browser tab name to be that of the currently-active scene.",
              'default': true,
              'type': 'boolean'
            },
            'tabNameSuffix': {
              'name': "Tab Name Suffix",
              'help': "Requires the \"Name Browser Tab After Active Scene\" option to be enabled. A custom name suffix to append to the scene name displayed in the tab (separated by a Foundry-style bullet character).",
              'default': null,
              'isNullable': true,
              'type': "string"
            },
            'isDisplayBackendStatus': {
              'name': "Display Detected Backend",
              'help': "Adds a cool green hacker tint to the Foundry \"anvil\" logo in the top-left corner of the screen if Plutonium's backend is detected.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isExpandActiveEffectConfig': {
              'name': "Enhance Active Effect Config UI",
              'help': "Adds a list of potential active effect attribute keys to the Configure Active Effect window's \"Effects\" tab, and a field for configuring priority.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_DAE]: false
              }
            },
            'isAddDeleteToSceneNavOptions': {
              'name': "Add \"Delete\" to Navbar Scene Context Menu",
              'help': "Adds a \"Delete\" option to the context menu found when right-clicking a scene in the navigation bar. Note that this does not include the currently-active scene.",
              'default': true,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'isHideGmOnlyConfig': {
              'name': "Hide GM-Only Config",
              'help': "If enabled, a player viewing the config will see only the limited subset of settings they are allowed to modify. If disabled, a player viewing the config will see all settings, regardless of whether or not they can modify those settings.",
              'default': true,
              'type': 'boolean'
            },
            'isDisableLargeImportWarning': {
              'name': "Disable Large Import Warning",
              'help': "Disable the warning confirmation dialogue shown when importing a large number of entities.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          },
          'settingsHacks': {
            'isFastAnimations': {
              'name': "Fast Animations",
              'help': "Increase the speed of various UI animations.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isFastTooltips': {
              'name': "Fast Tooltips",
              'help': "Increase the speed of tooltip animations, and reduce the delay before tooltips appear.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isFixEscapeKey': {
              'name': "Fix ESC Key",
              'help': "Bind the \"Escape\" key to (in this order): de-select active input fields; de-select selected canvas elements; close context menus; close individual windows in most-recently-active-first order; toggle the main menu.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isAddOpenMainMenuButtonToSettings': {
              'name': "Add \"Open Game Menu\" Button if &quot;Fix ESC Key&quot; Is Enabled",
              'help': "Add an alternate \"Open Game Menu\" button to the Settings tab if the \"Fix ESC Key\" Config option is enabled. This allows you to quickly open the main menu without first having to close all open windows.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isFixDrawingFreehandMinDistance': {
              'name': "Fix Freehand Drawing Minimum Distance",
              'help': "Reduce the minimum mouse movement distance required to start a freehand drawing.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isEnableIncreasedFolderDepth': {
              'name': "Render >3 Levels of Folder Nesting",
              'help': "If enabled, Foundry's default folder nesting limit (of 3) will be bypassed, for the purpose of rendering directories. Note that this does not necessarily allow you to create additionally-nested folders without using the game API.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_BETTER_ROLLTABLES]: false
              }
            },
            'isEnableFolderNameWrap': {
              'name': "Wrap Long Folder Names",
              'help': "Wrap long folder names over multiple lines, instead of clipping the name.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isEnableSubPopouts': {
              'name': "Allow Popout Chaining",
              'help': "Automatically pop out apps opened from within popped-out apps. If disabled, apps opened from within popped-out apps will appear in the main window, instead.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isSuppressMissingRollDataNotifications': {
              'name': "Suppress &quot;Missing Roll Data&quot; Notifications",
              'help': "If enabled, notification warning  messages of the form \"The attribute <X> was not present in the provided roll data.\" will be suppressed, and logged as console warnings instead.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isLazyActorAndItemRendering': {
              'name': "Minimize Actor/Item Re-Renders",
              'help': "If enabled, actor/item sheet re-rendering will be skipped where possible. This may reduce UI flickering, and may reduce unexpected input deselection when tabbing or clicking through fields. It may also horribly break your game, and is not expected to work with anything except default dnd5e sheets. Use with caution.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true,
              'isReloadRequired': true
            },
            'isAlwaysResizableApps': {
              'name': "Default Resizeable Applications",
              'help': "If enabled, applications will be resizeable by default. Note that specific applications may still override this.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          }
        },
        'tokens': {
          'name': 'Tokens',
          'settings': {
            'isDisplayDamageDealt': {
              'name': "Display Missing Health",
              'help': "This allows players to see \"damage dealt\" to a token, without revealing the token's total health. If enabled, each token's missing health is displayed as a number in the bottom-right corner of the token.",
              'default': false,
              'type': "boolean"
            },
            'damageDealtBloodiedThreshold': {
              'name': "Display Missing Health &quot;Wounded&quot; Threshold",
              'help': "The health-loss threshold at which the Missing Health text turns red.",
              'default': 0.5,
              'type': "percentage",
              'min': 0x0,
              'max': 0x1
            },
            'isDamageDealtBelowToken': {
              'name': "Missing Health Below Token",
              'help': "If the Missing Health text should be displayed beneath a token, rather than as an overlay.",
              'default': false,
              'type': 'boolean'
            },
            'nameplateFontSizeMultiplier': {
              'name': "Font Size Multiplier",
              'help': "A multiplier which is applied to token nameplate/tooltip font size, e.g. a value of \"0.5\" will decrease token nameplate/tooltip font size by half.",
              'default': null,
              'type': "number",
              'placeholder': "(Use default)",
              'min': 0.1,
              'max': 0xa,
              'isNullable': true
            },
            'isAllowNameplateFontWrap': {
              'name': "Allow Text Wrap",
              'help': "If enabled, token nameplate/tooltip text will wrap.",
              'default': ConfigConsts.C_USE_GAME_DEFAULT,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_USE_GAME_DEFAULT,
                'name': "Use Foundry default"
              }, {
                'value': false,
                'name': "Disabled"
              }, {
                'value': true,
                'name': 'Enabled'
              }]
            },
            'nameplateFontWrapWidthMultiplier': {
              'name': "Text Wrap Max Width Multiplier",
              'help': "A multiplier which is applied to token nameplate/tooltip text wrapping maximum size, e.g. a value of \"0.5\" will force token nameplates/tooltips to wrap at half their usual length. The base value to which this multiplier is applied is: \"2.5 × token width\".",
              'default': null,
              'type': "number",
              'placeholder': "(Use default)",
              'min': 0.1,
              'max': 0xa,
              'isNullable': true
            },
            'isNameplateOnToken': {
              'name': "Move Token Name Onto Token",
              'help': "If a token's name should be displayed on the token, rather than below it.",
              'default': false,
              'type': "boolean"
            },
            'npcHpRollMode': {
              'name': "NPC HP Roll Mode",
              'help': "Determines whether or not token HP, for NPC tokens which are not linked to their actor's data, should be rolled upon token creation. If a mode other than \"None\" is selected, and the token has a valid HP dice formula, the token will roll for HP. For example, a Goblin (7 HP; formula is 2d6) could be created with anywhere between 2 and 12 HP (inclusive).",
              'default': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE,
              'type': 'enum',
              'values': [{
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE,
                'name': "None",
                'help': "Do not roll NPC token health."
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_STANDARD,
                'name': "Standard Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_GM,
                'name': "GM Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_BLIND,
                'name': "Blind Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_SELF,
                'name': "Self Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_HIDDEN,
                'name': "Hidden Roll",
                'help': "Roll NPC token health, but do not post the result to chat."
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MIN,
                'name': "Minimum Value",
                'help': "Use the minimum possible roll value."
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MAX,
                'name': "Maximum Value",
                'help': "Use the maximum possible roll value."
              }]
            },
            'isDisableAnimations': {
              'name': "Disable Animations",
              'help': "Disable token animations.",
              'default': false,
              'type': "boolean"
            },
            'animationSpeedMultiplier': {
              'name': "Animation Speed",
              'help': "Multiplies token animation movement speed by the factor provided.",
              'default': null,
              'type': "number",
              'isNullable': true,
              'min': 0.1,
              'max': 0xa
            }
          },
          'settingsAdvanced': {
            'missingHealthAttribute': {
              'name': "Health Attribute",
              'help': "The sheet attribute used to fetch current/max health when the \"Display Missing Health\" option is enabled.",
              'default': "attributes.hp",
              'type': "string",
              'additionalStyleClasses': "code"
            }
          },
          'settingsHacks': {
            'isIgnoreDisableAnimationsForWaypointMovement': {
              'name': "Avoid Disabling Animations for Ruler Movement",
              'help': "Suppresses the \"Disable Animations\" option for a token being moved via ruler waypoints (i.e. when CTRL-dragging from a token and pressing SPACE). Note that dismissing the ruler during the move will end this suppression.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'import': {
          'name': "Import",
          'settings': {
            'isAddSourceToName': {
              'name': "Add Source to Names",
              'help': "If the source of each imported entry (e.g. \"MM\" for Monster Manual) should be appended to the name of the entry.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isRenderLinksAsTags': {
              'name': "Render Links as &quot;@tag&quot;s",
              'help': "If links found in description text should be rendered as Plutonium-specific @tag syntax, e.g. a link to \"goblin\" would be rendered as \"@creature[goblin|mm]\". (By default, a link to the 5etools page will be rendered instead.)",
              'default': true,
              'type': 'boolean'
            },
            'isRendererLinksDisabled': {
              'name': "Disable 5etools Links",
              'help': "Prevents links to other 5etools content from being added to the text of imported 5etools content.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isRendererDiceDisabled': {
              'name': "Render Dice as Plain Text",
              'help': "Forces dice expressions, usually rendered as \"[[/r XdY + Z ...]]\", to be rendered as plain text when importing 5etools content.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isRenderCustomDiceEnrichers': {
              'name': "Render Dice as Custom Enrichers",
              'help': "If enabled, importers will make use of dnd5e-specific custom enrichers when rendering dice. For example, damage rolls may be rendered as \"[[/damage ...]]\" instead of \"[[/r ...]]\", changing the on-click behaviour.",
              'default': true,
              'type': 'boolean'
            },
            'deduplicationMode': {
              'name': "Duplicate Handling Mode",
              'help': "Determines what action is taken when importing duplicate content to a directory or compendium. An entity is considered a duplicate if and only if its name and source match an existing entity. Note that this does not function when importing to actor sheets.",
              'default': ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE,
                'name': "None",
                'help': "No deduplication is done."
              }, {
                'value': ConfigConsts.C_IMPORT_DEDUPE_MODE_SKIP,
                'name': "Skip duplicates",
                'help': "If a duplicate is found for a would-be imported entity, that entity is not imported."
              }, {
                'value': ConfigConsts.C_IMPORT_DEDUPE_MODE_OVERWRITE,
                'name': "Update existing",
                'help': "If a duplicate is found for a would-be import entity, the existing entity is updated."
              }]
            },
            'isDuplicateHandlingMaintainImage': {
              'name': "Maintain Images when Overwriting Duplicates",
              'help': "If enabled, sheet and token images will be maintained when overwriting an existing document in \"Update Existing\" Duplicate Handling Mode.",
              'default': false,
              'type': 'boolean'
            },
            /* 'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Import",
              'help': "\"Import\" buttons will be hidden for any user with a role less than the chosen role."
            }), */
            'dragDropMode': {
              'name': "Use Importer when Drag-Dropping Items to Actors",
              'help': "Some Foundry items (backgrounds, races, spells, items, etc.), when imported via Plutonium and later drag-dropped to an actor sheet, have special handling allowing for greater functionality (such as populating skills and features). This allows you to control whether or not that special handling is used, rather than the baseline Foundry drag-drop. Note that if you modify an item, the changes will not be reflected in the version imported to the sheet by Plutonium.",
              'default': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_NEVER,
                'name': "Never"
              }, {
                'value': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT,
                'name': "Prompt"
              }, {
                'value': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_ALWAYS,
                'name': "Always"
              }],
              'isPlayerEditable': true
            },
            'isUseOtherFormulaFieldForSaveHalvesDamage': {
              'name': "Treat &quot;Save Halves&quot; Additional Attack Damage as &quot;Other Formula&quot;",
              'help': "This moves extra attack damage rolls (for example, the poison damage done by a Giant Spider's bite) to the \"Other Formula\" dice field, which can improve compatibility with some modules.",
              'default': false,
              'type': 'boolean',
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isUseOtherFormulaFieldForOtherDamage': {
              'name': "Treat &quot;Alternate&quot; Attack Damage as &quot;Other Formula&quot;",
              'help': "This moves alternate non-versatile attack damage rolls (for example, Egg Hunter Hatchling's &quot;Egg Tooth&quot; damage when targeting an object) to the \"Other Formula\" dice field, which can improve compatibility with some modules.",
              'default': false,
              'type': 'boolean',
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isGlobalMetricDistance': {
              'name': "Prefer Metric Distance/Speed (Where Available)",
              'help': "If enabled, metric distance/speed units will be preferred, where the importer supports them. Enabling this option effectively overrides all other metric distance/speed options, causing the importer to treat each as though it was enabled.",
              'default': false,
              'type': 'boolean'
            },
            'isGlobalMetricWeight': {
              'name': "Prefer Metric Weight (Where Available)",
              'help': "If enabled, metric weight units will be preferred, where the importer supports them. Enabling this option effectively overrides all other metric weight options, causing the importer to treat each as though it was enabled.",
              'default': false,
              'type': "boolean"
            },
            'isShowVariantsInLists': {
              'name': "Show Variants/Versions",
              'help': "If variants/versions of base entries should be shown in list views (with grayed-out names).",
              'default': true,
              'type': "boolean"
            },
            'isSaveImagesToServer': {
              'name': "Save Imported Images to Server",
              'help': "If images referenced in imported content should be saved to your server files, rather than referenced from an external server.",
              'default': false,
              'type': "boolean"
            },
            'isSaveTokensToServer': {
              'name': "Save Imported Tokens to Server",
              'help': "If tokens for imported actors should be saved to your server files, rather than referenced from an external server.",
              'default': true,
              'type': "boolean"
            },
            'localImageDirectoryPath': {
              'name': "Image/Token Directory",
              'help': "The sub-directory of the \"User Data\" directory where imported images/tokens will be saved to when using the \"Save Imported Images to Server\" option or the \"Save Imported Tokens to Server\" option. If the \"Use Local Images\" option is enabled, images will be loaded from this directory by default.",
              'default': "assets/" + SharedConsts.MODULE_ID_FAKE,
              'type': "string",
              'additionalStyleClasses': 'code'
            },
            'isPreferFoundryImages': {
              'name': "Prefer Foundry/System Images",
              'help': "If enabled, portraits for actors and images for items will be sourced from built-in compendiums first, then Plutonium second. If disabled, portraits/images will be sourced from Plutonium first, then built-in compendiums second.",
              'default': false,
              'type': "boolean"
            },
            'isPreferFoundryTokens': {
              'name': "Prefer Foundry/System Tokens",
              'help': "If enabled, tokens will be sourced from built-in compendiums first, then Plutonium second. If disabled, tokens will be sourced from Plutonium first, then built-in compendiums second.",
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getImporterToggles(),
            'isTreatJournalEntriesAsFolders': {
              'name': "Treat Journal Entries as Folders",
              'help': "If enabled, Journal Entries are treated as an additional folder level for the purpose of organising imports, etc.",
              'default': true,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isUseLocalImages': {
              'name': "Use Local Images",
              'help': "If enabled, images will be sourced from the \"Image/Token Directory\" directory, defined above.",
              'default': false,
              'type': 'boolean'
            },
            'isStrictMatching': {
              'name': "Use Strict Entity Matching",
              'help': "If enabled, any Plutonium feature which searches for existing data (for example, the class importer attempting to find existing class levels in a given class) will match by name and source. If disabled, only name is used.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'tempFolderName': {
              'name': "Temp Folder Name",
              'help': "The name of a temporary folder created/deleted by some operations. Note that the importer will delete this folder regardless of its contents, as anything contained within it is assumed to be a temporary entity created by the importer.",
              'type': 'string',
              'default': "Temp"
            },
            'isAutoAddAdditionalFonts': {
              'name': "Automatically Add Extra Fonts",
              'help': "If enabled, and you import content which requires additional fonts, these fonts will be added to your game's \"Additional Fonts\" setting.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importCreature': {
          'name': "Import (Creatures)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported creature."),
            'isImportBio': {
              'name': "Import Fluff to Biography",
              'help': "If enabled, any fluff text which is available for a creature will be imported into that creature's biography.",
              'default': true,
              'type': "boolean"
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Biography",
              'help': "If enabled, any fluff image which is available for a creature will be imported into that creature's biography.",
              'default': false,
              'type': 'boolean'
            },
            'isImportBioVariants': {
              'name': "Include Variants in Biography",
              'help': "If enabled, any inset variant boxes associated with a creature will be imported into that creature's biography.",
              'default': true,
              'type': "boolean"
            },
            'isImportVariantsAsFeatures': {
              'name': "Import Variants as Features",
              'help': "If enabled, any inset variant boxes associated with a creature will be imported into that creature's features.",
              'default': false,
              'type': "boolean"
            },
           /*  ...ConfigConsts._template_getTokenSettings({
              'actorType': "npc"
            }), */
            'itemWeightAndValueSizeScaling': {
              'name': "Item Weight & Value Scaling",
              'help': "The method by which to scale the weights and values of non-standard-sizes items carried by creatures.",
              'default': 0x1,
              'type': 'enum',
              'values': [{
                'value': 0x1,
                'name': "No scaling"
              }, {
                'value': 0x2,
                'name': "\"Barding\" scaling (multiplicative)",
                'help': "Based on the rules for calculating the weight and cost of barding, as presented in the Player's Handbook (p. 155)."
              }, {
                'value': 0x3,
                'name': "\"Gurt's Greataxe\" scaling (exponential)",
                'help': "Based on the giant-size greateaxe of the same name found in Storm King's Thunder (p. 234)."
              }]
            },
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not creature speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            },
            'spellcastingPrimaryTraitMode': {
              'name': "Spellcasting Primary Trait Selection Method",
              'help': "The method by which a primary spellcasting trait (i.e., the spellcasting trait used to set spellcasting ability, spell DC, and spell attack bonus) is selected if a creature has multiple spellcasting traits with associated ability scores.",
              'default': 0x1,
              'type': 'enum',
              'values': [{
                'value': 0x1,
                'name': "Highest spell count",
                'help': "Use whichever spellcasting trait has the most spells listed."
              }, {
                'value': 0x2,
                'name': "Highest ability score",
                'help': "Use whichever spellcasting trait has the highest associated ability score. Note that this may prefer innate spellcasting traits over spellcasting class levels."
              }]
            },
            'nameTags': {
              'name': "Add Tag Suffixes to Names",
              'help': "Add tags to an imported creature's name, to allow easier searching (especially within compendiums).",
              'default': {
                [ConfigConsts.C_CREATURE_NAMETAGS_CR]: false,
                [ConfigConsts.C_CREATURE_NAMETAGS_TYPE]: false,
                [ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS]: false
              },
              'type': 'multipleChoice',
              'choices': [{
                'value': ConfigConsts.C_CREATURE_NAMETAGS_CR,
                'name': "Add [CR] tag"
              }, {
                'value': ConfigConsts.C_CREATURE_NAMETAGS_TYPE,
                'name': "Add [type] tag"
              }, {
                'value': ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS,
                'name': "Add [type (with tags)] tag"
              }]
            },
            'isAddSoundEffect': {
              'name': "MLD: Add Audio as Sound Effect",
              'help': "If, when the Monk's Little Details module is active, an imported creature should have its sound effect set, where an audio clip is available (for official data, this will usually be an audio clip of the creature's name being pronounced).",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Creature Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CREATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums (Features)",
              'help': "A comma-separated list of compendiums that the Creature Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CREATURE_FEATURES.join(", "),
              'type': 'string',
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'isUseTokenImageAsPortrait': {
              'name': "Use Token Image as Portrait",
              'help': "If enabled, a creature's token image will be preferred over its portrait image when populating its sheet portrait during import.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getActorImportOverwriteSettings(),
            'isAddFakeClassToCharacter': {
              'name': "Add Class to Creatures Imported as Player Characters",
              'help': "If enabled, when importing a creature as a Player Character (\"character\"-type actor) a class item will be added to the actor's sheet, in order to set proficiency bonus and spellcasting levels.",
              'default': true,
              'type': 'boolean'
            },
            'isUseStaticAc': {
              'name': "Use Static AC Values",
              'help': "If enabled, creature AC will be imported as a static number (rather than relying on the sheet's formula calculation), and creature armor will be imported as unequipped.",
              'default': false,
              'type': "boolean"
            },
            'isUseCustomNaturalAc': {
              'name': "Use Custom Natural Armor Formula",
              'help': "If enabled, creatures with natural armor will have their armor formula broken down as \"@attributes.ac.armor + @attributes.ac.dex + <naturalBonus>\", allowing any later Dexterity score changes to be reflected in the creatures AC.",
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsHacks': {
            'isUsePathfinderTokenPackBestiariesImages': {
              'name': "Use &quot;Pathfinder Token Pack: Bestiaries&quot; Tokens/Portraits",
              'help': "If enabled, and the \"Pathfinder Token Pack: Bestiaries\" module is installed and enabled, the importer will attempt to use token and portrait art from the \"Pathfinder Token Pack: Bestiaries\" module.",
              'default': false,
              'type': "boolean"
            }
          }
        },
        'importCreatureFeature': {
          'name': "Import (Creature Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported creature feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "creature features"
            }), */
            'isSecretWrapAttacks': {
              'name': "&quot;Secret&quot; Attack Descriptions",
              'help': "If enabled, creature attack descriptions will be wrapped in \"Secret\" blocks, which are not shown when rolling.",
              'default': false,
              'type': "boolean"
            },
            'isScaleToTargetActor': {
              'name': "Scale to Target Actor CR",
              'help': "If enabled, creature features imported to existing NPC actors will be automatically scaled (altering to-hit bonuses, damage rolls, DCs, etc.) based on the difference between the original creature's CR and the target actor's CR.",
              'default': true,
              'type': 'boolean'
            },
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not creature feature range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "creature features"
            }),
            'isSplitMeleeRangedAttack': {
              'name': "Split &quot;Melee or Ranged Attack&quot; Actions",
              'help': "If enabled, the importer will create two sheet items per \"Melee or Ranged Attack\" action, each with the appropriate range set.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isSplitConditionalDamageAttack': {
              'name': "Split Conditional Damage Actions",
              'help': "If enabled, the importer will create two sheet items (\"Base\" and \"Full\") per \"... plus <x> damage if <y>\" action, where the \"base\" item does not include the conditional damage, and the \"full\" item does include the conditional damage.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isPreferFlatSavingThrows': {
              'name': "Prefer Flat Saving Throws",
              'help': "If enabled, a saving throw for a sheet item will always have \"flat\" scaling, with the flat DC value set to match the number in the creature's stat block. If disabled, a sheet item's saving throw scaling may be set as an ability score, provided that doing so produces the same value for the DC as is listed in the creature's stat block.",
              'default': false,
              'type': "boolean"
            }
          }
        },
        'importVehicle': {
          'name': "Import (Vehicles)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported vehicle."),
            ...ConfigConsts._template_getTokenSettings({
              'actorType': "vehicle"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not vehicle speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + "; " + ConfigConsts._DISP_METRIC_MILES + ').',
              'default': false,
              'type': "boolean"
            },
            'isImportBio': {
              'name': "Import Fluff to Description",
              'help': "If enabled, any fluff text which is available for a vehicle will be imported into that vehicle's description.",
              'default': true,
              'type': 'boolean'
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Description",
              'help': "If enabled, any fluff image which is available for a vehicle will be imported into that vehicle's description.",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the vehicle importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': '',
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'isUseTokenImageAsPortrait': {
              'name': "Use Token Image as Portrait",
              'help': "If enabled, a vehicle's token image will be preferred over its portrait image when populating its sheet portrait during import.",
              'default': false,
              'type': 'boolean'
            },
            ...ConfigConsts._template_getActorImportOverwriteSettings(),
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': 'vehicles'
            })
          }
        },
        'importVehicleUpgrade': {
          'name': "Import (Vehicle Upgrades)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported vehicle upgrades."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "vehicle upgrades"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not vehicle upgrade speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "vehicle upgrades"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a vehicle upgrade's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importObject': {
          'name': "Import (Objects)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported object."),
            ...ConfigConsts._template_getTokenSettings({
              'actorType': 'vehicle'
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not object speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            },
            'isImportBio': {
              'name': "Import Fluff to Description",
              'help': "If enabled, any fluff text which is available for an object will be imported into that object's description.",
              'default': true,
              'type': "boolean"
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Description",
              'help': "If enabled, any fluff image which is available for an object will be imported into that object's description.",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'isUseTokenImageAsPortrait': {
              'name': "Use Token Image as Portrait",
              'help': "If enabled, an object's token image will be preferred over its portrait image when populating its sheet portrait during import.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getActorImportOverwriteSettings()
          }
        },
        'importObjectFeature': {
          'name': "Import (Object Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported object feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "object features"
            }), */
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not object feature range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "object features"
            })
          }
        },
        'importFeat': {
          'name': "Import (Feats)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported feat."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': 'feats'
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not feat speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "feats"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a feat's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importBackground': {
          'name': "Import (Backgrounds)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported background.")
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums (Backgrounds)",
              'help': "A comma-separated list of compendiums that the background importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums (Features)",
              'help': "A comma-separated list of compendiums that the background importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "backgrounds"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a background's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importBackgroundFeature': {
          'name': "Import (Background Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported background feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "background features"
            }) */
          }
        },
        'importClass': {
          'name': "Import (Classes & Subclasses)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported class or subclass."),
            'isAddUnarmedStrike': {
              'name': "Add Unarmed Strike",
              'help': "If enabled, importing a class to an actor will create an \"Unarmed Strike\" weapon, unless one already exists.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isImportClassTable': {
              'name': "Import Class Table to Description",
              'help': "If enabled, a class's table will be imported as part of the class item's description.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isAddLevelUpButton': {
              'name': "Add &quot;Level Up&quot; Button to Character Sheets",
              'help': "If enabled, a \"Level Up\" button will be displayed in the top-right corner of a character's sheet (assuming the default dnd5e sheet is used).",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isSetXp': {
              'name': "Set Minimum Actor XP on Class Import",
              'help': "If enabled, during class import, actor XP will be set to the minimum XP value required for the actor's new level, if the actor's current XP is insufficient for them to reach their new level.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'hpIncreaseMode': {
              'name': "Hit Points Increase Mode",
              'help': "Determines how Hit Points are calculated when using the Class Importer to level up. If left unspecified, a user will be prompted to choose the mode each time their Hit Points are increased by the Class Importer.",
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE]
              }],
              'default': null,
              'isNullable': true
            },
            'hpIncreaseModeCustomRollFormula': {
              'name': "Hit Points Increase Custom Roll Formula",
              'help': "A custom roll formula to be used when gaining HP on level up. Used if either the \"Hit Points Increase Mode\" option is set to \"" + ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM] + "\", or if a player chooses \"" + ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM] + "\" when prompted to select their Hit Points Increase Mode. Use \"@hd.faces\" for the type of dice (i.e., the \"8\" in \"1d8\"), and \"@hd.number\" for \"number of dice\" (i.e., the \"1\" in \"1d8\"). Note that backticks (`) around an expression will also be replaced so \"`@hd.number`d`@hd.faces`\" will produce e.g. \"1d8\", should you need to avoid using brackets.",
              'placeholder': "(@hd.number)d(@hd.faces)",
              'type': "string",
              'additionalStyleClasses': "code",
              'default': null,
              'isNullable': true
            }
          },
          'settingsAdvanced': {
            'isDisplayOnLevelZeroCharacters': {
              'name': "Display &quot;Level Up&quot; Button on New Characters",
              'help': "If enabled, the \"Level Up\" button will be displayed on character actors with no levels.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isLevelUpButtonDisabledUntilEnoughExperience': {
              'name': "Disable the &quot;Level Up&quot; Button Until Character Has Enough XP",
              'help': "If enabled, the \"Level Up\" button will be disabled (though still visible) on characters who do not have sufficient XP to level up.",
              'default': true,
              'type': 'boolean'
            },
            'isLegacyLevelUpButton': {
              'name': "Prefer legacy &quot;Level Up&quot; Button",
              'help': "If disabled, the \"Level Up\" button will attempt to open the Charactermancer, a Patron-only feature which requires you to log in. If enabled, a dialogue of options will be presented, via which the Class Importer can be directly invoked.",
              'default': true,
              'type': "boolean"
            },
            'additionalDataCompendiumClasses': {
              'name': "Additional Data Compendiums (Classes)",
              'help': "A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CLASSES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumSubclasses': {
              'name': "Additional Data Compendiums (Subclasses)",
              'help': "A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_SUBCLASSES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums (Features)",
              'help': "A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CLASS_FEATURES.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "class"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a class's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            },
            'isUseDefaultSubclassImage': {
              'name': "Subclass Default Image Fallback",
              'help': "If enabled, when importing a subclass which has no well-defined image, use a default image based on class. If disabled, a generic black and white image will be used as a fallback instead.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isHideSubclassRows': {
              'name': "Hide Subclasses in Class Importer",
              'help': "If enabled, the class/subclass list in the Class Importer will only show classes.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            }
          }
        },
        'importClassSubclassFeature': {
          'name': "Import (Class & Sub. Features)",
          'help': "Import (Class & Subclass Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported class/subclass feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "class/subclass features"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not class/subclass feature speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "class features"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a class/subclass feature's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importItem': {
          'name': "Import (Items)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported item."),
            'isAddActiveEffects': {
              'name': "Populate Active Effects",
              'help': "If items should have active effects created during import.",
              'default': true,
              'type': 'boolean'
            },
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not item range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            },
            'isMetricWeight': {
              'name': "Convert Item Weights to Metric",
              'help': "Whether or not item weight units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_POUNDS + ').',
              'default': false,
              'type': 'boolean'
            },
            'inventoryStackingMode': {
              'name': "Inventory Stacking Mode",
              'help': "If imported items should \"stack\" with existing items when imported to an actor's inventory. If stacking is allowed, the importer will check for an existing item when importing an item to an actor's sheet. If the item already exists, the importer will increase the quantity of that item in the actor's inventory, rather than create a new copy of the item in the actor's inventory.",
              'default': ConfigConsts.C_ITEM_ATTUNEMENT_SMART,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_NEVER,
                'name': "Never Stack"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_SMART,
                'name': "Sometimes Stack (e.g. consumables, throwables)"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_ALWAYS,
                'name': "Always Stack"
              }]
            },
            'isSplitPacksActor': {
              'name': "Import Packs to Actors as Constituent Items",
              'help': "If \"pack\" items (explorer's pack, dungeoneer's pack) should be broken down and imported as their constituent items when importing to an actor's items.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isSplitAtomicPacksActor': {
              'name': "Import Item Stacks to Actors as Constituent Items",
              'help': "If an item which is formed of multiple constituent items of the same type, such as \"Bag of Ball Bearings (1,000)\", should be split up into its constituent items (a \"Ball Bearing\" item with its sheet quantity set to 1,000, in this example).",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'throwables': {
              'name': "Throwing Items",
              'help': "A list of items which are imported with their usage set to deplete their own quantity when used.",
              'default': ["Handaxe", "Javelin", "Light Hammer", "Dart", 'Net'],
              'type': 'arrayStringShort',
              'isPlayerEditable': true
            },
            'altAbilityScoreByClass': {
              'name': "Alt Ability Scores by Class",
              'help': "A list of <class>-<item>-<score> mappings, an entry in which, when importing an item, will change the default ability score used by an item for a member of that class.",
              'default': ['monk:club:dex', "monk:dagger:dex", 'monk:handaxe:dex', "monk:javelin:dex", "monk:light hammer:dex", "monk:mace:dex", "monk:quarterstaff:dex", 'monk:shortsword:dex', 'monk:sickle:dex', "monk:spear:dex"],
              'type': "arrayStringShort",
              'isPlayerEditable': true
            },
            'attunementType': {
              'name': "Attunement when Importing to Directory/Compendium",
              'help': "The attunement type to use when importing an item which can be attuned.",
              'default': ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
              'type': 'enum',
              'values': [{
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_NONE,
                'name': "None"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
                'name': "Attunement required"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
                'name': "Attuned"
              }]
            },
            'attunementTypeActor': {
              'name': "Attunement when Importing to Actors",
              'help': "The attunement type to use when importing an item which can be attuned.",
              'default': ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_NONE,
                'name': "None"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
                'name': "Attunement required"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
                'name': "Attuned"
              }]
            },
            'isImportDescriptionHeader': {
              'name': "Include Damage, Properties, Rarity, and Attunement in Description",
              'help': "If enabled, an imported item's description will include text generated from its rarity, attunement requirements, damage, and other properties.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isUseOtherFormulaFieldForExtraDamage': {
              'name': "Treat Extra Damage as &quot;Other Formula&quot;",
              'help': "This moves extra damage rolls to the \"Other Formula\" dice field, which can improve compatibility with some modules.",
              'default': false,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Item Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_ITEMS.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            'replacementDataCompendium': {
              'name': "Replacement Data Compendiums",
              'help': "A comma-separated list of compendiums that the Item Importer will attempt to pull items from, rather than using the data Plutonium would otherwise generate. This is useful when the Item Importer is used by other importers, e.g. when the Creature Importer is adding items to newly-created actors.",
              'default': '',
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "items"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, an item's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importPsionic': {
          'name': "Import (Psionics)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported psionic."),
            'psiPointsResource': {
              'name': "Psi Points Resource",
              'help': "The resource consumed by psionics.",
              'default': "resources.primary",
              'type': "enum",
              'values': [{
                'value': "resources.primary"
              }, {
                'value': 'resources.secondary'
              }, {
                'value': "resources.tertiary"
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM,
                'name': "\"Psi Points\" sheet item"
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM,
                'name': "Custom (see below)"
              }],
              'isPlayerEditable': true
            },
            'psiPointsResourceCustom': {
              'name': "Psi Points Custom Resource",
              'help': "The name of the custom resource to use if \"Custom\" is selected for \"Psi Points Resource\", above. This supports modules that expand the number of available sheet resources, such as \"5e-Sheet Resources Plus\" (which adds e.g. \"resources.fourth\", \"resources.fifth\", ...).",
              'type': 'string',
              'additionalStyleClasses': 'code',
              'default': null,
              'isNullable': true,
              'isPlayerEditable': true
            },
            'isImportAsSpell': {
              'name': "Import as Spells",
              'help': "If enabled, psionics will be imported as spells, rather than features.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "psionics"
            })
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': 'psionic'
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a psionic's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importRace': {
          'name': "Import (Races)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported race."),
           /*  ...ConfigConsts._template_getTokenSettings({
              'actorType': "character"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not race speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the race importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "races"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a race's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importRaceFeature': {
          'name': "Import (Race Features)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported race feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "race features"
            }) */
          },
          'settingsAdvanced': {
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the race feature importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "race features"
            })
          }
        },
        'importTable': {
          'name': "Import (Table)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported table.")
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Table Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_TABLES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': 'code',
              'isNullable': true
            }
          }
        },
        'importSpell': {
          'name': "Import (Spells)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported spell."),
            'prepareActorSpells': {
              'name': "Prepare Actor Spells",
              'help': "Whether or not spells that are imported to actor sheets should be prepared by default.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'prepareSpellItems': {
              'name': "Prepare Spell Items",
              'help': "Whether or not spells that are imported to the items directory should be prepared by default.",
              'default': false,
              'type': 'boolean'
            },
            'actorSpellPreparationMode': {
              'name': "Actor Spell Preparation Mode",
              'help': "The default spell preparation mode for spells imported to actor sheets.",
              'default': "prepared",
              'type': "enum",
              'values': [{
                'value': '',
                'name': "(None)"
              }, {
                'value': "always",
                'name': "Always Prepared"
              }, {
                'value': "prepared",
                'name': "Prepared"
              }, {
                'value': "innate",
                'name': "Innate Spellcasting"
              }, {
                'value': "pact",
                'name': "Pact Magic"
              }],
              'isPlayerEditable': true
            },
            'isAutoDetectActorSpellPreparationMode': {
              'name': "Auto-Detect Actor Spell Preparation Mode",
              'help': "If enabled, the default spell preparation mode for spells imported to actor sheets (as defined by \"Actor Spell Preparation Mode\") may be automatically overridden, e.g. \"pact magic\" is automatically used when importing to a warlock.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'spellItemPreparationMode': {
              'name': "Spell Item Preparation Mode",
              'help': "The default spell preparation mode for spells imported to the items directory.",
              'default': "prepared",
              'type': "enum",
              'values': [{
                'value': '',
                'name': '(None)'
              }, {
                'value': "always",
                'name': "Always Prepared"
              }, {
                'value': "prepared",
                'name': "Prepared"
              }, {
                'value': 'innate',
                'name': "Innate Spellcasting"
              }, {
                'value': "pact",
                'name': "Pact Magic"
              }]
            },
            'spellPointsMode': {
              'name': "Use Spell Points",
              'help': "If enabled, imported spells which would use spell slots will instead be marked as \"at will\" and set to consume an a sheet or feature resource. (The \"Spell Points\" variant rule can be found in the DMG, page 288.)",
              'default': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
              'type': 'enum',
              'values': [{
                'name': "Disabled",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED
              }, {
                'name': 'Enabled',
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED
              }, {
                'name': "Enabled, and Use 99 Slots",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS,
                'help': "If enabled, an imported spells will retain its \"Spell Preparation Mode\" in addition to consuming a \"Spell Points\" sheet/feature resource. This improves compatibility with many sheets and modules. To allow \"unlimited\" spellcasting at each spell level, a character's spell slots for each level will be set to 99."
              }],
              'isPlayerEditable': true
            },
            'spellPointsResource': {
              'name': "Spell Points Resource",
              'help': "The resource consumed by spells imported with \"Use Spell Points\" enabled.",
              'default': "resources.primary.value",
              'type': "enum",
              'values': [{
                'value': "resources.primary"
              }, {
                'value': 'resources.secondary'
              }, {
                'value': 'resources.tertiary'
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM,
                'name': "\"Spell Points\" sheet item"
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM,
                'name': "Custom (see below)"
              }],
              'isPlayerEditable': true
            },
            'spellPointsResourceCustom': {
              'name': "Spell Points Custom Resource",
              'help': "The name of the custom resource to use if \"Custom\" is selected for \"Spell Points Resource\", above. This supports modules that expand the number of available sheet resources, such as \"5e-Sheet Resources Plus\" (which adds e.g. \"resources.fourth\", \"resources.fifth\", ...).",
              'type': 'string',
              'additionalStyleClasses': "code",
              'default': null,
              'isNullable': true,
              'isPlayerEditable': true
            },
            'isIncludeClassesInDescription': {
              'name': "Include Caster Classes in Spell Description",
              'help': "If enabled, an imported spell's description will include the list of classes which have the spell on their spell list.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': 'spells'
            }),
            'isMetricDistance': {
              'name': "Convert Ranges and Areas to Metric",
              'help': "Whether or not spell range/area units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + "; " + ConfigConsts._DISP_METRIC_MILES + ').',
              'default': false,
              'type': "boolean"
            },
            'isFilterOnOpen': {
              'name': "Apply Class Filter when Opening on Actor",
              'help': "If enabled, and the importer is opened from an actor, the spell list will be filtered according to that actor's current class(es).",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Spell Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_SPELLS.join(", "),
              'type': 'string',
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'replacementDataCompendium': {
              'name': "Replacement Data Compendiums",
              'help': "A comma-separated list of compendiums that the Spell Importer will attempt to pull spells from, rather than using the data Plutonium would otherwise generate. This is useful when the Spell Importer is used by other importers, e.g. when the Creature Importer is adding spells to newly-created actors.",
              'default': '',
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': 'spells'
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a spell's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            },
            'isUseCustomSrdIcons': {
              'name': "Use Custom Icons for SRD Spells",
              'help': "If enabled, imported SRD spells will use an alternate icon set, as curated by the community.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isUseDefaultSchoolImage': {
              'name': "School Default Image Fallback",
              'help': "If enabled, when importing a spell which has no well-defined image, use a default image based on the school of the spell. If disabled, a generic black and white image will be used as a fallback instead.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'spellPointsModeNpc': {
              'name': "Use Spell Points (NPCs)",
              'help': "If enabled, a spell imported to an NPC which would use spell slots will instead be marked as \"at will\" and set to consume an a sheet or feature resource. (The \"Spell Points\" variant rule can be found in the DMG, page 288.)",
              'default': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
              'type': "enum",
              'values': [{
                'name': "Disabled",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED
              }, {
                'name': "Enabled",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED
              }, {
                'name': "Enabled, but Use 99 Slots",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS,
                'help': "If enabled, imported spells will retain their \"prepared\"/etc. types in addition to consuming a \"Spell Points\" sheet/feature resource. This allows easier organisation of spells, and better compatibility with many modules. To allow \"unlimited\" spellcasting at each spell level, a character's spell slots for each level will be set to 99."
              }]
            }
          }
        },
        'importRule': {
          'name': "Import (Rules)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported rule.")
          }
        },
        'importLanguage': {
          'name': "Import (Languages)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported language.")
          }
        },
        'importOptionalFeature': {
          'name': "Import (Options & Features)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported option/feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "optional features"
            }),
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not optional feature speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the optional feature importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_OPTIONAL_FEATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "optional features"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, an optional feature's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importConditionDisease': {
          'name': "Import (Conditions & Diseases)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported condition/diseases.")
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "conditions/diseases"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a condition/disease's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importCultBoon': {
          'name': "Import (Cults & Supernatural Boons)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported cult/boon.")
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "cults/boons"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a cult/boon's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importAction': {
          'name': "Import (Actions)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported action.")
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "actions"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a action's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importReward': {
          'name': "Import (Gifts & Rewards)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported supernatural gift/reward."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "supernatural gift/rewards"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not gift/reward speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "gift/rewards"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a supernatural gift/reward's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importCharCreationOption': {
          'name': "Import (Char. Creation Options)",
          'help': "Import (Character Creation Options)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported character creation option."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "character creation options"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not character creation option speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "character creation options"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a character creation option's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importDeity': {
          'name': "Import (Deities)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported deity.")
          }
        },
        'importRecipe': {
          'name': "Import (Recipes)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported recipe.")
          }
        },
        'importTrap': {
          'name': "Import (Traps)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported trap."),
            ...ConfigConsts._template_getTokenSettings({
              'actorType': "npc"
            }), */
            'isImportBio': {
              'name': "Import Fluff to Description",
              'help': "If enabled, any fluff text which is available for a trap will be imported into that trap's description.",
              'default': true,
              'type': 'boolean'
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Description",
              'help': "If enabled, any fluff image which is available for a trap will be imported into that trap's description.",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActorImportOverwriteSettings()
          }
        },
        'importTrapFeature': {
          'name': "Import (Trap Features)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported trap feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "trap features"
            }), */
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not trap feature range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "trap features"
            })
          }
        },
        'importHazard': {
          'name': "Import (Hazards)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported hazard.")
          }
        },
        'importAdventure': {
          'name': "Import (Adventures)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported adventure."),
            'isUseModdedInstaller': {
              'name': "Use Modded Package Installer",
              'help': "If the modded Plutonium backend is installed, adventure packages (modules/worlds) will be installed, automatically, using the mod, rather than providing you with a list of links to copy-paste into Foundry's \"Setup\".",
              'type': 'boolean',
              'default': false
            },
            'isUseLegacyImporter': {
              'name': "Enable Legacy Package Importer",
              'help': "If Plutonium should allow adventure packages (modules/worlds) to be imported directly, rather than providing references for the user to investigate themselves.",
              'type': "boolean",
              'default': false,
              'unlockCode': "unlock"
            },
            'indexUrl': {
              'name': "Package Index URL",
              'help': "The URL of the index file from which world/module package metadata is loaded.",
              'type': 'url',
              'default': "https://raw.githubusercontent.com/DMsGuild201/Foundry_Resources/master/worlds/index.json",
              'additionalStyleClasses': 'code',
              'isReloadRequired': true
            }
          }
        },
        'importBook': {
          'name': "Import (Books)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported book.")
          }
        },
        'importMap': {
          'name': "Import (Maps)",
          'settings': {
            //...ConfigConsts._template_getSceneImportSettings()
          }
        },
        'importDeck': {
          'name': "Import (Decks)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported deck.")
          }
        },
        'actor': {
          'name': 'Actors',
          'settings': {
            'isRefreshOtherOwnedSheets': {
              'name': "Refresh Sheets using &quot;@" + SharedConsts.MODULE_ID_FAKE + ".userchar&quot; when Updating Player Character",
              'help': "Player only. If enabled, when you update your character, the sheets of other actors you control which use \"@" + SharedConsts.MODULE_ID_FAKE + ".userchar. ...\" attributes will be automatically refreshed to reflect any changes made to your character. If disabled, you may notice a \"lag\" between updating your character and seeing the changes reflected in other sheets (a refresh can be forced manually by editing any field on the other sheet, or refreshing your browser tab).",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            }
          },
          'settingsAdvanced': {
            'isAddRollDataItemsFeat': {
              'name': "Add &quot;@items&quot; to Roll Data (Features)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isAddRollDataItemsItem': {
              'name': "Add &quot;@items&quot; to Roll Data (Inventory)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': 'boolean'
            },
            'isAddRollDataItemsSpell': {
              'name': "Add &quot;@items&quot; to Roll Data (Spells)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': "boolean"
            },
            'isAddRollDataItemsOther': {
              'name': "Add &quot;@items&quot; to Roll Data (Other)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsHacks': {
            'isAutoMultiattack': {
              'name': "Auto-Roll Multiattacks",
              'help': "Attempt to detect and automatically roll components of a creature's \"Multiattack\" sheet item on activation.",
              'default': false,
              'type': "boolean"
            },
            'autoMultiattackDelay': {
              'name': "Time Between Multiattack Rolls (ms)",
              'help': "A number of milliseconds to wait between each roll of a multiattack when using the \"Auto-Roll Multiattacks\" option. A value of 2000-2500 is recommended when using the \"Automated Animations\" module.",
              'default': null,
              'type': 'number',
              'min': 0x0,
              'isNullable': true
            },
            'isUseExtendedActiveEffectsParser': {
              'name': "Support Variables in Active Effect Values",
              'help': "Allows the use of roll syntax, and notably variables (such as \"@abilities.dex.mod\"), in active effect values.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_DAE]: false,
                [UtilCompat.MODULE_ROLLDATA_AWARE_ACTIVE_EFFECTS]: false
              }
            }
          }
        },
        'item': {
          'name': "Items",
          'settingsHacks': {
            'isSuppressAdvancementsOnImportedDrop': {
              'name': "Suppress Advancements During Drop Flow",
              'help': "If enabled, dropping a Plutonium-imported item to a sheet will briefly disable the default advancement workflow, potentially allowing Plutonium's importer to run instead.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'rivet': {
          'name': "Rivet",
          'settings': {
            'targetDocumentId': {
              'name': "Target Document",
              'help': "The ID of an actor or compendium to which Rivet content should be imported.",
              'default': '',
              'type': "string",
              'additionalStyleClasses': "code",
              'isPlayerEditable': true
            },
            'isDisplayStatus': {
              'name': "Display Extension Detected",
              'help': "Adds a \"paper plane\" icon to the Foundry \"anvil\" logo in the top-left corner of the screen if Rivet is detected.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            /* 'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level",
              'help': "Rivet will cease to function for any user user with a role less than the chosen role. Directory \"Set as Rivet Target\" context menu option will also be hidden for any user with a role less than the chosen role."
            }) */
          }
        },
        'artBrowser': {
          'name': "Art Browser",
          'settings': {
            'importImagesAs': {
              'name': "Drag-Drop Images As",
              'help': "The type of canvas object that should be created when drag-dropping images from the art browser to the canvas.",
              'default': ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
                'name': 'Tokens'
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_TILE,
                'name': "Tiles"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_NOTE,
                'name': "Journal notes"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_SCENE,
                'name': "Scenes"
              }]
            },
            'dropAnchor': {
              'name': "Drag-Drop Position Anchor",
              'help': "The origin point of the image used for the purpose of dropping it to the canvas. \"Center\" will place the center of the image at the drop position, whereas \"Top-Left Corner\" will place the top-left corner of the image at the drop position.",
              'default': 0x0,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ART_DROP_ANCHOR_CENTER,
                'name': "Center"
              }, {
                'value': ConfigConsts.C_ART_DROP_ANCHOR_TOP_LEFT,
                'name': "Top-Left Corner"
              }]
            },
            'scale': {
              'name': "Tile/Scene Scaling",
              'help': "A factor by which to scale placed tiles, and by which to scale scene backgrounds.",
              'default': 0x1,
              'type': 'number',
              'min': 0.01,
              'max': 0x64
            },
            ...ConfigConsts._template_getSceneImportSettings(),
            'tokenSize': {
              'name': "Token Size",
              'help': "The default size of placed tokens.",
              'default': 0x1,
              'type': "enum",
              'values': [{
                'value': 0x1,
                'name': "Medium or smaller"
              }, {
                'value': 0x2,
                'name': 'Large'
              }, {
                'value': 0x3,
                'name': "Huge"
              }, {
                'value': 0x4,
                'name': "Gargantuan or larger"
              }]
            },
            'isSwitchToCreatedScene': {
              'name': "Activate Scenes on Creation",
              'help': "If enabled, a scene will be activated upon creation (by drag-dropping an image to the canvas).",
              'default': true,
              'type': "boolean"
            },
            'isDisplaySheetCreatedScene': {
              'name': "Display Scene Sheets on Creation",
              'help': "If enabled, the \"sheet\" (i.e., configuration UI) for a scene will be shown upon creation (by drag-dropping an image to the canvas).",
              'default': true,
              'type': 'boolean'
            },
            'artDirectoryPath': {
              'name': "User Art Directory",
              'help': "The sub-directory of the \"User Data\" directory where downloaded images and image packs will be saved.",
              'default': "assets/art",
              'type': 'string',
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'buttonDisplay': {
              'name': "Add Button To",
              'help': "The place(s) where the Art Browser button should be visible.",
              'default': {
                [ConfigConsts.C_ART_IMAGE_MODE_TOKEN]: false,
                [ConfigConsts.C_ART_IMAGE_MODE_TILE]: true,
                [ConfigConsts.C_ART_IMAGE_MODE_NOTE]: false,
                [ConfigConsts.C_ART_IMAGE_MODE_SCENE]: true
              },
              'type': "multipleChoice",
              'choices': [{
                'value': ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
                'name': "Token scene controls"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_TILE,
                'name': "Tile scene controls"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_NOTE,
                'name': "Note scene controls"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_SCENE,
                'name': "Scene controls"
              }]
            },
            'imageSaveMode': {
              'name': "Image Saving Mode",
              'help': "How images should be saved to the server. If \"Default\" is selected, an imported image will only be saved if it cannot be referenced via URL. If \"Always\" is selected, an imported image will be saved to the server, regardless of whether or not it can be referenced via URL. If \"Never\" is selected, an imported image will only be referenced by URL; if it cannot be referenced via URL, the import will fail. Note that saving images requires the Plutonium backend mod to be installed.",
              'default': ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT,
                'name': "Default"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_SAVE_MODE__ALWAYS,
                'name': 'Always'
              }, {
                'value': ConfigConsts.C_ART_IMAGE_SAVE_MODE__NEVER,
                'name': "Never"
              }]
            }
          },
          'settingsAdvanced': {
            'isSwitchLayerOnDrop': {
              'name': "Switch to Layer on Drop",
              'help': "If, when dropping an image into a given layer, the canvas should switch to that layer.",
              'default': true,
              'type': "boolean"
            },
            'isShowMissingBackendWarning': {
              'name': "Show &quot;Missing Backend&quot; Warning",
              'help': "If enabled, and the Plutonium backend mod is not installed, a warning will be shown in the Art Browser.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'journalEntries': {
          'name': "Journal Entries",
          'settings': {
            'isAutoExpandJournalEmbeds': {
              'name': "Auto-Expand Page Embeds",
              'help': "If enabled, journal pages embedded using \"@EmbedUUID[JournalEntry. ... JournalEntryPage. ...]{...}\" will be expanded by default.",
              'default': true,
              'type': "boolean"
            },
            'isEnableNoteHeaderAnchor': {
              'name': "Allow &quot;Header Anchors&quot; in Notes",
              'help': "If enabled, a \"Header Anchor\" may be specified when creating or editing a map note. When opening a journal entry via a map note with a Header Anchor set, the journal entry will scroll to that header.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'tools': {
          'name': "Tools",
          'settings': {
            'isDeduplicateIgnoreType': {
              'name': "Ignore Types When Deduplicating",
              'help': "If enabled, the Collection Deduplicator will ignore entity types, treating e.g. a PC sheet and an NPC sheet with the same name as a set of duplicates.",
              'default': false,
              'type': "boolean"
            },
           /*  'minimumRolePolymorph': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Polymorph Tool",
              'help': "Actor \"Polymorph\" buttons will be hidden for any user with a role less than the chosen role."
            }),
            'minimumRoleActorTools': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Other Actor Tools",
              'help': "Actor \"Feature/Spell Cleaner,\" \"Prepared Spell Mass-Toggler,\" etc. buttons will be hidden for any user with a role less than the chosen role."
            }),
            'minimumRoleTableTools': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Other Table Tools",
              'help': "Table \"Row Cleaner\" button will be hidden for any user with a role less than the chosen role."
            }), */
            'isAddClearFlagsContextMenu': {
              'name': "Add &quot;Clear Flags&quot; Context Option",
              'help': "If enabled a \"Clear Flags\" option will be added to directory document context menus. This option will clear all \"plutonium\" flags from a document, and the document's embedded documents. Note that this will negatively impact Plutonium functionality for the document.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            }
          }
        },
        'text': {
          'name': "Text and Tags",
          'settings': {
            'isEnableHoverForLinkTags': {
              'name': "Enable Hover Popups for &quot;@tag&quot; Links",
              'help': "If links rendered from @tag syntax should display popups when hovered.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isAutoRollActorItemTags': {
              'name': "Roll Items Linked by @UUID[Actor.Item.] on Click",
              'help': "If enabled, clicking a rendered @UUID[Actor. ... Item. ...] tag will roll the linked embedded item. If disabled, or on SHIFT-click, the default action (opening the item's sheet) is taken.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isJumpToFolderTags': {
              'name': "Show Folder Linked by @UUID[Folder.] on Click",
              'help': "If enabled, clicking a rendered @UUID[Folder. ...] tag will switch to that folder's tab and scroll the folder into view. If disabled, or on SHIFT-click, the default action (opening the folder's sheet) is taken.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isShowLinkParent': {
              'name': "Show Parent Icon/Name For Child @UUIDs",
              'help': "If enabled, a rendered @UUID[<parentDocumentName>.<parentId>.<documentName>.<documentId>] tag will display the icon of the parent document type and the name of the parent document, in addition to the usual icon of the document type and the name of the document.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          }
        },
        'misc': {
          'name': "Miscellaneous",
          'settings': {
            'isSkipAddonAutomationCheck': {
              'name': "Skip Addon: Automation Check",
              'help': "Avoid posting to chat if the Addon: Automation companion model is not installed.",
              'default': false,
              'type': "boolean"
            },
            'isSkipBackendCheck': {
              'name': "Skip Backend Check",
              'help': "Avoid sending a network request during module initialisation to check if the modded Plutonium backend is installed.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          },
          'settingsAdvanced': {
            'baseSiteUrl': {
              'name': "Master of Ceremonies Server URL",
              'help': "The root server URL for the Mater of Ceremonies app, used to verify and unlock Patron benefits.",
              'type': 'url',
              'default': "https://plutonium.giddy.cyou",
              'isNullable': true,
              'isReloadRequired': true,
              'unlockCode': 'unlock'
            },
            'backendEndpoint': {
              'name': "Custom Backend Endpoint",
              'help': "The API endpoint used to make calls to the modded Plutonium backend, if available. Note that this API is considered \"internal,\" and is therefore undocumented, and may change on a per-version basis.",
              'default': null,
              'placeholder': "(Use default)",
              'type': "url",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'isPatchFromUuid': {
              'name': "Patch <code>fromUuid</code>",
              'help': "Patch the built-in Foundry function \"fromUuid\" to allow Plutonium-specific UUIDs to be processed. This improves compatibility with some modules.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'equipmentShop': {
          'name': "Equipment Shop",
          'settings': {
            'priceMultiplier': {
              'name': "Price Multiplier",
              'help': "A factor by which the prices in the equipment shop are multiplied.",
              'default': 0x1,
              'type': 'percentage',
              'min': 0.0001
            },
            'startingGold': {
              'name': "Class Starting Gold",
              'help': "A starting gold amount to use instead of a class's starting gold, when using the equipment shop during class creation.",
              'default': null,
              'type': "number",
              'isNullable': true
            },
           /*  'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level",
              'help': "\"Equipment Shop\" button will be hidden for any user with a role less than the chosen role."
            }) */
          }
        },
        'currency': {
          'name': 'Currency',
          'settingsAdvanced': {
            'isNpcUseCurrencySheetItems': {
              'name': "Import Currency as Sheet Item for NPCs",
              'help': "If enabled, the currency component of loot drag-dropped to an NPC sheet will be added as a sheet item. If disabled, it will be added as \"currency\" data instead, which the default " + SharedConsts.SYSTEM_ID_DND5E + " sheet does not display.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'dataSources': {
          'name': "Data Sources",
          'btnsAdditional': [{
            'name': "World Data Source Selector",
            'icon': "fas fa-fw fa-globe-africa",
            'onClick': async () => {
              const {
                WorldDataSourceSelector: _0x3787e7
              } = await Promise.resolve().then(function () {
                return WorldDataSourceSelector$1;
              });
              _0x3787e7.pHandleButtonClick().then(null);
            }
          }, {
            'name': "World Content Blocklist",
            'icon': "fas fa-fw fa-ban",
            'onClick': async () => {
              const {
                WorldContentBlocklistSourceSelector: _0x2b04fc
              } = await Promise.resolve().then(function () {
                return WorldContentBlocklist$1;
              });
              _0x2b04fc.pHandleButtonClick().then(null);
            }
          }],
          'settings': {
            'isPlayerEnableSourceSelection': {
              'name': "Enable Data Source Filtering for Players",
              'help': "Whether or not " + ConfigConsts._STR_DATA_SOURCES + " are filtered down to only those chosen in the \"World Data Source Selector\" application. Applies to players only.",
              'default': false,
              'type': 'boolean',
              'isReloadRequired': true
            },
            'isGmEnableSourceSelection': {
              'name': "Enable Data Source Filtering for GMs",
              'help': "Whether or not " + ConfigConsts._STR_DATA_SOURCES + " are filtered down to only those chosen in the \"World Data Source Selector\" application. Applies to GMs only.",
              'default': false,
              'type': 'boolean',
              'isReloadRequired': true
            },
            'isPlayerForceSelectAllowedSources': {
              'name': "Force Select All for Players",
              'help': "Whether or not all available " + ConfigConsts._STR_DATA_SOURCES + " are forcibly selected for players. Note that this can seriously degrade performance for players if data source filtering is not also enabled.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isGmForceSelectAllowedSources': {
              'name': "Force Select All for GMs",
              'help': "Whether or not all available " + ConfigConsts._STR_DATA_SOURCES + " are forcibly selected for GMs. Note that this can seriously degrade performance for GMs if data source filtering is not also enabled.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isLoadLocalPrereleaseIndex': {
              'name': "Load Local Prerelease Content",
              'help': "If enabled, the directory specified by the \"Local Prerelease Content Directory\" option will be read, and its contents added to the list of available sources.",
              'default': false,
              'type': "boolean"
            },
            'localPrereleaseDirectoryPath': {
              'name': "Local Prerelease Content Directory",
              'help': "The sub-directory of the \"User Data\" directory from which prerelease content should be automatically loaded if the \"Load Local Prerelease\" option is enabled.",
              'default': "assets/prerelease",
              'type': "string",
              'additionalStyleClasses': "code"
            },
            'isUseLocalPrereleaseIndexJson': {
              'name': "Use <code>index.json</code> for Local Prerelease Content",
              'help': "If, rather than read the local prerelease content directory directly, an \"index.json\" file should be read when loading local prerelease content. This file should be of the form: {\"toImport\": [ ... list of filenames ... ]}. Note that this is required if players do not have \"Use File Browser\" permissions.",
              'default': false,
              'type': "boolean"
            },
            'localPrerelease': {
              'name': "Additional Prerelease Files",
              'help': "Prerelease files which should be automatically loaded and added to the list of available sources.",
              'default': [],
              'type': "arrayStringShort",
              'isCaseSensitive': true
            },
            'isLoadLocalHomebrewIndex': {
              'name': "Load Local Homebrew",
              'help': "If enabled, the directory specified by the \"Local Homebrew Directory\" option will be read, and its contents added to the list of available sources.",
              'default': false,
              'type': "boolean"
            },
            'localHomebrewDirectoryPath': {
              'name': "Local Homebrew Directory",
              'help': "The sub-directory of the \"User Data\" directory from which homebrew should be automatically loaded if the \"Load Local Homebrew\" option is enabled.",
              'default': "assets/homebrew",
              'type': "string",
              'additionalStyleClasses': "code"
            },
            'isUseLocalHomebrewIndexJson': {
              'name': "Use <code>index.json</code> for Local Homebrew",
              'help': "If, rather than read the local homebrew directory directly, an \"index.json\" file should be read when loading local homebrew. This file should be of the form: {\"toImport\": [ ... list of filenames ... ]}. Note that this is required if players do not have \"Use File Browser\" permissions.",
              'default': false,
              'type': "boolean"
            },
            'localHomebrew': {
              'name': "Additional Homebrew Files",
              'help': "Homebrew files which should be automatically loaded and added to the list of available sources.",
              'default': [],
              'type': "arrayStringShort",
              'isCaseSensitive': true
            }
          },
          'settingsAdvanced': {
            'tooManySourcesWarningThreshold': {
              'name': "Auto-Selected Source Count Warning Threshold",
              'help': "If set, a warning will be shown when auto-selecting a number of sources greater than this value, which usually occurs if a \"Force Select All...\" option is set, without also \"Enabl[ing] Data Source Filtering.\"",
              'default': 0x32,
              'type': "integer",
              'isNullable': true
            },
            'baseSiteUrl': {
              'name': "Base Site URL",
              'help': "The root server URL from which to load data and source images, and to link in rendered text. Note that, where possible, the module will use its own built-in data files, rather than call out to a remote server.",
              'type': "url",
              'additionalStyleClasses': "code",
              'default': null,
              'isNullable': true,
              'isReloadRequired': true
            },
            'isNoLocalData': {
              'name': "Avoid Loading Local Data",
              'help': "If enabled, any data which would normally be loaded from the module's local copies is instead loaded from the sites URL (which may be customised by editing the \"Base Site Url\" config option).",
              'default': false,
              'type': "boolean"
            },
            'isNoPrereleaseBrewIndexes': {
              'name': "Avoid Loading Prerelease/Homebrew Indexes on Startup",
              'help': "If enabled, prerelease/homebrew repository indexes won't be loaded during initial module load. This will effectively prevent any prerelease/homebrew sources from appearing in source listings. Note that these indexes are loaded in the background/asynchronously during normal operation, so should not negatively impact game load times, unless you have a particularly terrible internet connection.",
              'default': false,
              'type': "boolean"
            },
            'basePrereleaseUrl': {
              'name': "Base Prerelease Repository URL",
              'help': "The root GitHub repository URL from which to load data and source images, and to link in rendered text, when importing prerelease content. URLs should be of the form \"https://raw.githubusercontent.com/[username]/[repository name]/master\".",
              'type': "url",
              'additionalStyleClasses': 'code',
              'default': null,
              'isNullable': true,
              'isReloadRequired': true
            },
            'baseBrewUrl': {
              'name': "Base Homebrew Repository URL",
              'help': "The root GitHub repository URL from which to load data and source images, and to link in rendered text, when importing homebrew content. URLs should be of the form \"https://raw.githubusercontent.com/[username]/[repository name]/master\".",
              'type': "url",
              'additionalStyleClasses': 'code',
              'default': null,
              'isNullable': true,
              'isReloadRequired': true
            }
          }
        },
        /* 'integrationQuickInsert': {
          'name': "Integrations (Quick Insert)",
          'settings': {
            ...ConfigConsts._template_getModuleFauxCompendiumIndexSettings({
              'moduleName': "Quick Insert"
            }),
            'pagesHidden': {
              'name': "Hidden Categories",
              'help': "Categories of entity which should not be indexed.",
              'default': ConfigConsts._QUICK_INSERT_PAGE_METAS.mergeMap(({
                page: _0x25cba7
              }) => ({
                [_0x25cba7]: _0x25cba7 === UrlUtil.PG_RECIPES
              })),
              'type': "multipleChoice",
              'choices': ConfigConsts._QUICK_INSERT_PAGE_METAS.map(({
                page: _0x365d30,
                displayPage: _0x31cbd1
              }) => ({
                'value': _0x365d30,
                'name': _0x31cbd1
              }))
            },
            'isDisplaySource': {
              'name': "Display Sources",
              'help': "If enabled, a source abbreviation will be displayed on each result. If disabled, the module name will be shown instead.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'integrationFoundrySummons': {
          'name': "Integrations (Foundry Summons)",
          'settings': {
            ...ConfigConsts._template_getModuleFauxCompendiumIndexSettings({
              'moduleName': "Foundry Summons"
            })
          }
        },
        'integrationBabele': {
          'name': "Integrations (Babele)",
          'settings': {
            'isEnabled': {
              'name': "Enabled",
              'help': "If enabled, and the Babele module is active, Plutonium will attempt to translate parts of imported content.",
              'default': true,
              'type': "boolean"
            },
            'isUseTranslatedDescriptions': {
              'name': "Use Translated Descriptions",
              'help': "If enabled, and a translated description is found for a document during import, that description will be used instead of the Plutonium default. Note that this may result in embedded functionality (for example, links between documents) being removed.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'integrationThreeDiCanvas': {
          'name': "Integrations (3D Canvas)",
          'settings': {
            'isSetThreeDiModels': {
              'name': "Allow Importer to Set 3D Models",
              'help': "If enabled, and the 3D Canvas, 3D Canvas Mapmaking Pack, and 3D Canvas Token Collection modules are active, Plutonium will attempt to set the \"3D Model\" field on imported tokens.",
              'default': true,
              'type': 'boolean',
              'isReloadRequired': true
            }
          }
        }, */
        'charactermancer': {
          'name': "Charactermancer",
          'settings': {
           /*  'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level",
              'help': "Actor \"Charactermancer\" buttons will be hidden for any user with a role less than the chosen role."
            }) */
          }
        }
      };
    }
    static ["_DEFAULT_CONFIG_SORTED"] = null;
    static ["getDefaultConfigSorted_"]() {
      return this._DEFAULT_CONFIG_SORTED = this._DEFAULT_CONFIG_SORTED || Object.entries(this.getDefaultConfig_()).sort(([, _0xb7c8c5], [, _0x343b25]) => SortUtil.ascSortLower(_0xb7c8c5.name, _0x343b25.name));
    }
    static ["_DEFAULT_CONFIG_SORTED_FLAT"] = null;
    static ["getDefaultConfigSortedFlat_"]() {
      if (this._DEFAULT_CONFIG_SORTED_FLAT) {
        return this._DEFAULT_CONFIG_SORTED_FLAT;
      }
      return this._DEFAULT_CONFIG_SORTED_FLAT = this._DEFAULT_CONFIG_SORTED_FLAT || this.getDefaultConfigSorted_().map(([_0x102f4b, _0x540fe5]) => {
        const _0x417b84 = {};
        this._KEYS_SETTINGS_METAS.forEach(_0x48a0c5 => {
          Object.entries(_0x540fe5[_0x48a0c5] || {}).forEach(([_0x70d0f8, _0x41ed31]) => {
            _0x417b84[_0x70d0f8] = _0x41ed31;
          });
        });
        return [_0x102f4b, _0x417b84];
      });
    }
    static ["getCompendiumPaths"]() {
      const _0x525cb1 = [];
      Object.entries(this.getDefaultConfig_()).forEach(([_0x3661aa, _0x57ce92]) => {
        this._KEYS_SETTINGS_METAS.forEach(_0x435517 => {
          if (!_0x57ce92[_0x435517]) {
            return;
          }
          Object.entries(_0x57ce92[_0x435517]).forEach(([_0x57b4d8, _0x1b0cb0]) => {
            if (_0x1b0cb0.typeSub !== "compendiums") {
              return;
            }
            _0x525cb1.push([_0x3661aa, _0x57b4d8]);
          });
        });
      });
      return _0x525cb1;
    }
  }
  ConfigConsts._STR_DATA_SOURCES = "\"data sources\" (e.g. those displayed in the Import Wizard)";
  ConfigConsts._KEYS_SETTINGS_METAS = ["settings", "settingsHacks", "settingsAdvanced"];
  ConfigConsts._TEMPLATE_ENTITY_OWNERSHIP = {
    'name': "Default Ownership",
    'default': 0x0,
    'type': "enum"
  };
  ConfigConsts._TEMPALTE_MINIMUM_ROLE = {
    'default': 0x0,
    'type': "enum",
    'isReloadRequired': true
  };
  ConfigConsts._DISP_METRIC_POUNDS = "1 pound ≈ 0.5 kilograms";
  ConfigConsts._DISP_METRIC_FEET = "5 feet ≈ 1.5 metres";
  ConfigConsts._DISP_METRIC_MILES = "1 mile ≈ 1.6 kilometres";
  ConfigConsts.SRD_COMPENDIUMS_CREATURES = [SharedConsts.SYSTEM_ID_DND5E + ".monsters"];
  ConfigConsts.SRD_COMPENDIUMS_CREATURE_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".monsterfeatures"];
  ConfigConsts.SRD_COMPENDIUMS_CLASSES = [SharedConsts.SYSTEM_ID_DND5E + ".classes"];
  ConfigConsts.SRD_COMPENDIUMS_SUBCLASSES = [SharedConsts.SYSTEM_ID_DND5E + ".subclasses"];
  ConfigConsts.SRD_COMPENDIUMS_CLASS_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".classfeatures"];
  ConfigConsts.SRD_COMPENDIUMS_ITEMS = [SharedConsts.SYSTEM_ID_DND5E + '.items', SharedConsts.SYSTEM_ID_DND5E + ".tradegoods"];
  ConfigConsts.SRD_COMPENDIUMS_SPELLS = [SharedConsts.SYSTEM_ID_DND5E + '.spells'];
  ConfigConsts.SRD_COMPENDIUMS_OPTIONAL_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".classfeatures"];
  ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".races"];
  ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".backgrounds"];
  ConfigConsts.SRD_COMPENDIUMS_TABLES = [SharedConsts.SYSTEM_ID_DND5E + ".tables"];
  /* ConfigConsts._QUICK_INSERT_PAGE_METAS = [...new Set(Renderer.tag.TAGS.filter(_0x244883 => _0x244883.page).map(_0x2e0a71 => _0x2e0a71.page).filter(_0x5b9350 => ![UrlUtil.PG_QUICKREF, "skill", "sense", "card", 'legroup'].includes(_0x5b9350)))].map(_0x207d8d => {
    let _0x1333af = UrlUtil.pageToDisplayPage(_0x207d8d);
    if (_0x1333af === _0x207d8d) {
      _0x1333af = Parser.getPropDisplayName(_0x207d8d);
    }
    return {
      'page': _0x207d8d,
      'displayPage': _0x1333af
    };
  }).sort(({
    displayPage: _0xb12442
  }, {
    displayPage: _0xb84237
  }) => SortUtil.ascSortLower(_0xb12442, _0xb84237)); */
  ConfigConsts.C_ART_IMAGE_MODE_TOKEN = 0x0;
  ConfigConsts.C_ART_IMAGE_MODE_TILE = 0x1;
  ConfigConsts.C_ART_IMAGE_MODE_NOTE = 0x2;
  ConfigConsts.C_ART_IMAGE_MODE_SCENE = 0x3;
  ConfigConsts.C_ART_DROP_ANCHOR_CENTER = 0x0;
  ConfigConsts.C_ART_DROP_ANCHOR_TOP_LEFT = 0x1;
  ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT = 0x0;
  ConfigConsts.C_ART_IMAGE_SAVE_MODE__ALWAYS = 0x1;
  ConfigConsts.C_ART_IMAGE_SAVE_MODE__NEVER = 0x2;
  ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE = 0x0;
  ConfigConsts.C_IMPORT_DEDUPE_MODE_SKIP = 0x1;
  ConfigConsts.C_IMPORT_DEDUPE_MODE_OVERWRITE = 0x2;
  ConfigConsts.C_IMPORT_DRAG_DROP_MODE_NEVER = 0x0;
  ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT = 0x1;
  ConfigConsts.C_IMPORT_DRAG_DROP_MODE_ALWAYS = 0x2;
  ConfigConsts.C_CREATURE_NAMETAGS_CR = 0x0;
  ConfigConsts.C_CREATURE_NAMETAGS_TYPE = 0x1;
  ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS = 0x2;
  ConfigConsts.C_SPELL_POINTS_MODE__DISABLED = 0x0;
  ConfigConsts.C_SPELL_POINTS_MODE__ENABLED = 0x1;
  ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS = 0x2;
  ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM = "sheetItem";
  ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM = "attributeCustom";
  ConfigConsts.C_ITEM_ATTUNEMENT_NONE = 0x0;
  ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED = 0x1;
  ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED = 0x2;
  ConfigConsts.C_ITEM_ATTUNEMENT_NEVER = 0x0;
  ConfigConsts.C_ITEM_ATTUNEMENT_SMART = 0x1;
  ConfigConsts.C_ITEM_ATTUNEMENT_ALWAYS = 0x2;
  ConfigConsts.C_USE_GAME_DEFAULT = 'VE_USE_GAME_DEFAULT';
  ConfigConsts.C_USE_PLUT_VALUE = "VE_USE_MODULE_VALUE";
  ConfigConsts.C_BOOL_DISABLED = 0x0;
  ConfigConsts.C_BOOL_ENABLED = 0x1;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE = 0x0;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_STANDARD = 0x1;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_GM = 0x2;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_BLIND = 0x3;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_SELF = 0x4;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_HIDDEN = 0x5;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MIN = 0x6;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MAX = 0x7;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE = 0x0;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN = 0x1;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX = 0x2;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL = 0x3;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM = 0x4;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE = 0x5;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES = {
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE]: "Take Average",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN]: "Minimum Value",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX]: "Maximum Value",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL]: "Roll",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM]: "Roll (Custom Formula)",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE]: "Do Not Increase HP"
  };
//#endregion


//#region VeLock
globalThis.VeLock = function({name=null, isDbg=false}={}) {
    this._name = name;
    this._isDbg = isDbg;
    this._lockMeta = null;

    this._getCaller = ()=>{
        return (new Error()).stack.split("\n")[3].trim();
    }
    ;

    this.pLock = async({token=null}={})=>{
        if (token != null && this._lockMeta?.token === token) {
            ++this._lockMeta.depth;
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" add (now ${this._lockMeta.depth}) at ${this._getCaller()}`);
            return token;
        }

        while (this._lockMeta)
            await this._lockMeta.lock;

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" acquired at ${this._getCaller()}`);

        let unlock = null;
        const lock = new Promise(resolve=>unlock = resolve);
        this._lockMeta = {
            lock,
            unlock,
            token: CryptUtil.uid(),
            depth: 0,
        };

        return this._lockMeta.token;
    }
    ;

    this.unlock = ()=>{
        if (!this._lockMeta)
            return;

        if (this._lockMeta.depth > 0) {
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" sub (now ${this._lockMeta.depth - 1}) at ${this._getCaller()}`);
            return --this._lockMeta.depth;
        }

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" released at ${this._getCaller()}`);

        const lockMeta = this._lockMeta;
        this._lockMeta = null;
        lockMeta.unlock();
    }
    ;
}
;
//#endregion
//#region Config
class Config {
    
    static ["_IS_INIT"] = false;
    static ["_IS_INIT_SAVE_REQUIRED"] = false;
    static get ['backendEndpoint']() {
      const _0xa1e040 = Config.get("misc", "backendEndpoint");
      if (_0xa1e040) {
        return _0xa1e040;
      }
      return ROUTE_PREFIX ? '/' + ROUTE_PREFIX + "/api/plutonium" : "/api/plutonium";
    }
    static get ["isInit"]() {
      return this._IS_INIT;
    }
    static ["prePreInit"]() {
      this._preInit_doLoadConfig();
    }
    static ["_preInit_getLoadedConfig"]() {
      let _0x4eb887 = UtilGameSettings.getSafe(SharedConsts.MODULE_ID, Config._SETTINGS_KEY);
      if (_0x4eb887 == null || !Object.keys(_0x4eb887).length) {
        return {
          'isLoaded': false,
          'config': Config._getDefaultGmConfig()
        };
      }
      return {
        'isLoaded': true,
        'config': ConfigMigration.getMigrated({
          'config': _0x4eb887
        })
      };
    }
    static ['_preInit_doLoadConfig']() {
      this._pPrePreInit_registerSettings();
      const {
        isLoaded: _0xa6ae2f,
        config: _0x2491d4
      } = this._preInit_getLoadedConfig();
      Config._CONFIG = _0x2491d4;
      if (_0xa6ae2f) {
        const _0x4150fc = this._populateMissingConfigValues(Config._CONFIG, {
          'isPlayer': false
        });
        this._IS_INIT_SAVE_REQUIRED = this._IS_INIT_SAVE_REQUIRED || _0x4150fc;
      }
      game.socket.on(this._SOCKET_ID, _0x11513f => {
        switch (_0x11513f.type) {
          case "config.update":
            {
              const _0x2829e6 = _0x11513f.config;
              const _0x218c03 = MiscUtil.copy(Config._CONFIG);
              Object.assign(Config._CONFIG, _0x2829e6);
              if (!UtilPrePreInit.isGM()) {
                ConfigApp.handleGmConfigUpdate(_0x2829e6);
              }
              UtilHooks.callAll(UtilHooks.HK_CONFIG_UPDATE, {
                'previous': _0x218c03,
                'current': MiscUtil.copy(Config._CONFIG)
              });
              break;
            }
        }
      });
      if (!UtilPrePreInit.isGM()) {
        const _0x2f835b = GameStorage.getClient(Config._CLIENT_SETTINGS_KEY);
        if (_0x2f835b == null) {
          Config._CONFIG_PLAYER = Config._getDefaultPlayerConfig();
        } else {
          Config._CONFIG_PLAYER = _0x2f835b;
          const _0x2803d0 = this._populateMissingConfigValues(Config._CONFIG_PLAYER, {
            'isPlayer': true
          });
          this._IS_INIT_SAVE_REQUIRED = this._IS_INIT_SAVE_REQUIRED || _0x2803d0;
        }
      }
      this._pInit_initCompatibilityTempOverrides();
      this._IS_INIT = true;
    }
    static ['_COMPATIBILITY_TEMP_OVERRIDES'] = null;
    static ["_pInit_initCompatibilityTempOverrides"]() {
      ConfigConsts.getDefaultConfigSortedFlat_().forEach(([_0x5f00ec, _0x5379fb]) => {
        Object.entries(_0x5379fb).forEach(([_0x20a13a, _0x3eecc1]) => {
          if (!_0x3eecc1.compatibilityModeValues) {
            return;
          }
          Object.entries(_0x3eecc1.compatibilityModeValues).find(([_0x25d591, _0x5ef870]) => {
            const _0x540a72 = _0x3eecc1.type === "enum" ? ConfigUtilsSettings.getEnumValueValue(_0x5ef870) : _0x5ef870;
            const _0x2883d8 = _0x3eecc1.type === "enum" ? _0x5ef870.name || _0x540a72 : _0x540a72;
            if (!UtilCompat.isModuleActive(_0x25d591)) {
              return false;
            }
            const _0x4a4aec = Config.get(_0x5f00ec, _0x20a13a);
            const _0x486d1b = !CollectionUtil.deepEquals(_0x540a72, _0x4a4aec);
            Config.setTemp(_0x5f00ec, _0x20a13a, _0x540a72, {
              'isSkipPermissionCheck': true
            });
            if (_0x486d1b) {
              const {
                displayGroup: _0x314d1c,
                displayKey: _0x4cabc2
              } = Config._getDisplayLabels(_0x5f00ec, _0x20a13a);
              const _0x5d4132 = _0x4a4aec != null ? JSON.stringify(_0x4a4aec) : _0x4a4aec;
              const _0x4fb80d = _0x2883d8 != null ? JSON.stringify(_0x2883d8) : _0x2883d8;
              this._COMPATIBILITY_TEMP_OVERRIDES = this._COMPATIBILITY_TEMP_OVERRIDES || {};
              MiscUtil.set(this._COMPATIBILITY_TEMP_OVERRIDES, _0x5f00ec, _0x20a13a, {
                'value': _0x540a72,
                'message': "\"" + _0x314d1c + " -&gt; " + _0x4cabc2 + "\" value `" + _0x5d4132 + "` has compatibility issues with module \"" + game.modules.get(_0x25d591).title + "\" (must be set to `" + _0x4fb80d + '`)'
              });
              console.warn(...LGT, game.modules.get(_0x25d591).title + " detected! Setting compatibility config: " + _0x5f00ec + '.' + _0x20a13a + " = " + _0x4fb80d + " (was " + _0x5d4132 + "). If you encounter unexpected issues, consider disabling either module.");
            }
          });
        });
      });
    }
    static ["_hasCompatibilityWarnings"]() {
      return this._COMPATIBILITY_TEMP_OVERRIDES != null;
    }
    static ["_getCompatibilityWarnings"]() {
      if (!this._COMPATIBILITY_TEMP_OVERRIDES) {
        return '';
      }
      const _0x35b741 = Object.values(this._COMPATIBILITY_TEMP_OVERRIDES).map(_0x152dda => Object.values(_0x152dda).map(_0x120f14 => _0x120f14.message)).flat().map(_0xcf5598 => " - " + _0xcf5598).join("\n");
      return "Click to resolve config module compatibility issues. Issues detected:\n" + _0x35b741 + '.';
    }
    static ["_doResolveCompatibility"]() {
      Object.entries(this._COMPATIBILITY_TEMP_OVERRIDES).forEach(([_0xf82a5d, _0x3d417f]) => {
        Object.entries(_0x3d417f).forEach(([_0x10d0e6, _0x5141bd]) => {
          Config.set(_0xf82a5d, _0x10d0e6, _0x5141bd.value);
        });
      });
      this._COMPATIBILITY_TEMP_OVERRIDES = null;
    }
    static ['_pPrePreInit_registerSettings']() {
      game.settings.register(SharedConsts.MODULE_ID, Config._SETTINGS_KEY, {
        'name': 'Config',
        'default': {},
        'type': Object,
        'scope': "world",
        'onChange': _0x2cf485 => {}
      });
    }
    static ["pOpen"]({
      evt = null,
      initialVisibleGroup = null
    } = {}) {
      return ConfigApp.pOpen({
        'evt': evt,
        'initialVisibleGroup': initialVisibleGroup,
        'backend': this
      });
    }
    static ["_populateMissingConfigValues"](_0x269be7, _0x40a182) {
      _0x40a182 = _0x40a182 || {};
      const _0x5ddf60 = !!_0x40a182.isPlayer;
      let _0x811367 = false;
      Object.entries(this._getDefaultConfig({
        'isPlayer': _0x5ddf60
      })).forEach(([_0x159930, _0x40e344]) => {
        if (!_0x269be7[_0x159930]) {
          _0x269be7[_0x159930] = _0x40e344;
          _0x811367 = true;
        } else {
          Object.entries(_0x40e344).forEach(([_0xfb319f, _0x2cb8c5]) => {
            if (_0x269be7[_0x159930][_0xfb319f] === undefined) {
              _0x269be7[_0x159930][_0xfb319f] = _0x2cb8c5;
              _0x811367 = true;
            }
          });
        }
      });
      return _0x811367;
    }
    static async ["pInit"]() {
      if (this._IS_INIT_SAVE_REQUIRED) {
        Config._saveConfigDebounced();
      }
      this._IS_INIT_SAVE_REQUIRED = false;
    }
    static ["_getDefaultGmConfig"]() {
      return this._getDefaultConfig({
        'isPlayer': false
      });
    }
    static ["_getDefaultPlayerConfig"]() {
      return this._getDefaultConfig({
        'isPlayer': true
      });
    }
    static ["_getDefaultConfig"](_0x3ef533) {
      _0x3ef533 = _0x3ef533 || {};
      const _0x3a1d8e = _0x3ef533.isPlayer;
      const _0x1f778c = MiscUtil.copy(ConfigConsts.getDefaultConfigSorted_());
      const _0x39f69c = {};
      _0x1f778c.forEach(([_0x1e3fbb, _0x120dfe]) => {
        const _0x5a892a = _0x39f69c[_0x1e3fbb] = {};
        const _0x2a5160 = _0x1fa78d => Object.entries(_0x1fa78d).forEach(([_0x249b71, _0x38a295]) => {
          if (_0x3a1d8e) {
            if (_0x38a295.isPlayerEditable) {
              _0x5a892a[_0x249b71] = null;
            }
          } else {
            _0x5a892a[_0x249b71] = _0x38a295["default"];
          }
        });
        if (_0x120dfe.settings) {
          _0x2a5160(_0x120dfe.settings);
        }
        if (_0x120dfe.settingsAdvanced) {
          _0x2a5160(_0x120dfe.settingsAdvanced);
        }
        if (_0x120dfe.settingsHacks) {
          _0x2a5160(_0x120dfe.settingsHacks);
        }
      });
      _0x39f69c.version = ConfigMigration.CURRENT_VERSION;
      return _0x39f69c;
    }
    static ['set'](_0x4f9d2a, _0x1112ce, _0xc4fc91) {
      if (!this._isCanSetConfig(_0x4f9d2a, _0x1112ce)) {
        return;
      }
      const _0x122bb6 = Config.get(_0x4f9d2a, _0x1112ce);
      const _0x5ededb = UtilPrePreInit.isGM() ? Config._CONFIG : Config._CONFIG_PLAYER;
      (_0x5ededb[_0x4f9d2a] = _0x5ededb[_0x4f9d2a] || {})[_0x1112ce] = _0xc4fc91;
      Config._saveConfigDebounced();
      this._fireConfigUpdateHook(_0x4f9d2a, _0x1112ce, _0x122bb6, _0xc4fc91);
    }
    static ['setTemp'](_0x43e89c, _0x14b600, _0x30dc13, {
      isSkipPermissionCheck = false
    } = {}) {
      if (!isSkipPermissionCheck && !this._isCanSetConfig(_0x43e89c, _0x14b600)) {
        return;
      }
      const _0x10d336 = Config.get(_0x43e89c, _0x14b600);
      (Config._CONFIG_TEMP[_0x43e89c] = Config._CONFIG_TEMP[_0x43e89c] || {})[_0x14b600] = _0x30dc13;
      this._fireConfigUpdateHook(_0x43e89c, _0x14b600, _0x10d336, _0x30dc13);
    }
    static ["setRivetTargetDocument"]({
      actor: _0x7aa906,
      pack: _0x11cb33
    } = {}) {
      if (_0x7aa906 && _0x11cb33) {
        throw new Error("Only one of \"actor\" or \"pack\" may be specified!");
      }
      if (!_0x7aa906 && !_0x11cb33) {
        ui.notifications.info("Cleared Rivet import target. Rivet will now import to an appropriate directory.");
        Config.set("rivet", "targetDocumentId", null);
        return;
      }
      if (_0x7aa906) {
        const _0x4dae8a = _0x7aa906.isToken ? _0x7aa906.uuid : _0x7aa906.id;
        if (Config.get("rivet", "targetDocumentId") === _0x4dae8a) {
          Config.set("rivet", "targetDocumentId", null);
          ui.notifications.warn("Cleared Rivet import target. Rivet will now import to an appropriate directory.");
          return;
        }
        Config.set("rivet", 'targetDocumentId', _0x4dae8a);
        ui.notifications.info("Set Rivet import target. Rivet will now import to Actor \"" + _0x7aa906.name + "\" (" + _0x4dae8a + "). This can be changed in the Config.");
        return;
      }
      if (_0x11cb33) {
        const _0xef065a = 'Compendium.' + _0x11cb33.metadata.id;
        if (Config.get('rivet', 'targetDocumentId') === _0xef065a) {
          Config.set("rivet", "targetDocumentId", null);
          ui.notifications.warn("Cleared Rivet import target. Rivet will now import to an appropriate directory.");
          return;
        }
        Config.set('rivet', "targetDocumentId", _0xef065a);
        ui.notifications.info("Set Rivet import target. Rivet will now import to Compendium \"" + _0x11cb33.metadata.label + "\" (" + _0x11cb33.metadata.id + "). This can be changed in the Config.");
      }
    }
    static ["_fireConfigUpdateHook"](_0x374034, _0xb156d3, _0x305b29, _0xea010c) {
      UtilHooks.callAll(UtilHooks.HK_CONFIG_UPDATE, {
        'previous': {
          [_0x374034]: {
            [_0xb156d3]: _0x305b29
          }
        },
        'current': {
          [_0x374034]: {
            [_0xb156d3]: _0xea010c
          }
        }
      });
    }
    static ["_isCanSetConfig"](_0x347dfb, _0x3965df) {
      return UtilPrePreInit.isGM() || ConfigUtilsSettings.isPlayerEditable(_0x347dfb, _0x3965df);
    }
    static ["_LOCK_SAVE_CONFIG"] = new VeLock({
      'name': "save config"
    });
    static async ["_pSaveConfig"]() {
      try {
        await this._LOCK_SAVE_CONFIG.pLock();
        await this._pSaveConfig_();
      } finally {
        this._LOCK_SAVE_CONFIG.unlock();
      }
    }
    static async ["_pSaveConfig_"]() {
      if (!UtilPrePreInit.isGM()) {
        await GameStorage.pSetClient(Config._CLIENT_SETTINGS_KEY, MiscUtil.copy(Config._CONFIG_PLAYER));
        return;
      }
      await game.settings.set(SharedConsts.MODULE_ID, Config._SETTINGS_KEY, MiscUtil.copy(Config._CONFIG));
      const _0x473106 = {
        'type': "config.update",
        'config': MiscUtil.copy(this._CONFIG)
      };
      game.socket.emit(Config._SOCKET_ID, _0x473106);
    }
    static ["_saveConfigDebounced"] = MiscUtil.throttle(Config._pSaveConfig, 0x64);
    static get(_0x1f916e, _0x501497, {isIgnorePlayer = false} = {}) {
      if (Config._CONFIG_TEMP[_0x1f916e]?.[_0x501497] !== undefined) {
        return Config._CONFIG_TEMP[_0x1f916e][_0x501497];
      }
      if (!UtilPrePreInit.isGM() && ConfigUtilsSettings.isPlayerEditable(_0x1f916e, _0x501497) && !isIgnorePlayer) {
        const _0x15b827 = (Config._CONFIG_PLAYER[_0x1f916e] || {})[_0x501497];
        if (ConfigUtilsSettings.isNullable(_0x1f916e, _0x501497) && _0x15b827 === null || _0x15b827 != null) {
          return this._get_getValidValue(_0x1f916e, _0x501497, _0x15b827);
        }
      }
      const _0x470979 = (Config._CONFIG[_0x1f916e] || {})[_0x501497];
      return this._get_getValidValue(_0x1f916e, _0x501497, _0x470979);
    }
    static ["_get_getValidValue"](_0x2319bc, _0x734aa3, _0x56c713) {
      const _0x14e622 = ConfigConsts.getDefaultConfigSortedFlat_().find(([_0x35aa58]) => _0x35aa58 === _0x2319bc)[0x1][_0x734aa3];
      if (_0x14e622.type !== "enum") {
        return _0x56c713;
      }
      if (_0x14e622.isNullable && _0x56c713 == null) {
        return _0x56c713;
      }
      const _0x4bd728 = ConfigUtilsSettings.getEnumValues(_0x14e622);
      if (_0x56c713 == null || !_0x4bd728.some(_0x472e97 => (_0x472e97.value ?? _0x472e97) === _0x56c713)) {
        return _0x14e622["default"] ?? _0x4bd728[0x0].value ?? _0x4bd728[0x0];
      }
      return _0x56c713;
    }
    static ["_getDisplayLabels"](_0x288279, _0xf85c74) {
      const _0x6262b3 = ConfigConsts.getDefaultConfig_();
      const _0x5cebfe = _0x6262b3[_0x288279]?.["name"];
      const _0x956382 = _0x6262b3[_0x288279]?.["settings"]?.[_0xf85c74]?.['name'] || _0x6262b3[_0x288279]?.['settingsAdvanced']?.[_0xf85c74]?.["name"] || _0x6262b3[_0x288279]?.['settingsHacks']?.[_0xf85c74]?.['name'];
      return {
        'displayGroup': _0x5cebfe,
        'displayKey': _0x956382
      };
    }
    static ['has'](_0x23c99c, _0x413db8) {
      return !!ConfigConsts.getDefaultConfigSortedFlat_().find(([_0x24a9a0]) => _0x24a9a0 === _0x23c99c)?.[0x1]?.[_0x413db8];
    }
    static ["getSafe"](_0x48e921, _0x55bcb1) {
      try {
        return this.get(_0x48e921, _0x55bcb1);
      } catch (_0x3f1440) {
        return undefined;
      }
    }
    static ["handleFailedInitConfigApplication"](_0x26ed85, _0x525fb9, _0x1a25c6) {
      const {
        displayGroup: _0x576794,
        displayKey: _0x1c32ad
      } = Config._getDisplayLabels(_0x26ed85, _0x525fb9);
      ui.notifications.error("Failed to apply Config \"" + _0x1c32ad + "\" -> \"" + _0x576794 + "\" during initial load! " + VeCt.STR_SEE_CONSOLE);
      if (_0x1a25c6) {
        console.error(...LGT, _0x1a25c6);
      }
    }
    static ["isUseMetricDistance"]({
      configGroup: _0x4095b3,
      configKey = "isMetricDistance"
    }) {
      return Config.get("import", "isGlobalMetricDistance") || Config.has(_0x4095b3, configKey) && Config.get(_0x4095b3, configKey);
    }
    static ["isUseMetricWeight"]({
      configGroup: _0x335df5,
      configKey = "isMetricWeight"
    }) {
      if (UtilGameSettings.getSafe(game.system.id, "metricWeightUnits")) {
        return true;
      }
      return Config.get('import', "isGlobalMetricWeight") || Config.has(_0x335df5, configKey) && Config.get(_0x335df5, configKey);
    }
    static ["getMetricNumberDistance"]({
      configGroup: _0x287496,
      originalValue: _0x2525c8,
      originalUnit: _0x15cbf9,
      configKey = "isMetricDistance",
      toFixed: _0x4780c3
    }) {
      return this._getMetricNumber({
        'configGroup': _0x287496,
        'originalValue': _0x2525c8,
        'originalUnit': _0x15cbf9,
        'configKey': configKey,
        'fnIsUse': Config.isUseMetricDistance.bind(Config),
        'toFixed': _0x4780c3
      });
    }
    static ['getMetricNumberWeight']({
      configGroup: _0x472563,
      originalValue: _0x3bcac6,
      originalUnit: _0x2715b2,
      configKey = "isMetricWeight",
      toFixed: _0x371dc8
    }) {
      return this._getMetricNumber({
        'configGroup': _0x472563,
        'originalValue': _0x3bcac6,
        'originalUnit': _0x2715b2,
        'configKey': configKey,
        'fnIsUse': Config.isUseMetricWeight.bind(Config),
        'toFixed': _0x371dc8
      });
    }
    static ["_getMetricNumber"]({
      configGroup: _0x3f59a7,
      originalValue: _0xb3e2df,
      originalUnit: _0x48ea42,
      configKey: _0x3f6086,
      fnIsUse: _0x4e4c24,
      toFixed: _0x13e977
    }) {
      if (!_0x4e4c24({
        'configGroup': _0x3f59a7,
        'configKey': _0x3f6086
      })) {
        if (_0x13e977) {
          return NumberUtil.toFixedNumber(_0xb3e2df, _0x13e977);
        }
        return _0xb3e2df;
      }
      return Parser.metric.getMetricNumber({
        'originalValue': _0xb3e2df,
        'originalUnit': _0x48ea42,
        'toFixed': _0x13e977 ?? 0x3
      });
    }
    static ['getMetricUnitDistance']({
      configGroup: _0x293bb4,
      originalUnit: _0x3ed5b6,
      configKey = "isMetricDistance",
      isShortForm = true,
      isPlural = false
    }) {
      return this._getMetricUnit({
        'configGroup': _0x293bb4,
        'originalUnit': _0x3ed5b6,
        'configKey': configKey,
        'isShortForm': isShortForm,
        'isPlural': isPlural,
        'fnIsUse': Config.isUseMetricDistance.bind(Config)
      });
    }
    static ["getMetricUnitWeight"]({
      configGroup: _0x486606,
      originalUnit: _0x50698d,
      configKey = "isMetricWeight",
      isShortForm = true,
      isPlural = false
    }) {
      return this._getMetricUnit({
        'configGroup': _0x486606,
        'originalUnit': _0x50698d,
        'configKey': configKey,
        'isShortForm': isShortForm,
        'isPlural': isPlural,
        'fnIsUse': Config.isUseMetricWeight.bind(Config)
      });
    }
    static ["_getMetricUnit"]({
      configGroup: _0x50bdc7,
      originalUnit: _0x5f0dc8,
      configKey: _0x4280fe,
      isShortForm: _0x45e3bf,
      isPlural: _0x44cab6,
      fnIsUse: _0x2933c2
    }) {
      if (!_0x2933c2({
        'configGroup': _0x50bdc7,
        'configKey': _0x4280fe
      })) {
        if (!_0x45e3bf) {
          return _0x5f0dc8;
        }
        switch (_0x5f0dc8) {
          case Parser.UNT_FEET:
            return 'ft';
          case Parser.UNT_YARDS:
            return 'yd';
          case Parser.UNT_MILES:
            return 'mi';
          default:
            return _0x5f0dc8;
        }
      }
      return Parser.metric.getMetricUnit({
        'originalUnit': _0x5f0dc8,
        'isShortForm': _0x45e3bf,
        'isPlural': _0x44cab6
      });
    }
    static ["getSpellPointsKey"]({
      actorType: _0x34101f
    }) {
      return _0x34101f === 'character' ? "spellPointsMode" : "spellPointsModeNpc";
    }
    static ["getSpellPointsResource"]({
      isValueKey = false,
      isMaxKey = false
    } = {}) {
      return this._getSpellPsiPointsResource({
        'configGroup': "importSpell",
        'configKey': "spellPointsResource",
        'configKeyCustom': "spellPointsResourceCustom",
        'isValueKey': isValueKey,
        'isMaxKey': isMaxKey
      });
    }
    static ["getPsiPointsResource"]({
      isValueKey = false,
      isMaxKey = false
    } = {}) {
      return this._getSpellPsiPointsResource({
        'configGroup': "importPsionic",
        'configKey': "psiPointsResource",
        'configKeyCustom': "psiPointsResourceCustom",
        'isValueKey': isValueKey,
        'isMaxKey': isMaxKey
      });
    }
    static ["_getSpellPsiPointsResource"]({
      configGroup: _0x5ff393,
      configKey: _0x61a78,
      configKeyCustom: _0x27b383,
      isValueKey = false,
      isMaxKey = false
    } = {}) {
      if (Config.get(_0x5ff393, _0x61a78) === ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM) {
        return ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM;
      }
      if (isValueKey && isMaxKey) {
        throw new Error("Only one of \"isValue\" and \"isMax\" may be specified!");
      }
      const _0x265e6e = Config.get(_0x5ff393, _0x61a78) === ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM ? Config.get(_0x5ff393, _0x27b383) : Config.get(_0x5ff393, _0x61a78);
      return isValueKey ? _0x265e6e + ".value" : isMaxKey ? _0x265e6e + ".max" : _0x265e6e;
    }
}
Config._SETTINGS_KEY = "config";
Config._CLIENT_SETTINGS_KEY = SharedConsts.MODULE_ID + '_config';
Config._SOCKET_ID = "module." + SharedConsts.MODULE_ID;
Config._CONFIG = {};
Config._CONFIG_PLAYER = {};
Config._CONFIG_TEMP = {};
//#endregion

//#region DataUtil
class _DataUtilPropConfig {
    static _MERGE_REQUIRES_PRESERVE = {};
    static _PAGE = null;

    static get PAGE() {
        return this._PAGE;
    }

    static async pMergeCopy(lst, ent, options) {
        return DataUtil.generic._pMergeCopy(this, this._PAGE, lst, ent, options);
    }
}

class _DataUtilPropConfigSingleSource extends _DataUtilPropConfig {
    static _FILENAME = null;

    static getDataUrl() {
        return `${Renderer.get().baseUrl}data/${this._FILENAME}`;
    }

    static async loadJSON() {
        return this.loadRawJSON();
    }
    static async loadRawJSON() {
        return DataUtil.loadJSON(this.getDataUrl());
    }
    static async loadUnmergedJSON() {
        return DataUtil.loadRawJSON(this.getDataUrl());
    }
}

class _DataUtilPropConfigMultiSource extends _DataUtilPropConfig {
    static _DIR = null;
    static _PROP = null;
    static _IS_MUT_ENTITIES = false;

    static get _isFluff() {
        return this._PROP.endsWith("Fluff");
    }

    static _P_INDEX = null;

    static pLoadIndex() {
        this._P_INDEX = this._P_INDEX || DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${this._DIR}/${this._isFluff ? `fluff-` : ""}index.json`);
        return this._P_INDEX;
    }

    static async pLoadAll() {
        const json = await this.loadJSON();
        return json[this._PROP];
    }

    static async loadJSON() {
        return this._loadJSON({
            isUnmerged: false
        });
    }
    static async loadUnmergedJSON() {
        return this._loadJSON({
            isUnmerged: true
        });
    }

    static async _loadJSON({isUnmerged=false}={}) {
        const index = await this.pLoadIndex();

        const allData = await Object.entries(index).pMap(async([source,file])=>this._pLoadSourceEntities({
            source,
            isUnmerged,
            file
        }));

        return {
            [this._PROP]: allData.flat()
        };
    }

    static async pLoadSingleSource(source) {
        const index = await this.pLoadIndex();

        const file = index[source];
        if (!file)
            return null;

        return {
            [this._PROP]: await this._pLoadSourceEntities({
                source,
                file
            })
        };
    }

    static async _pLoadSourceEntities({source, isUnmerged=false, file}) {
        await this._pInitPreData();

        const fnLoad = isUnmerged ? DataUtil.loadRawJSON.bind(DataUtil) : DataUtil.loadJSON.bind(DataUtil);

        let data = await fnLoad(`${Renderer.get().baseUrl}data/${this._DIR}/${file}`);
        data = data[this._PROP].filter(it=>it.source === source);

        if (!this._IS_MUT_ENTITIES)
            return data;

        return data.map(ent=>this._mutEntity(ent));
    }

    static _P_INIT_PRE_DATA = null;

    static async _pInitPreData() {
        return (this._P_INIT_PRE_DATA = this._P_INIT_PRE_DATA || this._pInitPreData_());
    }

    static async _pInitPreData_() {}

    static _mutEntity(ent) {
        return ent;
    }
}

class _DataUtilPropConfigCustom extends _DataUtilPropConfig {
    static async loadJSON() {
        throw new Error("Unimplemented!");
    }
    static async loadUnmergedJSON() {
        throw new Error("Unimplemented!");
    }
}

class _DataUtilBrewHelper {
    constructor({defaultUrlRoot}) {
        this._defaultUrlRoot = defaultUrlRoot;
    }

    _getCleanUrlRoot(urlRoot) {
        if (urlRoot && urlRoot.trim()) {
            urlRoot = urlRoot.trim();
            if (!urlRoot.endsWith("/"))
                urlRoot = `${urlRoot}/`;
            return urlRoot;
        }
        return this._defaultUrlRoot;
    }

    async pLoadTimestamps(urlRoot) {
        urlRoot = this._getCleanUrlRoot(urlRoot);
        return DataUtil.loadJSON(`${urlRoot}_generated/index-timestamps.json`);
    }

    async pLoadPropIndex(urlRoot) {
        urlRoot = this._getCleanUrlRoot(urlRoot);
        return DataUtil.loadJSON(`${urlRoot}_generated/index-props.json`);
    }

    async pLoadMetaIndex(urlRoot) {
        urlRoot = this._getCleanUrlRoot(urlRoot);
        return DataUtil.loadJSON(`${urlRoot}_generated/index-meta.json`);
    }

    async pLoadSourceIndex(urlRoot) {
        urlRoot = this._getCleanUrlRoot(urlRoot);
        return DataUtil.loadJSON(`${urlRoot}_generated/index-sources.json`);
    }

    getFileUrl(path, urlRoot) {
        urlRoot = this._getCleanUrlRoot(urlRoot);
        return `${urlRoot}${path}`;
    }
}
globalThis.DataUtil = {
    _loading: {},
    _loaded: {},
    _merging: {},
    _merged: {},

    async _pLoad({url, id, isBustCache=false}) {
        if (DataUtil._loading[id] && !isBustCache) {
            await DataUtil._loading[id];
            return DataUtil._loaded[id];
        }

        DataUtil._loading[id] = new Promise((resolve,reject)=>{
            const request = new XMLHttpRequest();

            request.open("GET", url, true);
            request.overrideMimeType("application/json");

            request.onload = function() {
                try {
                    DataUtil._loaded[id] = JSON.parse(this.response);
                    resolve();
                } catch (e) {
                    reject(new Error(`Could not parse JSON from ${url}: ${e.message}`));
                }
            }
            ;
            request.onerror = (e)=>{
                const ptDetail = ["status", "statusText", "readyState", "response", "responseType", ].map(prop=>`${prop}=${JSON.stringify(e.target[prop])}`).join(" ");
                reject(new Error(`Error during JSON request: ${ptDetail}`));
            }
            ;

            request.send();
        }
        );

        await DataUtil._loading[id];
        return DataUtil._loaded[id];
    },

    _mutAddProps(data) {
        if (data && typeof data === "object") {
            for (const k in data) {
                if (data[k]instanceof Array) {
                    for (const it of data[k]) {
                        if (typeof it !== "object")
                            continue;
                        it.__prop = k;
                    }
                }
            }
        }
    },

    async loadJSON(url) {
        return DataUtil._loadJson(url, {
            isDoDataMerge: true
        });
    },

    async loadRawJSON(url, {isBustCache}={}) {
        return DataUtil._loadJson(url, {
            isBustCache
        });
    },

    async _loadJson(url, {isDoDataMerge=false, isBustCache=false}={}) {
        const procUrl = UrlUtil.link(url, {
            isBustCache
        });

        let data;
        try {
            data = await DataUtil._pLoad({
                url: procUrl,
                id: url,
                isBustCache
            });
        } catch (e) {
            setTimeout(()=>{
                throw e;
            }
            );
        }

        if (!data)
            data = await DataUtil._pLoad({
                url: url,
                id: url,
                isBustCache
            });

        if (isDoDataMerge)
            await DataUtil.pDoMetaMerge(url, data);

        return data;
    },

    async pDoMetaMerge(ident, data, options) {
        DataUtil._mutAddProps(data);
        DataUtil._merging[ident] = DataUtil._merging[ident] || DataUtil._pDoMetaMerge(ident, data, options);
        await DataUtil._merging[ident];
        const out = DataUtil._merged[ident];

        if (options?.isSkipMetaMergeCache) {
            delete DataUtil._merging[ident];
            delete DataUtil._merged[ident];
        }

        return out;
    },

    _pDoMetaMerge_handleCopyProp(prop, arr, entry, options) {
        if (!entry._copy)
            return;
        let fnMergeCopy = DataUtil[prop]?.pMergeCopy;
        if (!fnMergeCopy)
            throw new Error(`No dependency _copy merge strategy specified for property "${prop}"`);
        fnMergeCopy = fnMergeCopy.bind(DataUtil[prop]);
        return fnMergeCopy(arr, entry, options);
    },

    async _pDoMetaMerge(ident, data, options) {
        if (data._meta) {
            const loadedSourceIds = new Set();

            if (data._meta.dependencies) {
                await Promise.all(Object.entries(data._meta.dependencies).map(async([dataProp,sourceIds])=>{
                    sourceIds.forEach(sourceId=>loadedSourceIds.add(sourceId));

                    if (!data[dataProp])
                        return;
                    const isHasInternalCopies = (data._meta.internalCopies || []).includes(dataProp);

                    const dependencyData = await Promise.all(sourceIds.map(sourceId=>DataUtil.pLoadByMeta(dataProp, sourceId)));

                    const flatDependencyData = dependencyData.map(dd=>dd[dataProp]).flat().filter(Boolean);
                    await Promise.all(data[dataProp].map(entry=>DataUtil._pDoMetaMerge_handleCopyProp(dataProp, flatDependencyData, entry, {
                        ...options,
                        isErrorOnMissing: !isHasInternalCopies
                    })));
                }
                ));
                delete data._meta.dependencies;
            }

            if (data._meta.internalCopies) {
                for (const prop of data._meta.internalCopies) {
                    if (!data[prop])
                        continue;
                    for (const entry of data[prop]) {
                        await DataUtil._pDoMetaMerge_handleCopyProp(prop, data[prop], entry, {
                            ...options,
                            isErrorOnMissing: true
                        });
                    }
                }
                delete data._meta.internalCopies;
            }

            if (data._meta.includes) {
                const includesData = await Promise.all(Object.entries(data._meta.includes).map(async([dataProp,sourceIds])=>{
                    sourceIds = sourceIds.filter(it=>!loadedSourceIds.has(it));

                    sourceIds.forEach(sourceId=>loadedSourceIds.add(sourceId));

                    const includesData = await Promise.all(sourceIds.map(sourceId=>DataUtil.pLoadByMeta(dataProp, sourceId)));

                    const flatIncludesData = includesData.map(dd=>dd[dataProp]).flat().filter(Boolean);
                    return {
                        dataProp,
                        flatIncludesData
                    };
                }
                ));
                delete data._meta.includes;

                includesData.forEach(({dataProp, flatIncludesData})=>{
                    data[dataProp] = [...data[dataProp] || [], ...flatIncludesData];
                }
                );
            }
        }

        if (data._meta && data._meta.otherSources) {
            await Promise.all(Object.entries(data._meta.otherSources).map(async([dataProp,sourceIds])=>{
                const additionalData = await Promise.all(Object.entries(sourceIds).map(async([sourceId,findWith])=>({
                    findWith,
                    dataOther: await DataUtil.pLoadByMeta(dataProp, sourceId),
                })));

                additionalData.forEach(({findWith, dataOther})=>{
                    const toAppend = dataOther[dataProp].filter(it=>it.otherSources && it.otherSources.find(os=>os.source === findWith));
                    if (toAppend.length)
                        data[dataProp] = (data[dataProp] || []).concat(toAppend);
                }
                );
            }
            ));
            delete data._meta.otherSources;
        }

        if (data._meta && !Object.keys(data._meta).length)
            delete data._meta;

        DataUtil._merged[ident] = data;
    },

    async pDoMetaMergeSingle(prop, meta, ent) {
        return (await DataUtil.pDoMetaMerge(CryptUtil.uid(), {
            _meta: meta,
            [prop]: [ent],
        }, {
            isSkipMetaMergeCache: true,
        }, ))[prop][0];
    },

    getCleanFilename(filename) {
        return filename.replace(/[^-_a-zA-Z0-9]/g, "_");
    },

    getCsv(headers, rows) {
        function escapeCsv(str) {
            return `"${str.replace(/"/g, `""`).replace(/ +/g, " ").replace(/\n\n+/gi, "\n\n")}"`;
        }

        function toCsv(row) {
            return row.map(str=>escapeCsv(str)).join(",");
        }

        return `${toCsv(headers)}\n${rows.map(r=>toCsv(r)).join("\n")}`;
    },

    userDownload(filename, data, {fileType=null, isSkipAdditionalMetadata=false, propVersion="siteVersion", valVersion=VERSION_NUMBER}={}) {
        filename = `${filename}.json`;
        if (isSkipAdditionalMetadata || data instanceof Array)
            return DataUtil._userDownload(filename, JSON.stringify(data, null, "\t"), "text/json");

        data = {
            [propVersion]: valVersion,
            ...data
        };
        if (fileType != null)
            data = {
                fileType,
                ...data
            };
        return DataUtil._userDownload(filename, JSON.stringify(data, null, "\t"), "text/json");
    },

    userDownloadText(filename, string) {
        return DataUtil._userDownload(filename, string, "text/plain");
    },

    _userDownload(filename, data, mimeType) {
        const a = document.createElement("a");
        const t = new Blob([data],{
            type: mimeType
        });
        a.href = window.URL.createObjectURL(t);
        a.download = filename;
        a.dispatchEvent(new MouseEvent("click",{
            bubbles: true,
            cancelable: true,
            view: window
        }));
        setTimeout(()=>window.URL.revokeObjectURL(a.href), 100);
    },

    pUserUpload({isMultiple=false, expectedFileTypes=null, propVersion="siteVersion", }={}, ) {
        return new Promise(resolve=>{
            const $iptAdd = $(`<input type="file" ${isMultiple ? "multiple" : ""} class="ve-hidden" accept=".json">`).on("change", (evt)=>{
                const input = evt.target;

                const reader = new FileReader();
                let readIndex = 0;
                const out = [];
                const errs = [];

                reader.onload = async()=>{
                    const name = input.files[readIndex - 1].name;
                    const text = reader.result;

                    try {
                        const json = JSON.parse(text);

                        const isSkipFile = expectedFileTypes != null && json.fileType && !expectedFileTypes.includes(json.fileType) && !(await InputUiUtil.pGetUserBoolean({
                            textYes: "Yes",
                            textNo: "Cancel",
                            title: "File Type Mismatch",
                            htmlDescription: `The file "${name}" has the type "${json.fileType}" when the expected file type was "${expectedFileTypes.join("/")}".<br>Are you sure you want to upload this file?`,
                        }));

                        if (!isSkipFile) {
                            delete json.fileType;
                            delete json[propVersion];

                            out.push({
                                name,
                                json
                            });
                        }
                    } catch (e) {
                        errs.push({
                            filename: name,
                            message: e.message
                        });
                    }

                    if (input.files[readIndex]) {
                        reader.readAsText(input.files[readIndex++]);
                        return;
                    }

                    resolve({
                        files: out,
                        errors: errs,
                        jsons: out.map(({json})=>json),
                    });
                }
                ;

                reader.readAsText(input.files[readIndex++]);
            }
            ).appendTo(document.body);

            $iptAdd.click();
        }
        );
    },

    doHandleFileLoadErrorsGeneric(errors) {
        if (!errors)
            return;
        errors.forEach(err=>{
            JqueryUtil.doToast({
                content: `Could not load file "${err.filename}": <code>${err.message}</code>. ${VeCt.STR_SEE_CONSOLE}`,
                type: "danger",
            });
        }
        );
    },

    cleanJson(cpy, {isDeleteUniqueId=true}={}) {
        if (!cpy)
            return cpy;
        cpy.name = cpy._displayName || cpy.name;
        if (isDeleteUniqueId)
            delete cpy.uniqueId;
        DataUtil.__cleanJsonObject(cpy);
        return cpy;
    },

    _CLEAN_JSON_ALLOWED_UNDER_KEYS: ["_copy", "_versions", "_version", ],
    __cleanJsonObject(obj) {
        if (obj == null)
            return obj;
        if (typeof obj !== "object")
            return obj;

        if (obj instanceof Array) {
            return obj.forEach(it=>DataUtil.__cleanJsonObject(it));
        }

        Object.entries(obj).forEach(([k,v])=>{
            if (DataUtil._CLEAN_JSON_ALLOWED_UNDER_KEYS.includes(k))
                return;
            if ((k.startsWith("_") && k !== "_") || k === "customHashId")
                delete obj[k];
            else
                DataUtil.__cleanJsonObject(v);
        }
        );
    },

    _MULTI_SOURCE_PROP_TO_DIR: {
        "monster": "bestiary",
        "monsterFluff": "bestiary",
        "spell": "spells",
        "spellFluff": "spells",
        "class": "class",
        "subclass": "class",
        "classFeature": "class",
        "subclassFeature": "class",
    },
    _MULTI_SOURCE_PROP_TO_INDEX_NAME: {
        "class": "index.json",
        "subclass": "index.json",
        "classFeature": "index.json",
        "subclassFeature": "index.json",
    },
    async pLoadByMeta(prop, source) {

        switch (prop) {
        case "monster":
        case "spell":
        case "monsterFluff":
        case "spellFluff":
            {
                const data = await DataUtil[prop].pLoadSingleSource(source);
                if (data)
                    return data;

                return DataUtil._pLoadByMeta_pGetPrereleaseBrew(source);
            }

        case "class":
        case "subclass":
        case "classFeature":
        case "subclassFeature":
            {
                const baseUrlPart = `${Renderer.get().baseUrl}data/${DataUtil._MULTI_SOURCE_PROP_TO_DIR[prop]}`;
                const index = await DataUtil.loadJSON(`${baseUrlPart}/${DataUtil._MULTI_SOURCE_PROP_TO_INDEX_NAME[prop]}`);
                if (index[source])
                    return DataUtil.loadJSON(`${baseUrlPart}/${index[source]}`);

                return DataUtil._pLoadByMeta_pGetPrereleaseBrew(source);
            }

        case "item":
        case "itemGroup":
        case "baseitem":
            {
                const data = await DataUtil.item.loadRawJSON();
                if (data[prop] && data[prop].some(it=>it.source === source))
                    return data;
                return DataUtil._pLoadByMeta_pGetPrereleaseBrew(source);
            }
        case "race":
            {
                const data = await DataUtil.race.loadJSON({
                    isAddBaseRaces: true
                });
                if (data[prop] && data[prop].some(it=>it.source === source))
                    return data;
                return DataUtil._pLoadByMeta_pGetPrereleaseBrew(source);
            }

        default:
            {
                const impl = DataUtil[prop];
                if (impl && (impl.getDataUrl || impl.loadJSON)) {
                    const data = await (impl.loadJSON ? impl.loadJSON() : DataUtil.loadJSON(impl.getDataUrl()));
                    if (data[prop] && data[prop].some(it=>it.source === source))
                        return data;

                    return DataUtil._pLoadByMeta_pGetPrereleaseBrew(source);
                }

                throw new Error(`Could not get loadable URL for \`${JSON.stringify({
                    key: prop,
                    value: source
                })}\``);
            }
        }
    },

    async _pLoadByMeta_pGetPrereleaseBrew(source) {
        const fromPrerelease = await DataUtil.pLoadPrereleaseBySource(source);
        if (fromPrerelease)
            return fromPrerelease;

        const fromBrew = await DataUtil.pLoadBrewBySource(source);
        if (fromBrew)
            return fromBrew;

        throw new Error(`Could not find prerelease/brew URL for source "${source}"`);
    },

    async pLoadPrereleaseBySource(source) {
        if (typeof PrereleaseUtil === "undefined")
            return null;
        return this._pLoadPrereleaseBrewBySource({
            source,
            brewUtil: PrereleaseUtil
        });
    },

    async pLoadBrewBySource(source) {
        if (typeof BrewUtil2 === "undefined")
            return null;
        return this._pLoadPrereleaseBrewBySource({
            source,
            brewUtil: BrewUtil2
        });
    },

    async _pLoadPrereleaseBrewBySource({source, brewUtil}) {
        const fromExisting = await brewUtil.pGetBrewBySource(source);
        if (fromExisting)
            return MiscUtil.copyFast(fromExisting.body);

        const url = await brewUtil.pGetSourceUrl(source);
        if (!url)
            return null;

        return DataUtil.loadJSON(url);
    },

    dbg: {
        isTrackCopied: false,
    },

    generic: {
        _MERGE_REQUIRES_PRESERVE_BASE: {
            page: true,
            otherSources: true,
            srd: true,
            basicRules: true,
            reprintedAs: true,
            hasFluff: true,
            hasFluffImages: true,
            hasToken: true,
            _versions: true,
        },

        _walker_replaceTxt: null,

        unpackUid(uid, tag, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,source,displayText,...others] = uid.split("|").map(Function.prototype.call.bind(String.prototype.trim));

            source = source || Parser.getTagSource(tag, source);
            if (opts.isLower)
                source = source.toLowerCase();

            return {
                name,
                source,
                displayText,
                others,
            };
        },

        packUid(ent, tag) {
            const sourceDefault = Parser.getTagSource(tag);
            return [ent.name, (ent.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : ent.source, ].join("|").replace(/\|+$/, "");
        },

        getNormalizedUid(uid, tag) {
            const {name, source} = DataUtil.generic.unpackUid(uid, tag, {
                isLower: true
            });
            return [name, source].join("|");
        },

        getUid(ent, {isMaintainCase=false}={}) {
            const {name} = ent;
            const source = SourceUtil.getEntitySource(ent);
            if (!name || !source)
                throw new Error(`Entity did not have a name and source!`);
            const out = [name, source].join("|");
            if (isMaintainCase)
                return out;
            return out.toLowerCase();
        },

        async _pMergeCopy(impl, page, entryList, entry, options) {
            if (!entry._copy)
                return;

            const hashCurrent = UrlUtil.URL_TO_HASH_BUILDER[page](entry);
            const hash = UrlUtil.URL_TO_HASH_BUILDER[page](entry._copy);

            if (hashCurrent === hash)
                throw new Error(`${hashCurrent} _copy self-references! This is a bug!`);

            const it = (impl._mergeCache = impl._mergeCache || {})[hash] || DataUtil.generic._pMergeCopy_search(impl, page, entryList, entry, options);

            if (!it) {
                if (options.isErrorOnMissing) {
                    if (!IS_DEPLOYED && !IS_VTT)
                        throw new Error(`Could not find "${page}" entity "${entry._copy.name}" ("${entry._copy.source}") to copy in copier "${entry.name}" ("${entry.source}")`);
                }
                return;
            }

            if (DataUtil.dbg.isTrackCopied)
                it.dbg_isCopied = true;
            if (it._copy)
                await DataUtil.generic._pMergeCopy(impl, page, entryList, it, options);

            const templateData = entry._copy?._trait ? (await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/bestiary/template.json`)) : null;
            return DataUtil.generic.copyApplier.getCopy(impl, MiscUtil.copyFast(it), entry, templateData, options);
        },

        _pMergeCopy_search(impl, page, entryList, entry, options) {
            const entryHash = UrlUtil.URL_TO_HASH_BUILDER[page](entry._copy);
            return entryList.find(it=>{
                const hash = UrlUtil.URL_TO_HASH_BUILDER[page](it);
                impl._mergeCache[hash] = it;
                return hash === entryHash;
            }
            );
        },

        COPY_ENTRY_PROPS: ["action", "bonus", "reaction", "trait", "legendary", "mythic", "variant", "spellcasting", "actionHeader", "bonusHeader", "reactionHeader", "legendaryHeader", "mythicHeader", ],

        copyApplier: class {
            static _normaliseMods(obj) {
                Object.entries(obj._mod).forEach(([k,v])=>{
                    if (!(v instanceof Array))
                        obj._mod[k] = [v];
                }
                );
            }

            static _doEnsureArray({obj, prop}) {
                if (!(obj[prop]instanceof Array))
                    obj[prop] = [obj[prop]];
            }

            static _getRegexFromReplaceModInfo({replace, flags}) {
                return new RegExp(replace,`g${flags || ""}`);
            }

            static _doReplaceStringHandler({re, withStr}, str) {
                const split = Renderer.splitByTags(str);
                const len = split.length;
                for (let i = 0; i < len; ++i) {
                    if (split[i].startsWith("{@"))
                        continue;
                    split[i] = split[i].replace(re, withStr);
                }
                return split.join("");
            }

            static _doMod_appendStr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (copyTo[prop])
                    copyTo[prop] = `${copyTo[prop]}${modInfo.joiner || ""}${modInfo.str}`;
                else
                    copyTo[prop] = modInfo.str;
            }

            static _doMod_replaceName({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (!copyTo[prop])
                    return;

                DataUtil.generic._walker_replaceTxt = DataUtil.generic._walker_replaceTxt || MiscUtil.getWalker();
                const re = this._getRegexFromReplaceModInfo({
                    replace: modInfo.replace,
                    flags: modInfo.flags
                });
                const handlers = {
                    string: this._doReplaceStringHandler.bind(null, {
                        re: re,
                        withStr: modInfo.with
                    })
                };

                copyTo[prop].forEach(it=>{
                    if (it.name)
                        it.name = DataUtil.generic._walker_replaceTxt.walk(it.name, handlers);
                }
                );
            }

            static _doMod_replaceTxt({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (!copyTo[prop])
                    return;

                DataUtil.generic._walker_replaceTxt = DataUtil.generic._walker_replaceTxt || MiscUtil.getWalker();
                const re = this._getRegexFromReplaceModInfo({
                    replace: modInfo.replace,
                    flags: modInfo.flags
                });
                const handlers = {
                    string: this._doReplaceStringHandler.bind(null, {
                        re: re,
                        withStr: modInfo.with
                    })
                };

                const props = modInfo.props || [null, "entries", "headerEntries", "footerEntries"];
                if (!props.length)
                    return;

                if (props.includes(null)) {
                    copyTo[prop] = copyTo[prop].map(it=>{
                        if (typeof it !== "string")
                            return it;
                        return DataUtil.generic._walker_replaceTxt.walk(it, handlers);
                    }
                    );
                }

                copyTo[prop].forEach(it=>{
                    props.forEach(prop=>{
                        if (prop == null)
                            return;
                        if (it[prop])
                            it[prop] = DataUtil.generic._walker_replaceTxt.walk(it[prop], handlers);
                    }
                    );
                }
                );
            }

            static _doMod_prependArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "items"
                });
                copyTo[prop] = copyTo[prop] ? modInfo.items.concat(copyTo[prop]) : modInfo.items;
            }

            static _doMod_appendArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "items"
                });
                copyTo[prop] = copyTo[prop] ? copyTo[prop].concat(modInfo.items) : modInfo.items;
            }

            static _doMod_appendIfNotExistsArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "items"
                });
                if (!copyTo[prop])
                    return copyTo[prop] = modInfo.items;
                copyTo[prop] = copyTo[prop].concat(modInfo.items.filter(it=>!copyTo[prop].some(x=>CollectionUtil.deepEquals(it, x))));
            }

            static _doMod_replaceArr({copyTo, copyFrom, modInfo, msgPtFailed, prop, isThrow=true}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "items"
                });

                if (!copyTo[prop]) {
                    if (isThrow)
                        throw new Error(`${msgPtFailed} Could not find "${prop}" array`);
                    return false;
                }

                let ixOld;
                if (modInfo.replace.regex) {
                    const re = new RegExp(modInfo.replace.regex,modInfo.replace.flags || "");
                    ixOld = copyTo[prop].findIndex(it=>it.name ? re.test(it.name) : typeof it === "string" ? re.test(it) : false);
                } else if (modInfo.replace.index != null) {
                    ixOld = modInfo.replace.index;
                } else {
                    ixOld = copyTo[prop].findIndex(it=>it.name ? it.name === modInfo.replace : it === modInfo.replace);
                }

                if (~ixOld) {
                    copyTo[prop].splice(ixOld, 1, ...modInfo.items);
                    return true;
                } else if (isThrow)
                    throw new Error(`${msgPtFailed} Could not find "${prop}" item with name "${modInfo.replace}" to replace`);
                return false;
            }

            static _doMod_replaceOrAppendArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                const didReplace = this._doMod_replaceArr({
                    copyTo,
                    copyFrom,
                    modInfo,
                    msgPtFailed,
                    prop,
                    isThrow: false
                });
                if (!didReplace)
                    this._doMod_appendArr({
                        copyTo,
                        copyFrom,
                        modInfo,
                        msgPtFailed,
                        prop
                    });
            }

            static _doMod_insertArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "items"
                });
                if (!copyTo[prop])
                    throw new Error(`${msgPtFailed} Could not find "${prop}" array`);
                copyTo[prop].splice(~modInfo.index ? modInfo.index : copyTo[prop].length, 0, ...modInfo.items);
            }

            static _doMod_removeArr({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (modInfo.names) {
                    this._doEnsureArray({
                        obj: modInfo,
                        prop: "names"
                    });
                    modInfo.names.forEach(nameToRemove=>{
                        const ixOld = copyTo[prop].findIndex(it=>it.name === nameToRemove);
                        if (~ixOld)
                            copyTo[prop].splice(ixOld, 1);
                        else {
                            if (!modInfo.force)
                                throw new Error(`${msgPtFailed} Could not find "${prop}" item with name "${nameToRemove}" to remove`);
                        }
                    }
                    );
                } else if (modInfo.items) {
                    this._doEnsureArray({
                        obj: modInfo,
                        prop: "items"
                    });
                    modInfo.items.forEach(itemToRemove=>{
                        const ixOld = copyTo[prop].findIndex(it=>it === itemToRemove);
                        if (~ixOld)
                            copyTo[prop].splice(ixOld, 1);
                        else
                            throw new Error(`${msgPtFailed} Could not find "${prop}" item "${itemToRemove}" to remove`);
                    }
                    );
                } else
                    throw new Error(`${msgPtFailed} One of "names" or "items" must be provided!`);
            }

            static _doMod_calculateProp({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                copyTo[prop] = copyTo[prop] || {};
                const toExec = modInfo.formula.replace(/<\$([^$]+)\$>/g, (...m)=>{
                    switch (m[1]) {
                    case "prof_bonus":
                        return Parser.crToPb(copyTo.cr);
                    case "dex_mod":
                        return Parser.getAbilityModNumber(copyTo.dex);
                    default:
                        throw new Error(`${msgPtFailed} Unknown variable "${m[1]}"`);
                    }
                }
                );
                copyTo[prop][modInfo.prop] = eval(toExec);
            }

            static _doMod_scalarAddProp({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                const applyTo = (k)=>{
                    const out = Number(copyTo[prop][k]) + modInfo.scalar;
                    const isString = typeof copyTo[prop][k] === "string";
                    copyTo[prop][k] = isString ? `${out >= 0 ? "+" : ""}${out}` : out;
                }
                ;

                if (!copyTo[prop])
                    return;
                if (modInfo.prop === "*")
                    Object.keys(copyTo[prop]).forEach(k=>applyTo(k));
                else
                    applyTo(modInfo.prop);
            }

            static _doMod_scalarMultProp({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                const applyTo = (k)=>{
                    let out = Number(copyTo[prop][k]) * modInfo.scalar;
                    if (modInfo.floor)
                        out = Math.floor(out);
                    const isString = typeof copyTo[prop][k] === "string";
                    copyTo[prop][k] = isString ? `${out >= 0 ? "+" : ""}${out}` : out;
                }
                ;

                if (!copyTo[prop])
                    return;
                if (modInfo.prop === "*")
                    Object.keys(copyTo[prop]).forEach(k=>applyTo(k));
                else
                    applyTo(modInfo.prop);
            }

            static _doMod_addSenses({copyTo, copyFrom, modInfo, msgPtFailed}) {
                this._doEnsureArray({
                    obj: modInfo,
                    prop: "senses"
                });
                copyTo.senses = copyTo.senses || [];
                modInfo.senses.forEach(sense=>{
                    let found = false;
                    for (let i = 0; i < copyTo.senses.length; ++i) {
                        const m = new RegExp(`${sense.type} (\\d+)`,"i").exec(copyTo.senses[i]);
                        if (m) {
                            found = true;
                            if (Number(m[1]) < sense.range) {
                                copyTo.senses[i] = `${sense.type} ${sense.range} ft.`;
                            }
                            break;
                        }
                    }

                    if (!found)
                        copyTo.senses.push(`${sense.type} ${sense.range} ft.`);
                }
                );
            }

            static _doMod_addSaves({copyTo, copyFrom, modInfo, msgPtFailed}) {
                copyTo.save = copyTo.save || {};
                Object.entries(modInfo.saves).forEach(([save,mode])=>{
                    const total = mode * Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(copyTo[save]);
                    const asText = total >= 0 ? `+${total}` : total;
                    if (copyTo.save && copyTo.save[save]) {
                        if (Number(copyTo.save[save]) < total)
                            copyTo.save[save] = asText;
                    } else
                        copyTo.save[save] = asText;
                }
                );
            }

            static _doMod_addSkills({copyTo, copyFrom, modInfo, msgPtFailed}) {
                copyTo.skill = copyTo.skill || {};
                Object.entries(modInfo.skills).forEach(([skill,mode])=>{
                    const total = mode * Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(copyTo[Parser.skillToAbilityAbv(skill)]);
                    const asText = total >= 0 ? `+${total}` : total;
                    if (copyTo.skill && copyTo.skill[skill]) {
                        if (Number(copyTo.skill[skill]) < total)
                            copyTo.skill[skill] = asText;
                    } else
                        copyTo.skill[skill] = asText;
                }
                );
            }

            static _doMod_addAllSaves({copyTo, copyFrom, modInfo, msgPtFailed}) {
                return this._doMod_addSaves({
                    copyTo,
                    copyFrom,
                    modInfo: {
                        mode: "addSaves",
                        saves: Object.keys(Parser.ATB_ABV_TO_FULL).mergeMap(it=>({
                            [it]: modInfo.saves
                        })),
                    },
                    msgPtFailed,
                });
            }

            static _doMod_addAllSkills({copyTo, copyFrom, modInfo, msgPtFailed}) {
                return this._doMod_addSkills({
                    copyTo,
                    copyFrom,
                    modInfo: {
                        mode: "addSkills",
                        skills: Object.keys(Parser.SKILL_TO_ATB_ABV).mergeMap(it=>({
                            [it]: modInfo.skills
                        })),
                    },
                    msgPtFailed,
                });
            }

            static _doMod_addSpells({copyTo, copyFrom, modInfo, msgPtFailed}) {
                if (!copyTo.spellcasting)
                    throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

                const spellcasting = copyTo.spellcasting[0];

                if (modInfo.spells) {
                    const spells = spellcasting.spells;

                    Object.keys(modInfo.spells).forEach(k=>{
                        if (!spells[k])
                            spells[k] = modInfo.spells[k];
                        else {
                            const spellCategoryNu = modInfo.spells[k];
                            const spellCategoryOld = spells[k];
                            Object.keys(spellCategoryNu).forEach(kk=>{
                                if (!spellCategoryOld[kk])
                                    spellCategoryOld[kk] = spellCategoryNu[kk];
                                else {
                                    if (typeof spellCategoryOld[kk] === "object") {
                                        if (spellCategoryOld[kk]instanceof Array)
                                            spellCategoryOld[kk] = spellCategoryOld[kk].concat(spellCategoryNu[kk]).sort(SortUtil.ascSortLower);
                                        else
                                            throw new Error(`${msgPtFailed} Object at key ${kk} not an array!`);
                                    } else
                                        spellCategoryOld[kk] = spellCategoryNu[kk];
                                }
                            }
                            );
                        }
                    }
                    );
                }

                ["constant", "will", "ritual"].forEach(prop=>{
                    if (!modInfo[prop])
                        return;
                    modInfo[prop].forEach(sp=>(spellcasting[prop] = spellcasting[prop] || []).push(sp));
                }
                );

                ["recharge", "charges", "rest", "daily", "weekly", "yearly"].forEach(prop=>{
                    if (!modInfo[prop])
                        return;

                    for (let i = 1; i <= 9; ++i) {
                        const e = `${i}e`;

                        spellcasting[prop] = spellcasting[prop] || {};

                        if (modInfo[prop][i]) {
                            modInfo[prop][i].forEach(sp=>(spellcasting[prop][i] = spellcasting[prop][i] || []).push(sp));
                        }

                        if (modInfo[prop][e]) {
                            modInfo[prop][e].forEach(sp=>(spellcasting[prop][e] = spellcasting[prop][e] || []).push(sp));
                        }
                    }
                }
                );
            }

            static _doMod_replaceSpells({copyTo, copyFrom, modInfo, msgPtFailed}) {
                if (!copyTo.spellcasting)
                    throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

                const spellcasting = copyTo.spellcasting[0];

                const handleReplace = (curSpells,replaceMeta,k)=>{
                    this._doEnsureArray({
                        obj: replaceMeta,
                        prop: "with"
                    });

                    const ix = curSpells[k].indexOf(replaceMeta.replace);
                    if (~ix) {
                        curSpells[k].splice(ix, 1, ...replaceMeta.with);
                        curSpells[k].sort(SortUtil.ascSortLower);
                    } else
                        throw new Error(`${msgPtFailed} Could not find spell "${replaceMeta.replace}" to replace`);
                }
                ;

                if (modInfo.spells) {
                    const trait0 = spellcasting.spells;
                    Object.keys(modInfo.spells).forEach(k=>{
                        if (trait0[k]) {
                            const replaceMetas = modInfo.spells[k];
                            const curSpells = trait0[k];
                            replaceMetas.forEach(replaceMeta=>handleReplace(curSpells, replaceMeta, "spells"));
                        }
                    }
                    );
                }

                if (modInfo.daily) {
                    for (let i = 1; i <= 9; ++i) {
                        const e = `${i}e`;

                        if (modInfo.daily[i]) {
                            modInfo.daily[i].forEach(replaceMeta=>handleReplace(spellcasting.daily, replaceMeta, i));
                        }

                        if (modInfo.daily[e]) {
                            modInfo.daily[e].forEach(replaceMeta=>handleReplace(spellcasting.daily, replaceMeta, e));
                        }
                    }
                }
            }

            static _doMod_removeSpells({copyTo, copyFrom, modInfo, msgPtFailed}) {
                if (!copyTo.spellcasting)
                    throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

                const spellcasting = copyTo.spellcasting[0];

                if (modInfo.spells) {
                    const spells = spellcasting.spells;

                    Object.keys(modInfo.spells).forEach(k=>{
                        if (!spells[k]?.spells)
                            return;

                        spells[k].spells = spells[k].spells.filter(it=>!modInfo.spells[k].includes(it));
                    }
                    );
                }

                ["constant", "will", "ritual"].forEach(prop=>{
                    if (!modInfo[prop])
                        return;
                    spellcasting[prop].filter(it=>!modInfo[prop].includes(it));
                }
                );

                ["recharge", "charges", "rest", "daily", "weekly", "yearly"].forEach(prop=>{
                    if (!modInfo[prop])
                        return;

                    for (let i = 1; i <= 9; ++i) {
                        const e = `${i}e`;

                        spellcasting[prop] = spellcasting[prop] || {};

                        if (modInfo[prop][i]) {
                            spellcasting[prop][i] = spellcasting[prop][i].filter(it=>!modInfo[prop][i].includes(it));
                        }

                        if (modInfo[prop][e]) {
                            spellcasting[prop][e] = spellcasting[prop][e].filter(it=>!modInfo[prop][e].includes(it));
                        }
                    }
                }
                );
            }

            static _doMod_scalarAddHit({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (!copyTo[prop])
                    return;
                copyTo[prop] = JSON.parse(JSON.stringify(copyTo[prop]).replace(/{@hit ([-+]?\d+)}/g, (m0,m1)=>`{@hit ${Number(m1) + modInfo.scalar}}`));
            }

            static _doMod_scalarAddDc({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                if (!copyTo[prop])
                    return;
                copyTo[prop] = JSON.parse(JSON.stringify(copyTo[prop]).replace(/{@dc (\d+)(?:\|[^}]+)?}/g, (m0,m1)=>`{@dc ${Number(m1) + modInfo.scalar}}`));
            }

            static _doMod_maxSize({copyTo, copyFrom, modInfo, msgPtFailed}) {
                const sizes = [...copyTo.size].sort(SortUtil.ascSortSize);

                const ixsCur = sizes.map(it=>Parser.SIZE_ABVS.indexOf(it));
                const ixMax = Parser.SIZE_ABVS.indexOf(modInfo.max);

                if (!~ixMax || ixsCur.some(ix=>!~ix))
                    throw new Error(`${msgPtFailed} Unhandled size!`);

                const ixsNxt = ixsCur.filter(ix=>ix <= ixMax);
                if (!ixsNxt.length)
                    ixsNxt.push(ixMax);

                copyTo.size = ixsNxt.map(ix=>Parser.SIZE_ABVS[ix]);
            }

            static _doMod_scalarMultXp({copyTo, copyFrom, modInfo, msgPtFailed}) {
                const getOutput = (input)=>{
                    let out = input * modInfo.scalar;
                    if (modInfo.floor)
                        out = Math.floor(out);
                    return out;
                }
                ;

                if (copyTo.cr.xp)
                    copyTo.cr.xp = getOutput(copyTo.cr.xp);
                else {
                    const curXp = Parser.crToXpNumber(copyTo.cr);
                    if (!copyTo.cr.cr)
                        copyTo.cr = {
                            cr: copyTo.cr
                        };
                    copyTo.cr.xp = getOutput(curXp);
                }
            }

            static _doMod_setProp({copyTo, copyFrom, modInfo, msgPtFailed, prop}) {
                const propPath = modInfo.prop.split(".");
                if (prop !== "*")
                    propPath.unshift(prop);
                MiscUtil.set(copyTo, ...propPath, MiscUtil.copyFast(modInfo.value));
            }

            static _doMod_handleProp({copyTo, copyFrom, modInfos, msgPtFailed, prop=null}) {
                modInfos.forEach(modInfo=>{
                    if (typeof modInfo === "string") {
                        switch (modInfo) {
                        case "remove":
                            return delete copyTo[prop];
                        default:
                            throw new Error(`${msgPtFailed} Unhandled mode: ${modInfo}`);
                        }
                    } else {
                        switch (modInfo.mode) {
                        case "appendStr":
                            return this._doMod_appendStr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "replaceName":
                            return this._doMod_replaceName({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "replaceTxt":
                            return this._doMod_replaceTxt({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "prependArr":
                            return this._doMod_prependArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "appendArr":
                            return this._doMod_appendArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "replaceArr":
                            return this._doMod_replaceArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "replaceOrAppendArr":
                            return this._doMod_replaceOrAppendArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "appendIfNotExistsArr":
                            return this._doMod_appendIfNotExistsArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "insertArr":
                            return this._doMod_insertArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "removeArr":
                            return this._doMod_removeArr({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "calculateProp":
                            return this._doMod_calculateProp({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "scalarAddProp":
                            return this._doMod_scalarAddProp({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "scalarMultProp":
                            return this._doMod_scalarMultProp({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "setProp":
                            return this._doMod_setProp({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "addSenses":
                            return this._doMod_addSenses({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "addSaves":
                            return this._doMod_addSaves({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "addSkills":
                            return this._doMod_addSkills({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "addAllSaves":
                            return this._doMod_addAllSaves({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "addAllSkills":
                            return this._doMod_addAllSkills({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "addSpells":
                            return this._doMod_addSpells({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "replaceSpells":
                            return this._doMod_replaceSpells({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "removeSpells":
                            return this._doMod_removeSpells({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "maxSize":
                            return this._doMod_maxSize({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "scalarMultXp":
                            return this._doMod_scalarMultXp({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed
                            });
                        case "scalarAddHit":
                            return this._doMod_scalarAddHit({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        case "scalarAddDc":
                            return this._doMod_scalarAddDc({
                                copyTo,
                                copyFrom,
                                modInfo,
                                msgPtFailed,
                                prop
                            });
                        default:
                            throw new Error(`${msgPtFailed} Unhandled mode: ${modInfo.mode}`);
                        }
                    }
                }
                );
            }

            static _doMod({copyTo, copyFrom, modInfos, msgPtFailed, props=null, isExternalApplicationIdentityOnly}) {
                if (isExternalApplicationIdentityOnly)
                    return;

                if (props?.length)
                    props.forEach(prop=>this._doMod_handleProp({
                        copyTo,
                        copyFrom,
                        modInfos,
                        msgPtFailed,
                        prop
                    }));
                else
                    this._doMod_handleProp({
                        copyTo,
                        copyFrom,
                        modInfos,
                        msgPtFailed
                    });
            }

            static getCopy(impl, copyFrom, copyTo, templateData, {isExternalApplicationKeepCopy=false, isExternalApplicationIdentityOnly=false}={}) {
                if (isExternalApplicationKeepCopy)
                    copyTo.__copy = MiscUtil.copyFast(copyFrom);

                const msgPtFailed = `Failed to apply _copy to "${copyTo.name}" ("${copyTo.source}").`;

                const copyMeta = copyTo._copy || {};

                if (copyMeta._mod)
                    this._normaliseMods(copyMeta);

                let template = null;
                if (copyMeta._trait) {
                    template = templateData.monsterTemplate.find(t=>t.name.toLowerCase() === copyMeta._trait.name.toLowerCase() && t.source.toLowerCase() === copyMeta._trait.source.toLowerCase());
                    if (!template)
                        throw new Error(`${msgPtFailed} Could not find traits to apply with name "${copyMeta._trait.name}" and source "${copyMeta._trait.source}"`);
                    template = MiscUtil.copyFast(template);

                    if (template.apply._mod) {
                        this._normaliseMods(template.apply);

                        if (copyMeta._mod) {
                            Object.entries(template.apply._mod).forEach(([k,v])=>{
                                if (copyMeta._mod[k])
                                    copyMeta._mod[k] = copyMeta._mod[k].concat(v);
                                else
                                    copyMeta._mod[k] = v;
                            }
                            );
                        } else
                            copyMeta._mod = template.apply._mod;
                    }

                    delete copyMeta._trait;
                }

                const copyToRootProps = new Set(Object.keys(copyTo));

                Object.keys(copyFrom).forEach(k=>{
                    if (copyTo[k] === null)
                        return delete copyTo[k];
                    if (copyTo[k] == null) {
                        if (DataUtil.generic._MERGE_REQUIRES_PRESERVE_BASE[k] || impl?._MERGE_REQUIRES_PRESERVE[k]) {
                            if (copyTo._copy._preserve?.["*"] || copyTo._copy._preserve?.[k])
                                copyTo[k] = copyFrom[k];
                        } else
                            copyTo[k] = copyFrom[k];
                    }
                }
                );

                if (template && template.apply._root) {
                    Object.entries(template.apply._root).filter(([k,v])=>!copyToRootProps.has(k)).forEach(([k,v])=>copyTo[k] = v);
                }

                if (copyMeta._mod) {
                    Object.entries(copyMeta._mod).forEach(([k,v])=>{
                        copyMeta._mod[k] = DataUtil.generic.variableResolver.resolve({
                            obj: v,
                            ent: copyTo
                        });
                    }
                    );

                    Object.entries(copyMeta._mod).forEach(([prop,modInfos])=>{
                        if (prop === "*")
                            this._doMod({
                                copyTo,
                                copyFrom,
                                modInfos,
                                props: DataUtil.generic.COPY_ENTRY_PROPS,
                                msgPtFailed,
                                isExternalApplicationIdentityOnly
                            });
                        else if (prop === "_")
                            this._doMod({
                                copyTo,
                                copyFrom,
                                modInfos,
                                msgPtFailed,
                                isExternalApplicationIdentityOnly
                            });
                        else
                            this._doMod({
                                copyTo,
                                copyFrom,
                                modInfos,
                                props: [prop],
                                msgPtFailed,
                                isExternalApplicationIdentityOnly
                            });
                    }
                    );
                }

                copyTo._isCopy = true;

                delete copyTo._copy;
            }
        }
        ,

        variableResolver: class {
            static _getSize({ent}) {
                return ent.size?.[0] || Parser.SZ_MEDIUM;
            }

            static _SIZE_TO_MULT = {
                [Parser.SZ_LARGE]: 2,
                [Parser.SZ_HUGE]: 3,
                [Parser.SZ_GARGANTUAN]: 4,
            };

            static _getSizeMult(size) {
                return this._SIZE_TO_MULT[size] ?? 1;
            }

            static _getCleanMathExpression(str) {
                return str.replace(/[^-+/*0-9.,]+/g, "");
            }

            static resolve({obj, ent, msgPtFailed=null}) {
                return JSON.parse(JSON.stringify(obj).replace(/<\$(?<variable>[^$]+)\$>/g, (...m)=>{
                    const [mode,detail] = m.last().variable.split("__");

                    switch (mode) {
                    case "name":
                        return ent.name;
                    case "short_name":
                    case "title_short_name":
                        {
                            return Renderer.monster.getShortName(ent, {
                                isTitleCase: mode === "title_short_name"
                            });
                        }

                    case "dc":
                    case "spell_dc":
                        {
                            if (!Parser.ABIL_ABVS.includes(detail))
                                throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
                            return 8 + Parser.getAbilityModNumber(Number(ent[detail])) + Parser.crToPb(ent.cr);
                        }

                    case "to_hit":
                        {
                            if (!Parser.ABIL_ABVS.includes(detail))
                                throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
                            const total = Parser.crToPb(ent.cr) + Parser.getAbilityModNumber(Number(ent[detail]));
                            return total >= 0 ? `+${total}` : total;
                        }

                    case "damage_mod":
                        {
                            if (!Parser.ABIL_ABVS.includes(detail))
                                throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
                            const total = Parser.getAbilityModNumber(Number(ent[detail]));
                            return total === 0 ? "" : total > 0 ? ` + ${total}` : ` - ${Math.abs(total)}`;
                        }

                    case "damage_avg":
                        {
                            const replaced = detail.replace(/\b(?<abil>str|dex|con|int|wis|cha)\b/gi, (...m)=>Parser.getAbilityModNumber(Number(ent[m.last().abil]))).replace(/\bsize_mult\b/g, ()=>this._getSizeMult(this._getSize({
                                ent
                            })));

                            return Math.floor(eval(this._getCleanMathExpression(replaced)));
                        }

                    case "size_mult":
                        {
                            const mult = this._getSizeMult(this._getSize({
                                ent
                            }));

                            if (!detail)
                                return mult;

                            return Math.floor(eval(`${mult} * ${this._getCleanMathExpression(detail)}`));
                        }

                    default:
                        return m[0];
                    }
                }
                ), );
            }
        }
        ,

        getVersions(parent, {impl=null, isExternalApplicationIdentityOnly=false}={}) {
            if (!parent?._versions?.length)
                return [];

            return parent._versions.map(ver=>{
                if (ver._template && ver._implementations?.length)
                    return DataUtil.generic._getVersions_template({
                        ver
                    });
                return DataUtil.generic._getVersions_basic({
                    ver
                });
            }
            ).flat().map(ver=>DataUtil.generic._getVersion({
                parentEntity: parent,
                version: ver,
                impl,
                isExternalApplicationIdentityOnly
            }));
        },

        _getVersions_template({ver}) {
            return ver._implementations.map(impl=>{
                let cpyTemplate = MiscUtil.copyFast(ver._template);
                const cpyImpl = MiscUtil.copyFast(impl);

                DataUtil.generic._getVersions_mutExpandCopy({
                    ent: cpyTemplate
                });

                if (cpyImpl._variables) {
                    cpyTemplate = MiscUtil.getWalker().walk(cpyTemplate, {
                        string: str=>str.replace(/{{([^}]+)}}/g, (...m)=>cpyImpl._variables[m[1]]),
                    }, );
                    delete cpyImpl._variables;
                }

                Object.assign(cpyTemplate, cpyImpl);

                return cpyTemplate;
            }
            );
        },

        _getVersions_basic({ver}) {
            const cpyVer = MiscUtil.copyFast(ver);
            DataUtil.generic._getVersions_mutExpandCopy({
                ent: cpyVer
            });
            return cpyVer;
        },

        _getVersions_mutExpandCopy({ent}) {
            ent._copy = {
                _mod: ent._mod,
                _preserve: ent._preserve || {
                    "*": true
                },
            };
            delete ent._mod;
            delete ent._preserve;
        },

        _getVersion({parentEntity, version, impl=null, isExternalApplicationIdentityOnly}) {
            const additionalData = {
                _versionBase_isVersion: true,
                _versionBase_name: parentEntity.name,
                _versionBase_source: parentEntity.source,
                _versionBase_hasToken: parentEntity.hasToken,
                _versionBase_hasFluff: parentEntity.hasFluff,
                _versionBase_hasFluffImages: parentEntity.hasFluffImages,
            };
            const cpyParentEntity = MiscUtil.copyFast(parentEntity);

            delete cpyParentEntity._versions;
            delete cpyParentEntity.hasToken;
            delete cpyParentEntity.hasFluff;
            delete cpyParentEntity.hasFluffImages;

            DataUtil.generic.copyApplier.getCopy(impl, cpyParentEntity, version, null, {
                isExternalApplicationIdentityOnly
            }, );
            Object.assign(version, additionalData);
            return version;
        },
    },

    proxy: {
        getVersions(prop, ent, {isExternalApplicationIdentityOnly=false}={}) {
            if (DataUtil[prop]?.getVersions)
                return DataUtil[prop]?.getVersions(ent, {
                    isExternalApplicationIdentityOnly
                });
            return DataUtil.generic.getVersions(ent, {
                isExternalApplicationIdentityOnly
            });
        },

        unpackUid(prop, uid, tag, opts) {
            if (DataUtil[prop]?.unpackUid)
                return DataUtil[prop]?.unpackUid(uid, tag, opts);
            return DataUtil.generic.unpackUid(uid, tag, opts);
        },

        getNormalizedUid(prop, uid, tag, opts) {
            if (DataUtil[prop]?.getNormalizedUid)
                return DataUtil[prop].getNormalizedUid(uid, tag, opts);
            return DataUtil.generic.getNormalizedUid(uid, tag, opts);
        },

        getUid(prop, ent, opts) {
            if (DataUtil[prop]?.getUid)
                return DataUtil[prop].getUid(ent, opts);
            return DataUtil.generic.getUid(ent, opts);
        },
    },

    spell: class extends _DataUtilPropConfigMultiSource {
        static _PAGE = UrlUtil.PG_SPELLS;
        static _DIR = "spells";
        static _PROP = "spell";
        static _IS_MUT_ENTITIES = true;

        static _SPELL_SOURCE_LOOKUP = null;

        static PROPS_SPELL_SOURCE = ["classes", "races", "optionalfeatures", "backgrounds", "feats", "charoptions", "rewards", ];

        static setSpellSourceLookup(lookup, {isExternalApplication=false}={}) {
            if (!isExternalApplication)
                throw new Error("Should not be calling this!");
            this._SPELL_SOURCE_LOOKUP = MiscUtil.copyFast(lookup);
        }

        static mutEntity(sp, {isExternalApplication=false}={}) {
            if (!isExternalApplication)
                throw new Error("Should not be calling this!");
            return this._mutEntity(sp);
        }

        static unmutEntity(sp, {isExternalApplication=false}={}) {
            if (!isExternalApplication)
                throw new Error("Should not be calling this!");
            this.PROPS_SPELL_SOURCE.forEach(prop=>delete sp[prop]);
            delete sp._isMutEntity;
        }

        static mutEntityBrewBuilder(sp, sourcesLookup) {
            const out = this._mutEntity(sp, {
                sourcesLookup
            });
            delete sp._isMutEntity;
            return out;
        }

        static async _pInitPreData_() {
            this._SPELL_SOURCE_LOOKUP = await DataUtil.loadRawJSON(`${Renderer.get().baseUrl}data/generated/gendata-spell-source-lookup.json`);
        }

        static _mutEntity(sp, {sourcesLookup=null}={}) {
            if (sp._isMutEntity)
                return sp;

            const spSources = (sourcesLookup ?? this._SPELL_SOURCE_LOOKUP)[sp.source.toLowerCase()]?.[sp.name.toLowerCase()];
            if (!spSources)
                return sp;

            this._mutSpell_class({
                sp,
                spSources,
                propSources: "class",
                propClasses: "fromClassList"
            });
            this._mutSpell_class({
                sp,
                spSources,
                propSources: "classVariant",
                propClasses: "fromClassListVariant"
            });
            this._mutSpell_subclass({
                sp,
                spSources
            });
            this._mutSpell_race({
                sp,
                spSources
            });
            this._mutSpell_optionalfeature({
                sp,
                spSources
            });
            this._mutSpell_background({
                sp,
                spSources
            });
            this._mutSpell_feat({
                sp,
                spSources
            });
            this._mutSpell_charoption({
                sp,
                spSources
            });
            this._mutSpell_reward({
                sp,
                spSources
            });

            sp._isMutEntity = true;

            return sp;
        }

        static _mutSpell_class({sp, spSources, propSources, propClasses}) {
            if (!spSources[propSources])
                return;

            Object.entries(spSources[propSources]).forEach(([source,nameTo])=>{
                const tgt = MiscUtil.getOrSet(sp, "classes", propClasses, []);

                Object.entries(nameTo).forEach(([name,val])=>{
                    if (tgt.some(it=>it.name === nameTo && it.source === source))
                        return;

                    const toAdd = {
                        name,
                        source
                    };
                    if (val === true)
                        return tgt.push(toAdd);

                    if (val.definedInSource) {
                        toAdd.definedInSource = val.definedInSource;
                        tgt.push(toAdd);
                        return;
                    }

                    if (val.definedInSources) {
                        val.definedInSources.forEach(definedInSource=>{
                            const cpyToAdd = MiscUtil.copyFast(toAdd);

                            if (definedInSource == null) {
                                return tgt.push(cpyToAdd);
                            }

                            cpyToAdd.definedInSource = definedInSource;
                            tgt.push(cpyToAdd);
                        }
                        );

                        return;
                    }

                    throw new Error("Unimplemented!");
                }
                );
            }
            );
        }

        static _mutSpell_subclass({sp, spSources}) {
            if (!spSources.subclass)
                return;

            Object.entries(spSources.subclass).forEach(([classSource,classNameTo])=>{
                Object.entries(classNameTo).forEach(([className,sourceTo])=>{
                    Object.entries(sourceTo).forEach(([source,nameTo])=>{
                        const tgt = MiscUtil.getOrSet(sp, "classes", "fromSubclass", []);

                        Object.entries(nameTo).forEach(([name,val])=>{
                            if (val === true)
                                throw new Error("Unimplemented!");

                            if (tgt.some(it=>it.class.name === className && it.class.source === classSource && it.subclass.name === name && it.subclass.source === source && ((it.subclass.subSubclass == null && val.subSubclasses == null) || val.subSubclasses.includes(it.subclass.subSubclass))))
                                return;

                            const toAdd = {
                                class: {
                                    name: className,
                                    source: classSource,
                                },
                                subclass: {
                                    name: val.name,
                                    shortName: name,
                                    source,
                                },
                            };

                            if (!val.subSubclasses?.length)
                                return tgt.push(toAdd);

                            val.subSubclasses.forEach(subSubclass=>{
                                const cpyToAdd = MiscUtil.copyFast(toAdd);
                                cpyToAdd.subclass.subSubclass = subSubclass;
                                tgt.push(cpyToAdd);
                            }
                            );
                        }
                        );
                    }
                    );
                }
                );
            }
            );
        }

        static _mutSpell_race({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "race",
                propSpell: "races"
            });
        }

        static _mutSpell_optionalfeature({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "optionalfeature",
                propSpell: "optionalfeatures"
            });
        }

        static _mutSpell_background({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "background",
                propSpell: "backgrounds"
            });
        }

        static _mutSpell_feat({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "feat",
                propSpell: "feats"
            });
        }

        static _mutSpell_charoption({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "charoption",
                propSpell: "charoptions"
            });
        }

        static _mutSpell_reward({sp, spSources}) {
            this._mutSpell_generic({
                sp,
                spSources,
                propSources: "reward",
                propSpell: "rewards"
            });
        }

        static _mutSpell_generic({sp, spSources, propSources, propSpell}) {
            if (!spSources[propSources])
                return;

            Object.entries(spSources[propSources]).forEach(([source,nameTo])=>{
                const tgt = MiscUtil.getOrSet(sp, propSpell, []);

                Object.entries(nameTo).forEach(([name,val])=>{
                    if (tgt.some(it=>it.name === nameTo && it.source === source))
                        return;

                    const toAdd = {
                        name,
                        source
                    };
                    if (val === true)
                        return tgt.push(toAdd);

                    Object.assign(toAdd, {
                        ...val
                    });
                    tgt.push(toAdd);
                }
                );
            }
            );
        }
    }
    ,

    spellFluff: class extends _DataUtilPropConfigMultiSource {
        static _PAGE = UrlUtil.PG_SPELLS;
        static _DIR = "spells";
        static _PROP = "spellFluff";
    }
    ,

    background: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_BACKGROUNDS;
        static _FILENAME = "backgrounds.json";
    }
    ,

    backgroundFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_BACKGROUNDS;
        static _FILENAME = "fluff-backgrounds.json";
    }
    ,

    charoption: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;
        static _FILENAME = "charcreationoptions.json";
    }
    ,

    charoptionFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;
        static _FILENAME = "fluff-charcreationoptions.json";
    }
    ,

    condition: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
        static _FILENAME = "conditionsdiseases.json";
    }
    ,

    conditionFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
        static _FILENAME = "fluff-conditionsdiseases.json";
    }
    ,

    disease: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
        static _FILENAME = "conditionsdiseases.json";
    }
    ,

    feat: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_FEATS;
        static _FILENAME = "feats.json";
    }
    ,

    featFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_FEATS;
        static _FILENAME = "fluff-feats.json";
    }
    ,

    item: class extends _DataUtilPropConfigCustom {
        static _MERGE_REQUIRES_PRESERVE = {
            lootTables: true,
            tier: true,
        };
        static _PAGE = UrlUtil.PG_ITEMS;

        static async loadRawJSON() {
            if (DataUtil.item._loadedRawJson)
                return DataUtil.item._loadedRawJson;

            DataUtil.item._pLoadingRawJson = (async()=>{
                const urlItems = `${Renderer.get().baseUrl}data/items.json`;
                const urlItemsBase = `${Renderer.get().baseUrl}data/items-base.json`;
                const urlVariants = `${Renderer.get().baseUrl}data/magicvariants.json`;

                const [dataItems,dataItemsBase,dataVariants] = await Promise.all([DataUtil.loadJSON(urlItems), DataUtil.loadJSON(urlItemsBase), DataUtil.loadJSON(urlVariants), ]);

                DataUtil.item._loadedRawJson = {
                    item: MiscUtil.copyFast(dataItems.item),
                    itemGroup: MiscUtil.copyFast(dataItems.itemGroup),
                    magicvariant: MiscUtil.copyFast(dataVariants.magicvariant),
                    baseitem: MiscUtil.copyFast(dataItemsBase.baseitem),
                };
            }
            )();
            await DataUtil.item._pLoadingRawJson;

            return DataUtil.item._loadedRawJson;
        }

        static async loadJSON() {
            return {
                item: await Renderer.item.pBuildList()
            };
        }

        static async loadPrerelease() {
            return {
                item: await Renderer.item.pGetItemsFromPrerelease()
            };
        }

        static async loadBrew() {
            return {
                item: await Renderer.item.pGetItemsFromBrew()
            };
        }
    }
    ,

    itemGroup: class extends _DataUtilPropConfig {
        static _MERGE_REQUIRES_PRESERVE = {
            lootTables: true,
            tier: true,
        };
        static _PAGE = UrlUtil.PG_ITEMS;

        static async pMergeCopy(...args) {
            return DataUtil.item.pMergeCopy(...args);
        }
        static async loadRawJSON(...args) {
            return DataUtil.item.loadRawJSON(...args);
        }
    }
    ,

    baseitem: class extends _DataUtilPropConfig {
        static _PAGE = UrlUtil.PG_ITEMS;

        static async pMergeCopy(...args) {
            return DataUtil.item.pMergeCopy(...args);
        }
        static async loadRawJSON(...args) {
            return DataUtil.item.loadRawJSON(...args);
        }
    }
    ,

    itemFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_ITEMS;
        static _FILENAME = "fluff-items.json";
    }
    ,

    itemType: class extends _DataUtilPropConfig {
        static _PAGE = "itemType";
    }
    ,

    language: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_LANGUAGES;
        static _FILENAME = "languages.json";

        static async loadJSON() {
            const rawData = await super.loadJSON();

            const scriptLookup = {};
            (rawData.languageScript || []).forEach(script=>scriptLookup[script.name] = script);

            const out = {
                language: MiscUtil.copyFast(rawData.language)
            };
            out.language.forEach(lang=>{
                if (!lang.script || lang.fonts === false)
                    return;

                const script = scriptLookup[lang.script];
                if (!script)
                    return;

                lang._fonts = [...script.fonts];
            }
            );

            return out;
        }
    }
    ,

    languageFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_LANGUAGES;
        static _FILENAME = "fluff-languages.json";
    }
    ,

    object: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_OBJECTS;
        static _FILENAME = "objects.json";
    }
    ,

    objectFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_OBJECTS;
        static _FILENAME = "fluff-objects.json";
    }
    ,

    race: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_RACES;
        static _FILENAME = "races.json";

        static _loadCache = {};
        static _pIsLoadings = {};
        static async loadJSON({isAddBaseRaces=false}={}) {
            if (!DataUtil.race._pIsLoadings[isAddBaseRaces]) {
                DataUtil.race._pIsLoadings[isAddBaseRaces] = (async()=>{
                    DataUtil.race._loadCache[isAddBaseRaces] = DataUtil.race.getPostProcessedSiteJson(await this.loadRawJSON(), {
                        isAddBaseRaces
                    }, );
                }
                )();
            }
            await DataUtil.race._pIsLoadings[isAddBaseRaces];
            return DataUtil.race._loadCache[isAddBaseRaces];
        }

        static getPostProcessedSiteJson(rawRaceData, {isAddBaseRaces=false}={}) {
            rawRaceData = MiscUtil.copyFast(rawRaceData);
            (rawRaceData.subrace || []).forEach(sr=>{
                const r = rawRaceData.race.find(it=>it.name === sr.raceName && it.source === sr.raceSource);
                if (!r)
                    return JqueryUtil.doToast({
                        content: `Failed to find race "${sr.raceName}" (${sr.raceSource})`,
                        type: "danger"
                    });
                const cpySr = MiscUtil.copyFast(sr);
                delete cpySr.raceName;
                delete cpySr.raceSource;
                (r.subraces = r.subraces || []).push(sr);
            }
            );
            delete rawRaceData.subrace;
            const raceData = Renderer.race.mergeSubraces(rawRaceData.race, {
                isAddBaseRaces
            });
            raceData.forEach(it=>it.__prop = "race");
            return {
                race: raceData
            };
        }

        static async loadPrerelease({isAddBaseRaces=true}={}) {
            return DataUtil.race._loadPrereleaseBrew({
                isAddBaseRaces,
                brewUtil: typeof PrereleaseUtil !== "undefined" ? PrereleaseUtil : null
            });
        }

        static async loadBrew({isAddBaseRaces=true}={}) {
            return DataUtil.race._loadPrereleaseBrew({
                isAddBaseRaces,
                brewUtil: typeof BrewUtil2 !== "undefined" ? BrewUtil2 : null
            });
        }

        static async _loadPrereleaseBrew({isAddBaseRaces=true, brewUtil}={}) {
            if (!brewUtil)
                return {};

            const rawSite = await DataUtil.race.loadRawJSON();
            const brew = await brewUtil.pGetBrewProcessed();
            return DataUtil.race.getPostProcessedPrereleaseBrewJson(rawSite, brew, {
                isAddBaseRaces
            });
        }

        static getPostProcessedPrereleaseBrewJson(rawSite, brew, {isAddBaseRaces=false}={}) {
            rawSite = MiscUtil.copyFast(rawSite);
            brew = MiscUtil.copyFast(brew);

            const rawSiteUsed = [];
            (brew.subrace || []).forEach(sr=>{
                const rSite = rawSite.race.find(it=>it.name === sr.raceName && it.source === sr.raceSource);
                const rBrew = (brew.race || []).find(it=>it.name === sr.raceName && it.source === sr.raceSource);
                if (!rSite && !rBrew)
                    return JqueryUtil.doToast({
                        content: `Failed to find race "${sr.raceName}" (${sr.raceSource})`,
                        type: "danger"
                    });
                const rTgt = rSite || rBrew;
                const cpySr = MiscUtil.copyFast(sr);
                delete cpySr.raceName;
                delete cpySr.raceSource;
                (rTgt.subraces = rTgt.subraces || []).push(sr);
                if (rSite && !rawSiteUsed.includes(rSite))
                    rawSiteUsed.push(rSite);
            }
            );
            delete brew.subrace;

            const raceDataBrew = Renderer.race.mergeSubraces(brew.race || [], {
                isAddBaseRaces
            });
            const raceDataSite = Renderer.race.mergeSubraces(rawSiteUsed, {
                isAddBaseRaces: false
            });

            const out = [...raceDataBrew, ...raceDataSite];
            out.forEach(it=>it.__prop = "race");
            return {
                race: out
            };
        }
    }
    ,

    raceFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_RACES;
        static _FILENAME = "fluff-races.json";

        static _getApplyUncommonMonstrous(data) {
            data = MiscUtil.copyFast(data);
            data.raceFluff.forEach(raceFluff=>{
                if (raceFluff.uncommon) {
                    raceFluff.entries = raceFluff.entries || [];
                    raceFluff.entries.push(MiscUtil.copyFast(data.raceFluffMeta.uncommon));
                    delete raceFluff.uncommon;
                }

                if (raceFluff.monstrous) {
                    raceFluff.entries = raceFluff.entries || [];
                    raceFluff.entries.push(MiscUtil.copyFast(data.raceFluffMeta.monstrous));
                    delete raceFluff.monstrous;
                }
            }
            );
            return data;
        }

        static async loadJSON() {
            const data = await super.loadJSON();
            return this._getApplyUncommonMonstrous(data);
        }

        static async loadUnmergedJSON() {
            const data = await super.loadUnmergedJSON();
            return this._getApplyUncommonMonstrous(data);
        }
    }
    ,

    raceFeature: class extends _DataUtilPropConfig {
        static _PAGE = "raceFeature";
    }
    ,

    recipe: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_RECIPES;
        static _FILENAME = "recipes.json";

        static async loadJSON() {
            const rawData = await super.loadJSON();
            return {
                recipe: await DataUtil.recipe.pGetPostProcessedRecipes(rawData.recipe)
            };
        }

        static async pGetPostProcessedRecipes(recipes) {
            if (!recipes?.length)
                return;

            recipes = MiscUtil.copyFast(recipes);

            recipes.forEach(r=>Renderer.recipe.populateFullIngredients(r));

            const out = [];

            for (const r of recipes) {
                const fluff = await Renderer.utils.pGetFluff({
                    entity: r,
                    fnGetFluffData: DataUtil.recipeFluff.loadJSON.bind(DataUtil.recipeFluff),
                    fluffProp: "recipeFluff",
                });

                if (!fluff) {
                    out.push(r);
                    continue;
                }

                const cpyR = MiscUtil.copyFast(r);
                cpyR.fluff = MiscUtil.copyFast(fluff);
                delete cpyR.fluff.name;
                delete cpyR.fluff.source;
                out.push(cpyR);
            }

            return out;
        }

        static async loadPrerelease() {
            return this._loadPrereleaseBrew({
                brewUtil: typeof PrereleaseUtil !== "undefined" ? PrereleaseUtil : null
            });
        }

        static async loadBrew() {
            return this._loadPrereleaseBrew({
                brewUtil: typeof BrewUtil2 !== "undefined" ? BrewUtil2 : null
            });
        }

        static async _loadPrereleaseBrew({brewUtil}) {
            if (!brewUtil)
                return {};

            const brew = await brewUtil.pGetBrewProcessed();
            if (!brew?.recipe?.length)
                return brew;

            return {
                ...brew,
                recipe: await DataUtil.recipe.pGetPostProcessedRecipes(brew.recipe),
            };
        }
    }
    ,

    recipeFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_RECIPES;
        static _FILENAME = "fluff-recipes.json";
    }
    ,

    vehicle: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_VEHICLES;
        static _FILENAME = "vehicles.json";
    }
    ,

    vehicleFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_VEHICLES;
        static _FILENAME = "fluff-vehicles.json";
    }
    ,

    optionalfeature: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_OPT_FEATURES;
        static _FILENAME = "optionalfeatures.json";
    }
    ,

    class: class clazz extends _DataUtilPropConfigCustom {
        static _PAGE = UrlUtil.PG_CLASSES;

        static _pLoadJson = null;
        static _pLoadRawJson = null;

        static loadJSON() {
            return DataUtil.class._pLoadJson = DataUtil.class._pLoadJson || (async()=>{
                return {
                    class: await DataLoader.pCacheAndGetAllSite("class"),
                    subclass: await DataLoader.pCacheAndGetAllSite("subclass"),
                };
            }
            )();
        }

        static loadRawJSON() {
            return DataUtil.class._pLoadRawJson = DataUtil.class._pLoadRawJson || (async()=>{
                const index = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/index.json`);
                const allData = await Promise.all(Object.values(index).map(it=>DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/${it}`)));

                return {
                    class: MiscUtil.copyFast(allData.map(it=>it.class || []).flat()),
                    subclass: MiscUtil.copyFast(allData.map(it=>it.subclass || []).flat()),
                    classFeature: allData.map(it=>it.classFeature || []).flat(),
                    subclassFeature: allData.map(it=>it.subclassFeature || []).flat(),
                };
            }
            )();
        }

        static async loadPrerelease() {
            return {
                class: await DataLoader.pCacheAndGetAllPrerelease("class"),
                subclass: await DataLoader.pCacheAndGetAllPrerelease("subclass"),
            };
        }

        static async loadBrew() {
            return {
                class: await DataLoader.pCacheAndGetAllBrew("class"),
                subclass: await DataLoader.pCacheAndGetAllBrew("subclass"),
            };
        }

        static packUidSubclass(it) {
            const sourceDefault = Parser.getTagSource("subclass");
            return [it.name, it.className, (it.classSource || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.classSource, (it.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.source, ].join("|").replace(/\|+$/, "");
        }

        static unpackUidClassFeature(uid, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,className,classSource,level,source,displayText] = uid.split("|").map(it=>it.trim());
            classSource = classSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
            source = source || classSource;
            level = Number(level);
            return {
                name,
                className,
                classSource,
                level,
                source,
                displayText,
            };
        }

        static isValidClassFeatureUid(uid) {
            const {name, className, level} = DataUtil.class.unpackUidClassFeature(uid);
            return !(!name || !className || isNaN(level));
        }

        static packUidClassFeature(f) {
            return [f.name, f.className, f.classSource === Parser.SRC_PHB ? "" : f.classSource, f.level, f.source === f.classSource ? "" : f.source, ].join("|").replace(/\|+$/, "");
        }

        static unpackUidSubclassFeature(uid, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,className,classSource,subclassShortName,subclassSource,level,source,displayText] = uid.split("|").map(it=>it.trim());
            classSource = classSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
            subclassSource = subclassSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
            source = source || subclassSource;
            level = Number(level);
            return {
                name,
                className,
                classSource,
                subclassShortName,
                subclassSource,
                level,
                source,
                displayText,
            };
        }

        static isValidSubclassFeatureUid(uid) {
            const {name, className, subclassShortName, level} = DataUtil.class.unpackUidSubclassFeature(uid);
            return !(!name || !className || !subclassShortName || isNaN(level));
        }

        static packUidSubclassFeature(f) {
            return [f.name, f.className, f.classSource === Parser.SRC_PHB ? "" : f.classSource, f.subclassShortName, f.subclassSource === Parser.SRC_PHB ? "" : f.subclassSource, f.level, f.source === f.subclassSource ? "" : f.source, ].join("|").replace(/\|+$/, "");
        }

        static _CACHE_SUBCLASS_LOOKUP_PROMISE = null;
        static _CACHE_SUBCLASS_LOOKUP = null;
        static async pGetSubclassLookup() {
            DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE = DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE || (async()=>{
                const subclassLookup = {};
                Object.assign(subclassLookup, await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`));
                DataUtil.class._CACHE_SUBCLASS_LOOKUP = subclassLookup;
            }
            )();
            await DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE;
            return DataUtil.class._CACHE_SUBCLASS_LOOKUP;
        }
    }
    ,

    subclass: class extends _DataUtilPropConfig {
        static _PAGE = "subclass";
    }
    ,

    deity: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_DEITIES;
        static _FILENAME = "deities.json";

        static doPostLoad(data) {
            const PRINT_ORDER = [Parser.SRC_PHB, Parser.SRC_DMG, Parser.SRC_SCAG, Parser.SRC_VGM, Parser.SRC_MTF, Parser.SRC_ERLW, Parser.SRC_EGW, Parser.SRC_TDCSR, ];

            const inSource = {};
            PRINT_ORDER.forEach(src=>{
                inSource[src] = {};
                data.deity.filter(it=>it.source === src).forEach(it=>inSource[src][it.reprintAlias || it.name] = it);
            }
            );

            const laterPrinting = [PRINT_ORDER.last()];
            [...PRINT_ORDER].reverse().slice(1).forEach(src=>{
                laterPrinting.forEach(laterSrc=>{
                    Object.keys(inSource[src]).forEach(name=>{
                        const newer = inSource[laterSrc][name];
                        if (newer) {
                            const old = inSource[src][name];
                            old.reprinted = true;
                            if (!newer._isEnhanced) {
                                newer.previousVersions = newer.previousVersions || [];
                                newer.previousVersions.push(old);
                            }
                        }
                    }
                    );
                }
                );

                laterPrinting.push(src);
            }
            );
            data.deity.forEach(g=>g._isEnhanced = true);

            return data;
        }

        static async loadJSON() {
            const data = await super.loadJSON();
            DataUtil.deity.doPostLoad(data);
            return data;
        }

        static getUid(ent, opts) {
            return this.packUidDeity(ent, opts);
        }

        static getNormalizedUid(uid, tag) {
            const {name, pantheon, source} = this.unpackUidDeity(uid, tag, {
                isLower: true
            });
            return [name, pantheon, source].join("|");
        }

        static unpackUidDeity(uid, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,pantheon,source,displayText,...others] = uid.split("|").map(it=>it.trim());

            pantheon = pantheon || "forgotten realms";
            if (opts.isLower)
                pantheon = pantheon.toLowerCase();

            source = source || Parser.getTagSource("deity", source);
            if (opts.isLower)
                source = source.toLowerCase();

            return {
                name,
                pantheon,
                source,
                displayText,
                others,
            };
        }

        static packUidDeity(it) {
            const sourceDefault = Parser.getTagSource("deity");
            return [it.name, (it.pantheon || "").toLowerCase() === "forgotten realms" ? "" : it.pantheon, (it.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.source, ].join("|").replace(/\|+$/, "");
        }
    }
    ,

    table: class extends _DataUtilPropConfigCustom {
        static async loadJSON() {
            const datas = await Promise.all([`${Renderer.get().baseUrl}data/generated/gendata-tables.json`, `${Renderer.get().baseUrl}data/tables.json`, ].map(url=>DataUtil.loadJSON(url)));
            const combined = {};
            datas.forEach(data=>{
                Object.entries(data).forEach(([k,v])=>{
                    if (combined[k] && combined[k]instanceof Array && v instanceof Array)
                        combined[k] = combined[k].concat(v);
                    else if (combined[k] == null)
                        combined[k] = v;
                    else
                        throw new Error(`Could not merge keys for key "${k}"`);
                }
                );
            }
            );

            return combined;
        }
    }
    ,

    legendaryGroup: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_BESTIARY;
        static _FILENAME = "bestiary/legendarygroups.json";

        static async pLoadAll() {
            return (await this.loadJSON()).legendaryGroup;
        }
    }
    ,

    variantrule: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_VARIANTRULES;
        static _FILENAME = "variantrules.json";

        static async loadJSON() {
            const rawData = await super.loadJSON();
            const rawDataGenerated = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-variantrules.json`);

            return {
                variantrule: [...rawData.variantrule, ...rawDataGenerated.variantrule]
            };
        }
    }
    ,

    deck: class extends _DataUtilPropConfigCustom {
        static _PAGE = UrlUtil.PG_DECKS;

        static _pLoadJson = null;
        static _pLoadRawJson = null;

        static loadJSON() {
            return DataUtil.deck._pLoadJson = DataUtil.deck._pLoadJson || (async()=>{
                return {
                    deck: await DataLoader.pCacheAndGetAllSite("deck"),
                    card: await DataLoader.pCacheAndGetAllSite("card"),
                };
            }
            )();
        }

        static loadRawJSON() {
            return DataUtil.deck._pLoadRawJson = DataUtil.deck._pLoadRawJson || DataUtil.loadJSON(`${Renderer.get().baseUrl}data/decks.json`);
        }

        static async loadPrerelease() {
            return {
                deck: await DataLoader.pCacheAndGetAllPrerelease("deck"),
                card: await DataLoader.pCacheAndGetAllPrerelease("card"),
            };
        }

        static async loadBrew() {
            return {
                deck: await DataLoader.pCacheAndGetAllBrew("deck"),
                card: await DataLoader.pCacheAndGetAllBrew("card"),
            };
        }

        static unpackUidCard(uid, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,set,source,displayText] = uid.split("|").map(it=>it.trim());
            set = set || "none";
            source = source || Parser.getTagSource("card", source)[opts.isLower ? "toLowerCase" : "toString"]();
            return {
                name,
                set,
                source,
                displayText,
            };
        }
    }
    ,

    reward: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_REWARDS;
        static _FILENAME = "rewards.json";
    }
    ,

    rewardFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_REWARDS;
        static _FILENAME = "fluff-rewards.json";
    }
    ,

    trap: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_TRAPS_HAZARDS;
        static _FILENAME = "trapshazards.json";
    }
    ,

    trapFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_TRAPS_HAZARDS;
        static _FILENAME = "fluff-trapshazards.json";
    }
    ,

    hazard: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_TRAPS_HAZARDS;
        static _FILENAME = "trapshazards.json";
    }
    ,

    hazardFluff: class extends _DataUtilPropConfigSingleSource {
        static _PAGE = UrlUtil.PG_TRAPS_HAZARDS;
        static _FILENAME = "fluff-trapshazards.json";
    }
    ,

    quickreference: {
        unpackUid(uid, opts) {
            opts = opts || {};
            if (opts.isLower)
                uid = uid.toLowerCase();
            let[name,source,ixChapter,ixHeader,displayText] = uid.split("|").map(it=>it.trim());
            source = source || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
            ixChapter = Number(ixChapter || 0);
            return {
                name,
                ixChapter,
                ixHeader,
                source,
                displayText,
            };
        },
    },

    brew: new _DataUtilBrewHelper({
        defaultUrlRoot: VeCt.URL_ROOT_BREW
    }),
    prerelease: new _DataUtilBrewHelper({
        defaultUrlRoot: VeCt.URL_ROOT_PRERELEASE
    }),
};
//#endregion

//#region RollerUtil
globalThis.RollerUtil = {
    isCrypto() {
        return typeof window !== "undefined" && typeof window.crypto !== "undefined";
    },

    randomise(max, min=1) {
        if (min > max)
            return 0;
        if (max === min)
            return max;
        if (RollerUtil.isCrypto()) {
            return RollerUtil._randomise(min, max + 1);
        } else {
            return RollerUtil.roll(max) + min;
        }
    },

    rollOnArray(array) {
        return array[RollerUtil.randomise(array.length) - 1];
    },

    _randomise: (min,max)=>{
        if (isNaN(min) || isNaN(max))
            throw new Error(`Invalid min/max!`);

        const range = max - min;
        const bytesNeeded = Math.ceil(Math.log2(range) / 8);
        const randomBytes = new Uint8Array(bytesNeeded);
        const maximumRange = (2 ** 8) ** bytesNeeded;
        const extendedRange = Math.floor(maximumRange / range) * range;
        let i;
        let randomInteger;
        while (true) {
            window.crypto.getRandomValues(randomBytes);
            randomInteger = 0;
            for (i = 0; i < bytesNeeded; i++) {
                randomInteger <<= 8;
                randomInteger += randomBytes[i];
            }
            if (randomInteger < extendedRange) {
                randomInteger %= range;
                return min + randomInteger;
            }
        }
    }
    ,

    roll(max, fn=Math.random) {
        return Math.floor(fn() * max);
    },

    getColRollType(colLabel) {
        if (typeof colLabel !== "string")
            return false;
        colLabel = Renderer.stripTags(colLabel);

        if (Renderer.dice.lang.getTree3(colLabel))
            return RollerUtil.ROLL_COL_STANDARD;

        colLabel = colLabel.replace(RollerUtil._REGEX_ROLLABLE_COL_LABEL, "$1");
        if (Renderer.dice.lang.getTree3(colLabel))
            return RollerUtil.ROLL_COL_VARIABLE;

        return RollerUtil.ROLL_COL_NONE;
    },

    getFullRollCol(lbl) {
        if (lbl.includes("@dice"))
            return lbl;

        if (Renderer.dice.lang.getTree3(lbl))
            return `{@dice ${lbl}}`;

        const m = RollerUtil._REGEX_ROLLABLE_COL_LABEL.exec(lbl);
        if (!m)
            return lbl;

        return `{@dice ${m[1]}${m[2]}#$prompt_number:title=Enter a ${m[3].trim()}$#|${lbl}}`;
    },

    _DICE_REGEX_STR: "((([1-9]\\d*)?d([1-9]\\d*)(\\s*?[-+×x*÷/]\\s*?(\\d,\\d|\\d)+(\\.\\d+)?)?))+?",
};
RollerUtil.DICE_REGEX = new RegExp(RollerUtil._DICE_REGEX_STR,"g");
RollerUtil.REGEX_DAMAGE_DICE = /(?<average>\d+)(?<prefix> \((?:{@dice |{@damage ))(?<diceExp>[-+0-9d ]*)(?<suffix>}\)(?:\s*\+\s*the spell's level)? [a-z]+( \([-a-zA-Z0-9 ]+\))?( or [a-z]+( \([-a-zA-Z0-9 ]+\))?)? damage)/gi;
RollerUtil.REGEX_DAMAGE_FLAT = /(?<prefix>Hit: |{@h})(?<flatVal>[0-9]+)(?<suffix> [a-z]+( \([-a-zA-Z0-9 ]+\))?( or [a-z]+( \([-a-zA-Z0-9 ]+\))?)? damage)/gi;
RollerUtil._REGEX_ROLLABLE_COL_LABEL = /^(.*?\d)(\s*[-+/*^×÷]\s*)([a-zA-Z0-9 ]+)$/;
RollerUtil.ROLL_COL_NONE = 0;
RollerUtil.ROLL_COL_STANDARD = 1;
RollerUtil.ROLL_COL_VARIABLE = 2;
//#endregion
//#region CryptUtil
globalThis.CryptUtil = {
    _md5cycle: (x,k)=>{
        let a = x[0];
        let b = x[1];
        let c = x[2];
        let d = x[3];

        a = CryptUtil._ff(a, b, c, d, k[0], 7, -680876936);
        d = CryptUtil._ff(d, a, b, c, k[1], 12, -389564586);
        c = CryptUtil._ff(c, d, a, b, k[2], 17, 606105819);
        b = CryptUtil._ff(b, c, d, a, k[3], 22, -1044525330);
        a = CryptUtil._ff(a, b, c, d, k[4], 7, -176418897);
        d = CryptUtil._ff(d, a, b, c, k[5], 12, 1200080426);
        c = CryptUtil._ff(c, d, a, b, k[6], 17, -1473231341);
        b = CryptUtil._ff(b, c, d, a, k[7], 22, -45705983);
        a = CryptUtil._ff(a, b, c, d, k[8], 7, 1770035416);
        d = CryptUtil._ff(d, a, b, c, k[9], 12, -1958414417);
        c = CryptUtil._ff(c, d, a, b, k[10], 17, -42063);
        b = CryptUtil._ff(b, c, d, a, k[11], 22, -1990404162);
        a = CryptUtil._ff(a, b, c, d, k[12], 7, 1804603682);
        d = CryptUtil._ff(d, a, b, c, k[13], 12, -40341101);
        c = CryptUtil._ff(c, d, a, b, k[14], 17, -1502002290);
        b = CryptUtil._ff(b, c, d, a, k[15], 22, 1236535329);

        a = CryptUtil._gg(a, b, c, d, k[1], 5, -165796510);
        d = CryptUtil._gg(d, a, b, c, k[6], 9, -1069501632);
        c = CryptUtil._gg(c, d, a, b, k[11], 14, 643717713);
        b = CryptUtil._gg(b, c, d, a, k[0], 20, -373897302);
        a = CryptUtil._gg(a, b, c, d, k[5], 5, -701558691);
        d = CryptUtil._gg(d, a, b, c, k[10], 9, 38016083);
        c = CryptUtil._gg(c, d, a, b, k[15], 14, -660478335);
        b = CryptUtil._gg(b, c, d, a, k[4], 20, -405537848);
        a = CryptUtil._gg(a, b, c, d, k[9], 5, 568446438);
        d = CryptUtil._gg(d, a, b, c, k[14], 9, -1019803690);
        c = CryptUtil._gg(c, d, a, b, k[3], 14, -187363961);
        b = CryptUtil._gg(b, c, d, a, k[8], 20, 1163531501);
        a = CryptUtil._gg(a, b, c, d, k[13], 5, -1444681467);
        d = CryptUtil._gg(d, a, b, c, k[2], 9, -51403784);
        c = CryptUtil._gg(c, d, a, b, k[7], 14, 1735328473);
        b = CryptUtil._gg(b, c, d, a, k[12], 20, -1926607734);

        a = CryptUtil._hh(a, b, c, d, k[5], 4, -378558);
        d = CryptUtil._hh(d, a, b, c, k[8], 11, -2022574463);
        c = CryptUtil._hh(c, d, a, b, k[11], 16, 1839030562);
        b = CryptUtil._hh(b, c, d, a, k[14], 23, -35309556);
        a = CryptUtil._hh(a, b, c, d, k[1], 4, -1530992060);
        d = CryptUtil._hh(d, a, b, c, k[4], 11, 1272893353);
        c = CryptUtil._hh(c, d, a, b, k[7], 16, -155497632);
        b = CryptUtil._hh(b, c, d, a, k[10], 23, -1094730640);
        a = CryptUtil._hh(a, b, c, d, k[13], 4, 681279174);
        d = CryptUtil._hh(d, a, b, c, k[0], 11, -358537222);
        c = CryptUtil._hh(c, d, a, b, k[3], 16, -722521979);
        b = CryptUtil._hh(b, c, d, a, k[6], 23, 76029189);
        a = CryptUtil._hh(a, b, c, d, k[9], 4, -640364487);
        d = CryptUtil._hh(d, a, b, c, k[12], 11, -421815835);
        c = CryptUtil._hh(c, d, a, b, k[15], 16, 530742520);
        b = CryptUtil._hh(b, c, d, a, k[2], 23, -995338651);

        a = CryptUtil._ii(a, b, c, d, k[0], 6, -198630844);
        d = CryptUtil._ii(d, a, b, c, k[7], 10, 1126891415);
        c = CryptUtil._ii(c, d, a, b, k[14], 15, -1416354905);
        b = CryptUtil._ii(b, c, d, a, k[5], 21, -57434055);
        a = CryptUtil._ii(a, b, c, d, k[12], 6, 1700485571);
        d = CryptUtil._ii(d, a, b, c, k[3], 10, -1894986606);
        c = CryptUtil._ii(c, d, a, b, k[10], 15, -1051523);
        b = CryptUtil._ii(b, c, d, a, k[1], 21, -2054922799);
        a = CryptUtil._ii(a, b, c, d, k[8], 6, 1873313359);
        d = CryptUtil._ii(d, a, b, c, k[15], 10, -30611744);
        c = CryptUtil._ii(c, d, a, b, k[6], 15, -1560198380);
        b = CryptUtil._ii(b, c, d, a, k[13], 21, 1309151649);
        a = CryptUtil._ii(a, b, c, d, k[4], 6, -145523070);
        d = CryptUtil._ii(d, a, b, c, k[11], 10, -1120210379);
        c = CryptUtil._ii(c, d, a, b, k[2], 15, 718787259);
        b = CryptUtil._ii(b, c, d, a, k[9], 21, -343485551);

        x[0] = CryptUtil._add32(a, x[0]);
        x[1] = CryptUtil._add32(b, x[1]);
        x[2] = CryptUtil._add32(c, x[2]);
        x[3] = CryptUtil._add32(d, x[3]);
    }
    ,

    _cmn: (q,a,b,x,s,t)=>{
        a = CryptUtil._add32(CryptUtil._add32(a, q), CryptUtil._add32(x, t));
        return CryptUtil._add32((a << s) | (a >>> (32 - s)), b);
    }
    ,

    _ff: (a,b,c,d,x,s,t)=>{
        return CryptUtil._cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    ,

    _gg: (a,b,c,d,x,s,t)=>{
        return CryptUtil._cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    ,

    _hh: (a,b,c,d,x,s,t)=>{
        return CryptUtil._cmn(b ^ c ^ d, a, b, x, s, t);
    }
    ,

    _ii: (a,b,c,d,x,s,t)=>{
        return CryptUtil._cmn(c ^ (b | (~d)), a, b, x, s, t);
    }
    ,

    _md51: (s)=>{
        let n = s.length;
        let state = [1732584193, -271733879, -1732584194, 271733878];
        let i;
        for (i = 64; i <= s.length; i += 64) {
            CryptUtil._md5cycle(state, CryptUtil._md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        let tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < s.length; i++)
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            CryptUtil._md5cycle(state, tail);
            for (i = 0; i < 16; i++)
                tail[i] = 0;
        }
        tail[14] = n * 8;
        CryptUtil._md5cycle(state, tail);
        return state;
    }
    ,

    _md5blk: (s)=>{
        let md5blks = [];
        for (let i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }
    ,

    _hex_chr: "0123456789abcdef".split(""),

    _rhex: (n)=>{
        let s = "";
        for (let j = 0; j < 4; j++) {
            s += CryptUtil._hex_chr[(n >> (j * 8 + 4)) & 0x0F] + CryptUtil._hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }
    ,

    _add32: (a,b)=>{
        return (a + b) & 0xFFFFFFFF;
    }
    ,

    hex: (x)=>{
        for (let i = 0; i < x.length; i++) {
            x[i] = CryptUtil._rhex(x[i]);
        }
        return x.join("");
    }
    ,

    hex2Dec(hex) {
        return parseInt(`0x${hex}`);
    },

    md5: (s)=>{
        return CryptUtil.hex(CryptUtil._md51(s));
    }
    ,

    hashCode(obj) {
        if (typeof obj === "string") {
            if (!obj)
                return 0;
            let h = 0;
            for (let i = 0; i < obj.length; ++i)
                h = 31 * h + obj.charCodeAt(i);
            return h;
        } else if (typeof obj === "number")
            return obj;
        else
            throw new Error(`No hashCode implementation for ${obj}`);
    },

    uid() {
        if (RollerUtil.isCrypto()) {
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c=>(c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
        } else {
            let d = Date.now();
            if (typeof performance !== "undefined" && typeof performance.now === "function") {
                d += performance.now();
            }
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
                const r = (d + Math.random() * 16) % 16 | 0;
                d = Math.floor(d / 16);
                return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
    },
};
//#endregion

//#region SourceFilter
let FilterBox$1 = class FilterBox extends ProxyBase {
    static TITLE_BTN_RESET = "Reset filters. SHIFT to reset everything.";

    static selectFirstVisible(entryList) {
        if (Hist.lastLoadedId == null && !Hist.initialLoad) {
            Hist._freshLoad();
        }

    }

    constructor(opts) {
        super();

        this._$iptSearch = opts.$iptSearch;
        this._$wrpFormTop = opts.$wrpFormTop;
        this._$btnReset = opts.$btnReset;
        this._$btnOpen = opts.$btnOpen;
        this._$wrpMiniPills = opts.$wrpMiniPills;
        this._$btnToggleSummaryHidden = opts.$btnToggleSummaryHidden;
        this._filters = opts.filters;
        this._isCompact = opts.isCompact;
        this._namespace = opts.namespace;

        this._doSaveStateThrottled = MiscUtil.throttle(()=>this._pDoSaveState(), 50);
        this.__meta = this._getDefaultMeta();
        if (this._isCompact)
            this.__meta.isSummaryHidden = true;

        this._meta = this._getProxy("meta", this.__meta);
        this.__minisHidden = {};
        this._minisHidden = this._getProxy("minisHidden", this.__minisHidden);
        this.__combineAs = {};
        this._combineAs = this._getProxy("combineAs", this.__combineAs);
        this._modalMeta = null;
        this._isRendered = false;

        this._cachedState = null;

        this._compSearch = BaseComponent.fromObject({
            search: ""
        });
        this._metaIptSearch = null;

        this._filters.forEach(f=>f.filterBox = this);

        this._eventListeners = {};
    }

    get filters() {
        return this._filters;
    }

    teardown() {
        this._filters.forEach(f=>f._doTeardown());
        if (this._modalMeta)
            this._modalMeta.doTeardown();
    }

    on(identifier, fn) {
        const [eventName,namespace] = identifier.split(".");
        (this._eventListeners[eventName] = this._eventListeners[eventName] || []).push({
            namespace,
            fn
        });
        return this;
    }

    off(identifier, fn=null) {
        const [eventName,namespace] = identifier.split(".");
        this._eventListeners[eventName] = (this._eventListeners[eventName] || []).filter(it=>{
            if (fn != null)
                return it.namespace !== namespace || it.fn !== fn;
            return it.namespace !== namespace;
        }
        );
        if (!this._eventListeners[eventName].length)
            delete this._eventListeners[eventName];
        return this;
    }

    fireChangeEvent() {
        this._doSaveStateThrottled();
        this.fireEvent(FilterBox$1.EVNT_VALCHANGE);
    }

    fireEvent(eventName) {
        (this._eventListeners[eventName] || []).forEach(it=>it.fn());
    }

    _getNamespacedStorageKey() {
        return `${FilterBox$1._STORAGE_KEY}${this._namespace ? `.${this._namespace}` : ""}`;
    }
    getNamespacedHashKey(k) {
        return `${k || "_".repeat(FilterUtil.SUB_HASH_PREFIX_LENGTH)}${this._namespace ? `.${this._namespace}` : ""}`;
    }

    async pGetStoredActiveSources() {
        const stored = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
        if (stored) {
            const sourceFilterData = stored.filters[FilterBox$1.SOURCE_HEADER];
            if (sourceFilterData) {
                const state = sourceFilterData.state;
                const blue = [];
                const white = [];
                Object.entries(state).forEach(([src,mode])=>{
                    if (mode === 1)
                        blue.push(src);
                    else if (mode !== -1)
                        white.push(src);
                }
                );
                if (blue.length)
                    return blue;
                else
                    return white;
            }
        }
        return null;
    }

    registerMinisHiddenHook(prop, hook) {
        this._addHook("minisHidden", prop, hook);
    }

    isMinisHidden(header) {
        return !!this._minisHidden[header];
    }

    async pDoLoadState() {
        const toLoad = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
        if (toLoad == null)
            return;
        this._setStateFromLoaded(toLoad, {
            isUserSavedState: true
        });
    }

    _setStateFromLoaded(state, {isUserSavedState=false}={}) {
        state.box = state.box || {};
        this._proxyAssign("meta", "_meta", "__meta", state.box.meta || {}, true);
        this._proxyAssign("minisHidden", "_minisHidden", "__minisHidden", state.box.minisHidden || {}, true);
        this._proxyAssign("combineAs", "_combineAs", "__combineAs", state.box.combineAs || {}, true);
        this._filters.forEach(it=>it.setStateFromLoaded(state.filters, {
            isUserSavedState
        }));
    }

    _getSaveableState() {
        const filterOut = {};
        this._filters.forEach(it=>Object.assign(filterOut, it.getSaveableState()));
        return {
            box: {
                meta: {
                    ...this.__meta
                },
                minisHidden: {
                    ...this.__minisHidden
                },
                combineAs: {
                    ...this.__combineAs
                },
            },
            filters: filterOut,
        };
    }

    async _pDoSaveState() {
        await StorageUtil.pSetForPage(this._getNamespacedStorageKey(), this._getSaveableState());
    }

    trimState_() {
        this._filters.forEach(f=>f.trimState_());
    }

    render() {
        if (this._isRendered) {
            this._filters.map(f=>f.update());
            return;
        }
        this._isRendered = true;

        if (this._$wrpFormTop || this._$wrpMiniPills) {
            if (!this._$wrpMiniPills) {
                this._$wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`).insertAfter(this._$wrpFormTop);
            } else {
                this._$wrpMiniPills.addClass("fltr__mini-view");
            }
        }

        if (this._$btnReset) {
            this._$btnReset.title(FilterBox$1.TITLE_BTN_RESET).click((evt)=>this.reset(evt.shiftKey));
        }

        if (this._$wrpFormTop || this._$btnToggleSummaryHidden) {
            if (!this._$btnToggleSummaryHidden) {
                this._$btnToggleSummaryHidden = $(`<button class="btn btn-default ${this._isCompact ? "p-2" : ""}" title="Toggle Filter Summary"><span class="glyphicon glyphicon-resize-small"></span></button>`).prependTo(this._$wrpFormTop);
            } else if (!this._$btnToggleSummaryHidden.parent().length) {
                this._$btnToggleSummaryHidden.prependTo(this._$wrpFormTop);
            }
            this._$btnToggleSummaryHidden.click(()=>{
                this._meta.isSummaryHidden = !this._meta.isSummaryHidden;
                this._doSaveStateThrottled();
            }
            );
            const summaryHiddenHook = ()=>{
                this._$btnToggleSummaryHidden.toggleClass("active", !!this._meta.isSummaryHidden);
                this._$wrpMiniPills.toggleClass("ve-hidden", !!this._meta.isSummaryHidden);
            }
            ;
            this._addHook("meta", "isSummaryHidden", summaryHiddenHook);
            summaryHiddenHook();
        }

        if (this._$wrpFormTop || this._$btnOpen) {
            if (!this._$btnOpen) {
                this._$btnOpen = $(`<button class="btn btn-default ${this._isCompact ? "px-2" : ""}">Filter</button>`).prependTo(this._$wrpFormTop);
            } else if (!this._$btnOpen.parent().length) {
                this._$btnOpen.prependTo(this._$wrpFormTop);
            }
            this._$btnOpen.click(()=>this.show());
        }

        const sourceFilter = this._filters.find(it=>it.header === FilterBox$1.SOURCE_HEADER);
        if (sourceFilter) {
            const selFnAlt = (val)=>!SourceUtil.isNonstandardSource(val) && !PrereleaseUtil.hasSourceJson(val) && !BrewUtil2.hasSourceJson(val);
            const hkSelFn = ()=>{
                if (this._meta.isBrewDefaultHidden)
                    sourceFilter.setTempFnSel(selFnAlt);
                else
                    sourceFilter.setTempFnSel(null);
                sourceFilter.updateMiniPillClasses();
            }
            ;
            this._addHook("meta", "isBrewDefaultHidden", hkSelFn);
            hkSelFn();
        }

        if (this._$wrpMiniPills)
            this._filters.map((f,i)=>f.$renderMinis({
                filterBox: this,
                isFirst: i === 0,
                $wrpMini: this._$wrpMiniPills
            }));
    }

    async _render_pRenderModal() {
        this._isModalRendered = true;

        this._modalMeta = await UiUtil.pGetShowModal({
            isHeight100: true,
            isWidth100: true,
            isUncappedHeight: true,
            isIndestructible: true,
            isClosed: true,
            isEmpty: true,
            title: "Filter",
            cbClose: (isDataEntered)=>this._pHandleHide(!isDataEntered),
        });

        const $children = this._filters.map((f,i)=>f.$render({
            filterBox: this,
            isFirst: i === 0,
            $wrpMini: this._$wrpMiniPills
        }));

        this._metaIptSearch = ComponentUiUtil.$getIptStr(this._compSearch, "search", {
            decorationRight: "clear",
            asMeta: true,
            html: `<input class="form-control input-xs" placeholder="Search...">`
        }, );
        this._compSearch._addHookBase("search", ()=>{
            const searchTerm = this._compSearch._state.search.toLowerCase();
            this._filters.forEach(f=>f.handleSearch(searchTerm));
        }
        );

        const $btnShowAllFilters = $(`<button class="btn btn-xs btn-default">Show All</button>`).click(()=>this.showAllFilters());
        const $btnHideAllFilters = $(`<button class="btn btn-xs btn-default">Hide All</button>`).click(()=>this.hideAllFilters());

        const $btnReset = $(`<button class="btn btn-xs btn-default mr-3" title="${FilterBox$1.TITLE_BTN_RESET}">Reset</button>`).click(evt=>this.reset(evt.shiftKey));

        const $btnSettings = $(`<button class="btn btn-xs btn-default mr-3"><span class="glyphicon glyphicon-cog"></span></button>`).click(()=>this._pOpenSettingsModal());

        const $btnSaveAlt = $(`<button class="btn btn-xs btn-primary" title="Save"><span class="glyphicon glyphicon-ok"></span></button>`).click(()=>this._modalMeta.doClose(true));

        const $wrpBtnCombineFilters = $(`<div class="btn-group mr-3"></div>`);
        const $btnCombineFilterSettings = $(`<button class="btn btn-xs btn-default"><span class="glyphicon glyphicon-cog"></span></button>`).click(()=>this._pOpenCombineAsModal());

        const btnCombineFiltersAs = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default`,
            click: ()=>this._meta.modeCombineFilters = FilterBox$1._COMBINE_MODES.getNext(this._meta.modeCombineFilters),
            title: `"AND" requires every filter to match. "OR" requires any filter to match. "Custom" allows you to specify a combination (every "AND" filter must match; only one "OR" filter must match) .`,
        }).appendTo($wrpBtnCombineFilters[0]);

        const hook = ()=>{
            btnCombineFiltersAs.innerText = this._meta.modeCombineFilters === "custom" ? this._meta.modeCombineFilters.uppercaseFirst() : this._meta.modeCombineFilters.toUpperCase();
            if (this._meta.modeCombineFilters === "custom")
                $wrpBtnCombineFilters.append($btnCombineFilterSettings);
            else
                $btnCombineFilterSettings.detach();
            this._doSaveStateThrottled();
        }
        ;
        this._addHook("meta", "modeCombineFilters", hook);
        hook();

        const $btnSave = $(`<button class="btn btn-primary fltr__btn-close mr-2">Save</button>`).click(()=>this._modalMeta.doClose(true));

        const $btnCancel = $(`<button class="btn btn-default fltr__btn-close">Cancel</button>`).click(()=>this._modalMeta.doClose(false));

        $$(this._modalMeta.$modal)`<div class="split mb-2 mt-2 ve-flex-v-center mobile__ve-flex-col">
			<div class="ve-flex-v-baseline mobile__ve-flex-col">
				<h4 class="m-0 mr-2 mobile__mb-2">Filters</h4>
				${this._metaIptSearch.$wrp.addClass("mobile__mb-2")}
			</div>
			<div class="ve-flex-v-center mobile__ve-flex-col">
				<div class="ve-flex-v-center mobile__m-1">
					<div class="mr-2">Combine as</div>
					${$wrpBtnCombineFilters}
				</div>
				<div class="ve-flex-v-center mobile__m-1">
					<div class="btn-group mr-2 ve-flex-h-center">
						${$btnShowAllFilters}
						${$btnHideAllFilters}
					</div>
					${$btnReset}
					${$btnSettings}
					${$btnSaveAlt}
				</div>
			</div>
		</div>
		<hr class="w-100 m-0 mb-2">

		<hr class="mt-1 mb-1">
		<div class="ui-modal__scroller smooth-scroll px-1">
			${$children}
		</div>
		<hr class="my-1 w-100">
		<div class="w-100 ve-flex-vh-center my-1">${$btnSave}${$btnCancel}</div>`;
    }

    async _pOpenSettingsModal() {
        const {$modalInner} = await UiUtil.pGetShowModal({
            title: "Settings"
        });

        UiUtil.$getAddModalRowCb($modalInner, "Deselect Homebrew Sources by Default", this._meta, "isBrewDefaultHidden");

        UiUtil.addModalSep($modalInner);

        UiUtil.$getAddModalRowHeader($modalInner, "Hide summary for filter...", {
            helpText: "The summary is the small red and blue button panel which appear below the search bar."
        });
        this._filters.forEach(f=>UiUtil.$getAddModalRowCb($modalInner, f.header, this._minisHidden, f.header));

        UiUtil.addModalSep($modalInner);

        const $rowResetAlwaysSave = UiUtil.$getAddModalRow($modalInner, "div").addClass("pr-2");
        $rowResetAlwaysSave.append(`<span>Always Save on Close</span>`);
        $(`<button class="btn btn-xs btn-default">Reset</button>`).appendTo($rowResetAlwaysSave).click(async()=>{
            await StorageUtil.pRemove(FilterBox$1._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED);
            JqueryUtil.doToast("Saved!");
        }
        );
    }

    async _pOpenCombineAsModal() {
        const {$modalInner} = await UiUtil.pGetShowModal({
            title: "Filter Combination Logic"
        });
        const $btnReset = $(`<button class="btn btn-xs btn-default">Reset</button>`).click(()=>{
            Object.keys(this._combineAs).forEach(k=>this._combineAs[k] = "and");
            $sels.forEach($sel=>$sel.val("0"));
        }
        );
        UiUtil.$getAddModalRowHeader($modalInner, "Combine filters as...", {
            $eleRhs: $btnReset
        });
        const $sels = this._filters.map(f=>UiUtil.$getAddModalRowSel($modalInner, f.header, this._combineAs, f.header, ["and", "or"], {
            fnDisplay: (it)=>it.toUpperCase()
        }));
    }

    getValues({nxtStateOuter=null}={}) {
        const outObj = {};
        this._filters.forEach(f=>Object.assign(outObj, f.getValues({
            nxtState: nxtStateOuter?.filters
        })));
        return outObj;
    }

    addEventListener(type, listener) {
        (this._$wrpFormTop ? this._$wrpFormTop[0] : this._$btnOpen[0]).addEventListener(type, listener);
    }

    _mutNextState_reset_meta({tgt}) {
        Object.assign(tgt, this._getDefaultMeta());
    }

    _mutNextState_minisHidden({tgt}) {
        Object.assign(tgt, this._getDefaultMinisHidden(tgt));
    }

    _mutNextState_combineAs({tgt}) {
        Object.assign(tgt, this._getDefaultCombineAs(tgt));
    }

    _reset_meta() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_reset_meta({
            tgt: nxtBoxState.meta
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    _reset_minisHidden() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_minisHidden({
            tgt: nxtBoxState.minisHidden
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    _reset_combineAs() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_combineAs({
            tgt: nxtBoxState.combineAs
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    reset(isResetAll) {
        this._filters.forEach(f=>f.reset({
            isResetAll
        }));
        if (isResetAll) {
            this._reset_meta();
            this._reset_minisHidden();
            this._reset_combineAs();
        }
        this.render();
        this.fireChangeEvent();
    }

    async show() {
        if (!this._isModalRendered)
            await this._render_pRenderModal();
        this._cachedState = this._getSaveableState();
        this._modalMeta.doOpen();
        if (this._metaIptSearch?.$ipt)
            this._metaIptSearch.$ipt.focus();
    }

    async _pHandleHide(isCancel=false) {
        if (this._cachedState && isCancel) {
            const curState = this._getSaveableState();
            const hasChanges = !CollectionUtil.deepEquals(curState, this._cachedState);

            if (hasChanges) {
                const isSave = await InputUiUtil.pGetUserBoolean({
                    title: "Unsaved Changes",
                    textYesRemember: "Always Save",
                    textYes: "Save",
                    textNo: "Discard",
                    storageKey: FilterBox$1._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED,
                    isGlobal: true,
                });
                if (isSave) {
                    this._cachedState = null;
                    this.fireChangeEvent();
                    return;
                } else
                    this._setStateFromLoaded(this._cachedState, {
                        isUserSavedState: true
                    });
            }
        } else {
            this.fireChangeEvent();
        }

        this._cachedState = null;
    }

    showAllFilters() {
        this._filters.forEach(f=>f.show());
    }

    hideAllFilters() {
        this._filters.forEach(f=>f.hide());
    }

    unpackSubHashes(subHashes, {force=false}={}) {
        const unpacked = {};
        subHashes.forEach(s=>{
            const unpackedPart = UrlUtil.unpackSubHash(s, true);
            if (Object.keys(unpackedPart).length > 1)
                throw new Error(`Multiple keys in subhash!`);
            const k = Object.keys(unpackedPart)[0];
            unpackedPart[k] = {
                clean: unpackedPart[k],
                raw: s
            };
            Object.assign(unpacked, unpackedPart);
        }
        );

        const urlHeaderToFilter = {};
        this._filters.forEach(f=>{
            const childFilters = f.getChildFilters();
            if (childFilters.length)
                childFilters.forEach(f=>urlHeaderToFilter[f.header.toLowerCase()] = f);
            urlHeaderToFilter[f.header.toLowerCase()] = f;
        }
        );

        const urlHeadersUpdated = new Set();
        const subHashesConsumed = new Set();
        let filterInitialSearch;

        const filterBoxState = {};
        const statePerFilter = {};
        const prefixLen = this.getNamespacedHashKey().length;
        Object.entries(unpacked).forEach(([hashKey,data])=>{
            const rawPrefix = hashKey.substring(0, prefixLen);
            const prefix = rawPrefix.substring(0, FilterUtil.SUB_HASH_PREFIX_LENGTH);

            const urlHeader = hashKey.substring(prefixLen);

            if (FilterUtil.SUB_HASH_PREFIXES.has(prefix) && urlHeaderToFilter[urlHeader]) {
                (statePerFilter[urlHeader] = statePerFilter[urlHeader] || {})[prefix] = data.clean;
                urlHeadersUpdated.add(urlHeader);
                subHashesConsumed.add(data.raw);
                return;
            }

            if (Object.values(FilterBox$1._SUB_HASH_PREFIXES).includes(prefix)) {
                if (prefix === VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX)
                    filterInitialSearch = data.clean[0];
                else
                    filterBoxState[prefix] = data.clean;
                subHashesConsumed.add(data.raw);
                return;
            }

            if (FilterUtil.SUB_HASH_PREFIXES.has(prefix))
                throw new Error(`Could not find filter with header ${urlHeader} for subhash ${data.raw}`);
        }
        );

        if (!subHashesConsumed.size && !force)
            return null;

        return {
            urlHeaderToFilter,
            filterBoxState,
            statePerFilter,
            urlHeadersUpdated,
            unpacked,
            subHashesConsumed,
            filterInitialSearch,
        };
    }

    setFromSubHashes(subHashes, {force=false, $iptSearch=null}={}) {
        const unpackedSubhashes = this.unpackSubHashes(subHashes, {
            force
        });

        if (unpackedSubhashes == null)
            return subHashes;

        const {unpacked, subHashesConsumed, filterInitialSearch, } = unpackedSubhashes;

        const {box: nxtStateBox, filters: nxtStatesFilters} = this.getNextStateFromSubHashes({
            unpackedSubhashes
        });

        this._setBoxStateFromNextBoxState(nxtStateBox);

        this._filters.flatMap(f=>[f, ...f.getChildFilters(), ]).filter(filter=>nxtStatesFilters[filter.header]).forEach(filter=>filter.setStateFromNextState(nxtStatesFilters));

        if (filterInitialSearch && ($iptSearch || this._$iptSearch))
            ($iptSearch || this._$iptSearch).val(filterInitialSearch).change().keydown().keyup().trigger("instantKeyup");

        const [link] = Hist.getHashParts();

        const outSub = [];
        Object.values(unpacked).filter(v=>!subHashesConsumed.has(v.raw)).forEach(v=>outSub.push(v.raw));

        Hist.setSuppressHistory(true);
        Hist.replaceHistoryHash(`${link}${outSub.length ? `${HASH_PART_SEP}${outSub.join(HASH_PART_SEP)}` : ""}`);

        this.fireChangeEvent();
        Hist.hashChange({
            isBlankFilterLoad: true
        });
        return outSub;
    }

    getNextStateFromSubHashes({unpackedSubhashes}) {
        const {urlHeaderToFilter, filterBoxState, statePerFilter, urlHeadersUpdated, } = unpackedSubhashes;

        const nxtStateBox = this._getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState);

        const nxtStateFilters = {};

        Object.entries(statePerFilter).forEach(([urlHeader,state])=>{
            const filter = urlHeaderToFilter[urlHeader];
            Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(state));
        }
        );

        Object.keys(urlHeaderToFilter).filter(k=>!urlHeadersUpdated.has(k)).forEach(k=>{
            const filter = urlHeaderToFilter[k];
            Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(null));
        }
        );

        return {
            box: nxtStateBox,
            filters: nxtStateFilters
        };
    }

    _getNextBoxState_base() {
        return {
            meta: MiscUtil.copyFast(this.__meta),
            minisHidden: MiscUtil.copyFast(this.__minisHidden),
            combineAs: MiscUtil.copyFast(this.__combineAs),
        };
    }

    _getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState) {
        const nxtBoxState = this._getNextBoxState_base();

        let hasMeta = false;
        let hasMinisHidden = false;
        let hasCombineAs = false;

        Object.entries(filterBoxState).forEach(([k,vals])=>{
            const mappedK = this.getNamespacedHashKey(Parser._parse_bToA(FilterBox$1._SUB_HASH_PREFIXES, k));
            switch (mappedK) {
            case "meta":
                {
                    hasMeta = true;
                    const data = vals.map(v=>UrlUtil.mini.decompress(v));
                    Object.keys(this._getDefaultMeta()).forEach((k,i)=>nxtBoxState.meta[k] = data[i]);
                    break;
                }
            case "minisHidden":
                {
                    hasMinisHidden = true;
                    Object.keys(nxtBoxState.minisHidden).forEach(k=>nxtBoxState.minisHidden[k] = false);
                    vals.forEach(v=>{
                        const [urlHeader,isHidden] = v.split("=");
                        const filter = urlHeaderToFilter[urlHeader];
                        if (!filter)
                            throw new Error(`Could not find filter with name "${urlHeader}"`);
                        nxtBoxState.minisHidden[filter.header] = !!Number(isHidden);
                    }
                    );
                    break;
                }
            case "combineAs":
                {
                    hasCombineAs = true;
                    Object.keys(nxtBoxState.combineAs).forEach(k=>nxtBoxState.combineAs[k] = "and");
                    vals.forEach(v=>{
                        const [urlHeader,ixCombineMode] = v.split("=");
                        const filter = urlHeaderToFilter[urlHeader];
                        if (!filter)
                            throw new Error(`Could not find filter with name "${urlHeader}"`);
                        nxtBoxState.combineAs[filter.header] = FilterBox$1._COMBINE_MODES[ixCombineMode] || FilterBox$1._COMBINE_MODES[0];
                    }
                    );
                    break;
                }
            }
        }
        );

        if (!hasMeta)
            this._mutNextState_reset_meta({
                tgt: nxtBoxState.meta
            });
        if (!hasMinisHidden)
            this._mutNextState_minisHidden({
                tgt: nxtBoxState.minisHidden
            });
        if (!hasCombineAs)
            this._mutNextState_combineAs({
                tgt: nxtBoxState.combineAs
            });

        return nxtBoxState;
    }

    _setBoxStateFromNextBoxState(nxtBoxState) {
        this._proxyAssignSimple("meta", nxtBoxState.meta, true);
        this._proxyAssignSimple("minisHidden", nxtBoxState.minisHidden, true);
        this._proxyAssignSimple("combineAs", nxtBoxState.combineAs, true);
    }

    getSubHashes(opts) {
        opts = opts || {};
        const out = [];
        const boxSubHashes = this.getBoxSubHashes();
        if (boxSubHashes)
            out.push(boxSubHashes);
        out.push(...this._filters.map(f=>f.getSubHashes()).filter(Boolean));
        if (opts.isAddSearchTerm && this._$iptSearch) {
            const searchTerm = UrlUtil.encodeForHash(this._$iptSearch.val().trim());
            if (searchTerm)
                out.push(UrlUtil.packSubHash(this._getSubhashPrefix("search"), [searchTerm]));
        }
        return out.flat();
    }

    getBoxSubHashes() {
        const out = [];

        const defaultMeta = this._getDefaultMeta();

        const anyNotDefault = Object.keys(defaultMeta).find(k=>this._meta[k] !== defaultMeta[k]);
        if (anyNotDefault) {
            const serMeta = Object.keys(defaultMeta).map(k=>UrlUtil.mini.compress(this._meta[k] === undefined ? defaultMeta[k] : this._meta[k]));
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("meta"), serMeta));
        }

        const setMinisHidden = Object.entries(this._minisHidden).filter(([k,v])=>!!v).map(([k])=>`${k.toUrlified()}=1`);
        if (setMinisHidden.length) {
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("minisHidden"), setMinisHidden));
        }

        const setCombineAs = Object.entries(this._combineAs).filter(([k,v])=>v !== FilterBox$1._COMBINE_MODES[0]).map(([k,v])=>`${k.toUrlified()}=${FilterBox$1._COMBINE_MODES.indexOf(v)}`);
        if (setCombineAs.length) {
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("combineAs"), setCombineAs));
        }

        return out.length ? out : null;
    }

    getFilterTag({isAddSearchTerm=false}={}) {
        const parts = this._filters.map(f=>f.getFilterTagPart()).filter(Boolean);
        if (isAddSearchTerm && this._$iptSearch) {
            const term = this._$iptSearch.val().trim();
            if (term)
                parts.push(`search=${term}`);
        }
        return `{@filter |${UrlUtil.getCurrentPage().replace(/\.html$/, "")}|${parts.join("|")}}`;
    }

    getDisplayState({nxtStateOuter=null}={}) {
        return this._filters.map(filter=>filter.getDisplayStatePart({
            nxtState: nxtStateOuter?.filters
        })).filter(Boolean).join("; ");
    }

    setFromValues(values) {
        this._filters.forEach(it=>it.setFromValues(values));
        this.fireChangeEvent();
    }

    toDisplay(boxState, ...entryVals) {
        return this._toDisplay(boxState, this._filters, entryVals);
    }

    toDisplayByFilters(boxState, ...filterToValueTuples) {
        return this._toDisplay(boxState, filterToValueTuples.map(it=>it.filter), filterToValueTuples.map(it=>it.value), );
    }

    _toDisplay(boxState, filters, entryVals) {
        switch (this._meta.modeCombineFilters) {
        case "and":
            return this._toDisplay_isAndDisplay(boxState, filters, entryVals);
        case "or":
            return this._toDisplay_isOrDisplay(boxState, filters, entryVals);
        case "custom":
            {
                if (entryVals.length !== filters.length)
                    throw new Error(`Number of filters and number of values did not match!`);

                const andFilters = [];
                const andValues = [];
                const orFilters = [];
                const orValues = [];

                for (let i = 0; i < filters.length; ++i) {
                    const f = filters[i];
                    if (!this._combineAs[f.header] || this._combineAs[f.header] === "and") {
                        andFilters.push(f);
                        andValues.push(entryVals[i]);
                    } else {
                        orFilters.push(f);
                        orValues.push(entryVals[i]);
                    }
                }

                return this._toDisplay_isAndDisplay(boxState, andFilters, andValues) && this._toDisplay_isOrDisplay(boxState, orFilters, orValues);
            }
        default:
            throw new Error(`Unhandled combining mode "${this._meta.modeCombineFilters}"`);
        }
    }

    _toDisplay_isAndDisplay(boxState, filters, vals) {
        return filters.map((f,i)=>f.toDisplay(boxState, vals[i])).every(it=>it);
    }

    _toDisplay_isOrDisplay(boxState, filters, vals) {
        const res = filters.map((f,i)=>{
            if (!f.isActive(boxState))
                return null;
            return f.toDisplay(boxState, vals[i]);
        }
        ).filter(it=>it != null);
        return res.length === 0 || res.find(it=>it);
    }

    _getSubhashPrefix(prop) {
        if (FilterBox$1._SUB_HASH_PREFIXES[prop])
            return this.getNamespacedHashKey(FilterBox$1._SUB_HASH_PREFIXES[prop]);
        throw new Error(`Unknown property "${prop}"`);
    }

    _getDefaultMeta() {
        const out = MiscUtil.copy(FilterBox$1._DEFAULT_META);
        if (this._isCompact)
            out.isSummaryHidden = true;
        return out;
    }

    _getDefaultMinisHidden(minisHidden) {
        if (!minisHidden)
            throw new Error(`Missing "minisHidden" argument!`);
        return Object.keys(minisHidden).mergeMap(k=>({
            [k]: false
        }));
    }

    _getDefaultCombineAs(combineAs) {
        if (!combineAs)
            throw new Error(`Missing "combineAs" argument!`);
        return Object.keys(combineAs).mergeMap(k=>({
            [k]: "and"
        }));
    }
}
;
FilterBox$1.EVNT_VALCHANGE = "valchange";
FilterBox$1.SOURCE_HEADER = "Source";
FilterBox$1._PILL_STATES = ["ignore", "yes", "no"];
FilterBox$1._COMBINE_MODES = ["and", "or", "custom"];
FilterBox$1._STORAGE_KEY = "filterBoxState";
FilterBox$1._DEFAULT_META = {
    modeCombineFilters: "and",
    isSummaryHidden: false,
    isBrewDefaultHidden: false,
};
FilterBox$1._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED = "filterAlwaysSaveUnchanged";

FilterBox$1._SUB_HASH_BOX_META_PREFIX = "fbmt";
FilterBox$1._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX = "fbmh";
FilterBox$1._SUB_HASH_BOX_COMBINE_AS_PREFIX = "fbca";
FilterBox$1._SUB_HASH_PREFIXES = {
    meta: FilterBox$1._SUB_HASH_BOX_META_PREFIX,
    minisHidden: FilterBox$1._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX,
    combineAs: FilterBox$1._SUB_HASH_BOX_COMBINE_AS_PREFIX,
    search: VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX,
};
let FilterItem$1 = class FilterItem {
    constructor(options) {
        this.item = options.item;
        this.pFnChange = options.pFnChange;
        this.group = options.group;
        this.nest = options.nest;
        this.nestHidden = options.nestHidden;
        this.isIgnoreRed = options.isIgnoreRed;
        this.userData = options.userData;

        this.rendered = null;
        this.searchText = null;
    }
}
;

class FilterBase extends BaseComponent {
    constructor(opts) {
        super();
        this._filterBox = null;

        this.header = opts.header;
        this._headerHelp = opts.headerHelp;

        this.__meta = {
            ...this.getDefaultMeta()
        };
        this._meta = this._getProxy("meta", this.__meta);

        this._hasUserSavedState = false;
    }

    _getRenderedHeader() {
        return `<span ${this._headerHelp ? `title="${this._headerHelp.escapeQuotes()}" class="help-subtle"` : ""}>${this.header}</span>`;
    }

    set filterBox(it) {
        this._filterBox = it;
    }

    show() {
        this._meta.isHidden = false;
    }

    hide() {
        this._meta.isHidden = true;
    }

    getBaseSaveableState() {
        return {
            meta: {
                ...this.__meta
            }
        };
    }

    _getNextState_base() {
        return {
            [this.header]: {
                state: MiscUtil.copyFast(this.__state),
                meta: MiscUtil.copyFast(this.__meta),
            },
        };
    }

    setStateFromNextState(nxtState) {
        this._proxyAssignSimple("state", nxtState[this.header].state, true);
        this._proxyAssignSimple("meta", nxtState[this.header].meta, true);
    }

    reset({isResetAll=false}={}) {
        const nxtState = this._getNextState_base();
        this._mutNextState_reset(nxtState, {
            isResetAll
        });
        this.setStateFromNextState(nxtState);
    }

    _mutNextState_resetBase(nxtState, {isResetAll=false}={}) {
        Object.assign(nxtState[this.header].meta, MiscUtil.copy(this.getDefaultMeta()));
    }

    getMetaSubHashes() {
        const compressedMeta = this._getCompressedMeta();
        if (!compressedMeta)
            return null;
        return [UrlUtil.packSubHash(this.getSubHashPrefix("meta", this.header), compressedMeta)];
    }

    _mutNextState_meta_fromSubHashState(nxtState, subHashState) {
        const hasMeta = this._mutNextState_meta_fromSubHashState_mutGetHasMeta(nxtState, subHashState, this.getDefaultMeta());
        if (!hasMeta)
            this._mutNextState_resetBase(nxtState);
    }

    _mutNextState_meta_fromSubHashState_mutGetHasMeta(nxtState, state, defaultMeta) {
        let hasMeta = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            if (prop !== "meta")
                return;

            hasMeta = true;
            const data = vals.map(v=>UrlUtil.mini.decompress(v));
            Object.keys(defaultMeta).forEach((k,i)=>{
                if (data[i] !== undefined)
                    nxtState[this.header].meta[k] = data[i];
                else
                    nxtState[this.header].meta[k] = defaultMeta[k];
            }
            );
        }
        );

        return hasMeta;
    }

    setBaseStateFromLoaded(toLoad) {
        Object.assign(this._meta, toLoad.meta);
    }

    getSubHashPrefix(prop, header) {
        if (FilterBase._SUB_HASH_PREFIXES[prop]) {
            const prefix = this._filterBox.getNamespacedHashKey(FilterBase._SUB_HASH_PREFIXES[prop]);
            return `${prefix}${header.toUrlified()}`;
        }
        throw new Error(`Unknown property "${prop}"`);
    }

    static getProp(prefix) {
        return Parser._parse_bToA(FilterBase._SUB_HASH_PREFIXES, prefix);
    }

    _getBtnMobToggleControls(wrpControls) {
        const btnMobToggleControls = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default mobile__visible ml-auto px-3 mr-2`,
            html: `<span class="glyphicon glyphicon-option-vertical"></span>`,
            click: ()=>this._meta.isMobileHeaderHidden = !this._meta.isMobileHeaderHidden,
        });
        const hkMobHeaderHidden = ()=>{
            btnMobToggleControls.toggleClass("active", !this._meta.isMobileHeaderHidden);
            wrpControls.toggleClass("mobile__hidden", !!this._meta.isMobileHeaderHidden);
        }
        ;
        this._addHook("meta", "isMobileHeaderHidden", hkMobHeaderHidden);
        hkMobHeaderHidden();

        return btnMobToggleControls;
    }

    getChildFilters() {
        return [];
    }
    getDefaultMeta() {
        return {
            ...FilterBase._DEFAULT_META
        };
    }

    isActive(vals) {
        vals = vals || this.getValues();
        return vals[this.header]._isActive;
    }

    _getCompressedMeta({isStripUiKeys=false}={}) {
        const defaultMeta = this.getDefaultMeta();
        const isAnyNotDefault = Object.keys(defaultMeta).some(k=>this._meta[k] !== defaultMeta[k]);
        if (!isAnyNotDefault)
            return null;

        let keys = Object.keys(defaultMeta);

        if (isStripUiKeys) {
            const popCount = Object.keys(FilterBase._DEFAULT_META).length;
            if (popCount)
                keys = keys.slice(0, -popCount);
        }

        while (keys.length && defaultMeta[keys.last()] === this._meta[keys.last()])
            keys.pop();

        return keys.map(k=>UrlUtil.mini.compress(this._meta[k] === undefined ? defaultMeta[k] : this._meta[k]));
    }

    $render() {
        throw new Error(`Unimplemented!`);
    }
    $renderMinis() {
        throw new Error(`Unimplemented!`);
    }
    getValues({nxtState=null}={}) {
        throw new Error(`Unimplemented!`);
    }
    _mutNextState_reset() {
        throw new Error(`Unimplemented!`);
    }
    update() {
        throw new Error(`Unimplemented!`);
    }
    toDisplay() {
        throw new Error(`Unimplemented!`);
    }
    addItem() {
        throw new Error(`Unimplemented!`);
    }
    getSaveableState() {
        throw new Error(`Unimplemented!`);
    }
    setStateFromLoaded() {
        throw new Error(`Unimplemented!`);
    }
    getSubHashes() {
        throw new Error(`Unimplemented!`);
    }
    getNextStateFromSubhashState() {
        throw new Error(`Unimplemented!`);
    }
    setFromValues() {
        throw new Error(`Unimplemented!`);
    }
    handleSearch() {
        throw new Error(`Unimplemented`);
    }
    getFilterTagPart() {
        throw new Error(`Unimplemented`);
    }
    getDisplayStatePart({nxtState=null}={}) {
        throw new Error(`Unimplemented`);
    }
    _doTeardown() {}
    trimState_() {}
}
FilterBase._DEFAULT_META = {
    isHidden: false,
    isMobileHeaderHidden: true,
};
FilterBase._SUB_HASH_STATE_PREFIX = "flst";
FilterBase._SUB_HASH_META_PREFIX = "flmt";
FilterBase._SUB_HASH_NESTS_HIDDEN_PREFIX = "flnh";
FilterBase._SUB_HASH_OPTIONS_PREFIX = "flop";
FilterBase._SUB_HASH_PREFIXES = {
    state: FilterBase._SUB_HASH_STATE_PREFIX,
    meta: FilterBase._SUB_HASH_META_PREFIX,
    nestsHidden: FilterBase._SUB_HASH_NESTS_HIDDEN_PREFIX,
    options: FilterBase._SUB_HASH_OPTIONS_PREFIX,
};

class Filter extends FilterBase {
    static _getAsFilterItems(items) {
        return items ? items.map(it=>it instanceof FilterItem$1 ? it : new FilterItem$1({
            item: it
        })) : null;
    }

    static _validateItemNests(items, nests) {
        if (!nests)
            return;
        items = items.filter(it=>it.nest);
        const noNest = items.find(it=>!nests[it.nest]);
        if (noNest)
            throw new Error(`Filter does not have matching nest: "${noNest.item}" (call addNest first)`);
        const invalid = items.find(it=>!it.nest || !nests[it.nest]);
        if (invalid)
            throw new Error(`Invalid nest: "${invalid.item}"`);
    }

    static _validateItemNest(item, nests) {
        if (!nests || !item.nest)
            return;
        if (!nests[item.nest])
            throw new Error(`Filter does not have matching nest: "${item.item}" (call addNest first)`);
        if (!item.nest || !nests[item.nest])
            throw new Error(`Invalid nest: "${item.item}"`);
    }

    constructor(opts) {
        super(opts);
        this._items = Filter._getAsFilterItems(opts.items || []);
        this.__itemsSet = new Set(this._items.map(it=>it.item));
        this._nests = opts.nests;
        this._displayFn = opts.displayFn;
        this._displayFnMini = opts.displayFnMini;
        this._displayFnTitle = opts.displayFnTitle;
        this._selFn = opts.selFn;
        this._selFnCache = null;
        this._deselFn = opts.deselFn;
        this._itemSortFn = opts.itemSortFn === undefined ? SortUtil.ascSort : opts.itemSortFn;
        this._itemSortFnMini = opts.itemSortFnMini;
        this._groupFn = opts.groupFn;
        this._minimalUi = opts.minimalUi;
        this._umbrellaItems = Filter._getAsFilterItems(opts.umbrellaItems);
        this._umbrellaExcludes = Filter._getAsFilterItems(opts.umbrellaExcludes);
        this._isSortByDisplayItems = !!opts.isSortByDisplayItems;
        this._isReprintedFilter = !!opts.isMiscFilter && this._items.some(it=>it.item === "Reprinted");
        this._isSrdFilter = !!opts.isMiscFilter && this._items.some(it=>it.item === "SRD");
        this._isBasicRulesFilter = !!opts.isMiscFilter && this._items.some(it=>it.item === "Basic Rules");

        Filter._validateItemNests(this._items, this._nests);

        this._filterBox = null;
        this._items.forEach(it=>this._defaultItemState(it, {
            isForce: true
        }));
        this.__$wrpFilter = null;
        this.__wrpPills = null;
        this.__wrpMiniPills = null;
        this.__$wrpNestHeadInner = null;
        this._updateNestSummary = null;
        this.__nestsHidden = {};
        this._nestsHidden = this._getProxy("nestsHidden", this.__nestsHidden);
        this._isNestsDirty = false;
        this._isItemsDirty = false;
        this._pillGroupsMeta = {};
    }

    get isReprintedFilter() {
        return this._isReprintedFilter;
    }
    get isSrdFilter() {
        return this._isSrdFilter;
    }
    get isBasicRulesFilter() {
        return this._isBasicRulesFilter;
    }

    getSaveableState() {
        return {
            [this.header]: {
                ...this.getBaseSaveableState(),
                state: {
                    ...this.__state
                },
                nestsHidden: {
                    ...this.__nestsHidden
                },
            },
        };
    }

    setStateFromLoaded(filterState, {isUserSavedState=false}={}) {
        if (!filterState?.[this.header])
            return;

        const toLoad = filterState[this.header];
        this._hasUserSavedState = this._hasUserSavedState || isUserSavedState;
        this.setBaseStateFromLoaded(toLoad);
        Object.assign(this._state, toLoad.state);
        Object.assign(this._nestsHidden, toLoad.nestsHidden);
    }

    _getStateNotDefault({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        return Object.entries(state).filter(([k,v])=>{
            if (k.startsWith("_"))
                return false;
            const defState = this._getDefaultState(k);
            return defState !== v;
        }
        );
    }

    getSubHashes() {
        const out = [];

        const baseMeta = this.getMetaSubHashes();
        if (baseMeta)
            out.push(...baseMeta);

        const areNotDefaultState = this._getStateNotDefault();
        if (areNotDefaultState.length) {
            const serPillStates = areNotDefaultState.map(([k,v])=>`${k.toUrlified()}=${v}`);
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serPillStates));
        }

        const areNotDefaultNestsHidden = Object.entries(this._nestsHidden).filter(([k,v])=>this._nests[k] && !(this._nests[k].isHidden === v));
        if (areNotDefaultNestsHidden.length) {
            const nestsHidden = areNotDefaultNestsHidden.map(([k])=>`${k.toUrlified()}=1`);
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("nestsHidden", this.header), nestsHidden));
        }

        if (!out.length)
            return null;

        out.push(UrlUtil.packSubHash(this.getSubHashPrefix("options", this.header), ["extend"]));
        return out;
    }

    getFilterTagPart() {
        const areNotDefaultState = this._getStateNotDefault();
        const compressedMeta = this._getCompressedMeta({
            isStripUiKeys: true
        });

        if (!areNotDefaultState.length && !compressedMeta)
            return null;

        const pt = Object.entries(this._state).filter(([k])=>!k.startsWith("_")).filter(([,v])=>v).map(([k,v])=>`${v === 2 ? "!" : ""}${k}`).join(";").toLowerCase();

        return [this.header.toLowerCase(), pt, compressedMeta ? compressedMeta.join(HASH_SUB_LIST_SEP) : null, ].filter(it=>it != null).join("=");
    }

    getDisplayStatePart({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        const areNotDefaultState = this._getStateNotDefault({
            nxtState
        });

        if (!areNotDefaultState.length)
            return null;

        const ptState = Object.entries(state).filter(([k])=>!k.startsWith("_")).filter(([,v])=>v).map(([k,v])=>{
            const item = this._items.find(item=>`${item.item}` === k);
            if (!item)
                return null;
            return `${v === 2 ? "not " : ""}${this._displayFn ? this._displayFn(item.item, item) : item.item}`;
        }
        ).filter(Boolean).join(", ");

        if (!ptState)
            return null;

        return `${this.header}: ${ptState}`;
    }

    _getOptionsFromSubHashState(state) {
        const opts = {};
        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            switch (prop) {
            case "options":
                {
                    vals.forEach(val=>{
                        switch (val) {
                        case "extend":
                            {
                                opts.isExtendDefaultState = true;
                            }
                        }
                    }
                    );
                }
            }
        }
        );
        return new FilterTransientOptions(opts);
    }

    setStateFromNextState(nxtState) {
        super.setStateFromNextState(nxtState);
        this._proxyAssignSimple("nestsHidden", nxtState[this.header].nestsHidden, true);
    }

    getNextStateFromSubhashState(state) {
        const nxtState = this._getNextState_base();

        if (state == null) {
            this._mutNextState_reset(nxtState);
            return nxtState;
        }

        this._mutNextState_meta_fromSubHashState(nxtState, state);
        const transientOptions = this._getOptionsFromSubHashState(state);

        let hasState = false;
        let hasNestsHidden = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            switch (prop) {
            case "state":
                {
                    hasState = true;
                    if (transientOptions.isExtendDefaultState) {
                        Object.keys(nxtState[this.header].state).forEach(k=>nxtState[this.header].state[k] = this._getDefaultState(k));
                    } else {
                        Object.keys(nxtState[this.header].state).forEach(k=>nxtState[this.header].state[k] = 0);
                    }

                    vals.forEach(v=>{
                        const [statePropLower,state] = v.split("=");
                        const stateProp = Object.keys(nxtState[this.header].state).find(k=>k.toLowerCase() === statePropLower);
                        if (stateProp)
                            nxtState[this.header].state[stateProp] = Number(state);
                    }
                    );
                    break;
                }
            case "nestsHidden":
                {
                    hasNestsHidden = true;
                    Object.keys(nxtState[this.header].nestsHidden).forEach(k=>{
                        const nestKey = Object.keys(this._nests).find(it=>k.toLowerCase() === it.toLowerCase());
                        nxtState[this.header].nestsHidden[k] = this._nests[nestKey] && this._nests[nestKey].isHidden;
                    }
                    );
                    vals.forEach(v=>{
                        const [nestNameLower,state] = v.split("=");
                        const nestName = Object.keys(nxtState[this.header].nestsHidden).find(k=>k.toLowerCase() === nestNameLower);
                        if (nestName)
                            nxtState[this.header].nestsHidden[nestName] = !!Number(state);
                    }
                    );
                    break;
                }
            }
        }
        );

        if (!hasState)
            this._mutNextState_reset(nxtState);
        if (!hasNestsHidden && this._nests)
            this._mutNextState_resetNestsHidden({
                tgt: nxtState[this.header].nestsHidden
            });

        return nxtState;
    }

    setFromValues(values) {
        if (values[this.header]) {
            Object.keys(this._state).forEach(k=>this._state[k] = 0);
            Object.assign(this._state, values[this.header]);
        }
    }

    setValue(k, v) {
        this._state[k] = v;
    }

    _mutNextState_resetNestsHidden({tgt}) {
        if (!this._nests)
            return;
        Object.entries(this._nests).forEach(([nestName,nestMeta])=>tgt[nestName] = !!nestMeta.isHidden);
    }

    _defaultItemState(item, {isForce=false}={}) {
        if (!isForce && this._hasUserSavedState)
            return this._state[item.item] = 0;

        this._state[item.item] = this._getDefaultState(item.item);
    }

    _getDefaultState(k) {
        return this._deselFn && this._deselFn(k) ? 2 : this._selFn && this._selFn(k) ? 1 : 0;
    }

    _getDisplayText(item) {
        return this._displayFn ? this._displayFn(item.item, item) : item.item;
    }

    _getDisplayTextMini(item) {
        return this._displayFnMini ? this._displayFnMini(item.item, item) : this._getDisplayText(item);
    }

    _getPill(item) {
        const displayText = this._getDisplayText(item);

        const btnPill = e_({
            tag: "div",
            clazz: "fltr__pill",
            html: displayText,
            click: evt=>this._getPill_handleClick({
                evt,
                item
            }),
            contextmenu: evt=>this._getPill_handleContextmenu({
                evt,
                item
            }),
        });

        this._getPill_bindHookState({
            btnPill,
            item
        });

        item.searchText = displayText.toLowerCase();

        return btnPill;
    }

    _getPill_handleClick({evt, item}) {
        if (evt.shiftKey) {
            this._doSetPillsClear();
        }

        if (++this._state[item.item] > 2)
            this._state[item.item] = 0;
    }

    _getPill_handleContextmenu({evt, item}) {
        evt.preventDefault();

        if (evt.shiftKey) {
            this._doSetPillsClear();
        }

        if (--this._state[item.item] < 0)
            this._state[item.item] = 2;
    }

    _getPill_bindHookState({btnPill, item}) {
        this._addHook("state", item.item, ()=>{
            const val = FilterBox$1._PILL_STATES[this._state[item.item]];
            btnPill.attr("state", val);
        }
        )();
    }

    setTempFnSel(tempFnSel) {
        this._selFnCache = this._selFnCache || this._selFn;
        if (tempFnSel)
            this._selFn = tempFnSel;
        else
            this._selFn = this._selFnCache;
    }

    updateMiniPillClasses() {
        this._items.filter(it=>it.btnMini).forEach(it=>{
            const isDefaultDesel = this._deselFn && this._deselFn(it.item);
            const isDefaultSel = this._selFn && this._selFn(it.item);
            it.btnMini.toggleClass("fltr__mini-pill--default-desel", isDefaultDesel).toggleClass("fltr__mini-pill--default-sel", isDefaultSel);
        }
        );
    }

    _getBtnMini(item) {
        const toDisplay = this._getDisplayTextMini(item);

        const btnMini = e_({
            tag: "div",
            clazz: `fltr__mini-pill ${this._filterBox.isMinisHidden(this.header) ? "ve-hidden" : ""} ${this._deselFn && this._deselFn(item.item) ? "fltr__mini-pill--default-desel" : ""} ${this._selFn && this._selFn(item.item) ? "fltr__mini-pill--default-sel" : ""}`,
            html: toDisplay,
            title: `${this._displayFnTitle ? `${this._displayFnTitle(item.item, item)} (` : ""}Filter: ${this.header}${this._displayFnTitle ? ")" : ""}`,
            click: ()=>{
                this._state[item.item] = 0;
                this._filterBox.fireChangeEvent();
            }
            ,
        }).attr("state", FilterBox$1._PILL_STATES[this._state[item.item]]);

        const hook = ()=>{
            const val = FilterBox$1._PILL_STATES[this._state[item.item]];
            btnMini.attr("state", val);
            if (item.pFnChange)
                item.pFnChange(item.item, val);
        }
        ;
        this._addHook("state", item.item, hook);

        const hideHook = ()=>btnMini.toggleClass("ve-hidden", this._filterBox.isMinisHidden(this.header));
        this._filterBox.registerMinisHiddenHook(this.header, hideHook);

        return btnMini;
    }

    _doSetPillsAll() {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: 1
        })), true, );
    }

    _doSetPillsClear() {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: 0
        })), true, );
    }

    _doSetPillsNone() {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: 2
        })), true, );
    }

    _doSetPinsDefault() {
        this.reset();
    }

    _getHeaderControls(opts) {
        const btnAll = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--all w-100`,
            click: ()=>this._doSetPillsAll(),
            html: "All",
        });
        const btnClear = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--clear w-100`,
            click: ()=>this._doSetPillsClear(),
            html: "Clear",
        });
        const btnNone = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--none w-100`,
            click: ()=>this._doSetPillsNone(),
            html: "None",
        });
        const btnDefault = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} w-100`,
            click: ()=>this._doSetPinsDefault(),
            html: "Default",
        });

        const wrpStateBtnsOuter = e_({
            tag: "div",
            clazz: "ve-flex-v-center fltr__h-wrp-state-btns-outer",
            children: [e_({
                tag: "div",
                clazz: "btn-group ve-flex-v-center w-100",
                children: [btnAll, btnClear, btnNone, btnDefault, ],
            }), ],
        });
        this._getHeaderControls_addExtraStateBtns(opts, wrpStateBtnsOuter);

        const wrpSummary = e_({
            tag: "div",
            clazz: "ve-flex-vh-center ve-hidden"
        });

        const btnCombineBlue = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn-logic--blue fltr__h-btn-logic w-100`,
            click: ()=>this._meta.combineBlue = Filter._getNextCombineMode(this._meta.combineBlue),
            title: `Blue match mode for this filter. "AND" requires all blues to match, "OR" requires at least one blue to match, "XOR" requires exactly one blue to match.`,
        });
        const hookCombineBlue = ()=>e_({
            ele: btnCombineBlue,
            text: `${this._meta.combineBlue}`.toUpperCase()
        });
        this._addHook("meta", "combineBlue", hookCombineBlue);
        hookCombineBlue();

        const btnCombineRed = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn-logic--red fltr__h-btn-logic w-100`,
            click: ()=>this._meta.combineRed = Filter._getNextCombineMode(this._meta.combineRed),
            title: `Red match mode for this filter. "AND" requires all reds to match, "OR" requires at least one red to match, "XOR" requires exactly one red to match.`,
        });
        const hookCombineRed = ()=>e_({
            ele: btnCombineRed,
            text: `${this._meta.combineRed}`.toUpperCase()
        });
        this._addHook("meta", "combineRed", hookCombineRed);
        hookCombineRed();

        const btnShowHide = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} ml-2`,
            click: ()=>this._meta.isHidden = !this._meta.isHidden,
            html: "Hide",
        });
        const hookShowHide = ()=>{
            e_({
                ele: btnShowHide
            }).toggleClass("active", this._meta.isHidden);
            wrpStateBtnsOuter.toggleVe(!this._meta.isHidden);

            const cur = this.getValues()[this.header];

            const htmlSummary = [cur._totals.yes ? `<span class="fltr__summary_item fltr__summary_item--include" title="${cur._totals.yes} hidden &quot;required&quot; tags">${cur._totals.yes}</span>` : null, cur._totals.yes && cur._totals.no ? `<span class="fltr__summary_item_spacer"></span>` : null, cur._totals.no ? `<span class="fltr__summary_item fltr__summary_item--exclude" title="${cur._totals.no} hidden &quot;excluded&quot; tags">${cur._totals.no}</span>` : null, ].filter(Boolean).join("");
            e_({
                ele: wrpSummary,
                html: htmlSummary
            }).toggleVe(this._meta.isHidden);
        }
        ;
        this._addHook("meta", "isHidden", hookShowHide);
        hookShowHide();

        return e_({
            tag: "div",
            clazz: `ve-flex-v-center fltr__h-wrp-btns-outer`,
            children: [wrpSummary, wrpStateBtnsOuter, e_({
                tag: "span",
                clazz: `btn-group ml-2 ve-flex-v-center`,
                children: [btnCombineBlue, btnCombineRed]
            }), btnShowHide, ],
        });
    }

    _getHeaderControls_addExtraStateBtns() {}

    $render(opts) {
        this._filterBox = opts.filterBox;
        this.__wrpMiniPills = opts.$wrpMini ? e_({
            ele: opts.$wrpMini[0]
        }) : null;

        const wrpControls = this._getHeaderControls(opts);

        if (this._nests) {
            const wrpNestHead = e_({
                tag: "div",
                clazz: "fltr__wrp-pills--sub"
            }).appendTo(this.__wrpPills);
            this.__$wrpNestHeadInner = e_({
                tag: "div",
                clazz: "ve-flex ve-flex-wrap fltr__container-pills"
            }).appendTo(wrpNestHead);

            const wrpNestHeadSummary = e_({
                tag: "div",
                clazz: "fltr__summary_nest"
            }).appendTo(wrpNestHead);

            this._updateNestSummary = ()=>{
                const stats = {
                    high: 0,
                    low: 0
                };
                this._items.filter(it=>this._state[it.item] && this._nestsHidden[it.nest]).forEach(it=>{
                    const key = this._state[it.item] === 1 ? "high" : "low";
                    stats[key]++;
                }
                );

                wrpNestHeadSummary.empty();

                if (stats.high) {
                    e_({
                        tag: "span",
                        clazz: "fltr__summary_item fltr__summary_item--include",
                        text: stats.high,
                        title: `${stats.high} hidden "required" tag${stats.high === 1 ? "" : "s"}`,
                    }).appendTo(wrpNestHeadSummary);
                }

                if (stats.high && stats.low)
                    e_({
                        tag: "span",
                        clazz: "fltr__summary_item_spacer"
                    }).appendTo(wrpNestHeadSummary);

                if (stats.low) {
                    e_({
                        tag: "span",
                        clazz: "fltr__summary_item fltr__summary_item--exclude",
                        text: stats.low,
                        title: `${stats.low} hidden "excluded" tag${stats.low === 1 ? "" : "s"}`,
                    }).appendTo(wrpNestHeadSummary);
                }
            }
            ;

            this._doRenderNests();
        }

        this._doRenderPills();

        const btnMobToggleControls = this._getBtnMobToggleControls(wrpControls);

        this.__$wrpFilter = $$`<div>
			${opts.isFirst ? "" : `<div class="fltr__dropdown-divider ${opts.isMulti ? "fltr__dropdown-divider--indented" : ""} mb-1"></div>`}
			<div class="split fltr__h ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
				<div class="fltr__h-text ve-flex-h-center mobile__w-100">
					${opts.isMulti ? `<span class="mr-2">\u2012</span>` : ""}
					${this._getRenderedHeader()}
					${btnMobToggleControls}
				</div>
				${wrpControls}
			</div>
			${this.__wrpPills}
		</div>`;

        this._doToggleDisplay();

        return this.__$wrpFilter;
    }

    $renderMinis(opts) {
        if (!opts.$wrpMini)
            return;

        this._filterBox = opts.filterBox;
        this.__wrpMiniPills = e_({
            ele: opts.$wrpMini[0]
        });

        this._renderMinis_initWrpPills();

        this._doRenderMiniPills();
    }

    _renderMinis_initWrpPills() {
        this.__wrpPills = e_({
            tag: "div",
            clazz: `fltr__wrp-pills ${this._groupFn ? "fltr__wrp-subs" : "fltr__container-pills"}`
        });
        const hook = ()=>this.__wrpPills.toggleVe(!this._meta.isHidden);
        this._addHook("meta", "isHidden", hook);
        hook();
    }

    getValues({nxtState=null}={}) {
        const state = MiscUtil.copy(nxtState?.[this.header]?.state || this.__state);
        const meta = nxtState?.[this.header]?.meta || this.__meta;

        Object.keys(state).filter(k=>!this._items.some(it=>`${it.item}` === k)).forEach(k=>delete state[k]);
        const out = {
            ...state
        };

        out._isActive = Object.values(state).some(Boolean);
        out._totals = {
            yes: 0,
            no: 0,
            ignored: 0
        };
        Object.values(state).forEach(v=>{
            const totalKey = v === 0 ? "ignored" : v === 1 ? "yes" : "no";
            out._totals[totalKey]++;
        }
        );
        out._combineBlue = meta.combineBlue;
        out._combineRed = meta.combineRed;
        return {
            [this.header]: out
        };
    }

    _getNextState_base() {
        return {
            [this.header]: {
                ...super._getNextState_base()[this.header],
                nestsHidden: MiscUtil.copyFast(this.__nestsHidden),
            },
        };
    }

    _mutNextState_reset(nxtState, {isResetAll=false}={}) {
        if (isResetAll) {
            this._mutNextState_resetBase(nxtState);
            this._mutNextState_resetNestsHidden({
                tgt: nxtState[this.header].nestsHidden
            });
        } else {
            Object.assign(nxtState[this.header].meta, {
                combineBlue: Filter._DEFAULT_META.combineBlue,
                combineRed: Filter._DEFAULT_META.combineRed
            });
        }
        Object.keys(nxtState[this.header].state).forEach(k=>delete nxtState[this.header].state[k]);
        this._items.forEach(item=>nxtState[this.header].state[item.item] = this._getDefaultState(item.item));
    }

    _doRenderPills() {
        if (this._itemSortFn)
            this._items.sort(this._isSortByDisplayItems && this._displayFn ? (a,b)=>this._itemSortFn(this._displayFn(a.item, a), this._displayFn(b.item, b)) : this._itemSortFn);

        this._items.forEach(it=>{
            if (!it.rendered) {
                it.rendered = this._getPill(it);
                if (it.nest) {
                    const hook = ()=>it.rendered.toggleVe(!this._nestsHidden[it.nest]);
                    this._addHook("nestsHidden", it.nest, hook);
                    hook();
                }
            }

            if (this._groupFn) {
                const group = this._groupFn(it);
                this._doRenderPills_doRenderWrpGroup(group);
                this._pillGroupsMeta[group].wrpPills.append(it.rendered);
            } else
                it.rendered.appendTo(this.__wrpPills);
        }
        );
    }

    _doRenderPills_doRenderWrpGroup(group) {
        const existingMeta = this._pillGroupsMeta[group];
        if (existingMeta && !existingMeta.isAttached) {
            existingMeta.hrDivider.appendTo(this.__wrpPills);
            existingMeta.wrpPills.appendTo(this.__wrpPills);
            existingMeta.isAttached = true;
        }
        if (existingMeta)
            return;

        this._pillGroupsMeta[group] = {
            hrDivider: this._doRenderPills_doRenderWrpGroup_getHrDivider(group).appendTo(this.__wrpPills),
            wrpPills: this._doRenderPills_doRenderWrpGroup_getWrpPillsSub(group).appendTo(this.__wrpPills),
            isAttached: true,
        };

        Object.entries(this._pillGroupsMeta).sort((a,b)=>SortUtil.ascSortLower(a[0], b[0])).forEach(([groupKey,groupMeta],i)=>{
            groupMeta.hrDivider.appendTo(this.__wrpPills);
            groupMeta.hrDivider.toggleVe(!this._isGroupDividerHidden(groupKey, i));
            groupMeta.wrpPills.appendTo(this.__wrpPills);
        }
        );

        if (this._nests) {
            this._pillGroupsMeta[group].toggleDividerFromNestVisibility = ()=>{
                this._pillGroupsMeta[group].hrDivider.toggleVe(!this._isGroupDividerHidden(group));
            }
            ;

            Object.keys(this._nests).forEach(nestName=>{
                const hook = ()=>this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
                this._addHook("nestsHidden", nestName, hook);
                hook();
                this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
            }
            );
        }
    }

    _isGroupDividerHidden(group, ixSortedGroups) {
        if (!this._nests) {
            if (ixSortedGroups === undefined)
                return `${group}` === `${Object.keys(this._pillGroupsMeta).sort((a,b)=>SortUtil.ascSortLower(a, b))[0]}`;
            return ixSortedGroups === 0;
        }

        const groupItems = this._items.filter(it=>this._groupFn(it) === group);
        const hiddenGroupItems = groupItems.filter(it=>this._nestsHidden[it.nest]);
        return groupItems.length === hiddenGroupItems.length;
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider() {
        return e_({
            tag: "hr",
            clazz: `fltr__dropdown-divider--sub hr-2 mx-3`
        });
    }
    _doRenderPills_doRenderWrpGroup_getWrpPillsSub() {
        return e_({
            tag: "div",
            clazz: `fltr__wrp-pills--sub fltr__container-pills`
        });
    }

    _doRenderMiniPills() {
        const view = this._items.slice(0);
        if (this._itemSortFnMini || this._itemSortFn) {
            const fnSort = this._itemSortFnMini || this._itemSortFn;
            view.sort(this._isSortByDisplayItems && this._displayFn ? (a,b)=>fnSort(this._displayFn(a.item, a), this._displayFn(b.item, b)) : fnSort);
        }

        if (this.__wrpMiniPills) {
            view.forEach(it=>{
                (it.btnMini = it.btnMini || this._getBtnMini(it)).appendTo(this.__wrpMiniPills);
            }
            );
        }
    }

    _doToggleDisplay() {
        if (this.__$wrpFilter)
            this.__$wrpFilter.toggleClass("fltr__no-items", !this._items.length);
    }

    _doRenderNests() {
        Object.entries(this._nests).sort((a,b)=>SortUtil.ascSort(a[0], b[0])).forEach(([nestName,nestMeta])=>{
            if (nestMeta._$btnNest == null) {
                if (this._nestsHidden[nestName] == null)
                    this._nestsHidden[nestName] = !!nestMeta.isHidden;

                const $btnText = $(`<span>${nestName} [${this._nestsHidden[nestName] ? "+" : "\u2212"}]</span>`);
                nestMeta._$btnNest = $$`<div class="fltr__btn_nest">${$btnText}</div>`.click(()=>this._nestsHidden[nestName] = !this._nestsHidden[nestName]);

                const hook = ()=>{
                    $btnText.text(`${nestName} [${this._nestsHidden[nestName] ? "+" : "\u2212"}]`);

                    const stats = {
                        high: 0,
                        low: 0,
                        total: 0
                    };
                    this._items.filter(it=>it.nest === nestName).find(it=>{
                        const key = this._state[it.item] === 1 ? "high" : this._state[it.item] ? "low" : "ignored";
                        stats[key]++;
                        stats.total++;
                    }
                    );
                    const allHigh = stats.total === stats.high;
                    const allLow = stats.total === stats.low;
                    nestMeta._$btnNest.toggleClass("fltr__btn_nest--include-all", this._nestsHidden[nestName] && allHigh).toggleClass("fltr__btn_nest--exclude-all", this._nestsHidden[nestName] && allLow).toggleClass("fltr__btn_nest--include", this._nestsHidden[nestName] && !!(!allHigh && !allLow && stats.high && !stats.low)).toggleClass("fltr__btn_nest--exclude", this._nestsHidden[nestName] && !!(!allHigh && !allLow && !stats.high && stats.low)).toggleClass("fltr__btn_nest--both", this._nestsHidden[nestName] && !!(!allHigh && !allLow && stats.high && stats.low));

                    if (this._updateNestSummary)
                        this._updateNestSummary();
                }
                ;

                this._items.filter(it=>it.nest === nestName).find(it=>{
                    this._addHook("state", it.item, hook);
                }
                );

                this._addHook("nestsHidden", nestName, hook);
                hook();
            }
            nestMeta._$btnNest.appendTo(this.__$wrpNestHeadInner);
        }
        );

        if (this._updateNestSummary)
            this._updateNestSummary();
    }

    update() {
        if (this._isNestsDirty) {
            this._isNestsDirty = false;

            this._doRenderNests();
        }

        if (this._isItemsDirty) {
            this._isItemsDirty = false;

            this._doRenderPills();
        }

        this._doRenderMiniPills();
        this._doToggleDisplay();
    }

    addItem(item) {
        if (item == null)
            return;

        if (item instanceof Array) {
            const len = item.length;
            for (let i = 0; i < len; ++i)
                this.addItem(item[i]);
            return;
        }

        if (!this.__itemsSet.has(item.item || item)) {
            item = item instanceof FilterItem$1 ? item : new FilterItem$1({
                item
            });
            Filter._validateItemNest(item, this._nests);

            this._isItemsDirty = true;
            this._items.push(item);
            this.__itemsSet.add(item.item);
            if (this._state[item.item] == null)
                this._defaultItemState(item);
        }
    }

    static _isItemsEqual(item1, item2) {
        return (item1 instanceof FilterItem$1 ? item1.item : item1) === (item2 instanceof FilterItem$1 ? item2.item : item2);
    }

    removeItem(item) {
        const ixItem = this._items.findIndex(it=>Filter._isItemsEqual(it, item));
        if (~ixItem) {
            const item = this._items[ixItem];

            this._isItemsDirty = true;
            item.rendered.detach();
            item.btnMini.detach();
            this._items.splice(ixItem, 1);
        }
    }

    addNest(nestName, nestMeta) {
        if (!this._nests)
            throw new Error(`Filter was not nested!`);
        if (!this._nests[nestName]) {
            this._isNestsDirty = true;
            this._nests[nestName] = nestMeta;

            if (this._groupFn) {
                Object.keys(this._pillGroupsMeta).forEach(group=>{
                    const hook = ()=>this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
                    this._addHook("nestsHidden", nestName, hook);
                    hook();
                    this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
                }
                );
            }
        }
    }

    _toDisplay_getMappedEntryVal(entryVal) {
        if (!(entryVal instanceof Array))
            entryVal = [entryVal];
        entryVal = entryVal.map(it=>it instanceof FilterItem$1 ? it : new FilterItem$1({
            item: it
        }));
        return entryVal;
    }

    _toDisplay_getFilterState(boxState) {
        return boxState[this.header];
    }

    toDisplay(boxState, entryVal) {
        const filterState = this._toDisplay_getFilterState(boxState);
        if (!filterState)
            return true;

        const totals = filterState._totals;

        entryVal = this._toDisplay_getMappedEntryVal(entryVal);

        const isUmbrella = ()=>{
            if (this._umbrellaItems) {
                if (!entryVal)
                    return false;

                if (this._umbrellaExcludes && this._umbrellaExcludes.some(it=>filterState[it.item]))
                    return false;

                return this._umbrellaItems.some(u=>entryVal.includes(u.item)) && (this._umbrellaItems.some(u=>filterState[u.item] === 0) || this._umbrellaItems.some(u=>filterState[u.item] === 1));
            }
        }
        ;

        let hide = false;
        let display = false;

        switch (filterState._combineBlue) {
        case "or":
            {
                if (totals.yes === 0)
                    display = true;

                display = display || entryVal.some(fi=>filterState[fi.item] === 1 || isUmbrella());

                break;
            }
        case "xor":
            {
                if (totals.yes === 0)
                    display = true;

                display = display || entryVal.filter(fi=>filterState[fi.item] === 1 || isUmbrella()).length === 1;

                break;
            }
        case "and":
            {
                const totalYes = entryVal.filter(fi=>filterState[fi.item] === 1).length;
                display = !totals.yes || totals.yes === totalYes;

                break;
            }
        default:
            throw new Error(`Unhandled combine mode "${filterState._combineBlue}"`);
        }

        switch (filterState._combineRed) {
        case "or":
            {
                hide = hide || entryVal.filter(fi=>!fi.isIgnoreRed).some(fi=>filterState[fi.item] === 2);

                break;
            }
        case "xor":
            {
                hide = hide || entryVal.filter(fi=>!fi.isIgnoreRed).filter(fi=>filterState[fi.item] === 2).length === 1;

                break;
            }
        case "and":
            {
                const totalNo = entryVal.filter(fi=>!fi.isIgnoreRed).filter(fi=>filterState[fi.item] === 2).length;
                hide = totals.no && totals.no === totalNo;

                break;
            }
        default:
            throw new Error(`Unhandled combine mode "${filterState._combineRed}"`);
        }

        return display && !hide;
    }

    _doInvertPins() {
        const cur = MiscUtil.copy(this._state);
        Object.keys(this._state).forEach(k=>this._state[k] = cur[k] === 1 ? 0 : 1);
    }

    getDefaultMeta() {
        return {
            ...super.getDefaultMeta(),
            ...Filter._DEFAULT_META,
        };
    }

    handleSearch(searchTerm) {
        const isHeaderMatch = this.header.toLowerCase().includes(searchTerm);

        if (isHeaderMatch) {
            this._items.forEach(it=>{
                if (!it.rendered)
                    return;
                it.rendered.toggleClass("fltr__hidden--search", false);
            }
            );

            if (this.__$wrpFilter)
                this.__$wrpFilter.toggleClass("fltr__hidden--search", false);

            return true;
        }

        let visibleCount = 0;
        this._items.forEach(it=>{
            if (!it.rendered)
                return;
            const isVisible = it.searchText.includes(searchTerm);
            it.rendered.toggleClass("fltr__hidden--search", !isVisible);
            if (isVisible)
                visibleCount++;
        }
        );

        if (this.__$wrpFilter)
            this.__$wrpFilter.toggleClass("fltr__hidden--search", visibleCount === 0);

        return visibleCount !== 0;
    }

    static _getNextCombineMode(combineMode) {
        let ix = Filter._COMBINE_MODES.indexOf(combineMode);
        if (ix === -1)
            ix = (Filter._COMBINE_MODES.length - 1);
        if (++ix === Filter._COMBINE_MODES.length)
            ix = 0;
        return Filter._COMBINE_MODES[ix];
    }

    _doTeardown() {
        this._items.forEach(it=>{
            if (it.rendered)
                it.rendered.detach();
            if (it.btnMini)
                it.btnMini.detach();
        }
        );

        Object.values(this._nests || {}).filter(nestMeta=>nestMeta._$btnNest).forEach(nestMeta=>nestMeta._$btnNest.detach());

        Object.values(this._pillGroupsMeta || {}).forEach(it=>{
            it.hrDivider.detach();
            it.wrpPills.detach();
            it.isAttached = false;
        }
        );
    }
}
_DEFAULT_META = {
    combineBlue: "or",
    combineRed: "or",
};
_COMBINE_MODES = ["or", "and", "xor"];

let SourceFilter = class SourceFilter extends Filter {
    static _SORT_ITEMS_MINI(a, b) {
        a = a.item ?? a;
        b = b.item ?? b;
        const valA = BrewUtil2.hasSourceJson(a) ? 2 : (SourceUtil.isNonstandardSource(a) || PrereleaseUtil.hasSourceJson(a)) ? 1 : 0;
        const valB = BrewUtil2.hasSourceJson(b) ? 2 : (SourceUtil.isNonstandardSource(b) || PrereleaseUtil.hasSourceJson(b)) ? 1 : 0;
        return SortUtil.ascSort(valA, valB) || SortUtil.ascSortLower(Parser.sourceJsonToFull(a), Parser.sourceJsonToFull(b));
    }

    static _getDisplayHtmlMini(item) {
        item = item.item || item;
        const isBrewSource = BrewUtil2.hasSourceJson(item);
        const isNonStandardSource = !isBrewSource && (SourceUtil.isNonstandardSource(item) || PrereleaseUtil.hasSourceJson(item));
        return `<span ${isBrewSource ? `title="(Homebrew)"` : isNonStandardSource ? `title="(UA/Etc.)"` : ""} class="glyphicon ${isBrewSource ? `glyphicon-glass` : isNonStandardSource ? `glyphicon-file` : `glyphicon-book`}"></span> ${Parser.sourceJsonToAbv(item)}`;
    }

    constructor(opts) {
        opts = opts || {};

        opts.header = opts.header === undefined ? FilterBox$1.SOURCE_HEADER : opts.header;
        opts.displayFn = opts.displayFn === undefined ? item=>Parser.sourceJsonToFullCompactPrefix(item.item || item) : opts.displayFn;
        opts.displayFnMini = opts.displayFnMini === undefined ? SourceFilter._getDisplayHtmlMini.bind(SourceFilter) : opts.displayFnMini;
        opts.displayFnTitle = opts.displayFnTitle === undefined ? item=>Parser.sourceJsonToFull(item.item || item) : opts.displayFnTitle;
        opts.itemSortFnMini = opts.itemSortFnMini === undefined ? SourceFilter._SORT_ITEMS_MINI.bind(SourceFilter) : opts.itemSortFnMini;
        opts.itemSortFn = opts.itemSortFn === undefined ? (a,b)=>SortUtil.ascSortLower(Parser.sourceJsonToFull(a.item), Parser.sourceJsonToFull(b.item)) : opts.itemSortFn;
        opts.groupFn = opts.groupFn === undefined ? SourceUtil.getFilterGroup : opts.groupFn;
        opts.selFn = opts.selFn === undefined ? PageFilter.defaultSourceSelFn : opts.selFn;

        super(opts);

        this.__tmpState = {
            ixAdded: 0
        };
        this._tmpState = this._getProxy("tmpState", this.__tmpState);
    }

    doSetPillsClear() {
        return this._doSetPillsClear();
    }

    addItem(item) {
        const out = super.addItem(item);
        this._tmpState.ixAdded++;
        return out;
    }

    removeItem(item) {
        const out = super.removeItem(item);
        this._tmpState.ixAdded--;
        return out;
    }

    _getHeaderControls_addExtraStateBtns(opts, wrpStateBtnsOuter) {
        const btnSupplements = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection; CTRL to include UA/etc.`,
            html: `Core/Supplements`,
            click: evt=>this._doSetPinsSupplements({
                isIncludeUnofficial: EventUtil.isCtrlMetaKey(evt),
                isAdditive: evt.shiftKey
            }),
        });

        const btnAdventures = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection; CTRL to include UA`,
            html: `Adventures`,
            click: evt=>this._doSetPinsAdventures({
                isIncludeUnofficial: EventUtil.isCtrlMetaKey(evt),
                isAdditive: evt.shiftKey
            }),
        });

        const btnPartnered = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection`,
            html: `Partnered`,
            click: evt=>this._doSetPinsPartnered({
                isAdditive: evt.shiftKey
            }),
        });

        const btnHomebrew = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection`,
            html: `Homebrew`,
            click: evt=>this._doSetPinsHomebrew({
                isAdditive: evt.shiftKey
            }),
        });

        const hkIsButtonsActive = ()=>{
            const hasPartnered = Object.keys(this.__state).some(src=>SourceUtil.getFilterGroup(src) === SourceUtil.FILTER_GROUP_PARTNERED);
            btnPartnered.toggleClass("ve-hidden", !hasPartnered);

            const hasBrew = Object.keys(this.__state).some(src=>SourceUtil.getFilterGroup(src) === SourceUtil.FILTER_GROUP_HOMEBREW);
            btnHomebrew.toggleClass("ve-hidden", !hasBrew);
        }
        ;
        this._addHook("tmpState", "ixAdded", hkIsButtonsActive);
        hkIsButtonsActive();

        const actionSelectDisplayMode = new ContextUtil.ActionSelect({
            values: Object.keys(SourceFilter._PILL_DISPLAY_MODE_LABELS).map(Number),
            fnGetDisplayValue: val=>SourceFilter._PILL_DISPLAY_MODE_LABELS[val] || SourceFilter._PILL_DISPLAY_MODE_LABELS[0],
            fnOnChange: val=>this._meta.pillDisplayMode = val,
        });
        this._addHook("meta", "pillDisplayMode", ()=>{
            actionSelectDisplayMode.setValue(this._meta.pillDisplayMode);
        }
        )();

        const menu = ContextUtil.getMenu([new ContextUtil.Action("Select All Standard Sources",()=>this._doSetPinsStandard(),), new ContextUtil.Action("Select All Partnered Sources",()=>this._doSetPinsPartnered(),), new ContextUtil.Action("Select All Non-Standard Sources",()=>this._doSetPinsNonStandard(),), new ContextUtil.Action("Select All Homebrew Sources",()=>this._doSetPinsHomebrew(),), null, new ContextUtil.Action(`Select "Vanilla" Sources`,()=>this._doSetPinsVanilla(),{
            title: `Select a baseline set of sources suitable for any campaign.`
        },), new ContextUtil.Action("Select All Non-UA Sources",()=>this._doSetPinsNonUa(),), null, new ContextUtil.Action("Select SRD Sources",()=>this._doSetPinsSrd(),{
            title: `Select System Reference Document Sources.`
        },), new ContextUtil.Action("Select Basic Rules Sources",()=>this._doSetPinsBasicRules(),), null, new ContextUtil.Action("Invert Selection",()=>this._doInvertPins(),), null, actionSelectDisplayMode, ]);
        const btnBurger = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            html: `<span class="glyphicon glyphicon-option-vertical"></span>`,
            click: evt=>ContextUtil.pOpenMenu(evt, menu),
            title: "Other Options",
        });

        const btnOnlyPrimary = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            html: `Include References`,
            title: `Consider entities as belonging to every source they appear in (i.e. reprints) as well as their primary source`,
            click: ()=>this._meta.isIncludeOtherSources = !this._meta.isIncludeOtherSources,
        });
        const hkIsIncludeOtherSources = ()=>{
            btnOnlyPrimary.toggleClass("active", !!this._meta.isIncludeOtherSources);
        }
        ;
        hkIsIncludeOtherSources();
        this._addHook("meta", "isIncludeOtherSources", hkIsIncludeOtherSources);

        e_({
            tag: "div",
            clazz: `btn-group mr-2 w-100 ve-flex-v-center mobile__m-1 mobile__mb-2`,
            children: [btnSupplements, btnAdventures, btnPartnered, btnHomebrew, btnBurger, btnOnlyPrimary, ],
        }).prependTo(wrpStateBtnsOuter);
    }

    _doSetPinsStandard() {
        Object.keys(this._state).forEach(k=>this._state[k] = SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_STANDARD ? 1 : 0);
    }

    _doSetPinsPartnered({isAdditive=false}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_PARTNERED ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsNonStandard() {
        Object.keys(this._state).forEach(k=>this._state[k] = SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_NON_STANDARD ? 1 : 0);
    }

    _doSetPinsSupplements({isIncludeUnofficial=false, isAdditive=false}={}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.isCoreOrSupplement(k) && (isIncludeUnofficial || !SourceUtil.isNonstandardSource(k)) ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsAdventures({isIncludeUnofficial=false, isAdditive=false}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.isAdventure(k) && (isIncludeUnofficial || !SourceUtil.isNonstandardSource(k)) ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsHomebrew({isAdditive=false}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_HOMEBREW ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsVanilla() {
        Object.keys(this._state).forEach(k=>this._state[k] = Parser.SOURCES_VANILLA.has(k) ? 1 : 0);
    }

    _doSetPinsNonUa() {
        Object.keys(this._state).forEach(k=>this._state[k] = !SourceUtil.isPrereleaseSource(k) ? 1 : 0);
    }

    _doSetPinsSrd() {
        SourceFilter._SRD_SOURCES = SourceFilter._SRD_SOURCES || new Set([Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG]);

        Object.keys(this._state).forEach(k=>this._state[k] = SourceFilter._SRD_SOURCES.has(k) ? 1 : 0);

        const srdFilter = this._filterBox.filters.find(it=>it.isSrdFilter);
        if (srdFilter)
            srdFilter.setValue("SRD", 1);

        const basicRulesFilter = this._filterBox.filters.find(it=>it.isBasicRulesFilter);
        if (basicRulesFilter)
            basicRulesFilter.setValue("Basic Rules", 0);

        const reprintedFilter = this._filterBox.filters.find(it=>it.isReprintedFilter);
        if (reprintedFilter)
            reprintedFilter.setValue("Reprinted", 0);
    }

    _doSetPinsBasicRules() {
        SourceFilter._BASIC_RULES_SOURCES = SourceFilter._BASIC_RULES_SOURCES || new Set([Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG]);

        Object.keys(this._state).forEach(k=>this._state[k] = SourceFilter._BASIC_RULES_SOURCES.has(k) ? 1 : 0);

        const basicRulesFilter = this._filterBox.filters.find(it=>it.isBasicRulesFilter);
        if (basicRulesFilter)
            basicRulesFilter.setValue("Basic Rules", 1);

        const srdFilter = this._filterBox.filters.find(it=>it.isSrdFilter);
        if (srdFilter)
            srdFilter.setValue("SRD", 0);

        const reprintedFilter = this._filterBox.filters.find(it=>it.isReprintedFilter);
        if (reprintedFilter)
            reprintedFilter.setValue("Reprinted", 0);
    }

    static getCompleteFilterSources(ent) {
        if (!ent.otherSources)
            return ent.source;

        const otherSourcesFilt = ent.otherSources.filter(src=>!ExcludeUtil.isExcluded("*", "*", src.source, {
            isNoCount: true
        }));
        if (!otherSourcesFilt.length)
            return ent.source;

        return [ent.source].concat(otherSourcesFilt.map(src=>new SourceFilterItem({
            item: src.source,
            isIgnoreRed: true,
            isOtherSource: true
        })));
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider(group) {
        switch (group) {
        case SourceUtil.FILTER_GROUP_NON_STANDARD:
            return this._doRenderPills_doRenderWrpGroup_getHrDivider_groupNonStandard(group);
        case SourceUtil.FILTER_GROUP_HOMEBREW:
            return this._doRenderPills_doRenderWrpGroup_getHrDivider_groupBrew(group);
        default:
            return super._doRenderPills_doRenderWrpGroup_getHrDivider(group);
        }
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider_groupNonStandard(group) {
        let dates = [];
        const comp = BaseComponent.fromObject({
            min: 0,
            max: 0,
            curMin: 0,
            curMax: 0,
        });

        const wrpSlider = new ComponentUiUtil.RangeSlider({
            comp,
            propMin: "min",
            propMax: "max",
            propCurMin: "curMin",
            propCurMax: "curMax",
            fnDisplay: val=>dates[val]?.str,
        }).get();

        const wrpWrpSlider = e_({
            tag: "div",
            clazz: `"w-100 ve-flex pt-2 pb-5 mb-2 mt-1 fltr-src__wrp-slider`,
            children: [wrpSlider, ],
        }).hideVe();

        const btnCancel = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default px-1`,
            html: "Cancel",
            click: ()=>{
                grpBtnsInactive.showVe();
                wrpWrpSlider.hideVe();
                grpBtnsActive.hideVe();
            }
            ,
        });

        const btnConfirm = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default px-1`,
            html: "Confirm",
            click: ()=>{
                grpBtnsInactive.showVe();
                wrpWrpSlider.hideVe();
                grpBtnsActive.hideVe();

                const min = comp._state.curMin;
                const max = comp._state.curMax;

                const allowedDateSet = new Set(dates.slice(min, max + 1).map(it=>it.str));
                const nxtState = {};
                Object.keys(this._state).filter(k=>SourceUtil.isNonstandardSource(k)).forEach(k=>{
                    const sourceDate = Parser.sourceJsonToDate(k);
                    nxtState[k] = allowedDateSet.has(sourceDate) ? 1 : 0;
                }
                );
                this._proxyAssign("state", "_state", "__state", nxtState);
            }
            ,
        });

        const btnShowSlider = e_({
            tag: "button",
            clazz: `btn btn-xxs btn-default px-1`,
            html: "Select by Date",
            click: ()=>{
                grpBtnsInactive.hideVe();
                wrpWrpSlider.showVe();
                grpBtnsActive.showVe();

                dates = Object.keys(this._state).filter(it=>SourceUtil.isNonstandardSource(it)).map(it=>Parser.sourceJsonToDate(it)).filter(Boolean).unique().map(it=>({
                    str: it,
                    date: new Date(it)
                })).sort((a,b)=>SortUtil.ascSortDate(a.date, b.date)).reverse();

                comp._proxyAssignSimple("state", {
                    min: 0,
                    max: dates.length - 1,
                    curMin: 0,
                    curMax: dates.length - 1,
                }, );
            }
            ,
        });

        const btnClear = e_({
            tag: "button",
            clazz: `btn btn-xxs btn-default px-1`,
            html: "Clear",
            click: ()=>{
                const nxtState = {};
                Object.keys(this._state).filter(k=>SourceUtil.isNonstandardSource(k)).forEach(k=>nxtState[k] = 0);
                this._proxyAssign("state", "_state", "__state", nxtState);
            }
            ,
        });

        const grpBtnsActive = e_({
            tag: "div",
            clazz: `ve-flex-v-center btn-group`,
            children: [btnCancel, btnConfirm, ],
        }).hideVe();

        const grpBtnsInactive = e_({
            tag: "div",
            clazz: `ve-flex-v-center btn-group`,
            children: [btnClear, btnShowSlider, ],
        });

        return e_({
            tag: "div",
            clazz: `ve-flex-col w-100`,
            children: [super._doRenderPills_doRenderWrpGroup_getHrDivider(), e_({
                tag: "div",
                clazz: `mb-1 ve-flex-h-right`,
                children: [grpBtnsActive, grpBtnsInactive, ],
            }), wrpWrpSlider, ],
        });
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider_groupBrew(group) {
        const btnClear = e_({
            tag: "button",
            clazz: `btn btn-xxs btn-default px-1`,
            html: "Clear",
            click: ()=>{
                const nxtState = {};
                Object.keys(this._state).filter(k=>BrewUtil2.hasSourceJson(k)).forEach(k=>nxtState[k] = 0);
                this._proxyAssign("state", "_state", "__state", nxtState);
            }
            ,
        });

        return e_({
            tag: "div",
            clazz: `ve-flex-col w-100`,
            children: [super._doRenderPills_doRenderWrpGroup_getHrDivider(), e_({
                tag: "div",
                clazz: `mb-1 ve-flex-h-right`,
                children: [e_({
                    tag: "div",
                    clazz: `ve-flex-v-center btn-group`,
                    children: [btnClear, ],
                }), ],
            }), ],
        });
    }

    _toDisplay_getMappedEntryVal(entryVal) {
        entryVal = super._toDisplay_getMappedEntryVal(entryVal);
        if (!this._meta.isIncludeOtherSources)
            entryVal = entryVal.filter(it=>!it.isOtherSource);
        return entryVal;
    }

    _getPill(item) {
        const displayText = this._getDisplayText(item);
        const displayTextMini = this._getDisplayTextMini(item);

        const dispName = e_({
            tag: "span",
            html: displayText,
        });

        const spc = e_({
            tag: "span",
            clazz: "px-2 fltr-src__spc-pill",
            text: "|",
        });

        const dispAbbreviation = e_({
            tag: "span",
            html: displayTextMini,
        });

        const btnPill = e_({
            tag: "div",
            clazz: "fltr__pill",
            children: [dispAbbreviation, spc, dispName, ],
            click: evt=>this._getPill_handleClick({
                evt,
                item
            }),
            contextmenu: evt=>this._getPill_handleContextmenu({
                evt,
                item
            }),
        });

        this._getPill_bindHookState({
            btnPill,
            item
        });

        this._addHook("meta", "pillDisplayMode", ()=>{
            dispAbbreviation.toggleVe(this._meta.pillDisplayMode !== 0);
            spc.toggleVe(this._meta.pillDisplayMode === 2);
            dispName.toggleVe(this._meta.pillDisplayMode !== 1);
        }
        )();

        item.searchText = `${Parser.sourceJsonToAbv(item.item || item).toLowerCase()} -- ${displayText.toLowerCase()}`;

        return btnPill;
    }

    getSources() {
        const out = {
            all: [],
        };
        this._items.forEach(it=>{
            out.all.push(it.item);
            const group = this._groupFn(it);
            (out[group] ||= []).push(it.item);
        }
        );
        return out;
    }

    getDefaultMeta() {
        return {
            ...super.getDefaultMeta(),
            ...SourceFilter._DEFAULT_META,
        };
    }
}
;
SourceFilter._DEFAULT_META = {
    isIncludeOtherSources: false,
    pillDisplayMode: 0,
};
SourceFilter._PILL_DISPLAY_MODE_LABELS = {
    "0": "As Names",
    "1": "As Abbreviations",
    "2": "As Names Plus Abbreviations",
};
SourceFilter._SRD_SOURCES = null;
SourceFilter._BASIC_RULES_SOURCES = null;
//#endregion

//#region OptionsFilter
let OptionsFilter$1 = class OptionsFilter extends FilterBase {
    constructor(opts) {
        super(opts);
        this._defaultState = opts.defaultState;
        this._displayFn = opts.displayFn;
        this._displayFnMini = opts.displayFnMini;

        Object.assign(this.__state, MiscUtil.copy(opts.defaultState), );

        this._filterBox = null;
        this.__$wrpMini = null;
    }

    getSaveableState() {
        return {
            [this.header]: {
                ...this.getBaseSaveableState(),
                state: {
                    ...this.__state
                },
            },
        };
    }

    setStateFromLoaded(filterState, {isUserSavedState=false}={}) {
        if (!filterState?.[this.header])
            return;

        const toLoad = filterState[this.header];
        this._hasUserSavedState = this._hasUserSavedState || isUserSavedState;

        this.setBaseStateFromLoaded(toLoad);

        const toAssign = {};
        Object.keys(this._defaultState).forEach(k=>{
            if (toLoad.state[k] == null)
                return;
            if (typeof toLoad.state[k] !== typeof this._defaultState[k])
                return;
            toAssign[k] = toLoad.state[k];
        }
        );

        Object.assign(this._state, toAssign);
    }

    _getStateNotDefault() {
        return Object.entries(this._state).filter(([k,v])=>this._defaultState[k] !== v);
    }

    getSubHashes() {
        const out = [];

        const baseMeta = this.getMetaSubHashes();
        if (baseMeta)
            out.push(...baseMeta);

        const serOptionState = [];
        Object.entries(this._defaultState).forEach(([k,vDefault])=>{
            if (this._state[k] !== vDefault)
                serOptionState.push(`${k.toLowerCase()}=${UrlUtil.mini.compress(this._state[k])}`);
        }
        );
        if (serOptionState.length) {
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serOptionState));
        }

        return out.length ? out : null;
    }

    getFilterTagPart() {
        const areNotDefaultState = this._getStateNotDefault();
        if (!areNotDefaultState.length)
            return null;

        const pt = areNotDefaultState.map(([k,v])=>`${v ? "" : "!"}${k}`).join(";").toLowerCase();

        return `${this.header.toLowerCase()}=::${pt}::`;
    }

    getDisplayStatePart({nxtState=null}={}) {
        return null;
    }

    getNextStateFromSubhashState(state) {
        const nxtState = this._getNextState_base();

        if (state == null) {
            this._mutNextState_reset(nxtState);
            return nxtState;
        }

        this._mutNextState_meta_fromSubHashState(nxtState, state);

        let hasState = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            if (prop !== "state")
                return;

            hasState = true;
            vals.forEach(v=>{
                const [prop,valCompressed] = v.split("=");
                const val = UrlUtil.mini.decompress(valCompressed);

                const casedProp = Object.keys(this._defaultState).find(k=>k.toLowerCase() === prop);
                if (!casedProp)
                    return;

                if (this._defaultState[casedProp] != null && typeof val === typeof this._defaultState[casedProp])
                    nxtState[this.header].state[casedProp] = val;
            }
            );
        }
        );

        if (!hasState)
            this._mutNextState_reset(nxtState);

        return nxtState;
    }

    setFromValues(values) {
        if (!values[this.header])
            return;
        const vals = values[this.header];
        Object.entries(vals).forEach(([k,v])=>{
            if (this._defaultState[k] && typeof this._defaultState[k] === typeof v)
                this._state[k] = v;
        }
        );
    }

    setValue(k, v) {
        this._state[k] = v;
    }

    $render(opts) {
        this._filterBox = opts.filterBox;
        this.__$wrpMini = opts.$wrpMini;

        const $wrpControls = opts.isMulti ? null : this._$getHeaderControls();

        const $btns = Object.keys(this._defaultState).map(k=>this._$render_$getPill(k));
        const $wrpButtons = $$`<div>${$btns}</div>`;

        if (opts.isMulti) {
            return this.__$wrpFilter = $$`<div class="ve-flex">
				<div class="fltr__range-inline-label mr-2">${this._getRenderedHeader()}</div>
				${$wrpButtons}
			</div>`;
        } else {
            return this.__$wrpFilter = $$`<div class="ve-flex-col">
				${opts.isFirst ? "" : `<div class="fltr__dropdown-divider mb-1"></div>`}
				<div class="split fltr__h ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
					<div class="fltr__h-text ve-flex-h-center">${this._getRenderedHeader()}</div>
					${$wrpControls}
				</div>
				${$wrpButtons}
			</div>`;
        }
    }

    $renderMinis(opts) {
        if (!opts.$wrpMini)
            return;

        this._filterBox = opts.filterBox;
        this.__$wrpMini = opts.$wrpMini;

        const $btnsMini = Object.keys(this._defaultState).map(k=>this._$render_$getMiniPill(k));
        $btnsMini.forEach($btn=>$btn.appendTo(this.__$wrpMini));
    }

    _$render_$getPill(key) {
        const displayText = this._displayFn(key);

        const $btnPill = $(`<div class="fltr__pill">${displayText}</div>`).click(()=>{
            this._state[key] = !this._state[key];
        }
        ).contextmenu((evt)=>{
            evt.preventDefault();
            this._state[key] = !this._state[key];
        }
        );
        const hook = ()=>{
            const val = FilterBox$1._PILL_STATES[this._state[key] ? 1 : 2];
            $btnPill.attr("state", val);
        }
        ;
        this._addHook("state", key, hook);
        hook();

        return $btnPill;
    }

    _$render_$getMiniPill(key) {
        const displayTextFull = this._displayFnMini ? this._displayFn(key) : null;
        const displayText = this._displayFnMini ? this._displayFnMini(key) : this._displayFn(key);

        const $btnMini = $(`<div class="fltr__mini-pill ${this._filterBox.isMinisHidden(this.header) ? "ve-hidden" : ""}" state="${FilterBox$1._PILL_STATES[this._defaultState[key] === this._state[key] ? 0 : this._state[key] ? 1 : 2]}">${displayText}</div>`).title(`${displayTextFull ? `${displayTextFull} (` : ""}Filter: ${this.header}${displayTextFull ? ")" : ""}`).click(()=>{
            this._state[key] = this._defaultState[key];
            this._filterBox.fireChangeEvent();
        }
        );

        const hook = ()=>$btnMini.attr("state", FilterBox$1._PILL_STATES[this._defaultState[key] === this._state[key] ? 0 : this._state[key] ? 1 : 2]);
        this._addHook("state", key, hook);

        const hideHook = ()=>$btnMini.toggleClass("ve-hidden", this._filterBox.isMinisHidden(this.header));
        this._filterBox.registerMinisHiddenHook(this.header, hideHook);

        return $btnMini;
    }

    _$getHeaderControls() {
        const $btnReset = $(`<button class="btn btn-default btn-xs">Reset</button>`).click(()=>this.reset());
        const $wrpBtns = $$`<div class="ve-flex-v-center">${$btnReset}</div>`;

        const $wrpSummary = $(`<div class="ve-flex-v-center fltr__summary_item fltr__summary_item--include"></div>`).hideVe();

        const $btnShowHide = $(`<button class="btn btn-default btn-xs ml-2 ${this._meta.isHidden ? "active" : ""}">Hide</button>`).click(()=>this._meta.isHidden = !this._meta.isHidden);
        const hkIsHidden = ()=>{
            $btnShowHide.toggleClass("active", this._meta.isHidden);
            $wrpBtns.toggleVe(!this._meta.isHidden);
            $wrpSummary.toggleVe(this._meta.isHidden);

            const cntNonDefault = Object.entries(this._defaultState).filter(([k,v])=>this._state[k] != null && this._state[k] !== v).length;

            $wrpSummary.title(`${cntNonDefault} non-default option${cntNonDefault === 1 ? "" : "s"} selected`).text(cntNonDefault);
        }
        ;
        this._addHook("meta", "isHidden", hkIsHidden);
        hkIsHidden();

        return $$`
		<div class="ve-flex-v-center">
			${$wrpBtns}
			${$wrpSummary}
			${$btnShowHide}
		</div>`;
    }

    getValues({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        const out = Object.entries(this._defaultState).mergeMap(([k,v])=>({
            [k]: state[k] == null ? v : state[k]
        }));
        out._isActive = Object.entries(this._defaultState).some(([k,v])=>state[k] != null && state[k] !== v);
        return {
            [this.header]: out,
        };
    }

    _mutNextState_reset(nxtState, {isResetAll=false}={}) {
        if (isResetAll)
            this._mutNextState_resetBase(nxtState, {
                isResetAll
            });
        Object.assign(nxtState[this.header].state, MiscUtil.copy(this._defaultState));
    }

    update() {}

    toDisplay(boxState, entryVal) {
        const filterState = boxState[this.header];
        if (!filterState)
            return true;
        if (entryVal == null)
            return true;
        return Object.entries(entryVal).every(([k,v])=>this._state[k] === v);
    }

    getDefaultMeta() {
        return {
            ...super.getDefaultMeta(),
            ...OptionsFilter$1._DEFAULT_META,
        };
    }

    handleSearch(searchTerm) {
        if (this.__$wrpFilter == null)
            return;

        const isVisible = this.header.toLowerCase().includes(searchTerm) || Object.keys(this._defaultState).map(it=>this._displayFn(it).toLowerCase()).some(it=>it.includes(searchTerm));

        this.__$wrpFilter.toggleClass("fltr__hidden--search", !isVisible);

        return isVisible;
    }
}
;
OptionsFilter$1._DEFAULT_META = {};
globalThis.OptionsFilter = OptionsFilter$1;
//#endregion

//#region PageFilterClasseste
class PageFilter {
    static defaultSourceSelFn(val) {
        return SourceUtil.getFilterGroup(val) === SourceUtil.FILTER_GROUP_STANDARD;
    }

    constructor(opts) {
        opts = opts || {};
        this._sourceFilter = new SourceFilter(opts.sourceFilterOpts);
        this._filterBox = null;
    }

    get filterBox() {
        return this._filterBox;
    }
    get sourceFilter() {
        return this._sourceFilter;
    }

    mutateAndAddToFilters(entity, isExcluded, opts) {
        this.constructor.mutateForFilters(entity, opts);
        this.addToFilters(entity, isExcluded, opts);
    }

    static mutateForFilters(entity, opts) {
        throw new Error("Unimplemented!");
    }
    addToFilters(entity, isExcluded, opts) {
        throw new Error("Unimplemented!");
    }
    toDisplay(values, entity) {
        throw new Error("Unimplemented!");
    }
    async _pPopulateBoxOptions() {
        throw new Error("Unimplemented!");
    }

    async pInitFilterBox(opts) {
        opts = opts || {};
        await this._pPopulateBoxOptions(opts);
        this._filterBox = new FilterBox$1(opts);
        await this._filterBox.pDoLoadState();
        return this._filterBox;
    }

    trimState() {
        return this._filterBox.trimState_();
    }

    static _getClassFilterItem({className, classSource, isVariantClass, definedInSource}) {
        const nm = className.split("(")[0].trim();
        const variantSuffix = isVariantClass ? ` [${definedInSource ? Parser.sourceJsonToAbv(definedInSource) : "Unknown"}]` : "";
        const sourceSuffix = (SourceUtil.isNonstandardSource(classSource || Parser.SRC_PHB) || (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(classSource || Parser.SRC_PHB)) || (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(classSource || Parser.SRC_PHB))) ? ` (${Parser.sourceJsonToAbv(classSource)})` : "";
        const name = `${nm}${variantSuffix}${sourceSuffix}`;

        const opts = {
            item: name,
            userData: {
                group: SourceUtil.getFilterGroup(classSource || Parser.SRC_PHB),
            },
        };

        if (isVariantClass) {
            opts.nest = definedInSource ? Parser.sourceJsonToFull(definedInSource) : "Unknown";
            opts.userData.equivalentClassName = `${nm}${sourceSuffix}`;
            opts.userData.definedInSource = definedInSource;
        }

        return new FilterItem$1(opts);
    }

    static _getSubclassFilterItem({className, classSource, subclassShortName, subclassName, subclassSource, subSubclassName, isVariantClass, definedInSource}) {
        const group = SourceUtil.isSubclassReprinted(className, classSource, subclassShortName, subclassSource) || Parser.sourceJsonToFull(subclassSource).startsWith(Parser.UA_PREFIX) || Parser.sourceJsonToFull(subclassSource).startsWith(Parser.PS_PREFIX);

        const classFilterItem = this._getClassFilterItem({
            className: subclassShortName || subclassName,
            classSource: subclassSource,
        });

        return new FilterItem$1({
            item: `${className}: ${classFilterItem.item}${subSubclassName ? `, ${subSubclassName}` : ""}`,
            nest: className,
            userData: {
                group,
            },
        });
    }

    static _isReprinted({reprintedAs, tag, page, prop}) {
        return reprintedAs?.length && reprintedAs.some(it=>{
            const {name, source} = DataUtil.generic.unpackUid(it?.uid ?? it, tag);
            const hash = UrlUtil.URL_TO_HASH_BUILDER[page]({
                name,
                source
            });
            return !ExcludeUtil.isExcluded(hash, prop, source, {
                isNoCount: true
            });
        }
        );
    }

    static getListAliases(ent) {
        return (ent.alias || []).map(it=>`"${it}"`).join(",");
    }
}

let PageFilterClassesBase$1 = class PageFilterClassesBase extends PageFilter {
    constructor() {
        super();

        this._miscFilter = new Filter({
            header: "Miscellaneous",
            items: ["Reprinted", "Sidekick", "SRD", "Basic Rules"],
            deselFn: (it)=>{
                return it === "Reprinted" || it === "Sidekick";
            }
            ,
            displayFnMini: it=>it === "Reprinted" ? "Repr." : it,
            displayFnTitle: it=>it === "Reprinted" ? it : "",
            isMiscFilter: true,
        });

        this._optionsFilter = new OptionsFilter({
            header: "Other/Text Options",
            defaultState: {
                isDisplayClassIfSubclassActive: false,
                isClassFeatureVariant: true,
            },
            displayFn: k=>{
                switch (k) {
                case "isClassFeatureVariant":
                    return "Class Feature Options/Variants";
                case "isDisplayClassIfSubclassActive":
                    return "Display Class if Any Subclass is Visible";
                default:
                    throw new Error(`Unhandled key "${k}"`);
                }
            }
            ,
            displayFnMini: k=>{
                switch (k) {
                case "isClassFeatureVariant":
                    return "C.F.O/V.";
                case "isDisplayClassIfSubclassActive":
                    return "Sc>C";
                default:
                    throw new Error(`Unhandled key "${k}"`);
                }
            }
            ,
        });
    }

    get optionsFilter() {
        return this._optionsFilter;
    }

    static mutateForFilters(cls) {
        cls.source = cls.source || Parser.SRC_PHB;
        cls.subclasses = cls.subclasses || [];

        cls._fSources = SourceFilter.getCompleteFilterSources(cls);

        cls._fSourceSubclass = [...new Set([cls.source, ...cls.subclasses.map(it=>[it.source, ...(it.otherSources || []).map(it=>it.source)]).flat(), ]), ];

        cls._fMisc = [];
        if (cls.isReprinted)
            cls._fMisc.push("Reprinted");
        if (cls.srd)
            cls._fMisc.push("SRD");
        if (cls.basicRules)
            cls._fMisc.push("Basic Rules");
        if (cls.isSidekick)
            cls._fMisc.push("Sidekick");

        cls.subclasses.forEach(sc=>{
            sc.source = sc.source || cls.source;
            sc.shortName = sc.shortName || sc.name;
            sc._fMisc = [];
            if (sc.srd)
                sc._fMisc.push("SRD");
            if (sc.basicRules)
                sc._fMisc.push("Basic Rules");
            if (sc.isReprinted)
                sc._fMisc.push("Reprinted");
        }
        );
    }

    _addEntrySourcesToFilter(entry) {
        this._addEntrySourcesToFilter_walk(entry);
    }

    _addEntrySourcesToFilter_walk = (obj)=>{
        if ((typeof obj !== "object") || obj == null)
            return;

        if (obj instanceof Array)
            return obj.forEach(this._addEntrySourcesToFilter_walk.bind(this));

        if (obj.source)
            this._sourceFilter.addItem(obj.source);
        if (obj.entries)
            this._addEntrySourcesToFilter_walk(obj.entries);
    }
    ;

    addToFilters(cls, isExcluded, opts) {
        if (isExcluded)
            return;
        opts = opts || {};
        const subclassExclusions = opts.subclassExclusions || {};

        this._sourceFilter.addItem(cls.source);

        if (cls.fluff)
            cls.fluff.forEach(it=>this._addEntrySourcesToFilter(it));
        cls.classFeatures.forEach(lvlFeatures=>lvlFeatures.forEach(feature=>this._addEntrySourcesToFilter(feature)));

        cls.subclasses.forEach(sc=>{
            const isScExcluded = (subclassExclusions[sc.source] || {})[sc.name] || false;
            if (!isScExcluded) {
                this._sourceFilter.addItem(sc.source);
                sc.subclassFeatures.forEach(lvlFeatures=>lvlFeatures.forEach(feature=>this._addEntrySourcesToFilter(feature)));
            }
        }
        );
    }

    async _pPopulateBoxOptions(opts) {
        opts.filters = [this._sourceFilter, this._miscFilter, this._optionsFilter, ];
        opts.isCompact = true;
    }

    isClassNaturallyDisplayed(values, cls) {
        return this._filterBox.toDisplay(values, ...this.constructor._getIsClassNaturallyDisplayedToDisplayParams(cls), );
    }

    static _getIsClassNaturallyDisplayedToDisplayParams(cls) {
        return [cls._fSources, cls._fMisc];
    }

    isAnySubclassDisplayed(values, cls) {
        return values[this._optionsFilter.header].isDisplayClassIfSubclassActive && (cls.subclasses || []).some(sc=>{
            if (this._filterBox.toDisplay(values, ...this.constructor._getIsSubclassDisplayedToDisplayParams(cls, sc), ))
                return true;

            return sc.otherSources?.length && sc.otherSources.some(src=>this._filterBox.toDisplay(values, ...this.constructor._getIsSubclassDisplayedToDisplayParams(cls, sc, src), ));
        }
        );
    }

    static _getIsSubclassDisplayedToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, null, ];
    }

    isSubclassVisible(f, cls, sc) {
        if (this.filterBox.toDisplay(f, ...this.constructor._getIsSubclassVisibleToDisplayParams(cls, sc), ))
            return true;

        if (!sc.otherSources?.length)
            return false;

        return sc.otherSources.some(src=>this.filterBox.toDisplay(f, ...this.constructor._getIsSubclassVisibleToDisplayParams(cls, sc, src.source), ));
    }

    static _getIsSubclassVisibleToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, null, ];
    }

    getActiveSource(values) {
        const sourceFilterValues = values[this._sourceFilter.header];
        if (!sourceFilterValues)
            return null;
        return Object.keys(sourceFilterValues).find(it=>this._sourceFilter.toDisplay(values, it));
    }

    toDisplay(values, it) {
        return this._filterBox.toDisplay(values, ...this._getToDisplayParams(values, it), );
    }

    _getToDisplayParams(values, cls) {
        return [this.isAnySubclassDisplayed(values, cls) ? cls._fSourceSubclass : (cls._fSources ?? cls.source), cls._fMisc, null, ];
    }
}
;

globalThis.PageFilterClassesBase = PageFilterClassesBase$1;

let PageFilterClasses$1 = class PageFilterClasses extends PageFilterClassesBase$1 {
    static _getClassSubclassLevelArray(it) {
        return it.classFeatures.map((_,i)=>i + 1);
    }

    constructor() {
        super();

        this._levelFilter = new RangeFilter({
            header: "Feature Level",
            min: 1,
            max: 20,
        });
    }

    get levelFilter() {
        return this._levelFilter;
    }

    static mutateForFilters(cls) {
        super.mutateForFilters(cls);

        cls._fLevelRange = this._getClassSubclassLevelArray(cls);
    }

    addToFilters(cls, isExcluded, opts) {
        super.addToFilters(cls, isExcluded, opts);

        if (isExcluded)
            return;

        this._levelFilter.addItem(cls._fLevelRange);
    }

    async _pPopulateBoxOptions(opts) {
        await super._pPopulateBoxOptions(opts);

        opts.filters = [this._sourceFilter, this._miscFilter, this._levelFilter, this._optionsFilter, ];
    }

    static _getIsClassNaturallyDisplayedToDisplayParams(cls) {
        return [cls._fSources, cls._fMisc, cls._fLevelRange];
    }

    static _getIsSubclassDisplayedToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, cls._fLevelRange];
    }

    static _getIsSubclassVisibleToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, cls._fLevelRange, null];
    }

    _getToDisplayParams(values, cls) {
        return [this.isAnySubclassDisplayed(values, cls) ? cls._fSourceSubclass : (cls._fSources ?? cls.source), cls._fMisc, cls._fLevelRange, ];
    }
}
;

globalThis.PageFilterClasses = PageFilterClasses$1;

"use strict";

let PageFilterClassesRaw$1 = class PageFilterClassesRaw extends PageFilterClassesBase {
    static _WALKER = null;
    static _IMPLS_SIDE_DATA = {};

    async _pPopulateBoxOptions(opts) {
        await super._pPopulateBoxOptions(opts);
        opts.isCompact = false;
    }

    addToFilters(cls, isExcluded, opts) {
        if (isExcluded)
            return;
        opts = opts || {};
        const subclassExclusions = opts.subclassExclusions || {};

        this._sourceFilter.addItem(cls.source);

        if (cls.fluff)
            cls.fluff.forEach(it=>this._addEntrySourcesToFilter(it));

        cls.classFeatures.forEach(feature=>feature.loadeds.forEach(ent=>this._addEntrySourcesToFilter(ent.entity)));

        cls.subclasses.forEach(sc=>{
            const isScExcluded = (subclassExclusions[sc.source] || {})[sc.name] || false;
            if (!isScExcluded) {
                this._sourceFilter.addItem(sc.source);
                sc.subclassFeatures.forEach(feature=>feature.loadeds.forEach(ent=>this._addEntrySourcesToFilter(ent.entity)));
            }
        }
        );
    }

    static async _pGetParentClass(sc) {
        let baseClass = (await DataUtil.class.loadRawJSON()).class.find(bc=>bc.name.toLowerCase() === sc.className.toLowerCase() && (bc.source.toLowerCase() || Parser.SRC_PHB) === sc.classSource.toLowerCase());

        baseClass = baseClass || await this._pGetParentClass_pPrerelease({
            sc
        });
        baseClass = baseClass || await this._pGetParentClass_pBrew({
            sc
        });

        return baseClass;
    }

    static async _pGetParentClass_pPrerelease({sc}) {
        await this._pGetParentClass_pPrereleaseBrew({
            sc,
            brewUtil: PrereleaseUtil
        });
    }

    static async _pGetParentClass_pBrew({sc}) {
        await this._pGetParentClass_pPrereleaseBrew({
            sc,
            brewUtil: BrewUtil2
        });
    }

    static async _pGetParentClass_pPrereleaseBrew({sc, brewUtil}) {
        const brew = await brewUtil.pGetBrewProcessed();
        return (brew.class || []).find(bc=>bc.name.toLowerCase() === sc.className.toLowerCase() && (bc.source.toLowerCase() || Parser.SRC_PHB) === sc.classSource.toLowerCase());
    }

    static async pPostLoad(data, {...opts}={}) {
        data = MiscUtil.copy(data);

        await PrereleaseUtil.pGetBrewProcessed();
        await BrewUtil2.pGetBrewProcessed();

        if (!data.class)
            data.class = [];

        if (data.subclass) {
            for (const sc of data.subclass) {
                if (!sc.className)
                    continue;
                sc.classSource = sc.classSource || Parser.SRC_PHB;

                let cls = data.class.find(it=>(it.name || "").toLowerCase() === sc.className.toLowerCase() && (it.source || Parser.SRC_PHB).toLowerCase() === sc.classSource.toLowerCase());

                if (!cls) {
                    cls = await this._pGetParentClass(sc);
                    if (cls) {
                        cls = MiscUtil.copy(cls);
                        cls.subclasses = [];
                        data.class.push(cls);
                    } else {
                        cls = {
                            name: sc.className,
                            source: sc.classSource
                        };
                        data.class.push(cls);
                    }
                }

                (cls.subclasses = cls.subclasses || []).push(sc);
            }

            delete data.subclass;
        }

        data.class.forEach(cls=>{
            cls.source = cls.source || Parser.SRC_PHB;

            cls.subclasses = cls.subclasses || [];

            cls.subclasses.forEach(sc=>{
                sc.name = sc.name || "(Unnamed subclass)";
                sc.source = sc.source || cls.source;
                sc.className = sc.className || cls.name;
                sc.classSource = sc.classSource || cls.source || Parser.SRC_PHB;
            }
            );

            cls.subclasses.sort((a,b)=>SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source || cls.source, b.source || cls.source));

            cls._cntStartingSkillChoices = (MiscUtil.get(cls, "startingProficiencies", "skills") || []).map(it=>it.choose ? (it.choose.count || 1) : 0).reduce((a,b)=>a + b, 0);

            cls._cntStartingSkillChoicesMutliclass = (MiscUtil.get(cls, "multiclassing", "proficienciesGained", "skills") || []).map(it=>it.choose ? (it.choose.count || 1) : 0).reduce((a,b)=>a + b, 0);
        }
        );
        data.class.sort((a,b)=>SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source));

        data.class.forEach(cls=>{
            cls.classFeatures = (cls.classFeatures || []).map(cf=>typeof cf === "string" ? {
                classFeature: cf
            } : cf);

            (cls.subclasses || []).forEach(sc=>{
                sc.subclassFeatures = (sc.subclassFeatures || []).map(cf=>typeof cf === "string" ? {
                    subclassFeature: cf
                } : cf);
            }
            );
        }
        );

        await this._pPreloadSideData();

        for (const cls of data.class) {
            await (cls.classFeatures || []).pSerialAwaitMap(cf=>this.pInitClassFeatureLoadeds({
                ...opts,
                classFeature: cf,
                className: cls.name
            }));

            if (cls.classFeatures)
                cls.classFeatures = cls.classFeatures.filter(it=>!it.isIgnored);

            for (const sc of cls.subclasses || []) {
                await (sc.subclassFeatures || []).pSerialAwaitMap(scf=>this.pInitSubclassFeatureLoadeds({
                    ...opts,
                    subclassFeature: scf,
                    className: cls.name,
                    subclassName: sc.name
                }));

                if (sc.subclassFeatures)
                    sc.subclassFeatures = sc.subclassFeatures.filter(it=>!it.isIgnored);
            }
        }

        return data;
    }

    static async pInitClassFeatureLoadeds({classFeature, className, ...opts}) {
        if (typeof classFeature !== "object")
            throw new Error(`Expected an object of the form {classFeature: "<UID>"}`);

        const unpacked = DataUtil.class.unpackUidClassFeature(classFeature.classFeature);

        classFeature.hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked);

        const {name, level, source} = unpacked;
        classFeature.name = name;
        classFeature.level = level;
        classFeature.source = source;

        const entityRoot = await DataLoader.pCacheAndGet("raw_classFeature", classFeature.source, classFeature.hash, {
            isCopy: true
        });
        const loadedRoot = {
            type: "classFeature",
            entity: entityRoot,
            page: "classFeature",
            source: classFeature.source,
            hash: classFeature.hash,
            className,
        };

        const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, "classFeature");
        if (isIgnored) {
            classFeature.isIgnored = true;
            return;
        }

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: "classFeature",
            ancestorMeta: {
                _ancestorClassName: className,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        classFeature.loadeds = [loadedRoot, ...subLoadeds];
    }

    static async pInitSubclassFeatureLoadeds({subclassFeature, className, subclassName, ...opts}) {
        if (typeof subclassFeature !== "object")
            throw new Error(`Expected an object of the form {subclassFeature: "<UID>"}`);

        const unpacked = DataUtil.class.unpackUidSubclassFeature(subclassFeature.subclassFeature);

        subclassFeature.hash = UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked);

        const {name, level, source} = unpacked;
        subclassFeature.name = name;
        subclassFeature.level = level;
        subclassFeature.source = source;

        const entityRoot = await DataLoader.pCacheAndGet("raw_subclassFeature", subclassFeature.source, subclassFeature.hash, {
            isCopy: true
        });
        const loadedRoot = {
            type: "subclassFeature",
            entity: entityRoot,
            page: "subclassFeature",
            source: subclassFeature.source,
            hash: subclassFeature.hash,
            className,
            subclassName,
        };

        const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, "subclassFeature");
        if (isIgnored) {
            subclassFeature.isIgnored = true;
            return;
        }

        if (entityRoot.isGainAtNextFeatureLevel) {
            subclassFeature.isGainAtNextFeatureLevel = true;
        }

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: "subclassFeature",
            ancestorMeta: {
                _ancestorClassName: className,
                _ancestorSubclassName: subclassName,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        subclassFeature.loadeds = [loadedRoot, ...subLoadeds];
    }

    static async pInitFeatLoadeds({feat, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: feat,
            prop: "feat",
            page: UrlUtil.PG_FEATS,
            propAncestorName: "_ancestorFeatName",
            raw,
        });
    }

    static async pInitOptionalFeatureLoadeds({optionalfeature, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: optionalfeature,
            prop: "optionalfeature",
            page: UrlUtil.PG_OPT_FEATURES,
            propAncestorName: "_ancestorOptionalfeatureName",
            raw,
        });
    }

    static async pInitRewardLoadeds({reward, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: reward,
            prop: "reward",
            page: UrlUtil.PG_REWARDS,
            propAncestorName: "_ancestorRewardName",
            raw,
        });
    }

    static async pInitCharCreationOptionLoadeds({charoption, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: charoption,
            prop: "charoption",
            page: UrlUtil.PG_CHAR_CREATION_OPTIONS,
            propAncestorName: "_ancestorCharoptionName",
            raw,
        });
    }

    static async pInitVehicleUpgradeLoadeds({vehicleUpgrade, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: vehicleUpgrade,
            prop: "vehicleUpgrade",
            page: UrlUtil.PG_VEHICLES,
            propAncestorName: "_ancestorVehicleUpgradeName",
            raw,
        });
    }

    static async _pInitGenericLoadeds({ent, prop, page, propAncestorName, raw, ...opts}) {
        if (typeof ent !== "object")
            throw new Error(`Expected an object of the form {${prop}: "<UID>"}`);

        const unpacked = DataUtil.generic.unpackUid(ent[prop]);

        ent.hash = UrlUtil.URL_TO_HASH_BUILDER[page](unpacked);

        const {name, source} = unpacked;
        ent.name = name;
        ent.source = source;

        const entityRoot = raw != null ? MiscUtil.copy(raw) : await DataLoader.pCacheAndGet(`raw_${prop}`, ent.source, ent.hash, {
            isCopy: true
        });
        const loadedRoot = {
            type: prop,
            entity: entityRoot,
            page,
            source: ent.source,
            hash: ent.hash,
        };

        const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, prop);
        if (isIgnored) {
            ent.isIgnored = true;
            return;
        }

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: prop,
            ancestorMeta: {
                [propAncestorName]: entityRoot.name,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        ent.loadeds = [loadedRoot, ...subLoadeds];
    }

    static async _pPreloadSideData() {
        await Promise.all(Object.values(PageFilterClassesRaw$1._IMPLS_SIDE_DATA).map(Impl=>Impl.pPreloadSideData()));
    }

    static async _pGetIgnoredAndApplySideData(entity, type) {
        if (!PageFilterClassesRaw$1._IMPLS_SIDE_DATA[type])
            throw new Error(`Unhandled type "${type}"`);

        const sideData = await PageFilterClassesRaw$1._IMPLS_SIDE_DATA[type].pGetSideLoaded(entity, {
            isSilent: true
        });

        if (!sideData)
            return false;
        if (sideData.isIgnored)
            return true;

        if (sideData.entries)
            entity.entries = MiscUtil.copy(sideData.entries);
        if (sideData.entryData)
            entity.entryData = MiscUtil.copy(sideData.entryData);

        return false;
    }

    static async _pLoadSubEntries(walker, entityRoot, {ancestorType, ancestorMeta, ...opts}) {
        const out = [];

        const pRecurse = async(parent,toWalk)=>{
            const references = [];
            const path = [];

            toWalk = walker.walk(toWalk, {
                array: (arr)=>{
                    arr = arr.map(it=>this._pLoadSubEntries_getMappedWalkerArrayEntry({
                        ...opts,
                        it,
                        path,
                        references
                    })).filter(Boolean);
                    return arr;
                }
                ,
                preObject: (obj)=>{
                    if (obj.type === "options") {
                        const parentName = (path.last() || {}).name ?? parent.name;

                        if (obj.count != null) {
                            const optionSetId = CryptUtil.uid();
                            obj.entries.forEach(ent=>{
                                ent._optionsMeta = {
                                    setId: optionSetId,
                                    count: obj.count,
                                    name: parentName,
                                };
                            }
                            );
                        }

                        if (parentName) {
                            obj.entries.forEach(ent=>{
                                if (typeof ent !== "object")
                                    return;
                                ent._displayNamePrefix = `${parentName}: `;
                            }
                            );
                        }
                    }

                    if (obj.name)
                        path.push(obj);
                }
                ,
                postObject: (obj)=>{
                    if (obj.name)
                        path.pop();
                }
                ,
            }, );

            for (const ent of references) {
                const isRequiredOption = !!MiscUtil.get(ent, "data", "isRequiredOption");
                switch (ent.type) {
                case "refClassFeature":
                    {
                        const unpacked = DataUtil.class.unpackUidClassFeature(ent.classFeature);
                        const {source} = unpacked;
                        const hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked);

                        let entity = await DataLoader.pCacheAndGet("raw_classFeature", source, hash, {
                            isCopy: true
                        });

                        if (!entity) {
                            this._handleReferenceError(`Failed to load "classFeature" reference "${ent.classFeature}" (not found)`);
                            continue;
                        }

                        if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER["classFeature"](toWalk) === hash) {
                            this._handleReferenceError(`Failed to load "classFeature" reference "${ent.classFeature}" (circular reference)`);
                            continue;
                        }

                        const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "classFeature");
                        if (isIgnored)
                            continue;

                        this.populateEntityTempData({
                            entity,
                            displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
                            ...ancestorMeta,
                        });

                        out.push({
                            type: "classFeature",
                            entry: `{@classFeature ${ent.classFeature}}`,
                            entity,
                            optionsMeta: ent._optionsMeta,
                            page: "classFeature",
                            source,
                            hash,
                            isRequiredOption,
                        });

                        entity = await pRecurse(entity, entity.entries);

                        break;
                    }
                case "refSubclassFeature":
                    {
                        const unpacked = DataUtil.class.unpackUidSubclassFeature(ent.subclassFeature);
                        const {source} = unpacked;
                        const hash = UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked);

                        let entity = await DataLoader.pCacheAndGet("raw_subclassFeature", source, hash, {
                            isCopy: true
                        });

                        if (!entity) {
                            this._handleReferenceError(`Failed to load "subclassFeature" reference "${ent.subclassFeature}" (not found)`);
                            continue;
                        }

                        if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](toWalk) === hash) {
                            this._handleReferenceError(`Failed to load "subclassFeature" reference "${ent.subclassFeature}" (circular reference)`);
                            continue;
                        }

                        const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "subclassFeature");
                        if (isIgnored)
                            continue;

                        this.populateEntityTempData({
                            entity,
                            displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
                            ...ancestorMeta,
                        });

                        out.push({
                            type: "subclassFeature",
                            entry: `{@subclassFeature ${ent.subclassFeature}}`,
                            entity,
                            optionsMeta: ent._optionsMeta,
                            page: "subclassFeature",
                            source,
                            hash,
                            isRequiredOption,
                        });

                        entity = await pRecurse(entity, entity.entries);

                        break;
                    }
                case "refOptionalfeature":
                    {
                        const unpacked = DataUtil.generic.unpackUid(ent.optionalfeature, "optfeature");
                        const page = UrlUtil.PG_OPT_FEATURES;
                        const {source} = unpacked;
                        const hash = UrlUtil.URL_TO_HASH_BUILDER[page](unpacked);

                        const entity = await DataLoader.pCacheAndGet(page, source, hash, {
                            isCopy: true
                        });

                        if (!entity) {
                            this._handleReferenceError(`Failed to load "optfeature" reference "${ent.optionalfeature}" (not found)`);
                            continue;
                        }

                        if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER[page](toWalk) === hash) {
                            this._handleReferenceError(`Failed to load "optfeature" reference "${ent.optionalfeature}" (circular reference)`);
                            continue;
                        }

                        const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "optionalfeature");
                        if (isIgnored)
                            continue;

                        this.populateEntityTempData({
                            entity,
                            ancestorType,
                            displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
                            ...ancestorMeta,
                            foundrySystem: {
                                requirements: entityRoot.className ? `${entityRoot.className} ${entityRoot.level}${entityRoot.subclassShortName ? ` (${entityRoot.subclassShortName})` : ""}` : null,
                            },
                        });

                        out.push({
                            type: "optionalfeature",
                            entry: `{@optfeature ${ent.optionalfeature}}`,
                            entity,
                            optionsMeta: ent._optionsMeta,
                            page,
                            source,
                            hash,
                            isRequiredOption,
                        });

                        break;
                    }
                default:
                    throw new Error(`Unhandled type "${ent.type}"`);
                }
            }

            return toWalk;
        }
        ;

        if (entityRoot.entries) //entityRoot.entryData is already set by this point
            entityRoot.entries = await pRecurse(entityRoot, entityRoot.entries);

        return {
            entityRoot,
            subLoadeds: out
        };
    }

    static _pLoadSubEntries_getMappedWalkerArrayEntry({it, path, references, ...opts}) {
        if (it.type !== "refClassFeature" && it.type !== "refSubclassFeature" && it.type !== "refOptionalfeature")
            return it;

        it.parentName = (path.last() || {}).name;
        references.push(it);

        return null;
    }

    static populateEntityTempData({entity, ancestorType, displayName, foundrySystem, ...others}, ) {
        if (ancestorType)
            entity._ancestorType = ancestorType;
        if (displayName)
            entity._displayName = displayName;
        if (foundrySystem)
            entity._foundrySystem = foundrySystem;
        Object.assign(entity, {
            ...others
        });
    }

    static _handleReferenceError(msg) {
        JqueryUtil.doToast({
            type: "danger",
            content: msg
        });
    }

    static _getPostLoadWalker() {
        PageFilterClassesRaw$1._WALKER = PageFilterClassesRaw$1._WALKER || MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
            isDepthFirst: true,
        });
        return PageFilterClassesRaw$1._WALKER;
    }

    static setImplSideData(prop, Impl) {
        PageFilterClassesRaw$1._IMPLS_SIDE_DATA[prop] = Impl;
    }
}
;

globalThis.PageFilterClassesRaw = PageFilterClassesRaw$1;
//#endregion

//#region Modals    

//#region ModalFilter
class ModalFilter {
    static _$getFilterColumnHeaders(btnMeta) {
        return btnMeta.map((it,i)=>$(`<button class="col-${it.width} ${i === 0 ? "pl-0" : i === btnMeta.length ? "pr-0" : ""} ${it.disabled ? "" : "sort"} btn btn-default btn-xs" ${it.disabled ? "" : `data-sort="${it.sort}"`} ${it.title ? `title="${it.title}"` : ""} ${it.disabled ? "disabled" : ""}>${it.text}</button>`));
    }

    constructor(opts) {
        this._modalTitle = opts.modalTitle;
        this._fnSort = opts.fnSort;
        this._pageFilter = opts.pageFilter;
        this._namespace = opts.namespace;
        this._allData = opts.allData || null;
        this._isRadio = !!opts.isRadio;

        this._list = null;
        this._filterCache = null;
    }

    get pageFilter() {
        return this._pageFilter;
    }

    get allData() {
        return this._allData;
    }

    _$getWrpList() {
        return $(`<div class="list ui-list__wrp overflow-x-hidden overflow-y-auto h-100 min-h-0"></div>`);
    }

    _$getColumnHeaderPreviewAll(opts) {
        return $(`<button class="btn btn-default btn-xs ${opts.isBuildUi ? "col-1" : "col-0-5"}">${ListUiUtil.HTML_GLYPHICON_EXPAND}</button>`);
    }

    async pPopulateWrapper($wrp, opts) {
        opts = opts || {};

        await this._pInit();

        const $ovlLoading = $(`<div class="w-100 h-100 ve-flex-vh-center"><i class="dnd-font ve-muted">Loading...</i></div>`).appendTo($wrp);

        const $iptSearch = (opts.$iptSearch || $(`<input class="form-control lst__search lst__search--no-border-h h-100" type="search" placeholder="Search...">`)).disableSpellcheck();
        const $btnReset = opts.$btnReset || $(`<button class="btn btn-default">Reset</button>`);
        const $dispNumVisible = $(`<div class="lst__wrp-search-visible no-events ve-flex-vh-center"></div>`);

        const $wrpIptSearch = $$`<div class="w-100 relative">
			${$iptSearch}
			<div class="lst__wrp-search-glass no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>
			${$dispNumVisible}
		</div>`;

        const $wrpFormTop = $$`<div class="ve-flex input-group btn-group w-100 lst__form-top">${$wrpIptSearch}${$btnReset}</div>`;

        const $wrpFormBottom = opts.$wrpMiniPills || $(`<div class="w-100"></div>`);

        const $wrpFormHeaders = $(`<div class="input-group input-group--bottom ve-flex no-shrink"></div>`);
        const $cbSelAll = opts.isBuildUi || this._isRadio ? null : $(`<input type="checkbox">`);
        const $btnSendAllToRight = opts.isBuildUi ? $(`<button class="btn btn-xxs btn-default col-1" title="Add All"><span class="glyphicon glyphicon-arrow-right"></span></button>`) : null;

        if (!opts.isBuildUi) {
            if (this._isRadio)
                $wrpFormHeaders.append(`<label class="btn btn-default btn-xs col-0-5 ve-flex-vh-center" disabled></label>`);
            else
                $$`<label class="btn btn-default btn-xs col-0-5 ve-flex-vh-center">${$cbSelAll}</label>`.appendTo($wrpFormHeaders);
        }

        const $btnTogglePreviewAll = this._$getColumnHeaderPreviewAll(opts).appendTo($wrpFormHeaders);

        this._$getColumnHeaders().forEach($ele=>$wrpFormHeaders.append($ele));
        if (opts.isBuildUi)
            $btnSendAllToRight.appendTo($wrpFormHeaders);

        const $wrpForm = $$`<div class="ve-flex-col w-100 mb-1">${$wrpFormTop}${$wrpFormBottom}${$wrpFormHeaders}</div>`;
        const $wrpList = this._$getWrpList();

        const $btnConfirm = opts.isBuildUi ? null : $(`<button class="btn btn-default">Confirm</button>`);

        this._list = new List({
            $iptSearch,
            $wrpList,
            fnSort: this._fnSort,
        });
        const listSelectClickHandler = new ListSelectClickHandler({
            list: this._list
        });

        if (!opts.isBuildUi && !this._isRadio)
            listSelectClickHandler.bindSelectAllCheckbox($cbSelAll);
        ListUiUtil.bindPreviewAllButton($btnTogglePreviewAll, this._list);
        SortUtil.initBtnSortHandlers($wrpFormHeaders, this._list);
        this._list.on("updated", ()=>$dispNumVisible.html(`${this._list.visibleItems.length}/${this._list.items.length}`));

        this._allData = this._allData || await this._pLoadAllData();

        await this._pageFilter.pInitFilterBox({
            $wrpFormTop,
            $btnReset,
            $wrpMiniPills: $wrpFormBottom,
            namespace: this._namespace,
            $btnOpen: opts.$btnOpen,
            $btnToggleSummaryHidden: opts.$btnToggleSummaryHidden,
        });

        this._allData.forEach((it,i)=>{
            this._pageFilter.mutateAndAddToFilters(it);
            const filterListItem = this._getListItem(this._pageFilter, it, i);
            this._list.addItem(filterListItem);
            if (!opts.isBuildUi) {
                if (this._isRadio)
                    filterListItem.ele.addEventListener("click", evt=>listSelectClickHandler.handleSelectClickRadio(filterListItem, evt));
                else
                    filterListItem.ele.addEventListener("click", evt=>listSelectClickHandler.handleSelectClick(filterListItem, evt));
            }
        }
        );

        this._list.init();
        this._list.update();

        const handleFilterChange = ()=>{
            const f = this._pageFilter.filterBox.getValues();
            this._list.filter(li=>this._isListItemMatchingFilter(f, li));
        }
        ;

        this._pageFilter.trimState();

        this._pageFilter.filterBox.on(FilterBox$1.EVNT_VALCHANGE, handleFilterChange);
        this._pageFilter.filterBox.render();
        handleFilterChange();

        $ovlLoading.remove();

        const $wrpInner = $$`<div class="ve-flex-col h-100">
			${$wrpForm}
			${$wrpList}
			${opts.isBuildUi ? null : $$`<hr class="hr-1"><div class="ve-flex-vh-center">${$btnConfirm}</div>`}
		</div>`.appendTo($wrp.empty());

        return {
            $wrpIptSearch,
            $iptSearch,
            $wrpInner,
            $btnConfirm,
            pageFilter: this._pageFilter,
            list: this._list,
            $cbSelAll,
            $btnSendAllToRight,
        };
    }

    _isListItemMatchingFilter(f, li) {
        return this._isEntityItemMatchingFilter(f, this._allData[li.ix]);
    }
    _isEntityItemMatchingFilter(f, it) {
        return this._pageFilter.toDisplay(f, it);
    }

    async pPopulateHiddenWrapper() {
        await this._pInit();

        this._allData = this._allData || await this._pLoadAllData();

        await this._pageFilter.pInitFilterBox({
            namespace: this._namespace
        });

        this._allData.forEach(it=>{
            this._pageFilter.mutateAndAddToFilters(it);
        }
        );

        this._pageFilter.trimState();
    }

    handleHiddenOpenButtonClick() {
        this._pageFilter.filterBox.show();
    }

    handleHiddenResetButtonClick(evt) {
        this._pageFilter.filterBox.reset(evt.shiftKey);
    }

    _getStateFromFilterExpression(filterExpression) {
        const filterSubhashMeta = Renderer.getFilterSubhashes(Renderer.splitTagByPipe(filterExpression), this._namespace);
        const subhashes = filterSubhashMeta.subhashes.map(it=>`${it.key}${HASH_SUB_KV_SEP}${it.value}`);
        const unpackedSubhashes = this.pageFilter.filterBox.unpackSubHashes(subhashes, {
            force: true
        });
        return this.pageFilter.filterBox.getNextStateFromSubHashes({
            unpackedSubhashes
        });
    }

    getItemsMatchingFilterExpression({filterExpression}) {
        const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);

        const f = this._pageFilter.filterBox.getValues({
            nxtStateOuter
        });
        const filteredItems = this._filterCache.list.getFilteredItems({
            items: this._filterCache.list.items,
            fnFilter: li=>this._isListItemMatchingFilter(f, li),
        });

        return this._filterCache.list.getSortedItems({
            items: filteredItems
        });
    }

    getEntitiesMatchingFilterExpression({filterExpression}) {
        const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);

        const f = this._pageFilter.filterBox.getValues({
            nxtStateOuter
        });
        return this._allData.filter(this._isEntityItemMatchingFilter.bind(this, f));
    }

    getRenderedFilterExpression({filterExpression}) {
        const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);
        return this.pageFilter.filterBox.getDisplayState({
            nxtStateOuter
        });
    }

    async pGetUserSelection({filterExpression=null}={}) {
        return new Promise(async resolve=>{
            const {$modalInner, doClose} = await this._pGetShowModal(resolve);

            await this.pPreloadHidden($modalInner);

            this._doApplyFilterExpression(filterExpression);

            this._filterCache.$btnConfirm.off("click").click(async()=>{
                const checked = this._filterCache.list.visibleItems.filter(it=>it.data.cbSel.checked);
                resolve(checked);

                doClose(true);

                if (this._filterCache.$cbSelAll)
                    this._filterCache.$cbSelAll.prop("checked", false);
                this._filterCache.list.items.forEach(it=>{
                    if (it.data.cbSel)
                        it.data.cbSel.checked = false;
                    it.ele.classList.remove("list-multi-selected");
                }
                );
            }
            );

            await UiUtil.pDoForceFocus(this._filterCache.$iptSearch[0]);
        }
        );
    }

    async _pGetShowModal(resolve) {
        const {$modalInner, doClose} = await UiUtil.pGetShowModal({
            isHeight100: true,
            isWidth100: true,
            title: `Filter/Search for ${this._modalTitle}`,
            cbClose: (isDataEntered)=>{
                this._filterCache.$wrpModalInner.detach();
                if (!isDataEntered)
                    resolve([]);
            }
            ,
            isUncappedHeight: true,
        });

        return {
            $modalInner,
            doClose
        };
    }

    _doApplyFilterExpression(filterExpression) {
        if (!filterExpression)
            return;

        const filterSubhashMeta = Renderer.getFilterSubhashes(Renderer.splitTagByPipe(filterExpression), this._namespace);
        const subhashes = filterSubhashMeta.subhashes.map(it=>`${it.key}${HASH_SUB_KV_SEP}${it.value}`);
        this.pageFilter.filterBox.setFromSubHashes(subhashes, {
            force: true,
            $iptSearch: this._filterCache.$iptSearch
        });
    }

    _getNameStyle() {
        return `bold`;
    }

    async pPreloadHidden($modalInner) {
        $modalInner = $modalInner || $(`<div></div>`);

        if (this._filterCache) {
            this._filterCache.$wrpModalInner.appendTo($modalInner);
        } else {
            const meta = await this.pPopulateWrapper($modalInner);
            const {$iptSearch, $btnConfirm, pageFilter, list, $cbSelAll} = meta;
            const $wrpModalInner = meta.$wrpInner;

            this._filterCache = {
                $iptSearch,
                $wrpModalInner,
                $btnConfirm,
                pageFilter,
                list,
                $cbSelAll
            };
        }
    }

    _$getColumnHeaders() {
        throw new Error(`Unimplemented!`);
    }
    async _pInit() {}
    async _pLoadAllData() {
        throw new Error(`Unimplemented!`);
    }
    async _getListItem() {
        throw new Error(`Unimplemented!`);
    }
}
class ModalFilterClasses extends ModalFilter {
    constructor(opts) {
        opts = opts || {};

        super({
            ...opts,
            modalTitle: "Class and Subclass",
            pageFilter: new PageFilterClassesRaw$1(),
            fnSort: ModalFilterClasses.fnSort,
        });

        this._pLoadingAllData = null;

        this._ixPrevSelectedClass = null;
        this._isClassDisabled = false;
        this._isSubclassDisabled = false;
    }

    get pageFilter() {
        return this._pageFilter;
    }

    static fnSort(a, b, opts) {
        const out = SortUtil.listSort(a, b, opts);

        if (opts.sortDir === "desc" && a.data.ixClass === b.data.ixClass && (a.data.ixSubclass != null || b.data.ixSubclass != null)) {
            return a.data.ixSubclass != null ? -1 : 1;
        }

        return out;
    }

    async pGetSelection(classSubclassMeta) {
        const {className, classSource, subclassName, subclassSource} = classSubclassMeta;

        const allData = this._allData || await this._pLoadAllData();

        const cls = allData.find(it=>it.name === className && it.source === classSource);
        if (!cls)
            throw new Error(`Could not find class with name "${className}" and source "${classSource}"`);

        const out = {
            class: cls,
        };

        if (subclassName && subclassSource) {
            const sc = cls.subclasses.find(it=>it.name === subclassName && it.source === subclassSource);
            if (!sc)
                throw new Error(`Could not find subclass with name "${subclassName}" and source "${subclassSource}" on class with name "${className}" and source "${classSource}"`);

            out.subclass = sc;
        }

        return out;
    }

    async pGetUserSelection({filterExpression=null, selectedClass=null, selectedSubclass=null, isClassDisabled=false, isSubclassDisabled=false}={}) {
        return new Promise(async resolve=>{
            const {$modalInner, doClose} = await this._pGetShowModal(resolve);

            await this.pPreloadHidden($modalInner);

            this._doApplyFilterExpression(filterExpression);

            this._filterCache.$btnConfirm.off("click").click(async()=>{
                const checked = this._filterCache.list.items.filter(it=>it.data.tglSel.classList.contains("active"));
                const out = {};
                checked.forEach(it=>{
                    if (it.data.ixSubclass == null)
                        out.class = this._filterCache.allData[it.data.ixClass];
                    else
                        out.subclass = this._filterCache.allData[it.data.ixClass].subclasses[it.data.ixSubclass];
                }
                );
                resolve(MiscUtil.copy(out));

                doClose(true);

                ModalFilterClasses$1._doListDeselectAll(this._filterCache.list);
            }
            );

            this._ixPrevSelectedClass = selectedClass != null ? this._filterCache.allData.findIndex(it=>it.name === selectedClass.name && it.source === selectedClass.source) : null;
            this._isClassDisabled = isClassDisabled;
            this._isSubclassDisabled = isSubclassDisabled;
            this._filterCache.list.items.forEach(li=>{
                const isScLi = li.data.ixSubclass != null;
                if (isScLi) {
                    li.data.tglSel.classList.toggle("disabled", this._isSubclassDisabled || (this._isClassDisabled && li.data.ixClass !== this._ixPrevSelectedClass));
                } else {
                    li.data.tglSel.classList.toggle("disabled", this._isClassDisabled);
                }
            }
            );

            if (selectedClass != null) {
                const ixSubclass = ~this._ixPrevSelectedClass && selectedSubclass != null ? this._filterCache.allData[this._ixPrevSelectedClass].subclasses.findIndex(it=>it.name === selectedSubclass.name && it.source === selectedSubclass.source) : -1;

                if (~this._ixPrevSelectedClass) {
                    ModalFilterClasses$1._doListDeselectAll(this._filterCache.list);

                    const clsItem = this._filterCache.list.items.find(it=>it.data.ixClass === this._ixPrevSelectedClass && it.data.ixSubclass == null);
                    if (clsItem) {
                        clsItem.data.tglSel.classList.add("active");
                        clsItem.ele.classList.add("list-multi-selected");
                    }

                    if (~ixSubclass && clsItem) {
                        const scItem = this._filterCache.list.items.find(it=>it.data.ixClass === this._ixPrevSelectedClass && it.data.ixSubclass === ixSubclass);
                        scItem.data.tglSel.classList.add("active");
                        scItem.ele.classList.add("list-multi-selected");
                    }
                }

                this._filterCache.list.setFnSearch((li,searchTerm)=>{
                    if (li.data.ixClass !== this._ixPrevSelectedClass)
                        return false;
                    return List.isVisibleDefaultSearch(li, searchTerm);
                }
                );
            } else {
                this._filterCache.list.setFnSearch(null);
            }

            this._filterCache.list.update();

            await UiUtil.pDoForceFocus(this._filterCache.$iptSearch[0]);
        }
        );
    }

    async pPreloadHidden($modalInner) {
        $modalInner = $modalInner || $(`<div></div>`);

        if (this._filterCache) {
            this._filterCache.$wrpModalInner.appendTo($modalInner);
        } else {
            await this._pInit();

            const $ovlLoading = $(`<div class="w-100 h-100 ve-flex-vh-center"><i class="dnd-font ve-muted">Loading...</i></div>`).appendTo($modalInner);

            const $iptSearch = $(`<input class="form-control h-100" type="search" placeholder="Search...">`);
            const $btnReset = $(`<button class="btn btn-default">Reset</button>`);
            const $wrpFormTop = $$`<div class="ve-flex input-group btn-group w-100 lst__form-top">${$iptSearch}${$btnReset}</div>`;

            const $wrpFormBottom = $(`<div class="w-100"></div>`);

            const $wrpFormHeaders = $(`<div class="input-group input-group--bottom ve-flex no-shrink">
				<div class="btn btn-default disabled col-1 pl-0"></div>
				<button class="col-9 sort btn btn-default btn-xs" data-sort="name">Name</button>
				<button class="col-2 pr-0 sort btn btn-default btn-xs ve-grow" data-sort="source">Source</button>
			</div>`);

            const $wrpForm = $$`<div class="ve-flex-col w-100 mb-2">${$wrpFormTop}${$wrpFormBottom}${$wrpFormHeaders}</div>`;
            const $wrpList = this._$getWrpList();

            const $btnConfirm = $(`<button class="btn btn-default">Confirm</button>`);

            const list = new List({
                $iptSearch,
                $wrpList,
                fnSort: this._fnSort,
            });

            SortUtil.initBtnSortHandlers($wrpFormHeaders, list);

            const allData = this._allData || await this._pLoadAllData();
            const pageFilter = this._pageFilter;

            await pageFilter.pInitFilterBox({
                $wrpFormTop,
                $btnReset,
                $wrpMiniPills: $wrpFormBottom,
                namespace: this._namespace,
            });

            allData.forEach((it,i)=>{
                pageFilter.mutateAndAddToFilters(it);
                const filterListItems = this._getListItems(pageFilter, it, i);
                filterListItems.forEach(li=>{
                    list.addItem(li);
                    li.ele.addEventListener("click", evt=>{
                        const isScLi = li.data.ixSubclass != null;

                        if (isScLi) {
                            if (this._isSubclassDisabled)
                                return;
                            if (this._isClassDisabled && li.data.ixClass !== this._ixPrevSelectedClass)
                                return;
                        } else {
                            if (this._isClassDisabled)
                                return;
                        }

                        this._handleSelectClick({
                            list,
                            filterListItems,
                            filterListItem: li,
                            evt,
                        });
                    }
                    );
                }
                );
            }
            );

            list.init();
            list.update();

            const handleFilterChange = ()=>{
                return this.constructor.handleFilterChange({
                    pageFilter,
                    list,
                    allData
                });
            }
            ;

            pageFilter.trimState();

            pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, handleFilterChange);
            pageFilter.filterBox.render();
            handleFilterChange();

            $ovlLoading.remove();

            const $wrpModalInner = $$`<div class="ve-flex-col h-100">
				${$wrpForm}
				${$wrpList}
				<div class="ve-flex-vh-center">${$btnConfirm}</div>
			</div>`.appendTo($modalInner);

            this._filterCache = {
                $wrpModalInner,
                $btnConfirm,
                pageFilter,
                list,
                allData,
                $iptSearch
            };
        }
    }

    static handleFilterChange({pageFilter, list, allData}) {
        const f = pageFilter.filterBox.getValues();

        list.filter(li=>{
            const cls = allData[li.data.ixClass];

            if (li.data.ixSubclass != null) {
                const sc = cls.subclasses[li.data.ixSubclass];
                if (!pageFilter.toDisplay(f, cls, [], null, ))
                    return false;

                return pageFilter.filterBox.toDisplay(f, sc.source, sc._fMisc, null, );
            }

            return pageFilter.toDisplay(f, cls, [], null);
        }
        );
    }

    static _doListDeselectAll(list, {isSubclassItemsOnly=false}={}) {
        list.items.forEach(it=>{
            if (isSubclassItemsOnly && it.data.ixSubclass == null)
                return;

            if (it.data.tglSel)
                it.data.tglSel.classList.remove("active");
            it.ele.classList.remove("list-multi-selected");
        }
        );
    }

    _handleSelectClick({list, filterListItems, filterListItem, evt}) {
        evt.preventDefault();
        evt.stopPropagation();

        const isScLi = filterListItem.data.ixSubclass != null;

        if (this._isClassDisabled && this._ixPrevSelectedClass != null && isScLi) {
            if (!filterListItem.data.tglSel.classList.contains("active"))
                this.constructor._doListDeselectAll(list, {
                    isSubclassItemsOnly: true
                });
            filterListItem.data.tglSel.classList.toggle("active");
            filterListItem.ele.classList.toggle("list-multi-selected");
            return;
        }

        if (filterListItem.data.tglSel.classList.contains("active")) {
            this.constructor._doListDeselectAll(list);
            return;
        }

        this.constructor._doListDeselectAll(list);

        if (isScLi) {
            const classItem = filterListItems[0];
            classItem.data.tglSel.classList.add("active");
            classItem.ele.classList.add("list-multi-selected");
        }

        filterListItem.data.tglSel.classList.add("active");
        filterListItem.ele.classList.add("list-multi-selected");
    }

    async _pLoadAllData() {
        this._pLoadingAllData = this._pLoadingAllData || (async()=>{
            const [data,prerelease,brew] = await Promise.all([MiscUtil.copy(await DataUtil.class.loadRawJSON()), PrereleaseUtil.pGetBrewProcessed(), BrewUtil2.pGetBrewProcessed(), ]);

            this._pLoadAllData_mutAddPrereleaseBrew({
                data,
                brew: prerelease,
                brewUtil: PrereleaseUtil
            });
            this._pLoadAllData_mutAddPrereleaseBrew({
                data,
                brew: brew,
                brewUtil: BrewUtil2
            });

            this._allData = (await PageFilterClassesRaw$1.pPostLoad(data)).class;
        }
        )();

        await this._pLoadingAllData;
        return this._allData;
    }

    _pLoadAllData_mutAddPrereleaseBrew({data, brew, brewUtil}) {
        const clsProps = brewUtil.getPageProps({
            page: UrlUtil.PG_CLASSES
        });

        if (!clsProps.includes("*")) {
            clsProps.forEach(prop=>data[prop] = [...(data[prop] || []), ...MiscUtil.copy(brew[prop] || [])]);
            return;
        }

        Object.entries(brew).filter(([,brewVal])=>brewVal instanceof Array).forEach(([prop,brewArr])=>data[prop] = [...(data[prop] || []), ...MiscUtil.copy(brewArr)]);
    }

    _getListItems(pageFilter, cls, clsI) {
        return [this._getListItems_getClassItem(pageFilter, cls, clsI), ...cls.subclasses.map((sc,scI)=>this._getListItems_getSubclassItem(pageFilter, cls, clsI, sc, scI)), ];
    }

    _getListItems_getClassItem(pageFilter, cls, clsI) {
        const eleLabel = document.createElement("label");
        eleLabel.className = `w-100 ve-flex lst--border veapp__list-row no-select lst__wrp-cells`;

        const source = Parser.sourceJsonToAbv(cls.source);

        eleLabel.innerHTML = `<div class="col-1 pl-0 ve-flex-vh-center"><div class="fltr-cls__tgl"></div></div>
		<div class="bold col-9 ${cls._versionBase_isVersion ? "italic" : ""}">${cls._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${cls.name}</div>
		<div class="col-2 pr-0 ve-text-center ${Parser.sourceJsonToColor(cls.source)}" title="${Parser.sourceJsonToFull(cls.source)}" ${Parser.sourceJsonToStyle(cls.source)}>${source}</div>`;

        return new ListItem(clsI,eleLabel,`${cls.name} -- ${cls.source}`,{
            source: `${source} -- ${cls.name}`,
        },{
            ixClass: clsI,
            tglSel: eleLabel.firstElementChild.firstElementChild,
        },);
    }

    _getListItems_getSubclassItem(pageFilter, cls, clsI, sc, scI) {
        const eleLabel = document.createElement("label");
        eleLabel.className = `w-100 ve-flex lst--border veapp__list-row no-select lst__wrp-cells`;

        const source = Parser.sourceJsonToAbv(sc.source);

        eleLabel.innerHTML = `<div class="col-1 pl-0 ve-flex-vh-center"><div class="fltr-cls__tgl"></div></div>
		<div class="col-9 pl-1 ve-flex-v-center ${sc._versionBase_isVersion ? "italic" : ""}">${sc._versionBase_isVersion ? `<span class="px-3"></span>` : ""}<span class="mx-3">\u2014</span> ${sc.name}</div>
		<div class="col-2 pr-0 ve-text-center ${Parser.sourceJsonToColor(sc.source)}" title="${Parser.sourceJsonToFull(sc.source)}" ${Parser.sourceJsonToStyle(sc.source)}>${source}</div>`;

        return new ListItem(`${clsI}--${scI}`,eleLabel,`${cls.name} -- ${cls.source} -- ${sc.name} -- ${sc.source}`,{
            source: `${cls.source} -- ${cls.name} -- ${source} -- ${sc.name}`,
        },{
            ixClass: clsI,
            ixSubclass: scI,
            tglSel: eleLabel.firstElementChild.firstElementChild,
        },);
    }
}
//#endregion

class MixedModalFilterFvtt //extends Cls
{
    constructor(...args) {
        //super(...args);

        this._prevApp = null;
    }

    _getNameStyle() {
        return "";
    }

    _getShowModal(resolve) {
        if (this._prevApp)
            this._prevApp.close();

        const self = this;

        const app = new class TempApplication extends Application {
            constructor() {
                super({
                    title: `Filter/Search for ${self._modalTitle}`,
                    template: `${SharedConsts.MODULE_LOCATION}/template/_Generic.hbs`,
                    width: Util.getMaxWindowWidth(900),
                    height: Util.getMaxWindowHeight(),
                    resizable: true,
                });

                this._$wrpHtmlInner = $(`<div class="ve-flex-col w-100 h-100"></div>`);
            }

            get $modalInner() {
                return this._$wrpHtmlInner;
            }

            async close(...args) {
                self._filterCache.$wrpModalInner.detach();
                await super.close(...args);
                resolve([]);
            }

            activateListeners($html) {
                this._$wrpHtmlInner.appendTo($html);
            }
        }
        ();

        app.render(true);
        this._prevApp = app;

        return {
            $modalInner: app.$modalInner,
            doClose: app.close.bind(app)
        };
    }

    getDataFromSelected(selected) {
        return this._allData[selected.ix];
    }
}
//Cls is an input class we choose to extend
function MixinModalFilterFvtt(Cls) {
    class MixedModalFilterFvtt extends Cls {
        constructor(...args) {
            super(...args);

            this._prevApp = null;
        }

        _getNameStyle() {
            return "";
        }

        _getShowModal(resolve) {
            if (this._prevApp)
                this._prevApp.close();

            const self = this;

            const app = new class TempApplication extends Application {
                constructor() {
                    super({
                        title: `Filter/Search for ${self._modalTitle}`,
                        template: `${SharedConsts.MODULE_LOCATION}/template/_Generic.hbs`,
                        width: Util.getMaxWindowWidth(900),
                        height: Util.getMaxWindowHeight(),
                        resizable: true,
                    });

                    this._$wrpHtmlInner = $(`<div class="ve-flex-col w-100 h-100"></div>`);
                }

                get $modalInner() {
                    return this._$wrpHtmlInner;
                }

                async close(...args) {
                    self._filterCache.$wrpModalInner.detach();
                    await super.close(...args);
                    resolve([]);
                }

                activateListeners($html) {
                    this._$wrpHtmlInner.appendTo($html);
                }
            }
            ();

            app.render(true);
            this._prevApp = app;

            return {
                $modalInner: app.$modalInner,
                doClose: app.close.bind(app)
            };
        }

        getDataFromSelected(selected) {
            return this._allData[selected.ix];
        }
    }
    return MixedModalFilterFvtt;
}
class ModalFilterClassesFvtt extends MixinModalFilterFvtt(ModalFilterClasses) {
}
//#endregion


