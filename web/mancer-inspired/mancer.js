
document.addEventListener('DOMContentLoaded', function () {
    JqueryUtil.initEnhancements();
    //test_AddClassPage();
});
window.addEventListener('load', function () {
   
    /* createPage_ClassSelect();
    addNewClassChoiceSection();
    let exportBtn = $(document).find("#btn_export");
    exportBtn.on('click', () => {
        e_onPressExportButton();
    }); */
    test_AddClassPage();

    
});

function test_AddClassPage(){
    let window = new ParentWindow($(`.left-content`));
    window.data = ContentGetter._getBase();
    let comp = new ActorCharactermancerClass(window);
    //Lets try to add it to our DOM
    comp.render();
}
class SETTINGS{
    static FILTERS = false;
    static PARENTLESS_MODE = true;
}
class ParentWindow {
    tabClass;
    constructor(parentDiv){
        this.tabClass = new WindowTab(parentDiv);
    }
}
/**Don't think of this as a tab button, but more as a tab screen */
class WindowTab {
    $wrpTab;
    constructor(parentDiv){
        this.$wrpTab = parentDiv;
    }
}

//#region Parser
globalThis.Parser = {};
Parser._parse_aToB = function(abMap, a, fallback) {
    if (a === undefined || a === null)
        throw new TypeError("undefined or null object passed to parser");
    if (typeof a === "string")
        a = a.trim();
    if (abMap[a] !== undefined)
        return abMap[a];
    return fallback !== undefined ? fallback : a;
}
;

Parser._parse_bToA = function(abMap, b, fallback) {
    if (b === undefined || b === null)
        throw new TypeError("undefined or null object passed to parser");
    if (typeof b === "string")
        b = b.trim();
    for (const v in abMap) {
        if (!abMap.hasOwnProperty(v))
            continue;
        if (abMap[v] === b)
            return v;
    }
    return fallback !== undefined ? fallback : b;
}
;

Parser.attrChooseToFull = function(attList) {
    if (attList.length === 1)
        return `${Parser.attAbvToFull(attList[0])} modifier`;
    else {
        const attsTemp = [];
        for (let i = 0; i < attList.length; ++i) {
            attsTemp.push(Parser.attAbvToFull(attList[i]));
        }
        return `${attsTemp.join(" or ")} modifier (your choice)`;
    }
}
;

Parser.numberToText = function(number) {
    if (number == null)
        throw new TypeError(`undefined or null object passed to parser`);
    if (Math.abs(number) >= 100)
        return `${number}`;

    return `${number < 0 ? "negative " : ""}${Parser.numberToText._getPositiveNumberAsText(Math.abs(number))}`;
}
;

Parser.numberToText._getPositiveNumberAsText = num=>{
    const [preDotRaw,postDotRaw] = `${num}`.split(".");

    if (!postDotRaw)
        return Parser.numberToText._getPositiveIntegerAsText(num);

    let preDot = preDotRaw === "0" ? "" : `${Parser.numberToText._getPositiveIntegerAsText(Math.trunc(num))} and `;

    switch (postDotRaw) {
    case "125":
        return `${preDot}one-eighth`;
    case "2":
        return `${preDot}one-fifth`;
    case "25":
        return `${preDot}one-quarter`;
    case "375":
        return `${preDot}three-eighths`;
    case "4":
        return `${preDot}two-fifths`;
    case "5":
        return `${preDot}one-half`;
    case "6":
        return `${preDot}three-fifths`;
    case "625":
        return `${preDot}five-eighths`;
    case "75":
        return `${preDot}three-quarters`;
    case "8":
        return `${preDot}four-fifths`;
    case "875":
        return `${preDot}seven-eighths`;

    default:
        {
            const asNum = Number(`0.${postDotRaw}`);

            if (asNum.toFixed(2) === (1 / 3).toFixed(2))
                return `${preDot}one-third`;
            if (asNum.toFixed(2) === (2 / 3).toFixed(2))
                return `${preDot}two-thirds`;

            if (asNum.toFixed(2) === (1 / 6).toFixed(2))
                return `${preDot}one-sixth`;
            if (asNum.toFixed(2) === (5 / 6).toFixed(2))
                return `${preDot}five-sixths`;
        }
    }
}
;

Parser.numberToText._getPositiveIntegerAsText = num=>{
    switch (num) {
    case 0:
        return "zero";
    case 1:
        return "one";
    case 2:
        return "two";
    case 3:
        return "three";
    case 4:
        return "four";
    case 5:
        return "five";
    case 6:
        return "six";
    case 7:
        return "seven";
    case 8:
        return "eight";
    case 9:
        return "nine";
    case 10:
        return "ten";
    case 11:
        return "eleven";
    case 12:
        return "twelve";
    case 13:
        return "thirteen";
    case 14:
        return "fourteen";
    case 15:
        return "fifteen";
    case 16:
        return "sixteen";
    case 17:
        return "seventeen";
    case 18:
        return "eighteen";
    case 19:
        return "nineteen";
    case 20:
        return "twenty";
    case 30:
        return "thirty";
    case 40:
        return "forty";
    case 50:
        return "fifty";
    case 60:
        return "sixty";
    case 70:
        return "seventy";
    case 80:
        return "eighty";
    case 90:
        return "ninety";
    default:
        {
            const str = String(num);
            return `${Parser.numberToText._getPositiveIntegerAsText(Number(`${str[0]}0`))}-${Parser.numberToText._getPositiveIntegerAsText(Number(str[1]))}`;
        }
    }
}
;

Parser.textToNumber = function(str) {
    str = str.trim().toLowerCase();
    if (!isNaN(str))
        return Number(str);
    switch (str) {
    case "zero":
        return 0;
    case "one":
    case "a":
    case "an":
        return 1;
    case "two":
    case "double":
        return 2;
    case "three":
    case "triple":
        return 3;
    case "four":
    case "quadruple":
        return 4;
    case "five":
        return 5;
    case "six":
        return 6;
    case "seven":
        return 7;
    case "eight":
        return 8;
    case "nine":
        return 9;
    case "ten":
        return 10;
    case "eleven":
        return 11;
    case "twelve":
        return 12;
    case "thirteen":
        return 13;
    case "fourteen":
        return 14;
    case "fifteen":
        return 15;
    case "sixteen":
        return 16;
    case "seventeen":
        return 17;
    case "eighteen":
        return 18;
    case "nineteen":
        return 19;
    case "twenty":
        return 20;
    case "thirty":
        return 30;
    case "forty":
        return 40;
    case "fifty":
        return 50;
    case "sixty":
        return 60;
    case "seventy":
        return 70;
    case "eighty":
        return 80;
    case "ninety":
        return 90;
    }
    return NaN;
}
;

Parser.numberToVulgar = function(number, {isFallbackOnFractional=true}={}) {
    const isNeg = number < 0;
    const spl = `${number}`.replace(/^-/, "").split(".");
    if (spl.length === 1)
        return number;

    let preDot = spl[0] === "0" ? "" : spl[0];
    if (isNeg)
        preDot = `-${preDot}`;

    switch (spl[1]) {
    case "125":
        return `${preDot}⅛`;
    case "2":
        return `${preDot}⅕`;
    case "25":
        return `${preDot}¼`;
    case "375":
        return `${preDot}⅜`;
    case "4":
        return `${preDot}⅖`;
    case "5":
        return `${preDot}½`;
    case "6":
        return `${preDot}⅗`;
    case "625":
        return `${preDot}⅝`;
    case "75":
        return `${preDot}¾`;
    case "8":
        return `${preDot}⅘`;
    case "875":
        return `${preDot}⅞`;

    default:
        {
            const asNum = Number(`0.${spl[1]}`);

            if (asNum.toFixed(2) === (1 / 3).toFixed(2))
                return `${preDot}⅓`;
            if (asNum.toFixed(2) === (2 / 3).toFixed(2))
                return `${preDot}⅔`;

            if (asNum.toFixed(2) === (1 / 6).toFixed(2))
                return `${preDot}⅙`;
            if (asNum.toFixed(2) === (5 / 6).toFixed(2))
                return `${preDot}⅚`;
        }
    }

    return isFallbackOnFractional ? Parser.numberToFractional(number) : null;
}
;

Parser.vulgarToNumber = function(str) {
    const [,leading="0",vulgar=""] = /^(\d+)?([⅛¼⅜½⅝¾⅞⅓⅔⅙⅚])?$/.exec(str) || [];
    let out = Number(leading);
    switch (vulgar) {
    case "⅛":
        out += 0.125;
        break;
    case "¼":
        out += 0.25;
        break;
    case "⅜":
        out += 0.375;
        break;
    case "½":
        out += 0.5;
        break;
    case "⅝":
        out += 0.625;
        break;
    case "¾":
        out += 0.75;
        break;
    case "⅞":
        out += 0.875;
        break;
    case "⅓":
        out += 1 / 3;
        break;
    case "⅔":
        out += 2 / 3;
        break;
    case "⅙":
        out += 1 / 6;
        break;
    case "⅚":
        out += 5 / 6;
        break;
    case "":
        break;
    default:
        throw new Error(`Unhandled vulgar part "${vulgar}"`);
    }
    return out;
}
;

Parser.numberToSuperscript = function(number) {
    return `${number}`.split("").map(c=>isNaN(c) ? c : Parser._NUMBERS_SUPERSCRIPT[Number(c)]).join("");
}
;
Parser._NUMBERS_SUPERSCRIPT = "⁰¹²³⁴⁵⁶⁷⁸⁹";

Parser.numberToSubscript = function(number) {
    return `${number}`.split("").map(c=>isNaN(c) ? c : Parser._NUMBERS_SUBSCRIPT[Number(c)]).join("");
}
;
Parser._NUMBERS_SUBSCRIPT = "₀₁₂₃₄₅₆₇₈₉";

Parser._greatestCommonDivisor = function(a, b) {
    if (b < Number.EPSILON)
        return a;
    return Parser._greatestCommonDivisor(b, Math.floor(a % b));
}
;
Parser.numberToFractional = function(number) {
    const len = number.toString().length - 2;
    let denominator = 10 ** len;
    let numerator = number * denominator;
    const divisor = Parser._greatestCommonDivisor(numerator, denominator);
    numerator = Math.floor(numerator / divisor);
    denominator = Math.floor(denominator / divisor);

    return denominator === 1 ? String(numerator) : `${Math.floor(numerator)}/${Math.floor(denominator)}`;
}
;

Parser.ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

Parser.attAbvToFull = function(abv) {
    return Parser._parse_aToB(Parser.ATB_ABV_TO_FULL, abv);
}
;

Parser.attFullToAbv = function(full) {
    return Parser._parse_bToA(Parser.ATB_ABV_TO_FULL, full);
}
;

Parser.sizeAbvToFull = function(abv) {
    return Parser._parse_aToB(Parser.SIZE_ABV_TO_FULL, abv);
}
;

Parser.getAbilityModNumber = function(abilityScore) {
    return Math.floor((abilityScore - 10) / 2);
}
;

Parser.getAbilityModifier = function(abilityScore) {
    let modifier = Parser.getAbilityModNumber(abilityScore);
    if (modifier >= 0)
        modifier = `+${modifier}`;
    return `${modifier}`;
}
;

Parser.getSpeedString = (ent,{isMetric=false, isSkipZeroWalk=false}={})=>{
    if (ent.speed == null)
        return "\u2014";

    const unit = isMetric ? Parser.metric.getMetricUnit({
        originalUnit: "ft.",
        isShortForm: true
    }) : "ft.";
    if (typeof ent.speed === "object") {
        const stack = [];
        let joiner = ", ";

        Parser.SPEED_MODES.filter(mode=>!ent.speed.hidden?.includes(mode)).forEach(mode=>Parser._getSpeedString_addSpeedMode({
            ent,
            prop: mode,
            stack,
            isMetric,
            isSkipZeroWalk,
            unit
        }));

        if (ent.speed.choose && !ent.speed.hidden?.includes("choose")) {
            joiner = "; ";
            stack.push(`${ent.speed.choose.from.sort().joinConjunct(", ", " or ")} ${ent.speed.choose.amount} ${unit}${ent.speed.choose.note ? ` ${ent.speed.choose.note}` : ""}`);
        }

        return stack.join(joiner) + (ent.speed.note ? ` ${ent.speed.note}` : "");
    }

    return (isMetric ? Parser.metric.getMetricNumber({
        originalValue: ent.speed,
        originalUnit: Parser.UNT_FEET
    }) : ent.speed) + (ent.speed === "Varies" ? "" : ` ${unit} `);
}
;
Parser._getSpeedString_addSpeedMode = ({ent, prop, stack, isMetric, isSkipZeroWalk, unit})=>{
    if (ent.speed[prop] || (!isSkipZeroWalk && prop === "walk"))
        Parser._getSpeedString_addSpeed({
            prop,
            speed: ent.speed[prop] || 0,
            isMetric,
            unit,
            stack
        });
    if (ent.speed.alternate && ent.speed.alternate[prop])
        ent.speed.alternate[prop].forEach(speed=>Parser._getSpeedString_addSpeed({
            prop,
            speed,
            isMetric,
            unit,
            stack
        }));
}
;
Parser._getSpeedString_addSpeed = ({prop, speed, isMetric, unit, stack})=>{
    const ptName = prop === "walk" ? "" : `${prop} `;
    const ptValue = Parser._getSpeedString_getVal({
        prop,
        speed,
        isMetric
    });
    const ptUnit = speed === true ? "" : ` ${unit}`;
    const ptCondition = Parser._getSpeedString_getCondition({
        speed
    });
    stack.push([ptName, ptValue, ptUnit, ptCondition].join(""));
}
;
Parser._getSpeedString_getVal = ({prop, speed, isMetric})=>{
    if (speed === true && prop !== "walk")
        return "equal to your walking speed";

    const num = speed === true ? 0 : speed.number != null ? speed.number : speed;

    return isMetric ? Parser.metric.getMetricNumber({
        originalValue: num,
        originalUnit: Parser.UNT_FEET
    }) : num;
}
;
Parser._getSpeedString_getCondition = ({speed})=>speed.condition ? ` ${Renderer.get().render(speed.condition)}` : "";

Parser.SPEED_MODES = ["walk", "burrow", "climb", "fly", "swim"];

Parser.SPEED_TO_PROGRESSIVE = {
    "walk": "walking",
    "burrow": "burrowing",
    "climb": "climbing",
    "fly": "flying",
    "swim": "swimming",
};

Parser.speedToProgressive = function(prop) {
    return Parser._parse_aToB(Parser.SPEED_TO_PROGRESSIVE, prop);
}
;

Parser._addCommas = function(intNum) {
    return `${intNum}`.replace(/(\d)(?=(\d{3})+$)/g, "$1,");
}
;

Parser.raceCreatureTypesToFull = function(creatureTypes) {
    const hasSubOptions = creatureTypes.some(it=>it.choose);
    return creatureTypes.map(it=>{
        if (!it.choose)
            return Parser.monTypeToFullObj(it).asText;
        return [...it.choose].sort(SortUtil.ascSortLower).map(sub=>Parser.monTypeToFullObj(sub).asText).joinConjunct(", ", " or ");
    }
    ).joinConjunct(hasSubOptions ? "; " : ", ", " and ");
}
;

Parser.crToXp = function(cr, {isDouble=false}={}) {
    if (cr != null && cr.xp)
        return Parser._addCommas(`${isDouble ? cr.xp * 2 : cr.xp}`);

    const toConvert = cr ? (cr.cr || cr) : null;
    if (toConvert === "Unknown" || toConvert == null || !Parser.XP_CHART_ALT[toConvert])
        return "Unknown";
    if (toConvert === "0")
        return "10";
    const xp = Parser.XP_CHART_ALT[toConvert];
    return Parser._addCommas(`${isDouble ? 2 * xp : xp}`);
}
;

Parser.crToXpNumber = function(cr) {
    if (cr != null && cr.xp)
        return cr.xp;
    const toConvert = cr ? (cr.cr || cr) : cr;
    if (toConvert === "Unknown" || toConvert == null)
        return null;
    return Parser.XP_CHART_ALT[toConvert] ?? null;
}
;

Parser.LEVEL_TO_XP_EASY = [0, 25, 50, 75, 125, 250, 300, 350, 450, 550, 600, 800, 1000, 1100, 1250, 1400, 1600, 2000, 2100, 2400, 2800];
Parser.LEVEL_TO_XP_MEDIUM = [0, 50, 100, 150, 250, 500, 600, 750, 900, 1100, 1200, 1600, 2000, 2200, 2500, 2800, 3200, 3900, 4100, 4900, 5700];
Parser.LEVEL_TO_XP_HARD = [0, 75, 150, 225, 375, 750, 900, 1100, 1400, 1600, 1900, 2400, 3000, 3400, 3800, 4300, 4800, 5900, 6300, 7300, 8500];
Parser.LEVEL_TO_XP_DEADLY = [0, 100, 200, 400, 500, 1100, 1400, 1700, 2100, 2400, 2800, 3600, 4500, 5100, 5700, 6400, 7200, 8800, 9500, 10900, 12700];
Parser.LEVEL_TO_XP_DAILY = [0, 300, 600, 1200, 1700, 3500, 4000, 5000, 6000, 7500, 9000, 10500, 11500, 13500, 15000, 18000, 20000, 25000, 27000, 30000, 40000];

Parser.LEVEL_XP_REQUIRED = [0, 300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000];

Parser.CRS = ["0", "1/8", "1/4", "1/2", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30"];

Parser.levelToXpThreshold = function(level) {
    return [Parser.LEVEL_TO_XP_EASY[level], Parser.LEVEL_TO_XP_MEDIUM[level], Parser.LEVEL_TO_XP_HARD[level], Parser.LEVEL_TO_XP_DEADLY[level]];
}
;

Parser.isValidCr = function(cr) {
    return Parser.CRS.includes(cr);
}
;

Parser.crToNumber = function(cr, opts={}) {
    const {isDefaultNull=false} = opts;

    if (cr === "Unknown" || cr === "\u2014" || cr == null)
        return isDefaultNull ? null : VeCt.CR_UNKNOWN;
    if (cr.cr)
        return Parser.crToNumber(cr.cr, opts);

    const parts = cr.trim().split("/");
    if (!parts.length || parts.length >= 3)
        return isDefaultNull ? null : VeCt.CR_CUSTOM;
    if (isNaN(parts[0]))
        return isDefaultNull ? null : VeCt.CR_CUSTOM;

    if (parts.length === 2) {
        if (isNaN(Number(parts[1])))
            return isDefaultNull ? null : VeCt.CR_CUSTOM;
        return Number(parts[0]) / Number(parts[1]);
    }

    return Number(parts[0]);
}
;

Parser.numberToCr = function(number, safe) {
    if (safe && typeof number === "string" && Parser.CRS.includes(number))
        return number;

    if (number == null)
        return "Unknown";

    return Parser.numberToFractional(number);
}
;

Parser.crToPb = function(cr) {
    if (cr === "Unknown" || cr == null)
        return 0;
    cr = cr.cr || cr;
    if (Parser.crToNumber(cr) < 5)
        return 2;
    return Math.ceil(cr / 4) + 1;
}
;

Parser.levelToPb = function(level) {
    if (!level)
        return 2;
    return Math.ceil(level / 4) + 1;
}
;
Parser.SKILL_TO_ATB_ABV = {
    "athletics": "str",
    "acrobatics": "dex",
    "sleight of hand": "dex",
    "stealth": "dex",
    "arcana": "int",
    "history": "int",
    "investigation": "int",
    "nature": "int",
    "religion": "int",
    "animal handling": "wis",
    "insight": "wis",
    "medicine": "wis",
    "perception": "wis",
    "survival": "wis",
    "deception": "cha",
    "intimidation": "cha",
    "performance": "cha",
    "persuasion": "cha",
};


Parser.skillToAbilityAbv = function(skill) {
    return Parser._parse_aToB(Parser.SKILL_TO_ATB_ABV, skill);
}
;

Parser.SKILL_TO_SHORT = {
    "athletics": "ath",
    "acrobatics": "acro",
    "sleight of hand": "soh",
    "stealth": "slth",
    "arcana": "arc",
    "history": "hist",
    "investigation": "invn",
    "nature": "natr",
    "religion": "reli",
    "animal handling": "hndl",
    "insight": "ins",
    "medicine": "med",
    "perception": "perp",
    "survival": "surv",
    "deception": "decp",
    "intimidation": "intm",
    "performance": "perf",
    "persuasion": "pers",
};

Parser.skillToShort = function(skill) {
    return Parser._parse_aToB(Parser.SKILL_TO_SHORT, skill);
}
;

Parser.LANGUAGES_STANDARD = ["Common", "Dwarvish", "Elvish", "Giant", "Gnomish", "Goblin", "Halfling", "Orc", ];

Parser.LANGUAGES_EXOTIC = ["Abyssal", "Aquan", "Auran", "Celestial", "Draconic", "Deep Speech", "Ignan", "Infernal", "Primordial", "Sylvan", "Terran", "Undercommon", ];

Parser.LANGUAGES_SECRET = ["Druidic", "Thieves' cant", ];

Parser.LANGUAGES_ALL = [...Parser.LANGUAGES_STANDARD, ...Parser.LANGUAGES_EXOTIC, ...Parser.LANGUAGES_SECRET, ].sort();

Parser.acToFull = function(ac, renderer) {
    if (typeof ac === "string")
        return ac;
    renderer = renderer || Renderer.get();

    let stack = "";
    let inBraces = false;
    for (let i = 0; i < ac.length; ++i) {
        const cur = ac[i];
        const nxt = ac[i + 1];

        if (cur.special != null) {
            if (inBraces)
                inBraces = false;

            stack += cur.special;
        } else if (cur.ac) {
            const isNxtBraces = nxt && nxt.braces;

            if (!inBraces && cur.braces) {
                stack += "(";
                inBraces = true;
            }

            stack += cur.ac;

            if (cur.from) {
                if (cur.braces) {
                    stack += " (";
                } else {
                    stack += inBraces ? "; " : " (";
                }

                inBraces = true;

                stack += cur.from.map(it=>renderer.render(it)).join(", ");

                if (cur.braces) {
                    stack += ")";
                } else if (!isNxtBraces) {
                    stack += ")";
                    inBraces = false;
                }
            }

            if (cur.condition)
                stack += ` ${renderer.render(cur.condition)}`;

            if (inBraces && !isNxtBraces) {
                stack += ")";
                inBraces = false;
            }
        } else {
            stack += cur;
        }

        if (nxt) {
            if (nxt.braces) {
                stack += inBraces ? "; " : " (";
                inBraces = true;
            } else
                stack += ", ";
        }
    }
    if (inBraces)
        stack += ")";

    return stack.trim();
}
;

Parser.MONSTER_COUNT_TO_XP_MULTIPLIER = [1, 1.5, 2, 2, 2, 2, 2.5, 2.5, 2.5, 2.5, 3, 3, 3, 3, 4];
Parser.numMonstersToXpMult = function(num, playerCount=3) {
    const baseVal = (()=>{
        if (num >= Parser.MONSTER_COUNT_TO_XP_MULTIPLIER.length)
            return 4;
        return Parser.MONSTER_COUNT_TO_XP_MULTIPLIER[num - 1];
    }
    )();

    if (playerCount < 3)
        return baseVal >= 3 ? baseVal + 1 : baseVal + 0.5;
    else if (playerCount > 5) {
        return baseVal === 4 ? 3 : baseVal - 0.5;
    } else
        return baseVal;
}
;

Parser.armorFullToAbv = function(armor) {
    return Parser._parse_bToA(Parser.ARMOR_ABV_TO_FULL, armor);
}
;

Parser.weaponFullToAbv = function(weapon) {
    return Parser._parse_bToA(Parser.WEAPON_ABV_TO_FULL, weapon);
}
;

Parser._getSourceStringFromSource = function(source) {
    if (source && source.source)
        return source.source;
    return source;
}
;
Parser._buildSourceCache = function(dict) {
    const out = {};
    Object.entries(dict).forEach(([k,v])=>out[k.toLowerCase()] = v);
    return out;
}
;
Parser._sourceJsonCache = null;
Parser.hasSourceJson = function(source) {
    Parser._sourceJsonCache = Parser._sourceJsonCache || Parser._buildSourceCache(Object.keys(Parser.SOURCE_JSON_TO_FULL).mergeMap(k=>({
        [k]: k
    })));
    return !!Parser._sourceJsonCache[source.toLowerCase()];
}
;
Parser._sourceFullCache = null;
Parser.hasSourceFull = function(source) {
    Parser._sourceFullCache = Parser._sourceFullCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_FULL);
    return !!Parser._sourceFullCache[source.toLowerCase()];
}
;
Parser._sourceAbvCache = null;
Parser.hasSourceAbv = function(source) {
    Parser._sourceAbvCache = Parser._sourceAbvCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_ABV);
    return !!Parser._sourceAbvCache[source.toLowerCase()];
}
;
Parser._sourceDateCache = null;
Parser.hasSourceDate = function(source) {
    Parser._sourceDateCache = Parser._sourceDateCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_DATE);
    return !!Parser._sourceDateCache[source.toLowerCase()];
}
;
Parser.sourceJsonToJson = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceJson(source))
        return Parser._sourceJsonCache[source.toLowerCase()];
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToSource(source).json;
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToSource(source).json;
    return source;
}
;
Parser.sourceJsonToFull = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceFull(source))
        return Parser._sourceFullCache[source.toLowerCase()].replace(/'/g, "\u2019");
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToFull(source).replace(/'/g, "\u2019");
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToFull(source).replace(/'/g, "\u2019");
    return Parser._parse_aToB(Parser.SOURCE_JSON_TO_FULL, source).replace(/'/g, "\u2019");
}
;
Parser.sourceJsonToFullCompactPrefix = function(source) {
    return Parser.sourceJsonToFull(source).replace(Parser.UA_PREFIX, Parser.UA_PREFIX_SHORT).replace(/^Unearthed Arcana (\d+): /, "UA$1: ").replace(Parser.AL_PREFIX, Parser.AL_PREFIX_SHORT).replace(Parser.PS_PREFIX, Parser.PS_PREFIX_SHORT);
}
;
Parser.sourceJsonToAbv = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceAbv(source))
        return Parser._sourceAbvCache[source.toLowerCase()];
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToAbv(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToAbv(source);
    return Parser._parse_aToB(Parser.SOURCE_JSON_TO_ABV, source);
}
;
Parser.sourceJsonToDate = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceDate(source))
        return Parser._sourceDateCache[source.toLowerCase()];
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToDate(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToDate(source);
    return Parser._parse_aToB(Parser.SOURCE_JSON_TO_DATE, source, null);
}
;

Parser.sourceJsonToColor = function(source) {
    return `source${Parser.sourceJsonToAbv(source)}`;
}
;

Parser.sourceJsonToStyle = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceJson(source))
        return "";
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToStyle(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToStyle(source);
    return "";
}
;

Parser.sourceJsonToStylePart = function(source) {
    source = Parser._getSourceStringFromSource(source);
    if (Parser.hasSourceJson(source))
        return "";
    if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
        return PrereleaseUtil.sourceJsonToStylePart(source);
    if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
        return BrewUtil2.sourceJsonToStylePart(source);
    return "";
}
;

Parser.stringToSlug = function(str) {
    return str.trim().toLowerCase().toAscii().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
}
;

Parser.stringToCasedSlug = function(str) {
    return str.toAscii().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
}
;

Parser.ITEM_SPELLCASTING_FOCUS_CLASSES = ["Artificer", "Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"];

Parser.itemValueToFull = function(item, opts={
    isShortForm: false,
    isSmallUnits: false
}) {
    return Parser._moneyToFull(item, "value", "valueMult", opts);
}
;

Parser.itemValueToFullMultiCurrency = function(item, opts={
    isShortForm: false,
    isSmallUnits: false
}) {
    return Parser._moneyToFullMultiCurrency(item, "value", "valueMult", opts);
}
;

Parser.itemVehicleCostsToFull = function(item, isShortForm) {
    return {
        travelCostFull: Parser._moneyToFull(item, "travelCost", "travelCostMult", {
            isShortForm
        }),
        shippingCostFull: Parser._moneyToFull(item, "shippingCost", "shippingCostMult", {
            isShortForm
        }),
    };
}
;

Parser.spellComponentCostToFull = function(item, isShortForm) {
    return Parser._moneyToFull(item, "cost", "costMult", {
        isShortForm
    });
}
;

Parser.vehicleCostToFull = function(item, isShortForm) {
    return Parser._moneyToFull(item, "cost", "costMult", {
        isShortForm
    });
}
;

Parser._moneyToFull = function(it, prop, propMult, opts={
    isShortForm: false,
    isSmallUnits: false
}) {
    if (it[prop] == null && it[propMult] == null)
        return "";
    if (it[prop] != null) {
        const {coin, mult} = Parser.getCurrencyAndMultiplier(it[prop], it.currencyConversion);
        return `${(it[prop] * mult).toLocaleString(undefined, {
            maximumFractionDigits: 5
        })}${opts.isSmallUnits ? `<span class="small ml-1">${coin}</span>` : ` ${coin}`}`;
    } else if (it[propMult] != null)
        return opts.isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;
    return "";
}
;

Parser._moneyToFullMultiCurrency = function(it, prop, propMult, {isShortForm, multiplier}={}) {
    if (it[prop]) {
        const conversionTable = Parser.getCurrencyConversionTable(it.currencyConversion);

        const simplified = it.currencyConversion ? CurrencyUtil.doSimplifyCoins({
            [conversionTable[0]?.coin || "cp"]: it[prop] * (multiplier ?? conversionTable[0]?.mult ?? 1),
        }, {
            currencyConversionId: it.currencyConversion,
        }, ) : CurrencyUtil.doSimplifyCoins({
            cp: it[prop] * (multiplier ?? 1),
        });

        return [...conversionTable].reverse().filter(meta=>simplified[meta.coin]).map(meta=>`${simplified[meta.coin].toLocaleString(undefined, {
            maximumFractionDigits: 5
        })} ${meta.coin}`).join(", ");
    }

    if (it[propMult])
        return isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;

    return "";
}
;

Parser.DEFAULT_CURRENCY_CONVERSION_TABLE = [{
    coin: "cp",
    mult: 1,
}, {
    coin: "sp",
    mult: 0.1,
}, {
    coin: "gp",
    mult: 0.01,
    isFallback: true,
}, ];
Parser.FULL_CURRENCY_CONVERSION_TABLE = [{
    coin: "cp",
    mult: 1,
}, {
    coin: "sp",
    mult: 0.1,
}, {
    coin: "ep",
    mult: 0.02,
}, {
    coin: "gp",
    mult: 0.01,
    isFallback: true,
}, {
    coin: "pp",
    mult: 0.001,
}, ];
Parser.getCurrencyConversionTable = function(currencyConversionId) {
    const fromPrerelease = currencyConversionId ? PrereleaseUtil.getMetaLookup("currencyConversions")?.[currencyConversionId] : null;
    const fromBrew = currencyConversionId ? BrewUtil2.getMetaLookup("currencyConversions")?.[currencyConversionId] : null;
    const conversionTable = fromPrerelease?.length ? fromPrerelease : fromBrew?.length ? fromBrew : Parser.DEFAULT_CURRENCY_CONVERSION_TABLE;
    if (conversionTable !== Parser.DEFAULT_CURRENCY_CONVERSION_TABLE)
        conversionTable.sort((a,b)=>SortUtil.ascSort(b.mult, a.mult));
    return conversionTable;
}
;
Parser.getCurrencyAndMultiplier = function(value, currencyConversionId) {
    const conversionTable = Parser.getCurrencyConversionTable(currencyConversionId);

    if (!value)
        return conversionTable.find(it=>it.isFallback) || conversionTable[0];
    if (conversionTable.length === 1)
        return conversionTable[0];
    if (!Number.isInteger(value) && value < conversionTable[0].mult)
        return conversionTable[0];

    for (let i = conversionTable.length - 1; i >= 0; --i) {
        if (Number.isInteger(value * conversionTable[i].mult))
            return conversionTable[i];
    }

    return conversionTable.last();
}
;

Parser.COIN_ABVS = ["cp", "sp", "ep", "gp", "pp"];
Parser.COIN_ABV_TO_FULL = {
    "cp": "copper pieces",
    "sp": "silver pieces",
    "ep": "electrum pieces",
    "gp": "gold pieces",
    "pp": "platinum pieces",
};
Parser.COIN_CONVERSIONS = [1, 10, 50, 100, 1000];

Parser.coinAbvToFull = function(coin) {
    return Parser._parse_aToB(Parser.COIN_ABV_TO_FULL, coin);
}
;

Parser.getDisplayCurrency = function(currency, {isDisplayEmpty=false}={}) {
    return [...Parser.COIN_ABVS].reverse().filter(abv=>isDisplayEmpty ? currency[abv] != null : currency[abv]).map(abv=>`${currency[abv].toLocaleString()} ${abv}`).join(", ");
}
;

Parser.itemWeightToFull = function(item, isShortForm) {
    if (item.weight) {
        if (Math.round(item.weight) === item.weight)
            return `${item.weight} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

        const integerPart = Math.floor(item.weight);

        const vulgarGlyph = Parser.numberToVulgar(item.weight - integerPart, {
            isFallbackOnFractional: false
        });
        if (vulgarGlyph)
            return `${integerPart || ""}${vulgarGlyph} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

        return `${(item.weight < 1 ? item.weight * 16 : item.weight).toLocaleString(undefined, {
            maximumFractionDigits: 5
        })} ${item.weight < 1 ? "oz" : "lb"}.${(item.weightNote ? ` ${item.weightNote}` : "")}`;
    }
    if (item.weightMult)
        return isShortForm ? `×${item.weightMult}` : `base weight ×${item.weightMult}`;
    return "";
}
;

Parser.ITEM_RECHARGE_TO_FULL = {
    round: "Every Round",
    restShort: "Short Rest",
    restLong: "Long Rest",
    dawn: "Dawn",
    dusk: "Dusk",
    midnight: "Midnight",
    week: "Week",
    month: "Month",
    year: "Year",
    decade: "Decade",
    century: "Century",
    special: "Special",
};
Parser.itemRechargeToFull = function(recharge) {
    return Parser._parse_aToB(Parser.ITEM_RECHARGE_TO_FULL, recharge);
}
;

Parser.ITEM_MISC_TAG_TO_FULL = {
    "CF/W": "Creates Food/Water",
    "TT": "Trinket Table",
};
Parser.itemMiscTagToFull = function(type) {
    return Parser._parse_aToB(Parser.ITEM_MISC_TAG_TO_FULL, type);
}
;

Parser._decimalSeparator = (0.1).toLocaleString().substring(1, 2);
Parser._numberCleanRegexp = Parser._decimalSeparator === "." ? new RegExp(/[\s,]*/g,"g") : new RegExp(/[\s.]*/g,"g");
Parser._costSplitRegexp = Parser._decimalSeparator === "." ? new RegExp(/(\d+(\.\d+)?)([csegp]p)/) : new RegExp(/(\d+(,\d+)?)([csegp]p)/);

Parser.coinValueToNumber = function(value) {
    if (!value)
        return 0;
    if (value === "Varies")
        return 0;

    value = value.replace(/\s*/, "").replace(Parser._numberCleanRegexp, "").toLowerCase();
    const m = Parser._costSplitRegexp.exec(value);
    if (!m)
        throw new Error(`Badly formatted value "${value}"`);
    const ixCoin = Parser.COIN_ABVS.indexOf(m[3]);
    if (!~ixCoin)
        throw new Error(`Unknown coin type "${m[3]}"`);
    return Number(m[1]) * Parser.COIN_CONVERSIONS[ixCoin];
}
;

Parser.weightValueToNumber = function(value) {
    if (!value)
        return 0;

    if (Number(value))
        return Number(value);
    else
        throw new Error(`Badly formatted value ${value}`);
}
;

Parser.dmgTypeToFull = function(dmgType) {
    return Parser._parse_aToB(Parser.DMGTYPE_JSON_TO_FULL, dmgType);
}
;

Parser.skillProficienciesToFull = function(skillProficiencies) {
    function renderSingle(skProf) {
        if (skProf.any) {
            skProf = MiscUtil.copyFast(skProf);
            skProf.choose = {
                "from": Object.keys(Parser.SKILL_TO_ATB_ABV),
                "count": skProf.any
            };
            delete skProf.any;
        }

        const keys = Object.keys(skProf).sort(SortUtil.ascSortLower);

        const ixChoose = keys.indexOf("choose");
        if (~ixChoose)
            keys.splice(ixChoose, 1);

        const baseStack = [];
        keys.filter(k=>skProf[k]).forEach(k=>baseStack.push(Renderer.get().render(`{@skill ${k.toTitleCase()}}`)));

        const chooseStack = [];
        if (~ixChoose) {
            const chObj = skProf.choose;
            if (chObj.from.length === 18) {
                chooseStack.push(`choose any ${!chObj.count || chObj.count === 1 ? "skill" : chObj.count}`);
            } else {
                chooseStack.push(`choose ${chObj.count || 1} from ${chObj.from.map(it=>Renderer.get().render(`{@skill ${it.toTitleCase()}}`)).joinConjunct(", ", " and ")}`);
            }
        }

        const base = baseStack.joinConjunct(", ", " and ");
        const choose = chooseStack.join("");
        if (baseStack.length && chooseStack.length)
            return `${base}; and ${choose}`;
        else if (baseStack.length)
            return base;
        else if (chooseStack.length)
            return choose;
    }

    return skillProficiencies.map(renderSingle).join(" <i>or</i> ");
}
;

Parser.spSchoolAndSubschoolsAbvsToFull = function(school, subschools) {
    if (!subschools || !subschools.length)
        return Parser.spSchoolAbvToFull(school);
    else
        return `${Parser.spSchoolAbvToFull(school)} (${subschools.map(sub=>Parser.spSchoolAbvToFull(sub)).join(", ")})`;
}
;

Parser.spSchoolAbvToFull = function(schoolOrSubschool) {
    const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_FULL, schoolOrSubschool);
    if (Parser.SP_SCHOOL_ABV_TO_FULL[schoolOrSubschool])
        return out;
    if (PrereleaseUtil.getMetaLookup("spellSchools")?.[schoolOrSubschool])
        return PrereleaseUtil.getMetaLookup("spellSchools")?.[schoolOrSubschool].full;
    if (BrewUtil2.getMetaLookup("spellSchools")?.[schoolOrSubschool])
        return BrewUtil2.getMetaLookup("spellSchools")?.[schoolOrSubschool].full;
    return out;
}
;

Parser.spSchoolAndSubschoolsAbvsShort = function(school, subschools) {
    if (!subschools || !subschools.length)
        return Parser.spSchoolAbvToShort(school);
    else
        return `${Parser.spSchoolAbvToShort(school)} (${subschools.map(sub=>Parser.spSchoolAbvToShort(sub)).join(", ")})`;
}
;

Parser.spSchoolAbvToShort = function(school) {
    const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_SHORT, school);
    if (Parser.SP_SCHOOL_ABV_TO_SHORT[school])
        return out;
    if (PrereleaseUtil.getMetaLookup("spellSchools")?.[school])
        return PrereleaseUtil.getMetaLookup("spellSchools")?.[school].short;
    if (BrewUtil2.getMetaLookup("spellSchools")?.[school])
        return BrewUtil2.getMetaLookup("spellSchools")?.[school].short;
    if (out.length <= 4)
        return out;
    return `${out.slice(0, 3)}.`;
}
;

Parser.spSchoolAbvToStyle = function(school) {
    const stylePart = Parser.spSchoolAbvToStylePart(school);
    if (!stylePart)
        return stylePart;
    return `style="${stylePart}"`;
}
;

Parser.spSchoolAbvToStylePart = function(school) {
    return Parser._spSchoolAbvToStylePart_prereleaseBrew({
        school,
        brewUtil: PrereleaseUtil
    }) || Parser._spSchoolAbvToStylePart_prereleaseBrew({
        school,
        brewUtil: BrewUtil2
    }) || "";
}
;

Parser._spSchoolAbvToStylePart_prereleaseBrew = function({school, brewUtil}) {
    const rawColor = brewUtil.getMetaLookup("spellSchools")?.[school]?.color;
    if (!rawColor || !rawColor.trim())
        return "";
    const validColor = BrewUtilShared.getValidColor(rawColor);
    if (validColor.length)
        return `color: #${validColor};`;
}
;

Parser.getOrdinalForm = function(i) {
    i = Number(i);
    if (isNaN(i))
        return "";
    const j = i % 10;
    const k = i % 100;
    if (j === 1 && k !== 11)
        return `${i}st`;
    if (j === 2 && k !== 12)
        return `${i}nd`;
    if (j === 3 && k !== 13)
        return `${i}rd`;
    return `${i}th`;
}
;

Parser.spLevelToFull = function(level) {
    if (level === 0)
        return "Cantrip";
    else
        return Parser.getOrdinalForm(level);
}
;

Parser.getArticle = function(str) {
    str = `${str}`;
    str = str.replace(/\d+/g, (...m)=>Parser.numberToText(m[0]));
    return /^[aeiou]/i.test(str) ? "an" : "a";
}
;

Parser.spLevelToFullLevelText = function(level, {isDash=false, isPluralCantrips=true}={}) {
    return `${Parser.spLevelToFull(level)}${(level === 0 ? (isPluralCantrips ? "s" : "") : `${isDash ? "-" : " "}level`)}`;
}
;

Parser.spLevelToSpellPoints = function(lvl) {
    lvl = Number(lvl);
    if (isNaN(lvl) || lvl === 0)
        return 0;
    return Math.ceil(1.34 * lvl);
}
;

Parser.spMetaToArr = function(meta) {
    if (!meta)
        return [];
    return Object.entries(meta).filter(([_,v])=>v).sort(SortUtil.ascSort).map(([k])=>k);
}
;

Parser.spMetaToFull = function(meta) {
    if (!meta)
        return "";
    const metaTags = Parser.spMetaToArr(meta);
    if (metaTags.length)
        return ` (${metaTags.join(", ")})`;
    return "";
}
;

Parser.spLevelSchoolMetaToFull = function(level, school, meta, subschools) {
    const levelPart = level === 0 ? Parser.spLevelToFull(level).toLowerCase() : `${Parser.spLevelToFull(level)}-level`;
    const levelSchoolStr = level === 0 ? `${Parser.spSchoolAbvToFull(school)} ${levelPart}` : `${levelPart} ${Parser.spSchoolAbvToFull(school).toLowerCase()}`;

    const metaArr = Parser.spMetaToArr(meta);
    if (metaArr.length || (subschools && subschools.length)) {
        const metaAndSubschoolPart = [(subschools || []).map(sub=>Parser.spSchoolAbvToFull(sub)).join(", "), metaArr.join(", "), ].filter(Boolean).join("; ").toLowerCase();
        return `${levelSchoolStr} (${metaAndSubschoolPart})`;
    }
    return levelSchoolStr;
}
;

Parser.spTimeListToFull = function(times, isStripTags) {
    return times.map(t=>`${Parser.getTimeToFull(t)}${t.condition ? `, ${isStripTags ? Renderer.stripTags(t.condition) : Renderer.get().render(t.condition)}` : ""}`).join(" or ");
}
;

Parser.getTimeToFull = function(time) {
    return `${time.number ? `${time.number} ` : ""}${time.unit === "bonus" ? "bonus action" : time.unit}${time.number > 1 ? "s" : ""}`;
}
;

Parser.getMinutesToFull = function(mins) {
    const days = Math.floor(mins / (24 * 60));
    mins = mins % (24 * 60);

    const hours = Math.floor(mins / 60);
    mins = mins % 60;

    return [days ? `${days} day${days > 1 ? "s" : ""}` : null, hours ? `${hours} hour${hours > 1 ? "s" : ""}` : null, mins ? `${mins} minute${mins > 1 ? "s" : ""}` : null, ].filter(Boolean).join(" ");
}
;

Parser.RNG_SPECIAL = "special";
Parser.RNG_POINT = "point";
Parser.RNG_LINE = "line";
Parser.RNG_CUBE = "cube";
Parser.RNG_CONE = "cone";
Parser.RNG_RADIUS = "radius";
Parser.RNG_SPHERE = "sphere";
Parser.RNG_HEMISPHERE = "hemisphere";
Parser.RNG_CYLINDER = "cylinder";
Parser.RNG_SELF = "self";
Parser.RNG_SIGHT = "sight";
Parser.RNG_UNLIMITED = "unlimited";
Parser.RNG_UNLIMITED_SAME_PLANE = "plane";
Parser.RNG_TOUCH = "touch";
Parser.SP_RANGE_TYPE_TO_FULL = {
    [Parser.RNG_SPECIAL]: "Special",
    [Parser.RNG_POINT]: "Point",
    [Parser.RNG_LINE]: "Line",
    [Parser.RNG_CUBE]: "Cube",
    [Parser.RNG_CONE]: "Cone",
    [Parser.RNG_RADIUS]: "Radius",
    [Parser.RNG_SPHERE]: "Sphere",
    [Parser.RNG_HEMISPHERE]: "Hemisphere",
    [Parser.RNG_CYLINDER]: "Cylinder",
    [Parser.RNG_SELF]: "Self",
    [Parser.RNG_SIGHT]: "Sight",
    [Parser.RNG_UNLIMITED]: "Unlimited",
    [Parser.RNG_UNLIMITED_SAME_PLANE]: "Unlimited on the same plane",
    [Parser.RNG_TOUCH]: "Touch",
};

Parser.spRangeTypeToFull = function(range) {
    return Parser._parse_aToB(Parser.SP_RANGE_TYPE_TO_FULL, range);
}
;

Parser.UNT_FEET = "feet";
Parser.UNT_YARDS = "yards";
Parser.UNT_MILES = "miles";
Parser.SP_DIST_TYPE_TO_FULL = {
    [Parser.UNT_FEET]: "Feet",
    [Parser.UNT_YARDS]: "Yards",
    [Parser.UNT_MILES]: "Miles",
    [Parser.RNG_SELF]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_SELF],
    [Parser.RNG_TOUCH]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_TOUCH],
    [Parser.RNG_SIGHT]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_SIGHT],
    [Parser.RNG_UNLIMITED]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_UNLIMITED],
    [Parser.RNG_UNLIMITED_SAME_PLANE]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_UNLIMITED_SAME_PLANE],
};

Parser.spDistanceTypeToFull = function(range) {
    return Parser._parse_aToB(Parser.SP_DIST_TYPE_TO_FULL, range);
}
;

Parser.SP_RANGE_TO_ICON = {
    [Parser.RNG_SPECIAL]: "fa-star",
    [Parser.RNG_POINT]: "",
    [Parser.RNG_LINE]: "fa-grip-lines-vertical",
    [Parser.RNG_CUBE]: "fa-cube",
    [Parser.RNG_CONE]: "fa-traffic-cone",
    [Parser.RNG_RADIUS]: "fa-hockey-puck",
    [Parser.RNG_SPHERE]: "fa-globe",
    [Parser.RNG_HEMISPHERE]: "fa-globe",
    [Parser.RNG_CYLINDER]: "fa-database",
    [Parser.RNG_SELF]: "fa-street-view",
    [Parser.RNG_SIGHT]: "fa-eye",
    [Parser.RNG_UNLIMITED_SAME_PLANE]: "fa-globe-americas",
    [Parser.RNG_UNLIMITED]: "fa-infinity",
    [Parser.RNG_TOUCH]: "fa-hand-paper",
};

Parser.spRangeTypeToIcon = function(range) {
    return Parser._parse_aToB(Parser.SP_RANGE_TO_ICON, range);
}
;

Parser.spRangeToShortHtml = function(range) {
    switch (range.type) {
    case Parser.RNG_SPECIAL:
        return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="Special"></span>`;
    case Parser.RNG_POINT:
        return Parser.spRangeToShortHtml._renderPoint(range);
    case Parser.RNG_LINE:
    case Parser.RNG_CUBE:
    case Parser.RNG_CONE:
    case Parser.RNG_RADIUS:
    case Parser.RNG_SPHERE:
    case Parser.RNG_HEMISPHERE:
    case Parser.RNG_CYLINDER:
        return Parser.spRangeToShortHtml._renderArea(range);
    }
}
;
Parser.spRangeToShortHtml._renderPoint = function(range) {
    const dist = range.distance;
    switch (dist.type) {
    case Parser.RNG_SELF:
    case Parser.RNG_SIGHT:
    case Parser.RNG_UNLIMITED:
    case Parser.RNG_UNLIMITED_SAME_PLANE:
    case Parser.RNG_SPECIAL:
    case Parser.RNG_TOUCH:
        return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(dist.type)} help-subtle" title="${Parser.spRangeTypeToFull(dist.type)}"></span>`;
    case Parser.UNT_FEET:
    case Parser.UNT_YARDS:
    case Parser.UNT_MILES:
    default:
        return `${dist.amount} <span class="ve-small">${Parser.getSingletonUnit(dist.type, true)}</span>`;
    }
}
;
Parser.spRangeToShortHtml._renderArea = function(range) {
    const size = range.distance;
    return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(Parser.RNG_SELF)} help-subtle" title="Self"></span> ${size.amount}<span class="ve-small">-${Parser.getSingletonUnit(size.type, true)}</span> ${Parser.spRangeToShortHtml._getAreaStyleString(range)}`;
}
;
Parser.spRangeToShortHtml._getAreaStyleString = function(range) {
    return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="${Parser.spRangeTypeToFull(range.type)}"></span>`;
}
;

Parser.spRangeToFull = function(range) {
    switch (range.type) {
    case Parser.RNG_SPECIAL:
        return Parser.spRangeTypeToFull(range.type);
    case Parser.RNG_POINT:
        return Parser.spRangeToFull._renderPoint(range);
    case Parser.RNG_LINE:
    case Parser.RNG_CUBE:
    case Parser.RNG_CONE:
    case Parser.RNG_RADIUS:
    case Parser.RNG_SPHERE:
    case Parser.RNG_HEMISPHERE:
    case Parser.RNG_CYLINDER:
        return Parser.spRangeToFull._renderArea(range);
    }
}
;
Parser.spRangeToFull._renderPoint = function(range) {
    const dist = range.distance;
    switch (dist.type) {
    case Parser.RNG_SELF:
    case Parser.RNG_SIGHT:
    case Parser.RNG_UNLIMITED:
    case Parser.RNG_UNLIMITED_SAME_PLANE:
    case Parser.RNG_SPECIAL:
    case Parser.RNG_TOUCH:
        return Parser.spRangeTypeToFull(dist.type);
    case Parser.UNT_FEET:
    case Parser.UNT_YARDS:
    case Parser.UNT_MILES:
    default:
        return `${dist.amount} ${dist.amount === 1 ? Parser.getSingletonUnit(dist.type) : dist.type}`;
    }
}
;
Parser.spRangeToFull._renderArea = function(range) {
    const size = range.distance;
    return `Self (${size.amount}-${Parser.getSingletonUnit(size.type)}${Parser.spRangeToFull._getAreaStyleString(range)}${range.type === Parser.RNG_CYLINDER ? `${size.amountSecondary != null && size.typeSecondary != null ? `, ${size.amountSecondary}-${Parser.getSingletonUnit(size.typeSecondary)}-high` : ""} cylinder` : ""})`;
}
;
Parser.spRangeToFull._getAreaStyleString = function(range) {
    switch (range.type) {
    case Parser.RNG_SPHERE:
        return " radius";
    case Parser.RNG_HEMISPHERE:
        return `-radius ${range.type}`;
    case Parser.RNG_CYLINDER:
        return "-radius";
    default:
        return ` ${range.type}`;
    }
}
;

Parser.getSingletonUnit = function(unit, isShort) {
    switch (unit) {
    case Parser.UNT_FEET:
        return isShort ? "ft." : "foot";
    case Parser.UNT_YARDS:
        return isShort ? "yd." : "yard";
    case Parser.UNT_MILES:
        return isShort ? "mi." : "mile";
    default:
        {
            const fromPrerelease = Parser._getSingletonUnit_prereleaseBrew({
                unit,
                isShort,
                brewUtil: PrereleaseUtil
            });
            if (fromPrerelease)
                return fromPrerelease;

            const fromBrew = Parser._getSingletonUnit_prereleaseBrew({
                unit,
                isShort,
                brewUtil: BrewUtil2
            });
            if (fromBrew)
                return fromBrew;

            if (unit.charAt(unit.length - 1) === "s")
                return unit.slice(0, -1);
            return unit;
        }
    }
}
;

Parser._getSingletonUnit_prereleaseBrew = function({unit, isShort, brewUtil}) {
    const fromBrew = brewUtil.getMetaLookup("spellDistanceUnits")?.[unit]?.["singular"];
    if (fromBrew)
        return fromBrew;
}
;

Parser.RANGE_TYPES = [{
    type: Parser.RNG_POINT,
    hasDistance: true,
    isRequireAmount: false
},
{
    type: Parser.RNG_LINE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_CUBE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_CONE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_RADIUS,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_SPHERE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_HEMISPHERE,
    hasDistance: true,
    isRequireAmount: true
}, {
    type: Parser.RNG_CYLINDER,
    hasDistance: true,
    isRequireAmount: true
},
{
    type: Parser.RNG_SPECIAL,
    hasDistance: false,
    isRequireAmount: false
}, ];

Parser.DIST_TYPES = [{
    type: Parser.RNG_SELF,
    hasAmount: false
}, {
    type: Parser.RNG_TOUCH,
    hasAmount: false
},
{
    type: Parser.UNT_FEET,
    hasAmount: true
}, {
    type: Parser.UNT_YARDS,
    hasAmount: true
}, {
    type: Parser.UNT_MILES,
    hasAmount: true
},
{
    type: Parser.RNG_SIGHT,
    hasAmount: false
}, {
    type: Parser.RNG_UNLIMITED_SAME_PLANE,
    hasAmount: false
}, {
    type: Parser.RNG_UNLIMITED,
    hasAmount: false
}, ];

Parser.spComponentsToFull = function(comp, level, {isPlainText=false}={}) {
    if (!comp)
        return "None";
    const out = [];
    if (comp.v)
        out.push("V");
    if (comp.s)
        out.push("S");
    if (comp.m != null) {
        const fnRender = isPlainText ? Renderer.stripTags.bind(Renderer) : Renderer.get().render.bind(Renderer.get());
        out.push(`M${comp.m !== true ? ` (${fnRender(comp.m.text != null ? comp.m.text : comp.m)})` : ""}`);
    }
    if (comp.r)
        out.push(`R (${level} gp)`);
    return out.join(", ") || "None";
}
;

Parser.SP_END_TYPE_TO_FULL = {
    "dispel": "dispelled",
    "trigger": "triggered",
    "discharge": "discharged",
};
Parser.spEndTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.SP_END_TYPE_TO_FULL, type);
}
;

Parser.spDurationToFull = function(dur) {
    let hasSubOr = false;
    const outParts = dur.map(d=>{
        switch (d.type) {
        case "special":
            return "Special";
        case "instant":
            return `Instantaneous${d.condition ? ` (${d.condition})` : ""}`;
        case "timed":
            return `${d.concentration ? "Concentration, " : ""}${d.concentration ? "u" : d.duration.upTo ? "U" : ""}${d.concentration || d.duration.upTo ? "p to " : ""}${d.duration.amount} ${d.duration.amount === 1 ? d.duration.type : `${d.duration.type}s`}`;
        case "permanent":
            {
                if (d.ends) {
                    const endsToJoin = d.ends.map(m=>Parser.spEndTypeToFull(m));
                    hasSubOr = hasSubOr || endsToJoin.length > 1;
                    return `Until ${endsToJoin.joinConjunct(", ", " or ")}`;
                } else {
                    return "Permanent";
                }
            }
        }
    }
    );
    return `${outParts.joinConjunct(hasSubOr ? "; " : ", ", " or ")}${dur.length > 1 ? " (see below)" : ""}`;
}
;

Parser.DURATION_TYPES = [{
    type: "instant",
    full: "Instantaneous"
}, {
    type: "timed",
    hasAmount: true
}, {
    type: "permanent",
    hasEnds: true
}, {
    type: "special"
}, ];

Parser.DURATION_AMOUNT_TYPES = ["turn", "round", "minute", "hour", "day", "week", "year", ];

Parser.spClassesToFull = function(sp, {isTextOnly=false, subclassLookup={}}={}) {
    const fromSubclassList = Renderer.spell.getCombinedClasses(sp, "fromSubclass");
    const fromSubclasses = Parser.spSubclassesToFull(fromSubclassList, {
        isTextOnly,
        subclassLookup
    });
    const fromClassList = Renderer.spell.getCombinedClasses(sp, "fromClassList");
    return `${Parser.spMainClassesToFull(fromClassList, {
        isTextOnly
    })}${fromSubclasses ? `, ${fromSubclasses}` : ""}`;
}
;

Parser.spMainClassesToFull = function(fromClassList, {isTextOnly=false}={}) {
    return fromClassList.map(c=>({
        hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](c),
        c
    })).filter(it=>!ExcludeUtil.isInitialised || !ExcludeUtil.isExcluded(it.hash, "class", it.c.source)).sort((a,b)=>SortUtil.ascSort(a.c.name, b.c.name)).map(it=>{
        if (isTextOnly)
            return it.c.name;

        return `<span title="${it.c.definedInSource ? `Class source` : "Source"}: ${Parser.sourceJsonToFull(it.c.source)}${it.c.definedInSource ? `. Spell list defined in: ${Parser.sourceJsonToFull(it.c.definedInSource)}.` : ""}">${Renderer.get().render(`{@class ${it.c.name}|${it.c.source}}`)}</span>`;
    }
    ).join(", ") || "";
}
;

Parser.spSubclassesToFull = function(fromSubclassList, {isTextOnly=false, subclassLookup={}}={}) {
    return fromSubclassList.filter(mt=>{
        if (!ExcludeUtil.isInitialised)
            return true;
        const excludeClass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](mt.class), "class", mt.class.source);
        if (excludeClass)
            return false;

        return !ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
            shortName: mt.subclass.name,
            source: mt.subclass.source,
            className: mt.class.name,
            classSource: mt.class.source,
        }), "subclass", mt.subclass.source, {
            isNoCount: true
        }, );
    }
    ).sort((a,b)=>{
        const byName = SortUtil.ascSort(a.class.name, b.class.name);
        return byName || SortUtil.ascSort(a.subclass.name, b.subclass.name);
    }
    ).map(c=>Parser._spSubclassItem({
        fromSubclass: c,
        isTextOnly
    })).join(", ") || "";
}
;

Parser._spSubclassItem = function({fromSubclass, isTextOnly}) {
    const c = fromSubclass.class;
    const sc = fromSubclass.subclass;
    const text = `${sc.shortName}${sc.subSubclass ? ` (${sc.subSubclass})` : ""}`;
    if (isTextOnly)
        return text;

    const classPart = `<span title="Source: ${Parser.sourceJsonToFull(c.source)}${c.definedInSource ? ` From a class spell list defined in: ${Parser.sourceJsonToFull(c.definedInSource)}` : ""}">${Renderer.get().render(`{@class ${c.name}|${c.source}}`)}</span>`;

    return `<span class="italic" title="Source: ${Parser.sourceJsonToFull(fromSubclass.subclass.source)}">${Renderer.get().render(`{@class ${c.name}|${c.source}|${text}|${sc.shortName}|${sc.source}}`)}</span> ${classPart}`;
}
;

Parser.SPELL_ATTACK_TYPE_TO_FULL = {};
Parser.SPELL_ATTACK_TYPE_TO_FULL["M"] = "Melee";
Parser.SPELL_ATTACK_TYPE_TO_FULL["R"] = "Ranged";
Parser.SPELL_ATTACK_TYPE_TO_FULL["O"] = "Other/Unknown";

Parser.spAttackTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.SPELL_ATTACK_TYPE_TO_FULL, type);
}
;

Parser.SPELL_AREA_TYPE_TO_FULL = {
    ST: "Single Target",
    MT: "Multiple Targets",
    C: "Cube",
    N: "Cone",
    Y: "Cylinder",
    S: "Sphere",
    R: "Circle",
    Q: "Square",
    L: "Line",
    H: "Hemisphere",
    W: "Wall",
};
Parser.spAreaTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.SPELL_AREA_TYPE_TO_FULL, type);
}
;

Parser.SP_MISC_TAG_TO_FULL = {
    HL: "Healing",
    THP: "Grants Temporary Hit Points",
    SGT: "Requires Sight",
    PRM: "Permanent Effects",
    SCL: "Scaling Effects",
    SMN: "Summons Creature",
    MAC: "Modifies AC",
    TP: "Teleportation",
    FMV: "Forced Movement",
    RO: "Rollable Effects",
    LGTS: "Creates Sunlight",
    LGT: "Creates Light",
    UBA: "Uses Bonus Action",
    PS: "Plane Shifting",
    OBS: "Obscures Vision",
    DFT: "Difficult Terrain",
    AAD: "Additional Attack Damage",
    OBJ: "Affects Objects",
    ADV: "Grants Advantage",
};
Parser.spMiscTagToFull = function(type) {
    return Parser._parse_aToB(Parser.SP_MISC_TAG_TO_FULL, type);
}
;

Parser.SP_CASTER_PROGRESSION_TO_FULL = {
    full: "Full",
    "1/2": "Half",
    "1/3": "One-Third",
    "pact": "Pact Magic",
};
Parser.spCasterProgressionToFull = function(type) {
    return Parser._parse_aToB(Parser.SP_CASTER_PROGRESSION_TO_FULL, type);
}
;

Parser.monTypeToFullObj = function(type) {
    const out = {
        types: [],
        tags: [],
        asText: "",
        asTextShort: "",

        typeSidekick: null,
        tagsSidekick: [],
        asTextSidekick: null,
    };

    if (typeof type === "string") {
        out.types = [type];
        out.asText = type.toTitleCase();
        out.asTextShort = out.asText;
        return out;
    }

    if (type.type?.choose) {
        out.types = type.type.choose;
    } else {
        out.types = [type.type];
    }

    if (type.swarmSize) {
        out.tags.push("swarm");
        out.asText = `swarm of ${Parser.sizeAbvToFull(type.swarmSize)} ${out.types.map(typ=>Parser.monTypeToPlural(typ).toTitleCase()).joinConjunct(", ", " or ")}`;
        out.asTextShort = out.asText;
        out.swarmSize = type.swarmSize;
    } else {
        out.asText = out.types.map(typ=>typ.toTitleCase()).joinConjunct(", ", " or ");
        out.asTextShort = out.asText;
    }

    const tagMetas = Parser.monTypeToFullObj._getTagMetas(type.tags);
    if (tagMetas.length) {
        out.tags.push(...tagMetas.map(({filterTag})=>filterTag));
        const ptTags = ` (${tagMetas.map(({displayTag})=>displayTag).join(", ")})`;
        out.asText += ptTags;
        out.asTextShort += ptTags;
    }

    if (type.note)
        out.asText += ` ${type.note}`;

    if (type.sidekickType) {
        out.typeSidekick = type.sidekickType;
        if (!type.sidekickHidden)
            out.asTextSidekick = `${type.sidekickType}`;

        const tagMetas = Parser.monTypeToFullObj._getTagMetas(type.sidekickTags);
        if (tagMetas.length) {
            out.tagsSidekick.push(...tagMetas.map(({filterTag})=>filterTag));
            if (!type.sidekickHidden)
                out.asTextSidekick += ` (${tagMetas.map(({displayTag})=>displayTag).join(", ")})`;
        }
    }

    return out;
}
;

Parser.monTypeToFullObj._getTagMetas = (tags)=>{
    return tags ? tags.map(tag=>{
        if (typeof tag === "string") {
            return {
                filterTag: tag.toLowerCase(),
                displayTag: tag.toTitleCase(),
            };
        } else {
            return {
                filterTag: tag.tag.toLowerCase(),
                displayTag: `${tag.prefix} ${tag.tag}`.toTitleCase(),
            };
        }
    }
    ) : [];
}
;

Parser.monTypeToPlural = function(type) {
    return Parser._parse_aToB(Parser.MON_TYPE_TO_PLURAL, type);
}
;

Parser.monTypeFromPlural = function(type) {
    return Parser._parse_bToA(Parser.MON_TYPE_TO_PLURAL, type);
}
;

Parser.monCrToFull = function(cr, {xp=null, isMythic=false}={}) {
    if (cr == null)
        return "";

    if (typeof cr === "string") {
        if (Parser.crToNumber(cr) >= VeCt.CR_CUSTOM)
            return `${cr}${xp != null ? ` (${xp} XP)` : ""}`;

        xp = xp != null ? Parser._addCommas(xp) : Parser.crToXp(cr);
        return `${cr} (${xp} XP${isMythic ? `, or ${Parser.crToXp(cr, {
            isDouble: true
        })} XP as a mythic encounter` : ""})`;
    } else {
        const stack = [Parser.monCrToFull(cr.cr, {
            xp: cr.xp,
            isMythic
        })];
        if (cr.lair)
            stack.push(`${Parser.monCrToFull(cr.lair)} when encountered in lair`);
        if (cr.coven)
            stack.push(`${Parser.monCrToFull(cr.coven)} when part of a coven`);
        return stack.joinConjunct(", ", " or ");
    }
}
;

Parser.getFullImmRes = function(toParse) {
    if (!toParse?.length)
        return "";

    let maxDepth = 0;

    function toString(it, depth=0) {
        maxDepth = Math.max(maxDepth, depth);
        if (typeof it === "string") {
            return it;
        } else if (it.special) {
            return it.special;
        } else {
            const stack = [];

            if (it.preNote)
                stack.push(it.preNote);

            const prop = it.immune ? "immune" : it.resist ? "resist" : it.vulnerable ? "vulnerable" : null;
            if (prop) {
                const toJoin = it[prop].length === Parser.DMG_TYPES.length && CollectionUtil.deepEquals(Parser.DMG_TYPES, it[prop]) ? ["all damage"] : it[prop].map(nxt=>toString(nxt, depth + 1));
                stack.push(depth ? toJoin.join(maxDepth ? "; " : ", ") : toJoin.joinConjunct(", ", " and "));
            }

            if (it.note)
                stack.push(it.note);

            return stack.join(" ");
        }
    }

    const arr = toParse.map(it=>toString(it));

    if (arr.length <= 1)
        return arr.join("");

    let out = "";
    for (let i = 0; i < arr.length - 1; ++i) {
        const it = arr[i];
        const nxt = arr[i + 1];

        const orig = toParse[i];
        const origNxt = toParse[i + 1];

        out += it;
        out += (it.includes(",") || nxt.includes(",") || (orig && orig.cond) || (origNxt && origNxt.cond)) ? "; " : ", ";
    }
    out += arr.last();
    return out;
}
;

Parser.getFullCondImm = function(condImm, {isPlainText=false, isEntry=false}={}) {
    if (isPlainText && isEntry)
        throw new Error(`Options "isPlainText" and "isEntry" are mutually exclusive!`);

    if (!condImm?.length)
        return "";

    const render = condition=>{
        if (isPlainText)
            return condition;
        const ent = `{@condition ${condition}}`;
        if (isEntry)
            return ent;
        return Renderer.get().render(ent);
    }
    ;

    return condImm.map(it=>{
        if (it.special)
            return it.special;
        if (it.conditionImmune)
            return `${it.preNote ? `${it.preNote} ` : ""}${it.conditionImmune.map(render).join(", ")}${it.note ? ` ${it.note}` : ""}`;
        return render(it);
    }
    ).sort(SortUtil.ascSortLower).join(", ");
}
;

Parser.MON_SENSE_TAG_TO_FULL = {
    "B": "blindsight",
    "D": "darkvision",
    "SD": "superior darkvision",
    "T": "tremorsense",
    "U": "truesight",
};
Parser.monSenseTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_SENSE_TAG_TO_FULL, tag);
}
;

Parser.MON_SPELLCASTING_TAG_TO_FULL = {
    "P": "Psionics",
    "I": "Innate",
    "F": "Form Only",
    "S": "Shared",
    "O": "Other",
    "CA": "Class, Artificer",
    "CB": "Class, Bard",
    "CC": "Class, Cleric",
    "CD": "Class, Druid",
    "CP": "Class, Paladin",
    "CR": "Class, Ranger",
    "CS": "Class, Sorcerer",
    "CL": "Class, Warlock",
    "CW": "Class, Wizard",
};
Parser.monSpellcastingTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_SPELLCASTING_TAG_TO_FULL, tag);
}
;

Parser.MON_MISC_TAG_TO_FULL = {
    "AOE": "Has Areas of Effect",
    "HPR": "Has HP Reduction",
    "MW": "Has Weapon Attacks, Melee",
    "RW": "Has Weapon Attacks, Ranged",
    "MLW": "Has Melee Weapons",
    "RNG": "Has Ranged Weapons",
    "RCH": "Has Reach Attacks",
    "THW": "Has Thrown Weapons",
};
Parser.monMiscTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_MISC_TAG_TO_FULL, tag);
}
;

Parser.MON_LANGUAGE_TAG_TO_FULL = {
    "AB": "Abyssal",
    "AQ": "Aquan",
    "AU": "Auran",
    "C": "Common",
    "CE": "Celestial",
    "CS": "Can't Speak Known Languages",
    "D": "Dwarvish",
    "DR": "Draconic",
    "DS": "Deep Speech",
    "DU": "Druidic",
    "E": "Elvish",
    "G": "Gnomish",
    "GI": "Giant",
    "GO": "Goblin",
    "GTH": "Gith",
    "H": "Halfling",
    "I": "Infernal",
    "IG": "Ignan",
    "LF": "Languages Known in Life",
    "O": "Orc",
    "OTH": "Other",
    "P": "Primordial",
    "S": "Sylvan",
    "T": "Terran",
    "TC": "Thieves' cant",
    "TP": "Telepathy",
    "U": "Undercommon",
    "X": "Any (Choose)",
    "XX": "All",
};
Parser.monLanguageTagToFull = function(tag) {
    return Parser._parse_aToB(Parser.MON_LANGUAGE_TAG_TO_FULL, tag);
}
;

Parser.ENVIRONMENTS = ["arctic", "coastal", "desert", "forest", "grassland", "hill", "mountain", "swamp", "underdark", "underwater", "urban"];

Parser.PSI_ABV_TYPE_TALENT = "T";
Parser.PSI_ABV_TYPE_DISCIPLINE = "D";
Parser.PSI_ORDER_NONE = "None";
Parser.psiTypeToFull = type=>Parser.psiTypeToMeta(type).full;

Parser.psiTypeToMeta = type=>{
    let out = {};
    if (type === Parser.PSI_ABV_TYPE_TALENT)
        out = {
            hasOrder: false,
            full: "Talent"
        };
    else if (type === Parser.PSI_ABV_TYPE_DISCIPLINE)
        out = {
            hasOrder: true,
            full: "Discipline"
        };
    else if (PrereleaseUtil.getMetaLookup("psionicTypes")?.[type])
        out = MiscUtil.copyFast(PrereleaseUtil.getMetaLookup("psionicTypes")[type]);
    else if (BrewUtil2.getMetaLookup("psionicTypes")?.[type])
        out = MiscUtil.copyFast(BrewUtil2.getMetaLookup("psionicTypes")[type]);
    out.full = out.full || "Unknown";
    out.short = out.short || out.full;
    return out;
}
;

Parser.psiOrderToFull = (order)=>{
    return order === undefined ? Parser.PSI_ORDER_NONE : order;
}
;

Parser.prereqSpellToFull = function(spell, {isTextOnly=false}={}) {
    if (spell) {
        const [text,suffix] = spell.split("#");
        if (!suffix)
            return isTextOnly ? spell : Renderer.get().render(`{@spell ${spell}}`);
        else if (suffix === "c")
            return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))(`{@spell ${text}} cantrip`);
        else if (suffix === "x")
            return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))("{@spell hex} spell or a warlock feature that curses");
    } else
        return VeCt.STR_NONE;
}
;

Parser.prereqPactToFull = function(pact) {
    if (pact === "Chain")
        return "Pact of the Chain";
    if (pact === "Tome")
        return "Pact of the Tome";
    if (pact === "Blade")
        return "Pact of the Blade";
    if (pact === "Talisman")
        return "Pact of the Talisman";
    return pact;
}
;

Parser.prereqPatronToShort = function(patron) {
    if (patron === "Any")
        return patron;
    const mThe = /^The (.*?)$/.exec(patron);
    if (mThe)
        return mThe[1];
    return patron;
}
;

Parser.OPT_FEATURE_TYPE_TO_FULL = {
    AI: "Artificer Infusion",
    ED: "Elemental Discipline",
    EI: "Eldritch Invocation",
    MM: "Metamagic",
    "MV": "Maneuver",
    "MV:B": "Maneuver, Battle Master",
    "MV:C2-UA": "Maneuver, Cavalier V2 (UA)",
    "AS:V1-UA": "Arcane Shot, V1 (UA)",
    "AS:V2-UA": "Arcane Shot, V2 (UA)",
    "AS": "Arcane Shot",
    OTH: "Other",
    "FS:F": "Fighting Style; Fighter",
    "FS:B": "Fighting Style; Bard",
    "FS:P": "Fighting Style; Paladin",
    "FS:R": "Fighting Style; Ranger",
    "PB": "Pact Boon",
    "OR": "Onomancy Resonant",
    "RN": "Rune Knight Rune",
    "AF": "Alchemical Formula",
};

Parser.optFeatureTypeToFull = function(type) {
    if (Parser.OPT_FEATURE_TYPE_TO_FULL[type])
        return Parser.OPT_FEATURE_TYPE_TO_FULL[type];
    if (PrereleaseUtil.getMetaLookup("optionalFeatureTypes")?.[type])
        return PrereleaseUtil.getMetaLookup("optionalFeatureTypes")[type];
    if (BrewUtil2.getMetaLookup("optionalFeatureTypes")?.[type])
        return BrewUtil2.getMetaLookup("optionalFeatureTypes")[type];
    return type;
}
;

Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL = {
    "SG": "Supernatural Gift",
    "OF": "Optional Feature",
    "DG": "Dark Gift",
    "RF:B": "Replacement Feature: Background",
    "CS": "Character Secret",
};

Parser.charCreationOptionTypeToFull = function(type) {
    if (Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type])
        return Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type];
    if (PrereleaseUtil.getMetaLookup("charOption")?.[type])
        return PrereleaseUtil.getMetaLookup("charOption")[type];
    if (BrewUtil2.getMetaLookup("charOption")?.[type])
        return BrewUtil2.getMetaLookup("charOption")[type];
    return type;
}
;

Parser.alignmentAbvToFull = function(alignment) {
    if (!alignment)
        return null;
    if (typeof alignment === "object") {
        if (alignment.special != null) {
            return alignment.special;
        } else {
            return `${alignment.alignment.map(a=>Parser.alignmentAbvToFull(a)).join(" ")}${alignment.chance ? ` (${alignment.chance}%)` : ""}${alignment.note ? ` (${alignment.note})` : ""}`;
        }
    } else {
        alignment = alignment.toUpperCase();
        switch (alignment) {
        case "L":
            return "lawful";
        case "N":
            return "neutral";
        case "NX":
            return "neutral (law/chaos axis)";
        case "NY":
            return "neutral (good/evil axis)";
        case "C":
            return "chaotic";
        case "G":
            return "good";
        case "E":
            return "evil";
        case "U":
            return "unaligned";
        case "A":
            return "any alignment";
        }
        return alignment;
    }
}
;

Parser.alignmentListToFull = function(alignList) {
    if (!alignList)
        return "";
    if (alignList.some(it=>typeof it !== "string")) {
        if (alignList.some(it=>typeof it === "string"))
            throw new Error(`Mixed alignment types: ${JSON.stringify(alignList)}`);
        alignList = alignList.filter(it=>it.alignment === undefined || it.alignment != null);
        return alignList.map(it=>it.special != null || it.chance != null || it.note != null ? Parser.alignmentAbvToFull(it) : Parser.alignmentListToFull(it.alignment)).join(" or ");
    } else {
        if (alignList.length === 1)
            return Parser.alignmentAbvToFull(alignList[0]);
        if (alignList.length === 2) {
            return alignList.map(a=>Parser.alignmentAbvToFull(a)).join(" ");
        }
        if (alignList.length === 3) {
            if (alignList.includes("NX") && alignList.includes("NY") && alignList.includes("N"))
                return "any neutral alignment";
        }
        if (alignList.length === 5) {
            if (!alignList.includes("G"))
                return "any non-good alignment";
            if (!alignList.includes("E"))
                return "any non-evil alignment";
            if (!alignList.includes("L"))
                return "any non-lawful alignment";
            if (!alignList.includes("C"))
                return "any non-chaotic alignment";
        }
        if (alignList.length === 4) {
            if (!alignList.includes("L") && !alignList.includes("NX"))
                return "any chaotic alignment";
            if (!alignList.includes("G") && !alignList.includes("NY"))
                return "any evil alignment";
            if (!alignList.includes("C") && !alignList.includes("NX"))
                return "any lawful alignment";
            if (!alignList.includes("E") && !alignList.includes("NY"))
                return "any good alignment";
        }
        throw new Error(`Unmapped alignment: ${JSON.stringify(alignList)}`);
    }
}
;

Parser.weightToFull = function(lbs, isSmallUnit) {
    const tons = Math.floor(lbs / 2000);
    lbs = lbs - (2000 * tons);
    return [tons ? `${tons}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}ton${tons === 1 ? "" : "s"}${isSmallUnit ? `</span>` : ""}` : null, lbs ? `${lbs}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}lb.${isSmallUnit ? `</span>` : ""}` : null, ].filter(Boolean).join(", ");
}
;

Parser.RARITIES = ["common", "uncommon", "rare", "very rare", "legendary", "artifact"];
Parser.ITEM_RARITIES = ["none", ...Parser.RARITIES, "unknown", "unknown (magic)", "other"];

Parser.CAT_ID_CREATURE = 1;
Parser.CAT_ID_SPELL = 2;
Parser.CAT_ID_BACKGROUND = 3;
Parser.CAT_ID_ITEM = 4;
Parser.CAT_ID_CLASS = 5;
Parser.CAT_ID_CONDITION = 6;
Parser.CAT_ID_FEAT = 7;
Parser.CAT_ID_ELDRITCH_INVOCATION = 8;
Parser.CAT_ID_PSIONIC = 9;
Parser.CAT_ID_RACE = 10;
Parser.CAT_ID_OTHER_REWARD = 11;
Parser.CAT_ID_VARIANT_OPTIONAL_RULE = 12;
Parser.CAT_ID_ADVENTURE = 13;
Parser.CAT_ID_DEITY = 14;
Parser.CAT_ID_OBJECT = 15;
Parser.CAT_ID_TRAP = 16;
Parser.CAT_ID_HAZARD = 17;
Parser.CAT_ID_QUICKREF = 18;
Parser.CAT_ID_CULT = 19;
Parser.CAT_ID_BOON = 20;
Parser.CAT_ID_DISEASE = 21;
Parser.CAT_ID_METAMAGIC = 22;
Parser.CAT_ID_MANEUVER_BATTLEMASTER = 23;
Parser.CAT_ID_TABLE = 24;
Parser.CAT_ID_TABLE_GROUP = 25;
Parser.CAT_ID_MANEUVER_CAVALIER = 26;
Parser.CAT_ID_ARCANE_SHOT = 27;
Parser.CAT_ID_OPTIONAL_FEATURE_OTHER = 28;
Parser.CAT_ID_FIGHTING_STYLE = 29;
Parser.CAT_ID_CLASS_FEATURE = 30;
Parser.CAT_ID_VEHICLE = 31;
Parser.CAT_ID_PACT_BOON = 32;
Parser.CAT_ID_ELEMENTAL_DISCIPLINE = 33;
Parser.CAT_ID_ARTIFICER_INFUSION = 34;
Parser.CAT_ID_SHIP_UPGRADE = 35;
Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE = 36;
Parser.CAT_ID_ONOMANCY_RESONANT = 37;
Parser.CAT_ID_RUNE_KNIGHT_RUNE = 37;
Parser.CAT_ID_ALCHEMICAL_FORMULA = 38;
Parser.CAT_ID_MANEUVER = 39;
Parser.CAT_ID_SUBCLASS = 40;
Parser.CAT_ID_SUBCLASS_FEATURE = 41;
Parser.CAT_ID_ACTION = 42;
Parser.CAT_ID_LANGUAGE = 43;
Parser.CAT_ID_BOOK = 44;
Parser.CAT_ID_PAGE = 45;
Parser.CAT_ID_LEGENDARY_GROUP = 46;
Parser.CAT_ID_CHAR_CREATION_OPTIONS = 47;
Parser.CAT_ID_RECIPES = 48;
Parser.CAT_ID_STATUS = 49;
Parser.CAT_ID_SKILLS = 50;
Parser.CAT_ID_SENSES = 51;
Parser.CAT_ID_DECK = 52;
Parser.CAT_ID_CARD = 53;

Parser.CAT_ID_TO_FULL = {};
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CREATURE] = "Bestiary";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SPELL] = "Spell";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BACKGROUND] = "Background";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ITEM] = "Item";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS] = "Class";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CONDITION] = "Condition";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FEAT] = "Feat";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELDRITCH_INVOCATION] = "Eldritch Invocation";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PSIONIC] = "Psionic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RACE] = "Race";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OTHER_REWARD] = "Other Reward";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "Variant/Optional Rule";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ADVENTURE] = "Adventure";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DEITY] = "Deity";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OBJECT] = "Object";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TRAP] = "Trap";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_HAZARD] = "Hazard";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_QUICKREF] = "Quick Reference";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CULT] = "Cult";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOON] = "Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DISEASE] = "Disease";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_METAMAGIC] = "Metamagic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "Maneuver; Battlemaster";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE_GROUP] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_CAVALIER] = "Maneuver; Cavalier";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARCANE_SHOT] = "Arcane Shot";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "Optional Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FIGHTING_STYLE] = "Fighting Style";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS_FEATURE] = "Class Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VEHICLE] = "Vehicle";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PACT_BOON] = "Pact Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "Elemental Discipline";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARTIFICER_INFUSION] = "Infusion";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SHIP_UPGRADE] = "Ship Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "Infernal War Machine Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ONOMANCY_RESONANT] = "Onomancy Resonant";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "Rune Knight Rune";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "Alchemical Formula";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER] = "Maneuver";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS] = "Subclass";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS_FEATURE] = "Subclass Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ACTION] = "Action";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LANGUAGE] = "Language";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOOK] = "Book";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PAGE] = "Page";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LEGENDARY_GROUP] = "Legendary Group";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "Character Creation Option";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RECIPES] = "Recipe";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_STATUS] = "Status";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DECK] = "Deck";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CARD] = "Card";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SKILLS] = "Skill";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SENSES] = "Sense";

Parser.pageCategoryToFull = function(catId) {
    return Parser._parse_aToB(Parser.CAT_ID_TO_FULL, catId);
}
;

Parser.CAT_ID_TO_PROP = {};
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CREATURE] = "monster";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SPELL] = "spell";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BACKGROUND] = "background";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ITEM] = "item";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS] = "class";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CONDITION] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FEAT] = "feat";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PSIONIC] = "psionic";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RACE] = "race";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OTHER_REWARD] = "reward";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "variantrule";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ADVENTURE] = "adventure";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DEITY] = "deity";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OBJECT] = "object";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TRAP] = "trap";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_HAZARD] = "hazard";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CULT] = "cult";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOON] = "boon";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DISEASE] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE] = "table";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE_GROUP] = "tableGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VEHICLE] = "vehicle";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELDRITCH_INVOCATION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_CAVALIER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARCANE_SHOT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FIGHTING_STYLE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_METAMAGIC] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PACT_BOON] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARTIFICER_INFUSION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SHIP_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ONOMANCY_RESONANT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_QUICKREF] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS_FEATURE] = "classFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS] = "subclass";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ACTION] = "action";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LANGUAGE] = "language";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOOK] = "book";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PAGE] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "charoption";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RECIPES] = "recipe";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_STATUS] = "status";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DECK] = "deck";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CARD] = "card";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SKILLS] = "skill";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SENSES] = "sense";

Parser.pageCategoryToProp = function(catId) {
    return Parser._parse_aToB(Parser.CAT_ID_TO_PROP, catId);
}
;

Parser.ABIL_ABVS = ["str", "dex", "con", "int", "wis", "cha"];

Parser.spClassesToCurrentAndLegacy = function(fromClassList) {
    const current = [];
    const legacy = [];
    fromClassList.forEach(cls=>{
        if ((cls.name === "Artificer" && cls.source === "UAArtificer") || (cls.name === "Artificer (Revisited)" && cls.source === "UAArtificerRevisited"))
            legacy.push(cls);
        else
            current.push(cls);
    }
    );
    return [current, legacy];
}
;

Parser.spSubclassesToCurrentAndLegacyFull = function(sp, subclassLookup) {
    return Parser._spSubclassesToCurrentAndLegacyFull({
        sp,
        subclassLookup,
        prop: "fromSubclass"
    });
}
;

Parser.spVariantSubclassesToCurrentAndLegacyFull = function(sp, subclassLookup) {
    return Parser._spSubclassesToCurrentAndLegacyFull({
        sp,
        subclassLookup,
        prop: "fromSubclassVariant"
    });
}
;

Parser._spSubclassesToCurrentAndLegacyFull = ({sp, subclassLookup, prop})=>{
    const fromSubclass = Renderer.spell.getCombinedClasses(sp, prop);
    if (!fromSubclass.length)
        return ["", ""];

    const current = [];
    const legacy = [];
    const curNames = new Set();
    const toCheck = [];
    fromSubclass.filter(c=>{
        const excludeClass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
            name: c.class.name,
            source: c.class.source
        }), "class", c.class.source, {
            isNoCount: true
        }, );
        if (excludeClass)
            return false;

        const excludeSubclass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
            shortName: c.subclass.shortName,
            source: c.subclass.source,
            className: c.class.name,
            classSource: c.class.source,
        }), "subclass", c.subclass.source, {
            isNoCount: true
        }, );
        if (excludeSubclass)
            return false;

        return !Renderer.spell.isExcludedSubclassVariantSource({
            classDefinedInSource: c.class.definedInSource
        });
    }
    ).sort((a,b)=>{
        const byName = SortUtil.ascSort(a.subclass.name, b.subclass.name);
        return byName || SortUtil.ascSort(a.class.name, b.class.name);
    }
    ).forEach(c=>{
        const nm = c.subclass.name;
        const src = c.subclass.source;

        const toAdd = Parser._spSubclassItem({
            fromSubclass: c,
            isTextOnly: false
        });

        const fromLookup = MiscUtil.get(subclassLookup, c.class.source, c.class.name, c.subclass.source, c.subclass.name, );

        if (fromLookup && fromLookup.isReprinted) {
            legacy.push(toAdd);
        } else if (SourceUtil.isNonstandardSource(src)) {
            const cleanName = Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent(nm.split("(")[0].trim().split(/v\d+/)[0].trim(), );
            toCheck.push({
                "name": cleanName,
                "ele": toAdd
            });
        } else {
            current.push(toAdd);
            curNames.add(nm);
        }
    }
    );

    toCheck.forEach(n=>{
        if (curNames.has(n.name)) {
            legacy.push(n.ele);
        } else {
            current.push(n.ele);
        }
    }
    );

    return [current.join(", "), legacy.join(", ")];
}
;

Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent = (shortName)=>{
    switch (shortName) {
    case "Favored Soul":
        return "Divine Soul";
    case "Undying Light":
        return "Celestial";
    case "Deep Stalker":
        return "Gloom Stalker";
    }
    return shortName;
}
;

Parser.spVariantClassesToCurrentAndLegacy = function(fromVariantClassList) {
    const current = [];
    const legacy = [];
    fromVariantClassList.forEach(cls=>{
        if (SourceUtil.isPrereleaseSource(cls.definedInSource))
            legacy.push(cls);
        else
            current.push(cls);
    }
    );
    return [current, legacy];
}
;

Parser.attackTypeToFull = function(attackType) {
    return Parser._parse_aToB(Parser.ATK_TYPE_TO_FULL, attackType);
}
;

Parser.trapHazTypeToFull = function(type) {
    return Parser._parse_aToB(Parser.TRAP_HAZARD_TYPE_TO_FULL, type);
}
;

Parser.TRAP_HAZARD_TYPE_TO_FULL = {
    MECH: "Mechanical Trap",
    MAG: "Magical Trap",
    SMPL: "Simple Trap",
    CMPX: "Complex Trap",
    HAZ: "Hazard",
    WTH: "Weather",
    ENV: "Environmental Hazard",
    WLD: "Wilderness Hazard",
    GEN: "Generic",
    EST: "Eldritch Storm",
};

Parser.tierToFullLevel = function(tier) {
    return Parser._parse_aToB(Parser.TIER_TO_FULL_LEVEL, tier);
}
;

Parser.TIER_TO_FULL_LEVEL = {};
Parser.TIER_TO_FULL_LEVEL[1] = "1st\u20134th Level";
Parser.TIER_TO_FULL_LEVEL[2] = "5th\u201310th Level";
Parser.TIER_TO_FULL_LEVEL[3] = "11th\u201316th Level";
Parser.TIER_TO_FULL_LEVEL[4] = "17th\u201320th Level";

Parser.trapInitToFull = function(init) {
    return Parser._parse_aToB(Parser.TRAP_INIT_TO_FULL, init);
}
;

Parser.TRAP_INIT_TO_FULL = {};
Parser.TRAP_INIT_TO_FULL[1] = "initiative count 10";
Parser.TRAP_INIT_TO_FULL[2] = "initiative count 20";
Parser.TRAP_INIT_TO_FULL[3] = "initiative count 20 and initiative count 10";

Parser.ATK_TYPE_TO_FULL = {};
Parser.ATK_TYPE_TO_FULL["MW"] = "Melee Weapon Attack";
Parser.ATK_TYPE_TO_FULL["RW"] = "Ranged Weapon Attack";

Parser.bookOrdinalToAbv = (ordinal,preNoSuff)=>{
    if (ordinal === undefined)
        return "";
    switch (ordinal.type) {
    case "part":
        return `${preNoSuff ? " " : ""}Part ${ordinal.identifier}${preNoSuff ? "" : " \u2014 "}`;
    case "chapter":
        return `${preNoSuff ? " " : ""}Ch. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
    case "episode":
        return `${preNoSuff ? " " : ""}Ep. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
    case "appendix":
        return `${preNoSuff ? " " : ""}App.${ordinal.identifier != null ? ` ${ordinal.identifier}` : ""}${preNoSuff ? "" : ": "}`;
    case "level":
        return `${preNoSuff ? " " : ""}Level ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
    default:
        throw new Error(`Unhandled ordinal type "${ordinal.type}"`);
    }
}
;

Parser.IMAGE_TYPE_TO_FULL = {
    "map": "Map",
    "mapPlayer": "Map (Player)",
};
Parser.imageTypeToFull = function(imageType) {
    return Parser._parse_aToB(Parser.IMAGE_TYPE_TO_FULL, imageType, "Other");
}
;

Parser.nameToTokenName = function(name) {
    return name.toAscii().replace(/"/g, "");
}
;

Parser.bytesToHumanReadable = function(bytes, {fixedDigits=2}={}) {
    if (bytes == null)
        return "";
    if (!bytes)
        return "0 B";
    const e = Math.floor(Math.log(bytes) / Math.log(1024));
    return `${(bytes / Math.pow(1024, e)).toFixed(fixedDigits)} ${`\u200bKMGTP`.charAt(e)}B`;
}
;

Parser.SKL_ABV_ABJ = "A";
Parser.SKL_ABV_EVO = "V";
Parser.SKL_ABV_ENC = "E";
Parser.SKL_ABV_ILL = "I";
Parser.SKL_ABV_DIV = "D";
Parser.SKL_ABV_NEC = "N";
Parser.SKL_ABV_TRA = "T";
Parser.SKL_ABV_CON = "C";
Parser.SKL_ABV_PSI = "P";
Parser.SKL_ABVS = [Parser.SKL_ABV_ABJ, Parser.SKL_ABV_CON, Parser.SKL_ABV_DIV, Parser.SKL_ABV_ENC, Parser.SKL_ABV_EVO, Parser.SKL_ABV_ILL, Parser.SKL_ABV_NEC, Parser.SKL_ABV_PSI, Parser.SKL_ABV_TRA, ];

Parser.SP_TM_ACTION = "action";
Parser.SP_TM_B_ACTION = "bonus";
Parser.SP_TM_REACTION = "reaction";
Parser.SP_TM_ROUND = "round";
Parser.SP_TM_MINS = "minute";
Parser.SP_TM_HRS = "hour";
Parser.SP_TIME_SINGLETONS = [Parser.SP_TM_ACTION, Parser.SP_TM_B_ACTION, Parser.SP_TM_REACTION, Parser.SP_TM_ROUND];
Parser.SP_TIME_TO_FULL = {
    [Parser.SP_TM_ACTION]: "Action",
    [Parser.SP_TM_B_ACTION]: "Bonus Action",
    [Parser.SP_TM_REACTION]: "Reaction",
    [Parser.SP_TM_ROUND]: "Rounds",
    [Parser.SP_TM_MINS]: "Minutes",
    [Parser.SP_TM_HRS]: "Hours",
};
Parser.spTimeUnitToFull = function(timeUnit) {
    return Parser._parse_aToB(Parser.SP_TIME_TO_FULL, timeUnit);
}
;

Parser.SP_TIME_TO_SHORT = {
    [Parser.SP_TM_ROUND]: "Rnd.",
    [Parser.SP_TM_MINS]: "Min.",
    [Parser.SP_TM_HRS]: "Hr.",
};
Parser.spTimeUnitToShort = function(timeUnit) {
    return Parser._parse_aToB(Parser.SP_TIME_TO_SHORT, timeUnit);
}
;

Parser.SP_TIME_TO_ABV = {
    [Parser.SP_TM_ACTION]: "A",
    [Parser.SP_TM_B_ACTION]: "BA",
    [Parser.SP_TM_REACTION]: "R",
    [Parser.SP_TM_ROUND]: "rnd",
    [Parser.SP_TM_MINS]: "min",
    [Parser.SP_TM_HRS]: "hr",
};
Parser.spTimeUnitToAbv = function(timeUnit) {
    return Parser._parse_aToB(Parser.SP_TIME_TO_ABV, timeUnit);
}
;

Parser.spTimeToShort = function(time, isHtml) {
    if (!time)
        return "";
    return (time.number === 1 && Parser.SP_TIME_SINGLETONS.includes(time.unit)) ? `${Parser.spTimeUnitToAbv(time.unit).uppercaseFirst()}${time.condition ? "*" : ""}` : `${time.number} ${isHtml ? `<span class="ve-small">` : ""}${Parser.spTimeUnitToAbv(time.unit)}${isHtml ? `</span>` : ""}${time.condition ? "*" : ""}`;
}
;

Parser.SKL_ABJ = "Abjuration";
Parser.SKL_EVO = "Evocation";
Parser.SKL_ENC = "Enchantment";
Parser.SKL_ILL = "Illusion";
Parser.SKL_DIV = "Divination";
Parser.SKL_NEC = "Necromancy";
Parser.SKL_TRA = "Transmutation";
Parser.SKL_CON = "Conjuration";
Parser.SKL_PSI = "Psionic";

Parser.SP_SCHOOL_ABV_TO_FULL = {};
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ABJ] = Parser.SKL_ABJ;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_EVO] = Parser.SKL_EVO;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ENC] = Parser.SKL_ENC;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ILL] = Parser.SKL_ILL;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_DIV] = Parser.SKL_DIV;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_NEC] = Parser.SKL_NEC;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_TRA] = Parser.SKL_TRA;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_CON] = Parser.SKL_CON;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_PSI] = Parser.SKL_PSI;

Parser.SP_SCHOOL_ABV_TO_SHORT = {};
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ABJ] = "Abj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_EVO] = "Evoc.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ENC] = "Ench.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ILL] = "Illu.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_DIV] = "Divin.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_NEC] = "Necro.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_TRA] = "Trans.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_CON] = "Conj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_PSI] = "Psi.";

Parser.ATB_ABV_TO_FULL = {
    "str": "Strength",
    "dex": "Dexterity",
    "con": "Constitution",
    "int": "Intelligence",
    "wis": "Wisdom",
    "cha": "Charisma",
};

Parser.TP_ABERRATION = "aberration";
Parser.TP_BEAST = "beast";
Parser.TP_CELESTIAL = "celestial";
Parser.TP_CONSTRUCT = "construct";
Parser.TP_DRAGON = "dragon";
Parser.TP_ELEMENTAL = "elemental";
Parser.TP_FEY = "fey";
Parser.TP_FIEND = "fiend";
Parser.TP_GIANT = "giant";
Parser.TP_HUMANOID = "humanoid";
Parser.TP_MONSTROSITY = "monstrosity";
Parser.TP_OOZE = "ooze";
Parser.TP_PLANT = "plant";
Parser.TP_UNDEAD = "undead";
Parser.MON_TYPES = [Parser.TP_ABERRATION, Parser.TP_BEAST, Parser.TP_CELESTIAL, Parser.TP_CONSTRUCT, Parser.TP_DRAGON, Parser.TP_ELEMENTAL, Parser.TP_FEY, Parser.TP_FIEND, Parser.TP_GIANT, Parser.TP_HUMANOID, Parser.TP_MONSTROSITY, Parser.TP_OOZE, Parser.TP_PLANT, Parser.TP_UNDEAD];
Parser.MON_TYPE_TO_PLURAL = {};
Parser.MON_TYPE_TO_PLURAL[Parser.TP_ABERRATION] = "aberrations";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_BEAST] = "beasts";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_CELESTIAL] = "celestials";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_CONSTRUCT] = "constructs";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_DRAGON] = "dragons";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_ELEMENTAL] = "elementals";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_FEY] = "fey";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_FIEND] = "fiends";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_GIANT] = "giants";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_HUMANOID] = "humanoids";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_MONSTROSITY] = "monstrosities";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_OOZE] = "oozes";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_PLANT] = "plants";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_UNDEAD] = "undead";

Parser.SZ_FINE = "F";
Parser.SZ_DIMINUTIVE = "D";
Parser.SZ_TINY = "T";
Parser.SZ_SMALL = "S";
Parser.SZ_MEDIUM = "M";
Parser.SZ_LARGE = "L";
Parser.SZ_HUGE = "H";
Parser.SZ_GARGANTUAN = "G";
Parser.SZ_COLOSSAL = "C";
Parser.SZ_VARIES = "V";
Parser.SIZE_ABVS = [Parser.SZ_TINY, Parser.SZ_SMALL, Parser.SZ_MEDIUM, Parser.SZ_LARGE, Parser.SZ_HUGE, Parser.SZ_GARGANTUAN, Parser.SZ_VARIES];
Parser.SIZE_ABV_TO_FULL = {};
Parser.SIZE_ABV_TO_FULL[Parser.SZ_FINE] = "Fine";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_DIMINUTIVE] = "Diminutive";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_TINY] = "Tiny";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_SMALL] = "Small";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_MEDIUM] = "Medium";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_LARGE] = "Large";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_HUGE] = "Huge";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_GARGANTUAN] = "Gargantuan";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_COLOSSAL] = "Colossal";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_VARIES] = "Varies";

Parser.XP_CHART_ALT = {
    "0": 10,
    "1/8": 25,
    "1/4": 50,
    "1/2": 100,
    "1": 200,
    "2": 450,
    "3": 700,
    "4": 1100,
    "5": 1800,
    "6": 2300,
    "7": 2900,
    "8": 3900,
    "9": 5000,
    "10": 5900,
    "11": 7200,
    "12": 8400,
    "13": 10000,
    "14": 11500,
    "15": 13000,
    "16": 15000,
    "17": 18000,
    "18": 20000,
    "19": 22000,
    "20": 25000,
    "21": 33000,
    "22": 41000,
    "23": 50000,
    "24": 62000,
    "25": 75000,
    "26": 90000,
    "27": 105000,
    "28": 120000,
    "29": 135000,
    "30": 155000,
};

Parser.ARMOR_ABV_TO_FULL = {
    "l.": "light",
    "m.": "medium",
    "h.": "heavy",
};

Parser.WEAPON_ABV_TO_FULL = {
    "s.": "simple",
    "m.": "martial",
};

Parser.CONDITION_TO_COLOR = {
    "Blinded": "#525252",
    "Charmed": "#f01789",
    "Deafened": "#ababab",
    "Exhausted": "#947a47",
    "Frightened": "#c9ca18",
    "Grappled": "#8784a0",
    "Incapacitated": "#3165a0",
    "Invisible": "#7ad2d6",
    "Paralyzed": "#c00900",
    "Petrified": "#a0a0a0",
    "Poisoned": "#4dc200",
    "Prone": "#5e60a0",
    "Restrained": "#d98000",
    "Stunned": "#a23bcb",
    "Unconscious": "#3a40ad",

    "Concentration": "#009f7a",
};

Parser.RULE_TYPE_TO_FULL = {
    "O": "Optional",
    "P": "Prerelease",
    "V": "Variant",
    "VO": "Variant Optional",
    "VV": "Variant Variant",
    "U": "Unknown",
};

Parser.ruleTypeToFull = function(ruleType) {
    return Parser._parse_aToB(Parser.RULE_TYPE_TO_FULL, ruleType);
}
;

Parser.VEHICLE_TYPE_TO_FULL = {
    "SHIP": "Ship",
    "SPELLJAMMER": "Spelljammer Ship",
    "INFWAR": "Infernal War Machine",
    "CREATURE": "Creature",
    "OBJECT": "Object",
    "SHP:H": "Ship Upgrade, Hull",
    "SHP:M": "Ship Upgrade, Movement",
    "SHP:W": "Ship Upgrade, Weapon",
    "SHP:F": "Ship Upgrade, Figurehead",
    "SHP:O": "Ship Upgrade, Miscellaneous",
    "IWM:W": "Infernal War Machine Variant, Weapon",
    "IWM:A": "Infernal War Machine Upgrade, Armor",
    "IWM:G": "Infernal War Machine Upgrade, Gadget",
};

Parser.vehicleTypeToFull = function(vehicleType) {
    return Parser._parse_aToB(Parser.VEHICLE_TYPE_TO_FULL, vehicleType);
}
;

Parser.SRC_5ETOOLS_TMP = "Parser.SRC_5ETOOLS_TMP";
Parser.SRC_CoS = "CoS";
Parser.SRC_DMG = "DMG";
Parser.SRC_EEPC = "EEPC";
Parser.SRC_EET = "EET";
Parser.SRC_HotDQ = "HotDQ";
Parser.SRC_LMoP = "LMoP";
Parser.SRC_MM = "MM";
Parser.SRC_OotA = "OotA";
Parser.SRC_PHB = "PHB";
Parser.SRC_PotA = "PotA";
Parser.SRC_RoT = "RoT";
Parser.SRC_RoTOS = "RoTOS";
Parser.SRC_SCAG = "SCAG";
Parser.SRC_SKT = "SKT";
Parser.SRC_ToA = "ToA";
Parser.SRC_TLK = "TLK";
Parser.SRC_ToD = "ToD";
Parser.SRC_TTP = "TTP";
Parser.SRC_TYP = "TftYP";
Parser.SRC_TYP_AtG = "TftYP-AtG";
Parser.SRC_TYP_DiT = "TftYP-DiT";
Parser.SRC_TYP_TFoF = "TftYP-TFoF";
Parser.SRC_TYP_THSoT = "TftYP-THSoT";
Parser.SRC_TYP_TSC = "TftYP-TSC";
Parser.SRC_TYP_ToH = "TftYP-ToH";
Parser.SRC_TYP_WPM = "TftYP-WPM";
Parser.SRC_VGM = "VGM";
Parser.SRC_XGE = "XGE";
Parser.SRC_OGA = "OGA";
Parser.SRC_MTF = "MTF";
Parser.SRC_WDH = "WDH";
Parser.SRC_WDMM = "WDMM";
Parser.SRC_GGR = "GGR";
Parser.SRC_KKW = "KKW";
Parser.SRC_LLK = "LLK";
Parser.SRC_AZfyT = "AZfyT";
Parser.SRC_GoS = "GoS";
Parser.SRC_AI = "AI";
Parser.SRC_OoW = "OoW";
Parser.SRC_ESK = "ESK";
Parser.SRC_DIP = "DIP";
Parser.SRC_HftT = "HftT";
Parser.SRC_DC = "DC";
Parser.SRC_SLW = "SLW";
Parser.SRC_SDW = "SDW";
Parser.SRC_BGDIA = "BGDIA";
Parser.SRC_LR = "LR";
Parser.SRC_AL = "AL";
Parser.SRC_SAC = "SAC";
Parser.SRC_ERLW = "ERLW";
Parser.SRC_EFR = "EFR";
Parser.SRC_RMBRE = "RMBRE";
Parser.SRC_RMR = "RMR";
Parser.SRC_MFF = "MFF";
Parser.SRC_AWM = "AWM";
Parser.SRC_IMR = "IMR";
Parser.SRC_SADS = "SADS";
Parser.SRC_EGW = "EGW";
Parser.SRC_EGW_ToR = "ToR";
Parser.SRC_EGW_DD = "DD";
Parser.SRC_EGW_FS = "FS";
Parser.SRC_EGW_US = "US";
Parser.SRC_MOT = "MOT";
Parser.SRC_IDRotF = "IDRotF";
Parser.SRC_TCE = "TCE";
Parser.SRC_VRGR = "VRGR";
Parser.SRC_HoL = "HoL";
Parser.SRC_XMtS = "XMtS";
Parser.SRC_RtG = "RtG";
Parser.SRC_AitFR = "AitFR";
Parser.SRC_AitFR_ISF = "AitFR-ISF";
Parser.SRC_AitFR_THP = "AitFR-THP";
Parser.SRC_AitFR_AVT = "AitFR-AVT";
Parser.SRC_AitFR_DN = "AitFR-DN";
Parser.SRC_AitFR_FCD = "AitFR-FCD";
Parser.SRC_WBtW = "WBtW";
Parser.SRC_DoD = "DoD";
Parser.SRC_MaBJoV = "MaBJoV";
Parser.SRC_FTD = "FTD";
Parser.SRC_SCC = "SCC";
Parser.SRC_SCC_CK = "SCC-CK";
Parser.SRC_SCC_HfMT = "SCC-HfMT";
Parser.SRC_SCC_TMM = "SCC-TMM";
Parser.SRC_SCC_ARiR = "SCC-ARiR";
Parser.SRC_MPMM = "MPMM";
Parser.SRC_CRCotN = "CRCotN";
Parser.SRC_JttRC = "JttRC";
Parser.SRC_SAiS = "SAiS";
Parser.SRC_AAG = "AAG";
Parser.SRC_BAM = "BAM";
Parser.SRC_LoX = "LoX";
Parser.SRC_DoSI = "DoSI";
Parser.SRC_DSotDQ = "DSotDQ";
Parser.SRC_KftGV = "KftGV";
Parser.SRC_BGG = "BGG";
Parser.SRC_TDCSR = "TDCSR";
Parser.SRC_PaBTSO = "PaBTSO";
Parser.SRC_PAitM = "PAitM";
Parser.SRC_SatO = "SatO";
Parser.SRC_ToFW = "ToFW";
Parser.SRC_MPP = "MPP";
Parser.SRC_BMT = "BMT";
Parser.SRC_GHLoE = "GHLoE";
Parser.SRC_DoDk = "DoDk";
Parser.SRC_SCREEN = "Screen";
Parser.SRC_SCREEN_WILDERNESS_KIT = "ScreenWildernessKit";
Parser.SRC_SCREEN_DUNGEON_KIT = "ScreenDungeonKit";
Parser.SRC_SCREEN_SPELLJAMMER = "ScreenSpelljammer";
Parser.SRC_HF = "HF";
Parser.SRC_HFFotM = "HFFotM";
Parser.SRC_HFStCM = "HFStCM";
Parser.SRC_CM = "CM";
Parser.SRC_NRH = "NRH";
Parser.SRC_NRH_TCMC = "NRH-TCMC";
Parser.SRC_NRH_AVitW = "NRH-AVitW";
Parser.SRC_NRH_ASS = "NRH-ASS";
Parser.SRC_NRH_CoI = "NRH-CoI";
Parser.SRC_NRH_TLT = "NRH-TLT";
Parser.SRC_NRH_AWoL = "NRH-AWoL";
Parser.SRC_NRH_AT = "NRH-AT";
Parser.SRC_MGELFT = "MGELFT";
Parser.SRC_VD = "VD";
Parser.SRC_SjA = "SjA";
Parser.SRC_HAT_TG = "HAT-TG";
Parser.SRC_HAT_LMI = "HAT-LMI";
Parser.SRC_GotSF = "GotSF";
Parser.SRC_LK = "LK";
Parser.SRC_CoA = "CoA";
Parser.SRC_PiP = "PiP";

Parser.SRC_AL_PREFIX = "AL";

Parser.SRC_ALCoS = `${Parser.SRC_AL_PREFIX}CurseOfStrahd`;
Parser.SRC_ALEE = `${Parser.SRC_AL_PREFIX}ElementalEvil`;
Parser.SRC_ALRoD = `${Parser.SRC_AL_PREFIX}RageOfDemons`;

Parser.SRC_PS_PREFIX = "PS";

Parser.SRC_PSA = `${Parser.SRC_PS_PREFIX}A`;
Parser.SRC_PSI = `${Parser.SRC_PS_PREFIX}I`;
Parser.SRC_PSK = `${Parser.SRC_PS_PREFIX}K`;
Parser.SRC_PSZ = `${Parser.SRC_PS_PREFIX}Z`;
Parser.SRC_PSX = `${Parser.SRC_PS_PREFIX}X`;
Parser.SRC_PSD = `${Parser.SRC_PS_PREFIX}D`;

Parser.SRC_UA_PREFIX = "UA";
Parser.SRC_UA_ONE_PREFIX = "XUA";
Parser.SRC_MCVX_PREFIX = "MCV";
Parser.SRC_MisMVX_PREFIX = "MisMV";
Parser.SRC_AA_PREFIX = "AA";

Parser.SRC_UATMC = `${Parser.SRC_UA_PREFIX}TheMysticClass`;
Parser.SRC_MCV1SC = `${Parser.SRC_MCVX_PREFIX}1SC`;
Parser.SRC_MCV2DC = `${Parser.SRC_MCVX_PREFIX}2DC`;
Parser.SRC_MCV3MC = `${Parser.SRC_MCVX_PREFIX}3MC`;
Parser.SRC_MCV4EC = `${Parser.SRC_MCVX_PREFIX}4EC`;
Parser.SRC_MisMV1 = `${Parser.SRC_MisMVX_PREFIX}1`;
Parser.SRC_AATM = `${Parser.SRC_AA_PREFIX}TM`;

Parser.AL_PREFIX = "Adventurers League: ";
Parser.AL_PREFIX_SHORT = "AL: ";
Parser.PS_PREFIX = "Plane Shift: ";
Parser.PS_PREFIX_SHORT = "PS: ";
Parser.UA_PREFIX = "Unearthed Arcana: ";
Parser.UA_PREFIX_SHORT = "UA: ";
Parser.TftYP_NAME = "Tales from the Yawning Portal";
Parser.AitFR_NAME = "Adventures in the Forgotten Realms";
Parser.NRH_NAME = "NERDS Restoring Harmony";
Parser.MCVX_PREFIX = "Monstrous Compendium Volume ";
Parser.MisMVX_PREFIX = "Misplaced Monsters: Volume ";
Parser.AA_PREFIX = "Adventure Atlas: ";

Parser.SOURCE_JSON_TO_FULL = {};
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CoS] = "Curse of Strahd";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DMG] = "Dungeon Master's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EEPC] = "Elemental Evil Player's Companion";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EET] = "Elemental Evil: Trinkets";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HotDQ] = "Hoard of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LMoP] = "Lost Mine of Phandelver";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MM] = "Monster Manual";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OotA] = "Out of the Abyss";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PHB] = "Player's Handbook";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PotA] = "Princes of the Apocalypse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RoT] = "The Rise of Tiamat";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RoTOS] = "The Rise of Tiamat Online Supplement";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCAG] = "Sword Coast Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SKT] = "Storm King's Thunder";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToA] = "Tomb of Annihilation";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TLK] = "The Lost Kenku";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToD] = "Tyranny of Dragons";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TTP] = "The Tortle Package";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP] = Parser.TftYP_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_AtG] = `${Parser.TftYP_NAME}: Against the Giants`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_DiT] = `${Parser.TftYP_NAME}: Dead in Thay`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_TFoF] = `${Parser.TftYP_NAME}: The Forge of Fury`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_THSoT] = `${Parser.TftYP_NAME}: The Hidden Shrine of Tamoachan`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_TSC] = `${Parser.TftYP_NAME}: The Sunless Citadel`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_ToH] = `${Parser.TftYP_NAME}: Tomb of Horrors`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_WPM] = `${Parser.TftYP_NAME}: White Plume Mountain`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VGM] = "Volo's Guide to Monsters";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_XGE] = "Xanathar's Guide to Everything";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OGA] = "One Grung Above";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MTF] = "Mordenkainen's Tome of Foes";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WDH] = "Waterdeep: Dragon Heist";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WDMM] = "Waterdeep: Dungeon of the Mad Mage";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GGR] = "Guildmasters' Guide to Ravnica";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_KKW] = "Krenko's Way";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LLK] = "Lost Laboratory of Kwalish";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AZfyT] = "A Zib for your Thoughts";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GoS] = "Ghosts of Saltmarsh";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AI] = "Acquisitions Incorporated";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OoW] = "The Orrery of the Wanderer";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ESK] = "Essentials Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DIP] = "Dragon of Icespire Peak";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HftT] = "Hunt for the Thessalhydra";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DC] = "Divine Contention";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SLW] = "Storm Lord's Wrath";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SDW] = "Sleeping Dragon's Wake";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BGDIA] = "Baldur's Gate: Descent Into Avernus";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LR] = "Locathah Rising";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AL] = "Adventurers' League";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SAC] = "Sage Advice Compendium";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ERLW] = "Eberron: Rising from the Last War";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EFR] = "Eberron: Forgotten Relics";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RMBRE] = "The Lost Dungeon of Rickedness: Big Rick Energy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RMR] = "Dungeons & Dragons vs. Rick and Morty: Basic Rules";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MFF] = "Mordenkainen's Fiendish Folio";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AWM] = "Adventure with Muk";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_IMR] = "Infernal Machine Rebuild";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SADS] = "Sapphire Anniversary Dice Set";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW] = "Explorer's Guide to Wildemount";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_ToR] = "Tide of Retribution";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_DD] = "Dangerous Designs";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_FS] = "Frozen Sick";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_US] = "Unwelcome Spirits";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MOT] = "Mythic Odysseys of Theros";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_IDRotF] = "Icewind Dale: Rime of the Frostmaiden";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TCE] = "Tasha's Cauldron of Everything";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VRGR] = "Van Richten's Guide to Ravenloft";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HoL] = "The House of Lament";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RtG] = "Return to Glory";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR] = Parser.AitFR_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_ISF] = `${Parser.AitFR_NAME}: In Scarlet Flames`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_THP] = `${Parser.AitFR_NAME}: The Hidden Page`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_AVT] = `${Parser.AitFR_NAME}: A Verdant Tomb`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_DN] = `${Parser.AitFR_NAME}: Deepest Night`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_FCD] = `${Parser.AitFR_NAME}: From Cyan Depths`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WBtW] = "The Wild Beyond the Witchlight";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoD] = "Domains of Delight";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MaBJoV] = "Minsc and Boo's Journal of Villainy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_FTD] = "Fizban's Treasury of Dragons";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC] = "Strixhaven: A Curriculum of Chaos";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_CK] = "Campus Kerfuffle";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_HfMT] = "Hunt for Mage Tower";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_TMM] = "The Magister's Masquerade";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_ARiR] = "A Reckoning in Ruins";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MPMM] = "Mordenkainen Presents: Monsters of the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CRCotN] = "Critical Role: Call of the Netherdeep";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_JttRC] = "Journeys through the Radiant Citadel";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SAiS] = "Spelljammer: Adventures in Space";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AAG] = "Astral Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BAM] = "Boo's Astral Menagerie";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LoX] = "Light of Xaryxis";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoSI] = "Dragons of Stormwreck Isle";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DSotDQ] = "Dragonlance: Shadow of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_KftGV] = "Keys from the Golden Vault";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BGG] = "Bigby Presents: Glory of the Giants";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TDCSR] = "Tal'Dorei Campaign Setting Reborn";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PaBTSO] = "Phandelver and Below: The Shattered Obelisk";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PAitM] = "Planescape: Adventures in the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SatO] = "Sigil and the Outlands";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToFW] = "Turn of Fortune's Wheel";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MPP] = "Morte's Planar Parade";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BMT] = "The Book of Many Things";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GHLoE] = "Grim Hollow: Lairs of Etharis";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoDk] = "Dungeons of Drakkenheim";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN] = "Dungeon Master's Screen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_WILDERNESS_KIT] = "Dungeon Master's Screen: Wilderness Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_DUNGEON_KIT] = "Dungeon Master's Screen: Dungeon Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_SPELLJAMMER] = "Dungeon Master's Screen: Spelljammer";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HF] = "Heroes' Feast";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HFFotM] = "Heroes' Feast: Flavors of the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HFStCM] = "Heroes' Feast: Saving the Childrens Menu";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CM] = "Candlekeep Mysteries";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH] = Parser.NRH_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_TCMC] = `${Parser.NRH_NAME}: The Candy Mountain Caper`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AVitW] = `${Parser.NRH_NAME}: A Voice in the Wilderness`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_ASS] = `${Parser.NRH_NAME}: A Sticky Situation`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_CoI] = `${Parser.NRH_NAME}: Circus of Illusions`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_TLT] = `${Parser.NRH_NAME}: The Lost Tomb`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AWoL] = `${Parser.NRH_NAME}: A Web of Lies`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AT] = `${Parser.NRH_NAME}: Adventure Together`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MGELFT] = "Muk's Guide To Everything He Learned From Tasha";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VD] = "Vecna Dossier";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SjA] = "Spelljammer Academy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HAT_TG] = "Honor Among Thieves: Thieves' Gallery";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HAT_LMI] = "Honor Among Thieves: Legendary Magic Items";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GotSF] = "Giants of the Star Forge";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LK] = "Lightning Keep";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CoA] = "Chains of Asmodeus";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PiP] = "Peril in Pinebrook";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALCoS] = `${Parser.AL_PREFIX}Curse of Strahd`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALEE] = `${Parser.AL_PREFIX}Elemental Evil`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALRoD] = `${Parser.AL_PREFIX}Rage of Demons`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSA] = `${Parser.PS_PREFIX}Amonkhet`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSI] = `${Parser.PS_PREFIX}Innistrad`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSK] = `${Parser.PS_PREFIX}Kaladesh`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSZ] = `${Parser.PS_PREFIX}Zendikar`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSX] = `${Parser.PS_PREFIX}Ixalan`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSD] = `${Parser.PS_PREFIX}Dominaria`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_XMtS] = `X Marks the Spot`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATMC] = `${Parser.UA_PREFIX}The Mystic Class`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV1SC] = `${Parser.MCVX_PREFIX}1: Spelljammer Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV2DC] = `${Parser.MCVX_PREFIX}2: Dragonlance Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV3MC] = `${Parser.MCVX_PREFIX}3: Minecraft Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV4EC] = `${Parser.MCVX_PREFIX}4: Eldraine Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MisMV1] = `${Parser.MisMVX_PREFIX}1`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AATM] = `${Parser.AA_PREFIX}The Mortuary`;

Parser.SOURCE_JSON_TO_ABV = {};
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CoS] = "CoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DMG] = "DMG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EEPC] = "EEPC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EET] = "EET";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HotDQ] = "HotDQ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LMoP] = "LMoP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MM] = "MM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OotA] = "OotA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PHB] = "PHB";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PotA] = "PotA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RoT] = "RoT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RoTOS] = "RoTOS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCAG] = "SCAG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SKT] = "SKT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToA] = "ToA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TLK] = "TLK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToD] = "ToD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TTP] = "TTP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_AtG] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_DiT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_TFoF] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_THSoT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_TSC] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_ToH] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_WPM] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VGM] = "VGM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_XGE] = "XGE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OGA] = "OGA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MTF] = "MTF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WDH] = "WDH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WDMM] = "WDMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GGR] = "GGR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_KKW] = "KKW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LLK] = "LLK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AZfyT] = "AZfyT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GoS] = "GoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AI] = "AI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OoW] = "OoW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ESK] = "ESK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DIP] = "DIP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HftT] = "HftT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DC] = "DC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SLW] = "SLW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SDW] = "SDW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BGDIA] = "BGDIA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LR] = "LR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AL] = "AL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SAC] = "SAC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ERLW] = "ERLW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EFR] = "EFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RMBRE] = "RMBRE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RMR] = "RMR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MFF] = "MFF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AWM] = "AWM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_IMR] = "IMR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SADS] = "SADS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW] = "EGW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_ToR] = "ToR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_DD] = "DD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_FS] = "FS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_US] = "US";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MOT] = "MOT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_IDRotF] = "IDRotF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TCE] = "TCE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VRGR] = "VRGR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HoL] = "HoL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RtG] = "RtG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR] = "AitFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_ISF] = "AitFR-ISF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_THP] = "AitFR-THP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_AVT] = "AitFR-AVT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_DN] = "AitFR-DN";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_FCD] = "AitFR-FCD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WBtW] = "WBtW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoD] = "DoD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MaBJoV] = "MaBJoV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_FTD] = "FTD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC] = "SCC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_CK] = "SCC-CK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_HfMT] = "SCC-HfMT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_TMM] = "SCC-TMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_ARiR] = "SCC-ARiR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MPMM] = "MPMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CRCotN] = "CRCotN";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_JttRC] = "JttRC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SAiS] = "SAiS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AAG] = "AAG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BAM] = "BAM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LoX] = "LoX";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoSI] = "DoSI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DSotDQ] = "DSotDQ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_KftGV] = "KftGV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BGG] = "BGG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TDCSR] = "TDCSR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PaBTSO] = "PaBTSO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PAitM] = "PAitM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SatO] = "SatO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToFW] = "ToFW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MPP] = "MPP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BMT] = "BMT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GHLoE] = "GHLoE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoDk] = "DoDk";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN] = "Screen";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_WILDERNESS_KIT] = "ScWild";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_DUNGEON_KIT] = "ScDun";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_SPELLJAMMER] = "ScSJ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HF] = "HF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HFFotM] = "HFFotM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HFStCM] = "HFStCM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CM] = "CM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH] = "NRH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_TCMC] = "NRH-TCMC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AVitW] = "NRH-AVitW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_ASS] = "NRH-ASS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_CoI] = "NRH-CoI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_TLT] = "NRH-TLT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AWoL] = "NRH-AWoL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AT] = "NRH-AT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MGELFT] = "MGELFT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VD] = "VD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SjA] = "SjA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HAT_TG] = "HAT-TG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HAT_LMI] = "HAT-LMI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GotSF] = "GotSF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LK] = "LK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CoA] = "CoA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PiP] = "PiP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALCoS] = "ALCoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALEE] = "ALEE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALRoD] = "ALRoD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSA] = "PSA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSI] = "PSI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSK] = "PSK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSZ] = "PSZ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSX] = "PSX";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSD] = "PSD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_XMtS] = "XMtS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATMC] = "UAMy";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV1SC] = "MCV1SC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV2DC] = "MCV2DC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV3MC] = "MCV3MC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV4EC] = "MCV4EC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MisMV1] = "MisMV1";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AATM] = "AATM";

Parser.SOURCE_JSON_TO_DATE = {};
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DMG] = "2014-12-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EEPC] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EET] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HotDQ] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LMoP] = "2014-07-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MM] = "2014-09-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OotA] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PHB] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PotA] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RoT] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RoTOS] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCAG] = "2015-11-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SKT] = "2016-09-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToA] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TLK] = "2017-11-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToD] = "2019-10-22";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TTP] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_AtG] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_DiT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_TFoF] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_THSoT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_TSC] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_ToH] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_WPM] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VGM] = "2016-11-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_XGE] = "2017-11-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OGA] = "2017-10-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MTF] = "2018-05-29";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WDH] = "2018-09-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WDMM] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GGR] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_KKW] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LLK] = "2018-11-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AZfyT] = "2019-03-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GoS] = "2019-05-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AI] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OoW] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ESK] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DIP] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HftT] = "2019-05-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DC] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SLW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SDW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BGDIA] = "2019-09-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LR] = "2019-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SAC] = "2019-01-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ERLW] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EFR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RMBRE] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RMR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MFF] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AWM] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_IMR] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SADS] = "2019-12-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_ToR] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_DD] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_FS] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_US] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MOT] = "2020-06-02";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_IDRotF] = "2020-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TCE] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VRGR] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HoL] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RtG] = "2021-05-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_ISF] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_THP] = "2021-07-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_AVT] = "2021-07-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_DN] = "2021-07-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_FCD] = "2021-07-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WBtW] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoD] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MaBJoV] = "2021-10-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_FTD] = "2021-11-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_CK] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_HfMT] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_TMM] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_ARiR] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MPMM] = "2022-01-25";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CRCotN] = "2022-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_JttRC] = "2022-07-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SAiS] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AAG] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BAM] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LoX] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoSI] = "2022-07-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DSotDQ] = "2022-11-22";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_KftGV] = "2023-02-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BGG] = "2023-08-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TDCSR] = "2022-01-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PaBTSO] = "2023-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PAitM] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SatO] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToFW] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MPP] = "2023-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BMT] = "2023-11-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GHLoE] = "2023-11-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoDk] = "2023-12-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN] = "2015-01-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_WILDERNESS_KIT] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_DUNGEON_KIT] = "2020-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_SPELLJAMMER] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HF] = "2020-10-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HFFotM] = "2023-11-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HFStCM] = "2023-11-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CM] = "2021-03-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_TCMC] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AVitW] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_ASS] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_CoI] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_TLT] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AWoL] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AT] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MGELFT] = "2020-12-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VD] = "2022-06-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SjA] = "2022-07-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HAT_TG] = "2023-03-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HAT_LMI] = "2023-03-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GotSF] = "2023-08-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LK] = "2023-09-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CoA] = "2023-10-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PiP] = "2023-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALCoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALEE] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALRoD] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSA] = "2017-07-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSI] = "2016-07-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSK] = "2017-02-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSZ] = "2016-04-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSX] = "2018-01-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSD] = "2018-07-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_XMtS] = "2017-12-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATMC] = "2017-03-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV1SC] = "2022-04-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV2DC] = "2022-12-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV3MC] = "2023-03-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV4EC] = "2023-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MisMV1] = "2023-05-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AATM] = "2023-10-17";

Parser.SOURCES_ADVENTURES = new Set([Parser.SRC_LMoP, Parser.SRC_HotDQ, Parser.SRC_RoT, Parser.SRC_RoTOS, Parser.SRC_PotA, Parser.SRC_OotA, Parser.SRC_CoS, Parser.SRC_SKT, Parser.SRC_TYP, Parser.SRC_TYP_AtG, Parser.SRC_TYP_DiT, Parser.SRC_TYP_TFoF, Parser.SRC_TYP_THSoT, Parser.SRC_TYP_TSC, Parser.SRC_TYP_ToH, Parser.SRC_TYP_WPM, Parser.SRC_ToA, Parser.SRC_TLK, Parser.SRC_TTP, Parser.SRC_WDH, Parser.SRC_LLK, Parser.SRC_WDMM, Parser.SRC_KKW, Parser.SRC_AZfyT, Parser.SRC_GoS, Parser.SRC_HftT, Parser.SRC_OoW, Parser.SRC_DIP, Parser.SRC_SLW, Parser.SRC_SDW, Parser.SRC_DC, Parser.SRC_BGDIA, Parser.SRC_LR, Parser.SRC_EFR, Parser.SRC_RMBRE, Parser.SRC_IMR, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US, Parser.SRC_IDRotF, Parser.SRC_CM, Parser.SRC_HoL, Parser.SRC_XMtS, Parser.SRC_RtG, Parser.SRC_AitFR, Parser.SRC_AitFR_ISF, Parser.SRC_AitFR_THP, Parser.SRC_AitFR_AVT, Parser.SRC_AitFR_DN, Parser.SRC_AitFR_FCD, Parser.SRC_WBtW, Parser.SRC_NRH, Parser.SRC_NRH_TCMC, Parser.SRC_NRH_AVitW, Parser.SRC_NRH_ASS, Parser.SRC_NRH_CoI, Parser.SRC_NRH_TLT, Parser.SRC_NRH_AWoL, Parser.SRC_NRH_AT, Parser.SRC_SCC, Parser.SRC_SCC_CK, Parser.SRC_SCC_HfMT, Parser.SRC_SCC_TMM, Parser.SRC_SCC_ARiR, Parser.SRC_CRCotN, Parser.SRC_JttRC, Parser.SRC_SjA, Parser.SRC_LoX, Parser.SRC_DoSI, Parser.SRC_DSotDQ, Parser.SRC_KftGV, Parser.SRC_GotSF, Parser.SRC_PaBTSO, Parser.SRC_LK, Parser.SRC_CoA, Parser.SRC_PiP, Parser.SRC_HFStCM, Parser.SRC_GHLoE, Parser.SRC_DoDk,
Parser.SRC_AWM, ]);
Parser.SOURCES_CORE_SUPPLEMENTS = new Set(Object.keys(Parser.SOURCE_JSON_TO_FULL).filter(it=>!Parser.SOURCES_ADVENTURES.has(it)));
Parser.SOURCES_NON_STANDARD_WOTC = new Set([Parser.SRC_OGA, Parser.SRC_LLK, Parser.SRC_AZfyT, Parser.SRC_LR, Parser.SRC_TLK, Parser.SRC_TTP, Parser.SRC_AWM, Parser.SRC_IMR, Parser.SRC_SADS, Parser.SRC_MFF, Parser.SRC_XMtS, Parser.SRC_RtG, Parser.SRC_AitFR, Parser.SRC_AitFR_ISF, Parser.SRC_AitFR_THP, Parser.SRC_AitFR_AVT, Parser.SRC_AitFR_DN, Parser.SRC_AitFR_FCD, Parser.SRC_DoD, Parser.SRC_MaBJoV, Parser.SRC_NRH, Parser.SRC_NRH_TCMC, Parser.SRC_NRH_AVitW, Parser.SRC_NRH_ASS, Parser.SRC_NRH_CoI, Parser.SRC_NRH_TLT, Parser.SRC_NRH_AWoL, Parser.SRC_NRH_AT, Parser.SRC_MGELFT, Parser.SRC_VD, Parser.SRC_SjA, Parser.SRC_HAT_TG, Parser.SRC_HAT_LMI, Parser.SRC_GotSF, Parser.SRC_MCV3MC, Parser.SRC_MCV4EC, Parser.SRC_MisMV1, Parser.SRC_LK, Parser.SRC_AATM, Parser.SRC_CoA, Parser.SRC_PiP, Parser.SRC_HFStCM, ]);
Parser.SOURCES_PARTNERED_WOTC = new Set([Parser.SRC_RMBRE, Parser.SRC_RMR, Parser.SRC_EGW, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US, Parser.SRC_CRCotN, Parser.SRC_TDCSR, Parser.SRC_HftT, Parser.SRC_GHLoE, Parser.SRC_DoDk, ]);

Parser.SOURCES_VANILLA = new Set([Parser.SRC_DMG, Parser.SRC_MM, Parser.SRC_PHB, Parser.SRC_SCAG, Parser.SRC_XGE, Parser.SRC_SAC, Parser.SRC_MFF, Parser.SRC_SADS, Parser.SRC_TCE, Parser.SRC_FTD, Parser.SRC_MPMM, Parser.SRC_SCREEN, Parser.SRC_SCREEN_WILDERNESS_KIT, Parser.SRC_SCREEN_DUNGEON_KIT, Parser.SRC_VD, Parser.SRC_GotSF, Parser.SRC_BGG, Parser.SRC_MaBJoV, Parser.SRC_CoA, Parser.SRC_BMT, ]);

Parser.SOURCES_COMEDY = new Set([Parser.SRC_AI, Parser.SRC_OoW, Parser.SRC_RMR, Parser.SRC_RMBRE, Parser.SRC_HftT, Parser.SRC_AWM, Parser.SRC_MGELFT, Parser.SRC_HAT_TG, Parser.SRC_HAT_LMI, Parser.SRC_MCV3MC, Parser.SRC_MisMV1, Parser.SRC_LK, Parser.SRC_PiP, ]);

Parser.SOURCES_NON_FR = new Set([Parser.SRC_GGR, Parser.SRC_KKW, Parser.SRC_ERLW, Parser.SRC_EFR, Parser.SRC_EGW, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US, Parser.SRC_MOT, Parser.SRC_XMtS, Parser.SRC_AZfyT, Parser.SRC_SCC, Parser.SRC_SCC_CK, Parser.SRC_SCC_HfMT, Parser.SRC_SCC_TMM, Parser.SRC_SCC_ARiR, Parser.SRC_CRCotN, Parser.SRC_SjA, Parser.SRC_SAiS, Parser.SRC_AAG, Parser.SRC_BAM, Parser.SRC_LoX, Parser.SRC_DSotDQ, Parser.SRC_TDCSR, Parser.SRC_PAitM, Parser.SRC_SatO, Parser.SRC_ToFW, Parser.SRC_MPP, Parser.SRC_MCV4EC, Parser.SRC_LK, Parser.SRC_GHLoE, Parser.SRC_DoDk, ]);

Parser.SOURCES_AVAILABLE_DOCS_BOOK = {};
[Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG, Parser.SRC_SCAG, Parser.SRC_VGM, Parser.SRC_OGA, Parser.SRC_XGE, Parser.SRC_MTF, Parser.SRC_GGR, Parser.SRC_AI, Parser.SRC_ERLW, Parser.SRC_RMR, Parser.SRC_EGW, Parser.SRC_MOT, Parser.SRC_TCE, Parser.SRC_VRGR, Parser.SRC_DoD, Parser.SRC_MaBJoV, Parser.SRC_FTD, Parser.SRC_SCC, Parser.SRC_MPMM, Parser.SRC_AAG, Parser.SRC_BAM, Parser.SRC_HAT_TG, Parser.SRC_SCREEN, Parser.SRC_SCREEN_WILDERNESS_KIT, Parser.SRC_SCREEN_DUNGEON_KIT, Parser.SRC_SCREEN_SPELLJAMMER, Parser.SRC_BGG, Parser.SRC_TDCSR, Parser.SRC_SatO, Parser.SRC_MPP, Parser.SRC_HF, Parser.SRC_HFFotM, Parser.SRC_BMT, ].forEach(src=>{
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = src;
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = src;
}
);
[{
    src: Parser.SRC_PSA,
    id: "PS-A"
}, {
    src: Parser.SRC_PSI,
    id: "PS-I"
}, {
    src: Parser.SRC_PSK,
    id: "PS-K"
}, {
    src: Parser.SRC_PSZ,
    id: "PS-Z"
}, {
    src: Parser.SRC_PSX,
    id: "PS-X"
}, {
    src: Parser.SRC_PSD,
    id: "PS-D"
}, ].forEach(({src, id})=>{
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = id;
    Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = id;
}
);
Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE = {};
[Parser.SRC_LMoP, Parser.SRC_HotDQ, Parser.SRC_RoT, Parser.SRC_PotA, Parser.SRC_OotA, Parser.SRC_CoS, Parser.SRC_SKT, Parser.SRC_TYP_AtG, Parser.SRC_TYP_DiT, Parser.SRC_TYP_TFoF, Parser.SRC_TYP_THSoT, Parser.SRC_TYP_TSC, Parser.SRC_TYP_ToH, Parser.SRC_TYP_WPM, Parser.SRC_ToA, Parser.SRC_TLK, Parser.SRC_TTP, Parser.SRC_WDH, Parser.SRC_LLK, Parser.SRC_WDMM, Parser.SRC_KKW, Parser.SRC_AZfyT, Parser.SRC_GoS, Parser.SRC_HftT, Parser.SRC_OoW, Parser.SRC_DIP, Parser.SRC_SLW, Parser.SRC_SDW, Parser.SRC_DC, Parser.SRC_BGDIA, Parser.SRC_LR, Parser.SRC_EFR, Parser.SRC_RMBRE, Parser.SRC_IMR, Parser.SRC_EGW_ToR, Parser.SRC_EGW_DD, Parser.SRC_EGW_FS, Parser.SRC_EGW_US, Parser.SRC_IDRotF, Parser.SRC_CM, Parser.SRC_HoL, Parser.SRC_XMtS, Parser.SRC_RtG, Parser.SRC_AitFR_ISF, Parser.SRC_AitFR_THP, Parser.SRC_AitFR_AVT, Parser.SRC_AitFR_DN, Parser.SRC_AitFR_FCD, Parser.SRC_WBtW, Parser.SRC_NRH, Parser.SRC_NRH_TCMC, Parser.SRC_NRH_AVitW, Parser.SRC_NRH_ASS, Parser.SRC_NRH_CoI, Parser.SRC_NRH_TLT, Parser.SRC_NRH_AWoL, Parser.SRC_NRH_AT, Parser.SRC_SCC_CK, Parser.SRC_SCC_HfMT, Parser.SRC_SCC_TMM, Parser.SRC_SCC_ARiR, Parser.SRC_CRCotN, Parser.SRC_JttRC, Parser.SRC_LoX, Parser.SRC_DoSI, Parser.SRC_DSotDQ, Parser.SRC_KftGV, Parser.SRC_GotSF, Parser.SRC_PaBTSO, Parser.SRC_ToFW, Parser.SRC_LK, Parser.SRC_CoA, Parser.SRC_PiP, Parser.SRC_HFStCM, Parser.SRC_GHLoE, Parser.SRC_DoDk, ].forEach(src=>{
    Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src] = src;
    Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src.toLowerCase()] = src;
}
);

Parser.getTagSource = function(tag, source) {
    if (source && source.trim())
        return source;

    tag = tag.trim();

    const tagMeta = Renderer.tag.TAG_LOOKUP[tag];

    if (!tagMeta)
        throw new Error(`Unhandled tag "${tag}"`);
    return tagMeta.defaultSource;
}
;

Parser.PROP_TO_TAG = {
    "monster": "creature",
    "optionalfeature": "optfeature",
    "tableGroup": "table",
    "vehicleUpgrade": "vehupgrade",
    "baseitem": "item",
    "itemGroup": "item",
    "magicvariant": "item",
};
Parser.getPropTag = function(prop) {
    if (Parser.PROP_TO_TAG[prop])
        return Parser.PROP_TO_TAG[prop];
    return prop;
}
;

Parser.PROP_TO_DISPLAY_NAME = {
    "variantrule": "Variant Rule",
    "optionalfeature": "Option/Feature",
    "magicvariant": "Magic Item Variant",
    "baseitem": "Item (Base)",
    "item": "Item",
    "adventure": "Adventure",
    "adventureData": "Adventure Text",
    "book": "Book",
    "bookData": "Book Text",
    "makebrewCreatureTrait": "Homebrew Builder Creature Trait",
    "charoption": "Other Character Creation Option",

    "bonus": "Bonus Action",
    "legendary": "Legendary Action",
    "mythic": "Mythic Action",
    "lairActions": "Lair Action",
    "regionalEffects": "Regional Effect",
};
Parser.getPropDisplayName = function(prop, {suffix=""}={}) {
    if (Parser.PROP_TO_DISPLAY_NAME[prop])
        return `${Parser.PROP_TO_DISPLAY_NAME[prop]}${suffix}`;

    const mFluff = /Fluff$/.exec(prop);
    if (mFluff)
        return Parser.getPropDisplayName(prop.slice(0, -mFluff[0].length), {
            suffix: " Fluff"
        });

    const mFoundry = /^foundry(?<prop>[A-Z].*)$/.exec(prop);
    if (mFoundry)
        return Parser.getPropDisplayName(mFoundry.groups.prop.lowercaseFirst(), {
            suffix: " Foundry Data"
        });

    return `${prop.split(/([A-Z][a-z]+)/g).filter(Boolean).join(" ").uppercaseFirst()}${suffix}`;
}
;

Parser.ITEM_TYPE_JSON_TO_ABV = {
    "A": "ammunition",
    "AF": "ammunition",
    "AT": "artisan's tools",
    "EM": "eldritch machine",
    "EXP": "explosive",
    "FD": "food and drink",
    "G": "adventuring gear",
    "GS": "gaming set",
    "HA": "heavy armor",
    "IDG": "illegal drug",
    "INS": "instrument",
    "LA": "light armor",
    "M": "melee weapon",
    "MA": "medium armor",
    "MNT": "mount",
    "MR": "master rune",
    "GV": "generic variant",
    "P": "potion",
    "R": "ranged weapon",
    "RD": "rod",
    "RG": "ring",
    "S": "shield",
    "SC": "scroll",
    "SCF": "spellcasting focus",
    "OTH": "other",
    "T": "tools",
    "TAH": "tack and harness",
    "TG": "trade good",
    "$": "treasure",
    "VEH": "vehicle (land)",
    "SHP": "vehicle (water)",
    "AIR": "vehicle (air)",
    "SPC": "vehicle (space)",
    "WD": "wand",
};

Parser.DMGTYPE_JSON_TO_FULL = {
    "A": "acid",
    "B": "bludgeoning",
    "C": "cold",
    "F": "fire",
    "O": "force",
    "L": "lightning",
    "N": "necrotic",
    "P": "piercing",
    "I": "poison",
    "Y": "psychic",
    "R": "radiant",
    "S": "slashing",
    "T": "thunder",
};

Parser.DMG_TYPES = ["acid", "bludgeoning", "cold", "fire", "force", "lightning", "necrotic", "piercing", "poison", "psychic", "radiant", "slashing", "thunder"];
Parser.CONDITIONS = ["blinded", "charmed", "deafened", "exhaustion", "frightened", "grappled", "incapacitated", "invisible", "paralyzed", "petrified", "poisoned", "prone", "restrained", "stunned", "unconscious"];

Parser.SENSES = [{
    "name": "blindsight",
    "source": Parser.SRC_PHB
}, {
    "name": "darkvision",
    "source": Parser.SRC_PHB
}, {
    "name": "tremorsense",
    "source": Parser.SRC_MM
}, {
    "name": "truesight",
    "source": Parser.SRC_PHB
}, ];

Parser.NUMBERS_ONES = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
Parser.NUMBERS_TENS = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];
Parser.NUMBERS_TEENS = ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"];

Parser.metric = {
    MILES_TO_KILOMETRES: 1.6,
    FEET_TO_METRES: 0.3,
    YARDS_TO_METRES: 0.9,
    POUNDS_TO_KILOGRAMS: 0.5,
    getMetricNumber({originalValue, originalUnit, toFixed=null}) {
        if (originalValue == null || isNaN(originalValue))
            return originalValue;

        originalValue = Number(originalValue);
        if (!originalValue)
            return originalValue;

        let out = null;
        switch (originalUnit) {
        case "ft.":
        case "ft":
        case Parser.UNT_FEET:
            out = originalValue * Parser.metric.FEET_TO_METRES;
            break;
        case "yd.":
        case "yd":
        case Parser.UNT_YARDS:
            out = originalValue * Parser.metric.YARDS_TO_METRES;
            break;
        case "mi.":
        case "mi":
        case Parser.UNT_MILES:
            out = originalValue * Parser.metric.MILES_TO_KILOMETRES;
            break;
        case "lb.":
        case "lb":
        case "lbs":
            out = originalValue * Parser.metric.POUNDS_TO_KILOGRAMS;
            break;
        default:
            return originalValue;
        }
        if (toFixed != null)
            return NumberUtil.toFixedNumber(out, toFixed);
        return out;
    },

    getMetricUnit({originalUnit, isShortForm=false, isPlural=true}) {
        switch (originalUnit) {
        case "ft.":
        case "ft":
        case Parser.UNT_FEET:
            return isShortForm ? "m" : `meter`[isPlural ? "toPlural" : "toString"]();
        case "yd.":
        case "yd":
        case Parser.UNT_YARDS:
            return isShortForm ? "m" : `meter`[isPlural ? "toPlural" : "toString"]();
        case "mi.":
        case "mi":
        case Parser.UNT_MILES:
            return isShortForm ? "km" : `kilometre`[isPlural ? "toPlural" : "toString"]();
        case "lb.":
        case "lb":
        case "lbs":
            return isShortForm ? "kg" : `kilogram`[isPlural ? "toPlural" : "toString"]();
        default:
            return originalUnit;
        }
    },
};

Parser.MAP_GRID_TYPE_TO_FULL = {};
Parser.MAP_GRID_TYPE_TO_FULL["none"] = "None";
Parser.MAP_GRID_TYPE_TO_FULL["square"] = "Square";
Parser.MAP_GRID_TYPE_TO_FULL["hexRowsOdd"] = "Hex Rows (Odd)";
Parser.MAP_GRID_TYPE_TO_FULL["hexRowsEven"] = "Hex Rows (Even)";
Parser.MAP_GRID_TYPE_TO_FULL["hexColsOdd"] = "Hex Columns (Odd)";
Parser.MAP_GRID_TYPE_TO_FULL["hexColsEven"] = "Hex Columns (Even)";

Parser.mapGridTypeToFull = function(gridType) {
    return Parser._parse_aToB(Parser.MAP_GRID_TYPE_TO_FULL, gridType);
}
;
//#endregion
//#region SortUtil
class SortUtil {
    static ascSort(a, b) {
        if (b === a)
            return 0;
        return b < a ? 1 : -1;
    }

    static ascSortLower(a, b) {
        return SortUtil.ascSort((a || "").toLowerCase(), (b || "").toLowerCase())
    }
}
;
//#endregion
//#region UtilActors

//#endregion

//#region Renderer
globalThis.Renderer = function() {
    this.wrapperTag = "div";
    this.baseUrl = "";
    this.baseMediaUrls = {};

    if (globalThis.DEPLOYED_IMG_ROOT) {
        this.baseMediaUrls["img"] = globalThis.DEPLOYED_IMG_ROOT;
    }

    this._lazyImages = false;
    this._subVariant = false;
    this._firstSection = true;
    this._isAddHandlers = true;
    this._headerIndex = 1;
    this._tagExportDict = null;
    this._roll20Ids = null;
    this._trackTitles = {
        enabled: false,
        titles: {}
    };
    this._enumerateTitlesRel = {
        enabled: false,
        titles: {}
    };
    this._isHeaderIndexIncludeTableCaptions = false;
    this._isHeaderIndexIncludeImageTitles = false;
    this._plugins = {};
    this._fnPostProcess = null;
    this._extraSourceClasses = null;
    this._depthTracker = null;
    this._depthTrackerAdditionalProps = [];
    this._depthTrackerAdditionalPropsInherited = [];
    this._lastDepthTrackerInheritedProps = {};
    this._isInternalLinksDisabled = false;
    this._isPartPageExpandCollapseDisabled = false;
    this._fnsGetStyleClasses = {};

    this.setLazyImages = function(bool) {
        if (typeof IntersectionObserver === "undefined")
            this._lazyImages = false;
        else
            this._lazyImages = !!bool;
        return this;
    }
    ;

    this.setWrapperTag = function(tag) {
        this.wrapperTag = tag;
        return this;
    }
    ;

    this.setBaseUrl = function(url) {
        this.baseUrl = url;
        return this;
    }
    ;

    this.setBaseMediaUrl = function(mediaDir, url) {
        this.baseMediaUrls[mediaDir] = url;
        return this;
    }
    ;

    this.setFirstSection = function(bool) {
        this._firstSection = bool;
        return this;
    }
    ;

    this.setAddHandlers = function(bool) {
        this._isAddHandlers = bool;
        return this;
    }
    ;

    this.setFnPostProcess = function(fn) {
        this._fnPostProcess = fn;
        return this;
    }
    ;

    this.setExtraSourceClasses = function(arr) {
        this._extraSourceClasses = arr;
        return this;
    }
    ;

    this.resetHeaderIndex = function() {
        this._headerIndex = 1;
        this._trackTitles.titles = {};
        this._enumerateTitlesRel.titles = {};
        return this;
    }
    ;

    this.getHeaderIndex = function() {
        return this._headerIndex;
    }
    ;

    this.setHeaderIndexTableCaptions = function(bool) {
        this._isHeaderIndexIncludeTableCaptions = bool;
        return this;
    }
    ;
    this.setHeaderIndexImageTitles = function(bool) {
        this._isHeaderIndexIncludeImageTitles = bool;
        return this;
    }
    ;

    this.doExportTags = function(toObj) {
        this._tagExportDict = toObj;
        return this;
    }
    ;

    this.resetExportTags = function() {
        this._tagExportDict = null;
        return this;
    }
    ;

    this.setRoll20Ids = function(roll20Ids) {
        this._roll20Ids = roll20Ids;
        return this;
    }
    ;

    this.resetRoll20Ids = function() {
        this._roll20Ids = null;
        return this;
    }
    ;

    this.setInternalLinksDisabled = function(val) {
        this._isInternalLinksDisabled = !!val;
        return this;
    }
    ;
    this.isInternalLinksDisabled = function() {
        return !!this._isInternalLinksDisabled;
    }
    ;

    this.setPartPageExpandCollapseDisabled = function(val) {
        this._isPartPageExpandCollapseDisabled = !!val;
        return this;
    }
    ;

    this.setFnGetStyleClasses = function(identifier, fn) {
        if (fn == null) {
            delete this._fnsGetStyleClasses[identifier];
            return this;
        }

        this._fnsGetStyleClasses[identifier] = fn;
        return this;
    }
    ;

    this.setEnumerateTitlesRel = function(bool) {
        this._enumerateTitlesRel.enabled = bool;
        return this;
    }
    ;

    this._getEnumeratedTitleRel = function(name) {
        if (this._enumerateTitlesRel.enabled && name) {
            const clean = name.toLowerCase();
            this._enumerateTitlesRel.titles[clean] = this._enumerateTitlesRel.titles[clean] || 0;
            return `data-title-relative-index="${this._enumerateTitlesRel.titles[clean]++}"`;
        } else
            return "";
    }
    ;

    this.setTrackTitles = function(bool) {
        this._trackTitles.enabled = bool;
        return this;
    }
    ;

    this.getTrackedTitles = function() {
        return MiscUtil.copyFast(this._trackTitles.titles);
    }
    ;

    this.getTrackedTitlesInverted = function({isStripTags=false}={}) {
        const trackedTitlesInverse = {};
        Object.entries(this._trackTitles.titles || {}).forEach(([titleIx,titleName])=>{
            if (isStripTags)
                titleName = Renderer.stripTags(titleName);
            titleName = titleName.toLowerCase().trim();
            (trackedTitlesInverse[titleName] = trackedTitlesInverse[titleName] || []).push(titleIx);
        }
        );
        return trackedTitlesInverse;
    }
    ;

    this._handleTrackTitles = function(name, {isTable=false, isImage=false}={}) {
        if (!this._trackTitles.enabled)
            return;
        if (isTable && !this._isHeaderIndexIncludeTableCaptions)
            return;
        if (isImage && !this._isHeaderIndexIncludeImageTitles)
            return;
        this._trackTitles.titles[this._headerIndex] = name;
    }
    ;

    this._handleTrackDepth = function(entry, depth) {
        if (!entry.name || !this._depthTracker)
            return;

        this._lastDepthTrackerInheritedProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        if (entry.source)
            this._lastDepthTrackerInheritedProps.source = entry.source;
        if (this._depthTrackerAdditionalPropsInherited?.length) {
            this._depthTrackerAdditionalPropsInherited.forEach(prop=>this._lastDepthTrackerInheritedProps[prop] = entry[prop] || this._lastDepthTrackerInheritedProps[prop]);
        }

        const additionalData = this._depthTrackerAdditionalProps.length ? this._depthTrackerAdditionalProps.mergeMap(it=>({
            [it]: entry[it]
        })) : {};

        this._depthTracker.push({
            ...this._lastDepthTrackerInheritedProps,
            ...additionalData,
            depth,
            name: entry.name,
            type: entry.type,
            ixHeader: this._headerIndex,
            source: this._lastDepthTrackerInheritedProps.source,
            data: entry.data,
            page: entry.page,
            alias: entry.alias,
            entry,
        });
    }
    ;

    this.addPlugin = function(pluginType, fnPlugin) {
        MiscUtil.getOrSet(this._plugins, pluginType, []).push(fnPlugin);
    }
    ;

    this.removePlugin = function(pluginType, fnPlugin) {
        if (!fnPlugin)
            return;
        const ix = (MiscUtil.get(this._plugins, pluginType) || []).indexOf(fnPlugin);
        if (~ix)
            this._plugins[pluginType].splice(ix, 1);
    }
    ;

    this.removePlugins = function(pluginType) {
        MiscUtil.delete(this._plugins, pluginType);
    }
    ;

    this._getPlugins = function(pluginType) {
        return this._plugins[pluginType] || [];
    }
    ;

    this.withPlugin = function({pluginTypes, fnPlugin, fn}) {
        for (const pt of pluginTypes)
            this.addPlugin(pt, fnPlugin);
        try {
            return fn(this);
        } finally {
            for (const pt of pluginTypes)
                this.removePlugin(pt, fnPlugin);
        }
    }
    ;

    this.pWithPlugin = async function({pluginTypes, fnPlugin, pFn}) {
        for (const pt of pluginTypes)
            this.addPlugin(pt, fnPlugin);
        try {
            const out = await pFn(this);
            return out;
        } finally {
            for (const pt of pluginTypes)
                this.removePlugin(pt, fnPlugin);
        }
    }
    ;

    this.setDepthTracker = function(arr, {additionalProps, additionalPropsInherited}={}) {
        this._depthTracker = arr;
        this._depthTrackerAdditionalProps = additionalProps || [];
        this._depthTrackerAdditionalPropsInherited = additionalPropsInherited || [];
        return this;
    }
    ;

    this.getLineBreak = function() {
        return "<br>";
    }
    ;

    this.recursiveRender = function(entry, textStack, meta, options) {
        if (entry instanceof Array) {
            entry.forEach(nxt=>this.recursiveRender(nxt, textStack, meta, options));
            setTimeout(()=>{
                throw new Error(`Array passed to renderer! The renderer only guarantees support for primitives and basic objects.`);
            }
            );
            return this;
        }

        if (textStack.length === 0)
            textStack[0] = "";
        else
            textStack.reverse();

        meta = meta || {};
        meta._typeStack = [];
        meta.depth = meta.depth == null ? 0 : meta.depth;

        this._recursiveRender(entry, textStack, meta, options);
        if (this._fnPostProcess)
            textStack[0] = this._fnPostProcess(textStack[0]);
        textStack.reverse();

        return this;
    }
    ;

    this._recursiveRender = function(entry, textStack, meta, options) {
        if (entry == null)
            return;
        if (!textStack)
            throw new Error("Missing stack!");
        if (!meta)
            throw new Error("Missing metadata!");
        if (entry.type === "section")
            meta.depth = -1;

        options = options || {};

        meta._didRenderPrefix = false;
        meta._didRenderSuffix = false;

        if (typeof entry === "object") {
            const type = entry.type == null || entry.type === "section" ? "entries" : entry.type;

            if (type === "wrapper")
                return this._recursiveRender(entry.wrapped, textStack, meta, options);

            meta._typeStack.push(type);

            switch (type) {
            case "entries":
                this._renderEntries(entry, textStack, meta, options);
                break;
            case "options":
                this._renderOptions(entry, textStack, meta, options);
                break;
            case "list":
                this._renderList(entry, textStack, meta, options);
                break;
            case "table":
                this._renderTable(entry, textStack, meta, options);
                break;
            case "tableGroup":
                this._renderTableGroup(entry, textStack, meta, options);
                break;
            case "inset":
                this._renderInset(entry, textStack, meta, options);
                break;
            case "insetReadaloud":
                this._renderInsetReadaloud(entry, textStack, meta, options);
                break;
            case "variant":
                this._renderVariant(entry, textStack, meta, options);
                break;
            case "variantInner":
                this._renderVariantInner(entry, textStack, meta, options);
                break;
            case "variantSub":
                this._renderVariantSub(entry, textStack, meta, options);
                break;
            case "spellcasting":
                this._renderSpellcasting(entry, textStack, meta, options);
                break;
            case "quote":
                this._renderQuote(entry, textStack, meta, options);
                break;
            case "optfeature":
                this._renderOptfeature(entry, textStack, meta, options);
                break;
            case "patron":
                this._renderPatron(entry, textStack, meta, options);
                break;

            case "abilityDc":
                this._renderAbilityDc(entry, textStack, meta, options);
                break;
            case "abilityAttackMod":
                this._renderAbilityAttackMod(entry, textStack, meta, options);
                break;
            case "abilityGeneric":
                this._renderAbilityGeneric(entry, textStack, meta, options);
                break;

            case "inline":
                this._renderInline(entry, textStack, meta, options);
                break;
            case "inlineBlock":
                this._renderInlineBlock(entry, textStack, meta, options);
                break;
            case "bonus":
                this._renderBonus(entry, textStack, meta, options);
                break;
            case "bonusSpeed":
                this._renderBonusSpeed(entry, textStack, meta, options);
                break;
            case "dice":
                this._renderDice(entry, textStack, meta, options);
                break;
            case "link":
                this._renderLink(entry, textStack, meta, options);
                break;
            case "actions":
                this._renderActions(entry, textStack, meta, options);
                break;
            case "attack":
                this._renderAttack(entry, textStack, meta, options);
                break;
            case "ingredient":
                this._renderIngredient(entry, textStack, meta, options);
                break;

            case "item":
                this._renderItem(entry, textStack, meta, options);
                break;
            case "itemSub":
                this._renderItemSub(entry, textStack, meta, options);
                break;
            case "itemSpell":
                this._renderItemSpell(entry, textStack, meta, options);
                break;

            case "statblockInline":
                this._renderStatblockInline(entry, textStack, meta, options);
                break;
            case "statblock":
                this._renderStatblock(entry, textStack, meta, options);
                break;

            case "image":
                this._renderImage(entry, textStack, meta, options);
                break;
            case "gallery":
                this._renderGallery(entry, textStack, meta, options);
                break;

            case "flowchart":
                this._renderFlowchart(entry, textStack, meta, options);
                break;
            case "flowBlock":
                this._renderFlowBlock(entry, textStack, meta, options);
                break;

            case "homebrew":
                this._renderHomebrew(entry, textStack, meta, options);
                break;

            case "code":
                this._renderCode(entry, textStack, meta, options);
                break;
            case "hr":
                this._renderHr(entry, textStack, meta, options);
                break;
            }

            meta._typeStack.pop();
        } else if (typeof entry === "string") {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderString(entry, textStack, meta, options);
            this._renderSuffix(entry, textStack, meta, options);
        } else {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderPrimitive(entry, textStack, meta, options);
            this._renderSuffix(entry, textStack, meta, options);
        }
    }
    ;

    this._RE_TEXT_CENTER = /\btext-center\b/;

    this._getMutatedStyleString = function(str) {
        if (!str)
            return str;
        return str.replace(this._RE_TEXT_CENTER, "ve-text-center");
    }
    ;

    this._adjustDepth = function(meta, dDepth) {
        const cachedDepth = meta.depth;
        meta.depth += dDepth;
        meta.depth = Math.min(Math.max(-1, meta.depth), 2);
        return cachedDepth;
    }
    ;

    this._renderPrefix = function(entry, textStack, meta, options) {
        if (meta._didRenderPrefix)
            return;
        if (options.prefix != null) {
            textStack[0] += options.prefix;
            meta._didRenderPrefix = true;
        }
    }
    ;

    this._renderSuffix = function(entry, textStack, meta, options) {
        if (meta._didRenderSuffix)
            return;
        if (options.suffix != null) {
            textStack[0] += options.suffix;
            meta._didRenderSuffix = true;
        }
    }
    ;

    this._renderImage = function(entry, textStack, meta, options) {
        if (entry.title)
            this._handleTrackTitles(entry.title, {
                isImage: true
            });

        textStack[0] += `<div class="float-clear"></div>`;

        if (entry.imageType === "map" || entry.imageType === "mapPlayer")
            textStack[0] += `<div class="rd__wrp-map">`;
        textStack[0] += `<div class="${meta._typeStack.includes("gallery") ? "rd__wrp-gallery-image" : ""}">`;

        const href = this._renderImage_getUrl(entry);
        const svg = this._lazyImages && entry.width != null && entry.height != null ? `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="${entry.width}" height="${entry.height}"><rect width="100%" height="100%" fill="#ccc3"></rect></svg>`)}` : null;
        const ptTitleCreditTooltip = this._renderImage_getTitleCreditTooltipText(entry);
        const ptTitle = ptTitleCreditTooltip ? `title="${ptTitleCreditTooltip}"` : "";
        const pluginDataIsNoLink = this._getPlugins("image_isNoLink").map(plugin=>plugin(entry, textStack, meta, options)).some(Boolean);

        textStack[0] += `<div class="${this._renderImage_getWrapperClasses(entry, meta)}" ${entry.title && this._isHeaderIndexIncludeImageTitles ? `data-title-index="${this._headerIndex++}"` : ""}>
			${pluginDataIsNoLink ? "" : `<a href="${href}" target="_blank" rel="noopener noreferrer" ${ptTitle}>`}
				<img class="${this._renderImage_getImageClasses(entry, meta)}" src="${svg || href}" ${pluginDataIsNoLink ? ptTitle : ""} ${entry.altText || entry.title ? `alt="${Renderer.stripTags((entry.altText || entry.title)).qq()}"` : ""} ${svg ? `data-src="${href}"` : `loading="lazy"`} ${this._renderImage_getStylePart(entry)}>
			${pluginDataIsNoLink ? "" : `</a>`}
		</div>`;

        if (!this._renderImage_isComicStyling(entry) && (entry.title || entry.credit || entry.mapRegions)) {
            const ptAdventureBookMeta = entry.mapRegions && meta.adventureBookPage && meta.adventureBookSource && meta.adventureBookHash ? `data-rd-adventure-book-map-page="${meta.adventureBookPage.qq()}" data-rd-adventure-book-map-source="${meta.adventureBookSource.qq()}" data-rd-adventure-book-map-hash="${meta.adventureBookHash.qq()}"` : "";

            textStack[0] += `<div class="rd__image-title">`;

            if (entry.title && !entry.mapRegions)
                textStack[0] += `<div class="rd__image-title-inner">${this.render(entry.title)}</div>`;

            if (entry.mapRegions && !IS_VTT) {
                textStack[0] += `<button class="btn btn-xs btn-default rd__image-btn-viewer" onclick="RenderMap.pShowViewer(event, this)" data-rd-packed-map="${this._renderImage_getMapRegionData(entry)}" ${ptAdventureBookMeta} title="Open Dynamic Viewer (SHIFT to Open in New Window)"><span class="glyphicon glyphicon-picture"></span> ${Renderer.stripTags(entry.title) || "Dynamic Viewer"}</button>`;
            }

            if (entry.credit)
                textStack[0] += `<div class="rd__image-credit ve-muted"><span class="glyphicon glyphicon-pencil" title="Art Credit"></span> ${this.render(entry.credit)}</div>`;

            textStack[0] += `</div>`;
        }

        if (entry._galleryTitlePad)
            textStack[0] += `<div class="rd__image-title">&nbsp;</div>`;
        if (entry._galleryCreditPad)
            textStack[0] += `<div class="rd__image-credit">&nbsp;</div>`;

        textStack[0] += `</div>`;
        if (entry.imageType === "map" || entry.imageType === "mapPlayer")
            textStack[0] += `</div>`;
    }
    ;

    this._renderImage_getTitleCreditTooltipText = function(entry) {
        if (!entry.title && !entry.credit)
            return null;
        return Renderer.stripTags([entry.title, entry.credit ? `Art credit: ${entry.credit}` : null].filter(Boolean).join(". "), ).qq();
    }
    ;

    this._renderImage_getStylePart = function(entry) {
        const styles = [entry.maxWidth ? `max-width: min(100%, ${entry.maxWidth}${entry.maxWidthUnits || "px"})` : "", entry.maxHeight ? `max-height: min(60vh, ${entry.maxHeight}${entry.maxHeightUnits || "px"})` : "", ].filter(Boolean).join("; ");
        return styles ? `style="${styles}"` : "";
    }
    ;

    this._renderImage_getMapRegionData = function(entry) {
        return JSON.stringify(this.getMapRegionData(entry)).escapeQuotes();
    }
    ;

    this.getMapRegionData = function(entry) {
        return {
            regions: entry.mapRegions,
            width: entry.width,
            height: entry.height,
            href: this._renderImage_getUrl(entry),
            hrefThumbnail: this._renderImage_getUrlThumbnail(entry),
            page: entry.page,
            source: entry.source,
            hash: entry.hash,
        };
    }
    ;

    this._renderImage_isComicStyling = function(entry) {
        if (!entry.style)
            return false;
        return ["comic-speaker-left", "comic-speaker-right"].includes(entry.style);
    }
    ;

    this._renderImage_getWrapperClasses = function(entry) {
        const out = ["rd__wrp-image", "relative"];
        if (entry.style) {
            switch (entry.style) {
            case "comic-speaker-left":
                out.push("rd__comic-img-speaker", "rd__comic-img-speaker--left");
                break;
            case "comic-speaker-right":
                out.push("rd__comic-img-speaker", "rd__comic-img-speaker--right");
                break;
            }
        }
        return out.join(" ");
    }
    ;

    this._renderImage_getImageClasses = function(entry) {
        const out = ["rd__image"];
        if (entry.style) {
            switch (entry.style) {
            case "deity-symbol":
                out.push("rd__img-small");
                break;
            }
        }
        return out.join(" ");
    }
    ;

    this._renderImage_getUrl = function(entry) {
        let url = Renderer.utils.getMediaUrl(entry, "href", "img");
        for (const plugin of this._getPlugins(`image_urlPostProcess`)) {
            url = plugin(entry, url) || url;
        }
        return url;
    }
    ;

    this._renderImage_getUrlThumbnail = function(entry) {
        let url = Renderer.utils.getMediaUrl(entry, "hrefThumbnail", "img");
        for (const plugin of this._getPlugins(`image_urlThumbnailPostProcess`)) {
            url = plugin(entry, url) || url;
        }
        return url;
    }
    ;

    this._renderList_getListCssClasses = function(entry, textStack, meta, options) {
        const out = [`rd__list`];
        if (entry.style || entry.columns) {
            if (entry.style)
                out.push(...entry.style.split(" ").map(it=>`rd__${it}`));
            if (entry.columns)
                out.push(`columns-${entry.columns}`);
        }
        return out.join(" ");
    }
    ;

    this._renderTableGroup = function(entry, textStack, meta, options) {
        const len = entry.tables.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.tables[i], textStack, meta);
    }
    ;

    this._renderTable = function(entry, textStack, meta, options) {
        if (entry.intro) {
            const len = entry.intro.length;
            for (let i = 0; i < len; ++i) {
                this._recursiveRender(entry.intro[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
            }
        }

        textStack[0] += `<table class="w-100 rd__table ${this._getMutatedStyleString(entry.style || "")} ${entry.isStriped === false ? "" : "stripe-odd-table"}">`;

        const headerRowMetas = Renderer.table.getHeaderRowMetas(entry);
        const autoRollMode = Renderer.table.getAutoConvertedRollMode(entry, {
            headerRowMetas
        });
        const toRenderLabel = autoRollMode ? RollerUtil.getFullRollCol(headerRowMetas.last()[0]) : null;
        const isInfiniteResults = autoRollMode === RollerUtil.ROLL_COL_VARIABLE;

        if (entry.caption != null) {
            this._handleTrackTitles(entry.caption, {
                isTable: true
            });
            textStack[0] += `<caption ${this._isHeaderIndexIncludeTableCaptions ? `data-title-index="${this._headerIndex++}"` : ""}>${entry.caption}</caption>`;
        }

        const rollCols = [];
        let bodyStack = [""];
        bodyStack[0] += "<tbody>";
        const lenRows = entry.rows.length;
        for (let ixRow = 0; ixRow < lenRows; ++ixRow) {
            bodyStack[0] += "<tr>";
            const r = entry.rows[ixRow];
            let roRender = r.type === "row" ? r.row : r;

            const len = roRender.length;
            for (let ixCell = 0; ixCell < len; ++ixCell) {
                rollCols[ixCell] = rollCols[ixCell] || false;

                if (autoRollMode && ixCell === 0) {
                    roRender = Renderer.getRollableRow(roRender, {
                        isForceInfiniteResults: isInfiniteResults,
                        isFirstRow: ixRow === 0,
                        isLastRow: ixRow === lenRows - 1,
                    }, );
                    rollCols[ixCell] = true;
                }

                let toRenderCell;
                if (roRender[ixCell].type === "cell") {
                    if (roRender[ixCell].roll) {
                        rollCols[ixCell] = true;
                        if (roRender[ixCell].entry) {
                            toRenderCell = roRender[ixCell].entry;
                        } else if (roRender[ixCell].roll.exact != null) {
                            toRenderCell = roRender[ixCell].roll.pad ? StrUtil.padNumber(roRender[ixCell].roll.exact, 2, "0") : roRender[ixCell].roll.exact;
                        } else {

                            const dispMin = roRender[ixCell].roll.displayMin != null ? roRender[ixCell].roll.displayMin : roRender[ixCell].roll.min;
                            const dispMax = roRender[ixCell].roll.displayMax != null ? roRender[ixCell].roll.displayMax : roRender[ixCell].roll.max;

                            if (dispMax === Renderer.dice.POS_INFINITE) {
                                toRenderCell = roRender[ixCell].roll.pad ? `${StrUtil.padNumber(dispMin, 2, "0")}+` : `${dispMin}+`;
                            } else {
                                toRenderCell = roRender[ixCell].roll.pad ? `${StrUtil.padNumber(dispMin, 2, "0")}-${StrUtil.padNumber(dispMax, 2, "0")}` : `${dispMin}-${dispMax}`;
                            }
                        }
                    } else if (roRender[ixCell].entry) {
                        toRenderCell = roRender[ixCell].entry;
                    }
                } else {
                    toRenderCell = roRender[ixCell];
                }
                bodyStack[0] += `<td ${this._renderTable_makeTableTdClassText(entry, ixCell)} ${this._renderTable_getCellDataStr(roRender[ixCell])} ${roRender[ixCell].type === "cell" && roRender[ixCell].width ? `colspan="${roRender[ixCell].width}"` : ""}>`;
                if (r.style === "row-indent-first" && ixCell === 0)
                    bodyStack[0] += `<div class="rd__tab-indent"></div>`;
                const cacheDepth = this._adjustDepth(meta, 1);
                this._recursiveRender(toRenderCell, bodyStack, meta);
                meta.depth = cacheDepth;
                bodyStack[0] += "</td>";
            }
            bodyStack[0] += "</tr>";
        }
        bodyStack[0] += "</tbody>";

        if (headerRowMetas) {
            textStack[0] += "<thead>";

            for (let ixRow = 0, lenRows = headerRowMetas.length; ixRow < lenRows; ++ixRow) {
                textStack[0] += "<tr>";

                const headerRowMeta = headerRowMetas[ixRow];
                for (let ixCell = 0, lenCells = headerRowMeta.length; ixCell < lenCells; ++ixCell) {
                    const lbl = headerRowMeta[ixCell];
                    textStack[0] += `<th ${this._renderTable_getTableThClassText(entry, ixCell)} data-rd-isroller="${rollCols[ixCell]}" ${entry.isNameGenerator ? `data-rd-namegeneratorrolls="${headerRowMeta.length - 1}"` : ""}>`;
                    this._recursiveRender(autoRollMode && ixCell === 0 ? RollerUtil.getFullRollCol(lbl) : lbl, textStack, meta);
                    textStack[0] += `</th>`;
                }

                textStack[0] += "</tr>";
            }

            textStack[0] += "</thead>";
        }

        textStack[0] += bodyStack[0];

        if (entry.footnotes != null) {
            textStack[0] += "<tfoot>";
            const len = entry.footnotes.length;
            for (let i = 0; i < len; ++i) {
                textStack[0] += `<tr><td colspan="99">`;
                const cacheDepth = this._adjustDepth(meta, 1);
                this._recursiveRender(entry.footnotes[i], textStack, meta);
                meta.depth = cacheDepth;
                textStack[0] += "</td></tr>";
            }
            textStack[0] += "</tfoot>";
        }
        textStack[0] += "</table>";

        if (entry.outro) {
            const len = entry.outro.length;
            for (let i = 0; i < len; ++i) {
                this._recursiveRender(entry.outro[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
            }
        }
    }
    ;

    this._renderTable_getCellDataStr = function(ent) {
        function convertZeros(num) {
            if (num === 0)
                return 100;
            return num;
        }

        if (ent.roll) {
            return `data-roll-min="${convertZeros(ent.roll.exact != null ? ent.roll.exact : ent.roll.min)}" data-roll-max="${convertZeros(ent.roll.exact != null ? ent.roll.exact : ent.roll.max)}"`;
        }

        return "";
    }
    ;

    this._renderTable_getTableThClassText = function(entry, i) {
        return entry.colStyles == null || i >= entry.colStyles.length ? "" : `class="${this._getMutatedStyleString(entry.colStyles[i])}"`;
    }
    ;

    this._renderTable_makeTableTdClassText = function(entry, i) {
        if (entry.rowStyles != null)
            return i >= entry.rowStyles.length ? "" : `class="${this._getMutatedStyleString(entry.rowStyles[i])}"`;
        else
            return this._renderTable_getTableThClassText(entry, i);
    }
    ;

    this._renderEntries = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, true);
    }
    ;

    this._getPagePart = function(entry, isInset) {
        if (!Renderer.utils.isDisplayPage(entry.page))
            return "";
        return ` <span class="rd__title-link ${isInset ? `rd__title-link--inset` : ""}">${entry.source ? `<span class="help-subtle" title="${Parser.sourceJsonToFull(entry.source)}">${Parser.sourceJsonToAbv(entry.source)}</span> ` : ""}p${entry.page}</span>`;
    }
    ;

    this._renderEntriesSubtypes = function(entry, textStack, meta, options, incDepth) {
        const type = entry.type || "entries";
        const isInlineTitle = meta.depth >= 2;
        const isAddPeriod = isInlineTitle && entry.name && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
        const pagePart = !this._isPartPageExpandCollapseDisabled && !isInlineTitle ? this._getPagePart(entry) : "";
        const partExpandCollapse = !this._isPartPageExpandCollapseDisabled && !isInlineTitle ? `<span class="rd__h-toggle ml-2 clickable no-select" data-rd-h-toggle-button="true" title="Toggle Visibility (CTRL to Toggle All)">[\u2013]</span>` : "";
        const partPageExpandCollapse = !this._isPartPageExpandCollapseDisabled && (pagePart || partExpandCollapse) ? `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>` : "";
        const nextDepth = incDepth && meta.depth < 2 ? meta.depth + 1 : meta.depth;
        const styleString = this._renderEntriesSubtypes_getStyleString(entry, meta, isInlineTitle);
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);

        const headerTag = isInlineTitle ? "span" : `h${Math.min(Math.max(meta.depth + 2, 1), 6)}`;
        const headerClass = `rd__h--${meta.depth + 1}`;
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, meta.depth);

        const pluginDataNamePrefix = this._getPlugins(`${type}_namePrefix`).map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);

        const headerSpan = entry.name ? `<${headerTag} class="rd__h ${headerClass}" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}> <span class="entry-title-inner${!pagePart && entry.source ? ` help-subtle` : ""}"${!pagePart && entry.source ? ` title="Source: ${Parser.sourceJsonToFull(entry.source)}${entry.page ? `, p${entry.page}` : ""}"` : ""}>${pluginDataNamePrefix.join("")}${this.render({
            type: "inline",
            entries: [entry.name]
        })}${isAddPeriod ? "." : ""}</span>${partPageExpandCollapse}</${headerTag}> ` : "";

        if (meta.depth === -1) {
            if (!this._firstSection)
                textStack[0] += `<hr class="rd__hr rd__hr--section">`;
            this._firstSection = false;
        }

        if (entry.entries || entry.name) {
            textStack[0] += `<${this.wrapperTag} ${dataString} ${styleString}>${headerSpan}`;
            this._renderEntriesSubtypes_renderPreReqText(entry, textStack, meta);
            if (entry.entries) {
                const cacheDepth = meta.depth;
                const len = entry.entries.length;
                for (let i = 0; i < len; ++i) {
                    meta.depth = nextDepth;
                    this._recursiveRender(entry.entries[i], textStack, meta, {
                        prefix: "<p>",
                        suffix: "</p>"
                    });
                    if (i === 0 && cacheDepth >= 2)
                        textStack[0] += `<div class="rd__spc-inline-post"></div>`;
                }
                meta.depth = cacheDepth;
            }
            textStack[0] += `</${this.wrapperTag}>`;
        }

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderEntriesSubtypes_getDataString = function(entry) {
        let dataString = "";
        if (entry.source)
            dataString += `data-source="${entry.source}"`;
        if (entry.data) {
            for (const k in entry.data) {
                if (!k.startsWith("rd-"))
                    continue;
                dataString += ` data-${k}="${`${entry.data[k]}`.escapeQuotes()}"`;
            }
        }
        return dataString;
    }
    ;

    this._renderEntriesSubtypes_renderPreReqText = function(entry, textStack, meta) {
        if (entry.prerequisite) {
            textStack[0] += `<span class="rd__prerequisite">Prerequisite: `;
            this._recursiveRender({
                type: "inline",
                entries: [entry.prerequisite]
            }, textStack, meta);
            textStack[0] += `</span>`;
        }
    }
    ;

    this._renderEntriesSubtypes_getStyleString = function(entry, meta, isInlineTitle) {
        const styleClasses = ["rd__b"];
        styleClasses.push(this._getStyleClass(entry.type || "entries", entry));
        if (isInlineTitle) {
            if (this._subVariant)
                styleClasses.push(Renderer.HEAD_2_SUB_VARIANT);
            else
                styleClasses.push(Renderer.HEAD_2);
        } else
            styleClasses.push(meta.depth === -1 ? Renderer.HEAD_NEG_1 : meta.depth === 0 ? Renderer.HEAD_0 : Renderer.HEAD_1);
        return styleClasses.length > 0 ? `class="${styleClasses.join(" ")}"` : "";
    }
    ;

    this._renderOptions = function(entry, textStack, meta, options) {
        if (!entry.entries)
            return;
        entry.entries = entry.entries.sort((a,b)=>a.name && b.name ? SortUtil.ascSort(a.name, b.name) : a.name ? -1 : b.name ? 1 : 0);

        if (entry.style && entry.style === "list-hang-notitle") {
            const fauxEntry = {
                type: "list",
                style: "list-hang-notitle",
                items: entry.entries.map(ent=>{
                    if (typeof ent === "string")
                        return ent;
                    if (ent.type === "item")
                        return ent;

                    const out = {
                        ...ent,
                        type: "item"
                    };
                    if (ent.name)
                        out.name = Renderer._INLINE_HEADER_TERMINATORS.has(ent.name[ent.name.length - 1]) ? out.name : `${out.name}.`;
                    return out;
                }
                ),
            };
            this._renderList(fauxEntry, textStack, meta, options);
        } else
            this._renderEntriesSubtypes(entry, textStack, meta, options, false);
    }
    ;

    this._renderList = function(entry, textStack, meta, options) {
        if (entry.items) {
            const tag = entry.start ? "ol" : "ul";
            const cssClasses = this._renderList_getListCssClasses(entry, textStack, meta, options);
            textStack[0] += `<${tag} ${cssClasses ? `class="${cssClasses}"` : ""} ${entry.start ? `start="${entry.start}"` : ""}>`;
            if (entry.name)
                textStack[0] += `<li class="rd__list-name">${entry.name}</li>`;
            const isListHang = entry.style && entry.style.split(" ").includes("list-hang");
            const len = entry.items.length;
            for (let i = 0; i < len; ++i) {
                const item = entry.items[i];
                if (item.type !== "list") {
                    const className = `${this._getStyleClass(entry.type, item)}${item.type === "itemSpell" ? " rd__li-spell" : ""}`;
                    textStack[0] += `<li class="rd__li ${className}">`;
                }
                if (isListHang && typeof item === "string")
                    textStack[0] += "<div>";
                this._recursiveRender(item, textStack, meta);
                if (isListHang && typeof item === "string")
                    textStack[0] += "</div>";
                if (item.type !== "list")
                    textStack[0] += "</li>";
            }
            textStack[0] += `</${tag}>`;
        }
    }
    ;

    this._getPtExpandCollapseSpecial = function() {
        return `<span class="rd__h-toggle ml-2 clickable no-select" data-rd-h-special-toggle-button="true" title="Toggle Visibility (CTRL to Toggle All)">[\u2013]</span>`;
    }
    ;

    this._renderInset = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset ${this._getMutatedStyleString(entry.style || "")}" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4>${partPageExpandCollapse}</span>`;
        } else {
            textStack[0] += `<span class="rd__h rd__h--2-inset rd__h--2-inset-no-name">${partPageExpandCollapse}</span>`;
        }

        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i) {
                const cacheDepth = meta.depth;
                meta.depth = 2;
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
                meta.depth = cacheDepth;
            }
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderInsetReadaloud = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset rd__b-inset--readaloud ${this._getMutatedStyleString(entry.style || "")}" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4>${this._getPagePart(entry, true)}</span>`;
        } else {
            textStack[0] += `<span class="rd__h rd__h--2-inset rd__h--2-inset-no-name">${partPageExpandCollapse}</span>`;
        }

        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariant = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset" ${dataString}>`;
        textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">Variant: ${entry.name}</h4>${partPageExpandCollapse}</span>`;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        if (entry.source)
            textStack[0] += Renderer.utils.getSourceAndPageTrHtml({
                source: entry.source,
                page: entry.page
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariantInner = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        textStack[0] += `<${this.wrapperTag} class="rd__b-inset-inner" ${dataString}>`;
        textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4></span>`;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        if (entry.source)
            textStack[0] += Renderer.utils.getSourceAndPageTrHtml({
                source: entry.source,
                page: entry.page
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariantSub = function(entry, textStack, meta, options) {
        this._subVariant = true;
        const fauxEntry = entry;
        fauxEntry.type = "entries";
        const cacheDepth = meta.depth;
        meta.depth = 3;
        this._recursiveRender(fauxEntry, textStack, meta, {
            prefix: "<p>",
            suffix: "</p>"
        });
        meta.depth = cacheDepth;
        this._subVariant = false;
    }
    ;

    this._renderSpellcasting_getEntries = function(entry) {
        const hidden = new Set(entry.hidden || []);
        const toRender = [{
            type: "entries",
            name: entry.name,
            entries: entry.headerEntries ? MiscUtil.copyFast(entry.headerEntries) : []
        }];

        if (entry.constant || entry.will || entry.recharge || entry.charges || entry.rest || entry.daily || entry.weekly || entry.yearly || entry.ritual) {
            const tempList = {
                type: "list",
                style: "list-hang-notitle",
                items: [],
                data: {
                    isSpellList: true
                }
            };
            if (entry.constant && !hidden.has("constant"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `Constant:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.constant).join(", ")
                });
            if (entry.will && !hidden.has("will"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `At will:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.will).join(", ")
                });

            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "recharge",
                fnGetDurationText: num=>`{@recharge ${num}|m}`,
                isSkipPrefix: true
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "charges",
                fnGetDurationText: num=>` charge${num === 1 ? "" : "s"}`
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "rest",
                durationText: "/rest"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "daily",
                durationText: "/day"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "weekly",
                durationText: "/week"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "yearly",
                durationText: "/year"
            });

            if (entry.ritual && !hidden.has("ritual"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `Rituals:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.ritual).join(", ")
                });
            tempList.items = tempList.items.filter(it=>it.entry !== "");
            if (tempList.items.length)
                toRender[0].entries.push(tempList);
        }

        if (entry.spells && !hidden.has("spells")) {
            const tempList = {
                type: "list",
                style: "list-hang-notitle",
                items: [],
                data: {
                    isSpellList: true
                }
            };

            const lvls = Object.keys(entry.spells).map(lvl=>Number(lvl)).sort(SortUtil.ascSort);

            for (const lvl of lvls) {
                const spells = entry.spells[lvl];
                if (spells) {
                    let levelCantrip = `${Parser.spLevelToFull(lvl)}${(lvl === 0 ? "s" : " level")}`;
                    let slotsAtWill = ` (at will)`;
                    const slots = spells.slots;
                    if (slots >= 0)
                        slotsAtWill = slots > 0 ? ` (${slots} slot${slots > 1 ? "s" : ""})` : ``;
                    if (spells.lower && spells.lower !== lvl) {
                        levelCantrip = `${Parser.spLevelToFull(spells.lower)}-${levelCantrip}`;
                        if (slots >= 0)
                            slotsAtWill = slots > 0 ? ` (${slots} ${Parser.spLevelToFull(lvl)}-level slot${slots > 1 ? "s" : ""})` : ``;
                    }
                    tempList.items.push({
                        type: "itemSpell",
                        name: `${levelCantrip}${slotsAtWill}:`,
                        entry: this._renderSpellcasting_getRenderableList(spells.spells).join(", ") || "\u2014"
                    });
                }
            }

            toRender[0].entries.push(tempList);
        }

        if (entry.footerEntries)
            toRender.push({
                type: "entries",
                entries: entry.footerEntries
            });
        return toRender;
    }
    ;

    this._renderSpellcasting_getEntries_procPerDuration = function({entry, hidden, tempList, prop, durationText, fnGetDurationText, isSkipPrefix}) {
        if (!entry[prop] || hidden.has(prop))
            return;

        for (let lvl = 9; lvl > 0; lvl--) {
            const perDur = entry[prop];
            if (perDur[lvl]) {
                tempList.items.push({
                    type: "itemSpell",
                    name: `${isSkipPrefix ? "" : lvl}${fnGetDurationText ? fnGetDurationText(lvl) : durationText}:`,
                    entry: this._renderSpellcasting_getRenderableList(perDur[lvl]).join(", "),
                });
            }

            const lvlEach = `${lvl}e`;
            if (perDur[lvlEach]) {
                const isHideEach = !perDur[lvl] && perDur[lvlEach].length === 1;
                tempList.items.push({
                    type: "itemSpell",
                    name: `${isSkipPrefix ? "" : lvl}${fnGetDurationText ? fnGetDurationText(lvl) : durationText}${isHideEach ? "" : ` each`}:`,
                    entry: this._renderSpellcasting_getRenderableList(perDur[lvlEach]).join(", "),
                });
            }
        }
    }
    ;

    this._renderSpellcasting_getRenderableList = function(spellList) {
        return spellList.filter(it=>!it.hidden).map(it=>it.entry || it);
    }
    ;

    this._renderSpellcasting = function(entry, textStack, meta, options) {
        const toRender = this._renderSpellcasting_getEntries(entry);
        if (!toRender?.[0].entries?.length)
            return;
        this._recursiveRender({
            type: "entries",
            entries: toRender
        }, textStack, meta);
    }
    ;

    this._renderQuote = function(entry, textStack, meta, options) {
        textStack[0] += `<div class="${this._renderList_getQuoteCssClasses(entry, textStack, meta, options)}">`;

        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            textStack[0] += `<p class="rd__quote-line ${i === len - 1 && entry.by ? `rd__quote-line--last` : ""}">${i === 0 && !entry.skipMarks ? "&ldquo;" : ""}`;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: entry.skipItalics ? "" : "<i>",
                suffix: entry.skipItalics ? "" : "</i>"
            });
            textStack[0] += `${i === len - 1 && !entry.skipMarks ? "&rdquo;" : ""}</p>`;
        }

        if (entry.by || entry.from) {
            textStack[0] += `<p>`;
            const tempStack = [""];
            const byArr = this._renderQuote_getBy(entry);
            if (byArr) {
                for (let i = 0, len = byArr.length; i < len; ++i) {
                    const by = byArr[i];
                    this._recursiveRender(by, tempStack, meta);
                    if (i < len - 1)
                        tempStack[0] += "<br>";
                }
            }
            textStack[0] += `<span class="rd__quote-by">\u2014 ${byArr ? tempStack.join("") : ""}${byArr && entry.from ? `, ` : ""}${entry.from ? `<i>${entry.from}</i>` : ""}</span>`;
            textStack[0] += `</p>`;
        }

        textStack[0] += `</div>`;
    }
    ;

    this._renderList_getQuoteCssClasses = function(entry, textStack, meta, options) {
        const out = [`rd__quote`];
        if (entry.style) {
            if (entry.style)
                out.push(...entry.style.split(" ").map(it=>`rd__${it}`));
        }
        return out.join(" ");
    }
    ;

    this._renderQuote_getBy = function(entry) {
        if (!entry.by?.length)
            return null;
        return entry.by instanceof Array ? entry.by : [entry.by];
    }
    ;

    this._renderOptfeature = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, true);
    }
    ;

    this._renderPatron = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, false);
    }
    ;

    this._renderAbilityDc = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center"><b>`;
        this._recursiveRender(entry.name, textStack, meta);
        textStack[0] += ` save DC</b> = 8 + your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderAbilityAttackMod = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center"><b>`;
        this._recursiveRender(entry.name, textStack, meta);
        textStack[0] += ` attack modifier</b> = your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderAbilityGeneric = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center">`;
        if (entry.name)
            this._recursiveRender(entry.name, textStack, meta, {
                prefix: "<b>",
                suffix: "</b> = "
            });
        textStack[0] += `${entry.text}${entry.attributes ? ` ${Parser.attrChooseToFull(entry.attributes)}` : ""}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderInline = function(entry, textStack, meta, options) {
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta);
        }
    }
    ;

    this._renderInlineBlock = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta);
        }
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderBonus = function(entry, textStack, meta, options) {
        textStack[0] += (entry.value < 0 ? "" : "+") + entry.value;
    }
    ;

    this._renderBonusSpeed = function(entry, textStack, meta, options) {
        textStack[0] += entry.value === 0 ? "\u2014" : `${entry.value < 0 ? "" : "+"}${entry.value} ft.`;
    }
    ;

    this._renderDice = function(entry, textStack, meta, options) {
        const pluginResults = this._getPlugins("dice").map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);

        textStack[0] += Renderer.getEntryDice(entry, entry.name, {
            isAddHandlers: this._isAddHandlers,
            pluginResults
        });
    }
    ;

    this._renderActions = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 2);

        textStack[0] += `<${this.wrapperTag} class="${Renderer.HEAD_2}" ${dataString}><span class="rd__h rd__h--3" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><span class="entry-title-inner">${entry.name}.</span></span> `;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderAttack = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<i>${Parser.attackTypeToFull(entry.attackType)}:</i> `;
        const len = entry.attackEntries.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.attackEntries[i], textStack, meta);
        textStack[0] += ` <i>Hit:</i> `;
        const len2 = entry.hitEntries.length;
        for (let i = 0; i < len2; ++i)
            this._recursiveRender(entry.hitEntries[i], textStack, meta);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderIngredient = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        this._recursiveRender(entry.entry, textStack, meta);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItem = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<p class="rd__p-list-item"><span class="${this._getMutatedStyleString(entry.style) || "bold"} rd__list-item-name">${this.render(entry.name)}${this._renderItem_isAddPeriod(entry) ? "." : ""}</span> `;
        if (entry.entry)
            this._recursiveRender(entry.entry, textStack, meta);
        else if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: i > 0 ? `<span class="rd__p-cont-indent">` : "",
                    suffix: i > 0 ? "</span>" : ""
                });
        }
        textStack[0] += "</p>";
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItem_isAddPeriod = function(entry) {
        return entry.name && entry.nameDot !== false && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
    }
    ;

    this._renderItemSub = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        const isAddPeriod = entry.name && entry.nameDot !== false && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
        this._recursiveRender(entry.entry, textStack, meta, {
            prefix: `<p class="rd__p-list-item"><span class="italic rd__list-item-name">${entry.name}${isAddPeriod ? "." : ""}</span> `,
            suffix: "</p>"
        });
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItemSpell = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);

        const tempStack = [""];
        this._recursiveRender(entry.name || "", tempStack, meta);

        this._recursiveRender(entry.entry, textStack, meta, {
            prefix: `<p>${tempStack.join("")} `,
            suffix: "</p>"
        });
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._InlineStatblockStrategy = function({pFnPreProcess, }, ) {
        this.pFnPreProcess = pFnPreProcess;
    }
    ;

    this._INLINE_STATBLOCK_STRATEGIES = {
        "item": new this._InlineStatblockStrategy({
            pFnPreProcess: async(ent)=>{
                await Renderer.item.pPopulatePropertyAndTypeReference();
                Renderer.item.enhanceItem(ent);
                return ent;
            }
            ,
        }),
    };

    this._renderStatblockInline = function(entry, textStack, meta, options) {
        const fnGetRenderCompact = Renderer.hover.getFnRenderCompact(entry.dataType);

        const headerName = entry.displayName || entry.data?.name;
        const headerStyle = entry.style;

        if (!fnGetRenderCompact) {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderDataHeader(textStack, headerName, headerStyle);
            textStack[0] += `<tr>
				<td colspan="6">
					<i class="text-danger">Cannot render &quot;${entry.type}&quot;&mdash;unknown data type &quot;${entry.dataType}&quot;!</i>
				</td>
			</tr>`;
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);
            return;
        }

        const strategy = this._INLINE_STATBLOCK_STRATEGIES[entry.dataType];

        if (!strategy?.pFnPreProcess && !entry.data?._copy) {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderDataHeader(textStack, headerName, headerStyle, {
                isCollapsed: entry.collapsed
            });
            textStack[0] += fnGetRenderCompact(entry.data, {
                isEmbeddedEntity: true
            });
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);
            return;
        }

        this._renderPrefix(entry, textStack, meta, options);
        this._renderDataHeader(textStack, headerName, headerStyle, {
            isCollapsed: entry.collapsed
        });

        const id = CryptUtil.uid();
        Renderer._cache.inlineStatblock[id] = {
            pFn: async(ele)=>{
                const entLoaded = entry.data?._copy ? (await DataUtil.pDoMetaMergeSingle(entry.dataType, {
                    dependencies: {
                        [entry.dataType]: entry.dependencies
                    }
                }, entry.data, )) : entry.data;

                const ent = strategy?.pFnPreProcess ? await strategy.pFnPreProcess(entLoaded) : entLoaded;

                const tbl = ele.closest("table");
                const nxt = e_({
                    outer: Renderer.utils.getEmbeddedDataHeader(headerName, headerStyle, {
                        isCollapsed: entry.collapsed
                    }) + fnGetRenderCompact(ent, {
                        isEmbeddedEntity: true
                    }) + Renderer.utils.getEmbeddedDataFooter(),
                });
                tbl.parentNode.replaceChild(nxt, tbl, );
            }
            ,
        };

        textStack[0] += `<tr><td colspan="6"><style data-rd-cache-id="${id}" data-rd-cache="inlineStatblock" onload="Renderer._cache.pRunFromEle(this)"></style></td></tr>`;
        this._renderDataFooter(textStack);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderDataHeader = function(textStack, name, style, {isCollapsed=false}={}) {
        textStack[0] += Renderer.utils.getEmbeddedDataHeader(name, style, {
            isCollapsed
        });
    }
    ;

    this._renderDataFooter = function(textStack) {
        textStack[0] += Renderer.utils.getEmbeddedDataFooter();
    }
    ;

    this._renderStatblock = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);

        const page = entry.prop || Renderer.tag.getPage(entry.tag);
        const source = Parser.getTagSource(entry.tag, entry.source);
        const hash = entry.hash || (UrlUtil.URL_TO_HASH_BUILDER[page] ? UrlUtil.URL_TO_HASH_BUILDER[page]({
            ...entry,
            name: entry.name,
            source
        }) : null);

        const asTag = `{@${entry.tag} ${entry.name}|${source}${entry.displayName ? `|${entry.displayName}` : ""}}`;

        if (!page || !source || !hash) {
            this._renderDataHeader(textStack, entry.name, entry.style);
            textStack[0] += `<tr>
				<td colspan="6">
					<i class="text-danger">Cannot load ${entry.tag ? `&quot;${asTag}&quot;` : entry.displayName || entry.name}! An unknown tag/prop, source, or hash was provided.</i>
				</td>
			</tr>`;
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);

            return;
        }

        this._renderDataHeader(textStack, entry.displayName || entry.name, entry.style, {
            isCollapsed: entry.collapsed
        });
        textStack[0] += `<tr>
			<td colspan="6" data-rd-tag="${(entry.tag || "").qq()}" data-rd-page="${(page || "").qq()}" data-rd-source="${(source || "").qq()}" data-rd-hash="${(hash || "").qq()}" data-rd-name="${(entry.name || "").qq()}" data-rd-display-name="${(entry.displayName || "").qq()}" data-rd-style="${(entry.style || "").qq()}">
				<i>Loading ${entry.tag ? `${Renderer.get().render(asTag)}` : entry.displayName || entry.name}...</i>
				<style onload="Renderer.events.handleLoad_inlineStatblock(this)"></style>
			</td>
		</tr>`;
        this._renderDataFooter(textStack);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderGallery = function(entry, textStack, meta, options) {
        if (entry.name)
            textStack[0] += `<h5 class="rd__gallery-name">${entry.name}</h5>`;
        textStack[0] += `<div class="rd__wrp-gallery">`;
        const len = entry.images.length;
        const anyNamed = entry.images.some(it=>it.title);
        const isAnyCredited = entry.images.some(it=>it.credit);
        for (let i = 0; i < len; ++i) {
            const img = MiscUtil.copyFast(entry.images[i]);

            if (anyNamed && !img.title)
                img._galleryTitlePad = true;
            if (isAnyCredited && !img.credit)
                img._galleryCreditPad = true;

            delete img.imageType;
            this._recursiveRender(img, textStack, meta, options);
        }
        textStack[0] += `</div>`;
    }
    ;

    this._renderFlowchart = function(entry, textStack, meta, options) {
        textStack[0] += `<div class="rd__wrp-flowchart">`;
        const len = entry.blocks.length;
        for (let i = 0; i < len; ++i) {
            this._recursiveRender(entry.blocks[i], textStack, meta, options);
            if (i !== len - 1) {
                textStack[0] += `<div class="rd__s-v-flow"></div>`;
            }
        }
        textStack[0] += `</div>`;
    }
    ;

    this._renderFlowBlock = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-flow ve-text-center" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-flow-block" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${this.render({
                type: "inline",
                entries: [entry.name]
            })}</h4></span>`;
        }
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i) {
                const cacheDepth = meta.depth;
                meta.depth = 2;
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
                meta.depth = cacheDepth;
            }
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderHomebrew = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="homebrew-section"><div class="homebrew-float"><span class="homebrew-notice"></span>`;

        if (entry.oldEntries) {
            const hoverMeta = Renderer.hover.getInlineHover({
                type: "entries",
                name: "Homebrew",
                entries: entry.oldEntries
            });
            let markerText;
            if (entry.movedTo) {
                markerText = "(See moved content)";
            } else if (entry.entries) {
                markerText = "(See replaced content)";
            } else {
                markerText = "(See removed content)";
            }
            textStack[0] += `<span class="homebrew-old-content" href="#${window.location.hash}" ${hoverMeta.html}>${markerText}</span>`;
        }

        textStack[0] += `</div>`;

        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
        } else if (entry.movedTo) {
            textStack[0] += `<i>This content has been moved to ${entry.movedTo}.</i>`;
        } else {
            textStack[0] += "<i>This content has been deleted.</i>";
        }

        textStack[0] += `</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderCode = function(entry, textStack, meta, options) {
        const isWrapped = !!StorageUtil.syncGet("rendererCodeWrap");
        textStack[0] += `
			<div class="ve-flex-col h-100">
				<div class="ve-flex no-shrink pt-1">
					<button class="btn btn-default btn-xs mb-1 mr-2" onclick="Renderer.events.handleClick_copyCode(event, this)">Copy Code</button>
					<button class="btn btn-default btn-xs mb-1 ${isWrapped ? "active" : ""}" onclick="Renderer.events.handleClick_toggleCodeWrap(event, this)">Word Wrap</button>
				</div>
				<pre class="h-100 w-100 mb-1 ${isWrapped ? "rd__pre-wrap" : ""}">${entry.preformatted}</pre>
			</div>
		`;
    }
    ;

    this._renderHr = function(entry, textStack, meta, options) {
        textStack[0] += `<hr class="rd__hr">`;
    }
    ;

    this._getStyleClass = function(entryType, entry) {
        const outList = [];

        const pluginResults = this._getPlugins(`${entryType}_styleClass_fromSource`).map(plugin=>plugin(entryType, entry)).filter(Boolean);

        if (!pluginResults.some(it=>it.isSkip)) {
            if (SourceUtil.isNonstandardSource(entry.source) || (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(entry.source)))
                outList.push("spicy-sauce");
            if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(entry.source))
                outList.push("refreshing-brew");
        }

        if (this._extraSourceClasses)
            outList.push(...this._extraSourceClasses);
        for (const k in this._fnsGetStyleClasses) {
            const fromFn = this._fnsGetStyleClasses[k](entry);
            if (fromFn)
                outList.push(...fromFn);
        }
        if (entry.style)
            outList.push(this._getMutatedStyleString(entry.style));
        return outList.join(" ");
    }
    ;

    this._renderString = function(entry, textStack, meta, options) {
        const tagSplit = Renderer.splitByTags(entry);
        const len = tagSplit.length;
        for (let i = 0; i < len; ++i) {
            const s = tagSplit[i];
            if (!s)
                continue;
            if (s.startsWith("{@")) {
                const [tag,text] = Renderer.splitFirstSpace(s.slice(1, -1));
                this._renderString_renderTag(textStack, meta, options, tag, text);
            } else
                textStack[0] += s;
        }
    }
    ;

    this._renderString_renderTag = function(textStack, meta, options, tag, text) {
        for (const plugin of this._getPlugins("string_tag")) {
            const out = plugin(tag, text, textStack, meta, options);
            if (out)
                return void (textStack[0] += out);
        }

        for (const plugin of this._getPlugins(`string_${tag}`)) {
            const out = plugin(tag, text, textStack, meta, options);
            if (out)
                return void (textStack[0] += out);
        }

        switch (tag) {
        case "@b":
        case "@bold":
            textStack[0] += `<b>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</b>`;
            break;
        case "@i":
        case "@italic":
            textStack[0] += `<i>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</i>`;
            break;
        case "@s":
        case "@strike":
            textStack[0] += `<s>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</s>`;
            break;
        case "@u":
        case "@underline":
            textStack[0] += `<u>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</u>`;
            break;
        case "@sup":
            textStack[0] += `<sup>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</sup>`;
            break;
        case "@sub":
            textStack[0] += `<sub>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</sub>`;
            break;
        case "@kbd":
            textStack[0] += `<kbd>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</kbd>`;
            break;
        case "@code":
            textStack[0] += `<span class="code">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@style":
            {
                const [displayText,styles] = Renderer.splitTagByPipe(text);
                const classNames = (styles || "").split(";").map(it=>Renderer._STYLE_TAG_ID_TO_STYLE[it.trim()]).filter(Boolean).join(" ");
                textStack[0] += `<span class="${classNames}">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@font":
            {
                const [displayText,fontFamily] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span style="font-family: '${fontFamily}'">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@note":
            textStack[0] += `<i class="ve-muted">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</i>`;
            break;
        case "@tip":
            {
                const [displayText,titielText] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span title="${titielText.qq()}">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@atk":
            textStack[0] += `<i>${Renderer.attackTagToFull(text)}</i>`;
            break;
        case "@h":
            textStack[0] += `<i>Hit:</i> `;
            break;
        case "@m":
            textStack[0] += `<i>Miss:</i> `;
            break;
        case "@color":
            {
                const [toDisplay,color] = Renderer.splitTagByPipe(text);
                const ptColor = this._renderString_renderTag_getBrewColorPart(color);

                textStack[0] += `<span class="rd__color" style="color: ${ptColor}">`;
                this._recursiveRender(toDisplay, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@highlight":
            {
                const [toDisplay,color] = Renderer.splitTagByPipe(text);
                const ptColor = this._renderString_renderTag_getBrewColorPart(color);

                textStack[0] += ptColor ? `<span style="background-color: ${ptColor}">` : `<span class="rd__highlight">`;
                textStack[0] += toDisplay;
                textStack[0] += `</span>`;
                break;
            }
        case "@help":
            {
                const [toDisplay,title=""] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span class="help" title="${title.qq()}">`;
                this._recursiveRender(toDisplay, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }

        case "@unit":
            {
                const [amount,unitSingle,unitPlural] = Renderer.splitTagByPipe(text);
                textStack[0] += isNaN(amount) ? unitSingle : Number(amount) > 1 ? (unitPlural || unitSingle.toPlural()) : unitSingle;
                break;
            }

        case "@comic":
            textStack[0] += `<span class="rd__comic">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH1":
            textStack[0] += `<span class="rd__comic rd__comic--h1">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH2":
            textStack[0] += `<span class="rd__comic rd__comic--h2">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH3":
            textStack[0] += `<span class="rd__comic rd__comic--h3">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH4":
            textStack[0] += `<span class="rd__comic rd__comic--h4">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicNote":
            textStack[0] += `<span class="rd__comic rd__comic--note">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;

        case "@dc":
            {
                const [dcText,displayText] = Renderer.splitTagByPipe(text);
                textStack[0] += `DC <span class="rd__dc">${displayText || dcText}</span>`;
                break;
            }

        case "@dcYourSpellSave":
            {
                const [displayText] = Renderer.splitTagByPipe(text);
                textStack[0] += displayText || "your spell save DC";
                break;
            }

        case "@dice":
        case "@autodice":
        case "@damage":
        case "@hit":
        case "@d20":
        case "@chance":
        case "@coinflip":
        case "@recharge":
        case "@ability":
        case "@savingThrow":
        case "@skillCheck":
            {
                const fauxEntry = Renderer.utils.getTagEntry(tag, text);

                if (tag === "@recharge") {
                    const [,flagsRaw] = Renderer.splitTagByPipe(text);
                    const flags = flagsRaw ? flagsRaw.split("") : null;
                    textStack[0] += `${flags && flags.includes("m") ? "" : "("}Recharge `;
                    this._recursiveRender(fauxEntry, textStack, meta);
                    textStack[0] += `${flags && flags.includes("m") ? "" : ")"}`;
                } else {
                    this._recursiveRender(fauxEntry, textStack, meta);
                }

                break;
            }

        case "@hitYourSpellAttack":
            this._renderString_renderTag_hitYourSpellAttack(textStack, meta, options, tag, text);
            break;

        case "@scaledice":
        case "@scaledamage":
            {
                const fauxEntry = Renderer.parseScaleDice(tag, text);
                this._recursiveRender(fauxEntry, textStack, meta);
                break;
            }

        case "@filter":
            {
                const [displayText,page,...filters] = Renderer.splitTagByPipe(text);

                const filterSubhashMeta = Renderer.getFilterSubhashes(filters);

                const fauxEntry = {
                    type: "link",
                    text: displayText,
                    href: {
                        type: "internal",
                        path: `${page}.html`,
                        hash: HASH_BLANK,
                        hashPreEncoded: true,
                        subhashes: filterSubhashMeta.subhashes,
                    },
                };

                if (filterSubhashMeta.customHash)
                    fauxEntry.href.hash = filterSubhashMeta.customHash;

                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        case "@link":
            {
                const [displayText,url] = Renderer.splitTagByPipe(text);
                let outUrl = url == null ? displayText : url;
                if (!outUrl.startsWith("http"))
                    outUrl = `http://${outUrl}`;
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "external",
                        url: outUrl,
                    },
                    text: displayText,
                };
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        case "@5etools":
            {
                const [displayText,page,hash] = Renderer.splitTagByPipe(text);
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                    },
                    text: displayText,
                };
                if (hash) {
                    fauxEntry.hash = hash;
                    fauxEntry.hashPreEncoded = true;
                }
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }

        case "@footnote":
            {
                const [displayText,footnoteText,optTitle] = Renderer.splitTagByPipe(text);
                const hoverMeta = Renderer.hover.getInlineHover({
                    type: "entries",
                    name: optTitle ? optTitle.toTitleCase() : "Footnote",
                    entries: [footnoteText, optTitle ? `{@note ${optTitle}}` : ""].filter(Boolean),
                });
                textStack[0] += `<span class="help" ${hoverMeta.html}>`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;

                break;
            }
        case "@homebrew":
            {
                const [newText,oldText] = Renderer.splitTagByPipe(text);
                const tooltipEntries = [];
                if (newText && oldText) {
                    tooltipEntries.push("{@b This is a homebrew addition, replacing the following:}");
                } else if (newText) {
                    tooltipEntries.push("{@b This is a homebrew addition.}");
                } else if (oldText) {
                    tooltipEntries.push("{@b The following text has been removed with this homebrew:}");
                }
                if (oldText) {
                    tooltipEntries.push(oldText);
                }
                const hoverMeta = Renderer.hover.getInlineHover({
                    type: "entries",
                    name: "Homebrew Modifications",
                    entries: tooltipEntries,
                });
                textStack[0] += `<span class="homebrew-inline" ${hoverMeta.html}>`;
                this._recursiveRender(newText || "[...]", textStack, meta);
                textStack[0] += `</span>`;

                break;
            }
        case "@area":
            {
                const {areaId, displayText} = Renderer.tag.TAG_LOOKUP.area.getMeta(tag, text);

                if (typeof BookUtil === "undefined") {
                    textStack[0] += displayText;
                } else {
                    const area = BookUtil.curRender.headerMap[areaId] || {
                        entry: {
                            name: ""
                        }
                    };
                    const hoverMeta = Renderer.hover.getInlineHover(area.entry, {
                        isLargeBookContent: true,
                        depth: area.depth
                    });
                    textStack[0] += `<a href="#${BookUtil.curRender.curBookId},${area.chapter},${UrlUtil.encodeForHash(area.entry.name)},0" ${hoverMeta.html}>${displayText}</a>`;
                }

                break;
            }

        case "@loader":
            {
                const {name, path, mode} = this._renderString_getLoaderTagMeta(text);

                const brewUtilName = mode === "homebrew" ? "BrewUtil2" : mode === "prerelease" ? "PrereleaseUtil" : null;
                const brewUtil = globalThis[brewUtilName];

                if (!brewUtil) {
                    textStack[0] += `<span class="text-danger" title="Unknown loader mode &quot;${mode.qq()}&quot;!">${name}<span class="glyphicon glyphicon-alert rd__loadbrew-icon rd__loadbrew-icon"></span></span>`;

                    break;
                }

                textStack[0] += `<span onclick="${brewUtilName}.pAddBrewFromLoaderTag(this)" data-rd-loader-path="${path.escapeQuotes()}" data-rd-loader-name="${name.escapeQuotes()}" class="rd__wrp-loadbrew--ready" title="Click to install ${brewUtil.DISPLAY_NAME}">${name}<span class="glyphicon glyphicon-download-alt rd__loadbrew-icon rd__loadbrew-icon"></span></span>`;
                break;
            }

        case "@book":
        case "@adventure":
            {
                const page = tag === "@book" ? "book.html" : "adventure.html";
                const [displayText,book,chapter,section,rawNumber] = Renderer.splitTagByPipe(text);
                const number = rawNumber || 0;
                const hash = `${book}${chapter ? `${HASH_PART_SEP}${chapter}${section ? `${HASH_PART_SEP}${UrlUtil.encodeForHash(section)}${number != null ? `${HASH_PART_SEP}${UrlUtil.encodeForHash(number)}` : ""}` : ""}` : ""}`;
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                        hash,
                        hashPreEncoded: true,
                    },
                    text: displayText,
                };
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }

        default:
            {
                const {name, source, displayText, others, page, hash, hashPreEncoded, pageHover, hashHover, hashPreEncodedHover, preloadId, linkText, subhashes, subhashesHover, isFauxPage} = Renderer.utils.getTagMeta(tag, text);

                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                        hash,
                        hover: {
                            page,
                            isFauxPage,
                            source,
                        },
                    },
                    text: (displayText || name),
                };

                if (hashPreEncoded != null)
                    fauxEntry.href.hashPreEncoded = hashPreEncoded;
                if (pageHover != null)
                    fauxEntry.href.hover.page = pageHover;
                if (hashHover != null)
                    fauxEntry.href.hover.hash = hashHover;
                if (hashPreEncodedHover != null)
                    fauxEntry.href.hover.hashPreEncoded = hashPreEncodedHover;
                if (preloadId != null)
                    fauxEntry.href.hover.preloadId = preloadId;
                if (linkText)
                    fauxEntry.text = linkText;
                if (subhashes)
                    fauxEntry.href.subhashes = subhashes;
                if (subhashesHover)
                    fauxEntry.href.hover.subhashes = subhashesHover;

                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        }
    }
    ;

    this._renderString_renderTag_getBrewColorPart = function(color) {
        if (!color)
            return "";
        const scrubbedColor = BrewUtilShared.getValidColor(color, {
            isExtended: true
        });
        return scrubbedColor.startsWith("--") ? `var(${scrubbedColor})` : `#${scrubbedColor}`;
    }
    ;

    this._renderString_renderTag_hitYourSpellAttack = function(textStack, meta, options, tag, text) {
        const [displayText] = Renderer.splitTagByPipe(text);

        const fauxEntry = {
            type: "dice",
            rollable: true,
            subType: "d20",
            displayText: displayText || "your spell attack modifier",
            toRoll: `1d20 + #$prompt_number:title=Enter your Spell Attack Modifier$#`,
        };
        return this._recursiveRender(fauxEntry, textStack, meta);
    }
    ;

    this._renderString_getLoaderTagMeta = function(text, {isDefaultUrl=false}={}) {
        const [name,file,mode="homebrew"] = Renderer.splitTagByPipe(text);

        if (!isDefaultUrl)
            return {
                name,
                path: file,
                mode
            };

        const path = /^.*?:\/\//.test(file) ? file : `${VeCt.URL_ROOT_BREW}${file}`;
        return {
            name,
            path,
            mode
        };
    }
    ;

    this._renderPrimitive = function(entry, textStack, meta, options) {
        textStack[0] += entry;
    }
    ;

    this._renderLink = function(entry, textStack, meta, options) {
        let href = this._renderLink_getHref(entry);

        if (entry.href.hover && this._roll20Ids) {
            const procHash = UrlUtil.encodeForHash(entry.href.hash);
            const id = this._roll20Ids[procHash];
            if (id) {
                href = `http://journal.roll20.net/${id.type}/${id.roll20Id}`;
            }
        }

        const pluginData = this._getPlugins("link").map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);
        const isDisableEvents = pluginData.some(it=>it.isDisableEvents);
        const additionalAttributes = pluginData.map(it=>it.attributes).filter(Boolean);

        if (this._isInternalLinksDisabled && entry.href.type === "internal") {
            textStack[0] += `<span class="bold" ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</span>`;
        } else if (entry.href.hover?.isFauxPage) {
            textStack[0] += `<span class="help help--hover" ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</span>`;
        } else {
            textStack[0] += `<a href="${href.qq()}" ${entry.href.type === "internal" ? "" : `target="_blank" rel="noopener noreferrer"`} ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</a>`;
        }
    }
    ;

    this._renderLink_getHref = function(entry) {
        let href;
        if (entry.href.type === "internal") {
            href = `${this.baseUrl}${entry.href.path}#`;
            if (entry.href.hash != null) {
                href += entry.href.hashPreEncoded ? entry.href.hash : UrlUtil.encodeForHash(entry.href.hash);
            }
            if (entry.href.subhashes != null) {
                href += Renderer.utils.getLinkSubhashString(entry.href.subhashes);
            }
        } else if (entry.href.type === "external") {
            href = entry.href.url;
        }
        return href;
    }
    ;

    this._renderLink_getHoverString = function(entry) {
        if (!entry.href.hover || !this._isAddHandlers)
            return "";

        let procHash = entry.href.hover.hash ? entry.href.hover.hashPreEncoded ? entry.href.hover.hash : UrlUtil.encodeForHash(entry.href.hover.hash) : entry.href.hashPreEncoded ? entry.href.hash : UrlUtil.encodeForHash(entry.href.hash);

        if (this._tagExportDict) {
            this._tagExportDict[procHash] = {
                page: entry.href.hover.page,
                source: entry.href.hover.source,
                hash: procHash,
            };
        }

        if (entry.href.hover.subhashes) {
            procHash += Renderer.utils.getLinkSubhashString(entry.href.hover.subhashes);
        }

        const pluginData = this._getPlugins("link_attributesHover").map(plugin=>plugin(entry, procHash)).filter(Boolean);
        const replacementAttributes = pluginData.map(it=>it.attributesHoverReplace).filter(Boolean);
        if (replacementAttributes.length)
            return replacementAttributes.join(" ");

        return `onmouseover="Renderer.hover.pHandleLinkMouseOver(event, this)" onmouseleave="Renderer.hover.handleLinkMouseLeave(event, this)" onmousemove="Renderer.hover.handleLinkMouseMove(event, this)" data-vet-page="${entry.href.hover.page.qq()}" data-vet-source="${entry.href.hover.source.qq()}" data-vet-hash="${procHash.qq()}" ${entry.href.hover.preloadId != null ? `data-vet-preload-id="${`${entry.href.hover.preloadId}`.qq()}"` : ""} ${entry.href.hover.isFauxPage ? `data-vet-is-faux-page="true"` : ""} ${Renderer.hover.getPreventTouchString()}`;
    }
    ;

    this.render = function(entry, depth=0) {
        const tempStack = [];
        this.recursiveRender(entry, tempStack, {
            depth
        });
        return tempStack.join("");
    }
    ;
}
;

Renderer.generic = class {
    static getCompactRenderedString(ent, opts) {
        opts = opts || {};
        const prerequisite = Renderer.utils.prerequisite.getHtml(ent.prerequisite);

        return `
		${opts.dataProp && opts.page ? Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: opts.dataProp,
            page: opts.page
        }) : ""}
		${opts.isSkipNameRow ? "" : Renderer.utils.getNameTr(ent, {
            page: opts.page
        })}
		<tr class="text"><td colspan="6">
		${prerequisite ? `<p>${prerequisite}</p>` : ""}
		${Renderer.get().setFirstSection(true).render({
            entries: ent.entries
        })}
		</td></tr>
		${opts.isSkipPageRow ? "" : Renderer.utils.getPageTr(ent)}`;
    }

    static FEATURE__SKILLS_ALL = Object.keys(Parser.SKILL_TO_ATB_ABV).sort(SortUtil.ascSortLower);

    static FEATURE__TOOLS_ARTISANS = ["alchemist's supplies", "brewer's supplies", "calligrapher's supplies", "carpenter's tools", "cartographer's tools", "cobbler's tools", "cook's utensils", "glassblower's tools", "jeweler's tools", "leatherworker's tools", "mason's tools", "painter's supplies", "potter's tools", "smith's tools", "tinker's tools", "weaver's tools", "woodcarver's tools", ];
    static FEATURE__TOOLS_MUSICAL_INSTRUMENTS = ["bagpipes", "drum", "dulcimer", "flute", "horn", "lute", "lyre", "pan flute", "shawm", "viol", ];
    static FEATURE__TOOLS_ALL = ["artisan's tools",
    ...this.FEATURE__TOOLS_ARTISANS, ...this.FEATURE__TOOLS_MUSICAL_INSTRUMENTS,
    "disguise kit", "forgery kit", "gaming set", "herbalism kit", "musical instrument", "navigator's tools", "thieves' tools", "poisoner's kit", "vehicles (land)", "vehicles (water)", "vehicles (air)", "vehicles (space)", ];

    static FEATURE__LANGUAGES_ALL = Parser.LANGUAGES_ALL.map(it=>it.toLowerCase());
    static FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ = {
        from: [...Parser.LANGUAGES_STANDARD.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesStandard",
        })), ...Parser.LANGUAGES_EXOTIC.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesExotic",
        })), ...Parser.LANGUAGES_SECRET.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesSecret",
        })), ],
        groups: {
            languagesStandard: {
                name: "Standard Languages",
            },
            languagesExotic: {
                name: "Exotic Languages",
                hint: "With your DM's permission, you can choose an exotic language.",
            },
            languagesSecret: {
                name: "Secret Languages",
                hint: "With your DM's permission, you can choose a secret language.",
            },
        },
    };

    static FEATURE__SAVING_THROWS_ALL = [...Parser.ABIL_ABVS];

    static _SKILL_TOOL_LANGUAGE_KEYS__SKILL_ANY = new Set(["anySkill"]);
    static _SKILL_TOOL_LANGUAGE_KEYS__TOOL_ANY = new Set(["anyTool", "anyArtisansTool"]);
    static _SKILL_TOOL_LANGUAGE_KEYS__LANGAUGE_ANY = new Set(["anyLanguage", "anyStandardLanguage", "anyExoticLanguage"]);

    static getSkillSummary({skillProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: skillProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__SKILLS_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__SKILL_ANY,
            isShort,
            hoverTag: "skill",
        });
    }

    static getToolSummary({toolProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: toolProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__TOOLS_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__TOOL_ANY,
            isShort,
        });
    }

    static getLanguageSummary({languageProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: languageProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__LANGUAGES_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__LANGAUGE_ANY,
            isShort,
        });
    }

    static _summariseProfs({profGroupArr, skillToolLanguageProfs, setValid, setValidAny, isShort, hoverTag}) {
        if (!profGroupArr?.length && !skillToolLanguageProfs?.length)
            return {
                summary: "",
                collection: []
            };

        const collectionSet = new Set();

        const handleProfGroup = (profGroup,{isValidate=true}={})=>{
            let sep = ", ";

            const toJoin = Object.entries(profGroup).sort(([kA],[kB])=>this._summariseProfs_sortKeys(kA, kB)).filter(([k,v])=>v && (!isValidate || setValid.has(k) || setValidAny.has(k))).map(([k,v],i)=>{
                const vMapped = this.getMappedAnyProficiency({
                    keyAny: k,
                    countRaw: v
                }) ?? v;

                if (k === "choose") {
                    sep = "; ";

                    const chooseProfs = vMapped.from.filter(s=>!isValidate || setValid.has(s)).map(s=>{
                        collectionSet.add(s);
                        return this._summariseProfs_getEntry({
                            str: s,
                            isShort,
                            hoverTag
                        });
                    }
                    );
                    return `${isShort ? `${i === 0 ? "C" : "c"}hoose ` : ""}${v.count || 1} ${isShort ? `of` : `from`} ${chooseProfs.joinConjunct(", ", " or ")}`;
                }

                collectionSet.add(k);
                return this._summariseProfs_getEntry({
                    str: k,
                    isShort,
                    hoverTag
                });
            }
            );

            return toJoin.join(sep);
        }
        ;

        const summary = [...(profGroupArr || []).map(profGroup=>handleProfGroup(profGroup, {
            isValidate: false
        })), ...(skillToolLanguageProfs || []).map(profGroup=>handleProfGroup(profGroup)), ].filter(Boolean).join(` <i>or</i> `);

        return {
            summary,
            collection: [...collectionSet].sort(SortUtil.ascSortLower)
        };
    }

    static _summariseProfs_sortKeys(a, b, {setValidAny=null}={}) {
        if (a === b)
            return 0;
        if (a === "choose")
            return 2;
        if (b === "choose")
            return -2;
        if (setValidAny) {
            if (setValidAny.has(a))
                return 1;
            if (setValidAny.has(b))
                return -1;
        }
        return SortUtil.ascSort(a, b);
    }

    static _summariseProfs_getEntry({str, isShort, hoverTag}) {
        return isShort ? str.toTitleCase() : hoverTag ? `{@${hoverTag} ${str.toTitleCase()}}` : str.toTitleCase();
    }

    static getMappedAnyProficiency({keyAny, countRaw}) {
        const mappedCount = !isNaN(countRaw) ? Number(countRaw) : 1;
        if (mappedCount <= 0)
            return null;

        switch (keyAny) {
        case "anySkill":
            return {
                name: mappedCount === 1 ? `Any Skill` : `Any ${mappedCount} Skills`,
                from: this.FEATURE__SKILLS_ALL.map(it=>({
                    name: it,
                    prop: "skillProficiencies"
                })),
                count: mappedCount,
            };
        case "anyTool":
            return {
                name: mappedCount === 1 ? `Any Tool` : `Any ${mappedCount} Tools`,
                from: this.FEATURE__TOOLS_ALL.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyArtisansTool":
            return {
                name: mappedCount === 1 ? `Any Artisan's Tool` : `Any ${mappedCount} Artisan's Tools`,
                from: this.FEATURE__TOOLS_ARTISANS.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyMusicalInstrument":
            return {
                name: mappedCount === 1 ? `Any Musical Instrument` : `Any ${mappedCount} Musical Instruments`,
                from: this.FEATURE__TOOLS_MUSICAL_INSTRUMENTS.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyLanguage":
            return {
                name: mappedCount === 1 ? `Any Language` : `Any ${mappedCount} Languages`,
                from: this.FEATURE__LANGUAGES_ALL.map(it=>({
                    name: it,
                    prop: "languageProficiencies"
                })),
                count: mappedCount,
            };
        case "anyStandardLanguage":
            return {
                name: mappedCount === 1 ? `Any Standard Language` : `Any ${mappedCount} Standard Languages`,
                ...MiscUtil.copyFast(this.FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ),
                count: mappedCount,
            };
        case "anyExoticLanguage":
            return {
                name: mappedCount === 1 ? `Any Exotic Language` : `Any ${mappedCount} Exotic Languages`,
                ...MiscUtil.copyFast(this.FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ),
                count: mappedCount,
            };
        case "anySavingThrow":
            return {
                name: mappedCount === 1 ? `Any Saving Throw` : `Any ${mappedCount} Saving Throws`,
                from: this.FEATURE__SAVING_THROWS_ALL.map(it=>({
                    name: it,
                    prop: "savingThrowProficiencies"
                })),
                count: mappedCount,
            };

        case "anyWeapon":
            throw new Error(`Property handling for "anyWeapon" is unimplemented!`);
        case "anyArmor":
            throw new Error(`Property handling for "anyArmor" is unimplemented!`);

        default:
            return null;
        }
    }
}
;
//#endregion


//#region VeCt
globalThis.VeCt = {
    STR_NONE: "None",
    STR_SEE_CONSOLE: "See the console (CTRL+SHIFT+J) for details.",

    HASH_SCALED: "scaled",
    HASH_SCALED_SPELL_SUMMON: "scaledspellsummon",
    HASH_SCALED_CLASS_SUMMON: "scaledclasssummon",

    FILTER_BOX_SUB_HASH_SEARCH_PREFIX: "fbsr",

    JSON_PRERELEASE_INDEX: `prerelease/index.json`,
    JSON_BREW_INDEX: `homebrew/index.json`,

    STORAGE_HOMEBREW: "HOMEBREW_STORAGE",
    STORAGE_HOMEBREW_META: "HOMEBREW_META_STORAGE",
    STORAGE_EXCLUDES: "EXCLUDES_STORAGE",
    STORAGE_DMSCREEN: "DMSCREEN_STORAGE",
    STORAGE_DMSCREEN_TEMP_SUBLIST: "DMSCREEN_TEMP_SUBLIST",
    STORAGE_ROLLER_MACRO: "ROLLER_MACRO_STORAGE",
    STORAGE_ENCOUNTER: "ENCOUNTER_STORAGE",
    STORAGE_POINTBUY: "POINTBUY_STORAGE",
    STORAGE_GLOBAL_COMPONENT_STATE: "GLOBAL_COMPONENT_STATE",

    DUR_INLINE_NOTIFY: 500,

    PG_NONE: "NO_PAGE",
    STR_GENERIC: "Generic",

    SYM_UI_SKIP: Symbol("uiSkip"),

    SYM_WALKER_BREAK: Symbol("walkerBreak"),

    SYM_UTIL_TIMEOUT: Symbol("timeout"),

    LOC_ORIGIN_CANCER: "https://5e.tools",

    URL_BREW: `https://github.com/TheGiddyLimit/homebrew`,
    URL_ROOT_BREW: `https://raw.githubusercontent.com/TheGiddyLimit/homebrew/master/`,
    URL_PRERELEASE: `https://github.com/TheGiddyLimit/unearthed-arcana`,
    URL_ROOT_PRERELEASE: `https://raw.githubusercontent.com/TheGiddyLimit/unearthed-arcana/master/`,
    STR_NO_ATTUNEMENT: "No Attunement Required",

    CR_UNKNOWN: 100001,
    CR_CUSTOM: 100000,

    SPELL_LEVEL_MAX: 9,
    LEVEL_MAX: 20,

    ENTDATA_TABLE_INCLUDE: "tableInclude",
    ENTDATA_ITEM_MERGED_ENTRY_TAG: "item__mergedEntryTag",

    DRAG_TYPE_IMPORT: "ve-Import",
    DRAG_TYPE_LOOT: "ve-Loot",

    Z_INDEX_BENEATH_HOVER: 199,
};
//#endregion

class MixedProxyBase //extends Cls
{
    constructor(...args) {
        //super(...args);
        this.__hooks = {};
        this.__hooksAll = {};
        this.__hooksTmp = null;
        this.__hooksAllTmp = null;
    }

    _getProxy(hookProp, toProxy) {
        return new Proxy(toProxy,{
            set: (object,prop,value)=>{
                return this._doProxySet(hookProp, object, prop, value);
            }
            ,
            deleteProperty: (object,prop)=>{
                if (!(prop in object))
                    return true;
                const prevValue = object[prop];
                Reflect.deleteProperty(object, prop);
                this._doFireHooksAll(hookProp, prop, undefined, prevValue);
                if (this.__hooks[hookProp] && this.__hooks[hookProp][prop])
                    this.__hooks[hookProp][prop].forEach(hook=>hook(prop, undefined, prevValue));
                return true;
            }
            ,
        });
    }

    _doProxySet(hookProp, object, prop, value) {
        if (object[prop] === value){return true;}
        const prevValue = object[prop];
        Reflect.set(object, prop, value);
        this._doFireHooksAll(hookProp, prop, value, prevValue);
        this._doFireHooks(hookProp, prop, value, prevValue);
        return true;
    }

    async _pDoProxySet(hookProp, object, prop, value) {
        if (object[prop] === value)
            return true;
        const prevValue = object[prop];
        Reflect.set(object, prop, value);
        if (this.__hooksAll[hookProp])
            for (const hook of this.__hooksAll[hookProp])
                await hook(prop, value, prevValue);
        if (this.__hooks[hookProp] && this.__hooks[hookProp][prop])
            for (const hook of this.__hooks[hookProp][prop])
                await hook(prop, value, prevValue);
        return true;
    }

    _doFireHooks(hookProp, prop, value, prevValue) {
        if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]){
            console.log("Fire hooks");
            this.__hooks[hookProp][prop].forEach(hook=>hook(prop, value, prevValue));
        }
    }

    _doFireHooksAll(hookProp, prop, value, prevValue) {
        if (this.__hooksAll[hookProp])
            this.__hooksAll[hookProp].forEach(hook=>hook(prop, undefined, prevValue));
    }

    _doFireAllHooks(hookProp) {
        if (this.__hooks[hookProp])
            Object.entries(this.__hooks[hookProp]).forEach(([prop,hk])=>hk(prop));
    }

    _addHook(hookProp, prop, hook) {
        ProxyBase._addHook_to(this.__hooks, hookProp, prop, hook);
        if (this.__hooksTmp)
            ProxyBase._addHook_to(this.__hooksTmp, hookProp, prop, hook);
        return hook;
    }

    static _addHook_to(obj, hookProp, prop, hook) {
        ((obj[hookProp] = obj[hookProp] || {})[prop] = (obj[hookProp][prop] || [])).push(hook);
    }

    _addHookAll(hookProp, hook) {
        ProxyBae._addHookAll_to(this.__hooksAll, hookProp, hook);
        if (this.__hooksAllTmp)
            ProxyBae._addHookAll_to(this.__hooksAllTmp, hookProp, hook);
        return hook;
    }

    static _addHookAll_to(obj, hookProp, hook) {
        (obj[hookProp] = obj[hookProp] || []).push(hook);
    }

    _removeHook(hookProp, prop, hook) {
        ProxyBae._removeHook_from(this.__hooks, hookProp, prop, hook);
        if (this.__hooksTmp)
            ProxyBae._removeHook_from(this.__hooksTmp, hookProp, prop, hook);
    }

    static _removeHook_from(obj, hookProp, prop, hook) {
        if (obj[hookProp] && obj[hookProp][prop]) {
            const ix = obj[hookProp][prop].findIndex(hk=>hk === hook);
            if (~ix)
                obj[hookProp][prop].splice(ix, 1);
        }
    }

    _removeHooks(hookProp, prop) {
        if (this.__hooks[hookProp])
            delete this.__hooks[hookProp][prop];
        if (this.__hooksTmp && this.__hooksTmp[hookProp])
            delete this.__hooksTmp[hookProp][prop];
    }

    _removeHookAll(hookProp, hook) {
        ProxyBae._removeHookAll_from(this.__hooksAll, hookProp, hook);
        if (this.__hooksAllTmp)
            ProxyBae._removeHook_from(this.__hooksAllTmp, hookProp, hook);
    }

    static _removeHookAll_from(obj, hookProp, hook) {
        if (obj[hookProp]) {
            const ix = obj[hookProp].findIndex(hk=>hk === hook);
            if (~ix)
                obj[hookProp].splice(ix, 1);
        }
    }

    _resetHooks(hookProp) {
        if (hookProp !== undefined)
            delete this.__hooks[hookProp];
        else
            Object.keys(this.__hooks).forEach(prop=>delete this.__hooks[prop]);
    }

    _resetHooksAll(hookProp) {
        if (hookProp !== undefined)
            delete this.__hooksAll[hookProp];
        else
            Object.keys(this.__hooksAll).forEach(prop=>delete this.__hooksAll[prop]);
    }

    _saveHookCopiesTo(obj) {
        this.__hooksTmp = obj;
    }
    _saveHookAllCopiesTo(obj) {
        this.__hooksAllTmp = obj;
    }

    _proxyAssign(hookProp, proxyProp, underProp, toObj, isOverwrite) {
        const oldKeys = Object.keys(this[proxyProp]);
        const nuKeys = new Set(Object.keys(toObj));
        const dirtyKeyValues = {};

        if (isOverwrite) {
            oldKeys.forEach(k=>{
                if (!nuKeys.has(k) && this[underProp] !== undefined) {
                    const prevValue = this[proxyProp][k];
                    delete this[underProp][k];
                    dirtyKeyValues[k] = prevValue;
                }
            }
            );
        }

        nuKeys.forEach(k=>{
            if (!CollectionUtil.deepEquals(this[underProp][k], toObj[k])) {
                const prevValue = this[proxyProp][k];
                this[underProp][k] = toObj[k];
                dirtyKeyValues[k] = prevValue;
            }
        }
        );

        Object.entries(dirtyKeyValues).forEach(([k,prevValue])=>{
            this._doFireHooksAll(hookProp, k, this[underProp][k], prevValue);
            if (this.__hooks[hookProp] && this.__hooks[hookProp][k])
                this.__hooks[hookProp][k].forEach(hk=>hk(k, this[underProp][k], prevValue));
        }
        );
    }

    _proxyAssignSimple(hookProp, toObj, isOverwrite) {
        return this._proxyAssign(hookProp, `_${hookProp}`, `__${hookProp}`, toObj, isOverwrite);
    }
}
class BaseComponent //extends Cls
extends MixedProxyBase
{
    _state;
    constructor(...args) {
        super(...args);

        this.__locks = {};
        this.__rendered = {};

        this.__state = {...this._getDefaultState()};
        this._state = this._getProxy("state", this.__state);
    }

    _addHookBase(prop, hook) {
        return this._addHook("state", prop, hook);
    }

    _removeHookBase(prop, hook) {
        return this._removeHook("state", prop, hook);
    }

    _removeHooksBase(prop) {
        return this._removeHooks("state", prop);
    }

    _addHookAllBase(hook) {
        return this._addHookAll("state", hook);
    }

    _removeHookAllBase(hook) {
        return this._removeHookAll("state", hook);
    }

    _setState(toState) {
        this._proxyAssign("state", "_state", "__state", toState, true);
    }

    _setStateValue(prop, value, {isForceTriggerHooks=true}={}) {
        if (this._state[prop] === value && !isForceTriggerHooks)
            return value;
        if (this._state[prop] !== value)
            return this._state[prop] = value;

        this._doFireHooksAll("state", prop, value, value);
        this._doFireHooks("state", prop, value, value);
        return value;
    }

    _getState() {
        return MiscUtil.copyFast(this.__state);
    }

    getPod() {
        this.__pod = this.__pod || {
            get: (prop)=>this._state[prop],
            set: (prop,val)=>this._state[prop] = val,
            delete: (prop)=>delete this._state[prop],
            addHook: (prop,hook)=>this._addHookBase(prop, hook),
            addHookAll: (hook)=>this._addHookAllBase(hook),
            removeHook: (prop,hook)=>this._removeHookBase(prop, hook),
            removeHookAll: (hook)=>this._removeHookAllBase(hook),
            triggerCollectionUpdate: (prop)=>this._triggerCollectionUpdate(prop),
            setState: (state)=>this._setState(state),
            getState: ()=>this._getState(),
            assign: (toObj,isOverwrite)=>this._proxyAssign("state", "_state", "__state", toObj, isOverwrite),
            pLock: lockName=>this._pLock(lockName),
            unlock: lockName=>this._unlock(lockName),
            component: this,
        };
        return this.__pod;
    }

    _getDefaultState() {
        return {};
    }

    getBaseSaveableState() {
        return {
            state: MiscUtil.copyFast(this.__state),
        };
    }

    setBaseSaveableStateFrom(toLoad, isOverwrite=false) {
        toLoad?.state && this._proxyAssignSimple("state", toLoad.state, isOverwrite);
    }

    _getRenderedCollection(opts) {
        opts = opts || {};
        const renderedLookupProp = opts.namespace ? `${opts.namespace}.${opts.prop}` : opts.prop;
        return (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
    }

    _renderCollection(opts) {
        opts = opts || {};

        const rendered = this._getRenderedCollection(opts);
        const entities = this._state[opts.prop] || [];
        return this._renderCollection_doRender(rendered, entities, opts);
    }

    _renderCollection_doRender(rendered, entities, opts) {
        opts = opts || {};

        const toDelete = new Set(Object.keys(rendered));

        for (let i = 0; i < entities.length; ++i) {
            const it = entities[i];

            if (it.id == null)
                throw new Error(`Collection item did not have an ID!`);
            const meta = rendered[it.id];

            toDelete.delete(it.id);
            if (meta) {
                if (opts.isDiffMode) {
                    const nxtHash = this._getCollectionEntityHash(it);
                    if (nxtHash !== meta.__hash)
                        meta.__hash = nxtHash;
                    else
                        continue;
                }

                meta.data = it;
                opts.fnUpdateExisting(meta, it, i);
            } else {
                const meta = opts.fnGetNew(it, i);

                if (meta == null)
                    continue;

                meta.data = it;
                if (!meta.$wrpRow && !meta.fnRemoveEles)
                    throw new Error(`A "$wrpRow" or a "fnRemoveEles" property is required for deletes!`);

                if (opts.isDiffMode)
                    meta.__hash = this._getCollectionEntityHash(it);

                rendered[it.id] = meta;
            }
        }

        const doRemoveElements = meta=>{
            if (meta.$wrpRow)
                meta.$wrpRow.remove();
            if (meta.fnRemoveEles)
                meta.fnRemoveEles();
        }
        ;

        toDelete.forEach(id=>{
            const meta = rendered[id];
            doRemoveElements(meta);
            delete rendered[id];
            if (opts.fnDeleteExisting)
                opts.fnDeleteExisting(meta);
        }
        );

        if (opts.fnReorderExisting) {
            entities.forEach((it,i)=>{
                const meta = rendered[it.id];
                opts.fnReorderExisting(meta, it, i);
            }
            );
        }
    }

    async _pRenderCollection(opts) {
        opts = opts || {};

        const rendered = this._getRenderedCollection(opts);
        const entities = this._state[opts.prop] || [];
        return this._pRenderCollection_doRender(rendered, entities, opts);
    }

    async _pRenderCollection_doRender(rendered, entities, opts) {
        opts = opts || {};

        const toDelete = new Set(Object.keys(rendered));

        for (let i = 0; i < entities.length; ++i) {
            const it = entities[i];

            if (!it.id)
                throw new Error(`Collection item did not have an ID!`);
            const meta = rendered[it.id];

            toDelete.delete(it.id);
            if (meta) {
                if (opts.isDiffMode) {
                    const nxtHash = this._getCollectionEntityHash(it);
                    if (nxtHash !== meta.__hash)
                        meta.__hash = nxtHash;
                    else
                        continue;
                }

                const nxtMeta = await opts.pFnUpdateExisting(meta, it);
                if (opts.isMultiRender)
                    rendered[it.id] = nxtMeta;
            } else {
                const meta = await opts.pFnGetNew(it);

                if (meta == null)
                    continue;

                if (!opts.isMultiRender && !meta.$wrpRow && !meta.fnRemoveEles)
                    throw new Error(`A "$wrpRow" or a "fnRemoveEles" property is required for deletes!`);
                if (opts.isMultiRender && meta.some(it=>!it.$wrpRow && !it.fnRemoveEles))
                    throw new Error(`A "$wrpRow" or a "fnRemoveEles" property is required for deletes!`);

                if (opts.isDiffMode)
                    meta.__hash = this._getCollectionEntityHash(it);

                rendered[it.id] = meta;
            }
        }

        const doRemoveElements = meta=>{
            if (meta.$wrpRow)
                meta.$wrpRow.remove();
            if (meta.fnRemoveEles)
                meta.fnRemoveEles();
        }
        ;

        for (const id of toDelete) {
            const meta = rendered[id];
            if (opts.isMultiRender)
                meta.forEach(it=>doRemoveElements(it));
            else
                doRemoveElements(meta);
            if (opts.additionalCaches)
                opts.additionalCaches.forEach(it=>delete it[id]);
            delete rendered[id];
            if (opts.pFnDeleteExisting)
                await opts.pFnDeleteExisting(meta);
        }

        if (opts.pFnReorderExisting) {
            await entities.pSerialAwaitMap(async(it,i)=>{
                const meta = rendered[it.id];
                await opts.pFnReorderExisting(meta, it, i);
            }
            );
        }
    }

    _detachCollection(prop, namespace=null) {
        const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
        const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
        Object.values(rendered).forEach(it=>it.$wrpRow.detach());
    }

    _resetCollectionRenders(prop, namespace=null) {
        const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
        const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
        Object.values(rendered).forEach(it=>it.$wrpRow.remove());
        delete this.__rendered[renderedLookupProp];
    }

    _getCollectionEntityHash(ent) {
        return CryptUtil.md5(JSON.stringify(ent));
    }

    render() {
        throw new Error("Unimplemented!");
    }

    getSaveableState() {
        return {
            ...this.getBaseSaveableState()
        };
    }
    setStateFrom(toLoad, isOverwrite=false) {
        this.setBaseSaveableStateFrom(toLoad, isOverwrite);
    }

    async _pLock(lockName) {
        while (this.__locks[lockName])
            await this.__locks[lockName].lock;
        let unlock = null;
        const lock = new Promise(resolve=>unlock = resolve);
        this.__locks[lockName] = {
            lock,
            unlock,
        };
    }

    async _pGate(lockName) {
        while (this.__locks[lockName])
            await this.__locks[lockName].lock;
    }

    _unlock(lockName) {
        const lockMeta = this.__locks[lockName];
        if (lockMeta) {
            delete this.__locks[lockName];
            lockMeta.unlock();
        }
    }

    async _pDoProxySetBase(prop, value) {
        return this._pDoProxySet("state", this.__state, prop, value);
    }

    _triggerCollectionUpdate(prop) {
        if (!this._state[prop])
            return;
        this._state[prop] = [...this._state[prop]];
    }

    static _toCollection(array) {
        if (array)
            return array.map(it=>({
                id: CryptUtil.uid(),
                entity: it
            }));
    }

    static _fromCollection(array) {
        if (array)
            return array.map(it=>it.entity);
    }

    static fromObject(obj, ...noModCollections) {
        const comp = new this();
        Object.entries(MiscUtil.copyFast(obj)).forEach(([k,v])=>{
            if (v == null)
                comp.__state[k] = v;
            else if (noModCollections.includes(k) || noModCollections.includes("*"))
                comp.__state[k] = v;
            else if (typeof v === "object" && v instanceof Array)
                comp.__state[k] = BaseComponent$1._toCollection(v);
            else
                comp.__state[k] = v;
        }
        );
        return comp;
    }

    static fromObjectNoMod(obj) {
        return this.fromObject(obj, "*");
    }

    toObject(...noModCollections) {
        const cpy = MiscUtil.copyFast(this.__state);
        Object.entries(cpy).forEach(([k,v])=>{
            if (v == null)
                return;

            if (noModCollections.includes(k) || noModCollections.includes("*"))
                cpy[k] = v;
            else if (v instanceof Array && v.every(it=>it && it.id))
                cpy[k] = BaseComponent$1._fromCollection(v);
        }
        );
        return cpy;
    }

    toObjectNoMod() {
        return this.toObject("*");
    }
}
class ActorCharactermancerBaseComponent extends BaseComponent {
    get state() {return this._state; }
    addHookBase(prop, hook) {
      this._addHookBase(prop, hook);
    }
    proxyAssignSimple(hookProp, toObj, isOverwrite) {
      return this._proxyAssignSimple(hookProp, toObj, isOverwrite);
    }
    /**Simply creates a property out of an index, to use for asking _state for information */
    static class_getProps(ix) {
    return {
        'propPrefixClass': 'class_' + ix + '_',
        'propIxClass': "class_" + ix + "_ixClass",
        'propPrefixSubclass': "class_" + ix + "_subclass_",
        'propIxSubclass': "class_" + ix + "_subclass_ixSubclass",
        'propCntAsi': "class_" + ix + "_cntAsi",
        'propCurLevel': "class_" + ix + "_curLevel",
        'propTargetLevel': "class_" + ix + "_targetLevel"
      };
    }
    _shared_renderEntity_stgOtherProficiencies({
      $stg: _0xc3c609,
      ent: _0x18d378,
      propComp: _0x4903c6,
      propProficiencies: _0x5a1d45,
      title: _0x275afd,
      CompClass: _0x479d8d,
      propPathActorExistingProficiencies: _0x429830,
      fnGetExistingFvtt: _0x42b271,
      fnGetMappedProficiencies: _0x18857c
    }) {
      _0xc3c609.empty();
      this._parent.featureSourceTracker_.unregister(this[_0x4903c6]);
      if (_0x18d378 && _0x18d378[_0x5a1d45]) {
        _0xc3c609.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">" + _0x275afd + "</div>");
        const _0x5ddf7b = _0x42b271 ? _0x42b271(this._actor) : {
          [_0x5a1d45]: MiscUtil.get(this._actor, '_source', ..._0x429830)
        };
        this[_0x4903c6] = new _0x479d8d({
          'featureSourceTracker': this._parent.featureSourceTracker_,
          'existing': _0x479d8d.getExisting(_0x5ddf7b),
          'existingFvtt': _0x5ddf7b,
          'available': _0x18857c ? _0x18857c(_0x18d378[_0x5a1d45], _0x5a1d45) : _0x18d378[_0x5a1d45]
        });
        this[_0x4903c6].render(_0xc3c609);
      } else {
        _0xc3c609.hideVe();
        this[_0x4903c6] = null;
      }
    }
    _shared_renderEntity_stgDiDrDvCi({
      $stg: _0x53e426,
      ent: _0x137c88,
      propComp: _0x528966,
      CompClass: _0x49593b,
      title: _0xf6f71d,
      propRaceData: _0xcf0cc,
      propTraits: _0x141da8
    }) {
      _0x53e426.empty();
      if (_0x137c88 && _0x137c88[_0xcf0cc]) {
        _0x53e426.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">" + _0xf6f71d + "</div>");
        const _0x44ab2c = {
          [_0xcf0cc]: MiscUtil.get(this._actor, "_source", "system", "traits", _0x141da8)
        };
        this[_0x528966] = new _0x49593b({
          'existing': _0x49593b.getExisting(_0x44ab2c),
          'existingFvtt': _0x44ab2c,
          'available': _0x137c88[_0xcf0cc]
        });
        this[_0x528966].render(_0x53e426);
      } else {
        _0x53e426.hideVe();
        this[_0x528966] = null;
      }
    }
}
class ActorCharactermancerClass extends ActorCharactermancerBaseComponent {
    _data;
    _tabClass;
    _actor;

    constructor(_0x13f182) {
      _0x13f182 = _0x13f182 || {};
      super();
      this._actor = _0x13f182.actor;
      this._data = _0x13f182.data; //data is an object containing information about all classes, subclasses, feats, etc
      this._parent = _0x13f182.parent;
      //_0x13f182 is basically the window, tabClass contains DOM elements, one for each "screen" (class, race, abiltiies, etc)
      this._tabClass = _0x13f182.tabClass;
      //TEMP not sure what this does, bloat code so im commenting it out for the moment
      this._modalFilterClasses = new ModalFilterClassesFvtt({
        'namespace': "ActorCharactermancer.classes",
        'allData': this._data["class"]
      });
      this._metaHksClassStgSubclass = [];
      this._compsClassStartingProficiencies = [];
      this._compsClassHpIncreaseMode = [];
      this._compsClassHpInfo = [];
      this._compsClassLevelSelect = [];
      this._compsClassFeatureOptionsSelect = [];
      this._compsClassSkillProficiencies = [];
      this._compsClassToolProficiencies = [];
      this._metaHksClassStgSkills = [];
      this._metaHksClassStgTools = [];
      this._metaHksClassStgStartingProficiencies = [];
      this._$wrpsClassTable = [];
      this._existingClassMetas = [];

    }
    get modalFilterClasses() {
      return this._modalFilterClasses;
    }
    get compsClassStartingProficiencies() {
      return this._compsClassStartingProficiencies;
    }
    get compsClassHpIncreaseMode() {
      return this._compsClassHpIncreaseMode;
    }
    get compsClassLevelSelect() {
      return this._compsClassLevelSelect;
    }
    get compsClassFeatureOptionsSelect() {
      return this._compsClassFeatureOptionsSelect;
    }
    get compsClassSkillProficiencies() {
      return this._compsClassSkillProficiencies;
    }
    get compsClassToolProficiencies() {
      return this._compsClassToolProficiencies;
    }
    get existingClassMetas() {
      return this._existingClassMetas;
    }
    async pLoad() {
      await this._modalFilterClasses.pPreloadHidden();
      await this._pLoad_pDoHandleExistingClassItems();
    }
    async _pLoad_pDoHandleExistingClassItems() {
      const _0x1c249f = this._actor.items.filter(_0x5de464 => _0x5de464.type === 'class');
      const _0x3dab8a = this._actor.items.filter(_0x248afa => _0x248afa.type === 'subclass');
      this._existingClassMetas = _0x1c249f.map(_0x122387 => {
        const _0x39760a = this._pLoad_getExistingClassIndex(_0x122387);
        const _0x56b925 = _0x3dab8a.find(_0x162fde => _0x162fde.system.classIdentifier === _0x122387.system.identifier);
        let _0xa0d172 = this._pLoad_getExistingSubclassIndex(_0x39760a, _0x56b925);
        const _0x5372b3 = this._actor.system?.details?.['originalClass'] ? this._actor.system?.details?.originalClass === _0x122387.id : !!_0x122387.flags?.[SharedConsts.MODULE_ID]?.['isPrimaryClass'];
        const _0x55c437 = ~_0x39760a ? null : "Could not find class \"" + _0x122387.name + "\" (\"" + UtilDocumentSource.getDocumentSourceDisplayString(_0x122387) + "\") in loaded data. " + Charactermancer_Util.STR_WARN_SOURCE_SELECTION;
        if (_0x55c437) {
          ui.notifications.warn(_0x55c437);
          console.warn(...LGT, _0x55c437, "Strict source matching is: " + Config.get("import", "isStrictMatching") + '.');
        }
        const _0x530b46 = _0x56b925 == null || ~_0xa0d172 ? null : "Could not find subclass \"" + _0x56b925.name + "\" in loaded data. " + Charactermancer_Util.STR_WARN_SOURCE_SELECTION;
        if (_0x530b46) {
          ui.notifications.warn(_0x530b46);
          console.warn(...LGT, _0x530b46, "Strict source matching is: " + Config.get("import", "isStrictMatching") + '.');
        }
        return new ActorCharactermancerClass.ExistingClassMeta({
          'item': _0x122387,
          'ixClass': _0x39760a,
          'isUnknownClass': !~_0x39760a,
          'ixSubclass': _0xa0d172,
          'isUnknownSubclass': _0xa0d172 == null && !~_0xa0d172,
          'level': Number(_0x122387.system.levels || 0x0),
          'isPrimary': _0x5372b3,
          'spellSlotLevelSelection': _0x122387?.flags?.[SharedConsts.MODULE_ID]?.['spellSlotLevelSelection']
        });
      });
      if (!this._existingClassMetas.length) {
        return;
      }
      this._state.class_ixMax = this._existingClassMetas.length - 0x1;
      for (let _0xfaa7c6 = 0x0; _0xfaa7c6 < this._existingClassMetas.length; ++_0xfaa7c6) {
        const _0x325547 = this._existingClassMetas[_0xfaa7c6];
        const {
          propIxClass: _0x57fec3,
          propIxSubclass: _0x4335dc
        } = ActorCharactermancerBaseComponent.class_getProps(_0xfaa7c6);
        await this._pDoProxySetBase(_0x57fec3, _0x325547.ixClass);
        await this._pDoProxySetBase(_0x4335dc, _0x325547.ixSubclass);
        if (_0x325547.isPrimary) {
          this._state.class_ixPrimaryClass = _0xfaa7c6;
        }
      }
      if (!this._existingClassMetas.some(_0x34ec7d => _0x34ec7d.isPrimary)) {
        this._state.class_ixPrimaryClass = 0x0;
      }
    }
    _pLoad_getExistingClassIndex(_0x31ccce) {
      const _0x9c6a99 = _0x31ccce.flags?.[SharedConsts.MODULE_ID];
      if (_0x9c6a99?.propDroppable === 'class' && _0x9c6a99?.source && _0x9c6a99?.hash) {
        const _0x4fb2d3 = this._data["class"].findIndex(_0xc280a8 => _0x9c6a99.source === _0xc280a8.source && _0x9c6a99.hash === UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](_0xc280a8));
        if (~_0x4fb2d3) {
          return _0x4fb2d3;
        }
      }
      const _0x22658f = (IntegrationBabele.getOriginalName(_0x31ccce) || '').toLowerCase().trim();
      const _0xf5d9aa = this._data['class'].findIndex(_0x5112df => {
        return _0x22658f === _0x5112df.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(_0x31ccce).source || '').toLowerCase() === Parser.sourceJsonToAbv(_0x5112df.source).toLowerCase());
      });
      if (~_0xf5d9aa) {
        return _0xf5d9aa;
      }
      const _0x4d5c9d = /^(.*?)\(.*\)$/.exec(_0x22658f);
      if (!_0x4d5c9d) {
        return -0x1;
      }
      return this._data["class"].findIndex(_0x12f0b7 => {
        return _0x4d5c9d[0x1].trim() === _0x12f0b7.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(_0x31ccce).source || '').toLowerCase() === Parser.sourceJsonToAbv(_0x12f0b7.source).toLowerCase());
      });
    }
    _pLoad_getExistingSubclassIndex(_0x161fa4, _0x3e14d4) {
      if (!_0x3e14d4 || !~_0x161fa4) {
        return null;
      }
      const _0x10558f = this._data['class'][_0x161fa4];
      const _0x50af12 = _0x3e14d4.flags?.[SharedConsts.MODULE_ID];
      if (_0x50af12?.["propDroppable"] === "subclass" && _0x50af12?.["source"] && _0x50af12?.["hash"]) {
        const _0x37d579 = _0x10558f.subclasses.findIndex(_0x5067b7 => _0x50af12.source === _0x5067b7.source && _0x50af12.hash === UrlUtil.URL_TO_HASH_BUILDER.subclass(_0x5067b7));
        if (~_0x37d579) {
          return _0x37d579;
        }
      }
      return _0x10558f.subclasses.findIndex(_0x54c0e7 => (IntegrationBabele.getOriginalName(_0x3e14d4) || '').toLowerCase().trim() === _0x54c0e7.name.toLowerCase().trim() && (!Config.get("import", 'isStrictMatching') || (UtilDocumentSource.getDocumentSource(_0x3e14d4).source || '').toLowerCase() === Parser.sourceJsonToAbv(_0x54c0e7.source).toLowerCase()));
    }
    getExistingClassTotalLevels_() {
      return this._existingClassMetas.filter(Boolean).map(_0x29ccbb => _0x29ccbb.level).sum();
    }
    _getExistingClassCount() {
      return this._existingClassMetas.filter(Boolean).length;
    }
    getClass_({ix: ix, propIxClass: propIxClass}) {
        //console.log("_getClass", ix, propIxClass, this._data);
      if (ix == null && propIxClass == null) { throw new Error("At least one argument must be provided!"); }
      //If a propIxClass was provived, try to get the class from this._state
      if (propIxClass != null) {
        if (this._state[propIxClass] == null) { return null;  }
        if (!~this._state[propIxClass]) { return DataConverterClass.getClassStub(); }
        return this._data.class[this._state[propIxClass]];
      }
      //Otherwise, try to get it from this._data, if we have an ix
      if (ix != null && ~ix) { return this._data.class[ix];}
      return DataConverterClass.getClassStub();
    }
    getSubclass_({
      cls: _0x5c8967,
      propIxSubclass: _0x3ff653,
      ix: _0x325aa4
    }) {
      if (_0x325aa4 == null && _0x3ff653 == null) {
        throw new Error("At least one argument must be provided!");
      }
      if (!_0x5c8967) {
        return null;
      }
      if (_0x3ff653 != null) {
        if (this._state[_0x3ff653] == null) {
          return null;
        }
        if (!~this._state[_0x3ff653]) {
          return DataConverterClass.getSubclassStub({
            'cls': _0x5c8967
          });
        }
        if (!_0x5c8967.subclasses?.["length"]) {
          return DataConverterClass.getSubclassStub({
            'cls': _0x5c8967
          });
        }
        return _0x5c8967.subclasses[this._state[_0x3ff653]];
      }
      if (_0x325aa4 != null && ~_0x325aa4) {
        return _0x5c8967.subclasses[_0x325aa4];
      }
      return DataConverterClass.getSubclassStub({
        'cls': _0x5c8967
      });
    }
    _class_isClassSelectionDisabled({
      ix: _0x5bbf32
    }) {
      return !!this._existingClassMetas[_0x5bbf32];
    }
    _class_isSubclassSelectionDisabled({
      ix: _0x3ccf09
    }) {
      return this._existingClassMetas[_0x3ccf09] && (this._existingClassMetas[_0x3ccf09].ixSubclass != null || this._existingClassMetas[_0x3ccf09].isUnknownClass);
    }
    //FINDME ActorCharactermancerClass.render
    render() {
        

      let wrptab = this._tabClass?.$wrpTab;
      if (!wrptab) { return; }
      let classChoiceElement = $(`<div class="ve-flex-col w-100 h-100 px-1 pt-1 overflow-y-auto ve-grow veapp__bg-foundry"></div>`);
      let sidebarElement = $(`<div class="ve-flex-col w-100 h-100 px-1 overflow-y-auto ve-grow veapp__bg-foundry"></div>`);
      for (let i = 0; i < this._state.class_ixMax + 1; ++i) {
        this._class_renderClass(classChoiceElement, sidebarElement, i);
      }
      this._addHookBase("class_ixPrimaryClass", () => this._state.class_pulseChange = !this._state.class_pulseChange);

      //ADD CLASS BUTTON
      const addClassBtn = $(`<button class="btn btn-5et btn-sm">Add Another Class</button>`)
      .click(() => {
        console.log("AddClassButton");
        this._class_renderClass(classChoiceElement, sidebarElement, ++this._state.class_ixMax);
      });


      let o = $$`<div class="ve-flex w-100 h-100">
              <div class="ve-flex-col w-100">
                  ${classChoiceElement}
                  <div class="mt-2">${addClassBtn}</div>
              </div>
              <div class="vr-1"></div>
              ${sidebarElement}
          </div>`.appendTo(wrptab);
    }
    static _class_getLocks(ix) {
      return {
        'lockChangeClass': 'class_' + ix + '_pHkChangeClass',
        'lockChangeSubclass': "class_" + ix + '_pHkChangeSubclass',
        'lockRenderFeatureOptionsSelects': 'class_' + ix + "_renderFeatureOptionsSelects"
      };
    }
    
    _class_renderClass(element1, element2, ix) {
        //Main properties for asking our _state for information on this class
      const {
        propPrefixClass: propPrefixClass,
        propIxClass: propIxClass,
        propPrefixSubclass: propPrefixSubclass,
        propIxSubclass: propIxSubclass,
        propCntAsi: propCntAsi,
        propCurLevel: propCurLevel,
        propTargetLevel: propTargetLevel
      } = ActorCharactermancerBaseComponent.class_getProps(ix);
      const filter_evnt_valchange_class = FilterBox.EVNT_VALCHANGE + ".class_" + ix + "_classLevels";
      const filter_evnt_valchange_subclass = FilterBox.EVNT_VALCHANGE + ".class_" + ix + "_subclass";

      const {
        lockChangeClass: lockChangeClass,
        lockChangeSubclass: lockChangeSubclass,
        lockRenderFeatureOptionsSelects: _0x3217e0
      } = this.constructor._class_getLocks(ix);

      this._addHookBase(propIxClass, () => this._state.class_pulseChange = !this._state.class_pulseChange);

      //Get some information on how this class choice would be displayed (in a dropdown)
      const {
        $wrp: wrapper, //Wrapper DOM for the dropdown menu DOM object
        $iptDisplay: inputDisplay, //a function that returns the visible name of a class that you provide the index for
        $iptSearch: inputSearch,
        fnUpdateHidden: fnUpdateHidden
      } = ComponentUiUtil.$getSelSearchable(this, propIxClass, {
        'values': this._data.class.map((_0x2b7aa2, _0x2f3ba4) => _0x2f3ba4), //Think this is just the ix's of the classes
        'isAllowNull': true,
        'fnDisplay': clsIx => {
            //Using a simple index, ask _data for the class
          const cls = this.getClass_({'ix': clsIx });
          if (!cls) {
            console.warn(...LGT, "Could not find class with index " + clsIx + " (" + this._data.class.length + " classes were available)");
            return '(Unknown)';
          }
          //Then return what should be the displayed name
          return cls.name + " " + (cls.source !== Parser.SRC_PHB ? '[' + Parser.sourceJsonToAbv(cls.source) + ']' : '');
        },
        'fnGetAdditionalStyleClasses': classIx => {
          if (classIx == null) { return null; }
          const cls = this.getClass_({'ix': classIx});
          if (!cls) { return; }
          return cls._versionBase_isVersion ? ['italic'] : null;
        },
        'asMeta': true,
        'isDisabled': this._class_isClassSelectionDisabled({'ix': ix })
      });

      inputDisplay.addClass("bl-0");
      inputSearch.addClass("bl-0");

      const updateHiddenClasses = () => {
        const filterValues = this._modalFilterClasses.pageFilter.filterBox.getValues();
        const classes = this._data.class.map(cls => !this._modalFilterClasses.pageFilter.toDisplay(filterValues, cls));
        fnUpdateHidden(classes, false);
      };

      const applySubclassFilter = () => {
        const cls = this.getClass_({'propIxClass': propIxClass});
        if (!cls || !this._metaHksClassStgSubclass[ix]) { return; }
        const filteredValues = this._modalFilterClasses.pageFilter.filterBox.getValues();
        const displayableSubclasses = cls.subclasses.map(val => !this._modalFilterClasses.pageFilter.toDisplay(filteredValues, val));
        this._metaHksClassStgSubclass[ix].fnUpdateHidden(displayableSubclasses, false);
      };

      //TEMPFIX
      if(SETTINGS.FILTERS){
        //this._modalFilterClasses.pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, () => _0x1133f2());
        //_0x1133f2();
        }
      const filterBtn = $("<button class=\"btn btn-xs btn-5et h-100 btr-0 bbr-0 pr-2\" title=\"Filter for Class and Subclass\"><span class=\"glyphicon glyphicon-filter\"></span> Filter</button>")
      .click(async () => {
        const cls = this.getClass_({
          'propIxClass': propIxClass
        });
        const subcls = this.getSubclass_({
          'cls': cls,
          'propIxSubclass': propIxSubclass
        });
        const classSelectDisabled = this._class_isClassSelectionDisabled({
          'ix': ix
        });
        const subclassSelectDisabled = this._class_isSubclassSelectionDisabled({
          'ix': ix
        });
        const userSelection = await this._modalFilterClasses.pGetUserSelection({
          'selectedClass': cls,
          'selectedSubclass': subcls,
          'isClassDisabled': classSelectDisabled,
          'isSubclassDisabled': subclassSelectDisabled
        });
        if (classSelectDisabled && subclassSelectDisabled) {
          return;
        }
        if (userSelection == null || !userSelection.class) {
          return;
        }
        const class_index = this._data.class.findIndex(_0x46996f => _0x46996f.name === userSelection.class.name && _0x46996f.source === userSelection['class'].source);
        if (!~class_index) {
          throw new Error("Could not find selected class: " + JSON.stringify(userSelection["class"]));
        }
        this._state[propIxClass] = class_index;
        await this._pGate(lockChangeClass);
        if (userSelection.subclass != null) {
          const cls = this.getClass_({
            'propIxClass': propIxClass
          });
          const subcls_index = cls.subclasses.findIndex(_0x482224 => _0x482224.name === userSelection.subclass.name && _0x482224.source === userSelection.subclass.source);
          if (!~subcls_index) {
            throw new Error("Could not find selected subclass: " + JSON.stringify(userSelection.subclass));
          }
          this._state[propIxSubclass] = subcls_index;
        } else {
          this._state[propIxSubclass] = null;
        }
      });

      const renderClass = async _0xd4d6f7 => {
        if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.off(filter_evnt_valchange_subclass);}
        //FIXME SET STATE!
        if (_0xd4d6f7) {
          const toObj = Object.keys(this.__state).filter(propName => propName.startsWith(propPrefixClass) && propName !== propIxClass).mergeMap(_0x77ce3e => ({
            [_0x77ce3e]: null
          }));
          this._proxyAssignSimple("state", toObj);
        }
        //First time this function is called, we will probably not get anything out of getClass since we haven't set anything to _state yet
        const cls = this.getClass_({'propIxClass': propIxClass});
        const subcls = this.getSubclass_({
          'cls': cls,
          'propIxSubclass': propIxSubclass
        });
        console.log("renderClass", cls);
        this._class_renderClass_stgSelectSubclass({
          '$stgSelectSubclass': holder_selectSubclass,
          'cls': cls,
          'ix': ix,
          'propIxSubclass': propIxSubclass,
          'idFilterBoxChangeSubclass': filter_evnt_valchange_subclass,
          'doApplyFilterToSelSubclass': applySubclassFilter
        });
        this._class_renderClass_stgHpMode({
          '$stgHpMode': holder_hpMode,
          'ix': ix,
          'cls': cls
        });
        this._class_renderClass_stgHpInfo({
          '$stgHpInfo': holder_hpInfo,
          'ix': ix,
          'cls': cls
        });/* 
        this._class_renderClass_stgStartingProficiencies({
          '$stgStartingProficiencies': holder_startingProf,
          'ix': ix,
          'cls': cls
        });
        await this._class_renderClass_pStgLevelSelect({
          '$stgLevelSelect': holder_levelSelect,
          '$stgFeatureOptions': holder_featureOptions,
          'ix': ix,
          'cls': cls,
          'sc': subcls,
          'propIxSubclass': propIxSubclass,
          'propCurLevel': propCurLevel,
          'propTargetLevel': propTargetLevel,
          'propCntAsi': propCntAsi,
          'lockRenderFeatureOptionsSelects': _0x3217e0,
          'idFilterBoxChangeClassLevels': filter_evnt_valchange_class
        }); */
        this._state.class_totalLevels = this.class_getTotalLevels();
        /* this._class_renderClass_stgSkills({
          '$stgSkills': holder_skills,
          'ix': ix,
          'propIxClass': propIxClass
        }); */
        /* this._class_renderClass_stgTools({
          '$stgTools': holder_tools,
          'ix': ix,
          'propIxClass': propIxClass
        }); */
        /* await this._class_renderClass_pDispClass({
          'ix': ix,
          '$dispClass': holder_dispClass,
          'cls': cls,
          'sc': subcls
        }); */
        disp_subclass.empty();
      };

      const renderClass_safe = async _0x7a25e5 => {
        try {
          await this._pLock(lockChangeClass);
          await renderClass(_0x7a25e5);
        } finally {
          this._unlock(lockChangeClass);
        }
      };
      this._addHookBase(propIxClass, renderClass_safe);

      const renderSubclass = async () => {
        if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.off(filter_evnt_valchange_subclass);}
        const toObj = Object.keys(this.__state).filter(prop => prop.startsWith(propPrefixSubclass) && prop !== propIxSubclass).mergeMap(_0x207fe4 => ({
          [_0x207fe4]: null
        }));
        this._proxyAssignSimple("state", toObj);
        const cls = this.getClass_({
          'propIxClass': propIxClass
        });
        const subcls = this.getSubclass_({
          'cls': cls,
          'propIxSubclass': propIxSubclass
        });
        /* const filteredFeatures = this._class_getFilteredFeatures(cls, subcls);
        if (this._compsClassLevelSelect[ix]) {
          this._compsClassLevelSelect[ix].setFeatures(filteredFeatures);
        }
        await this._class_pRenderFeatureOptionsSelects({
          'ix': ix,
          'propCntAsi': propCntAsi,
          'filteredFeatures': filteredFeatures,
          '$stgFeatureOptions': holder_featureOptions,
          'lockRenderFeatureOptionsSelects': _0x3217e0
        }); */
        if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.on(filter_evnt_valchange_subclass, () => applySubclassFilter());}
        /* applySubclassFilter();
        await this._class_renderClass_pDispSubclass({
          'ix': ix,
          '$dispSubclass': disp_subclass,
          'cls': cls,
          'sc': subcls
        }); */
      };
      const renderSubclass_safe = async () => {
        try {
          await this._pLock(lockChangeSubclass);
          await renderSubclass();
        } finally {
          this._unlock(lockChangeSubclass);
        }
      };

      this._addHookBase(propIxSubclass, renderSubclass_safe);

      //Create parent objects to hold subcomponents, hide the later ones
      const header = $("<div class=\"bold\">Select a Class</div>");
      const holder_selectSubclass = $(`<div class="ve-flex-col w-100"></div>`).hideVe();
      const holder_hpMode = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_hpInfo = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_startingProf = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_levelSelect = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_featureOptions = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_skills = $(`<div class="ve-flex-col"></div>`).hideVe();
      const holder_tools = $(`<div class="ve-flex-col"></div>`).hideVe();

      let primaryBtn = null;
      if (!this._existingClassMetas.length) {
        primaryBtn = $("<button class=\"btn btn-5et btn-xs mr-2\"></button>").click(() => this._state.class_ixPrimaryClass = ix);
        const primaryBtnHover = () => {
          primaryBtn.text(this._state.class_ixPrimaryClass === ix ? "Primary Class" : "Make Primary").title(this._state.class_ixPrimaryClass === ix ? "This is your primary class, i.e. the one you chose at level 1 for the purposes of proficiencies/etc." : "Make this your primary class, i.e. the one you chose at level 1 for the purposes of proficiencies/etc.").prop("disabled", this._state.class_ixPrimaryClass === ix);
        };
        this._addHookBase("class_ixPrimaryClass", primaryBtnHover);
        primaryBtnHover();
      }

      const minimizerToggle = $("<div class=\"py-1 clickable ve-muted\">[‒]</div>").click(() => {
        const isMinimized = minimizerToggle.text() === '[+]';
        minimizerToggle.text(isMinimized ? "[‒]" : "[+]");
        if (isMinimized) {
          header.text("Select a Class");
        } else {
          const cls = this.getClass_({'propIxClass': propIxClass});
          const subcls = this.getSubclass_({
            'cls': cls,
            'propIxSubclass': propIxSubclass
          });
          if (cls) { header.text('' + cls.name + (subcls ? " (" + subcls.name + ')' : ''));}
          else { header.text("Select a Class"); }
        }
        classChoicePanels.toggleVe();
      });
      
      const holder_dispClass = $(`<div class="ve-flex-col w-100"></div>`);
      const disp_subclass = $(`<div class="ve-flex-col w-100"></div>`);

      /* const classChoicePanels = $(`<div class="ve-flex-col w-100 mt-2">
              <div class="ve-flex btn-group w-100">
                  <div class="ve-flex no-shrink">
                      ${filterBtn[0].outerHTML}
                  </div>
                  <div class="ve-flex-col w-100">
                      ${wrapper[0].outerHTML}
                      ${holder_selectSubclass[0].outerHTML}
                  </div>
              </div>
              ${holder_hpMode[0].outerHTML}
              ${holder_hpInfo[0].outerHTML}
              ${holder_startingProf[0].outerHTML}
              ${holder_skills[0].outerHTML}
              ${holder_tools[0].outerHTML}
              ${holder_levelSelect[0].outerHTML}
              ${holder_featureOptions[0].outerHTML}
          </div>`); */
          const classChoicePanels = $$`<div class="ve-flex-col w-100 mt-2">
              <div class="ve-flex btn-group w-100">
                  <div class="ve-flex no-shrink">
                      ${filterBtn}
                  </div>
                  <div class="ve-flex-col w-100">
                        ${wrapper}
                        ${holder_selectSubclass}
                  </div>
              </div>
              ${holder_hpMode}
              ${holder_hpInfo}
          </div>`;

      /* const classChoicePanelsWrapper = $(`<div class="ve-flex-col">
          ${ix>0? `<hr class=\"hr-3 hr--heavy\">`:''}

          <div class="split-v-center">
              ${header}
              <div class="ve-flex-v-center">
                  ${primaryBtn}
                  ${minimizerToggle}
              </div>
          </div>

          ${classChoicePanels}
      </div>`); */
      const classChoicePanelsWrapper = $$`<div class="ve-flex-col">
        ${ix>0? `<hr class=\"hr-3 hr--heavy\">`:''}
        <div class="split-v-center">
            ${header}
            <div class="ve-flex-v-center">
                ${primaryBtn}
                ${minimizerToggle}
            </div>
        </div>

        ${classChoicePanels}
      </div>`;
      classChoicePanelsWrapper.appendTo(element1);

      //Sidebar display (class text info)
      const sidebarContent=$(`<div>
          ${ix>0?'<hr\x20class=\x22hr-2\x20hr--heavy\x22>':''}

          ${holder_dispClass}
          ${disp_subclass}
      </div>`).appendTo(element2);

      renderClass_safe().then(() => renderSubclass_safe());
    }
    _class_renderClass_stgSelectSubclass({
      $stgSelectSubclass: stgSelectSubclass,
      cls: cls,
      ix: ix,
      propIxSubclass: propIxSubclass,
      idFilterBoxChangeSubclass: idFilterBoxChangeSubclass,
      doApplyFilterToSelSubclass: doApplyFilterToSelSubclass
    }) {
      stgSelectSubclass.empty();
      if (this._metaHksClassStgSubclass[ix]) { this._metaHksClassStgSubclass[ix].unhook(); }
      if(cls == null){console.error("Class is null");}
      if (cls && cls.subclasses && cls.subclasses.length) {
        const uiSearchElement = ComponentUiUtil.$getSelSearchable(this, propIxSubclass, {
          'values': cls.subclasses.map((a, b) => b),
          'isAllowNull': true,
          'fnDisplay': ix => {
            const subcls = this.getSubclass_({'cls': cls, 'ix': ix });
            if (!subcls) {
              console.warn(...LGT, "Could not find subclass with index " + ix + " (" + cls.subclasses.length + " subclasses were available for class " + cls.name + ')');
              return '(Unknown)';
            }
            return subcls.name + " " + (subcls.source !== Parser.SRC_PHB ? '[' + Parser.sourceJsonToAbv(subcls.source) + ']' : '');
          },
          'fnGetAdditionalStyleClasses': ix => {
            if (ix == null) { return null; }
            const subcls = this.getSubclass_({'cls': cls, 'ix': ix });
            if (!subcls) { return; }
            return subcls._versionBase_isVersion ? ['italic'] : null;
          },
          'asMeta': true,
          'isDisabled': this._class_isSubclassSelectionDisabled({'ix': ix}),
          'displayNullAs': "Select a Subclass"
        });
        uiSearchElement.$iptDisplay.addClass('bl-0');
        uiSearchElement.$iptSearch.addClass("bl-0");
        this._metaHksClassStgSubclass[ix] = uiSearchElement;
        this._modalFilterClasses.pageFilter.filterBox.on(idFilterBoxChangeSubclass, () => doApplyFilterToSelSubclass());
        doApplyFilterToSelSubclass();
        const wrp = $$`<div class="ve-flex-col w-100 mt-1">${uiSearchElement.$wrp}</div>`;
        stgSelectSubclass.showVe().append(wrp);
      }
      else {
        console.error("No subclasses found");
        console.log(cls);
        stgSelectSubclass.hideVe();
        this._metaHksClassStgSubclass[ix] = null;
      }
    }
    _class_renderClass_stgHpMode({
      $stgHpMode: parentElement,
      ix: ix,
      cls: cls
    }) {
      parentElement.empty();
      if (cls && Charactermancer_Class_HpIncreaseModeSelect.isHpAvailable(cls)) {
        parentElement.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Hit Points Increase Mode</div>");
        this._compsClassHpIncreaseMode[ix] = new Charactermancer_Class_HpIncreaseModeSelect();
        this._compsClassHpIncreaseMode[ix].render(parentElement);
      }
      else {
        parentElement.hideVe();
        this._compsClassHpIncreaseMode[ix] = null;
      }
    }
    _class_renderClass_stgHpInfo({
      $stgHpInfo: parentElement,
      ix: ix,
      cls: cls
    }) {
      parentElement.empty();
      if (cls && Charactermancer_Class_HpIncreaseModeSelect.isHpAvailable(cls)) {
        parentElement.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Hit Points</div>");
        this._compsClassHpInfo[ix] = new Charactermancer_Class_HpInfo({
          'className': cls.name,
          'hitDice': cls.hd
        });
        this._compsClassHpInfo[ix].render(parentElement);
      }
      else {
        parentElement.hideVe();
        this._compsClassHpInfo[ix] = null;
      }
    }
    _class_renderClass_stgStartingProficiencies({
      $stgStartingProficiencies: _0x1b56f5,
      ix: _0x527fdb,
      cls: _0x1777c2
    }) {
      const _0x344de6 = this._class_getExistingClassMeta(_0x527fdb);
      if (_0x344de6) {
        return;
      }
      if (this._metaHksClassStgStartingProficiencies[_0x527fdb]) {
        this._metaHksClassStgStartingProficiencies[_0x527fdb].unhook();
      }
      _0x1b56f5.empty();
      //Our parent should be an ActorCharactermancer
      if(!SETTINGS.PARENTLESS_MODE){this._parent.featureSourceTracker_.unregister(this._compsClassStartingProficiencies[_0x527fdb]);}
      if (_0x1777c2 && (_0x1777c2.startingProficiencies || _0x1777c2.multiclassing?.["proficienciesGained"])) {
        _0x1b56f5.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Proficiencies</div>");
        this._compsClassStartingProficiencies[_0x527fdb] = Charactermancer_Class_StartingProficiencies.get({
          'featureSourceTracker': this._parent.featureSourceTracker_,
          'primaryProficiencies': _0x1777c2.startingProficiencies,
          'multiclassProficiencies': _0x1777c2.multiclassing?.["proficienciesGained"],
          'savingThrowsProficiencies': _0x1777c2.proficiency,
          'existingProficienciesFvttArmor': MiscUtil.get(this._actor, "_source", "system", "traits", "armorProf"),
          'existingProficienciesFvttWeapons': MiscUtil.get(this._actor, '_source', "system", "traits", "weaponProf"),
          'existingProficienciesFvttSavingThrows': Charactermancer_Class_StartingProficiencies.getExistingProficienciesFvttSavingThrows(this._actor)
        });
        this._compsClassStartingProficiencies[_0x527fdb].render(_0x1b56f5);
      } else {
        _0x1b56f5.hideVe();
        this._compsClassStartingProficiencies[_0x527fdb] = null;
      }
      const _0x2c34e2 = () => {
        if (this._compsClassStartingProficiencies[_0x527fdb]) {
          this._compsClassStartingProficiencies[_0x527fdb].mode = this._state.class_ixPrimaryClass === _0x527fdb ? Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY : Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS;
        }
      };
      this._addHookBase("class_ixPrimaryClass", _0x2c34e2);
      this._metaHksClassStgStartingProficiencies[_0x527fdb] = {
        'unhook': () => this._removeHookBase("class_ixPrimaryClass", _0x2c34e2)
      };
      _0x2c34e2();
    }
    _class_getExistingClassMeta(_0xbe660b) {
      if (this._existingClassMetas[_0xbe660b]) {
        return this._existingClassMetas[_0xbe660b];
      }
      const {
        propIxClass: _0x5b74cd
      } = ActorCharactermancerBaseComponent.class_getProps(_0xbe660b);
      const _0x1f931b = this.getClass_({
        'propIxClass': _0x5b74cd
      });
      const _0x11c553 = Charactermancer_Class_Util.getExistingClassItems(this._actor, _0x1f931b);
      const _0x5dcf2a = _0x11c553.length ? _0x11c553[0x0] : null;
      if (!_0x5dcf2a) {
        return null;
      }
      return {
        'item': _0x5dcf2a,
        'level': Number(_0x5dcf2a.system.levels || 0x0)
      };
    }
    async _class_renderClass_pStgLevelSelect({
      $stgLevelSelect: _0xfb7131,
      $stgFeatureOptions: _0x2cd62a,
      ix: _0x2974ee,
      cls: _0x3174e4,
      sc: _0x39dfb0,
      propIxSubclass: _0x157e74,
      propCurLevel: _0x507c12,
      propTargetLevel: _0x325b4f,
      propCntAsi: _0x36fa76,
      lockRenderFeatureOptionsSelects: _0x31ad95,
      idFilterBoxChangeClassLevels: _0x36f0ca
    }) {
      _0xfb7131.empty();
      if (_0x3174e4) {
        _0xfb7131.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">Select Levels</div>");
        const _0xab8fed = this._class_getFilteredFeatures(_0x3174e4, _0x39dfb0);
        const _0xa230b0 = this._class_getExistingClassMeta(_0x2974ee);
        this._compsClassLevelSelect[_0x2974ee] = new Charactermancer_Class_LevelSelect({
          'features': _0xab8fed,
          'isRadio': true,
          'isForceSelect': this.getExistingClassTotalLevels_() === 0x0 || !_0xa230b0,
          'maxPreviousLevel': _0xa230b0?.["level"],
          'isSubclass': true
        });
        this._compsClassLevelSelect[_0x2974ee].render(_0xfb7131);
        const _0x54b941 = async () => {
          const _0x30091c = this.getSubclass_({
            'cls': _0x3174e4,
            'propIxSubclass': _0x157e74
          });
          const _0x4869de = this._class_getFilteredFeatures(_0x3174e4, _0x30091c);
          await this._class_pRenderFeatureOptionsSelects({
            'ix': _0x2974ee,
            'propCntAsi': _0x36fa76,
            'filteredFeatures': _0x4869de,
            '$stgFeatureOptions': _0x2cd62a,
            'lockRenderFeatureOptionsSelects': _0x31ad95
          });
          this._state[_0x507c12] = this._compsClassLevelSelect[_0x2974ee].getCurLevel();
          this._state[_0x325b4f] = this._compsClassLevelSelect[_0x2974ee].getTargetLevel();
          this._state.class_totalLevels = this.class_getTotalLevels();
        };
        this._compsClassLevelSelect[_0x2974ee].onchange(_0x54b941);
        await _0x54b941();
        this._modalFilterClasses.pageFilter.filterBox.on(_0x36f0ca, () => {
          if (!this._compsClassLevelSelect[_0x2974ee]) {
            return;
          }
          const _0x5bc252 = this.getSubclass_({
            'cls': _0x3174e4,
            'propIxSubclass': _0x157e74
          });
          const _0x10299e = this._class_getFilteredFeatures(_0x3174e4, _0x5bc252);
          if (this._compsClassLevelSelect[_0x2974ee]) {
            this._compsClassLevelSelect[_0x2974ee].setFeatures(_0x10299e);
          }
          this._class_pRenderFeatureOptionsSelects({
            'ix': _0x2974ee,
            'propCntAsi': _0x36fa76,
            'filteredFeatures': _0x10299e,
            '$stgFeatureOptions': _0x2cd62a,
            'lockRenderFeatureOptionsSelects': _0x31ad95
          });
        });
      } else {
        _0xfb7131.hideVe();
        this._compsClassLevelSelect[_0x2974ee] = null;
        _0x2cd62a.empty().hideVe();
        this._class_unregisterFeatureSourceTrackingFeatureComps(_0x2974ee);
        this._state[_0x36fa76] = null;
        if(SETTINGS.FILTERS){this._modalFilterClasses.pageFilter.filterBox.off(_0x36f0ca);}
      }
    }
    /* _class_renderClass_stgSkills({
      $stgSkills: _0x18fe7d,
      ix: _0x138ef0,
      propIxClass: _0x2f063c
    }) {
      this._class_renderClass_stgSkillsTools({
        '$stg': _0x18fe7d,
        'ix': _0x138ef0,
        'propIxClass': _0x2f063c,
        'propMetaHks': "_metaHksClassStgSkills",
        'propCompsClass': '_compsClassSkillProficiencies',
        'propSystem': 'skills',
        'fnGetProfs': ({
          cls: _0x1dbeaa,
          isPrimaryClass: _0x155251
        }) => {
          if (!_0x1dbeaa) {
            return null;
          }
          return _0x155251 ? _0x1dbeaa.startingProficiencies?.["skills"] : _0x1dbeaa.multiclassing?.['proficienciesGained']?.["skills"];
        },
        'headerText': "Skill Proficiencies",
        'fnGetMapped': Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect)
      });
    }
    _class_renderClass_stgTools({
      $stgTools: _0x32cea1,
      ix: _0x40352a,
      propIxClass: _0x1e9a92
    }) {
      this._class_renderClass_stgSkillsTools({
        '$stg': _0x32cea1,
        'ix': _0x40352a,
        'propIxClass': _0x1e9a92,
        'propMetaHks': "_metaHksClassStgTools",
        'propCompsClass': '_compsClassToolProficiencies',
        'propSystem': "tools",
        'fnGetProfs': ({
          cls: _0x5ed998,
          isPrimaryClass: _0x1be964
        }) => {
          if (!_0x5ed998) {
            return null;
          }
          return _0x1be964 ? Charactermancer_Class_Util.getToolProficiencyData(_0x5ed998.startingProficiencies) : Charactermancer_Class_Util.getToolProficiencyData(_0x5ed998.multiclassing?.['proficienciesGained']);
        },
        'headerText': "Tool Proficiencies",
        'fnGetMapped': Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect)
      });
    } */
    _class_renderClass_stgSkillsTools({
      $stg: _0x469daf,
      ix: _0x3fe1d8,
      propIxClass: _0x15d389,
      propMetaHks: _0x343f18,
      propCompsClass: _0x122a08,
      propSystem: _0x4a9a60,
      fnGetProfs: _0x39bdbe,
      headerText: _0x17d1c9,
      fnGetMapped: _0x2664f3
    }) {
      const _0x1d6f33 = this._class_getExistingClassMeta(_0x3fe1d8);
      if (_0x1d6f33) {
        return;
      }
      if (this[_0x343f18][_0x3fe1d8]) {
        this[_0x343f18][_0x3fe1d8].unhook();
      }
      const _0x3f3f87 = () => {
        _0x469daf.empty();
        const _0x456745 = this.getClass_({
          'propIxClass': _0x15d389
        });
        const _0x405d40 = this._state.class_ixPrimaryClass === _0x3fe1d8;
        this._parent.featureSourceTracker_.unregister(this[_0x122a08][_0x3fe1d8]);
        const _0x52873c = _0x39bdbe({
          'cls': _0x456745,
          'isPrimaryClass': _0x405d40
        });
        if (_0x456745 && _0x52873c) {
          _0x469daf.showVe().append("<hr class=\"hr-2\"><div class=\"bold mb-2\">" + _0x17d1c9 + "</div>");
          const _0x16d7ec = {
            'skillProficiencies': MiscUtil.get(this._actor, "_source", "system", _0x4a9a60)
          };
          this[_0x122a08][_0x3fe1d8] = new Charactermancer_OtherProficiencySelect({
            'featureSourceTracker': this._parent.featureSourceTracker_,
            'existing': Charactermancer_OtherProficiencySelect.getExisting(_0x16d7ec),
            'existingFvtt': _0x16d7ec,
            'available': _0x2664f3(_0x52873c)
          });
          this[_0x122a08][_0x3fe1d8].render(_0x469daf);
        } else {
          _0x469daf.hideVe();
          this[_0x122a08][_0x3fe1d8] = null;
        }
      };
      this._addHookBase("class_ixPrimaryClass", _0x3f3f87);
      this[_0x343f18][_0x3fe1d8] = {
        'unhook': () => this._removeHookBase("class_ixPrimaryClass", _0x3f3f87)
      };
      _0x3f3f87();
    }
    async _class_renderClass_pDispClass({
      ix: _0x3c9e06,
      $dispClass: _0x1bf26,
      cls: _0x50e1af,
      sc: _0x1f1733
    }) {
      if (this._$wrpsClassTable[_0x3c9e06]) {
        this._$wrpsClassTable[_0x3c9e06].detach();
      } else {
        this._$wrpsClassTable[_0x3c9e06] = $("<div class=\"ve-flex-col w-100\"></div>");
      }
      _0x1bf26.empty();
      if (_0x50e1af) {
        const _0x184e57 = _0x50e1af._isStub ? _0x50e1af : await DataLoader.pCacheAndGet("class", _0x50e1af.source, UrlUtil.URL_TO_HASH_BUILDER["class"](_0x50e1af));
        let _0x5c41fe = MiscUtil.copy(_0x184e57.classFeatures || []).flat();
        _0x5c41fe = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x5c41fe, this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
        const _0x50ec18 = {
          'type': "section",
          'entries': _0x5c41fe
        };
        this._class_renderEntriesSection(_0x1bf26, _0x50e1af.name, _0x50ec18, {
          '$wrpTable': this._$wrpsClassTable[_0x3c9e06]
        });
        await this._class_renderClass_pClassTable({
          'ix': _0x3c9e06,
          'cls': _0x50e1af,
          'sc': _0x1f1733
        });
      }
    }
    async _class_renderClass_pDispSubclass({
      ix: _0xd8d788,
      $dispSubclass: _0x189ba0,
      cls: _0x3f21f6,
      sc: _0x5dd639
    }) {
      _0x189ba0.empty();
      if (_0x5dd639) {
        _0x189ba0.append("<hr class=\"hr-1\">");
        const _0x19c6a9 = _0x5dd639._isStub ? _0x5dd639 : await DataLoader.pCacheAndGet("subclass", _0x5dd639.source, UrlUtil.URL_TO_HASH_BUILDER.subclass(_0x5dd639));
        let _0x4cd88b = MiscUtil.copy(_0x19c6a9.subclassFeatures).flat();
        _0x4cd88b = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x4cd88b, this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
        const _0x92cb5c = {
          'type': "section",
          'entries': _0x4cd88b
        };
        if (_0x92cb5c.entries[0x0] && _0x92cb5c.entries[0x0].name) {
          delete _0x92cb5c.entries[0x0].name;
        }
        this._class_renderEntriesSection(_0x189ba0, _0x5dd639.name, _0x92cb5c);
      }
      await this._class_renderClass_pClassTable({
        'ix': _0xd8d788,
        'cls': _0x3f21f6,
        'sc': _0x5dd639
      });
    }
    async _class_renderClass_pClassTable({
      ix: _0x29a0a3,
      cls: _0xed637d,
      sc: _0x386619
    }) {
      const _0x57a945 = _0xed637d ? _0xed637d._isStub ? _0xed637d : await DataLoader.pCacheAndGet('class', _0xed637d.source, UrlUtil.URL_TO_HASH_BUILDER["class"](_0xed637d)) : null;
      const _0x4d6b47 = _0x386619 ? _0x386619._isStub ? _0x386619 : await DataLoader.pCacheAndGet("subclass", _0x386619.source, UrlUtil.URL_TO_HASH_BUILDER.subclass(_0x386619)) : null;
      const _0x2da178 = _0x57a945?.["classFeatures"] || _0x4d6b47?.["subclassFeatures"] ? this._modalFilterClasses.pageFilter.filterBox.getValues() : null;
      if (_0x57a945?.["classFeatures"]) {
        _0x57a945.classFeatures = _0x57a945.classFeatures.map(_0x2106c1 => {
          _0x2106c1 = MiscUtil.copy(_0x2106c1);
          _0x2106c1 = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x2106c1, this._modalFilterClasses.pageFilter, _0x2da178);
          return _0x2106c1;
        });
      }
      if (_0x4d6b47?.["subclassFeatures"]) {
        _0x4d6b47.subclassFeatures = _0x4d6b47.subclassFeatures.map(_0x3cb3f1 => {
          _0x3cb3f1 = MiscUtil.copy(_0x3cb3f1);
          _0x3cb3f1 = Charactermancer_Class_Util.getFilteredEntries_bySource(_0x3cb3f1, this._modalFilterClasses.pageFilter, _0x2da178);
          return _0x3cb3f1;
        });
      }
      const _0x5e497c = DataConverterClass.getRenderedClassTableFromDereferenced(_0x57a945, _0x4d6b47);
      this._$wrpsClassTable[_0x29a0a3].html('').fastSetHtml(_0x5e497c);
    }
    _class_getFilteredFeatures(_0x547c47, _0x29fb5c) {
      if (!_0x547c47) {
        return [];
      }
      _0x547c47 = MiscUtil.copy(_0x547c47);
      _0x547c47.subclasses = [_0x29fb5c].filter(Boolean);
      return Charactermancer_Util.getFilteredFeatures(Charactermancer_Class_Util.getAllFeatures(_0x547c47), this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
    }
    async _class_pRenderFeatureOptionsSelects(_0xd3c29b) {
      const {
        lockRenderFeatureOptionsSelects: _0x105085
      } = _0xd3c29b;
      try {
        await this._pLock(_0x105085);
        return this._class_pRenderFeatureOptionsSelects_(_0xd3c29b);
      } finally {
        this._unlock(_0x105085);
      }
    }
    async _class_pRenderFeatureOptionsSelects_({
      ix: ix,
      propCntAsi: propCntAsi,
      filteredFeatures: filteredFeatures,
      $stgFeatureOptions: stgFeatureOptions
    }) {
      const selElement = this._compsClassFeatureOptionsSelect[ix] || [];
      selElement.forEach(e => this._parent.featureSourceTracker_.unregister(e));
      stgFeatureOptions.empty();
      const existingFeatureChecker = this._existingClassMetas[ix] ? new Charactermancer_Class_Util.ExistingFeatureChecker(this._actor) : null;
      const importableFeatures = Charactermancer_Util.getImportableFeatures(filteredFeatures);
      const features = MiscUtil.copy(importableFeatures);
      Charactermancer_Util.doApplyFilterToFeatureEntries_bySource(features, this._modalFilterClasses.pageFilter, this._modalFilterClasses.pageFilter.filterBox.getValues());
      const groupedByOptionsSet = Charactermancer_Util.getFeaturesGroupedByOptionsSet(features);
      const {
        lvlMin: lvlMin,
        lvlMax: lvlMax
      } = await this._class_pGetMinMaxLevel(ix);
      this._class_unregisterFeatureSourceTrackingFeatureComps(ix);
      let asiCount = 0;
      for (const grpA of groupedByOptionsSet) {
        const {
          topLevelFeature: topLevelFeature,
          optionsSets: optionsSets
        } = _0x54d088;
        if (topLevelFeature.level < lvlMin || topLevelFeature.level > lvlMax) {
          continue;
        }
        const featureName = topLevelFeature.name.toLowerCase();
        if (featureName === "ability score improvement") {
          asiCount++;
          continue;
        }
        for (const set of optionsSets) {
          const component = new Charactermancer_FeatureOptionsSelect({
            'featureSourceTracker': this._parent.featureSourceTracker_,
            'existingFeatureChecker': existingFeatureChecker,
            'actor': this._actor,
            'optionsSet': set,
            'level': topLevelFeature.level,
            'modalFilterSpells': this._parent.compSpell.modalFilterSpells
          });
          this._compsClassFeatureOptionsSelect[ix].push(component);
          component.findAndCopyStateFrom(selElement);
        }
      }
      this._state[propCntAsi] = asiCount;
      await this._class_pRenderFeatureComps(ix, {
        '$stgFeatureOptions': stgFeatureOptions
      });
    }
    ["_class_unregisterFeatureSourceTrackingFeatureComps"](_0x3f9ba9) {
      (this._compsClassFeatureOptionsSelect[_0x3f9ba9] || []).forEach(_0x2edadc => _0x2edadc.unregisterFeatureSourceTracking());
      this._compsClassFeatureOptionsSelect[_0x3f9ba9] = [];
    }
    async ["_class_pGetMinMaxLevel"](_0x356dbb) {
      let _0x3d959d = 0x0;
      let _0x1005e8 = 0x0;
      if (this._compsClassLevelSelect[_0x356dbb]) {
        const _0xbda027 = await this._compsClassLevelSelect[_0x356dbb].pGetFormData().data;
        _0x3d959d = Math.min(..._0xbda027) + 0x1;
        _0x1005e8 = Math.max(..._0xbda027) + 0x1;
      }
      return {
        'lvlMin': _0x3d959d,
        'lvlMax': _0x1005e8
      };
    }
    async ["_class_pRenderFeatureComps"](_0x3f9795, {
      $stgFeatureOptions: _0x3179cf
    }) {
      for (const _0x5b3543 of this._compsClassFeatureOptionsSelect[_0x3f9795]) {
        if ((await _0x5b3543.pIsNoChoice()) && !(await _0x5b3543.pIsAvailable())) {
          continue;
        }
        if (!(await _0x5b3543.pIsNoChoice()) || (await _0x5b3543.pIsForceDisplay())) {
          _0x3179cf.showVe().append('' + (_0x5b3543.modalTitle ? "<hr class=\"hr-2\"><div class=\"mb-2 bold w-100\">" + _0x5b3543.modalTitle + "</div>" : ''));
        }
        _0x5b3543.render(_0x3179cf);
      }
    }
    ["_class_renderEntriesSection"](_0x3413d5, _0x582d2d, _0x1aea64, {
      $wrpTable = null
    } = {}) {
      const _0x4c8fa0 = $("<div class=\"py-1 pl-2 clickable ve-muted\">[‒]</div>").click(() => {
        _0x4c8fa0.text(_0x4c8fa0.text() === '[+]' ? '[‒]' : "[+]");
        if ($wrpTable) {
          $wrpTable.toggleVe();
        }
        _0x3fe7d2.toggleVe();
      });
      const _0x3fe7d2 = Renderer.hover.$getHoverContent_generic(_0x1aea64);
      $`<div class="ve-flex-col">
              <div class="split-v-center">
                  <div class="rd__h rd__h--0"><div class="entry-title-inner">${(_0x582d2d || '').qq()}</div></div>
                  ${_0x4c8fa0}
              </div>
              ${$wrpTable}
              ${_0x3fe7d2}
          </div>`.appendTo(_0x3413d5);
    }
    ['class_getPrimaryClass']() {
      if (!~this._state.class_ixPrimaryClass) {
        return null;
      }
      const {
        propIxClass: _0x42dfba
      } = ActorCharactermancerBaseComponent.class_getProps(this._state.class_ixPrimaryClass);
      return this._data["class"][this._state[_0x42dfba]];
    }
    ["class_getTotalLevels"]() {
      return this._compsClassLevelSelect.filter(Boolean).map(_0x169930 => _0x169930.getTargetLevel() || _0x169930.getCurLevel()).reduce((_0x130249, _0x125134) => _0x130249 + _0x125134, 0x0);
    }
    ["class_getMinMaxSpellLevel"]() {
      const _0x35ebcb = [];
      const _0x5ba174 = [];
      let _0x8a1dd5 = false;
      for (let _0xa4aa35 = 0x0; _0xa4aa35 < this._state.class_ixMax + 0x1; ++_0xa4aa35) {
        const {
          propIxClass: _0x27f359,
          propIxSubclass: _0x215bda,
          propCurLevel: _0x496498,
          propTargetLevel: _0x4c7a29
        } = ActorCharactermancerBaseComponent.class_getProps(_0xa4aa35);
        const _0x2bea38 = this.getClass_({
          'propIxClass': _0x27f359
        });
        if (!_0x2bea38) {
          continue;
        }
        const _0x6aec7a = this.getSubclass_({
          'cls': _0x2bea38,
          'propIxSubclass': _0x215bda
        });
        const _0x19e990 = this._state[_0x496498];
        const _0x275d07 = this._state[_0x4c7a29];
        const _0x547cd0 = DataConverter.getMaxCasterProgression(_0x2bea38.casterProgression, _0x6aec7a?.["casterProgression"]);
        const _0x52dd93 = Charactermancer_Spell_Util.getCasterProgressionMeta({
          'casterProgression': _0x547cd0,
          'curLevel': _0x19e990,
          'targetLevel': _0x275d07,
          'isBreakpointsOnly': true
        })?.["spellLevelLow"];
        if (_0x52dd93 != null) {
          _0x35ebcb.push(_0x52dd93);
        }
        const _0x38d005 = Charactermancer_Spell_Util.getCasterProgressionMeta({
          'casterProgression': _0x547cd0,
          'curLevel': _0x19e990,
          'targetLevel': _0x275d07,
          'isBreakpointsOnly': true
        })?.["spellLevelHigh"];
        if (_0x38d005 != null) {
          _0x5ba174.push(_0x38d005);
        }
        _0x8a1dd5 = _0x8a1dd5 || Charactermancer_Spell_Util.getMaxLearnedCantrips({
          'cls': _0x2bea38,
          'sc': _0x6aec7a,
          'targetLevel': _0x275d07
        }) != null;
      }
      return {
        'min': _0x35ebcb.length ? Math.min(..._0x35ebcb) : null,
        'max': _0x5ba174.length ? Math.max(..._0x5ba174) : null,
        'isAnyCantrips': _0x8a1dd5
      };
    }
    /**Defines the starting default values of our _state proxy  */
    _getDefaultState() {
      return {
        'class_ixPrimaryClass': 0,
        'class_ixMax': 0,
        'class_totalLevels': 0,
        'class_pulseChange': false
      };
    }
}
class Charactermancer_Class_HpIncreaseModeSelect extends BaseComponent {
    static async pGetUserInput() {
        if (this.isNoChoice()) {
            const comp = new this();
            return comp.pGetFormData();
        }

        return UtilApplications.pGetImportCompApplicationFormData({
            comp: new this(),
            width: 480,
            height: 150,
        });
    }

    static isHpAvailable(cls) {
        return cls.hd && cls.hd.number && !isNaN(cls.hd.number) && cls.hd.faces && !isNaN(cls.hd.faces);
    }

    static isNoChoice() {
        if (game.user.isGM)
            return false;

        if (Config.get("importClass", "hpIncreaseMode") === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM && Config.get("importClass", "hpIncreaseModeCustomRollFormula") == null)
            return false;

        return Config.get("importClass", "hpIncreaseMode") != null;
    }

    pGetFormData() {
        return {
            isFormComplete: true,
            data: {
                mode: this._state.mode,
                customFormula: this._state.customFormula,
            },
        };
    }

    get modalTitle() {
        return `Select Hit Points Increase Mode`;
    }

    render($wrp) {
        const $sel = ComponentUiUtil.$getSelEnum(this, "mode", {
            values: [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM, ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE, ],
            fnDisplay: mode=>ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[mode],
        }, );

        /* if (!game.user.isGM && Config.get("importClass", "hpIncreaseMode") != null)
            $sel.disable(); */

        const $iptCustom = ComponentUiUtil.$getIptStr(this, "customFormula").addClass("code");

        /* if (!game.user.isGM && Config.get("importClass", "hpIncreaseModeCustomRollFormula") != null)
            $iptCustom.disable(); */

        const $stgCustom = $$`<div class="mt-2 ve-flex-v-center">
			<div class="inline-block bold mr-1 no-wrap">Custom Formula:</div>
			${$iptCustom}
		</div>`;
        const hkMode = ()=>{
            $stgCustom.toggleVe(this._state.mode === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM);
        }
        ;
        this._addHookBase("mode", hkMode);
        hkMode();

        $$`<div class="ve-flex-col min-h-0">
			${$sel}
			${$stgCustom}
		</div>`.appendTo($wrp);
    }

    _getDefaultState() {
        return {
            mode: Config.get("importClass", "hpIncreaseMode") ?? ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE,
            customFormula: Config.get("importClass", "hpIncreaseModeCustomRollFormula") ?? "(2 * @hd.number)d(@hd.faces / 2)",
        };
    }
}
class Charactermancer_Class_HpInfo extends BaseComponent {
    constructor({className, hitDice}) {
        super();
        this._className = className;
        this._hitDice = hitDice;
    }

    render($wrp) {
        const hdEntry = Renderer.class.getHitDiceEntry(this._hitDice);


        const we = $$`<div class="ve-flex-col min-h-0 ve-small">
			<div class="block"><div class="inline-block bold mr-1">Hit Dice:</div>${Vetools.withUnpatchedDiceRendering(()=>
                Renderer.getEntryDice(hdEntry, "Hit die"))}</div>
			<div class="block"><div class="inline-block bold mr-1">Hit Points:</div>${Renderer.class.getHitPointsAtFirstLevel(this._hitDice)}</div>
			<div class="block"><div class="inline-block bold mr-1">Hit Points at Higher Levels:</div>${Vetools.withUnpatchedDiceRendering(()=>Renderer.class.getHitPointsAtHigherLevels(this._className, this._hitDice, hdEntry))}</div>
		</div>`;
        we.appendTo($wrp);
    }
}

class ProxyBase extends MixedProxyBase{

}



//#region ElementUtil
jQuery.fn.disableSpellcheck = function(){
    return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");
}
jQuery.fn.hideVe = function() {
    this.classList.add("ve-hidden");
    return this;
}
globalThis.ElementUtil = {
    _ATTRS_NO_FALSY: new Set(["checked", "disabled", ]),

    getOrModify({tag, clazz, style, click, contextmenu, change, mousedown, mouseup, mousemove, pointerdown, pointerup, keydown, html, text, txt, ele, children, outer,
    id, name, title, val, href, type, tabindex, value, placeholder, attrs, data, }) {
        ele = ele || (outer ? (new DOMParser()).parseFromString(outer, "text/html").body.childNodes[0] : document.createElement(tag));

        if (clazz)
            ele.className = clazz;
        if (style)
            ele.setAttribute("style", style);
        if (click)
            ele.addEventListener("click", click);
        if (contextmenu)
            ele.addEventListener("contextmenu", contextmenu);
        if (change)
            ele.addEventListener("change", change);
        if (mousedown)
            ele.addEventListener("mousedown", mousedown);
        if (mouseup)
            ele.addEventListener("mouseup", mouseup);
        if (mousemove)
            ele.addEventListener("mousemove", mousemove);
        if (pointerdown)
            ele.addEventListener("pointerdown", pointerdown);
        if (pointerup)
            ele.addEventListener("pointerup", pointerup);
        if (keydown)
            ele.addEventListener("keydown", keydown);
        if (html != null)
            ele.innerHTML = html;
        if (text != null || txt != null)
            ele.textContent = text;
        if (id != null)
            ele.setAttribute("id", id);
        if (name != null)
            ele.setAttribute("name", name);
        if (title != null)
            ele.setAttribute("title", title);
        if (href != null)
            ele.setAttribute("href", href);
        if (val != null)
            ele.setAttribute("value", val);
        if (type != null)
            ele.setAttribute("type", type);
        if (tabindex != null)
            ele.setAttribute("tabindex", tabindex);
        if (value != null)
            ele.setAttribute("value", value);
        if (placeholder != null)
            ele.setAttribute("placeholder", placeholder);

        if (attrs != null) {
            for (const k in attrs) {
                if (attrs[k] === undefined)
                    continue;
                if (!attrs[k] && ElementUtil._ATTRS_NO_FALSY.has(k))
                    continue;
                ele.setAttribute(k, attrs[k]);
            }
        }

        if (data != null) {
            for (const k in data) {
                if (data[k] === undefined)
                    continue;
                ele.dataset[k] = data[k];
            }
        }

        if (children)
            for (let i = 0, len = children.length; i < len; ++i)
                if (children[i] != null)
                    ele.append(children[i]);

        ele.appends = ele.appends || ElementUtil._appends.bind(ele);
        ele.appendTo = ele.appendTo || ElementUtil._appendTo.bind(ele);
        ele.prependTo = ele.prependTo || ElementUtil._prependTo.bind(ele);
        ele.insertAfter = ele.insertAfter || ElementUtil._insertAfter.bind(ele);
        ele.addClass = ele.addClass || ElementUtil._addClass.bind(ele);
        ele.removeClass = ele.removeClass || ElementUtil._removeClass.bind(ele);
        ele.toggleClass = ele.toggleClass || ElementUtil._toggleClass.bind(ele);
        ele.showVe = ele.showVe || ElementUtil._showVe.bind(ele);
        ele.hideVe = ele.hideVe || ElementUtil._hideVe.bind(ele);
        ele.toggleVe = ele.toggleVe || ElementUtil._toggleVe.bind(ele);
        ele.empty = ele.empty || ElementUtil._empty.bind(ele);
        ele.detach = ele.detach || ElementUtil._detach.bind(ele);
        ele.attr = ele.attr || ElementUtil._attr.bind(ele);
        ele.val = ele.val || ElementUtil._val.bind(ele);
        ele.html = ele.html || ElementUtil._html.bind(ele);
        ele.txt = ele.txt || ElementUtil._txt.bind(ele);
        ele.tooltip = ele.tooltip || ElementUtil._tooltip.bind(ele);
        ele.disableSpellcheck = ele.disableSpellcheck || ElementUtil._disableSpellcheck.bind(ele);
        ele.on = ele.on || ElementUtil._onX.bind(ele);
        ele.onClick = ele.onClick || ElementUtil._onX.bind(ele, "click");
        ele.onContextmenu = ele.onContextmenu || ElementUtil._onX.bind(ele, "contextmenu");
        ele.onChange = ele.onChange || ElementUtil._onX.bind(ele, "change");
        ele.onKeydown = ele.onKeydown || ElementUtil._onX.bind(ele, "keydown");
        ele.onKeyup = ele.onKeyup || ElementUtil._onX.bind(ele, "keyup");

        return ele;
    },

    _appends(child) {
        this.appendChild(child);
        return this;
    },

    _appendTo(parent) {
        parent.appendChild(this);
        return this;
    },

    _prependTo(parent) {
        parent.prepend(this);
        return this;
    },

    _insertAfter(parent) {
        parent.after(this);
        return this;
    },

    _addClass(clazz) {
        this.classList.add(clazz);
        return this;
    },

    _removeClass(clazz) {
        this.classList.remove(clazz);
        return this;
    },

    _toggleClass(clazz, isActive) {
        if (isActive == null)
            this.classList.toggle(clazz);
        else if (isActive)
            this.classList.add(clazz);
        else
            this.classList.remove(clazz);
        return this;
    },

    _showVe() {
        this.classList.remove("ve-hidden");
        return this;
    },

    _hideVe() {
        this.classList.add("ve-hidden");
        return this;
    },

    _toggleVe(isActive) {
        this.toggleClass("ve-hidden", isActive == null ? isActive : !isActive);
        return this;
    },

    _empty() {
        this.innerHTML = "";
        return this;
    },

    _detach() {
        if (this.parentElement)
            this.parentElement.removeChild(this);
        return this;
    },

    _attr(name, value) {
        this.setAttribute(name, value);
        return this;
    },

    _html(html) {
        if (html === undefined)
            return this.innerHTML;
        this.innerHTML = html;
        return this;
    },

    _txt(txt) {
        if (txt === undefined)
            return this.innerText;
        this.innerText = txt;
        return this;
    },

    _tooltip(title) {
        return this.attr("title", title);
    },

    _disableSpellcheck() {
        return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");
    },

    _onX(evtName, fn) {
        this.addEventListener(evtName, fn);
        return this;
    },

    _val(val) {
        if (val !== undefined) {
            switch (this.tagName) {
            case "SELECT":
                {
                    let selectedIndexNxt = -1;
                    for (let i = 0, len = this.options.length; i < len; ++i) {
                        if (this.options[i]?.value === val) {
                            selectedIndexNxt = i;
                            break;
                        }
                    }
                    this.selectedIndex = selectedIndexNxt;
                    return this;
                }

            default:
                {
                    this.value = val;
                    return this;
                }
            }
        }

        switch (this.tagName) {
        case "SELECT":
            return this.options[this.selectedIndex]?.value;

        default:
            return this.value;
        }
    },

    getIndexPathToParent(parent, child) {
        if (!parent.contains(child))
            return null;
        const path = [];

        while (child !== parent) {
            if (!child.parentElement)
                return null;
            const ix = [...child.parentElement.children].indexOf(child);
            if (!~ix)
                return null;
            path.push(ix);

            child = child.parentElement;
        }

        return path.reverse();
    },

    getChildByIndexPath(parent, indexPath) {
        for (let i = 0; i < indexPath.length; ++i) {
            const ix = indexPath[i];
            parent = parent.children[ix];
            if (!parent)
                return null;
        }
        return parent;
    },
};
if (typeof window !== "undefined"){window.e_ = ElementUtil.getOrModify;}
//#endregion

//#region CollectionUtil
globalThis.CollectionUtil = {
    ObjectSet: class ObjectSet {
        constructor() {
            this.map = new Map();
            this[Symbol.iterator] = this.values;
        }
        add(item) {
            this.map.set(item._toIdString(), item);
        }

        values() {
            return this.map.values();
        }
    }
    ,

    setEq(a, b) {
        if (a.size !== b.size)
            return false;
        for (const it of a)
            if (!b.has(it))
                return false;
        return true;
    },

    setDiff(set1, set2) {
        return new Set([...set1].filter(it=>!set2.has(it)));
    },

    objectDiff(obj1, obj2) {
        const out = {};

        [...new Set([...Object.keys(obj1), ...Object.keys(obj2)])].forEach(k=>{
            const diff = CollectionUtil._objectDiff_recurse(obj1[k], obj2[k]);
            if (diff !== undefined)
                out[k] = diff;
        }
        );

        return out;
    },

    _objectDiff_recurse(a, b) {
        if (CollectionUtil.deepEquals(a, b))
            return undefined;

        if (a && b && typeof a === "object" && typeof b === "object") {
            return CollectionUtil.objectDiff(a, b);
        }

        return b;
    },

    objectIntersect(obj1, obj2) {
        const out = {};

        [...new Set([...Object.keys(obj1), ...Object.keys(obj2)])].forEach(k=>{
            const diff = CollectionUtil._objectIntersect_recurse(obj1[k], obj2[k]);
            if (diff !== undefined)
                out[k] = diff;
        }
        );

        return out;
    },

    _objectIntersect_recurse(a, b) {
        if (CollectionUtil.deepEquals(a, b))
            return a;

        if (a && b && typeof a === "object" && typeof b === "object") {
            return CollectionUtil.objectIntersect(a, b);
        }

        return undefined;
    },

    deepEquals(a, b) {
        if (Object.is(a, b))
            return true;
        if (a && b && typeof a === "object" && typeof b === "object") {
            if (CollectionUtil._eq_isPlainObject(a) && CollectionUtil._eq_isPlainObject(b))
                return CollectionUtil._eq_areObjectsEqual(a, b);
            const isArrayA = Array.isArray(a);
            const isArrayB = Array.isArray(b);
            if (isArrayA || isArrayB)
                return isArrayA === isArrayB && CollectionUtil._eq_areArraysEqual(a, b);
            const isSetA = a instanceof Set;
            const isSetB = b instanceof Set;
            if (isSetA || isSetB)
                return isSetA === isSetB && CollectionUtil.setEq(a, b);
            return CollectionUtil._eq_areObjectsEqual(a, b);
        }
        return false;
    },

    _eq_isPlainObject: (value)=>value.constructor === Object || value.constructor == null,
    _eq_areObjectsEqual(a, b) {
        const keysA = Object.keys(a);
        const {length} = keysA;
        if (Object.keys(b).length !== length)
            return false;
        for (let i = 0; i < length; i++) {
            if (!b.hasOwnProperty(keysA[i]))
                return false;
            if (!CollectionUtil.deepEquals(a[keysA[i]], b[keysA[i]]))
                return false;
        }
        return true;
    },
    _eq_areArraysEqual(a, b) {
        const {length} = a;
        if (b.length !== length)
            return false;
        for (let i = 0; i < length; i++)
            if (!CollectionUtil.deepEquals(a[i], b[i]))
                return false;
        return true;
    },

    dfs(obj, opts) {
        const {prop=null, fnMatch=null} = opts;
        if (!prop && !fnMatch)
            throw new Error(`One of "prop" or "fnMatch" must be specified!`);

        if (obj instanceof Array) {
            for (const child of obj) {
                const n = CollectionUtil.dfs(child, opts);
                if (n)
                    return n;
            }
            return;
        }

        if (obj instanceof Object) {
            if (prop && obj[prop])
                return obj[prop];
            if (fnMatch && fnMatch(obj))
                return obj;

            for (const child of Object.values(obj)) {
                const n = CollectionUtil.dfs(child, opts);
                if (n)
                    return n;
            }
        }
    },

    bfs(obj, opts) {
        const {prop=null, fnMatch=null} = opts;
        if (!prop && !fnMatch)
            throw new Error(`One of "prop" or "fnMatch" must be specified!`);

        if (obj instanceof Array) {
            for (const child of obj) {
                if (!(child instanceof Array) && child instanceof Object) {
                    if (prop && child[prop])
                        return child[prop];
                    if (fnMatch && fnMatch(child))
                        return child;
                }
            }

            for (const child of obj) {
                const n = CollectionUtil.bfs(child, opts);
                if (n)
                    return n;
            }

            return;
        }

        if (obj instanceof Object) {
            if (prop && obj[prop])
                return obj[prop];
            if (fnMatch && fnMatch(obj))
                return obj;

            return CollectionUtil.bfs(Object.values(obj));
        }
    },
};
//#endregion

//#region Charactermancer
class Charactermancer_Class_Util {
    static getAllFeatures(cls) {
        let allFeatures = [];
        const seenSubclassFeatureHashes = new Set();

        const gainSubclassFeatureLevels = cls.classFeatures.filter(it=>it.gainSubclassFeature).map(cf=>cf.level ?? DataUtil.class.unpackUidClassFeature(cf.classFeature || cf).level);

        cls.classFeatures.forEach(cf=>{
            allFeatures.push(cf);

            const cfLevel = cf.level ?? DataUtil.class.unpackUidClassFeature(cf.classFeature || cf).level;
            const nxtCfLevel = gainSubclassFeatureLevels.includes(cfLevel) ? gainSubclassFeatureLevels[gainSubclassFeatureLevels.indexOf(cfLevel) + 1] : null;

            cls.subclasses.forEach(sc=>{
                sc.subclassFeatures.filter(scf=>{
                    const scfHash = scf.hash ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).hash;
                    const scfLevel = scf.level ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).level;

                    if (seenSubclassFeatureHashes.has(scfHash))
                        return false;

                    if (scf.isGainAtNextFeatureLevel) {
                        if (!cf.gainSubclassFeature)
                            return false;

                        if (cfLevel === gainSubclassFeatureLevels[0] && scfLevel <= cfLevel)
                            return true;

                        if (scfLevel <= cfLevel && (nxtCfLevel == null || scfLevel < nxtCfLevel))
                            return true;

                        return false;
                    }

                    return scfLevel === cfLevel;
                }
                ).forEach(scf=>{
                    const scfHash = scf.hash ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).hash;
                    seenSubclassFeatureHashes.add(scfHash);

                    scf.level = cfLevel;

                    allFeatures.push(scf);
                }
                );
            }
            );
        }
        );

        return MiscUtil.copy(allFeatures);
    }

    static isClassEntryFilterMatch(entry, pageFilter, filterValues) {
        const source = entry.source;
        const options = entry.isClassFeatureVariant ? {
            isClassFeatureVariant: true
        } : null;

        if (pageFilter.filterBox) {
            return pageFilter.filterBox.toDisplayByFilters(filterValues, ...[{
                filter: pageFilter.sourceFilter,
                value: source,
            }, pageFilter.optionsFilter ? {
                filter: pageFilter.optionsFilter,
                value: options,
            } : null, ].filter(Boolean), );
        }

        return pageFilter.sourceFilter.toDisplay(filterValues, source) && (!pageFilter.optionsFilter || pageFilter.optionsFilter.toDisplay(filterValues, options));
    }

    static getFilteredEntries_bySource(entries, pageFilter, filterValues) {
        const isDisplayableEntry = ({entry, filterValues, pageFilter})=>{
            if (!entry.source)
                return true;

            return this.isClassEntryFilterMatch(entry, pageFilter, filterValues);
        }
        ;

        return this._getFilteredEntries({
            entries,
            pageFilter,
            filterValues,
            fnIsDisplayableEntry: isDisplayableEntry,
        }, );
    }

    static _getFilteredEntries({entries, pageFilter, filterValues, fnIsDisplayableEntry, }, ) {
        const recursiveFilter = (entry)=>{
            if (entry == null)
                return entry;
            if (typeof entry !== "object")
                return entry;

            if (entry instanceof Array) {
                entry = entry.filter(it=>fnIsDisplayableEntry({
                    entry: it,
                    pageFilter,
                    filterValues,
                }));

                return entry.map(it=>recursiveFilter(it));
            }

            Object.keys(entry).forEach(k=>{
                if (entry[k]instanceof Array) {
                    entry[k] = recursiveFilter(entry[k]);
                    if (!entry[k].length)
                        delete entry[k];
                } else
                    entry[k] = recursiveFilter(entry[k]);
            }
            );
            return entry;
        }
        ;

        entries = MiscUtil.copy(entries);
        return recursiveFilter(entries);
    }

    static async pGetPreparableSpells(spells, cls, spellLevelLow, spellLevelHigh) {
        Renderer.spell.populatePrereleaseLookup(await PrereleaseUtil.pGetBrewProcessed(), {
            isForce: true
        });
        Renderer.spell.populateBrewLookup(await BrewUtil2.pGetBrewProcessed(), {
            isForce: true
        });

        return spells.filter(it=>{
            if (!(it.level > 0 && it.level >= spellLevelLow && it.level <= spellLevelHigh))
                return false;

            Renderer.spell.uninitBrewSources(it);
            Renderer.spell.initBrewSources(it);

            const fromClassList = Renderer.spell.getCombinedClasses(it, "fromClassList");
            return fromClassList.some(c=>(c.name || "").toLowerCase() === cls.name.toLowerCase() && (c.source || Parser.SRC_PHB).toLowerCase() === cls.source.toLowerCase());
        }
        );
    }

    static getCasterProgression(cls, sc, {targetLevel, otherExistingClassItems=null, otherExistingSubclassItems=null}) {
        otherExistingClassItems = otherExistingClassItems || [];
        otherExistingSubclassItems = otherExistingSubclassItems || [];

        const isSpellcastingMulticlass = [...otherExistingClassItems.filter(it=>it.system?.spellcasting && it.system?.spellcasting !== "none"), ...otherExistingSubclassItems.filter(it=>it.system?.spellcasting && it.system?.spellcasting !== "none"), cls.casterProgression != null || sc?.casterProgression != null, ].filter(Boolean).length > 1;

        let {totalSpellcastingLevels, casterClassCount, maxPactCasterLevel, } = UtilActors.getActorSpellcastingInfo({
            sheetItems: [...otherExistingClassItems, ...otherExistingSubclassItems],
            isForceSpellcastingMulticlass: isSpellcastingMulticlass,
        });

        maxPactCasterLevel = Math.max(maxPactCasterLevel, targetLevel);

        const casterProgression = sc?.casterProgression || cls.casterProgression;
        const spellAbility = sc?.spellcastingAbility || cls.spellcastingAbility;

        if (casterProgression) {
            const fnRound = casterClassCount ? Math.floor : Math.ceil;
            switch (casterProgression) {
            case "full":
                totalSpellcastingLevels += targetLevel;
                break;
            case "1/2":
                totalSpellcastingLevels += fnRound(targetLevel / 2);
                break;
            case "1/3":
                totalSpellcastingLevels += fnRound(targetLevel / 3);
                break;
            }
        }

        return {
            casterProgression,
            spellAbility,
            totalSpellcastingLevels,
            maxPactCasterLevel,
        };
    }

    static getMysticProgression({cls=null, targetLevel=0, otherExistingClassItems=null, otherExistingSubclassItems=null}) {
        otherExistingClassItems = otherExistingClassItems || [];
        otherExistingSubclassItems = otherExistingSubclassItems || [];
        let totalMysticLevels = 0;

        if (cls?.name === "Mystic" && cls?.source === Parser.SRC_UATMC)
            totalMysticLevels += targetLevel;

        if (otherExistingClassItems) {
            totalMysticLevels += otherExistingClassItems.filter(it=>it.name.toLowerCase().trim() === "mystic").map(it=>it.system.levels).sum();
        }

        return {
            totalMysticLevels,
        };
    }

    static addFauxOptionalFeatureFeatures(classList, optfeatList) {
        for (const cls of classList) {
            if (cls.classFeatures && cls.optionalfeatureProgression?.length) {
                for (const optFeatProgression of cls.optionalfeatureProgression) {
                    this._addFauxOptionalFeatureFeatures_handleClassProgression(optfeatList, cls, null, optFeatProgression, );
                }
            }

            for (const sc of cls.subclasses) {
                if (sc.subclassFeatures && sc.optionalfeatureProgression?.length) {
                    for (const optFeatProgression of sc.optionalfeatureProgression) {
                        this._addFauxOptionalFeatureFeatures_handleClassProgression(optfeatList, cls, sc, optFeatProgression, );
                    }
                }
            }
        }
    }

    static _addFauxOptionalFeatureFeatures_handleClassProgression(optfeatList, cls, sc, optFeatProgression) {
        const fauxLoadeds = this._addFauxOptionalFeatureFeatures_getLoadeds(optfeatList, cls, optFeatProgression);

        let progression = optFeatProgression.progression;
        if (!(progression instanceof Array)) {
            if (progression["*"]) {
                progression = MiscUtil.copy(progression);
                progression[1] = progression["*"];
            }

            const populated = new Set(Object.keys(progression).map(it=>Number(it)).sort(SortUtil.ascSort));
            const nxt = [];
            const lvlMax = Math.max(...populated, Consts.CHAR_MAX_LEVEL);
            for (let i = 0; i < lvlMax; ++i) {
                nxt[i] = populated.has(i + 1) ? progression[i + 1] : nxt.length ? nxt.last() : 0;
            }
            progression = nxt;
        }

        let required = optFeatProgression.required;
        if (required && !(required instanceof Array)) {
            const populated = new Set(Object.keys(required).map(it=>Number(it)).sort(SortUtil.ascSort));
            const nxt = [];
            const lvlMax = Math.max(...populated, Consts.CHAR_MAX_LEVEL);
            for (let i = 0; i < lvlMax; ++i) {
                nxt[i] = populated.has(i + 1) ? required[i + 1] : [];
            }
            required = nxt;
        }

        const propFeatures = sc ? "subclassFeatures" : "classFeatures";
        const propFeature = sc ? "subclassFeature" : "classFeature";
        const fnUnpackUidFeature = sc ? DataUtil.class.unpackUidSubclassFeature : DataUtil.class.unpackUidClassFeature;

        let cntPrev = 0;
        progression.forEach((cntOptFeats,ixLvl)=>{
            if (cntOptFeats === cntPrev)
                return;
            const cntDelta = cntOptFeats - cntPrev;
            if (!~cntDelta)
                return;
            const lvl = ixLvl + 1;
            const requiredUidsUnpacked = (required?.[ixLvl] || []).map(it=>DataUtil.proxy.unpackUid("optionalfeature", it, "optfeature", {
                isLower: true
            }));

            const feature = this._addFauxOptionalFeatureFeatures_getFauxFeature(cls, sc, optFeatProgression, lvl, fauxLoadeds, cntDelta, requiredUidsUnpacked);

            const ixInsertBefore = (sc || cls)[propFeatures].findIndex(it=>{
                return (it.level || fnUnpackUidFeature(it[propFeature] || it).level) > lvl;
            }
            );
            if (~ixInsertBefore)
                (sc || cls)[propFeatures].splice(ixInsertBefore, 0, feature);
            else
                (sc || cls)[propFeatures].push(feature);

            cntPrev = cntOptFeats;
        }
        );
    }

    static _addFauxOptionalFeatureFeatures_getLoadeds(optfeatList, clsSc, optFeatProgression) {
        const availOptFeats = optfeatList.filter(it=>optFeatProgression.featureType instanceof Array && (optFeatProgression.featureType || []).some(ft=>it.featureType.includes(ft)));
        const optionsMeta = {
            setId: CryptUtil.uid(),
            name: optFeatProgression.name
        };
        return availOptFeats.map(it=>{
            return {
                type: "optionalfeature",
                entry: `{@optfeature ${it.name}|${it.source}}`,
                entity: MiscUtil.copy(it),
                optionsMeta,
                page: UrlUtil.PG_OPT_FEATURES,
                source: it.source,
                hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES](it),
                isRequiredOption: false,
            };
        }
        );
    }

    static _addFauxOptionalFeatureFeatures_getFauxFeature(cls, sc, optFeatProgression, lvl, fauxLoadeds, cntOptions, requiredUidsUnpacked) {
        const loadeds = MiscUtil.copy(fauxLoadeds).filter(l=>!ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES]({
            name: l.entity.name,
            source: l.entity.source
        }), "optionalfeature", l.entity.source, {
            isNoCount: true
        }, ));

        loadeds.forEach(l=>{
            l.isRequiredOption = requiredUidsUnpacked.some(it=>it.name === l.entity.name.toLowerCase() && it.source === l.entity.source.toLowerCase());
            l.optionsMeta.count = cntOptions;
            PageFilterClassesFoundry.populateEntityTempData({
                entity: l.entity,
                ancestorClassName: cls.name,
                ancestorSubclassName: sc?.name,
                level: lvl,
                ancestorType: "optionalfeature",
                displayName: `${optFeatProgression.name}: ${l.entity.name}`,
                foundrySystem: {
                    requirements: cls.name ? `${cls.name}${sc ? ` (${sc.name})` : ""} ${lvl}` : null,
                },
            });
        }
        );

        const out = {
            name: optFeatProgression.name,
            level: lvl,
            loadeds: loadeds,
        };

        if (sc) {
            Object.assign(out, {
                source: sc.source,
                subclassFeature: `${optFeatProgression.name}|${cls.name}|${cls.source}|${sc.shortName}|${sc.source}|${lvl}|${Parser.SRC_5ETOOLS_TMP}`,
                hash: UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"]({
                    name: optFeatProgression.name,
                    subclassName: sc.name,
                    subclassSource: sc.source,
                    className: cls.name,
                    classSource: cls.source,
                    level: lvl,
                    source: Parser.SRC_5ETOOLS_TMP,
                }),
            }, );
        } else {
            Object.assign(out, {
                source: cls.source,
                classFeature: `${optFeatProgression.name}|${cls.name}|${cls.source}|${lvl}|${Parser.SRC_5ETOOLS_TMP}`,
                hash: UrlUtil.URL_TO_HASH_BUILDER["classFeature"]({
                    name: optFeatProgression.name,
                    className: cls.name,
                    classSource: cls.source,
                    level: lvl,
                    source: Parser.SRC_5ETOOLS_TMP,
                }),
            }, );
        }

        return out;
    }

    static getExistingClassItems(actor, cls) {
        if (!cls)
            return [];

        return actor.items.filter(actItem=>{
            if (actItem.type !== "class")
                return false;

            const {page, source, hash, propDroppable} = MiscUtil.get(actItem, "flags", SharedConsts.MODULE_ID) || {};
            if (page === UrlUtil.PG_CLASSES && propDroppable === "class" && source === cls.source && hash === UrlUtil.URL_TO_HASH_BUILDER["class"](cls))
                return true;

            return (actItem.name || "").toLowerCase().trim() === cls.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(actItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(cls.source).toLowerCase());
        }
        );
    }

    static getExistingSubclassItems(actor, cls, sc) {
        if (!cls || !sc)
            return [];

        return actor.items.filter(actItem=>{
            if (actItem.type !== "subclass")
                return false;

            const {page, source, hash, propDroppable} = MiscUtil.get(actItem, "flags", SharedConsts.MODULE_ID) || {};
            if (page === UrlUtil.PG_CLASSES && propDroppable === "subclass" && source === sc.source && hash === UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc))
                return true;

            return (actItem.name || "").toLowerCase().trim() === sc.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(actItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(sc.source).toLowerCase());
        }
        );
    }

    static getClassFromExistingClassItem(existingClassItem, classes) {
        if (!existingClassItem || existingClassItem.type !== "class" || !classes?.length)
            return null;

        classes = [...classes].sort(this._sortByOfficialAndRecent.bind(this));

        return classes.find(cls=>cls.name.toLowerCase().trim() === existingClassItem.name.toLowerCase().trim() && (!Config.get("import", "isStrictMatching") || (UtilDocumentSource.getDocumentSource(existingClassItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(cls.source).toLowerCase()), );
    }

    static getSubclassFromExistingSubclassItem(existingSubclassItem, cls, subclasses) {
        if (!existingSubclassItem || existingSubclassItem.type !== "subclass" || !subclasses?.length)
            return null;

        subclasses = subclasses.filter(it=>it.className === cls.name && it.classSource === cls.source);

        subclasses = [...subclasses].sort(this._sortByOfficialAndRecent.bind(this));

        return subclasses.find(sc=>sc.name.toLowerCase().trim() === existingSubclassItem.name.toLowerCase().trim() || sc.shortName.toLowerCase().trim() === existingSubclassItem.name.toLowerCase().trim(), );
    }

    static _sortByOfficialAndRecent(a, b) {
        const isNonStandardSourceA = SourceUtil.isNonstandardSource(a.source);
        const isNonStandardSourceB = SourceUtil.isNonstandardSource(b.source);

        if (isNonStandardSourceA === isNonStandardSourceB) {
            return SortUtil.ascSortDateString(Parser.sourceJsonToDate(a.source), Parser.sourceJsonToDate(b.source)) || SortUtil.ascSortLower(a.name, b.name);
        }

        return isNonStandardSourceA ? 1 : -1;
    }

    static getClassSubclassFeatureReferences(obj) {
        const refsClassFeature = [];
        const refsSubclassFeature = [];

        MiscUtil.getWalker({
            isNoModification: true
        }).walk(obj, {
            object: (obj)=>{
                if (obj.type === "refClassFeature") {
                    refsClassFeature.push(MiscUtil.copy(obj));
                    return;
                }

                if (obj.type === "refSubclassFeature") {
                    refsSubclassFeature.push(MiscUtil.copy(obj));
                }
            }
            ,
        }, );

        return {
            refsClassFeature,
            refsSubclassFeature
        };
    }

    static getClassSubclassItemTuples({classItems, subclassItems}) {
        if (!classItems?.length)
            return [];

        subclassItems = subclassItems || [];

        return classItems.map(classItem=>({
            classItem,
            subclassItem: subclassItems.find(it=>it.system.classIdentifier === classItem.system.identifier),
        }));
    }

    static getToolProficiencyData(profs) {
        if (!profs)
            return null;
        if (profs.toolProficiencies)
            return profs.toolProficiencies;
        if (!profs.tools)
            return null;

        const out = {};
        profs.tools.forEach(str=>{
            const itemUid = UtilActors.getItemUIdFromToolProficiency(str);
            if (!itemUid)
                return;
            const mappedTool = UtilActors.getMappedTool(itemUid);
            if (!mappedTool)
                return;
            const unmappedTool = UtilActors.getUnmappedTool(mappedTool);
            if (!unmappedTool)
                return;
            out[unmappedTool] = true;
        }
        );

        return [out];
    }
}

Charactermancer_Class_Util.ExistingFeatureChecker = class {
    constructor(actor) {
        this._actor = actor;

        this._existingSheetFeatures = {};
        this._existingImportFeatures = {};

        actor.items.filter(it=>it.type === "feat").forEach(it=>{
            const cleanSource = (UtilDocumentSource.getDocumentSource(it).source || "").trim().toLowerCase();
            Charactermancer_Class_Util.ExistingFeatureChecker._getNameAliases(it.name).forEach(alias=>this._existingSheetFeatures[alias] = cleanSource);

            const {page, source, hash} = it.flags?.[SharedConsts.MODULE_ID] || {};
            if (page && source && hash)
                this.addImportFeature(page, source, hash);
        }
        );
    }

    static _getNameAliases(name) {
        const cleanName = name.trim().toLowerCase();
        const out = [cleanName, ];

        const mTrailingParens = /^(.*?)\(.*\)$/.exec(cleanName);
        if (mTrailingParens)
            out.push(mTrailingParens[1].trim());

        if (cleanName.includes(": ")) {
            const cleanNamePostColon = cleanName.split(":").slice(1).join(":").trim();
            out.push(cleanNamePostColon);
            const mTrailingParensPostColon = /^(.*?)\(.*\)$/.exec(cleanNamePostColon);
            if (mTrailingParensPostColon)
                out.push(mTrailingParensPostColon[1].trim());
        }

        return out;
    }

    isExistingFeature(name, page, source, hash) {
        if (MiscUtil.get(this._existingImportFeatures, page, source, hash))
            return true;

        const searchNameAliases = Charactermancer_Class_Util.ExistingFeatureChecker._getNameAliases(name);
        if (!searchNameAliases.some(it=>this._existingSheetFeatures[it]))
            return false;

        if (!Config.get("import", "isStrictMatching"))
            return true;

        const searchSource = Parser.sourceJsonToAbv(source).trim().toLowerCase();
        return searchNameAliases.some(it=>this._existingSheetFeatures[it] === searchSource);
    }

    addImportFeature(page, source, hash) {
        MiscUtil.set(this._existingImportFeatures, page, source, hash, true);
    }
}
;

class Charactermancer_ProficiencySelect extends BaseComponent {
}

Charactermancer_ProficiencySelect.PropGroup = class {
    constructor({prop, propTrackerPulse, propTracker}) {
        this.prop = prop;
        this.propTrackerPulse = propTrackerPulse;
        this.propTracker = propTracker;
    }
}
;

class Charactermancer_OtherProficiencySelect extends Charactermancer_ProficiencySelect {
    static async pGetUserInput(opts) {
        opts = opts || {};

        if (!opts.available)
            return {
                isFormComplete: true,
                data: {}
            };

        const comp = new this({
            ...opts,
            existing: this.getExisting(opts.existingFvtt),
            existingFvtt: opts.existingFvtt,
        });
        if (comp.isNoChoice())
            return comp.pGetFormData();

        return UtilApplications.pGetImportCompApplicationFormData({
            comp,
            width: 640,
            isAutoResize: true,
        });
    }

    static getExistingFvttFromActor(actor) {
        return {
            skillProficiencies: MiscUtil.get(actor, "_source", "system", "skills"),
            toolProficiencies: MiscUtil.get(actor, "_source", "system", "tools"),
            languageProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "languages"),
            armorProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "armorProf"),
            weaponProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "weaponProf"),
            savingThrowProficiencies: MiscUtil.get(actor, "_source", "system", "abilities"),
        };
    }

    static getExisting(existingFvtt) {
        return {
            skillProficiencies: this._getExistingSkillToolProficiencies({
                existingProficienciesSetFvtt: existingFvtt.skillProficiencies,
                mapAbvToFull: UtilActors.SKILL_ABV_TO_FULL,
            }),
            toolProficiencies: this._getExistingSkillToolProficiencies({
                existingProficienciesSetFvtt: existingFvtt.toolProficiencies,
                mapAbvToFull: UtilActors.SKILL_ABV_TO_FULL,
            }),
            languageProficiencies: this._getExistingProficiencies({
                existingProficienciesSetFvtt: existingFvtt?.languageProficiencies,
                vetToFvttProfs: UtilActors.VALID_LANGUAGES,
                allProfsVet: Parser.LANGUAGES_ALL,
            }),
            armorProficiencies: this._getExistingProficiencies({
                existingProficienciesSetFvtt: existingFvtt?.armorProficiencies,
                vetToFvttProfs: UtilActors.VALID_ARMOR_PROFICIENCIES,
                allProfsVet: UtilActors.ARMOR_PROFICIENCIES,
            }),
            weaponProficiencies: this._getExistingProficiencies({
                existingProficienciesSetFvtt: existingFvtt?.weaponProficiencies,
                vetToFvttProfs: UtilActors.VALID_WEAPON_PROFICIENCIES,
                allProfsVet: UtilActors.WEAPON_PROFICIENCIES,
            }),
            savingThrowProficiencies: this._getExistingSavingThrowProficiencies(existingFvtt),
        };
    }

    static isNoChoice(available) {
        return this._isNoChoice({
            available
        });
    }

    static _isNoChoice({available, isAlreadyMapped}) {
        if (!available?.length)
            return true;
        if (isAlreadyMapped && !this._isValidAvailableData(available))
            throw new Error(`Proficiency data was not valid! Data was:\n${JSON.stringify(available)}`);

        if (!isAlreadyMapped)
            available = Charactermancer_OtherProficiencySelect._getNormalizedAvailableProficiencies(available);

        return available.length === 1 && !available[0].choose;
    }

    static _isValidAvailableData(available) {
        if (!(available instanceof Array))
            return false;

        for (const profSet of available) {
            const badKeys = Object.keys(profSet).filter(it=>it !== "static" && it !== "choose");
            if (badKeys.length)
                return false;

            if ((profSet.static || []).filter(it=>!it.prop).length)
                return false;
            if ((profSet.choose || []).filter(it=>it.from && it.from.some(from=>!from.prop)).length)
                return false;
            if ((profSet.choose || []).filter(it=>it.fromFilter && !it.prop).length)
                return false;
        }

        return true;
    }

    static getMappedSkillProficiencies(skillProficiencies) {
        if (!skillProficiencies)
            return skillProficiencies;
        return skillProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anySkill = it.any;
                delete it.any;
            }
            if (it.choose?.from && CollectionUtil.setEq(new Set(it.choose.from), new Set(Renderer.generic.FEATURE__ALL_SKILLS))) {
                it.anySkill = it.choose.count ?? 1;
                delete it.choose;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "skillProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedLanguageProficiencies(languageProficiencies) {
        if (!languageProficiencies)
            return languageProficiencies;
        return languageProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyLanguage = it.any;
                delete it.any;
            }
            if (it.anyStandard) {
                it.anyStandardLanguage = it.anyStandard;
                delete it.anyStandard;
            }
            if (it.anyExotic) {
                it.anyExoticLanguage = it.anyExotic;
                delete it.anyExotic;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "languageProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "languageProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedToolProficiencies(toolProficiencies) {
        if (!toolProficiencies)
            return toolProficiencies;
        return toolProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyTool = it.any;
                delete it.any;
            }
            if (it.anyArtisans) {
                it.anyArtisansTool = it.anyArtisans;
                delete it.anyArtisans;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "toolProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "toolProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedArmorProficiencies(armorProficiencies) {
        if (!armorProficiencies)
            return armorProficiencies;
        return armorProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyArmor = it.any;
                delete it.any;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "armorProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "armorProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedWeaponProficiencies(weaponProficiencies) {
        if (!weaponProficiencies)
            return weaponProficiencies;
        return weaponProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anyWeapon = it.any;
                delete it.any;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "weaponProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "weaponProficiencies"
            });
            return it;
        }
        );
    }

    static getMappedSavingThrowProficiencies(savingThrowProficiencies) {
        if (!savingThrowProficiencies)
            return savingThrowProficiencies;
        return savingThrowProficiencies.map(it=>{
            it = MiscUtil.copy(it);
            if (it.any) {
                it.anySavingThrow = it.any;
                delete it.any;
            }
            this._getMappedProficiencies_expandChoose({
                proficienciesSet: it,
                prop: "savingThrowProficiencies"
            });
            this._getMappedProficiencies_expandStatic({
                proficienciesSet: it,
                prop: "savingThrowProficiencies"
            });
            return it;
        }
        );
    }

    static _getMappedProficiencies_expandChoose({proficienciesSet, prop}) {
        if (!proficienciesSet.choose)
            return;
        if (proficienciesSet.choose.fromFilter)
            proficienciesSet.choose.prop = prop;
        if (proficienciesSet.choose.from) {
            proficienciesSet.choose.from = proficienciesSet.choose.from.map(it=>{
                if (typeof it !== "string")
                    return it;
                return {
                    prop,
                    name: it
                };
            }
            );
        }
        proficienciesSet.choose = [proficienciesSet.choose];
    }

    static _getMappedProficiencies_expandStatic({proficienciesSet, prop, ignoredKeys}) {
        Object.entries(proficienciesSet).forEach(([k,v])=>{
            if ((ignoredKeys && ignoredKeys.has(k)) || Charactermancer_OtherProficiencySelect._MAPPED_IGNORE_KEYS.has(k))
                return;

            if (typeof v === "boolean") {
                proficienciesSet[k] = {
                    prop
                };
                return;
            }
            if (typeof v === "number") {
                proficienciesSet[k] = {
                    prop,
                    count: v
                };
                return;
            }

            throw new Error(`Unhandled type "${typeof v}" for value of proficiency "${k}"`);
        }
        );
    }

    static _getExistingFvttProficiencySetsMeta(existingFvtt) {
        return {
            existingProficienciesFvttSet: new Set(existingFvtt?.value || []),
            existingProficienciesFvttSetCustom: new Set((existingFvtt?.custom || "").split(";").map(it=>it.trim().toLowerCase()).filter(Boolean)),
        };
    }

    constructor(opts) {
        opts = opts || {};
        super();

        this._existing = opts.existing;
        this._available = Charactermancer_OtherProficiencySelect._getNormalizedAvailableProficiencies(opts.available);
        this._titlePrefix = opts.titlePrefix;
        this._featureSourceTracker = opts.featureSourceTracker || new Charactermancer_FeatureSourceTracker();
        this._$elesPreFromGroups = opts.$elesPreFromGroups;
        this._$elesPostFromGroups = opts.$elesPostFromGroups;

        this._lastMetas = [];
        this._hkExisting = null;
    }

    static _getNormalizedAvailableProficiencies(availProfs) {
        return availProfs.map(availProfSet=>{
            const out = {};

            Object.entries(availProfSet).forEach(([k,v])=>{
                if (!v)
                    return;

                switch (k) {
                case "choose":
                    {
                        v.forEach(choose=>{
                            const mappedCount = choose.count != null && !isNaN(choose.count) ? Number(choose.count) : 1;
                            if (mappedCount <= 0)
                                return;

                            const mappedFroms = (choose?.from || []).map(it=>Renderer.generic.getMappedAnyProficiency({
                                keyAny: it,
                                countRaw: mappedCount
                            }) || this._getNormalizedProficiency(null, it)).filter(Boolean);

                            const mappedFromFilter = (choose?.fromFilter || "").trim();

                            if (!mappedFroms.length && !mappedFromFilter)
                                return;
                            if (mappedFroms.length && mappedFromFilter)
                                throw new Error(`Invalid proficiencies! Only one of "from" and "fromFilter" may be provided. Data was:\n${JSON.stringify(choose)}`);

                            const tgt = (out.choose = out.choose || []);

                            if (mappedFromFilter) {
                                if (!choose.type && !choose.prop)
                                    throw new Error(`"fromFilter" did not have an associated "type"!`);
                                tgt.push({
                                    fromFilter: mappedFromFilter,
                                    count: mappedCount,
                                    prop: choose.prop || this._getNormalizedProficiencyPropFromType(choose.type)
                                });
                                return;
                            }

                            if (!mappedFroms.length)
                                return;

                            const subOut = {
                                from: [],
                                count: mappedCount
                            };
                            mappedFroms.forEach(it=>{
                                if (it.from) {
                                    subOut.from = [...subOut.from, ...it.from];
                                    if (it.groups)
                                        Object.assign((subOut.groups = subOut.groups || {}), it.groups);
                                    return;
                                }

                                subOut.from.push(it);
                            }
                            );
                            tgt.push(subOut);
                        }
                        );

                        break;
                    }

                case "anySkill":
                case "anyTool":
                case "anyArtisansTool":
                case "anyMusicalInstrument":
                case "anyLanguage":
                case "anyStandardLanguage":
                case "anyExoticLanguage":
                case "anyWeapon":
                case "anyArmor":
                case "anySavingThrow":
                    {
                        const mappedAny = Renderer.generic.getMappedAnyProficiency({
                            keyAny: k,
                            countRaw: v
                        });
                        if (!mappedAny)
                            break;
                        (out.choose = out.choose || []).push(mappedAny);
                        break;
                    }

                default:
                    {
                        if (k === "static")
                            throw new Error(`Property handling for "static" is unimplemented!`);

                        if (v?.prop) {
                            (out.static = out.static || []).push({
                                name: k,
                                prop: v.prop
                            });
                            break;
                        }
                        if (v?.type) {
                            (out.static = out.static || []).push({
                                name: k,
                                prop: this._getNormalizedProficiencyPropFromType(v.type)
                            });
                            break;
                        }

                        const normalized = this._getNormalizedProficiency(k, v);
                        if (normalized)
                            (out.static = out.static || []).push(normalized);
                    }
                }
            }
            );

            if (out.static && out.choose) {
                out.choose.forEach(choose=>{
                    if (choose.fromFilter)
                        return;

                    choose.from = choose.from.filter(({name, prop})=>!out.static.some(({name: nameStatic, prop: propStatic})=>nameStatic === name && propStatic === prop));
                }
                );
            }

            return out;
        }
        );
    }

    static _getNormalizedProficiency(k, v) {
        if (!v)
            return null;

        let name = v?.name ?? k ?? v;
        if (!name || typeof name !== "string")
            return null;
        name = name.trim();

        if (v?.prop) {
            return {
                name,
                prop: v.prop
            };
        }

        if (v?.type) {
            const prop = this._getNormalizedProficiencyPropFromType(v.type);
            return {
                name,
                prop
            };
        }

        if (Charactermancer_OtherProficiencySelect._VALID_SKILLS.has(name))
            return {
                name,
                prop: "skillProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_TOOLS.has(name))
            return {
                name,
                prop: "toolProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_LANGUAGES.has(name))
            return {
                name,
                prop: "languageProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_WEAPONS.has(name))
            return {
                name,
                prop: "weaponProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_ARMORS.has(name))
            return {
                name,
                prop: "armorProficiencies"
            };
        if (Charactermancer_OtherProficiencySelect._VALID_SAVING_THROWS.has(name))
            return {
                name,
                prop: "savingThrowProficiencies"
            };

        console.warn(...LGT, `Could not discern the type of proficiency "${name}"\u2014you may need to specify it directly with "type".`);

        return null;
    }

    static _getNormalizedProficiencyPropFromType(type) {
        type = type.trim().toLowerCase();
        switch (type) {
        case "skill":
            return "skillProficiencies";
        case "tool":
            return "toolProficiencies";
        case "language":
            return "languageProficiencies";
        case "weapon":
            return "weaponProficiencies";
        case "armor":
            return "armorProficiencies";
        case "savingThrow":
            return "savingThrowProficiencies";
        default:
            throw new Error(`Type "${type}" did not have an associated proficiency property!`);
        }
    }

    static _getTagFromProp(prop) {
        switch (prop) {
        case "armorProficiencies":
            return "@item";
        case "weaponProficiencies":
            return "@item";
        default:
            throw new Error(`Cannot get @tag from prop "${prop}"`);
        }
    }

    _getTitle() {
        const props = this._getAllPossibleProps();
        return `${props.map(prop=>this.constructor._getPropDisplayName({
            prop
        })).join("/")} Proficiency`;
    }

    _getTitlePlural() {
        const props = this._getAllPossibleProps();
        return `${props.map(prop=>this.constructor._getPropDisplayName({
            prop,
            isPlural: true
        })).join("/")} Proficiencies`;
    }

    _getAllPossibleProps() {
        const propSet = new Set();

        this._available.forEach(profSet=>{
            const subSet = this.constructor._getAllPossiblePropsForProfSet(profSet);
            subSet.forEach(prop=>propSet.add(prop));
        }
        );

        return [...propSet];
    }

    static _getAllPossiblePropsForProfSet(profSet) {
        const out = new Set();
        (profSet.static || []).forEach(it=>out.add(it.prop));
        (profSet.choose || []).forEach(it=>{
            if (it.prop)
                return out.add(it.prop);
            it.from.forEach(from=>out.add(from.prop));
        }
        );
        return out;
    }

    get modalTitle() {
        return this._getTitlePlural();
    }

    render($wrp) {
        const $stgSelGroup = this._render_$getStgSelGroup();

        const $stgGroup = $$`<div class="ve-flex-col"></div>`;

        const hkIxSet = ()=>{
            $stgGroup.empty();

            if (this._featureSourceTracker && this._hkExisting) {
                Object.values(Charactermancer_OtherProficiencySelect._PROP_GROUPS).forEach(({propTrackerPulse})=>this._featureSourceTracker.removeHook(this, propTrackerPulse, this._hkExisting));
            }
            this._lastMetas.forEach(it=>it.cleanup());
            this._lastMetas = [];

            const selProfs = this._available[this._state.ixSet];

            if (this._featureSourceTracker)
                this._doSetTrackerState();

            const $ptsExistingStatic = selProfs.static?.length ? this._render_renderPtStatic($stgGroup, selProfs.static) : null;

            if ($ptsExistingStatic && selProfs.choose?.length)
                $stgGroup.append(`<hr class="hr-2">`);

            const $ptsExistingChoose = (selProfs.choose || []).map(({count, from, groups, fromFilter, prop},i)=>{
                if (this._$elesPreFromGroups?.[i])
                    $stgGroup.append(this._$elesPreFromGroups?.[i]);

                const $outPtsExisting = fromFilter ? this._render_renderPtChooseFromFilter($stgGroup, {
                    ix: i,
                    count,
                    fromFilter,
                    prop
                }) : this._render_renderPtChooseFrom($stgGroup, {
                    ix: i,
                    count,
                    from,
                    groups
                });

                if (this._$elesPostFromGroups?.[i])
                    $stgGroup.append(this._$elesPostFromGroups?.[i]);

                if (selProfs.choose.length > 1 && (i < selProfs.choose.length - 1)) {
                    $stgGroup.append(`<hr class="hr-2">`);
                }

                return $outPtsExisting;
            }
            );

            this._hkExisting = ()=>this._hk_pUpdatePtsExisting($ptsExistingStatic, $ptsExistingChoose);
            if (this._featureSourceTracker) {
                Object.values(Charactermancer_OtherProficiencySelect._PROP_GROUPS).forEach(({propTrackerPulse})=>this._featureSourceTracker.addHook(this, propTrackerPulse, this._hkExisting));
            }
            this._hkExisting();
        }
        ;
        this._addHookBase("ixSet", hkIxSet);
        hkIxSet();

        $$($wrp)`
			${$stgSelGroup}
			${$stgGroup}
		`;
    }

    _doSetTrackerState() {
        const formData = this._getFormData();
        this._featureSourceTracker.setState(this, Object.keys(Charactermancer_OtherProficiencySelect._PROP_GROUPS).mergeMap(prop=>({
            [prop]: formData.data?.[prop]
        })), );
    }

    static _render_getStaticKeyFullText({name, prop}) {
        switch (prop) {
        case "weaponProficiencies":
            return name.split("|")[0].toTitleCase();

        case "armorProficiencies":
            {
                switch (name) {
                case "light":
                case "medium":
                case "heavy":
                    return name.toTitleCase();
                case "shield|phb":
                    return "Shields";
                default:
                    return name.split("|")[0].toTitleCase();
                }
            }

        case "savingThrowProficiencies":
            return Parser.attAbvToFull(name).toTitleCase();

        default:
            return name.toTitleCase();
        }
    }

    static _render_getStaticKeyFullTextOther({prop}) {
        switch (prop) {
        case "skillProficiencies":
            return "(Other skill proficiency)";
        case "toolProficiencies":
            return "(Other tool proficiency)";
        case "languageProficiencies":
            return "(Other language proficiency)";
        case "weaponProficiencies":
            return "(Other weapon proficiency)";
        case "armorProficiencies":
            return "(Other armor proficiency)";
        case "savingThrowProficiencies":
            return "(Other saving throw proficiency)";
        default:
            throw new Error(`Unhandled prop "${prop}"`);
        }
    }

    static async _pGetParentGroup({prop, name}) {
        switch (prop) {
        case "weaponProficiencies":
            return UtilDataConverter.pGetItemWeaponType(name);
        default:
            return null;
        }
    }

    static _getRenderedStatic({prop, name}) {
        switch (prop) {
        case "skillProficiencies":
            return this._getRenderedStatic_skillProficiencies(name);
        case "languageProficiencies":
            return this._getRenderedStatic_languageProficiencies(name);
        case "toolProficiencies":
            return this._getRenderedStatic_toolProficiencies(name);
        case "armorProficiencies":
            return this._getRenderedStatic_armorProficiencies(name);
        case "weaponProficiencies":
            return Renderer.get().render(`{@item ${name.split("|").map(sub=>sub.toTitleCase()).join("|")}}`);
        case "savingThrowProficiencies":
            return Parser.attAbvToFull(name).toTitleCase();
        default:
            return name.toTitleCase();
        }
    }

    static _getRenderedStatic_skillProficiencies(name) {
        const atb = Parser.skillToAbilityAbv(name);
        const ptAbility = `<div class="ml-1 ve-small ve-muted" title="${Parser.attAbvToFull(atb)}">(${atb.toTitleCase()})</div>`;

        return `<div class="ve-inline-flex-v-center">${Renderer.get().render(`{@skill ${name.toTitleCase()}}`)}${ptAbility}</div>`;
    }

    static _getRenderedStatic_languageProficiencies(name) {
        if (name === "other")
            return name.toTitleCase();
        if (UtilActors.LANGUAGES_PRIMORDIAL.includes(name))
            return Renderer.get().render(`{@language primordial||${name.toTitleCase()}}`);
        return Renderer.get().render(`{@language ${name.toTitleCase()}}`);
    }

    static _getRenderedStatic_toolProficiencies(name) {
        if (UtilActors.TOOL_PROFICIENCIES_TO_UID[name])
            return Renderer.get().render(`{@item ${UtilActors.TOOL_PROFICIENCIES_TO_UID[name].toTitleCase()}}`);
        return name.toTitleCase();
    }

    static _getRenderedStatic_armorProficiencies(key) {
        if (key === "light" || key === "medium" || key === "heavy")
            return key.toTitleCase();
        if (key === "shield|phb")
            return Renderer.get().render(`{@item shield|phb|Shields}`);
        return Renderer.get().render(`{@item ${key.split("|").map(sub=>sub.toTitleCase()).join("|")}}`);
    }

    static _getPropDisplayName({prop}) {
        switch (prop) {
        case "skillProficiencies":
            return `Skill`;
        case "toolProficiencies":
            return `Tool`;
        case "languageProficiencies":
            return `Language`;
        case "weaponProficiencies":
            return `Weapon`;
        case "armorProficiencies":
            return `Armor`;
        case "savingThrowProficiencies":
            return `Saving Throw`;
        default:
            throw new Error(`Unhandled prop "${prop}"`);
        }
    }

    _render_$getStgSelGroup() {
        if (this._available.length <= 1)
            return null;

        const $selIxSet = ComponentUiUtil.$getSelEnum(this, "ixSet", {
            placeholder: `Select ${this._getTitle()} Set`,
            values: this._available.map((_,i)=>i),
            fnDisplay: ix=>{
                const selProfs = this._available[ix];

                const out = [];

                if (selProfs.static) {
                    const pt = MiscUtil.copy(selProfs.static).sort((a,b)=>SortUtil.ascSortLower(a.name, b.name)).map(({name, prop})=>{
                        if (name === "other")
                            return this.constructor._render_getStaticKeyFullTextOther({
                                prop
                            });
                        return this.constructor._render_getStaticKeyFullText({
                            name,
                            prop
                        });
                    }
                    ).join(", ");
                    out.push(pt);
                }

                if (selProfs.choose) {
                    selProfs.choose.forEach(fromBlock=>{
                        if (fromBlock.name) {
                            out.push(`Choose ${fromBlock.name.toLowerCase()}`);
                            return;
                        }

                        if (fromBlock.fromFilter) {
                            out.push(`Choose ${Parser.numberToText(fromBlock.count)} from filtered selection`);
                            return;
                        }

                        if (fromBlock.groups) {
                            out.push(`Choose ${Parser.numberToText(fromBlock.count)} from ${Object.values(fromBlock.groups).map(({name})=>name).joinConjunct(", ", " or ")}`);
                            return;
                        }

                        out.push(`Choose ${Parser.numberToText(fromBlock.count || 1)} from ${fromBlock.from.map(({name})=>name.toTitleCase()).join(", ")}`);
                    }
                    );
                }

                return out.filter(Boolean).join("; ") || "(Nothing)";
            }
            ,
        }, );

        if (this._featureSourceTracker) {
            const hk = ()=>{
                const formData = this._getFormData().data;
                const trackerState = Object.keys(formData.data || {}).filter(k=>Charactermancer_OtherProficiencySelect._PROP_GROUPS[k]).mergeMap(it=>it);
                this._featureSourceTracker.setState(this, trackerState);
            }
            ;
            this._addHookBase("ixSet", hk);
        }

        return $$`<div class="w-100 mb-2 ve-flex-vh-center">
			${$selIxSet}
		</div>`;
    }

    _getAllValuesMaybeInUseLookup() {
        const out = {};

        const activeSet = this._available[this._state.ixSet] || {};

        if (activeSet.static) {
            activeSet.static.forEach(({name, prop})=>{
                out[prop] = out[prop] || new Set();
                out[prop].add(name);
            }
            );
        }

        if (activeSet.choose) {
            activeSet.choose.forEach(({from, fromFilter})=>{
                if (fromFilter) {
                    const prefix = `${this._getStateKeyPrefix()}_chooseFilter_`;
                    Object.entries(this._state).filter(([k,v])=>k.startsWith(prefix) && v).forEach(([,{prop, name}])=>{
                        if (!name)
                            throw new Error(`"fromFilter" choice had no "name"--this should never occur!`);
                        out[prop] = out[prop] || new Set();
                        out[prop].add(name);
                    }
                    );
                    return;
                }

                from.forEach(({name, prop})=>{
                    out[prop] = out[prop] || new Set();
                    out[prop].add(name);
                }
                );
            }
            );
        }

        return out;
    }

    _getStateKeyPrefix() {
        return "otherProfSelect";
    }

    _getPropsChooseFromFilter({ixChoose, ixCount}) {
        return {
            propState: `${this._getStateKeyPrefix()}_chooseFilter_${ixChoose}_${ixCount}`,
        };
    }

    _getPropsChooseFrom({ixChoose}) {
        return {
            propState: `${this._getStateKeyPrefix()}_${ixChoose}`,
        };
    }

    async _hk_pUpdatePtsExisting($ptsExistingStatic, $ptsExistingChooseFrom) {
        try {
            await this._pLock("updateExisting");
            await this._hk_pUpdatePtsExisting_({
                $ptsExistingStatic,
                $ptsExistingChooseFrom
            });
        } finally {
            this._unlock("updateExisting");
        }
    }

    async _hk_pUpdatePtsExisting_({$ptsExistingStatic, $ptsExistingChooseFrom}) {
        const allValueLookupEntries = Object.entries(this._getAllValuesMaybeInUseLookup());

        if ($ptsExistingStatic)
            await this._hk_pUpdatePtsExisting_part({
                allValueLookupEntries,
                $ptsExisting: $ptsExistingStatic
            });
        if (!$ptsExistingChooseFrom)
            return;
        for (const $ptsExisting of $ptsExistingChooseFrom)
            await this._hk_pUpdatePtsExisting_part({
                allValueLookupEntries,
                $ptsExisting
            });
    }

    async _hk_pUpdatePtsExisting_part({allValueLookupEntries, $ptsExisting}) {
        for (const [prop,allProfs] of allValueLookupEntries) {
            const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(prop, {
                ignore: this
            }) : null;

            for (const v of allProfs) {
                const parentGroup = await this.constructor._pGetParentGroup({
                    prop,
                    name: v
                });

                if (!$ptsExisting[prop]?.[v] && !parentGroup)
                    continue;

                let maxExisting = this._existing?.[prop]?.[v] || (parentGroup && this._existing?.[prop]?.[parentGroup]) || 0;

                if (otherStates)
                    otherStates.forEach(otherState=>maxExisting = Math.max(maxExisting, otherState[v] || 0, (parentGroup ? otherState[parentGroup] : 0) || 0));

                const helpText = maxExisting === 0 ? "" : `${UtilActors.PROF_TO_TEXT[maxExisting]} from Another Source`;

                $ptsExisting[prop][v].title(helpText).toggleClass("ml-1", !!maxExisting).html(maxExisting ? `(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[maxExisting]}"></i>)` : "");
            }
        }
    }

    _render_renderPtStatic($stgGroup, profsStatic) {
        const $ptsExisting = {};

        const byProp = {};
        profsStatic.forEach(({prop, name})=>MiscUtil.set(byProp, prop, name, true));
        const isMultiProp = this.constructor._getAllPossiblePropsForProfSet(this._available[this._state.ixSet]).size > 1;

        const $wrps = Object.entries(byProp).map(([prop,profsStaticSet])=>{
            const ptPropType = isMultiProp ? ` (${this.constructor._getPropDisplayName({
                prop
            })} Proficiency)` : "";
            const profsStaticSetKeys = Object.keys(profsStaticSet);
            return profsStaticSetKeys.sort(SortUtil.ascSortLower).map((name,i)=>{
                const $ptExisting = $(`<div class="ve-small veapp__msg-warning inline-block"></div>`);
                MiscUtil.set($ptsExisting, prop, name, $ptExisting);
                const isNotLast = i < profsStaticSetKeys.length - 1;
                return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${this.constructor._getRenderedStatic({
                    prop,
                    name
                })}${ptPropType}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
            }
            );
        }
        ).flat();

        $$`<div class="block">
			${$wrps}
		</div>`.appendTo($stgGroup);

        return $ptsExisting;
    }

    _render_renderPtChooseFrom($stgGroup, {ix, count, from, groups}) {
        const {propState} = this._getPropsChooseFrom({
            ixChoose: ix
        });

        const $ptsExisting = {};
        const compOpts = {
            count,
            fnDisplay: ({prop, name})=>{
                const $ptExisting = $(`<div class="ve-small veapp__msg-warning"></div>`);
                MiscUtil.set($ptsExisting, prop, name, $ptExisting);

                return $$`<div class="ve-flex-v-center w-100">
					<div class="ve-flex-v-center">${this.constructor._getRenderedStatic({
                    prop,
                    name
                })}</div>
					${$ptExisting}
				</div>`;
            }
            ,
        };

        const fromProps = new Set(from.map(({prop})=>prop));

        const byPropThenGroup = {};

        from.forEach(({name, prop, group})=>{
            group = group ?? "_";
            MiscUtil.set(byPropThenGroup, prop, group, name, Charactermancer_OtherProficiencySelect._PROFICIENT);
        }
        );

        const isMultiProp = Object.keys(byPropThenGroup).length > 1;
        const isGrouped = Object.values(byPropThenGroup).some(groupMeta=>Object.keys(groupMeta).some(group=>group !== "_"));

        if (isMultiProp || isGrouped) {
            const valueGroups = [];
            Object.entries(byPropThenGroup).forEach(([prop,groupMeta])=>{
                Object.entries(groupMeta).forEach(([groupId,names])=>{
                    const groupDetails = groups?.[groupId];

                    valueGroups.push({
                        name: [(isMultiProp ? `${this.constructor._getPropDisplayName({
                            prop
                        })} Proficiencies` : ""), groupDetails?.name, ].filter(Boolean).join(""),
                        text: groupDetails?.hint,
                        values: Object.keys(names).map(name=>({
                            prop,
                            name
                        })),
                    });
                }
                );
            }
            );

            compOpts.valueGroups = valueGroups;
        } else {
            compOpts.values = from;
        }

        const meta = ComponentUiUtil.getMetaWrpMultipleChoice(this, propState, compOpts, );

        let hkSetTrackerInfo = null;
        if (this._featureSourceTracker) {
            hkSetTrackerInfo = ()=>this._doSetTrackerState();
            this._addHookBase(meta.propPulse, hkSetTrackerInfo);
        }

        this._lastMetas.push({
            cleanup: ()=>{
                meta.cleanup();
                if (hkSetTrackerInfo)
                    this._removeHookBase(meta.propPulse, hkSetTrackerInfo);
            }
            ,
        });

        const header = fromProps.size === 1 ? (`${this.constructor._getPropDisplayName({
            prop: [...fromProps][0]
        })} ${count === 1 ? "Proficiency" : "Proficiencies"}`) : (count === 1 ? this._getTitle() : this._getTitlePlural());
        $stgGroup.append(`<div class="mb-1">${this._titlePrefix ? `${this._titlePrefix}: ` : ""}Choose ${Parser.numberToText(count)} ${header}:</div>`);
        meta.$ele.appendTo($stgGroup);

        return $ptsExisting;
    }

    _render_renderPtChooseFromFilter($stgGroup, {ix, fromFilter, count, prop}) {
        const $ptsExisting = {};

        const $row = $(`<div class="ve-flex-v-center"></div>`);

        [...new Array(count)].forEach((_,i)=>{
            const {propState} = this._getPropsChooseFromFilter({
                ixChoose: ix,
                ixCount: i
            });

            const $ptExisting = $(`<div class="ve-small veapp__msg-warning"></div>`);

            const $disp = $(`<div class="ve-flex-v-center"></div>`);
            const hkChosen = (propHk,valueHk,prevValueHk)=>{
                const isFirstRun = !propHk;
                if (!isFirstRun) {
                    if (prevValueHk) {
                        const {prop: propPrev, name: namePrev} = prevValueHk;
                        const uidPrev = (namePrev || "").toLowerCase();
                        MiscUtil.delete($ptsExisting, propPrev, uidPrev, $ptExisting);
                    }

                    if (valueHk) {
                        const {prop, name} = valueHk || {};
                        const uid = (name || "").toLowerCase();
                        MiscUtil.set($ptsExisting, prop, uid, $ptExisting);
                    }
                }

                $disp.html(this._state[propState] != null ? `<div>${Renderer.get().render(`{${this.constructor._getTagFromProp(prop)} ${this._state[propState].name.toLowerCase()}}`)}</div>` : `<div class="italic ve-muted">(select a ${this.constructor._getPropDisplayName({
                    prop
                }).toLowerCase()} proficiency)</div>`, );

                if (!isFirstRun && this._featureSourceTracker)
                    this._doSetTrackerState();
            }
            ;
            this._addHookBase(propState, hkChosen);
            this._lastMetas.push({
                cleanup: ()=>this._removeHookBase(propState, hkChosen)
            });
            hkChosen();

            const $btnFilter = $(`<button class="btn btn-default btn-xxs mx-1" title="Choose a ${this.constructor._getPropDisplayName({
                prop
            })} Proficiency"><span class="fas fa-fw fa-search"></span></button>`).click(async()=>{
                const selecteds = await this._pGetFilterChoice({
                    prop,
                    fromFilter
                });
                if (selecteds == null || !selecteds.length)
                    return;

                const selected = selecteds[0];
                this._state[propState] = {
                    prop,
                    name: `${selected.name}|${selected.values.sourceJson}`.toLowerCase()
                };
            }
            );

            $$`<div class="ve-flex-v-center mr-1">${$btnFilter}${$disp}${$ptExisting}</div>`.appendTo($row);
        }
        );

        $$`<div class="py-1 ve-flex-v-center">
			${$row}
		</div>`.appendTo($stgGroup);

        return $ptsExisting;
    }

    _pGetFilterChoice({prop, fromFilter}) {
        switch (prop) {
        case "armorProficiencies":
        case "weaponProficiencies":
            {
                const modalFilterItems = new ModalFilterItemsFvtt({
                    filterExpression: fromFilter,
                    namespace: "Charactermancer_OtherProficiencySelect.items",
                    isRadio: true,
                });
                return modalFilterItems.pGetUserSelection({
                    filterExpression: fromFilter
                });
            }

        default:
            throw new Error(`Filter choices for "${prop}" are unimplemented!`);
        }
    }

    isNoChoice() {
        return this.constructor._isNoChoice({
            available: this._available,
            isAlreadyMapped: true
        });
    }

    _getFormData() {
        let isFormComplete = true;
        const out = {};

        const selProfs = this._available[this._state.ixSet];

        (selProfs.static || []).forEach(({prop, name})=>MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT));

        (selProfs.choose || []).forEach(({count, from, groups, fromFilter, prop},ixChoose)=>{
            if (fromFilter) {
                [...new Array(count)].forEach((_,ixCount)=>{
                    const {propState} = this._getPropsChooseFromFilter({
                        ixChoose,
                        ixCount
                    });

                    if (!this._state[propState])
                        return isFormComplete = false;

                    const {prop, name} = this._state[propState];
                    MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT);
                }
                );

                return;
            }

            const {propState} = this._getPropsChooseFrom({
                ixChoose
            });

            const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, propState);
            ixs.map(ix=>from[ix]).forEach(({prop, name})=>MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT));

            if (!this._state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable(propState)])
                isFormComplete = false;
        }
        );

        return {
            isFormComplete,
            data: out,
        };
    }

    pGetFormData() {
        return this._getFormData();
    }

    _getDefaultState() {
        return {
            ixSet: 0,
        };
    }

    static _getExistingProficiencies({existingProficienciesSetFvtt, vetToFvttProfs, allProfsVet}) {
        const {existingProficienciesFvttSet, existingProficienciesFvttSetCustom} = this._getExistingFvttProficiencySetsMeta(existingProficienciesSetFvtt);

        const existing = {};

        Object.entries(vetToFvttProfs).filter(([_,fvtt])=>existingProficienciesFvttSet.has(fvtt)).forEach(([vet,fvtt])=>{
            existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
            existingProficienciesFvttSet.delete(fvtt);
        }
        );

        allProfsVet.forEach(vet=>{
            if (existingProficienciesFvttSet.has(vet)) {
                existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
                existingProficienciesFvttSet.delete(vet);
            } else if (existingProficienciesFvttSetCustom.has(vet)) {
                existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
                existingProficienciesFvttSetCustom.delete(vet);
            }
        }
        );

        if (existingProficienciesFvttSet.size || existingProficienciesFvttSetCustom.size) {
            existing.other = existingProficienciesFvttSet.size + existingProficienciesFvttSetCustom.size;
        }

        return existing;
    }

    static _getExistingSkillToolProficiencies({existingProficienciesSetFvtt, mapAbvToFull}) {
        const existing = {};

        Object.entries(existingProficienciesSetFvtt || {}).forEach(([abv,data])=>{
            if (!data.value)
                return;
            existing[mapAbvToFull[abv]] = data.value;
        }
        );

        return existing;
    }

    static _getExistingSavingThrowProficiencies(existingFvtt) {
        const existing = {};

        Object.entries(existingFvtt?.savingThrowProficiencies || {}).forEach(([ab,data])=>{
            if (!data.proficient)
                return;
            existing[ab] = data.proficient;
        }
        );

        return existing;
    }
}
/* Charactermancer_OtherProficiencySelect._PROFICIENT = 1;
Charactermancer_OtherProficiencySelect._PROP_GROUPS = {
    "skillProficiencies": {
        propTrackerPulse: "pulseSkillProficiencies",
    },
    "toolProficiencies": {
        propTrackerPulse: "pulseToolProficiencies",
    },
    "languageProficiencies": {
        propTrackerPulse: "pulseLanguageProficiencies",
    },
    "weaponProficiencies": {
        propTrackerPulse: "pulseWeaponProficiencies",
    },
    "armorProficiencies": {
        propTrackerPulse: "pulseArmorProficiencies",
    },
    "savingThrowProficiencies": {
        propTrackerPulse: "pulseSavingThrowProficiencies",
    },
};

Charactermancer_OtherProficiencySelect._MAPPED_IGNORE_KEYS = new Set(["choose", "any", "anySkill", "anyTool", "anyArtisansTool", "anyMusicalInstrument", "anyLanguage", "anyStandardLanguage", "anyExoticLanguage", "anyWeapon", "anyArmor", "anySavingThrow", ]);

Charactermancer_OtherProficiencySelect._VALID_SKILLS = new Set([...Renderer.generic.FEATURE__SKILLS_ALL, "anySkill", ]);
Charactermancer_OtherProficiencySelect._VALID_TOOLS = new Set([...Renderer.generic.FEATURE__TOOLS_ALL, "anyTool", "anyArtisansTool", "anyMusicalInstrument", ]);
Charactermancer_OtherProficiencySelect._VALID_LANGUAGES = new Set([...Renderer.generic.FEATURE__LANGUAGES_ALL, "anyLanguage", "anyStandardLanguage", "anyExoticLanguage", ]);
Charactermancer_OtherProficiencySelect._VALID_WEAPONS = new Set([...UtilActors.WEAPON_PROFICIENCIES, "anyWeapon", ]);
Charactermancer_OtherProficiencySelect._VALID_ARMORS = new Set([...UtilActors.ARMOR_PROFICIENCIES, "anyArmor", ]);
Charactermancer_OtherProficiencySelect._VALID_SAVING_THROWS = new Set([...Parser.ABIL_ABVS, "anySavingThrow", ]); */
//#endregion

//#region UIUtil
let UiUtil$1 = class UiUtil {
    static strToInt(string, fallbackEmpty=0, opts) {
        return UiUtil$1._strToNumber(string, fallbackEmpty, opts, true);
    }

    static strToNumber(string, fallbackEmpty=0, opts) {
        return UiUtil$1._strToNumber(string, fallbackEmpty, opts, false);
    }

    static _strToNumber(string, fallbackEmpty=0, opts, isInt) {
        opts = opts || {};
        let out;
        string = string.trim();
        if (!string)
            out = fallbackEmpty;
        else {
            const num = UiUtil$1._parseStrAsNumber(string, isInt);
            out = isNaN(num) || !isFinite(num) ? opts.fallbackOnNaN !== undefined ? opts.fallbackOnNaN : 0 : num;
        }
        if (opts.max != null)
            out = Math.min(out, opts.max);
        if (opts.min != null)
            out = Math.max(out, opts.min);
        return out;
    }

    static strToBool(string, fallbackEmpty=null, opts) {
        opts = opts || {};
        if (!string)
            return fallbackEmpty;
        string = string.trim().toLowerCase();
        if (!string)
            return fallbackEmpty;
        return string === "true" ? true : string === "false" ? false : opts.fallbackOnNaB;
    }

    static intToBonus(int, {isPretty=false}={}) {
        return `${int >= 0 ? "+" : int < 0 ? (isPretty ? "\u2012" : "-") : ""}${Math.abs(int)}`;
    }

    static getEntriesAsText(entryArray) {
        if (!entryArray || !entryArray.length)
            return "";
        if (!(entryArray instanceof Array))
            return UiUtil$1.getEntriesAsText([entryArray]);

        return entryArray.map(it=>{
            if (typeof it === "string" || typeof it === "number")
                return it;

            return JSON.stringify(it, null, 2).split("\n").map(it=>`  ${it}`);
        }
        ).flat().join("\n");
    }

    static getTextAsEntries(text) {
        try {
            const lines = text.split("\n").filter(it=>it.trim()).map(it=>{
                if (/^\s/.exec(it))
                    return it;
                return `"${it.replace(/"/g, `\\"`)}",`;
            }
            ).map(it=>{
                if (/[}\]]$/.test(it.trim()))
                    return `${it},`;
                return it;
            }
            );
            const json = `[\n${lines.join("")}\n]`.replace(/(.*?)(,)(:?\s*]|\s*})/g, "$1$3");
            return JSON.parse(json);
        } catch (e) {
            const lines = text.split("\n").filter(it=>it.trim());
            const slice = lines.join(" \\ ").substring(0, 30);
            JqueryUtil.doToast({
                content: `Could not parse entries! Error was: ${e.message}<br>Text was: ${slice}${slice.length === 30 ? "..." : ""}`,
                type: "danger",
            });
            return lines;
        }
    }

    static getShowModal(opts) {
        opts = opts || {};

        const doc = (opts.window || window).document;

        UiUtil$1._initModalEscapeHandler({
            doc
        });
        UiUtil$1._initModalMouseupHandlers({
            doc
        });
        if (doc.activeElement)
            doc.activeElement.blur();
        let resolveModal;
        const pResolveModal = new Promise(resolve=>{
            resolveModal = resolve;
        }
        );

        const pHandleCloseClick = async(isDataEntered,...args)=>{
            if (opts.cbClose)
                await opts.cbClose(isDataEntered, ...args);
            resolveModal([isDataEntered, ...args]);

            if (opts.isIndestructible)
                wrpOverlay.detach();
            else
                wrpOverlay.remove();

            ContextUtil.closeAllMenus();

            doTeardown();
        }
        ;

        const doTeardown = ()=>{
            UiUtil$1._popFromModalStack(modalStackMeta);
            if (!UiUtil$1._MODAL_STACK.length)
                doc.body.classList.remove(`ui-modal__body-active`);
        }
        ;

        const doOpen = ()=>{
            wrpOverlay.appendTo(doc.body);
            doc.body.classList.add(`ui-modal__body-active`);
        }
        ;

        const wrpOverlay = e_({
            tag: "div",
            clazz: "ui-modal__overlay"
        });
        if (opts.zIndex != null)
            wrpOverlay.style.zIndex = `${opts.zIndex}`;
        if (opts.overlayColor != null)
            wrpOverlay.style.backgroundColor = `${opts.overlayColor}`;

        const overlayBlind = opts.isFullscreenModal ? e_({
            tag: "div",
            clazz: `ui-modal__overlay-blind w-100 h-100 ve-flex-col`,
        }).appendTo(wrpOverlay) : null;

        const wrpScroller = e_({
            tag: "div",
            clazz: `ui-modal__scroller ve-flex-col`,
        });

        const modalWindowClasses = [opts.isWidth100 ? `w-100` : "", opts.isHeight100 ? "h-100" : "", opts.isUncappedHeight ? "ui-modal__inner--uncap-height" : "", opts.isUncappedWidth ? "ui-modal__inner--uncap-width" : "", opts.isMinHeight0 ? `ui-modal__inner--no-min-height` : "", opts.isMinWidth0 ? `ui-modal__inner--no-min-width` : "", opts.isMaxWidth640p ? `ui-modal__inner--max-width-640p` : "", opts.isFullscreenModal ? `ui-modal__inner--mode-fullscreen my-0 pt-0` : "", opts.hasFooter ? `pb-0` : "", ].filter(Boolean);

        const btnCloseModal = opts.isFullscreenModal ? e_({
            tag: "button",
            clazz: `btn btn-danger btn-xs`,
            html: `<span class="glyphicon glyphicon-remove></span>`,
            click: pHandleCloseClick(false),
        }) : null;

        const modalFooter = opts.hasFooter ? e_({
            tag: "div",
            clazz: `no-shrink w-100 ve-flex-col ui-modal__footer ${opts.isFullscreenModal ? `ui-modal__footer--fullscreen mt-1` : "mt-auto"}`,
        }) : null;

        const modal = e_({
            tag: "div",
            clazz: `ui-modal__inner ve-flex-col ${modalWindowClasses.join(" ")}`,
            children: [!opts.isEmpty && opts.title ? e_({
                tag: "div",
                clazz: `split-v-center no-shrink ${opts.isHeaderBorder ? `ui-modal__header--border` : ""} ${opts.isFullscreenModal ? `ui-modal__header--fullscreen mb-1` : ""}`,
                children: [opts.title ? e_({
                    tag: "h4",
                    clazz: `my-2`,
                    html: opts.title.qq(),
                }) : null,
                opts.$titleSplit ? opts.$titleSplit[0] : null,
                btnCloseModal, ].filter(Boolean),
            }) : null,
            !opts.isEmpty ? wrpScroller : null,
            modalFooter, ].filter(Boolean),
        }).appendTo(opts.isFullscreenModal ? overlayBlind : wrpOverlay);

        wrpOverlay.addEventListener("mouseup", async evt=>{
            if (evt.target !== wrpOverlay)
                return;
            if (evt.target !== UiUtil$1._MODAL_LAST_MOUSEDOWN)
                return;
            if (opts.isPermanent)
                return;
            evt.stopPropagation();
            evt.preventDefault();
            return pHandleCloseClick(false);
        }
        );

        if (!opts.isClosed)
            doOpen();

        const modalStackMeta = {
            isPermanent: opts.isPermanent,
            pHandleCloseClick,
            doTeardown,
        };
        if (!opts.isClosed)
            UiUtil$1._pushToModalStack(modalStackMeta);

        const out = {
            $modal: $(modal),
            $modalInner: $(wrpScroller),
            $modalFooter: $(modalFooter),
            doClose: pHandleCloseClick,
            doTeardown,
            pGetResolved: ()=>pResolveModal,
        };

        if (opts.isIndestructible || opts.isClosed) {
            out.doOpen = ()=>{
                UiUtil$1._pushToModalStack(modalStackMeta);
                doOpen();
            }
            ;
        }

        return out;
    }

    static async pGetShowModal(opts) {
        return UiUtil$1.getShowModal(opts);
    }

    static _pushToModalStack(modalStackMeta) {
        if (!UiUtil$1._MODAL_STACK.includes(modalStackMeta)) {
            UiUtil$1._MODAL_STACK.push(modalStackMeta);
        }
    }

    static _popFromModalStack(modalStackMeta) {
        const ixStack = UiUtil$1._MODAL_STACK.indexOf(modalStackMeta);
        if (~ixStack)
            UiUtil$1._MODAL_STACK.splice(ixStack, 1);
    }

    static _initModalEscapeHandler({doc}) {
        if (UiUtil$1._MODAL_STACK)
            return;
        UiUtil$1._MODAL_STACK = [];

        doc.addEventListener("keydown", evt=>{
            if (evt.which !== 27)
                return;
            if (!UiUtil$1._MODAL_STACK.length)
                return;
            if (EventUtil.isInInput(evt))
                return;

            const outerModalMeta = UiUtil$1._MODAL_STACK.last();
            if (!outerModalMeta)
                return;
            evt.stopPropagation();
            if (!outerModalMeta.isPermanent)
                return outerModalMeta.pHandleCloseClick(false);
        }
        );
    }

    static _initModalMouseupHandlers({doc}) {
        doc.addEventListener("mousedown", evt=>{
            UiUtil$1._MODAL_LAST_MOUSEDOWN = evt.target;
        }
        );
    }

    static isAnyModalOpen() {
        return !!UiUtil$1._MODAL_STACK?.length;
    }

    static addModalSep($modalInner) {
        $modalInner.append(`<hr class="hr-2">`);
    }

    static $getAddModalRow($modalInner, tag="div") {
        return $(`<${tag} class="ui-modal__row"></${tag}>`).appendTo($modalInner);
    }

    static $getAddModalRowHeader($modalInner, headerText, opts) {
        opts = opts || {};
        const $row = UiUtil$1.$getAddModalRow($modalInner, "h5").addClass("bold");
        if (opts.$eleRhs)
            $$`<div class="split ve-flex-v-center w-100 pr-1"><span>${headerText}</span>${opts.$eleRhs}</div>`.appendTo($row);
        else
            $row.text(headerText);
        if (opts.helpText)
            $row.title(opts.helpText);
        return $row;
    }

    static $getAddModalRowCb($modalInner, labelText, objectWithProp, propName, helpText) {
        const $row = UiUtil$1.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--cb`);
        if (helpText)
            $row.title(helpText);
        $row.append(`<span>${labelText}</span>`);
        const $cb = $(`<input type="checkbox">`).appendTo($row).keydown(evt=>{
            if (evt.key === "Escape")
                $cb.blur();
        }
        ).prop("checked", objectWithProp[propName]).on("change", ()=>objectWithProp[propName] = $cb.prop("checked"));
        return $cb;
    }

    static $getAddModalRowCb2({$wrp, comp, prop, text, title=null}) {
        const $cb = ComponentUiUtil$1.$getCbBool(comp, prop);

        const $row = $$`<label class="split-v-center py-1 veapp__ele-hoverable">
			<span>${text}</span>
			${$cb}
		</label>`.appendTo($wrp);
        if (title)
            $row.title(title);

        return $cb;
    }

    static $getAddModalRowSel($modalInner, labelText, objectWithProp, propName, values, opts) {
        opts = opts || {};
        const $row = UiUtil$1.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--sel`);
        if (opts.helpText)
            $row.title(opts.helpText);
        $row.append(`<span>${labelText}</span>`);
        const $sel = $(`<select class="form-control input-xs w-30">`).appendTo($row);
        values.forEach((val,i)=>$(`<option value="${i}"></option>`).text(opts.fnDisplay ? opts.fnDisplay(val) : val).appendTo($sel));
        const ix = values.indexOf(objectWithProp[propName]);
        $sel.val(`${~ix ? ix : 0}`).change(()=>objectWithProp[propName] = values[$sel.val()]);
        return $sel;
    }

    static _parseStrAsNumber(str, isInt) {
        const wrpTree = Renderer.dice.lang.getTree3(str);
        if (!wrpTree)
            return NaN;
        const out = wrpTree.tree.evl({});
        if (!isNaN(out) && isInt)
            return Math.round(out);
        return out;
    }

    static bindTypingEnd({$ipt, fnKeyup, fnKeypress, fnKeydown, fnClick}={}) {
        let timerTyping;
        $ipt.on("keyup search paste", evt=>{
            clearTimeout(timerTyping);
            timerTyping = setTimeout(()=>{
                fnKeyup(evt);
            }
            , UiUtil$1.TYPE_TIMEOUT_MS);
        }
        ).on("blur", evt=>{
            clearTimeout(timerTyping);
            fnKeyup(evt);
        }
        ).on("keypress", evt=>{
            if (fnKeypress)
                fnKeypress(evt);
        }
        ).on("keydown", evt=>{
            if (fnKeydown)
                fnKeydown(evt);
            clearTimeout(timerTyping);
        }
        ).on("click", ()=>{
            if (fnClick)
                fnClick();
        }
        ).on("instantKeyup", ()=>{
            clearTimeout(timerTyping);
            fnKeyup();
        }
        );
    }

    static async pDoForceFocus(ele, {timeout=250}={}) {
        if (!ele)
            return;
        ele.focus();

        const forceFocusStart = Date.now();
        while ((Date.now() < forceFocusStart + timeout) && document.activeElement !== ele) {
            await MiscUtil.pDelay(33);
            ele.focus();
        }
    }
}
;
UiUtil$1.SEARCH_RESULTS_CAP = 75;
UiUtil$1.TYPE_TIMEOUT_MS = 100;
UiUtil$1._MODAL_STACK = null;
UiUtil$1._MODAL_LAST_MOUSEDOWN = null;
globalThis.UiUtil = UiUtil$1;
//#endregion

//#region ComponentUiUtil
class ComponentUiUtil {
    static trackHook(hooks, prop, hook) {
        hooks[prop] = hooks[prop] || [];
        hooks[prop].push(hook);
    }

    static $getDisp(comp, prop, {html, $ele, fnGetText}={}) {
        $ele = ($ele || $(html || `<div></div>`));

        const hk = ()=>$ele.text(fnGetText ? fnGetText(comp._state[prop]) : comp._state[prop]);
        comp._addHookBase(prop, hk);
        hk();

        return $ele;
    }

    static $getIptInt(component, prop, fallbackEmpty=0, opts) {
        return ComponentUiUtil._$getIptNumeric(component, prop, UiUtil$1.strToInt, fallbackEmpty, opts);
    }

    static $getIptNumber(component, prop, fallbackEmpty=0, opts) {
        return ComponentUiUtil._$getIptNumeric(component, prop, UiUtil$1.strToNumber, fallbackEmpty, opts);
    }

    static _$getIptNumeric(component, prop, fnConvert, fallbackEmpty=0, opts) {
        opts = opts || {};
        opts.offset = opts.offset || 0;

        const setIptVal = ()=>{
            if (opts.isAllowNull && component._state[prop] == null) {
                return $ipt.val(null);
            }

            const num = (component._state[prop] || 0) + opts.offset;
            const val = opts.padLength ? `${num}`.padStart(opts.padLength, "0") : num;
            $ipt.val(val);
        }
        ;

        const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal text-right">`)).disableSpellcheck().keydown(evt=>{
            if (evt.key === "Escape")
                $ipt.blur();
        }
        ).change(()=>{
            const raw = $ipt.val().trim();
            const cur = component._state[prop];

            if (opts.isAllowNull && !raw)
                return component._state[prop] = null;

            if (raw.startsWith("=")) {
                component._state[prop] = fnConvert(raw.slice(1), fallbackEmpty, opts) - opts.offset;
            } else {
                const mUnary = prevValue != null && prevValue < 0 ? /^[+/*^]/.exec(raw) : /^[-+/*^]/.exec(raw);
                if (mUnary) {
                    let proc = raw;
                    proc = proc.slice(1).trim();
                    const mod = fnConvert(proc, fallbackEmpty, opts);
                    const full = `${cur}${mUnary[0]}${mod}`;
                    component._state[prop] = fnConvert(full, fallbackEmpty, opts) - opts.offset;
                } else {
                    component._state[prop] = fnConvert(raw, fallbackEmpty, opts) - opts.offset;
                }
            }

            if (cur === component._state[prop])
                setIptVal();
        }
        );

        let prevValue;
        const hook = ()=>{
            prevValue = component._state[prop];
            setIptVal();
        }
        ;
        if (opts.hookTracker)
            ComponentUiUtil.trackHook(opts.hookTracker, prop, hook);
        component._addHookBase(prop, hook);
        hook();

        if (opts.asMeta)
            return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
        else
            return $ipt;
    }

    static $getIptStr(component, prop, opts) {
        opts = opts || {};

        if ((opts.decorationLeft || opts.decorationRight) && !opts.asMeta)
            throw new Error(`Input must be created with "asMeta" option`);

        const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`)).keydown(evt=>{
            if (evt.key === "Escape")
                $ipt.blur();
        }
        ).disableSpellcheck();
        UiUtil.bindTypingEnd({
            $ipt,
            fnKeyup: ()=>{
                const nxtVal = opts.isNoTrim ? $ipt.val() : $ipt.val().trim();
                component._state[prop] = opts.isAllowNull && !nxtVal ? null : nxtVal;
            }
            ,
        });

        if (opts.placeholder)
            $ipt.attr("placeholder", opts.placeholder);

        if (opts.autocomplete && opts.autocomplete.length)
            $ipt.typeahead({
                source: opts.autocomplete
            });
        const hook = ()=>{
            if (component._state[prop] == null)
                $ipt.val(null);
            else {
                if ($ipt.val().trim() !== component._state[prop])
                    $ipt.val(component._state[prop]);
            }
        }
        ;
        component._addHookBase(prop, hook);
        hook();

        if (opts.asMeta)
            return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
        else
            return $ipt;
    }

    static _getIptDecoratedMeta(component, prop, $ipt, hook, opts) {
        const out = {
            $ipt,
            unhook: ()=>component._removeHookBase(prop, hook)
        };

        if (opts.decorationLeft || opts.decorationRight) {
            let $decorLeft;
            let $decorRight;

            if (opts.decorationLeft) {
                $ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--left`);
                $decorLeft = ComponentUiUtil._$getDecor(component, prop, $ipt, opts.decorationLeft, "left", opts);
            }

            if (opts.decorationRight) {
                $ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--right`);
                $decorRight = ComponentUiUtil._$getDecor(component, prop, $ipt, opts.decorationRight, "right", opts);
            }

            out.$wrp = $$`<div class="relative w-100">${$ipt}${$decorLeft}${$decorRight}</div>`;
        }

        return out;
    }

    static _$getDecor(component, prop, $ipt, decorType, side, opts) {
        switch (decorType) {
        case "search":
            {
                return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>`);
            }
        case "clear":
            {
                return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} ve-flex-vh-center clickable" title="Clear"><span class="glyphicon glyphicon-remove"></span></div>`).click(()=>$ipt.val("").change().keydown().keyup());
            }
        case "ticker":
            {
                const isValidValue = val=>{
                    if (opts.max != null && val > opts.max)
                        return false;
                    if (opts.min != null && val < opts.min)
                        return false;
                    return true;
                }
                ;

                const handleClick = (delta)=>{
                    const nxt = component._state[prop] + delta;
                    if (!isValidValue(nxt))
                        return;
                    component._state[prop] = nxt;
                    $ipt.focus();
                }
                ;

                const $btnUp = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">+</button>`).click(()=>handleClick(1));

                const $btnDown = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">\u2012</button>`).click(()=>handleClick(-1));

                return $$`<div class="ui-ideco__wrp ui-ideco__wrp--${side} ve-flex-vh-center ve-flex-col">
					${$btnUp}
					${$btnDown}
				</div>`;
            }
        case "spacer":
            {
                return "";
            }
        default:
            throw new Error(`Unimplemented!`);
        }
    }

    static $getIptEntries(component, prop, opts) {
        opts = opts || {};

        const $ipt = (opts.$ele || $(`<textarea class="form-control input-xs form-control--minimal resize-vertical"></textarea>`)).keydown(evt=>{
            if (evt.key === "Escape")
                $ipt.blur();
        }
        ).change(()=>component._state[prop] = UiUtil$1.getTextAsEntries($ipt.val().trim()));
        const hook = ()=>$ipt.val(UiUtil$1.getEntriesAsText(component._state[prop]));
        component._addHookBase(prop, hook);
        hook();
        return $ipt;
    }

    static $getIptColor(component, prop, opts) {
        opts = opts || {};

        const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal ui__ipt-color" type="color">`)).change(()=>component._state[prop] = $ipt.val());
        const hook = ()=>$ipt.val(component._state[prop]);
        component._addHookBase(prop, hook);
        hook();
        return $ipt;
    }

    static getBtnBool(component, prop, opts) {
        opts = opts || {};

        let ele = opts.ele;
        if (opts.html)
            ele = e_({
                outer: opts.html
            });

        const activeClass = opts.activeClass || "active";
        const stateName = opts.stateName || "state";
        const stateProp = opts.stateProp || `_${stateName}`;

        const btn = (ele ? e_({
            ele
        }) : e_({
            ele: ele,
            tag: "button",
            clazz: "btn btn-xs btn-default",
            text: opts.text || "Toggle",
        })).onClick(()=>component[stateProp][prop] = !component[stateProp][prop]).onContextmenu(evt=>{
            evt.preventDefault();
            component[stateProp][prop] = !component[stateProp][prop];
        }
        );

        const hk = ()=>{
            btn.toggleClass(activeClass, opts.isInverted ? !component[stateProp][prop] : !!component[stateProp][prop]);
            if (opts.activeTitle || opts.inactiveTitle)
                btn.title(component[stateProp][prop] ? (opts.activeTitle || opts.title || "") : (opts.inactiveTitle || opts.title || ""));
            if (opts.fnHookPost)
                opts.fnHookPost(component[stateProp][prop]);
        }
        ;
        component._addHook(stateName, prop, hk);
        hk();

        return btn;
    }

    static $getBtnBool(component, prop, opts) {
        const nxtOpts = {
            ...opts
        };
        if (nxtOpts.$ele) {
            nxtOpts.ele = nxtOpts.$ele[0];
            delete nxtOpts.$ele;
        }
        return $(this.getBtnBool(component, prop, nxtOpts));
    }

    static $getCbBool(component, prop, opts) {
        opts = opts || {};

        const stateName = opts.stateName || "state";
        const stateProp = opts.stateProp || `_${stateName}`;

        const cb = e_({
            tag: "input",
            type: "checkbox",
            keydown: evt=>{
                if (evt.key === "Escape")
                    cb.blur();
            }
            ,
            change: ()=>{
                if (opts.isTreatIndeterminateNullAsPositive && component[stateProp][prop] == null) {
                    component[stateProp][prop] = false;
                    return;
                }

                component[stateProp][prop] = cb.checked;
            }
            ,
        });

        const hook = ()=>{
            cb.checked = !!component[stateProp][prop];
            if (opts.isDisplayNullAsIndeterminate)
                cb.indeterminate = component[stateProp][prop] == null;
        }
        ;
        component._addHook(stateName, prop, hook);
        hook();

        const $cb = $(cb);

        return opts.asMeta ? ({
            $cb,
            unhook: ()=>component._removeHook(stateName, prop, hook)
        }) : $cb;
    }

    /**Create a dropdown menu with options to click on (used to create a class dropdown menu at least) */
    static $getSelSearchable(comp, prop, opts) {
        opts = opts || {};

        //UI Dropdown element
        const $iptDisplay = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
        .addClass("ui-sel2__ipt-display").attr("tabindex", "-1").click(()=>{
            if (opts.isDisabled){return;}
            $iptSearch.focus().select();
        }
        ).prop("disabled", !!opts.isDisabled);
        //$iptDisplay.disableSpellcheck();
        $iptDisplay.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");

        const handleSearchChange = ()=>{
            const cleanTerm = this._$getSelSearchable_getSearchString($iptSearch.val());
            metaOptions.forEach(it=>{
                it.isVisible = it.searchTerm.includes(cleanTerm);
                it.$ele.toggleVe(it.isVisible && !it.isForceHidden);
            }
            );
        };

        const handleSearchChangeDebounced = MiscUtil.debounce(handleSearchChange, 30);

        const $iptSearch = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`)).addClass("absolute ui-sel2__ipt-search").keydown(evt=>{
            if (opts.isDisabled)
                return;

            switch (evt.key) {
            case "Escape":
                evt.stopPropagation();
                return $iptSearch.blur();

            case "ArrowDown":
                {
                    evt.preventDefault();
                    const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                    if (!visibleMetaOptions.length)
                        return;
                    visibleMetaOptions[0].$ele.focus();
                    break;
                }

            case "Enter":
            case "Tab":
                {
                    const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                    if (!visibleMetaOptions.length)
                        return;
                    comp._state[prop] = visibleMetaOptions[0].value;
                    $iptSearch.blur();
                    break;
                }

            default:
                handleSearchChangeDebounced();
            }
        }
        ).change(()=>handleSearchChangeDebounced()).click(()=>{
            if (opts.isDisabled)
                return;
            $iptSearch.focus().select();
        }
        ).prop("disabled", !!opts.isDisabled)//.disableSpellcheck();
        .attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");

        //This object will be the parent of our choices in the dropdown menu
        const $wrpChoices = $(`<div class="absolute ui-sel2__wrp-options overflow-y-scroll"></div>`);
        const $wrp = $(`<div class="ve-flex relative ui-sel2__wrp w-100 overflow-x-vis">
			${$iptDisplay[0].outerHTML}
			${$iptSearch[0].outerHTML}
		</div>`);

        

        const procValues = opts.isAllowNull ? [null, ...opts.values] : opts.values;
        //Create dropdown options here
        const metaOptions = procValues.map((v,i)=>{
            const display = v == null ? (opts.displayNullAs || "\u2014") : opts.fnDisplay ? opts.fnDisplay(v) : v;
            const additionalStyleClasses = opts.fnGetAdditionalStyleClasses ? opts.fnGetAdditionalStyleClasses(v) : null;

            //V is an index that points to a class

            //Here we create an option in the dropdown menu
            const $ele = $(`<div class="ve-flex-v-center py-1 px-1 clickable ui-sel2__disp-option
                ${v == null ? `italic` : ""} ${additionalStyleClasses ? additionalStyleClasses.join(" ") : ""}" tabindex="0">${display}</div>`)
            .click(()=>{ //When an option is clicked
                console.log("BTN CLICKED");
                if (opts.isDisabled){return;}
                //here is where _state first gets set with the [propIxClass] thingy
                //this should probably trigger an event (because _state is a proxy and can run events when something is setted)
                comp._state[prop] = v; 
                $(document.activeElement).blur();
                $wrp.addClass("no-events");
                setTimeout(()=>$wrp.removeClass("no-events"), 50);
            })
            .keydown(evt=>{
                if (opts.isDisabled)
                    return;

                switch (evt.key) {
                case "Escape":
                    evt.stopPropagation();
                    return $ele.blur();

                case "ArrowDown":
                    {
                        evt.preventDefault();
                        const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                        if (!visibleMetaOptions.length)
                            return;
                        const ixCur = visibleMetaOptions.indexOf(out);
                        const nxt = visibleMetaOptions[ixCur + 1];
                        if (nxt)
                            nxt.$ele.focus();
                        break;
                    }

                case "ArrowUp":
                    {
                        evt.preventDefault();
                        const visibleMetaOptions = metaOptions.filter(it=>it.isVisible && !it.isForceHidden);
                        if (!visibleMetaOptions.length)
                            return;
                        const ixCur = visibleMetaOptions.indexOf(out);
                        const prev = visibleMetaOptions[ixCur - 1];
                        if (prev)
                            return prev.$ele.focus();
                        $iptSearch.focus();
                        break;
                    }

                case "Enter":
                    {
                        comp._state[prop] = v;
                        $ele.blur();
                        break;
                    }
                }
            }
            ).appendTo($wrpChoices);


            //TEMPFIX
            const isForceHidden = false; //opts.isHiddenPerValue && !!(opts.isAllowNull ? opts.isHiddenPerValue[i - 1] : opts.isHiddenPerValue[i]);
            if (isForceHidden){$ele.hideVe();}
            
            
        
            $wrp.append($wrpChoices);

            const out = {
                value: v,
                isVisible: true,
                isForceHidden,
                searchTerm: this._$getSelSearchable_getSearchString(display),
                $ele,
            };
            
            return out;
        });

        const fnUpdateHidden = (isHiddenPerValue,isHideNull=false)=>{
            let metaOptions_ = metaOptions;

            if (opts.isAllowNull) {
                metaOptions_[0].isForceHidden = isHideNull;
                metaOptions_ = metaOptions_.slice(1);
            }

            metaOptions_.forEach((it,i)=>it.isForceHidden = !!isHiddenPerValue[i]);
            handleSearchChange();
        };

        const hk = ()=>{
            if (comp._state[prop] == null)
                $iptDisplay.addClass("italic").addClass("ve-muted").val(opts.displayNullAs || "\u2014");
            else
                $iptDisplay.removeClass("italic").removeClass("ve-muted").val(opts.fnDisplay ? opts.fnDisplay(comp._state[prop]) : comp._state[prop]);

            metaOptions.forEach(it=>it.$ele.removeClass("active"));
            const metaActive = metaOptions.find(it=>it.value == null ? comp._state[prop] == null : it.value === comp._state[prop]);
            if (metaActive)
                metaActive.$ele.addClass("active");
        };
        comp._addHookBase(prop, hk);
        hk();
        
        const arrow = $(`<div class="ui-sel2__disp-arrow absolute no-events bold">
            <span class="glyphicon glyphicon-menu-down"></span>
        </div>`);
        $wrp.append(arrow);

        return opts.asMeta ? ({
            $wrp,
            unhook: ()=>comp._removeHookBase(prop, hk),
            $iptDisplay,
            $iptSearch,
            fnUpdateHidden,
        }) : $wrp;
    }

    static _$getSelSearchable_getSearchString(str) {
        if (str == null)
            return "";
        return CleanUtil.getCleanString(str.trim().toLowerCase().replace(/\s+/g, " "));
    }

    static $getSelEnum(component, prop, {values, $ele, html, isAllowNull, fnDisplay, displayNullAs, asMeta, propProxy="state", isSetIndexes=false}={}) {
        const _propProxy = `_${propProxy}`;

        let values_;

        let $sel = $ele || (html ? $(html) : null);
        if (!$sel) {
            const sel = document.createElement("select");
            sel.className = "form-control input-xs";
            $sel = $(sel);
        }

        $sel.change(()=>{
            const ix = Number($sel.val());
            if (~ix)
                return void (component[_propProxy][prop] = isSetIndexes ? ix : values_[ix]);

            if (isAllowNull)
                return void (component[_propProxy][prop] = null);
            component[_propProxy][prop] = isSetIndexes ? 0 : values_[0];
        }
        );

        const setValues_handleResetOnMissing = ({isResetOnMissing, nxtValues})=>{
            if (!isResetOnMissing)
                return;

            if (component[_propProxy][prop] == null)
                return;

            if (isSetIndexes) {
                if (component[_propProxy][prop] >= 0 && component[_propProxy][prop] < nxtValues.length) {
                    if (isAllowNull)
                        return component[_propProxy][prop] = null;
                    return component[_propProxy][prop] = 0;
                }

                return;
            }

            if (!nxtValues.includes(component[_propProxy][prop])) {
                if (isAllowNull)
                    return component[_propProxy][prop] = null;
                return component[_propProxy][prop] = nxtValues[0];
            }
        }
        ;

        const setValues = (nxtValues,{isResetOnMissing=false, isForce=false}={})=>{
            if (!isForce && CollectionUtil.deepEquals(values_, nxtValues))
                return;
            values_ = nxtValues;
            $sel.empty();
            if (isAllowNull) {
                const opt = document.createElement("option");
                opt.value = "-1";
                opt.text = displayNullAs || "\u2014";
                $sel.append(opt);
            }
            values_.forEach((it,i)=>{
                const opt = document.createElement("option");
                opt.value = `${i}`;
                opt.text = fnDisplay ? fnDisplay(it) : it;
                $sel.append(opt);
            }
            );

            setValues_handleResetOnMissing({
                isResetOnMissing,
                nxtValues
            });

            hook();
        }
        ;

        const hook = ()=>{
            if (isSetIndexes) {
                const ix = component[_propProxy][prop] == null ? -1 : component[_propProxy][prop];
                $sel.val(`${ix}`);
                return;
            }

            const searchFor = component[_propProxy][prop] === undefined ? null : component[_propProxy][prop];
            const ix = values_.indexOf(searchFor);
            $sel.val(`${ix}`);
        }
        ;
        component._addHookBase(prop, hook);

        setValues(values);

        if (!asMeta)
            return $sel;

        return {
            $sel,
            unhook: ()=>component._removeHookBase(prop, hook),
            setValues,
        };
    }

    static $getPickEnum(component, prop, opts) {
        return this._$getPickEnumOrString(component, prop, opts);
    }

    static $getPickString(component, prop, opts) {
        return this._$getPickEnumOrString(component, prop, {
            ...opts,
            isFreeText: true
        });
    }

    static _$getPickEnumOrString(component, prop, opts) {
        opts = opts || {};

        const getSubcompValues = ()=>{
            const initialValuesArray = (opts.values || []).concat(opts.isFreeText ? MiscUtil.copyFast((component._state[prop] || [])) : []);
            const initialValsCompWith = opts.isCaseInsensitive ? component._state[prop].map(it=>it.toLowerCase()) : component._state[prop];
            return initialValuesArray.map(v=>opts.isCaseInsensitive ? v.toLowerCase() : v).mergeMap(v=>({
                [v]: component._state[prop] && initialValsCompWith.includes(v)
            }));
        }
        ;

        const initialVals = getSubcompValues();

        let $btnAdd;
        if (opts.isFreeText) {
            $btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add ml-auto">+</button>`).click(async()=>{
                const input = await InputUiUtil$1.pGetUserString();
                if (input == null || input === VeCt.SYM_UI_SKIP)
                    return;
                const inputClean = opts.isCaseInsensitive ? input.trim().toLowerCase() : input.trim();
                pickComp.getPod().set(inputClean, true);
            }
            );
        } else {
            const menu = ContextUtil.getMenu(opts.values.map(it=>new ContextUtil.Action(opts.fnDisplay ? opts.fnDisplay(it) : it,()=>pickComp.getPod().set(it, true),)));

            $btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add">+</button>`).click(evt=>ContextUtil.pOpenMenu(evt, menu));
        }

        const pickComp = BaseComponent$1.fromObject(initialVals);
        pickComp.render = function($parent) {
            $parent.empty();

            Object.entries(this._state).forEach(([k,v])=>{
                if (v === false)
                    return;

                const $btnRemove = $(`<button class="btn btn-danger ui-pick__btn-remove ve-text-center">×</button>`).click(()=>this._state[k] = false);
                const txt = `${opts.fnDisplay ? opts.fnDisplay(k) : k}`;
                $$`<div class="ve-flex mx-1 mb-1 ui-pick__disp-pill max-w-100 min-w-0"><div class="px-1 ui-pick__disp-text ve-flex-v-center text-clip-ellipsis" title="${txt.qq()}">${txt}</div>${$btnRemove}</div>`.appendTo($parent);
            }
            );
        }
        ;

        const $wrpPills = $(`<div class="ve-flex ve-flex-wrap max-w-100 min-w-0"></div>`);
        const $wrp = $$`<div class="ve-flex-v-center w-100">${$btnAdd}${$wrpPills}</div>`;
        pickComp._addHookAll("state", ()=>{
            component._state[prop] = Object.keys(pickComp._state).filter(k=>pickComp._state[k]);
            pickComp.render($wrpPills);
        }
        );
        pickComp.render($wrpPills);

        const hkParent = ()=>pickComp._proxyAssignSimple("state", getSubcompValues(), true);
        component._addHookBase(prop, hkParent);

        return $wrp;
    }

    static $getCbsEnum(component, prop, opts) {
        opts = opts || {};

        const $wrp = $(`<div class="ve-flex-col w-100"></div>`);
        const metas = opts.values.map(it=>{
            const $cb = $(`<input type="checkbox">`).keydown(evt=>{
                if (evt.key === "Escape")
                    $cb.blur();
            }
            ).change(()=>{
                let didUpdate = false;
                const ix = (component._state[prop] || []).indexOf(it);
                if (~ix)
                    component._state[prop].splice(ix, 1);
                else {
                    if (component._state[prop])
                        component._state[prop].push(it);
                    else {
                        didUpdate = true;
                        component._state[prop] = [it];
                    }
                }
                if (!didUpdate)
                    component._state[prop] = [...component._state[prop]];
            }
            );

            $$`<label class="split-v-center my-1 stripe-odd ${opts.isIndent ? "ml-4" : ""}"><div class="no-wrap ve-flex-v-center">${opts.fnDisplay ? opts.fnDisplay(it) : it}</div>${$cb}</label>`.appendTo($wrp);

            return {
                $cb,
                value: it
            };
        }
        );

        const hook = ()=>metas.forEach(meta=>meta.$cb.prop("checked", component._state[prop] && component._state[prop].includes(meta.value)));
        component._addHookBase(prop, hook);
        hook();

        return opts.asMeta ? {
            $wrp,
            unhook: ()=>component._removeHookBase(prop, hook)
        } : $wrp;
    }

    static getMetaWrpMultipleChoice(comp, prop, opts) {
        opts = opts || {};
        this._getMetaWrpMultipleChoice_doValidateOptions(opts);

        const rowMetas = [];
        const $eles = [];
        const ixsSelectionOrder = [];
        const $elesSearchable = {};

        const propIsAcceptable = this.getMetaWrpMultipleChoice_getPropIsAcceptable(prop);
        const propPulse = this.getMetaWrpMultipleChoice_getPropPulse(prop);
        const propIxMax = this._getMetaWrpMultipleChoice_getPropValuesLength(prop);

        const cntRequired = ((opts.required || []).length) + ((opts.ixsRequired || []).length);
        const count = opts.count != null ? opts.count - cntRequired : null;
        const countIncludingRequired = opts.count != null ? count + cntRequired : null;
        const min = opts.min != null ? opts.min - cntRequired : null;
        const max = opts.max != null ? opts.max - cntRequired : null;

        const valueGroups = opts.valueGroups || [{
            values: opts.values
        }];

        let ixValue = 0;
        valueGroups.forEach((group,i)=>{
            if (i !== 0)
                $eles.push($(`<hr class="w-100 hr-2 hr--dotted">`));

            if (group.name) {
                const $wrpName = $$`<div class="split-v-center py-1">
					<div class="ve-flex-v-center"><span class="mr-2">‒</span><span>${group.name}</span></div>
					${opts.valueGroupSplitControlsLookup?.[group.name]}
				</div>`;
                $eles.push($wrpName);
            }

            if (group.text)
                $eles.push($(`<div class="ve-flex-v-center py-1"><div class="ml-1 mr-3"></div><i>${group.text}</i></div>`));

            group.values.forEach(v=>{
                const ixValueFrozen = ixValue;

                const propIsActive = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixValueFrozen);
                const propIsRequired = this.getMetaWrpMultipleChoice_getPropIsRequired(prop, ixValueFrozen);

                const isHardRequired = (opts.required && opts.required.includes(v)) || (opts.ixsRequired && opts.ixsRequired.includes(ixValueFrozen));
                const isRequired = isHardRequired || comp._state[propIsRequired];

                if (comp._state[propIsActive] && !comp._state[propIsRequired])
                    ixsSelectionOrder.push(ixValueFrozen);

                let hk;
                const $cb = isRequired ? $(`<input type="checkbox" disabled checked title="This option is required.">`) : ComponentUiUtil.$getCbBool(comp, propIsActive);

                if (isRequired)
                    comp._state[propIsActive] = true;

                if (!isRequired) {
                    hk = ()=>{
                        const ixIx = ixsSelectionOrder.findIndex(it=>it === ixValueFrozen);
                        if (~ixIx)
                            ixsSelectionOrder.splice(ixIx, 1);
                        if (comp._state[propIsActive])
                            ixsSelectionOrder.push(ixValueFrozen);

                        const activeRows = rowMetas.filter(it=>comp._state[it.propIsActive]);

                        if (count != null) {
                            if (activeRows.length > countIncludingRequired) {
                                const ixFirstSelected = ixsSelectionOrder.splice(ixsSelectionOrder.length - 2, 1)[0];
                                if (ixFirstSelected != null) {
                                    const propIsActiveOther = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixFirstSelected);
                                    comp._state[propIsActiveOther] = false;

                                    comp._state[propPulse] = !comp._state[propPulse];
                                }
                                return;
                            }
                        }

                        let isAcceptable = false;
                        if (count != null) {
                            if (activeRows.length === countIncludingRequired)
                                isAcceptable = true;
                        } else {
                            if (activeRows.length >= (min || 0) && activeRows.length <= (max || Number.MAX_SAFE_INTEGER))
                                isAcceptable = true;
                        }

                        comp._state[propIsAcceptable] = isAcceptable;

                        comp._state[propPulse] = !comp._state[propPulse];
                    }
                    ;
                    comp._addHookBase(propIsActive, hk);
                    hk();
                }

                const displayValue = opts.fnDisplay ? opts.fnDisplay(v, ixValueFrozen) : v;

                rowMetas.push({
                    $cb,
                    displayValue,
                    value: v,
                    propIsActive,
                    unhook: ()=>{
                        if (hk)
                            comp._removeHookBase(propIsActive, hk);
                    }
                    ,
                });

                const $ele = $$`<label class="ve-flex-v-center py-1 stripe-even">
					<div class="col-1 ve-flex-vh-center">${$cb}</div>
					<div class="col-11 ve-flex-v-center">${displayValue}</div>
				</label>`;
                $eles.push($ele);

                if (opts.isSearchable) {
                    const searchText = `${opts.fnGetSearchText ? opts.fnGetSearchText(v, ixValueFrozen) : v}`.toLowerCase().trim();
                    ($elesSearchable[searchText] = $elesSearchable[searchText] || []).push($ele);
                }

                ixValue++;
            }
            );
        }
        );

        ixsSelectionOrder.sort((a,b)=>SortUtil.ascSort(a, b));

        comp.__state[propIxMax] = ixValue;

        let $iptSearch;
        if (opts.isSearchable) {
            const compSub = BaseComponent$1.fromObject({
                search: ""
            });
            $iptSearch = ComponentUiUtil.$getIptStr(compSub, "search");
            const hkSearch = ()=>{
                const cleanSearch = compSub._state.search.trim().toLowerCase();
                if (!cleanSearch) {
                    Object.values($elesSearchable).forEach($eles=>$eles.forEach($ele=>$ele.removeClass("ve-hidden")));
                    return;
                }

                Object.entries($elesSearchable).forEach(([searchText,$eles])=>$eles.forEach($ele=>$ele.toggleVe(searchText.includes(cleanSearch))));
            }
            ;
            compSub._addHookBase("search", hkSearch);
            hkSearch();
        }

        const unhook = ()=>rowMetas.forEach(it=>it.unhook());
        return {
            $ele: $$`<div class="ve-flex-col w-100 overflow-y-auto">${$eles}</div>`,
            $iptSearch,
            rowMetas,
            propIsAcceptable,
            propPulse,
            unhook,
            cleanup: ()=>{
                unhook();
                Object.keys(comp._state).filter(it=>it.startsWith(`${prop}__`)).forEach(it=>delete comp._state[it]);
            }
            ,
        };
    }

    static getMetaWrpMultipleChoice_getPropIsAcceptable(prop) {
        return `${prop}__isAcceptable`;
    }
    static getMetaWrpMultipleChoice_getPropPulse(prop) {
        return `${prop}__pulse`;
    }
    static _getMetaWrpMultipleChoice_getPropValuesLength(prop) {
        return `${prop}__length`;
    }
    static getMetaWrpMultipleChoice_getPropIsActive(prop, ixValue) {
        return `${prop}__isActive_${ixValue}`;
    }
    static getMetaWrpMultipleChoice_getPropIsRequired(prop, ixValue) {
        return `${prop}__isRequired_${ixValue}`;
    }

    static getMetaWrpMultipleChoice_getSelectedIxs(comp, prop) {
        const out = [];
        const len = comp._state[this._getMetaWrpMultipleChoice_getPropValuesLength(prop)] || 0;
        for (let i = 0; i < len; ++i) {
            if (comp._state[this.getMetaWrpMultipleChoice_getPropIsActive(prop, i)])
                out.push(i);
        }
        return out;
    }

    static getMetaWrpMultipleChoice_getSelectedValues(comp, prop, {values, valueGroups}) {
        const selectedIxs = this.getMetaWrpMultipleChoice_getSelectedIxs(comp, prop);
        if (values)
            return selectedIxs.map(ix=>values[ix]);

        const selectedIxsSet = new Set(selectedIxs);
        const out = [];
        let ixValue = 0;
        valueGroups.forEach(group=>{
            group.values.forEach(v=>{
                if (selectedIxsSet.has(ixValue))
                    out.push(v);
                ixValue++;
            }
            );
        }
        );
        return out;
    }

    static _getMetaWrpMultipleChoice_doValidateOptions(opts) {
        if ((Number(!!opts.values) + Number(!!opts.valueGroups)) !== 1)
            throw new Error(`Exactly one of "values" and "valueGroups" must be specified!`);

        if (opts.count != null && (opts.min != null || opts.max != null))
            throw new Error(`Chooser must be either in "count" mode or "min/max" mode!`);
        if (opts.count == null && opts.min == null && opts.max == null)
            opts.count = 1;
    }

    static $getSliderRange(comp, opts) {
        opts = opts || {};
        const slider = new ComponentUiUtil.RangeSlider({
            comp,
            ...opts
        });
        return slider.$get();
    }

    static $getSliderNumber(comp, prop, {min, max, step, $ele, asMeta, }={}, ) {
        const $slider = ($ele || $(`<input type="range">`)).change(()=>comp._state[prop] = Number($slider.val()));

        if (min != null)
            $slider.attr("min", min);
        if (max != null)
            $slider.attr("max", max);
        if (step != null)
            $slider.attr("step", step);

        const hk = ()=>$slider.val(comp._state[prop]);
        comp._addHookBase(prop, hk);
        hk();

        return asMeta ? ({
            $slider,
            unhook: ()=>comp._removeHookBase(prop, hk)
        }) : $slider;
    }
}

ComponentUiUtil.RangeSlider = class {
    constructor({comp, propMin, propMax, propCurMin, propCurMax, fnDisplay, fnDisplayTooltip, sparseValues, }, ) {
        this._comp = comp;
        this._propMin = propMin;
        this._propMax = propMax;
        this._propCurMin = propCurMin;
        this._propCurMax = propCurMax;
        this._fnDisplay = fnDisplay;
        this._fnDisplayTooltip = fnDisplayTooltip;
        this._sparseValues = sparseValues;

        this._isSingle = !this._propCurMax;

        const compCpyState = {
            [this._propMin]: this._comp._state[this._propMin],
            [this._propCurMin]: this._comp._state[this._propCurMin],
            [this._propMax]: this._comp._state[this._propMax],
        };
        if (!this._isSingle)
            compCpyState[this._propCurMax] = this._comp._state[this._propCurMax];
        this._compCpy = BaseComponent$1.fromObject(compCpyState);

        this._comp._addHook("state", this._propMin, ()=>this._compCpy._state[this._propMin] = this._comp._state[this._propMin]);
        this._comp._addHook("state", this._propCurMin, ()=>this._compCpy._state[this._propCurMin] = this._comp._state[this._propCurMin]);
        this._comp._addHook("state", this._propMax, ()=>this._compCpy._state[this._propMax] = this._comp._state[this._propMax]);

        if (!this._isSingle)
            this._comp._addHook("state", this._propCurMax, ()=>this._compCpy._state[this._propCurMax] = this._comp._state[this._propCurMax]);

        this._cacheRendered = null;
        this._dispTrackOuter = null;
        this._dispTrackInner = null;
        this._thumbLow = null;
        this._thumbHigh = null;
        this._dragMeta = null;
    }

    $get() {
        const out = this.get();
        return $(out);
    }

    get() {
        this.constructor._init();
        this.constructor._ALL_SLIDERS.add(this);

        if (this._cacheRendered)
            return this._cacheRendered;

        const dispValueLeft = this._isSingle ? this._getSpcSingleValue() : this._getDispValue({
            isVisible: true,
            side: "left"
        });
        const dispValueRight = this._getDispValue({
            isVisible: true,
            side: "right"
        });

        this._dispTrackInner = this._isSingle ? null : e_({
            tag: "div",
            clazz: "ui-slidr__track-inner h-100 absolute",
        });

        this._thumbLow = this._getThumb();
        this._thumbHigh = this._isSingle ? null : this._getThumb();

        this._dispTrackOuter = e_({
            tag: "div",
            clazz: `relative w-100 ui-slidr__track-outer`,
            children: [this._dispTrackInner, this._thumbLow, this._thumbHigh, ].filter(Boolean),
        });

        const wrpTrack = e_({
            tag: "div",
            clazz: `ve-flex-v-center w-100 h-100 ui-slidr__wrp-track clickable`,
            mousedown: evt=>{
                const thumb = this._getClosestThumb(evt);
                this._handleMouseDown(evt, thumb);
            }
            ,
            children: [this._dispTrackOuter, ],
        });

        const wrpTop = e_({
            tag: "div",
            clazz: "ve-flex-v-center w-100 ui-slidr__wrp-top",
            children: [dispValueLeft, wrpTrack, dispValueRight, ].filter(Boolean),
        });

        const wrpPips = e_({
            tag: "div",
            clazz: `w-100 ve-flex relative clickable h-100 ui-slidr__wrp-pips`,
            mousedown: evt=>{
                const thumb = this._getClosestThumb(evt);
                this._handleMouseDown(evt, thumb);
            }
            ,
        });

        const wrpBottom = e_({
            tag: "div",
            clazz: "w-100 ve-flex-vh-center ui-slidr__wrp-bottom",
            children: [this._isSingle ? this._getSpcSingleValue() : this._getDispValue({
                side: "left"
            }), wrpPips, this._getDispValue({
                side: "right"
            }), ].filter(Boolean),
        });

        const hkChangeValue = ()=>{
            const curMin = this._compCpy._state[this._propCurMin];
            const pctMin = this._getLeftPositionPercentage({
                value: curMin
            });
            this._thumbLow.style.left = `calc(${pctMin}% - ${this.constructor._W_THUMB_PX / 2}px)`;
            const toDisplayLeft = this._fnDisplay ? `${this._fnDisplay(curMin)}`.qq() : curMin;
            const toDisplayLeftTooltip = this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMin)}`.qq() : null;
            if (!this._isSingle) {
                dispValueLeft.html(toDisplayLeft).tooltip(toDisplayLeftTooltip);
            }

            if (!this._isSingle) {
                this._dispTrackInner.style.left = `${pctMin}%`;

                const curMax = this._compCpy._state[this._propCurMax];
                const pctMax = this._getLeftPositionPercentage({
                    value: curMax
                });
                this._dispTrackInner.style.right = `${100 - pctMax}%`;
                this._thumbHigh.style.left = `calc(${pctMax}% - ${this.constructor._W_THUMB_PX / 2}px)`;
                dispValueRight.html(this._fnDisplay ? `${this._fnDisplay(curMax)}`.qq() : curMax).tooltip(this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMax)}`.qq() : null);
            } else {
                dispValueRight.html(toDisplayLeft).tooltip(toDisplayLeftTooltip);
            }
        }
        ;

        const hkChangeLimit = ()=>{
            const pips = [];

            if (!this._sparseValues) {
                const numPips = this._compCpy._state[this._propMax] - this._compCpy._state[this._propMin];
                let pipIncrement = 1;
                if (numPips > ComponentUiUtil.RangeSlider._MAX_PIPS)
                    pipIncrement = Math.ceil(numPips / ComponentUiUtil.RangeSlider._MAX_PIPS);

                let i, len;
                for (i = this._compCpy._state[this._propMin],
                len = this._compCpy._state[this._propMax] + 1; i < len; i += pipIncrement) {
                    pips.push(this._getWrpPip({
                        isMajor: i === this._compCpy._state[this._propMin] || i === (len - 1),
                        value: i,
                    }));
                }

                if (i !== this._compCpy._state[this._propMax])
                    pips.push(this._getWrpPip({
                        isMajor: true,
                        value: this._compCpy._state[this._propMax]
                    }));
            } else {
                const len = this._sparseValues.length;
                this._sparseValues.forEach((val,i)=>{
                    pips.push(this._getWrpPip({
                        isMajor: i === 0 || i === (len - 1),
                        value: val,
                    }));
                }
                );
            }

            wrpPips.empty();
            e_({
                ele: wrpPips,
                children: pips,
            });

            hkChangeValue();
        }
        ;

        this._compCpy._addHook("state", this._propMin, hkChangeLimit);
        this._compCpy._addHook("state", this._propMax, hkChangeLimit);
        this._compCpy._addHook("state", this._propCurMin, hkChangeValue);
        if (!this._isSingle)
            this._compCpy._addHook("state", this._propCurMax, hkChangeValue);

        hkChangeLimit();

        const wrp = e_({
            tag: "div",
            clazz: "ve-flex-col w-100 ui-slidr__wrp",
            children: [wrpTop, wrpBottom, ],
        });

        return this._cacheRendered = wrp;
    }

    destroy() {
        this.constructor._ALL_SLIDERS.delete(this);
        if (this._cacheRendered)
            this._cacheRendered.remove();
    }

    _getDispValue({isVisible, side}) {
        return e_({
            tag: "div",
            clazz: `overflow-hidden ui-slidr__disp-value no-shrink no-grow ve-flex-vh-center bold no-select ${isVisible ? `ui-slidr__disp-value--visible` : ""} ui-slidr__disp-value--${side}`,
        });
    }

    _getSpcSingleValue() {
        return e_({
            tag: "div",
            clazz: `px-2`,
        });
    }

    _getThumb() {
        const thumb = e_({
            tag: "div",
            clazz: "ui-slidr__thumb absolute clickable",
            mousedown: evt=>this._handleMouseDown(evt, thumb),
        }).attr("draggable", true);

        return thumb;
    }

    _getWrpPip({isMajor, value}={}) {
        const style = this._getWrpPip_getStyle({
            value
        });

        const pip = e_({
            tag: "div",
            clazz: `ui-slidr__pip ${isMajor ? `ui-slidr__pip--major` : `absolute`}`,
        });

        const dispLabel = e_({
            tag: "div",
            clazz: "absolute ui-slidr__pip-label ve-flex-vh-center ve-small no-wrap",
            html: isMajor ? this._fnDisplay ? `${this._fnDisplay(value)}`.qq() : value : "",
            title: isMajor && this._fnDisplayTooltip ? `${this._fnDisplayTooltip(value)}`.qq() : null,
        });

        return e_({
            tag: "div",
            clazz: "ve-flex-col ve-flex-vh-center absolute no-select",
            children: [pip, dispLabel, ],
            style,
        });
    }

    _getWrpPip_getStyle({value}) {
        return `left: ${this._getLeftPositionPercentage({
            value
        })}%`;
    }

    _getLeftPositionPercentage({value}) {
        if (this._sparseValues) {
            const ix = this._sparseValues.sort(SortUtil.ascSort).indexOf(value);
            if (!~ix)
                throw new Error(`Value "${value}" was not in the list of sparse values!`);
            return (ix / (this._sparseValues.length - 1)) * 100;
        }

        const min = this._compCpy._state[this._propMin];
        const max = this._compCpy._state[this._propMax];
        return ((value - min) / (max - min)) * 100;
    }

    _getRelativeValue(evt, {trackOriginX, trackWidth}) {
        const xEvt = EventUtil.getClientX(evt) - trackOriginX;

        if (this._sparseValues) {
            const ixMax = this._sparseValues.length - 1;
            const rawVal = Math.round((xEvt / trackWidth) * ixMax);
            return this._sparseValues[Math.min(ixMax, Math.max(0, rawVal))];
        }

        const min = this._compCpy._state[this._propMin];
        const max = this._compCpy._state[this._propMax];

        const rawVal = min + Math.round((xEvt / trackWidth) * (max - min), );

        return Math.min(max, Math.max(min, rawVal));
    }

    _getClosestThumb(evt) {
        if (this._isSingle)
            return this._thumbLow;

        const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();
        const value = this._getRelativeValue(evt, {
            trackOriginX,
            trackWidth
        });

        if (value < this._compCpy._state[this._propCurMin])
            return this._thumbLow;
        if (value > this._compCpy._state[this._propCurMax])
            return this._thumbHigh;

        const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);
        if (distToMax < distToMin)
            return this._thumbHigh;
        return this._thumbLow;
    }

    _getDistsToCurrentMinAndMax(value) {
        if (this._isSingle)
            throw new Error(`Can not get distance to max value for singleton slider!`);

        const distToMin = Math.abs(this._compCpy._state[this._propCurMin] - value);
        const distToMax = Math.abs(this._compCpy._state[this._propCurMax] - value);
        return {
            distToMin,
            distToMax
        };
    }

    _handleClick(evt, value) {
        evt.stopPropagation();
        evt.preventDefault();

        if (value < this._compCpy._state[this._propCurMin])
            this._compCpy._state[this._propCurMin] = value;

        if (value > this._compCpy._state[this._propCurMax])
            this._compCpy._state[this._propCurMax] = value;

        const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);

        if (distToMax < distToMin)
            this._compCpy._state[this._propCurMax] = value;
        else
            this._compCpy._state[this._propCurMin] = value;
    }

    _handleMouseDown(evt, thumb) {
        evt.preventDefault();
        evt.stopPropagation();

        const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();

        thumb.addClass(`ui-slidr__thumb--hover`);

        this._dragMeta = {
            trackOriginX,
            trackWidth,
            thumb,
        };

        this._handleMouseMove(evt);
    }

    _handleMouseUp() {
        const wasActive = this._doDragCleanup();

        if (wasActive) {
            const nxtState = {
                [this._propMin]: this._compCpy._state[this._propMin],
                [this._propMax]: this._compCpy._state[this._propMax],
                [this._propCurMin]: this._compCpy._state[this._propCurMin],
            };
            if (!this._isSingle)
                nxtState[this._propCurMax] = this._compCpy._state[this._propCurMax];

            this._comp._proxyAssignSimple("state", nxtState);
        }
    }

    _handleMouseMove(evt) {
        if (!this._dragMeta)
            return;

        const val = this._getRelativeValue(evt, this._dragMeta);

        if (this._dragMeta.thumb === this._thumbLow) {
            if (val > this._compCpy._state[this._propCurMax])
                return;
            this._compCpy._state[this._propCurMin] = val;
        } else if (this._dragMeta.thumb === this._thumbHigh) {
            if (val < this._compCpy._state[this._propCurMin])
                return;
            this._compCpy._state[this._propCurMax] = val;
        }
    }

    _doDragCleanup() {
        const isActive = this._dragMeta != null;

        if (this._dragMeta?.thumb)
            this._dragMeta.thumb.removeClass(`ui-slidr__thumb--hover`);

        this._dragMeta = null;

        return isActive;
    }

    static _init() {
        if (this._isInit)
            return;
        document.addEventListener("mousemove", evt=>{
            for (const slider of this._ALL_SLIDERS) {
                slider._handleMouseMove(evt);
            }
        }
        );

        document.addEventListener("mouseup", evt=>{
            for (const slider of this._ALL_SLIDERS) {
                slider._handleMouseUp(evt);
            }
        }
        );
    }
}
;
ComponentUiUtil.RangeSlider._isInit = false;
ComponentUiUtil.RangeSlider._ALL_SLIDERS = new Set();
ComponentUiUtil.RangeSlider._W_THUMB_PX = 16;
ComponentUiUtil.RangeSlider._W_LABEL_PX = 24;
ComponentUiUtil.RangeSlider._MAX_PIPS = 40;
//#endregion

//#region FilterBox
//TEMP ProxyBase seems to just be a MixedProxyBase
class FilterBox extends ProxyBase
//extends ProxyBase
{
    static TITLE_BTN_RESET = "Reset filters. SHIFT to reset everything.";

    static selectFirstVisible(entryList) {
        if (Hist.lastLoadedId == null && !Hist.initialLoad) {
            Hist._freshLoad();
        }

    }

    constructor(opts) {
        super();

        this._$iptSearch = opts.$iptSearch;
        this._$wrpFormTop = opts.$wrpFormTop;
        this._$btnReset = opts.$btnReset;
        this._$btnOpen = opts.$btnOpen;
        this._$wrpMiniPills = opts.$wrpMiniPills;
        this._$btnToggleSummaryHidden = opts.$btnToggleSummaryHidden;
        this._filters = opts.filters;
        this._isCompact = opts.isCompact;
        this._namespace = opts.namespace;

        this._doSaveStateThrottled = MiscUtil.throttle(()=>this._pDoSaveState(), 50);
        this.__meta = this._getDefaultMeta();
        if (this._isCompact)
            this.__meta.isSummaryHidden = true;

        this._meta = this._getProxy("meta", this.__meta);
        this.__minisHidden = {};
        this._minisHidden = this._getProxy("minisHidden", this.__minisHidden);
        this.__combineAs = {};
        this._combineAs = this._getProxy("combineAs", this.__combineAs);
        this._modalMeta = null;
        this._isRendered = false;

        this._cachedState = null;

        this._compSearch = BaseComponent.fromObject({
            search: ""
        });
        this._metaIptSearch = null;

        this._filters.forEach(f=>f.filterBox = this);

        this._eventListeners = {};
    }

    get filters() {
        return this._filters;
    }

    teardown() {
        this._filters.forEach(f=>f._doTeardown());
        if (this._modalMeta)
            this._modalMeta.doTeardown();
    }

    on(identifier, fn) {
        const [eventName,namespace] = identifier.split(".");
        (this._eventListeners[eventName] = this._eventListeners[eventName] || []).push({
            namespace,
            fn
        });
        return this;
    }

    off(identifier, fn=null) {
        const [eventName,namespace] = identifier.split(".");
        this._eventListeners[eventName] = (this._eventListeners[eventName] || []).filter(it=>{
            if (fn != null)
                return it.namespace !== namespace || it.fn !== fn;
            return it.namespace !== namespace;
        }
        );
        if (!this._eventListeners[eventName].length)
            delete this._eventListeners[eventName];
        return this;
    }

    fireChangeEvent() {
        this._doSaveStateThrottled();
        this.fireEvent(FilterBox.EVNT_VALCHANGE);
    }

    fireEvent(eventName) {
        (this._eventListeners[eventName] || []).forEach(it=>it.fn());
    }

    _getNamespacedStorageKey() {
        return `${FilterBox._STORAGE_KEY}${this._namespace ? `.${this._namespace}` : ""}`;
    }
    getNamespacedHashKey(k) {
        return `${k || "_".repeat(FilterUtil.SUB_HASH_PREFIX_LENGTH)}${this._namespace ? `.${this._namespace}` : ""}`;
    }

    async pGetStoredActiveSources() {
        const stored = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
        if (stored) {
            const sourceFilterData = stored.filters[FilterBox.SOURCE_HEADER];
            if (sourceFilterData) {
                const state = sourceFilterData.state;
                const blue = [];
                const white = [];
                Object.entries(state).forEach(([src,mode])=>{
                    if (mode === 1)
                        blue.push(src);
                    else if (mode !== -1)
                        white.push(src);
                }
                );
                if (blue.length)
                    return blue;
                else
                    return white;
            }
        }
        return null;
    }

    registerMinisHiddenHook(prop, hook) {
        this._addHook("minisHidden", prop, hook);
    }

    isMinisHidden(header) {
        return !!this._minisHidden[header];
    }

    async pDoLoadState() {
        const toLoad = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
        if (toLoad == null)
            return;
        this._setStateFromLoaded(toLoad, {
            isUserSavedState: true
        });
    }

    _setStateFromLoaded(state, {isUserSavedState=false}={}) {
        state.box = state.box || {};
        this._proxyAssign("meta", "_meta", "__meta", state.box.meta || {}, true);
        this._proxyAssign("minisHidden", "_minisHidden", "__minisHidden", state.box.minisHidden || {}, true);
        this._proxyAssign("combineAs", "_combineAs", "__combineAs", state.box.combineAs || {}, true);
        this._filters.forEach(it=>it.setStateFromLoaded(state.filters, {
            isUserSavedState
        }));
    }

    _getSaveableState() {
        const filterOut = {};
        this._filters.forEach(it=>Object.assign(filterOut, it.getSaveableState()));
        return {
            box: {
                meta: {
                    ...this.__meta
                },
                minisHidden: {
                    ...this.__minisHidden
                },
                combineAs: {
                    ...this.__combineAs
                },
            },
            filters: filterOut,
        };
    }

    async _pDoSaveState() {
        await StorageUtil.pSetForPage(this._getNamespacedStorageKey(), this._getSaveableState());
    }

    trimState_() {
        this._filters.forEach(f=>f.trimState_());
    }

    render() {
        if (this._isRendered) {
            this._filters.map(f=>f.update());
            return;
        }
        this._isRendered = true;

        if (this._$wrpFormTop || this._$wrpMiniPills) {
            if (!this._$wrpMiniPills) {
                this._$wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`).insertAfter(this._$wrpFormTop);
            } else {
                this._$wrpMiniPills.addClass("fltr__mini-view");
            }
        }

        if (this._$btnReset) {
            this._$btnReset.title(FilterBox.TITLE_BTN_RESET).click((evt)=>this.reset(evt.shiftKey));
        }

        if (this._$wrpFormTop || this._$btnToggleSummaryHidden) {
            if (!this._$btnToggleSummaryHidden) {
                this._$btnToggleSummaryHidden = $(`<button class="btn btn-default ${this._isCompact ? "p-2" : ""}" title="Toggle Filter Summary"><span class="glyphicon glyphicon-resize-small"></span></button>`).prependTo(this._$wrpFormTop);
            } else if (!this._$btnToggleSummaryHidden.parent().length) {
                this._$btnToggleSummaryHidden.prependTo(this._$wrpFormTop);
            }
            this._$btnToggleSummaryHidden.click(()=>{
                this._meta.isSummaryHidden = !this._meta.isSummaryHidden;
                this._doSaveStateThrottled();
            }
            );
            const summaryHiddenHook = ()=>{
                this._$btnToggleSummaryHidden.toggleClass("active", !!this._meta.isSummaryHidden);
                this._$wrpMiniPills.toggleClass("ve-hidden", !!this._meta.isSummaryHidden);
            }
            ;
            this._addHook("meta", "isSummaryHidden", summaryHiddenHook);
            summaryHiddenHook();
        }

        if (this._$wrpFormTop || this._$btnOpen) {
            if (!this._$btnOpen) {
                this._$btnOpen = $(`<button class="btn btn-default ${this._isCompact ? "px-2" : ""}">Filter</button>`).prependTo(this._$wrpFormTop);
            } else if (!this._$btnOpen.parent().length) {
                this._$btnOpen.prependTo(this._$wrpFormTop);
            }
            this._$btnOpen.click(()=>this.show());
        }

        const sourceFilter = this._filters.find(it=>it.header === FilterBox.SOURCE_HEADER);
        if (sourceFilter) {
            const selFnAlt = (val)=>!SourceUtil.isNonstandardSource(val) && !PrereleaseUtil.hasSourceJson(val) && !BrewUtil2.hasSourceJson(val);
            const hkSelFn = ()=>{
                if (this._meta.isBrewDefaultHidden)
                    sourceFilter.setTempFnSel(selFnAlt);
                else
                    sourceFilter.setTempFnSel(null);
                sourceFilter.updateMiniPillClasses();
            }
            ;
            this._addHook("meta", "isBrewDefaultHidden", hkSelFn);
            hkSelFn();
        }

        if (this._$wrpMiniPills)
            this._filters.map((f,i)=>f.$renderMinis({
                filterBox: this,
                isFirst: i === 0,
                $wrpMini: this._$wrpMiniPills
            }));
    }

    async _render_pRenderModal() {
        this._isModalRendered = true;

        this._modalMeta = await UiUtil.pGetShowModal({
            isHeight100: true,
            isWidth100: true,
            isUncappedHeight: true,
            isIndestructible: true,
            isClosed: true,
            isEmpty: true,
            title: "Filter",
            cbClose: (isDataEntered)=>this._pHandleHide(!isDataEntered),
        });

        const $children = this._filters.map((f,i)=>f.$render({
            filterBox: this,
            isFirst: i === 0,
            $wrpMini: this._$wrpMiniPills
        }));

        this._metaIptSearch = ComponentUiUtil.$getIptStr(this._compSearch, "search", {
            decorationRight: "clear",
            asMeta: true,
            html: `<input class="form-control input-xs" placeholder="Search...">`
        }, );
        this._compSearch._addHookBase("search", ()=>{
            const searchTerm = this._compSearch._state.search.toLowerCase();
            this._filters.forEach(f=>f.handleSearch(searchTerm));
        }
        );

        const $btnShowAllFilters = $(`<button class="btn btn-xs btn-default">Show All</button>`).click(()=>this.showAllFilters());
        const $btnHideAllFilters = $(`<button class="btn btn-xs btn-default">Hide All</button>`).click(()=>this.hideAllFilters());

        const $btnReset = $(`<button class="btn btn-xs btn-default mr-3" title="${FilterBox.TITLE_BTN_RESET}">Reset</button>`).click(evt=>this.reset(evt.shiftKey));

        const $btnSettings = $(`<button class="btn btn-xs btn-default mr-3"><span class="glyphicon glyphicon-cog"></span></button>`).click(()=>this._pOpenSettingsModal());

        const $btnSaveAlt = $(`<button class="btn btn-xs btn-primary" title="Save"><span class="glyphicon glyphicon-ok"></span></button>`).click(()=>this._modalMeta.doClose(true));

        const $wrpBtnCombineFilters = $(`<div class="btn-group mr-3"></div>`);
        const $btnCombineFilterSettings = $(`<button class="btn btn-xs btn-default"><span class="glyphicon glyphicon-cog"></span></button>`).click(()=>this._pOpenCombineAsModal());

        const btnCombineFiltersAs = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default`,
            click: ()=>this._meta.modeCombineFilters = FilterBox._COMBINE_MODES.getNext(this._meta.modeCombineFilters),
            title: `"AND" requires every filter to match. "OR" requires any filter to match. "Custom" allows you to specify a combination (every "AND" filter must match; only one "OR" filter must match) .`,
        }).appendTo($wrpBtnCombineFilters[0]);

        const hook = ()=>{
            btnCombineFiltersAs.innerText = this._meta.modeCombineFilters === "custom" ? this._meta.modeCombineFilters.uppercaseFirst() : this._meta.modeCombineFilters.toUpperCase();
            if (this._meta.modeCombineFilters === "custom")
                $wrpBtnCombineFilters.append($btnCombineFilterSettings);
            else
                $btnCombineFilterSettings.detach();
            this._doSaveStateThrottled();
        }
        ;
        this._addHook("meta", "modeCombineFilters", hook);
        hook();

        const $btnSave = $(`<button class="btn btn-primary fltr__btn-close mr-2">Save</button>`).click(()=>this._modalMeta.doClose(true));

        const $btnCancel = $(`<button class="btn btn-default fltr__btn-close">Cancel</button>`).click(()=>this._modalMeta.doClose(false));

        $$(this._modalMeta.$modal)`<div class="split mb-2 mt-2 ve-flex-v-center mobile__ve-flex-col">
			<div class="ve-flex-v-baseline mobile__ve-flex-col">
				<h4 class="m-0 mr-2 mobile__mb-2">Filters</h4>
				${this._metaIptSearch.$wrp.addClass("mobile__mb-2")}
			</div>
			<div class="ve-flex-v-center mobile__ve-flex-col">
				<div class="ve-flex-v-center mobile__m-1">
					<div class="mr-2">Combine as</div>
					${$wrpBtnCombineFilters}
				</div>
				<div class="ve-flex-v-center mobile__m-1">
					<div class="btn-group mr-2 ve-flex-h-center">
						${$btnShowAllFilters}
						${$btnHideAllFilters}
					</div>
					${$btnReset}
					${$btnSettings}
					${$btnSaveAlt}
				</div>
			</div>
		</div>
		<hr class="w-100 m-0 mb-2">

		<hr class="mt-1 mb-1">
		<div class="ui-modal__scroller smooth-scroll px-1">
			${$children}
		</div>
		<hr class="my-1 w-100">
		<div class="w-100 ve-flex-vh-center my-1">${$btnSave}${$btnCancel}</div>`;
    }

    async _pOpenSettingsModal() {
        const {$modalInner} = await UiUtil.pGetShowModal({
            title: "Settings"
        });

        UiUtil.$getAddModalRowCb($modalInner, "Deselect Homebrew Sources by Default", this._meta, "isBrewDefaultHidden");

        UiUtil.addModalSep($modalInner);

        UiUtil.$getAddModalRowHeader($modalInner, "Hide summary for filter...", {
            helpText: "The summary is the small red and blue button panel which appear below the search bar."
        });
        this._filters.forEach(f=>UiUtil.$getAddModalRowCb($modalInner, f.header, this._minisHidden, f.header));

        UiUtil.addModalSep($modalInner);

        const $rowResetAlwaysSave = UiUtil.$getAddModalRow($modalInner, "div").addClass("pr-2");
        $rowResetAlwaysSave.append(`<span>Always Save on Close</span>`);
        $(`<button class="btn btn-xs btn-default">Reset</button>`).appendTo($rowResetAlwaysSave).click(async()=>{
            await StorageUtil.pRemove(FilterBox._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED);
            JqueryUtil.doToast("Saved!");
        }
        );
    }

    async _pOpenCombineAsModal() {
        const {$modalInner} = await UiUtil.pGetShowModal({
            title: "Filter Combination Logic"
        });
        const $btnReset = $(`<button class="btn btn-xs btn-default">Reset</button>`).click(()=>{
            Object.keys(this._combineAs).forEach(k=>this._combineAs[k] = "and");
            $sels.forEach($sel=>$sel.val("0"));
        }
        );
        UiUtil.$getAddModalRowHeader($modalInner, "Combine filters as...", {
            $eleRhs: $btnReset
        });
        const $sels = this._filters.map(f=>UiUtil.$getAddModalRowSel($modalInner, f.header, this._combineAs, f.header, ["and", "or"], {
            fnDisplay: (it)=>it.toUpperCase()
        }));
    }

    getValues({nxtStateOuter=null}={}) {
        const outObj = {};
        this._filters.forEach(f=>Object.assign(outObj, f.getValues({
            nxtState: nxtStateOuter?.filters
        })));
        return outObj;
    }

    addEventListener(type, listener) {
        (this._$wrpFormTop ? this._$wrpFormTop[0] : this._$btnOpen[0]).addEventListener(type, listener);
    }

    _mutNextState_reset_meta({tgt}) {
        Object.assign(tgt, this._getDefaultMeta());
    }

    _mutNextState_minisHidden({tgt}) {
        Object.assign(tgt, this._getDefaultMinisHidden(tgt));
    }

    _mutNextState_combineAs({tgt}) {
        Object.assign(tgt, this._getDefaultCombineAs(tgt));
    }

    _reset_meta() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_reset_meta({
            tgt: nxtBoxState.meta
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    _reset_minisHidden() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_minisHidden({
            tgt: nxtBoxState.minisHidden
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    _reset_combineAs() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_combineAs({
            tgt: nxtBoxState.combineAs
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    reset(isResetAll) {
        this._filters.forEach(f=>f.reset({
            isResetAll
        }));
        if (isResetAll) {
            this._reset_meta();
            this._reset_minisHidden();
            this._reset_combineAs();
        }
        this.render();
        this.fireChangeEvent();
    }

    async show() {
        if (!this._isModalRendered)
            await this._render_pRenderModal();
        this._cachedState = this._getSaveableState();
        this._modalMeta.doOpen();
        if (this._metaIptSearch?.$ipt)
            this._metaIptSearch.$ipt.focus();
    }

    async _pHandleHide(isCancel=false) {
        if (this._cachedState && isCancel) {
            const curState = this._getSaveableState();
            const hasChanges = !CollectionUtil.deepEquals(curState, this._cachedState);

            if (hasChanges) {
                const isSave = await InputUiUtil.pGetUserBoolean({
                    title: "Unsaved Changes",
                    textYesRemember: "Always Save",
                    textYes: "Save",
                    textNo: "Discard",
                    storageKey: FilterBox._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED,
                    isGlobal: true,
                });
                if (isSave) {
                    this._cachedState = null;
                    this.fireChangeEvent();
                    return;
                } else
                    this._setStateFromLoaded(this._cachedState, {
                        isUserSavedState: true
                    });
            }
        } else {
            this.fireChangeEvent();
        }

        this._cachedState = null;
    }

    showAllFilters() {
        this._filters.forEach(f=>f.show());
    }

    hideAllFilters() {
        this._filters.forEach(f=>f.hide());
    }

    unpackSubHashes(subHashes, {force=false}={}) {
        const unpacked = {};
        subHashes.forEach(s=>{
            const unpackedPart = UrlUtil.unpackSubHash(s, true);
            if (Object.keys(unpackedPart).length > 1)
                throw new Error(`Multiple keys in subhash!`);
            const k = Object.keys(unpackedPart)[0];
            unpackedPart[k] = {
                clean: unpackedPart[k],
                raw: s
            };
            Object.assign(unpacked, unpackedPart);
        }
        );

        const urlHeaderToFilter = {};
        this._filters.forEach(f=>{
            const childFilters = f.getChildFilters();
            if (childFilters.length)
                childFilters.forEach(f=>urlHeaderToFilter[f.header.toLowerCase()] = f);
            urlHeaderToFilter[f.header.toLowerCase()] = f;
        }
        );

        const urlHeadersUpdated = new Set();
        const subHashesConsumed = new Set();
        let filterInitialSearch;

        const filterBoxState = {};
        const statePerFilter = {};
        const prefixLen = this.getNamespacedHashKey().length;
        Object.entries(unpacked).forEach(([hashKey,data])=>{
            const rawPrefix = hashKey.substring(0, prefixLen);
            const prefix = rawPrefix.substring(0, FilterUtil.SUB_HASH_PREFIX_LENGTH);

            const urlHeader = hashKey.substring(prefixLen);

            if (FilterUtil.SUB_HASH_PREFIXES.has(prefix) && urlHeaderToFilter[urlHeader]) {
                (statePerFilter[urlHeader] = statePerFilter[urlHeader] || {})[prefix] = data.clean;
                urlHeadersUpdated.add(urlHeader);
                subHashesConsumed.add(data.raw);
                return;
            }

            if (Object.values(FilterBox._SUB_HASH_PREFIXES).includes(prefix)) {
                if (prefix === VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX)
                    filterInitialSearch = data.clean[0];
                else
                    filterBoxState[prefix] = data.clean;
                subHashesConsumed.add(data.raw);
                return;
            }

            if (FilterUtil.SUB_HASH_PREFIXES.has(prefix))
                throw new Error(`Could not find filter with header ${urlHeader} for subhash ${data.raw}`);
        }
        );

        if (!subHashesConsumed.size && !force)
            return null;

        return {
            urlHeaderToFilter,
            filterBoxState,
            statePerFilter,
            urlHeadersUpdated,
            unpacked,
            subHashesConsumed,
            filterInitialSearch,
        };
    }

    setFromSubHashes(subHashes, {force=false, $iptSearch=null}={}) {
        const unpackedSubhashes = this.unpackSubHashes(subHashes, {
            force
        });

        if (unpackedSubhashes == null)
            return subHashes;

        const {unpacked, subHashesConsumed, filterInitialSearch, } = unpackedSubhashes;

        const {box: nxtStateBox, filters: nxtStatesFilters} = this.getNextStateFromSubHashes({
            unpackedSubhashes
        });

        this._setBoxStateFromNextBoxState(nxtStateBox);

        this._filters.flatMap(f=>[f, ...f.getChildFilters(), ]).filter(filter=>nxtStatesFilters[filter.header]).forEach(filter=>filter.setStateFromNextState(nxtStatesFilters));

        if (filterInitialSearch && ($iptSearch || this._$iptSearch))
            ($iptSearch || this._$iptSearch).val(filterInitialSearch).change().keydown().keyup().trigger("instantKeyup");

        const [link] = Hist.getHashParts();

        const outSub = [];
        Object.values(unpacked).filter(v=>!subHashesConsumed.has(v.raw)).forEach(v=>outSub.push(v.raw));

        Hist.setSuppressHistory(true);
        Hist.replaceHistoryHash(`${link}${outSub.length ? `${HASH_PART_SEP}${outSub.join(HASH_PART_SEP)}` : ""}`);

        this.fireChangeEvent();
        Hist.hashChange({
            isBlankFilterLoad: true
        });
        return outSub;
    }

    getNextStateFromSubHashes({unpackedSubhashes}) {
        const {urlHeaderToFilter, filterBoxState, statePerFilter, urlHeadersUpdated, } = unpackedSubhashes;

        const nxtStateBox = this._getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState);

        const nxtStateFilters = {};

        Object.entries(statePerFilter).forEach(([urlHeader,state])=>{
            const filter = urlHeaderToFilter[urlHeader];
            Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(state));
        }
        );

        Object.keys(urlHeaderToFilter).filter(k=>!urlHeadersUpdated.has(k)).forEach(k=>{
            const filter = urlHeaderToFilter[k];
            Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(null));
        }
        );

        return {
            box: nxtStateBox,
            filters: nxtStateFilters
        };
    }

    _getNextBoxState_base() {
        return {
            meta: MiscUtil.copyFast(this.__meta),
            minisHidden: MiscUtil.copyFast(this.__minisHidden),
            combineAs: MiscUtil.copyFast(this.__combineAs),
        };
    }

    _getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState) {
        const nxtBoxState = this._getNextBoxState_base();

        let hasMeta = false;
        let hasMinisHidden = false;
        let hasCombineAs = false;

        Object.entries(filterBoxState).forEach(([k,vals])=>{
            const mappedK = this.getNamespacedHashKey(Parser._parse_bToA(FilterBox._SUB_HASH_PREFIXES, k));
            switch (mappedK) {
            case "meta":
                {
                    hasMeta = true;
                    const data = vals.map(v=>UrlUtil.mini.decompress(v));
                    Object.keys(this._getDefaultMeta()).forEach((k,i)=>nxtBoxState.meta[k] = data[i]);
                    break;
                }
            case "minisHidden":
                {
                    hasMinisHidden = true;
                    Object.keys(nxtBoxState.minisHidden).forEach(k=>nxtBoxState.minisHidden[k] = false);
                    vals.forEach(v=>{
                        const [urlHeader,isHidden] = v.split("=");
                        const filter = urlHeaderToFilter[urlHeader];
                        if (!filter)
                            throw new Error(`Could not find filter with name "${urlHeader}"`);
                        nxtBoxState.minisHidden[filter.header] = !!Number(isHidden);
                    }
                    );
                    break;
                }
            case "combineAs":
                {
                    hasCombineAs = true;
                    Object.keys(nxtBoxState.combineAs).forEach(k=>nxtBoxState.combineAs[k] = "and");
                    vals.forEach(v=>{
                        const [urlHeader,ixCombineMode] = v.split("=");
                        const filter = urlHeaderToFilter[urlHeader];
                        if (!filter)
                            throw new Error(`Could not find filter with name "${urlHeader}"`);
                        nxtBoxState.combineAs[filter.header] = FilterBox._COMBINE_MODES[ixCombineMode] || FilterBox._COMBINE_MODES[0];
                    }
                    );
                    break;
                }
            }
        }
        );

        if (!hasMeta)
            this._mutNextState_reset_meta({
                tgt: nxtBoxState.meta
            });
        if (!hasMinisHidden)
            this._mutNextState_minisHidden({
                tgt: nxtBoxState.minisHidden
            });
        if (!hasCombineAs)
            this._mutNextState_combineAs({
                tgt: nxtBoxState.combineAs
            });

        return nxtBoxState;
    }

    _setBoxStateFromNextBoxState(nxtBoxState) {
        this._proxyAssignSimple("meta", nxtBoxState.meta, true);
        this._proxyAssignSimple("minisHidden", nxtBoxState.minisHidden, true);
        this._proxyAssignSimple("combineAs", nxtBoxState.combineAs, true);
    }

    getSubHashes(opts) {
        opts = opts || {};
        const out = [];
        const boxSubHashes = this.getBoxSubHashes();
        if (boxSubHashes)
            out.push(boxSubHashes);
        out.push(...this._filters.map(f=>f.getSubHashes()).filter(Boolean));
        if (opts.isAddSearchTerm && this._$iptSearch) {
            const searchTerm = UrlUtil.encodeForHash(this._$iptSearch.val().trim());
            if (searchTerm)
                out.push(UrlUtil.packSubHash(this._getSubhashPrefix("search"), [searchTerm]));
        }
        return out.flat();
    }

    getBoxSubHashes() {
        const out = [];

        const defaultMeta = this._getDefaultMeta();

        const anyNotDefault = Object.keys(defaultMeta).find(k=>this._meta[k] !== defaultMeta[k]);
        if (anyNotDefault) {
            const serMeta = Object.keys(defaultMeta).map(k=>UrlUtil.mini.compress(this._meta[k] === undefined ? defaultMeta[k] : this._meta[k]));
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("meta"), serMeta));
        }

        const setMinisHidden = Object.entries(this._minisHidden).filter(([k,v])=>!!v).map(([k])=>`${k.toUrlified()}=1`);
        if (setMinisHidden.length) {
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("minisHidden"), setMinisHidden));
        }

        const setCombineAs = Object.entries(this._combineAs).filter(([k,v])=>v !== FilterBox._COMBINE_MODES[0]).map(([k,v])=>`${k.toUrlified()}=${FilterBox._COMBINE_MODES.indexOf(v)}`);
        if (setCombineAs.length) {
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("combineAs"), setCombineAs));
        }

        return out.length ? out : null;
    }

    getFilterTag({isAddSearchTerm=false}={}) {
        const parts = this._filters.map(f=>f.getFilterTagPart()).filter(Boolean);
        if (isAddSearchTerm && this._$iptSearch) {
            const term = this._$iptSearch.val().trim();
            if (term)
                parts.push(`search=${term}`);
        }
        return `{@filter |${UrlUtil.getCurrentPage().replace(/\.html$/, "")}|${parts.join("|")}}`;
    }

    getDisplayState({nxtStateOuter=null}={}) {
        return this._filters.map(filter=>filter.getDisplayStatePart({
            nxtState: nxtStateOuter?.filters
        })).filter(Boolean).join("; ");
    }

    setFromValues(values) {
        this._filters.forEach(it=>it.setFromValues(values));
        this.fireChangeEvent();
    }

    toDisplay(boxState, ...entryVals) {
        return this._toDisplay(boxState, this._filters, entryVals);
    }

    toDisplayByFilters(boxState, ...filterToValueTuples) {
        return this._toDisplay(boxState, filterToValueTuples.map(it=>it.filter), filterToValueTuples.map(it=>it.value), );
    }

    _toDisplay(boxState, filters, entryVals) {
        switch (this._meta.modeCombineFilters) {
        case "and":
            return this._toDisplay_isAndDisplay(boxState, filters, entryVals);
        case "or":
            return this._toDisplay_isOrDisplay(boxState, filters, entryVals);
        case "custom":
            {
                if (entryVals.length !== filters.length)
                    throw new Error(`Number of filters and number of values did not match!`);

                const andFilters = [];
                const andValues = [];
                const orFilters = [];
                const orValues = [];

                for (let i = 0; i < filters.length; ++i) {
                    const f = filters[i];
                    if (!this._combineAs[f.header] || this._combineAs[f.header] === "and") {
                        andFilters.push(f);
                        andValues.push(entryVals[i]);
                    } else {
                        orFilters.push(f);
                        orValues.push(entryVals[i]);
                    }
                }

                return this._toDisplay_isAndDisplay(boxState, andFilters, andValues) && this._toDisplay_isOrDisplay(boxState, orFilters, orValues);
            }
        default:
            throw new Error(`Unhandled combining mode "${this._meta.modeCombineFilters}"`);
        }
    }

    _toDisplay_isAndDisplay(boxState, filters, vals) {
        return filters.map((f,i)=>f.toDisplay(boxState, vals[i])).every(it=>it);
    }

    _toDisplay_isOrDisplay(boxState, filters, vals) {
        const res = filters.map((f,i)=>{
            if (!f.isActive(boxState))
                return null;
            return f.toDisplay(boxState, vals[i]);
        }
        ).filter(it=>it != null);
        return res.length === 0 || res.find(it=>it);
    }

    _getSubhashPrefix(prop) {
        if (FilterBox._SUB_HASH_PREFIXES[prop])
            return this.getNamespacedHashKey(FilterBox._SUB_HASH_PREFIXES[prop]);
        throw new Error(`Unknown property "${prop}"`);
    }

    _getDefaultMeta() {
        const out = MiscUtil.copy(FilterBox._DEFAULT_META);
        if (this._isCompact)
            out.isSummaryHidden = true;
        return out;
    }

    _getDefaultMinisHidden(minisHidden) {
        if (!minisHidden)
            throw new Error(`Missing "minisHidden" argument!`);
        return Object.keys(minisHidden).mergeMap(k=>({
            [k]: false
        }));
    }

    _getDefaultCombineAs(combineAs) {
        if (!combineAs)
            throw new Error(`Missing "combineAs" argument!`);
        return Object.keys(combineAs).mergeMap(k=>({
            [k]: "and"
        }));
    }
}
;
FilterBox.EVNT_VALCHANGE = "valchange";
FilterBox.SOURCE_HEADER = "Source";
FilterBox._PILL_STATES = ["ignore", "yes", "no"];
FilterBox._COMBINE_MODES = ["and", "or", "custom"];
FilterBox._STORAGE_KEY = "filterBoxState";
FilterBox._DEFAULT_META = {
    modeCombineFilters: "and",
    isSummaryHidden: false,
    isBrewDefaultHidden: false,
};
FilterBox._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED = "filterAlwaysSaveUnchanged";

FilterBox._SUB_HASH_BOX_META_PREFIX = "fbmt";
FilterBox._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX = "fbmh";
FilterBox._SUB_HASH_BOX_COMBINE_AS_PREFIX = "fbca";
FilterBox._SUB_HASH_PREFIXES = {
    meta: FilterBox._SUB_HASH_BOX_META_PREFIX,
    minisHidden: FilterBox._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX,
    combineAs: FilterBox._SUB_HASH_BOX_COMBINE_AS_PREFIX,
    search: VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX,
};
//#endregion

//#region ContentGetter
class ContentGetter{
    static _getBase(){
        

        const class_barbarian = String.raw`{
        "class": [
            {
                "name": "Barbarian",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "hd": {
                    "number": 1,
                    "faces": 12
                },
                "proficiency": [
                    "str",
                    "con"
                ],
                "startingProficiencies": {
                    "armor": [
                        "light",
                        "medium",
                        "{@item shield|phb|shields}"
                    ],
                    "weapons": [
                        "simple",
                        "martial"
                    ],
                    "skills": [
                        {
                            "choose": {
                                "from": [
                                    "animal handling",
                                    "athletics",
                                    "intimidation",
                                    "nature",
                                    "perception",
                                    "survival"
                                ],
                                "count": 2
                            }
                        }
                    ]
                },
                "startingEquipment": {
                    "additionalFromBackground": true,
                    "default": [
                        "(a) a {@item greataxe|phb} or (b) any {@filter martial melee weapon|items|source=phb|category=basic|type=martial weapon;melee weapon=u~u~sand}",
                        "(a) two {@item handaxe|phb|handaxes} or (b) any {@filter simple weapon|items|source=phb|category=basic|type=simple weapon}",
                        "An {@item explorer's pack|phb}, and four {@item javelin|phb|javelins}"
                    ],
                    "goldAlternative": "{@dice 2d4 × 10|2d4 × 10|Starting Gold}",
                    "defaultData": [
                        {
                            "a": [
                                "greataxe|phb"
                            ],
                            "b": [
                                {
                                    "equipmentType": "weaponMartialMelee"
                                }
                            ]
                        },
                        {
                            "a": [
                                {
                                    "item": "handaxe|phb",
                                    "quantity": 2
                                }
                            ],
                            "b": [
                                {
                                    "equipmentType": "weaponSimple"
                                }
                            ]
                        },
                        {
                            "_": [
                                "explorer's pack|phb",
                                {
                                    "item": "javelin|phb",
                                    "quantity": 4
                                }
                            ]
                        }
                    ]
                },
                "multiclassing": {
                    "requirements": {
                        "str": 13
                    },
                    "proficienciesGained": {
                        "armor": [
                            "{@item shield|phb|shields}"
                        ],
                        "weapons": [
                            "simple",
                            "martial"
                        ]
                    }
                },
                "classTableGroups": [
                    {
                        "colLabels": [
                            "Rages",
                            "Rage Damage"
                        ],
                        "rows": [
                            [
                                "2",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "2",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "3",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "3",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "3",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 2
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "4",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "5",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "5",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "5",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "5",
                                {
                                    "type": "bonus",
                                    "value": 3
                                }
                            ],
                            [
                                "5",
                                {
                                    "type": "bonus",
                                    "value": 4
                                }
                            ],
                            [
                                "6",
                                {
                                    "type": "bonus",
                                    "value": 4
                                }
                            ],
                            [
                                "6",
                                {
                                    "type": "bonus",
                                    "value": 4
                                }
                            ],
                            [
                                "6",
                                {
                                    "type": "bonus",
                                    "value": 4
                                }
                            ],
                            [
                                "Unlimited",
                                {
                                    "type": "bonus",
                                    "value": 4
                                }
                            ]
                        ]
                    }
                ],
                "classFeatures": [
                    "Rage|Barbarian||1",
                    "Unarmored Defense|Barbarian||1",
                    "Danger Sense|Barbarian||2",
                    "Reckless Attack|Barbarian||2",
                    {
                        "classFeature": "Primal Path|Barbarian||3",
                        "gainSubclassFeature": true
                    },
                    "Primal Knowledge|Barbarian||3|TCE",
                    "Ability Score Improvement|Barbarian||4",
                    "Extra Attack|Barbarian||5",
                    "Fast Movement|Barbarian||5",
                    {
                        "classFeature": "Path Feature|Barbarian||6",
                        "gainSubclassFeature": true
                    },
                    "Feral Instinct|Barbarian||7",
                    "Instinctive Pounce|Barbarian||7|TCE",
                    "Ability Score Improvement|Barbarian||8",
                    "Brutal Critical (1 die)|Barbarian||9",
                    {
                        "classFeature": "Path feature|Barbarian||10",
                        "gainSubclassFeature": true
                    },
                    "Relentless Rage|Barbarian||11",
                    "Ability Score Improvement|Barbarian||12",
                    "Brutal Critical (2 dice)|Barbarian||13",
                    {
                        "classFeature": "Path feature|Barbarian||14",
                        "gainSubclassFeature": true
                    },
                    "Persistent Rage|Barbarian||15",
                    "Ability Score Improvement|Barbarian||16",
                    "Brutal Critical (3 dice)|Barbarian||17",
                    "Indomitable Might|Barbarian||18",
                    "Ability Score Improvement|Barbarian||19",
                    "Primal Champion|Barbarian||20"
                ],
                "subclassTitle": "Primal Path",
                "fluff": [
                    {
                        "name": "Barbarian",
                        "type": "section",
                        "entries": [
                            "A tall human tribesman strides through a blizzard, draped in fur and hefting his axe. He laughs as he charges toward the frost giant who dared poach his people's elk herd.",
                            "A half-orc snarls at the latest challenger to her authority over their savage tribe, ready to break his neck with her bare hands as she did to the last six rivals.",
                            "Frothing at the mouth, a dwarf slams his helmet into the face of his drow foe, then turns to drive his armored elbow into the gut of another.",
                            "These barbarians, different as they might be, are defined by their rage: unbridled, unquenchable, and unthinking fury. More than a mere emotion, their anger is the ferocity of a cornered predator, the unrelenting assault of a storm, the churning turmoil of the sea.",
                            "For some, their rage springs from a communion with fierce animal spirits. Others draw from a roiling reservoir of anger at a world full of pain. For every barbarian, rage is a power that fuels not just a battle frenzy but also uncanny reflexes, resilience, and feats of strength.",
                            {
                                "type": "entries",
                                "name": "Primal Instinct",
                                "entries": [
                                    "People of towns and cities take pride in how their civilized ways set them apart from animals, as if denying one's own nature was a mark of superiority. To a barbarian, though, civilization is no virtue, but a sign of weakness. The strong embrace their animal nature\u2014keen instincts, primal physicality, and ferocious rage. Barbarians are uncomfortable when hedged in by walls and crowds. They thrive in the wilds of their homelands: the tundra, jungle, or grasslands where their tribes live and hunt.",
                                    "Barbarians come alive in the chaos of combat. They can enter a berserk state where rage takes over, giving them superhuman strength and resilience. A barbarian can draw on this reservoir of fury only a few times without resting, but those few rages are usually sufficient to defeat whatever threats arise."
                                ]
                            },
                            {
                                "type": "entries",
                                "name": "A Life of Danger",
                                "entries": [
                                    "Not every member of the tribes deemed \"barbarians\" by scions of civilized society has the barbarian class. A true barbarian among these people is as uncommon as a skilled fighter in a town, and he or she plays a similar role as a protector of the people and a leader in times of war. Life in the wild places of the world is fraught with peril: rival tribes, deadly weather, and terrifying monsters. Barbarians charge headlong into that danger so that their people don't have to.",
                                    "Their courage in the face of danger makes barbarians perfectly suited for adventuring. Wandering is often a way of life for their native tribes, and the rootless life of the adventurer is little hardship for a barbarian. Some barbarians miss the close-knit family structures of the tribe, but eventually find them replaced by the bonds formed among the members of their adventuring parties."
                                ]
                            },
                            {
                                "type": "entries",
                                "name": "Creating a Barbarian",
                                "entries": [
                                    "When creating a barbarian character, think about where your character comes from and his or her place in the world. Talk with your DM about an appropriate origin for your barbarian. Did you come from a distant land, making you a stranger in the area of the campaign? Or is the campaign set in a rough-and-tumble frontier where barbarians are common?",
                                    "What led you to take up the adventuring life? Were you lured to settled lands by the promise of riches? Did you join forces with soldiers of those lands to face a shared threat? Did monsters or an invading horde drive you out of your homeland, making you a rootless refugee? Perhaps you were a prisoner of war, brought in chains to \"civilized\" lands and only now able to win your freedom. Or you might have been cast out from your people because of a crime you committed, a taboo you violated, or a coup that removed you from a position of authority.",
                                    {
                                        "type": "entries",
                                        "name": "Quick Build",
                                        "entries": [
                                            "You can make a barbarian quickly by following these suggestions. First, put your highest ability score in Strength, followed by Constitution. Second, choose the {@background outlander} background."
                                        ]
                                    }
                                ]
                            }
                        ],
                        "source": "PHB",
                        "page": 46
                    },
                    {
                        "type": "section",
                        "entries": [
                            {
                                "type": "quote",
                                "entries": [
                                    "I have witnessed the indomitable performance of barbarians on the field of battle, and it makes me wonder what force lies at the heart of their rage."
                                ],
                                "by": "Seret, archwizard"
                            },
                            "The anger felt by a normal person resembles the rage of a barbarian in the same way that a gentle breeze is akin to a furious thunderstorm. The barbarian's driving force comes from a place that transcends mere emotion, making its manifestation all the more terrible. Whether the impetus for the fury comes entirely from within or from forging a link with a spirit animal, a raging barbarian becomes able to perform supernatural feats of strength and endurance. The outburst is temporary, but while it lasts, it takes over body and mind, driving the barbarian on despite peril and injury, until the last enemy falls.",
                            "It can be tempting to play a barbarian character that is a straightforward application of the classic archetype\u2014a brute, and usually a dimwitted one at that, who rushes in where others fear to tread. But not all the barbarians in the world are cut from that cloth, so you can certainly put your own spin on things. Either way, consider adding some flourishes to make your barbarian stand out from all others; see the following sections for some ideas.",
                            {
                                "type": "entries",
                                "name": "Personal Totems",
                                "entries": [
                                    "Barbarians tend to travel light, carrying little in the way of personal effects or other unnecessary gear. The few possessions they do carry often include small items that have special significance. A personal totem is significant because it has a mystical origin or is tied to an important moment in the character's life\u2014perhaps a remembrance from the barbarian's past or a harbinger of what lies ahead.",
                                    "A personal totem of this sort might be associated with a barbarian's spirit animal, or might actually be the totem object for the animal, but such a connection is not essential. One who has a bear totem spirit, for instance, could still carry an eagle's feather as a personal totem.",
                                    "Consider creating one or more personal totems for your character\u2014objects that hold a special link to your character's past or future. Think about how a totem might affect your character's actions.",
                                    {
                                        "type": "table",
                                        "caption": "Personal Totems",
                                        "colLabels": [
                                            "{@dice d6}",
                                            "Totem"
                                        ],
                                        "colStyles": [
                                            "col-1 text-center",
                                            "col-11"
                                        ],
                                        "rows": [
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 1
                                                    }
                                                },
                                                "A tuft of fur from a solitary wolf that you befriended during a hunt"
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 2
                                                    }
                                                },
                                                "Three eagle feathers given to you by a wise shaman, who told you they would play a role in determining your fate"
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 3
                                                    }
                                                },
                                                "A necklace made from the claws of a young cave bear that you slew singlehandedly as a child"
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 4
                                                    }
                                                },
                                                "A small leather pouch holding three stones that represent your ancestors"
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 5
                                                    }
                                                },
                                                "A few small bones from the first beast you killed, tied together with colored wool"
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 6
                                                    }
                                                },
                                                "An egg-sized stone in the shape of your spirit animal that appeared one day in your belt pouch"
                                            ]
                                        ]
                                    }
                                ]
                            },
                            {
                                "type": "entries",
                                "name": "Tattoos",
                                "entries": [
                                    "The members of many barbarian clans decorate their bodies with tattoos, each of which represents a significant moment in the life of the bearer or the bearer's ancestors, or which symbolizes a feeling or an attitude. As with personal totems, a barbarian's tattoos might or might not be related to an animal spirit.",
                                    "Each tattoo a barbarian displays contributes to that individual's identity. If your character wears tattoos, what do they look like, and what do they represent?",
                                    {
                                        "type": "table",
                                        "caption": "Tattoos",
                                        "colLabels": [
                                            "{@dice d6}",
                                            "Tattoo"
                                        ],
                                        "colStyles": [
                                            "col-1 text-center",
                                            "col-11"
                                        ],
                                        "rows": [
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 1
                                                    }
                                                },
                                                "The wings of an eagle are spread wide across your upper back."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 2
                                                    }
                                                },
                                                "Etched on the backs of your hands are the paws of a cave bear."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 3
                                                    }
                                                },
                                                "The symbols of your clan are displayed in viny patterns along your arms."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 4
                                                    }
                                                },
                                                "The antlers of an elk are inked across your back."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 5
                                                    }
                                                },
                                                "Images of your spirit animal are tattooed along your weapon arm and hand."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 6
                                                    }
                                                },
                                                "The eyes of a wolf are marked on your back to help you see and ward off evil spirits."
                                            ]
                                        ]
                                    }
                                ]
                            },
                            {
                                "type": "entries",
                                "name": "Superstitions",
                                "entries": [
                                    "Barbarians vary widely in how they understand life. Some follow gods and look for guidance from those deities in the cycles of nature and the animals they encounter. These barbarians believe that spirits inhabit the plants and animals of the world, and the barbarians look to them for omens and power.",
                                    "Other barbarians trust only in the blood that runs in their veins and the steel they hold in their hands. They have no use for the invisible world, instead relying on their senses to hunt and survive like the wild beasts they emulate.",
                                    "Both of these attitudes can give rise to superstitions. These beliefs are often passed down within a family or shared among the members of a clan or a hunting group.",
                                    "If your barbarian character has any superstitions, were they ingrained in you by your family, or are they the result of personal experience?",
                                    {
                                        "type": "table",
                                        "caption": "Superstition",
                                        "colLabels": [
                                            "{@dice d6}",
                                            "Superstition"
                                        ],
                                        "colStyles": [
                                            "col-1 text-center",
                                            "col-11"
                                        ],
                                        "rows": [
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 1
                                                    }
                                                },
                                                "If you disturb the bones of the dead, you inherit all the troubles that plagued them in life."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 2
                                                    }
                                                },
                                                "Never trust a wizard. They're all devils in disguise, especially the friendly ones."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 3
                                                    }
                                                },
                                                "Dwarves have lost their spirits, and are almost like the undead. That's why they live underground."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 4
                                                    }
                                                },
                                                "Magical things bring trouble. Never sleep with a magic object within ten feet of you."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 5
                                                    }
                                                },
                                                "When you walk through a graveyard, be sure to wear silver, or a ghost might jump into your body."
                                            ],
                                            [
                                                {
                                                    "type": "cell",
                                                    "roll": {
                                                        "exact": 6
                                                    }
                                                },
                                                "If an elf looks you in the eyes, she's trying to read your thoughts."
                                            ]
                                        ]
                                    }
                                ]
                            }
                        ],
                        "source": "XGE",
                        "page": 8
                    }
                ]
            }
        ],
        "subclass": [
            {
                "name": "Path of the Berserker",
                "shortName": "Berserker",
                "source": "PHB",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 49,
                "srd": true,
                "subclassFeatures": [
                    "Path of the Berserker|Barbarian||Berserker||3",
                    "Mindless Rage|Barbarian||Berserker||6",
                    "Intimidating Presence|Barbarian||Berserker||10",
                    "Retaliation|Barbarian||Berserker||14"
                ]
            },
            {
                "name": "Path of the Totem Warrior",
                "shortName": "Totem Warrior",
                "source": "PHB",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 50,
                "additionalSpells": [
                    {
                        "innate": {
                            "3": {
                                "ritual": [
                                    "beast sense",
                                    "speak with animals"
                                ]
                            },
                            "10": {
                                "ritual": [
                                    "commune with nature"
                                ]
                            }
                        }
                    }
                ],
                "subclassFeatures": [
                    "Path of the Totem Warrior|Barbarian||Totem Warrior||3",
                    "Aspect of the Beast|Barbarian||Totem Warrior||6",
                    "Spirit Walker|Barbarian||Totem Warrior||10",
                    "Totemic Attunement|Barbarian||Totem Warrior||14"
                ]
            },
            {
                "name": "Path of the Battlerager",
                "shortName": "Battlerager",
                "source": "SCAG",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 121,
                "subclassFeatures": [
                    "Path of the Battlerager|Barbarian||Battlerager|SCAG|3",
                    "Reckless Abandon|Barbarian||Battlerager|SCAG|6",
                    "Battlerager Charge|Barbarian||Battlerager|SCAG|10",
                    "Spiked Retribution|Barbarian||Battlerager|SCAG|14"
                ]
            },
            {
                "name": "Path of the Ancestral Guardian",
                "shortName": "Ancestral Guardian",
                "source": "XGE",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 9,
                "spellcastingAbility": "wis",
                "additionalSpells": [
                    {
                        "innate": {
                            "10": [
                                "augury",
                                "clairvoyance"
                            ]
                        }
                    }
                ],
                "subclassFeatures": [
                    "Path of the Ancestral Guardian|Barbarian||Ancestral Guardian|XGE|3",
                    "Spirit Shield|Barbarian||Ancestral Guardian|XGE|6",
                    "Consult the Spirits|Barbarian||Ancestral Guardian|XGE|10",
                    "Vengeful Ancestors|Barbarian||Ancestral Guardian|XGE|14"
                ]
            },
            {
                "name": "Path of the Storm Herald",
                "shortName": "Storm Herald",
                "source": "XGE",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 10,
                "subclassFeatures": [
                    "Path of the Storm Herald|Barbarian||Storm Herald|XGE|3",
                    "Storm Soul|Barbarian||Storm Herald|XGE|6",
                    "Shielding Storm|Barbarian||Storm Herald|XGE|10",
                    "Raging Storm|Barbarian||Storm Herald|XGE|14"
                ]
            },
            {
                "name": "Path of the Zealot",
                "shortName": "Zealot",
                "source": "XGE",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 11,
                "subclassFeatures": [
                    "Path of the Zealot|Barbarian||Zealot|XGE|3",
                    "Fanatical Focus|Barbarian||Zealot|XGE|6",
                    "Zealous Presence|Barbarian||Zealot|XGE|10",
                    "Rage beyond Death|Barbarian||Zealot|XGE|14"
                ]
            },
            {
                "name": "Path of the Beast",
                "shortName": "Beast",
                "source": "TCE",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 24,
                "subclassFeatures": [
                    "Path of the Beast|Barbarian||Beast|TCE|3",
                    "Bestial Soul|Barbarian||Beast|TCE|6",
                    "Infectious Fury|Barbarian||Beast|TCE|10",
                    "Call the Hunt|Barbarian||Beast|TCE|14"
                ]
            },
            {
                "name": "Path of Wild Magic",
                "shortName": "Wild Magic",
                "source": "TCE",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 25,
                "subclassFeatures": [
                    "Path of Wild Magic|Barbarian||Wild Magic|TCE|3",
                    "Bolstering Magic|Barbarian||Wild Magic|TCE|6",
                    "Unstable Backlash|Barbarian||Wild Magic|TCE|10",
                    "Controlled Surge|Barbarian||Wild Magic|TCE|14"
                ]
            },
            {
                "name": "Path of the Juggernaut",
                "shortName": "Juggernaut",
                "source": "TDCSR",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 165,
                "subclassFeatures": [
                    "Path of the Juggernaut|Barbarian|PHB|Juggernaut|TDCSR|3",
                    "Demolishing Might|Barbarian|PHB|Juggernaut|TDCSR|6",
                    "Resolute Stance|Barbarian|PHB|Juggernaut|TDCSR|6",
                    "Thunderous Blows (10th Level)|Barbarian|PHB|Juggernaut|TDCSR|10",
                    "Hurricane Strike|Barbarian|PHB|Juggernaut|TDCSR|10",
                    "Unstoppable|Barbarian|PHB|Juggernaut|TDCSR|14"
                ]
            },
            {
                "name": "Path of the Giant",
                "shortName": "Giant",
                "source": "BGG",
                "className": "Barbarian",
                "classSource": "PHB",
                "page": 1,
                "spellcastingAbility": "wis",
                "additionalSpells": [
                    {
                        "innate": {
                            "3": [
                                "druidcraft#c"
                            ]
                        }
                    },
                    {
                        "innate": {
                            "3": [
                                "thaumaturgy#c"
                            ]
                        }
                    }
                ],
                "subclassFeatures": [
                    "Path of the Giant|Barbarian||Giant|BGG|3",
                    "Elemental Cleaver|Barbarian||Giant|BGG|6",
                    "Mighty Impel|Barbarian||Giant|BGG|10",
                    "Demiurgic Colossus|Barbarian||Giant|BGG|14"
                ]
            }
        ],
        "classFeature": [
            {
                "name": "Rage",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 1,
                "entries": [
                    "In battle, you fight with primal ferocity. On your turn, you can enter a rage as a bonus action.",
                    "While raging, you gain the following benefits if you aren't wearing heavy armor:",
                    {
                        "type": "list",
                        "items": [
                            "You have advantage on Strength checks and Strength saving throws.",
                            "When you make a melee weapon attack using Strength, you gain a +2 bonus to the damage roll. This bonus increases as you level.",
                            "You have resistance to bludgeoning, piercing, and slashing damage."
                        ]
                    },
                    "If you are able to cast spells, you can't cast them or concentrate on them while raging.",
                    "Your rage lasts for 1 minute. It ends early if you are knocked {@condition unconscious} or if your turn ends and you haven't attacked a hostile creature since your last turn or taken damage since then. You can also end your rage on your turn as a bonus action.",
                    "Once you have raged the maximum number of times for your barbarian level, you must finish a long rest before you can rage again. You may rage 2 times at 1st level, 3 at 3rd, 4 at 6th, 5 at 12th, and 6 at 17th."
                ]
            },
            {
                "name": "Unarmored Defense",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 1,
                "entries": [
                    "While you are not wearing any armor, your Armor Class equals 10 + your Dexterity modifier + your Constitution modifier. You can use a shield and still gain this benefit."
                ]
            },
            {
                "name": "Danger Sense",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 2,
                "entries": [
                    "At 2nd level, you gain an uncanny sense of when things nearby aren't as they should be, giving you an edge when you dodge away from danger. You have advantage on Dexterity saving throws against effects that you can see, such as traps and spells. To gain this benefit, you can't be {@condition blinded}, {@condition deafened}, or {@condition incapacitated}."
                ]
            },
            {
                "name": "Reckless Attack",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 2,
                "entries": [
                    "Starting at 2nd level, you can throw aside all concern for defense to attack with fierce desperation. When you make your first attack on your turn, you can decide to attack recklessly. Doing so gives you advantage on melee weapon attack rolls using Strength during this turn, but attack rolls against you have advantage until your next turn."
                ]
            },
            {
                "name": "Primal Knowledge",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 3,
                "isClassFeatureVariant": true,
                "entries": [
                    "{@i 3rd-level barbarian {@variantrule optional class features|tce|optional feature}}",
                    "When you reach 3rd level and again at 10th level, you gain proficiency in one skill of your choice from the list of skills available to barbarians at 1st level."
                ]
            },
            {
                "name": "Primal Path",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 3,
                "entries": [
                    "At 3rd level, you choose a path that shapes the nature of your rage from the list of available paths. Your choice grants you features at 3rd level and again at 6th, 10th, and 14th levels."
                ]
            },
            {
                "name": "Ability Score Improvement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 4,
                "entries": [
                    "When you reach 4th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                    "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                ]
            },
            {
                "name": "Extra Attack",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 5,
                "entries": [
                    "Beginning at 5th level, you can attack twice, instead of once, whenever you take the {@action Attack} action on your turn."
                ]
            },
            {
                "name": "Fast Movement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 5,
                "entries": [
                    "Starting at 5th level, your speed increases by 10 feet while you aren't wearing heavy armor."
                ]
            },
            {
                "name": "Path Feature",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 6,
                "entries": [
                    "At 6th level, you gain a feature from your Primal Path."
                ]
            },
            {
                "name": "Feral Instinct",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 7,
                "entries": [
                    "By 7th level, your instincts are so honed that you have advantage on initiative rolls.",
                    "Additionally, if you are {@quickref Surprise|PHB|3|0|surprised} at the beginning of combat and aren't {@condition incapacitated}, you can act normally on your first turn, but only if you enter your rage before doing anything else on that turn."
                ]
            },
            {
                "name": "Instinctive Pounce",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 7,
                "isClassFeatureVariant": true,
                "entries": [
                    "{@i 7th-level barbarian {@variantrule optional class features|tce|optional feature}}",
                    "As part of the bonus action you take to enter your rage, you can move up to half your speed."
                ]
            },
            {
                "name": "Ability Score Improvement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 8,
                "entries": [
                    "When you reach 8th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                    "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                ]
            },
            {
                "name": "Brutal Critical (1 die)",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 9,
                "entries": [
                    "Beginning at 9th level, you can roll one additional weapon damage die when determining the extra damage for a critical hit with a melee attack.",
                    "This increases to two additional dice at 13th level and three additional dice at 17th level."
                ]
            },
            {
                "name": "Path feature",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 10,
                "entries": [
                    "At 10th level, you gain a feature from your Primal Path."
                ]
            },
            {
                "name": "Relentless Rage",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 11,
                "entries": [
                    "Starting at 11th level, your rage can keep you fighting despite grievous wounds. If you drop to 0 hit points while you're raging and don't die outright, you can make a DC 10 Constitution saving throw. If you succeed, you drop to 1 hit point instead.",
                    "Each time you use this feature after the first, the DC increases by 5. When you finish a short or long rest, the DC resets to 10."
                ]
            },
            {
                "name": "Ability Score Improvement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 12,
                "entries": [
                    "When you reach 12th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                    "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                ]
            },
            {
                "name": "Brutal Critical (2 dice)",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 13,
                "entries": [
                    "At 13th level, you can roll two additional weapon damage dice when determining the extra damage for a critical hit with a melee attack.",
                    "This increases to three additional dice at 17th level."
                ]
            },
            {
                "name": "Path feature",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 14,
                "entries": [
                    "At 14th level, you gain a feature from your Primal Path."
                ]
            },
            {
                "name": "Persistent Rage",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 15,
                "entries": [
                    "Beginning at 15th level, your rage is so fierce that it ends early only if you fall {@condition unconscious} or if you choose to end it."
                ]
            },
            {
                "name": "Ability Score Improvement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 16,
                "entries": [
                    "When you reach 16th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                    "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                ]
            },
            {
                "name": "Brutal Critical (3 dice)",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 17,
                "entries": [
                    "At 17th level, you can roll three additional weapon damage dice when determining the extra damage for a critical hit with a melee attack."
                ]
            },
            {
                "name": "Indomitable Might",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 18,
                "entries": [
                    "Beginning at 18th level, if your total for a Strength check is less than your Strength score, you can use that score in place of the total."
                ]
            },
            {
                "name": "Ability Score Improvement",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 19,
                "entries": [
                    "When you reach 19th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                    "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                ]
            },
            {
                "name": "Primal Champion",
                "source": "PHB",
                "page": 46,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "level": 20,
                "entries": [
                    "At 20th level, you embody the power of the wilds. Your Strength and Constitution scores increase by 4. Your maximum for those scores is now 24."
                ]
            }
        ],
        "subclassFeature": [
            {
                "name": "Giant Power",
                "source": "BGG",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 3,
                "entries": [
                    "{@i 3rd-Level Path of the Giant Feature}",
                    "When you choose this path, you learn to speak, read, and write Giant or one other language of your choice if you already know Giant. Additionally, you learn a cantrip of your choice: either {@spell druidcraft} or {@spell thaumaturgy}. Wisdom is your spellcasting ability for this spell."
                ]
            },
            {
                "name": "Giant's Havoc",
                "source": "BGG",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 3,
                "entries": [
                    "{@i 3rd-Level Path of the Giant Feature}",
                    "Your rages pull strength from the primal might of giants, transforming you into a hulking force of destruction. While raging, you gain the following benefits:",
                    {
                        "type": "list",
                        "style": "list-hang-notitle",
                        "items": [
                            {
                                "type": "item",
                                "name": "Crushing Throw",
                                "entry": "When you make a successful ranged attack with a thrown weapon using Strength, you can add your Rage Damage bonus to the attack's damage roll."
                            },
                            {
                                "type": "item",
                                "name": "Giant Stature",
                                "entry": "Your reach increases by 5 feet, and if you are smaller than Large, you become Large, along with anything you are wearing. If there isn't enough room for you to increase your size, your size doesn't change."
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Path of the Giant",
                "source": "BGG",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 3,
                "entries": [
                    "Barbarians who walk the Path of the Giant draw strength from the same primal forces as giants. As they rage, these barbarians surge with elemental power and grow in size, taking on forms that evoke the glory of giants. Some barbarians look like oversized versions of themselves, perhaps with a hint of elemental energy flaring in their eyes and around their weapons. Others transform more dramatically, taking on the appearance of an actual giant or a form similar to an Elemental, wreathed in fire, frost, or lightning.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Giant Power|Barbarian||Giant|BGG|3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Giant's Havoc|Barbarian||Giant|BGG|3"
                    }
                ]
            },
            {
                "name": "Elemental Cleaver",
                "source": "BGG",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 6,
                "header": 2,
                "entries": [
                    "{@i 6th-Level Path of the Giant Feature}",
                    "Your bond with the elemental might of giants grows, and you learn to infuse weapons with primordial energy.",
                    "When you enter your rage, you can choose one weapon that you are holding and infuse it with one of the following damage types: acid, cold, fire, thunder, or lightning. While you wield the infused weapon during your rage, the weapon's damage type changes to the chosen type, it deals an extra {@dice 1d6} damage of the chosen type when it hits, and it gains the thrown property, with a normal range of 20 feet and a long range of 60 feet. If you throw the weapon, it reappears in your hand the instant after it hits or misses a target. The infused weapon's benefits are suppressed while a creature other than you wields it.",
                    "While raging and holding the infused weapon, you can use a bonus action to change the infused weapon's current damage type to another one from the damage type options above."
                ]
            },
            {
                "name": "Mighty Impel",
                "source": "BGG",
                "page": 12,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 10,
                "header": 2,
                "entries": [
                    "{@i 10th-Level Path of the Giant Feature}",
                    "Your connection to giant strength allows you to hurl both allies and enemies on the battlefield. As a bonus action while raging, you can choose one Medium or smaller creature within your reach and move it to an unoccupied space you can see within 30 feet of yourself. An unwilling creature must succeed on a Strength saving throw (DC equals 8 + your proficiency bonus + your Strength modifier) to avoid the effect.",
                    "If, at the end of this movement, the thrown creature isn't on a surface or liquid that can support it, the creature falls, taking damage as normal and landing {@condition prone}."
                ]
            },
            {
                "name": "Demiurgic Colossus",
                "source": "BGG",
                "page": 12,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Giant",
                "subclassSource": "BGG",
                "level": 14,
                "header": 2,
                "entries": [
                    "{@i 14th-Level Path of the Giant Feature}",
                    "The primordial power of your rage intensifies. When you rage, your reach increases by 10 feet, your size can increase to Large or Huge (your choice), and you can use your Mighty Impel to move creatures that are Large or smaller.",
                    "In addition, the extra damage dealt by your Elemental Cleaver feature increases to {@dice 2d6}."
                ]
            },
            {
                "name": "Path of the Berserker",
                "source": "PHB",
                "page": 49,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Berserker",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "For some barbarians, rage is a means to an end\u2014that end being violence. The Path of the Berserker is a path of untrammeled fury, slick with blood. As you enter the berserker's rage, you thrill in the chaos of battle, heedless of your own health or well-being.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Frenzy|Barbarian||Berserker||3"
                    }
                ]
            },
            {
                "name": "Frenzy",
                "source": "PHB",
                "page": 49,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Berserker",
                "subclassSource": "PHB",
                "level": 3,
                "header": 1,
                "entries": [
                    "Starting when you choose this path at 3rd level, you can go into a frenzy when you rage. If you do so, for the duration of your rage you can make a single melee weapon attack as a bonus action on each of your turns after this one. When your rage ends, you suffer one level of {@condition exhaustion}."
                ]
            },
            {
                "name": "Mindless Rage",
                "source": "PHB",
                "page": 49,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Berserker",
                "subclassSource": "PHB",
                "level": 6,
                "header": 2,
                "entries": [
                    "Beginning at 6th level, you can't be {@condition charmed} or {@condition frightened} while raging. If you are {@condition charmed} or {@condition frightened} when you enter your rage, the effect is suspended for the duration of the rage."
                ]
            },
            {
                "name": "Intimidating Presence",
                "source": "PHB",
                "page": 49,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Berserker",
                "subclassSource": "PHB",
                "level": 10,
                "header": 2,
                "entries": [
                    "Beginning at 10th level, you can use your action to frighten someone with your menacing presence. When you do so, choose one creature that you can see within 30 feet of you. If the creature can see or hear you, it must succeed on a Wisdom saving throw (DC equal to 8 + your proficiency bonus + your Charisma modifier) or be {@condition frightened} of you until the end of your next turn. On subsequent turns, you can use your action to extend the duration of this effect on the {@condition frightened} creature until the end of your next turn. This effect ends if the creature ends its turn out of line of sight or more than 60 feet away from you.",
                    "If the creature succeeds on its saving throw, you can't use this feature on that creature again for 24 hours."
                ]
            },
            {
                "name": "Retaliation",
                "source": "PHB",
                "page": 49,
                "srd": true,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Berserker",
                "subclassSource": "PHB",
                "level": 14,
                "header": 2,
                "entries": [
                    "Starting at 14th level, when you take damage from a creature that is within 5 feet of you, you can use your reaction to make a melee weapon attack against that creature."
                ]
            },
            {
                "name": "Bear",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "While raging, you have resistance to all damage except psychic damage. The spirit of the bear makes you tough enough to stand up to any punishment."
                ]
            },
            {
                "name": "Eagle",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "While you're raging and aren't wearing heavy armor, other creatures have disadvantage on opportunity attack rolls against you, and you can use the {@action Dash} action as a bonus action on your turn. The spirit of the eagle makes you into a predator who can weave through the fray with ease."
                ]
            },
            {
                "name": "Path of the Totem Warrior",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "The Path of the Totem Warrior is a spiritual journey, as the barbarian accepts a spirit animal as guide, protector, and inspiration. In battle, your totem spirit fills you with supernatural might, adding magical fuel to your barbarian rage.",
                    "Most barbarian tribes consider a totem animal to be kin to a particular clan. In such cases, it is unusual for an individual to have more than one totem animal spirit, though exceptions exist.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Spirit Seeker|Barbarian||Totem Warrior||3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Totem Spirit|Barbarian||Totem Warrior||3"
                    }
                ]
            },
            {
                "name": "Wolf",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "While you're raging, your friends have advantage on melee attack rolls against any creature within 5 feet of you that is hostile to you. The spirit of the wolf makes you a leader of hunters."
                ]
            },
            {
                "name": "Spirit Seeker",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "header": 1,
                "entries": [
                    "Yours is a path that seeks attunement with the natural world, giving you a kinship with beasts. At 3rd level when you adopt this path, you gain the ability to cast the {@spell beast sense} and {@spell speak with animals} spells, but only as rituals, as described in {@book chapter 10|PHB|10|rituals}."
                ]
            },
            {
                "name": "Totem Spirit",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "header": 1,
                "entries": [
                    "At 3rd level, when you adopt this path, you choose a totem spirit and gain its feature. You must make or acquire a physical totem object\u2014an amulet or similar adornment\u2014that incorporates fur or feathers, claws, teeth, or bones of the totem animal. At your option, you also gain minor physical attributes that are reminiscent of your totem spirit. For example, if you have a bear totem spirit, you might be unusually hairy and thick-skinned, or if your totem is the eagle, your eyes turn bright yellow.",
                    "Your totem animal might be an animal related to those listed here but more appropriate to your homeland. For example, you could choose a hawk or vulture in place of an eagle.",
                    {
                        "type": "options",
                        "count": 1,
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Bear|Barbarian||Totem Warrior||3"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Eagle|Barbarian||Totem Warrior||3"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Elk|Barbarian|SCAG|Totem Warrior||3|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tiger|Barbarian|SCAG|Totem Warrior||3|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Wolf|Barbarian||Totem Warrior||3"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Bear",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "entries": [
                    "You gain the might of a bear. Your carrying capacity (including maximum load and maximum lift) is doubled, and you have advantage on Strength checks made to push, pull, lift, or break objects."
                ]
            },
            {
                "name": "Eagle",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "entries": [
                    "You gain the eyesight of an eagle. You can see up to 1 mile away with no difficulty, able to discern even fine details as though looking at something no more than 100 feet away from you. Additionally, dim light doesn't impose disadvantage on your Wisdom ({@skill Perception}) checks."
                ]
            },
            {
                "name": "Wolf",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "entries": [
                    "You gain the hunting sensibilities of a wolf. You can track other creatures while traveling at a fast pace, and you can move stealthily while traveling at a normal pace."
                ]
            },
            {
                "name": "Aspect of the Beast",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "header": 2,
                "entries": [
                    "At 6th level, you gain a magical benefit based on the totem animal of your choice. You can choose the same animal you selected at 3rd level or a different one.",
                    {
                        "type": "options",
                        "count": 1,
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Bear|Barbarian||Totem Warrior||6"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Eagle|Barbarian||Totem Warrior||6"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Elk|Barbarian|SCAG|Totem Warrior||6|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tiger|Barbarian|SCAG|Totem Warrior||6|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Wolf|Barbarian||Totem Warrior||6"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Spirit Walker",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 10,
                "header": 2,
                "entries": [
                    "At 10th level, you can cast the {@spell commune with nature} spell, but only as a ritual. When you do so, a spiritual version of one of the animals you chose for Totem Spirit or Aspect of the Beast appears to you to convey the information you seek."
                ]
            },
            {
                "name": "Bear",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "entries": [
                    "While you're raging, any creature within 5 feet of you that's hostile to you has disadvantage on attack rolls against targets other than you or another character with this feature. An enemy is immune to this effect if it can't see or hear you or if it can't be {@condition frightened}."
                ]
            },
            {
                "name": "Eagle",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "entries": [
                    "While raging, you have a flying speed equal to your current walking speed. This benefit works only in short bursts; you fall if you end your turn in the air and nothing else is holding you aloft."
                ]
            },
            {
                "name": "Wolf",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "entries": [
                    "While you're raging, you can use a bonus action on your turn to knock a Large or smaller creature {@condition prone} when you hit it with melee weapon attack."
                ]
            },
            {
                "name": "Totemic Attunement",
                "source": "PHB",
                "page": 50,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "header": 2,
                "entries": [
                    "At 14th level, you gain a magical benefit based on a totem animal of your choice. You can choose the same animal you selected previously or a different one.",
                    {
                        "type": "options",
                        "count": 1,
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Bear|Barbarian||Totem Warrior||14"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Eagle|Barbarian||Totem Warrior||14"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Elk|Barbarian|SCAG|Totem Warrior||14|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tiger|Barbarian|SCAG|Totem Warrior||14|SCAG"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Wolf|Barbarian||Totem Warrior||14"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Path of the Battlerager",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 3,
                "entries": [
                    "Known as Kuldjargh (literally \"axe idiot\") in Dwarvish, battleragers are dwarf followers of the gods of war and take the Path of the Battlerager. They specialize in wearing bulky, {@item spiked armor|scag} and throwing themselves into combat, striking with their body itself and giving themselves over to the fury of battle.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Restriction\u2014Dwarves Only|Barbarian||Battlerager|SCAG|3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Battlerager Armor|Barbarian||Battlerager|SCAG|3"
                    }
                ]
            },
            {
                "name": "Battlerager Armor",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 3,
                "header": 1,
                "entries": [
                    "When you choose this path at 3rd level, you gain the ability to use {@item spiked armor|scag} as a weapon.",
                    "While you are wearing {@item spiked armor|scag} and are raging, you can use a bonus action to make one melee weapon attack with your armor spikes at a target within 5 feet of you. If the attack hits, the spikes deal {@damage 1d4} piercing damage. You use your Strength modifier for the attack and damage rolls.",
                    "Additionally, when you use the {@action Attack} action to grapple a creature, the target takes 3 piercing damage if your grapple check succeeds."
                ]
            },
            {
                "name": "Restriction\u2014Dwarves Only",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 3,
                "header": 1,
                "entries": [
                    "Only dwarves can follow the Path of the Battlerager. The battlerager fills a particular niche in dwarven society and culture.",
                    "Your DM can lift this restriction to better suit the campaign. The restriction exists for the Forgotten Realms. It might not apply to your DM's setting or your DM's version of the Realms."
                ]
            },
            {
                "name": "Reckless Abandon",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 6,
                "header": 2,
                "entries": [
                    "Beginning at 6th level, when you use Reckless Attack while raging, you also gain temporary hit points equal to your Constitution modifier (minimum of 1). They vanish if any of them are left when your rage ends."
                ]
            },
            {
                "name": "Battlerager Charge",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 10,
                "header": 2,
                "entries": [
                    "Beginning at 10th level, you can take the {@action Dash} action as a bonus action while you are raging."
                ]
            },
            {
                "name": "Spiked Retribution",
                "source": "SCAG",
                "page": 121,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Battlerager",
                "subclassSource": "SCAG",
                "level": 14,
                "header": 2,
                "entries": [
                    "Starting at 14th level, when a creature within 5 feet of you hits you with a melee attack, the attacker takes 3 piercing damage if you are raging, aren't {@condition incapacitated}, and are wearing {@item spiked armor|scag}."
                ]
            },
            {
                "name": "Path of the Beast",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Beast",
                "subclassSource": "TCE",
                "level": 3,
                "entries": [
                    "Barbarians who walk the Path of the Beast draw their rage from a bestial spark burning within their souls. That beast bursts forth in the throes of rage, physically transforming the barbarian.",
                    "Such a barbarian might be inhabited by a primal spirit or be descended from shape-shifters. You can choose the origin of your feral might or determine it by rolling on the Origin of the Beast table.",
                    {
                        "type": "table",
                        "caption": "Origin of the Beast",
                        "colLabels": [
                            "d4",
                            "Origin"
                        ],
                        "colStyles": [
                            "col-2 text-center",
                            "col-10"
                        ],
                        "rows": [
                            [
                                "1",
                                "One of your parents is a lycanthrope, and you've inherited some of their curse."
                            ],
                            [
                                "2",
                                "You are descended from an archdruid and inherited the ability to partially change shape."
                            ],
                            [
                                "3",
                                "A fey spirit gifted you with the ability to adopt different bestial aspects."
                            ],
                            [
                                "4",
                                "An ancient animal spirit dwells within you, allowing you to walk this path."
                            ]
                        ]
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Form of the Beast|Barbarian||Beast|TCE|3"
                    }
                ]
            },
            {
                "name": "Form of the Beast",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Beast",
                "subclassSource": "TCE",
                "level": 3,
                "header": 1,
                "entries": [
                    "{@i 3rd-level Path of the Beast feature}",
                    "When you enter your rage, you can transform, revealing the bestial power within you. Until the rage ends, you manifest a natural weapon. It counts as a simple melee weapon for you, and you add your Strength modifier to the attack and damage rolls when you attack with it, as normal.",
                    "You choose the weapon's form each time you rage:",
                    {
                        "type": "list",
                        "style": "list-hang-notitle",
                        "items": [
                            {
                                "type": "item",
                                "name": "Bite",
                                "entry": "Your mouth transforms into a bestial muzzle or great mandibles (your choice). It deals {@damage 1d8} piercing damage on a hit. Once on each of your turns when you damage a creature with this bite, you regain a number of hit points equal to your proficiency bonus, provided you have less than half your hit points when you hit."
                            },
                            {
                                "type": "item",
                                "name": "Claws",
                                "entry": "Each of your hands transforms into a claw, which you can use as a weapon if it's empty. It deals {@damage 1d6} slashing damage on a hit. Once on each of your turns when you attack with a claw using the {@action Attack} action, you can make one additional claw attack as part of the same action."
                            },
                            {
                                "type": "item",
                                "name": "Tail",
                                "entry": "You grow a lashing, spiny tail, which deals {@damage 1d8} piercing damage on a hit and has the reach property. If a creature you can see within 10 feet of you hits you with an attack roll, you can use your reaction to swipe your tail and roll a {@dice d8}, applying a bonus to your AC equal to the number rolled, potentially causing the attack to miss you."
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Bestial Soul",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Beast",
                "subclassSource": "TCE",
                "level": 6,
                "header": 2,
                "entries": [
                    "{@i 6th-level Path of the Beast feature}",
                    "The feral power within you increases, causing the natural weapons of your Form of the Beast to count as magical for the purpose of overcoming resistance and immunity to nonmagical attacks and damage.",
                    "You can also alter your form to help you adapt to your surroundings. When you finish a short or long rest, choose one of the following benefits, which lasts until you finish your next short or long rest:",
                    {
                        "type": "list",
                        "items": [
                            "You gain a swimming speed equal to your walking speed, and you can breathe underwater.",
                            "You gain a climbing speed equal to your walking speed, and you can climb difficult surfaces, including upside down on ceilings, without needing to make an ability check.",
                            "When you jump, you can make a Strength ({@skill Athletics}) check and extend your jump by a number of feet equal to the check's total. You can make this special check only once per turn."
                        ]
                    }
                ]
            },
            {
                "name": "Infectious Fury",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Beast",
                "subclassSource": "TCE",
                "level": 10,
                "header": 2,
                "entries": [
                    "{@i 10th-level Path of the Beast feature}",
                    "When you hit a creature with your natural weapons while you are raging, the beast within you can curse your target with rabid fury. The target must succeed on a Wisdom saving throw (DC equal to 8 + your Constitution modifier + your proficiency bonus) or suffer one of the following effects (your choice):",
                    {
                        "type": "list",
                        "items": [
                            "The target must use its reaction to make a melee attack against another creature of your choice that you can see.",
                            "The target takes {@damage 2d12} psychic damage."
                        ]
                    },
                    "You can use this feature a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                ]
            },
            {
                "name": "Call the Hunt",
                "source": "TCE",
                "page": 24,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Beast",
                "subclassSource": "TCE",
                "level": 14,
                "header": 2,
                "entries": [
                    "{@i 14th-level Path of the Beast feature}",
                    "The beast within you grows so powerful that you can spread its ferocity to others and gain resilience from them joining your hunt. When you enter your rage, you can choose a number of other willing creatures you can see within 30 feet of you equal to your Constitution modifier (minimum of one creature).",
                    "You gain 5 temporary hit points for each creature that accepts this feature. Until the rage ends, the chosen creatures can each use the following benefit once on each of their turns: when the creature hits a target with an attack roll and deals damage to it, the creature can roll a {@dice d6} and gain a bonus to the damage equal to the number rolled.",
                    "You can use this feature a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                ]
            },
            {
                "name": "Path of Wild Magic",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 3,
                "entries": [
                    "Many places in the multiverse abound with beauty, intense emotion, and rampant magic; the Feywild, the Upper Planes, and other realms of supernatural power radiate with such forces and can profoundly influence people. As folk of deep feeling, barbarians are especially susceptible to these wild influences, with some barbarians being transformed by the magic. These magic-suffused barbarians walk the Path of Wild Magic. Elf, tiefling, aasimar, and genasi barbarians often seek this path, eager to manifest the otherworldly magic of their ancestors.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Magic Awareness|Barbarian||Wild Magic|TCE|3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Wild Surge|Barbarian||Wild Magic|TCE|3"
                    }
                ]
            },
            {
                "name": "Magic Awareness",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 3,
                "header": 1,
                "entries": [
                    "{@i 3rd-level Path of Wild Magic feature}",
                    "As an action, you can open your awareness to the presence of concentrated magic. Until the end of your next turn, you know the location of any spell or magic item within 60 feet of you that isn't behind total cover. When you sense a spell, you learn which school of magic it belongs to.",
                    "You can use this feature a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                ]
            },
            {
                "name": "Wild Surge",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 3,
                "header": 1,
                "entries": [
                    "{@i 3rd-level Path of Wild Magic feature}",
                    "The magical energy roiling inside you sometimes erupts from you. When you enter your rage, roll on the Wild Magic table to determine the magical effect produced.",
                    "If the effect requires a saving throw, the DC equals 8 + your proficiency bonus + your Constitution modifier.",
                    {
                        "type": "table",
                        "caption": "Wild Magic",
                        "colLabels": [
                            "d8",
                            "Magical Effect"
                        ],
                        "colStyles": [
                            "col-2 text-center",
                            "col-10"
                        ],
                        "rows": [
                            [
                                "1",
                                "Shadowy tendrils lash around you. Each creature of your choice that you can see within 30 feet of you must succeed on a Constitution saving throw or take {@damage 1d12} necrotic damage. You also gain {@dice 1d12} temporary hit points."
                            ],
                            [
                                "2",
                                "You teleport up to 30 feet to an unoccupied space you can see. Until your rage ends, you can use this effect again on each of your turns as a bonus action."
                            ],
                            [
                                "3",
                                "An intangible spirit, which looks like a {@creature flumph} or a {@creature pixie} (your choice), appears within 5 feet of one creature of your choice that you can see within 30 feet of you. At the end of the current turn, the spirit explodes, and each creature within 5 feet of it must succeed on a Dexterity saving throw or take {@damage 1d6} force damage. Until your rage ends, you can use this effect again, summoning another spirit, on each of your turns as a bonus action."
                            ],
                            [
                                "4",
                                "Magic infuses one weapon of your choice that you are holding. Until your rage ends, the weapon's damage type changes to force, and it gains the light and thrown properties, with a normal range of 20 feet and a long range of 60 feet. If the weapon leaves your hand, the weapon reappears in your hand at the end of the current turn."
                            ],
                            [
                                "5",
                                "Whenever a creature hits you with an attack roll before your rage ends, that creature takes {@damage 1d6} force damage, as magic lashes out in retribution."
                            ],
                            [
                                "6",
                                "Until your rage ends, you are surrounded by multi colored, protective lights; you gain a +1 bonus to AC, and while within 10 feet of you, your allies gain the same bonus."
                            ],
                            [
                                "7",
                                "Flowers and vines temporarily grow around you. Until your rage ends, the ground within 15 feet of you is {@quickref difficult terrain||3} for your enemies."
                            ],
                            [
                                "8",
                                "A bolt of light shoots from your chest. Another creature of your choice that you can see within 30 feet of you must succeed on a Constitution saving throw or take {@damage 1d6} radiant damage and be {@condition blinded} until the start of your next turn. Until your rage ends, you can use this effect again on each of your turns as a bonus action."
                            ]
                        ],
                        "data": {
                            "tableInclude": true
                        }
                    }
                ]
            },
            {
                "name": "Bolstering Magic",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 6,
                "header": 2,
                "entries": [
                    "{@i 6th-level Path of Wild Magic feature}",
                    "You can harness your wild magic to bolster yourself or a companion. As an action, you can touch one creature (which can be yourself) and confer one of the following benefits of your choice to that creature:",
                    {
                        "type": "list",
                        "items": [
                            "For 10 minutes, the creature can roll a {@dice d3} whenever making an attack roll or an ability check and add the number rolled to the {@dice d20} roll.",
                            "Roll a {@dice d3}. The creature regains one expended spell slot, the level of which equals the number rolled or lower (the creature's choice). Once a creature receives this benefit, that creature can't receive it again until after a long rest."
                        ]
                    },
                    "You can take this action a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest."
                ]
            },
            {
                "name": "Unstable Backlash",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 10,
                "header": 2,
                "entries": [
                    "{@i 10th-level Path of Wild Magic feature}",
                    "When you are imperiled during your rage, the magic within you can lash out; immediately after you take damage or fail a saving throw while raging, you can use your reaction to roll on the Wild Magic table and immediately produce the effect rolled. This effect replaces your current Wild Magic effect."
                ]
            },
            {
                "name": "Controlled Surge",
                "source": "TCE",
                "page": 25,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Wild Magic",
                "subclassSource": "TCE",
                "level": 14,
                "header": 2,
                "entries": [
                    "{@i 14th-level Path of Wild Magic feature}",
                    "Whenever you roll on the Wild Magic table, you can roll the die twice and choose which of the two effects to unleash. If you roll the same number on both dice, you can ignore the number and choose any effect on the table."
                ]
            },
            {
                "name": "Path of the Juggernaut",
                "source": "TDCSR",
                "page": 165,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 3,
                "entries": [
                    "Barbarians who follow the Path of the Juggernaut stand so resolutely that none can deter them, and they swing their weapons with such force that all who stand against them are flung aside. In might and in spirit, juggernauts are immovable object and unstoppable force all at once.",
                    "Juggernaut barbarians can be found all over Tal'Dorei, and are common among the goliath warriors of the {@book Rivermaw herd|TDCSR|3|Rivermaw Herd} that wanders the {@book Dividing Plains|TDCSR|3|Dividing Plains}. Some {@book dwarves|TDCSR|4|dwarves} and humanoid survivalists of the {@book Cliffkeep Mountains|TDCSR|3|Cliffkeep Mountains} adopt this fighting style as an extension of their rugged determinism. And a number of stalwart juggernauts hail from the jungles of the {@book Rifenmist Peninsula|TDCSR|3|Rifenmist Peninsula}, having cast off the oppressive yoke of the {@book Iron Authority|TDCSR|3|Tz'Arrm, Helm of the Emperor}.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Thunderous Blows|Barbarian|PHB|Juggernaut|TDCSR|3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Spirit of the Mountain|Barbarian|PHB|Juggernaut|TDCSR|3"
                    }
                ]
            },
            {
                "name": "Spirit of the Mountain",
                "source": "TDCSR",
                "page": 166,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 3,
                "header": 1,
                "entries": [
                    "At 3rd level, you harness your fury to anchor your feet to the ground, becoming a bulwark of strength. While you are raging, you can't be knocked {@condition prone} or moved along the ground against your will."
                ]
            },
            {
                "name": "Thunderous Blows",
                "source": "TDCSR",
                "page": 165,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 3,
                "header": 1,
                "entries": [
                    "Starting when you choose this path at 3rd level, your rage instills you with the strength to shove and smash your way through your foes, making any battlefield your domain. When you hit a creature with a melee attack while you're raging, you can push that creature up to 5 feet away from you in a direction of your choice. A creature that is Huge or larger makes a Strength {@quickref saving throws|PHB|2|1|saving throw} with a DC equal to 8 + your proficiency bonus + your Strength modifier. On a success, the creature is not pushed.",
                    {
                        "type": "inset",
                        "name": "Rules Tip: Forced Movement",
                        "page": 166,
                        "entries": [
                            "Usually when one creature moves out of a hostile creature's reach, the hostile creature can use its reaction to make an {@action opportunity attack}. However, forced movement\u2014such as being pushed by a Path of the Juggernaut barbarian's {@subclassFeature Thunderous Blows|Barbarian|PHB|Juggernaut|TDCSR|3} feature\u2014doesn't provoke {@action opportunity attack|PHB|opportunity attacks}.",
                            "Likewise, a juggernaut barbarian's {@subclassFeature Hurricane Strike|Barbarian|PHB|Juggernaut|TDCSR|10} feature allows an ally to make a melee weapon attack as a reaction only if the foe ends its forced movement within 5 feet of the ally. If a foe is pushed through other spaces within 5 feet of your allies, those allies can't make normal {@action opportunity attack|PHB|opportunity attacks} against the foe."
                        ]
                    }
                ]
            },
            {
                "name": "Demolishing Might",
                "source": "TDCSR",
                "page": 166,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 6,
                "header": 2,
                "entries": [
                    "Starting at 6th level, your melee weapon attacks deal an extra {@damage 1d8} damage to constructs, and deal double damage to objects and structures."
                ]
            },
            {
                "name": "Resolute Stance",
                "source": "TDCSR",
                "page": 166,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 6,
                "header": 2,
                "entries": [
                    "Also at 6th level, you can temporarily refocus your combat ability to make yourself a bulwark of defense. At the start of your turn (no action required), you can assume a defensive stance that lasts until the start of your next turn. While in this stance, you can't be {@condition grappled}, attack rolls against you have {@quickref Advantage and Disadvantage|PHB|2|0|disadvantage}, and your weapon attacks are made with {@quickref Advantage and Disadvantage|PHB|2|0|disadvantage}."
                ]
            },
            {
                "name": "Hurricane Strike",
                "source": "TDCSR",
                "page": 166,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 10,
                "header": 2,
                "entries": [
                    "Starting at 10th level, your blows can hurl foes through the air and into the attacks of your allies. As a reaction when you push a creature at least 5 feet, you can then leap into an unoccupied space next to the creature. If you do so, the creature must succeed on a Strength {@quickref saving throws|PHB|2|1|saving throw} with a DC equal to 8 + your proficiency bonus + your Strength modifier or be knocked {@condition prone}. This leap costs no movement and does not provoke {@action opportunity attack|PHB|opportunity attacks}.",
                    "Additionally, whenever you push a creature into a space within 5 feet of one of your allies, the ally can use its reaction to make a melee weapon attack against that creature."
                ]
            },
            {
                "name": "Thunderous Blows (10th Level)",
                "source": "TDCSR",
                "page": 165,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 10,
                "header": 2,
                "entries": [
                    "Starting at 10th level, you can push a creature up to 10 feet when you hit it with a melee attack while you're raging."
                ]
            },
            {
                "name": "Unstoppable",
                "source": "TDCSR",
                "page": 166,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Juggernaut",
                "subclassSource": "TDCSR",
                "level": 14,
                "header": 2,
                "entries": [
                    "At 14th level, your fury in battle makes you unstoppable. While you're raging, your speed cannot be reduced, and you are immune to the {@condition frightened}, {@condition paralyzed}, {@condition prone}, and {@condition stunned} conditions.",
                    "If you are {@condition frightened}, {@condition paralyzed}, or {@condition stunned}, you can still use a bonus action to enter a rage (even if you can't otherwise take actions). You aren't affected by any of these conditions while you're raging."
                ]
            },
            {
                "name": "Path of the Ancestral Guardian",
                "source": "XGE",
                "page": 9,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Ancestral Guardian",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "Some barbarians hail from cultures that revere their ancestors. These tribes teach that the warriors of the past linger in the world as mighty spirits, who can guide and protect the living. When a barbarian who follows this path rages, the barbarian contacts the spirit world and calls on these guardian spirits for aid.",
                    "Barbarians who draw on their ancestral guardians can better fight to protect their tribes and their allies. In order to cement ties to their ancestral guardians, barbarians who follow this path cover themselves in elaborate tattoos that celebrate their ancestors' deeds. These tattoos tell sagas of victories against terrible monsters and other fearsome rivals.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Ancestral Protectors|Barbarian||Ancestral Guardian|XGE|3"
                    }
                ]
            },
            {
                "name": "Ancestral Protectors",
                "source": "XGE",
                "page": 9,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Ancestral Guardian",
                "subclassSource": "XGE",
                "level": 3,
                "header": 1,
                "entries": [
                    "Starting when you choose this path at 3rd level, spectral warriors appear when you enter your rage. While you're raging, the first creature you hit with an attack on your turn becomes the target of the warriors, which hinder its attacks. Until the start of your next turn, that target has disadvantage on any attack roll that isn't against you, and when the target hits a creature other than you with an attack, that creature has resistance to the damage dealt by the attack. The effect on the target ends early if your rage ends."
                ]
            },
            {
                "name": "Spirit Shield",
                "source": "XGE",
                "page": 9,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Ancestral Guardian",
                "subclassSource": "XGE",
                "level": 6,
                "header": 2,
                "entries": [
                    "Beginning at 6th level, the guardian spirits that aid you can provide supernatural protection to those you defend. If you are raging and another creature you can see within 30 feet of you takes damage, you can use your reaction to reduce that damage by {@dice 2d6}.",
                    "When you reach certain levels in this class, you can reduce the damage by more: by {@dice 3d6} at 10th level and by {@dice 4d6} at 14th level."
                ]
            },
            {
                "name": "Consult the Spirits",
                "source": "XGE",
                "page": 9,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Ancestral Guardian",
                "subclassSource": "XGE",
                "level": 10,
                "header": 2,
                "entries": [
                    "At 10th level, you gain the ability to consult with your ancestral spirits. When you do so, you cast the {@spell augury} or {@spell clairvoyance} spell, without using a spell slot or material components. Rather than creating a spherical sensor, this use of {@spell clairvoyance} invisibly summons one of your ancestral spirits to the chosen location. Wisdom is your spellcasting ability for these spells.",
                    "After you cast either spell in this way, you can't use this feature again until you finish a short or long rest."
                ]
            },
            {
                "name": "Vengeful Ancestors",
                "source": "XGE",
                "page": 9,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Ancestral Guardian",
                "subclassSource": "XGE",
                "level": 14,
                "header": 2,
                "entries": [
                    "At 14th level, your ancestral spirits grow powerful enough to retaliate. When you use your Spirit Shield to reduce the damage of an attack, the attacker takes an amount of force damage equal to the damage that your Spirit Shield prevents."
                ]
            },
            {
                "name": "Path of the Storm Herald",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "All barbarians harbor a fury within. Their rage grants them superior strength, durability, and speed. Barbarians who follow the Path of the Storm Herald learn to transform that rage into a mantle of primal magic, which swirls around them. When in a fury, a barbarian of this path taps into the forces of nature to create powerful magical effects.",
                    "Storm heralds are typically elite champions who train alongside druids, rangers, and others sworn to protect nature. Other storm heralds hone their craft in lodges in regions wracked by storms, in the frozen reaches at the world's end, or deep in the hottest deserts.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Storm Aura|Barbarian||Storm Herald|XGE|3"
                    }
                ]
            },
            {
                "name": "Storm Aura",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 3,
                "header": 1,
                "entries": [
                    "Starting at 3rd level, you emanate a stormy, magical aura while you rage. The aura extends 10 feet from you in every direction, but not through total cover.",
                    "Your aura has an effect that activates when you enter your rage, and you can activate the effect again on each of your turns as a bonus action. Choose desert, sea, or tundra. Your aura's effect depends on that chosen environment, as detailed below. You can change your environment choice whenever you gain a level in this class.",
                    "If your aura's effects require a saving throw, the DC equals 8 + your proficiency bonus + your Constitution modifier.",
                    {
                        "type": "options",
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Desert|Barbarian|XGE|Storm Herald|XGE|3"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Sea|Barbarian|XGE|Storm Herald|XGE|3"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tundra|Barbarian|XGE|Storm Herald|XGE|3"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Storm Soul",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 6,
                "header": 2,
                "entries": [
                    "At 6th level, the storm grants you benefits even when your aura isn't active. The benefits are based on the environment you chose for your Storm Aura.",
                    {
                        "type": "options",
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Desert|Barbarian|XGE|Storm Herald|XGE|6"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Sea|Barbarian|XGE|Storm Herald|XGE|6"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tundra|Barbarian|XGE|Storm Herald|XGE|6"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Shielding Storm",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 10,
                "header": 2,
                "entries": [
                    "At 10th level, you learn to use your mastery of the storm to protect others. Each creature of your choice has the damage resistance you gained from the Storm Soul feature while the creature is in your Storm Aura."
                ]
            },
            {
                "name": "Raging Storm",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 14,
                "header": 2,
                "entries": [
                    "At 14th level, the power of the storm you channel grows mightier, lashing out at your foes. The effect is based on the environment you chose for your Storm Aura.",
                    {
                        "type": "options",
                        "entries": [
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Desert|Barbarian|XGE|Storm Herald|XGE|14"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Sea|Barbarian|XGE|Storm Herald|XGE|14"
                            },
                            {
                                "type": "refSubclassFeature",
                                "subclassFeature": "Tundra|Barbarian|XGE|Storm Herald|XGE|14"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Path of the Zealot",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "Some deities inspire their followers to pitch themselves into a ferocious battle fury. These barbarians are zealots\u2014warriors who channel their rage into powerful displays of divine power.",
                    "A variety of gods across the worlds of D&D inspire their followers to embrace this path. Tempus from the Forgotten Realms and Hextor and Erythnul of Greyhawk are all prime examples. In general, the gods who inspire zealots are deities of combat, destruction, and violence. Not all are evil, but few are good.",
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Divine Fury|Barbarian||Zealot|XGE|3"
                    },
                    {
                        "type": "refSubclassFeature",
                        "subclassFeature": "Warrior of the Gods|Barbarian||Zealot|XGE|3"
                    }
                ]
            },
            {
                "name": "Divine Fury",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 3,
                "header": 1,
                "entries": [
                    "Starting when you choose this path at 3rd level, you can channel divine fury into your weapon strikes. While you're raging, the first creature you hit on each of your turns with a weapon attack takes extra damage equal to {@dice 1d6} + half your barbarian level. The extra damage is necrotic or radiant; you choose the type of damage when you gain this feature."
                ]
            },
            {
                "name": "Warrior of the Gods",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 3,
                "header": 1,
                "entries": [
                    "At 3rd level, your soul is marked for endless battle. If a spell, such as {@spell raise dead}, has the sole effect of restoring you to life (but not undeath), the caster doesn't need material components to cast the spell on you."
                ]
            },
            {
                "name": "Fanatical Focus",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 6,
                "header": 2,
                "entries": [
                    "Starting at 6th level, the divine power that fuels your rage can protect you. If you fail a saving throw while you're raging, you can reroll it, and you must use the new roll. You can use this ability only once per rage."
                ]
            },
            {
                "name": "Zealous Presence",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 10,
                "header": 2,
                "entries": [
                    "At 10th level, you learn to channel divine power to inspire zealotry in others. As a bonus action, you unleash a battle cry infused with divine energy. Up to ten other creatures of your choice within 60 feet of you that can hear you gain advantage on attack rolls and saving throws until the start of your next turn.",
                    "Once you use this feature, you can't use it again until you finish a long rest."
                ]
            },
            {
                "name": "Rage beyond Death",
                "source": "XGE",
                "page": 11,
                "className": "Barbarian",
                "classSource": "PHB",
                "subclassShortName": "Zealot",
                "subclassSource": "XGE",
                "level": 14,
                "header": 2,
                "entries": [
                    "Beginning at 14th level, the divine power that fuels your rage allows you to shrug off fatal blows.",
                    "While you're raging, having 0 hit points doesn't knock you {@condition unconscious}. You still must make death saving throws, and you suffer the normal effects of taking damage while at 0 hit points. However, if you would die due to failing death saving throws, you don't die until your rage ends, and you die then only if you still have 0 hit points."
                ]
            },
            {
                "name": "Elk",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "While you're raging and aren't wearing heavy armor, your walking speed increases by 15 feet. The spirit of the elk makes you extraordinarily swift."
                ]
            },
            {
                "name": "Tiger",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 3,
                "entries": [
                    "While raging, you can add 10 feet to your long jump distance and 3 feet to your high jump distance. The spirit of the tiger empowers your leaps."
                ]
            },
            {
                "name": "Elk",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "entries": [
                    "Whether mounted or on foot, your travel pace is doubled, as is the travel pace of up to ten companions while they're within 60 feet of you and you're not {@condition incapacitated}. The elk spirit helps you roam far and fast."
                ]
            },
            {
                "name": "Tiger",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 6,
                "entries": [
                    "You gain proficiency in two skills from the following list: {@skill Athletics}, {@skill Acrobatics}, {@skill Stealth}, and {@skill Survival}. The cat spirit hones your survival instincts."
                ]
            },
            {
                "name": "Elk",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "entries": [
                    "While raging, you can use a bonus action during your move to pass through the space of a Large or smaller creature. That creature must succeed on a Strength saving throw (DC 8 + your Strength bonus + your proficiency bonus) or be knocked {@condition prone} and take bludgeoning damage equal to {@dice 1d12} + your Strength modifier."
                ]
            },
            {
                "name": "Tiger",
                "source": "SCAG",
                "page": 122,
                "className": "Barbarian",
                "classSource": "SCAG",
                "subclassShortName": "Totem Warrior",
                "subclassSource": "PHB",
                "level": 14,
                "entries": [
                    "While you're raging, if you move at least 20 feet in a straight line toward a Large or smaller target right before making a melee weapon attack against it, you can use a bonus action to make an additional melee weapon attack against it."
                ]
            },
            {
                "name": "Desert",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "When this effect is activated, all other creatures in your aura take 2 fire damage each. The damage increases when you reach certain levels in this class, increasing to 3 at 5th level, 4 at 10th level, 5 at 15th level, and 6 at 20th level."
                ]
            },
            {
                "name": "Sea",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "When this effect is activated, you can choose one other creature you can see in your aura. The target must make a Dexterity saving throw. The target takes {@damage 1d6} lightning damage on a failed save, or half as much damage on a successful one. The damage increases when you reach certain levels in this class, increasing to {@dice 2d6} at 10th level, {@dice 3d6} at 15th level, and {@dice 4d6} at 20th level."
                ]
            },
            {
                "name": "Tundra",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 3,
                "entries": [
                    "When this effect is activated, each creature of your choice in your aura gains 2 temporary hit points, as icy spirits inure it to suffering. The temporary hit points increase when you reach certain levels in this class, increasing to 3 at 5th level, 4 at 10th level, 5 at 15th level, and 6 at 20th level."
                ]
            },
            {
                "name": "Desert",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 6,
                "entries": [
                    "You gain resistance to fire damage, and you don't suffer the effects of extreme heat, as described in the Dungeon Master's Guide. Moreover, as an action, you can touch a flammable object that isn't being worn or carried by anyone else and set it on fire."
                ]
            },
            {
                "name": "Sea",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 6,
                "entries": [
                    "You gain resistance to lightning damage, and you can breathe underwater. You also gain a swimming speed of 30 feet."
                ]
            },
            {
                "name": "Tundra",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 6,
                "entries": [
                    "You gain resistance to cold damage, and you don't suffer the effects of extreme cold, as described in the Dungeon Master's Guide. Moreover, as an action, you can touch water and turn a 5-foot cube of it into ice, which melts after 1 minute. This action fails if a creature is in the cube."
                ]
            },
            {
                "name": "Desert",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 14,
                "entries": [
                    "Immediately after a creature in your aura hits you with an attack, you can use your reaction to force that creature to make a Dexterity saving throw. On a failed save, the creature takes fire damage equal to half your barbarian level."
                ]
            },
            {
                "name": "Sea",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 14,
                "entries": [
                    "When you hit a creature in your aura with an attack, you can use your reaction to force that creature to make a Strength saving throw. On a failed save, the creature is knocked {@condition prone}, as if struck by a wave."
                ]
            },
            {
                "name": "Tundra",
                "source": "XGE",
                "page": 10,
                "className": "Barbarian",
                "classSource": "XGE",
                "subclassShortName": "Storm Herald",
                "subclassSource": "XGE",
                "level": 14,
                "entries": [
                    "Whenever the effect of your Storm Aura is activated, you can choose one creature you can see in the aura. That creature must succeed on a Strength saving throw, or its speed is reduced to 0 until the start of your next turn, as magical frost covers it."
                ]
            }
        ]
    }
        `;

        const class_bard = String.raw`{
            "class": [
                {
                    "name": "Bard",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "hd": {
                        "number": 1,
                        "faces": 8
                    },
                    "proficiency": [
                        "dex",
                        "cha"
                    ],
                    "spellcastingAbility": "cha",
                    "casterProgression": "full",
                    "cantripProgression": [
                        2,
                        2,
                        2,
                        3,
                        3,
                        3,
                        3,
                        3,
                        3,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4,
                        4
                    ],
                    "spellsKnownProgression": [
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        14,
                        15,
                        15,
                        16,
                        18,
                        19,
                        19,
                        20,
                        22,
                        22,
                        22
                    ],
                    "additionalSpells": [
                        {
                            "name": "Magical Secrets",
                            "known": {
                                "10": [
                                    {
                                        "choose": "level=0;1;2;3;4;5"
                                    },
                                    {
                                        "choose": "level=0;1;2;3;4;5"
                                    }
                                ],
                                "14": [
                                    {
                                        "choose": "level=0;1;2;3;4;5;6;7"
                                    },
                                    {
                                        "choose": "level=0;1;2;3;4;5;6;7"
                                    }
                                ],
                                "18": [
                                    {
                                        "choose": ""
                                    },
                                    {
                                        "choose": ""
                                    }
                                ]
                            }
                        }
                    ],
                    "startingProficiencies": {
                        "armor": [
                            "light"
                        ],
                        "weapons": [
                            "simple",
                            "{@item hand crossbow|phb|hand crossbows}",
                            "{@item longsword|phb|longswords}",
                            "{@item rapier|phb|rapiers}",
                            "{@item shortsword|phb|shortswords}"
                        ],
                        "tools": [
                            "three {@item musical instrument|PHB|musical instruments} of your choice"
                        ],
                        "toolProficiencies": [
                            {
                                "anyMusicalInstrument": 3
                            }
                        ],
                        "skills": [
                            {
                                "any": 3
                            }
                        ]
                    },
                    "startingEquipment": {
                        "additionalFromBackground": true,
                        "default": [
                            "(a) a {@item rapier|phb}, (b) a {@item longsword|phb}, or (c) any {@filter simple weapon|items|source=phb|category=basic|type=simple weapon}",
                            "(a) a {@item diplomat's pack|phb} or (b) an {@item entertainer's pack|phb}",
                            "(a) a {@item lute|phb} or (b) any other {@filter musical instrument|items|miscellaneous=mundane|type=instrument}",
                            "{@item Leather armor|phb}, and a {@item dagger|phb}"
                        ],
                        "goldAlternative": "{@dice 5d4 × 10|5d4 × 10|Starting Gold}",
                        "defaultData": [
                            {
                                "a": [
                                    "rapier|phb"
                                ],
                                "b": [
                                    "longsword|phb"
                                ],
                                "c": [
                                    {
                                        "equipmentType": "weaponSimple"
                                    }
                                ]
                            },
                            {
                                "a": [
                                    "diplomat's pack|phb"
                                ],
                                "b": [
                                    "entertainer's pack|phb"
                                ]
                            },
                            {
                                "a": [
                                    "lute|phb"
                                ],
                                "b": [
                                    {
                                        "equipmentType": "instrumentMusical"
                                    }
                                ]
                            },
                            {
                                "_": [
                                    "Leather armor|phb",
                                    "dagger|phb"
                                ]
                            }
                        ]
                    },
                    "multiclassing": {
                        "requirements": {
                            "cha": 13
                        },
                        "proficienciesGained": {
                            "armor": [
                                "light"
                            ],
                            "skills": [
                                {
                                    "choose": {
                                        "from": [
                                            "athletics",
                                            "acrobatics",
                                            "sleight of hand",
                                            "stealth",
                                            "arcana",
                                            "history",
                                            "investigation",
                                            "nature",
                                            "religion",
                                            "animal handling",
                                            "insight",
                                            "medicine",
                                            "perception",
                                            "survival",
                                            "deception",
                                            "intimidation",
                                            "performance",
                                            "persuasion"
                                        ],
                                        "count": 1
                                    }
                                }
                            ],
                            "tools": [
                                "one {@item musical instrument|PHB} of your choice"
                            ],
                            "toolProficiencies": [
                                {
                                    "anyMusicalInstrument": 1
                                }
                            ]
                        }
                    },
                    "classTableGroups": [
                        {
                            "colLabels": [
                                "{@filter Cantrips Known|spells|level=0|class=bard}",
                                "{@filter Spells Known|spells|class=bard}"
                            ],
                            "rows": [
                                [
                                    2,
                                    4
                                ],
                                [
                                    2,
                                    5
                                ],
                                [
                                    2,
                                    6
                                ],
                                [
                                    3,
                                    7
                                ],
                                [
                                    3,
                                    8
                                ],
                                [
                                    3,
                                    9
                                ],
                                [
                                    3,
                                    10
                                ],
                                [
                                    3,
                                    11
                                ],
                                [
                                    3,
                                    12
                                ],
                                [
                                    4,
                                    14
                                ],
                                [
                                    4,
                                    15
                                ],
                                [
                                    4,
                                    15
                                ],
                                [
                                    4,
                                    16
                                ],
                                [
                                    4,
                                    18
                                ],
                                [
                                    4,
                                    19
                                ],
                                [
                                    4,
                                    19
                                ],
                                [
                                    4,
                                    20
                                ],
                                [
                                    4,
                                    22
                                ],
                                [
                                    4,
                                    22
                                ],
                                [
                                    4,
                                    22
                                ]
                            ]
                        },
                        {
                            "title": "Spell Slots per Spell Level",
                            "colLabels": [
                                "{@filter 1st|spells|level=1|class=bard}",
                                "{@filter 2nd|spells|level=2|class=bard}",
                                "{@filter 3rd|spells|level=3|class=bard}",
                                "{@filter 4th|spells|level=4|class=bard}",
                                "{@filter 5th|spells|level=5|class=bard}",
                                "{@filter 6th|spells|level=6|class=bard}",
                                "{@filter 7th|spells|level=7|class=bard}",
                                "{@filter 8th|spells|level=8|class=bard}",
                                "{@filter 9th|spells|level=9|class=bard}"
                            ],
                            "rowsSpellProgression": [
                                [
                                    2,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    3,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    2,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    2,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    1,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    2,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    1,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    0,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    0,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    0,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    1,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    1,
                                    0
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    1,
                                    1
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    3,
                                    1,
                                    1,
                                    1,
                                    1
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    3,
                                    2,
                                    1,
                                    1,
                                    1
                                ],
                                [
                                    4,
                                    3,
                                    3,
                                    3,
                                    3,
                                    2,
                                    2,
                                    1,
                                    1
                                ]
                            ]
                        }
                    ],
                    "classFeatures": [
                        "Bardic Inspiration|Bard||1",
                        "Spellcasting|Bard||1",
                        "Jack of All Trades|Bard||2",
                        "Song of Rest (d6)|Bard||2",
                        "Magical Inspiration|Bard||2|TCE",
                        {
                            "classFeature": "Bard College|Bard||3",
                            "gainSubclassFeature": true
                        },
                        "Expertise|Bard||3",
                        "Ability Score Improvement|Bard||4",
                        "Bardic Versatility|Bard||4|TCE",
                        "Bardic Inspiration (d8)|Bard||5",
                        "Font of Inspiration|Bard||5",
                        "Countercharm|Bard||6",
                        {
                            "classFeature": "Bard College feature|Bard||6",
                            "gainSubclassFeature": true
                        },
                        "Ability Score Improvement|Bard||8",
                        "Song of Rest (d8)|Bard||9",
                        "Bardic Inspiration (d10)|Bard||10",
                        "Expertise|Bard||10",
                        "Magical Secrets|Bard||10",
                        "Ability Score Improvement|Bard||12",
                        "Song of Rest (d10)|Bard||13",
                        "Magical Secrets|Bard||14",
                        {
                            "classFeature": "Bard College feature|Bard||14",
                            "gainSubclassFeature": true
                        },
                        "Bardic Inspiration (d12)|Bard||15",
                        "Ability Score Improvement|Bard||16",
                        "Song of Rest (d12)|Bard||17",
                        "Magical Secrets|Bard||18",
                        "Ability Score Improvement|Bard||19",
                        "Superior Inspiration|Bard||20"
                    ],
                    "subclassTitle": "Bard College",
                    "fluff": [
                        {
                            "name": "Bard",
                            "type": "section",
                            "entries": [
                                "Humming as she traces her fingers over an ancient monument in a long-forgotten ruin, a half-elf in rugged leathers finds knowledge springing into her mind, conjured forth by the magic of her song\u2014knowledge of the people who constructed the monument and the mythic saga it depicts.",
                                "A stern human warrior bangs his sword rhythmically against his scale mail, setting the tempo for his war chant and exhorting his companions to bravery and heroism. The magic of his song fortifies and emboldens them.",
                                "Laughing as she tunes her cittern, a gnome weaves her subtle magic over the assembled nobles, ensuring that her companions' words will be well received.",
                                "Whether scholar, skald, or scoundrel, a bard weaves magic through words and music to inspire allies, demoralize foes, manipulate minds, create illusions, and even heal wounds.",
                                {
                                    "type": "entries",
                                    "name": "Music and Magic",
                                    "entries": [
                                        "In the worlds of D&D, words and music are not just vibrations of air, but vocalizations with power all their own. The bard is a master of song, speech, and the magic they contain. Bards say that the multiverse was spoken into existence, that the words of the gods gave it shape, and that echoes of these primordial Words of Creation still resound throughout the cosmos. The music of bards is an attempt to snatch and harness those echoes, subtly woven into their spells and powers.",
                                        "The greatest strength of bards is their sheer versatility. Many bards prefer to stick to the sidelines in combat, using their magic to inspire their allies and hinder their foes from a distance. But bards are capable of defending themselves in melee if necessary, using their magic to bolster their swords and armor. Their spells lean toward charms and illusions rather than blatantly destructive spells. They have a wide-ranging knowledge of many subjects and a natural aptitude that lets them do almost anything well. Bards become masters of the talents they set their minds to perfecting, from musical performance to esoteric knowledge."
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "Learning from Experience",
                                    "entries": [
                                        "True bards are not common in the world. Not every minstrel singing in a tavern or jester cavorting in a royal court is a bard. Discovering the magic hidden in music requires hard study and some measure of natural talent that most troubadours and jongleurs lack. It can be hard to spot the difference between these performers and true bards, though. A bard's life is spent wandering across the land gathering lore, telling stories, and living on the gratitude of audiences, much like any other entertainer. But a depth of knowledge, a level of musical skill, and a touch of magic set bards apart from their fellows.",
                                        "Only rarely do bards settle in one place for long, and their natural desire to travel\u2014to find new tales to tell, new skills to learn, and new discoveries beyond the horizon\u2014makes an adventuring career a natural calling. Every adventure is an opportunity to learn, practice a variety of skills, enter long-forgotten tombs, discover lost works of magic, decipher old tomes, travel to strange places, or encounter exotic creatures. Bards love to accompany heroes to witness their deeds firsthand. A bard who can tell an awe-inspiring story from personal experience earns renown among other bards. Indeed, after telling so many stories about heroes accomplishing mighty deeds, many bards take these themes to heart and assume heroic roles themselves."
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "Creating a Bard",
                                    "entries": [
                                        "Bards thrive on stories, whether those stories are true or not. Your character's background and motivations are not as important as the stories that he or she tells about them. Perhaps you had a secure and mundane childhood. There's no good story to be told about that, so you might paint yourself as an orphan raised by a hag in a dismal swamp. Or your childhood might be worthy of a story. Some bards acquire their magical music through extraordinary means, including the inspiration of fey or other supernatural creatures.",
                                        "Did you serve an apprenticeship, studying under a master, following the more experienced bard until you were ready to strike out on your own? Or did you attend a college where you studied bardic lore and practiced your musical magic? Perhaps you were a young runaway or orphan, befriended by a wandering bard who became your mentor. Or you might have been a spoiled noble child tutored by a master. Perhaps you stumbled into the clutches of a hag, making a bargain for a musical gift in addition to your life and freedom, but at what cost?",
                                        {
                                            "type": "entries",
                                            "name": "Quick Build",
                                            "entries": [
                                                "You can make a bard quickly by following these suggestions. First, Charisma should be your highest ability score, followed by Dexterity. Second, choose the {@background entertainer} background. Third, choose the {@spell dancing lights} and {@spell vicious mockery} cantrips, along with the following 1st-level spells: {@spell charm person}, {@spell detect magic}, {@spell healing word}, and {@spell thunderwave}."
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "source": "PHB",
                            "page": 51
                        },
                        {
                            "type": "section",
                            "entries": [
                                {
                                    "type": "quote",
                                    "entries": [
                                        "Music is the fruit of the divine tree that vibrates with the Words of Creation. But the question I ask you is, can a bard go to the root of this tree? Can one tap into the source of that power? Ah, then what manner of music they would bring to this world!"
                                    ],
                                    "by": "Fletcher Danairia, master bard"
                                },
                                "Bards bring levity during grave times; they impart wisdom to offset ignorance; and they make the ridiculous seem sublime. Bards are preservers of ancient history, their songs and tales perpetuating the memory of great events down through time\u2014knowledge so important that it is memorized and passed along as oral history, to survive even when no written record remains.",
                                "It is also the bard's role to chronicle smaller and more contemporary events\u2014the stories of today's heroes, including their feats of valor as well as their less than impressive failures.",
                                "Of course, the world has many people who can carry a tune or tell a good story, and there's much more to any adventuring bard than a glib tongue and a melodious voice. Yet what truly sets bards apart from others\u2014and from one another\u2014are the style and substance of their performances.",
                                "To grab and hold the attention of an audience, bards are typically flamboyant and outgoing when they perform. The most famous of them are essentially the D&D world's equivalent of pop stars. If you're playing a bard, consider using one of your favorite musicians as a role model for your character.",
                                "You can add some unique aspects to your bard character by considering the suggestions that follow.",
                                {
                                    "type": "entries",
                                    "name": "Defining Work",
                                    "entries": [
                                        "Every successful bard is renowned for at least one piece of performance art, typically a song or a poem that is popular with everyone who hears it. These performances are spoken about for years by those who view them, and some spectators have had their lives forever changed because of the experience.",
                                        "If your character is just starting out, your ultimate defining work is likely in the future. But in order to make any sort of living at your profession, chances are you already have a piece or two in your repertoire that have proven to be audience pleasers.",
                                        {
                                            "type": "table",
                                            "caption": "Defining Work",
                                            "colLabels": [
                                                "{@dice d6}",
                                                "Defining Work"
                                            ],
                                            "colStyles": [
                                                "col-1 text-center",
                                                "col-11"
                                            ],
                                            "rows": [
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 1
                                                        }
                                                    },
                                                    "\"The Three Flambinis,\" a ribald song concerning mistaken identities and unfettered desire"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 2
                                                        }
                                                    },
                                                    "\"Waltz of the Myconids,\" an upbeat tune that children in particular enjoy"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 3
                                                        }
                                                    },
                                                    "\"Asmodeus's Golden Arse,\" a dramatic poem you claim was inspired by your personal visit to Avernus"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 4
                                                        }
                                                    },
                                                    "\"The Pirates of Luskan,\" your firsthand account of being kidnapped by sea reavers as a child"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 5
                                                        }
                                                    },
                                                    "\"A Hoop, Two Pigeons, and a Hell Hound,\" a subtle parody of an incompetent noble"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 6
                                                        }
                                                    },
                                                    "\"A Fool in the Abyss,\" a comedic poem about a jester's travels among demons"
                                                ]
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "Instrument",
                                    "entries": [
                                        "In a bard's quest for the ultimate performance and the highest acclaim, one's instrument is at least as important as one's vocal ability. The instrument's quality of manufacture is a critical factor, of course; the best ones make the best music, and some bards are continually on the lookout for an improvement. Perhaps just as important, though, is the instrument's own entertainment value; those that are bizarrely constructed or made of exotic materials are likely to leave a lasting impression on an audience.",
                                        "You might have an \"off the rack\" instrument, perhaps because it's all you can afford right now. Or, if your first instrument was gifted to you, it might be of a more elaborate sort. Are you satisfied with the instrument you have, or do you aspire to replace it with something truly distinctive?",
                                        {
                                            "type": "table",
                                            "caption": "Instrument",
                                            "colLabels": [
                                                "{@dice d6}",
                                                "Instrument"
                                            ],
                                            "colStyles": [
                                                "col-1 text-center",
                                                "col-11"
                                            ],
                                            "rows": [
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 1
                                                        }
                                                    },
                                                    "A masterfully crafted halfling fiddle"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 2
                                                        }
                                                    },
                                                    "A mithral {@item horn|PHB} made by elves"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 3
                                                        }
                                                    },
                                                    "A zither made with drow spider silk"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 4
                                                        }
                                                    },
                                                    "An orcish {@item drum|PHB}"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 5
                                                        }
                                                    },
                                                    "A wooden bullywug croak box"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 6
                                                        }
                                                    },
                                                    "A tinker's harp of gnomish design"
                                                ]
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "Embarrassment",
                                    "entries": [
                                        "Almost every bard has suffered at least one bad experience in front of an audience, and chances are you're no exception. No one becomes famous right away, after all; perhaps you had a few small difficulties early in your career, or maybe it took you a while to restore your reputation after one agonizing night when the fates conspired to bring about your theatrical ruin.",
                                        "The ways that a performance can go wrong are as varied as the fish in the sea. No matter what sort of disaster might occur, however, a bard has the courage and the confidence to rebound from it\u2014either pressing on with the show (if possible) or promising to come back tomorrow with a new performance that's guaranteed to please.",
                                        {
                                            "type": "table",
                                            "caption": "Embarrassment",
                                            "colLabels": [
                                                "{@dice d6}",
                                                "Embarrassment"
                                            ],
                                            "colStyles": [
                                                "col-1 text-center",
                                                "col-11"
                                            ],
                                            "rows": [
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 1
                                                        }
                                                    },
                                                    "The time when your comedic song, \"Big Tom's Hijinks\"\u2014which, by the way, you thought was brilliant\u2014did not go over well with Big Tom"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 2
                                                        }
                                                    },
                                                    "The matinee performance when a circus's owlbear got loose and terrorized the crowd"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 3
                                                        }
                                                    },
                                                    "When your opening song was your enthusiastic but universally hated rendition of \"Song of the Froghemoth\""
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 4
                                                        }
                                                    },
                                                    "The first and last public performance of \"Mirt, Man about Town\""
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 5
                                                        }
                                                    },
                                                    "The time on stage when your wig caught fire and you threw it down\u2014which set fire to the stage"
                                                ],
                                                [
                                                    {
                                                        "type": "cell",
                                                        "roll": {
                                                            "exact": 6
                                                        }
                                                    },
                                                    "When you sat on your {@item lute|PHB} by mistake during the final stanza of \"Starlight Serenade\""
                                                ]
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "type": "entries",
                                    "name": "A Bard's Muse",
                                    "entries": [
                                        "Naturally, every bard has a repertoire of songs and stories. Some bards are generalists who can draw from a wide range of topics for each performance, and who take pride in their versatility. Others adopt a more personal approach to their art, driven by their attachment to a muse\u2014a particular concept that inspires much of what those bards do in front of an audience.",
                                        "A bard who follows a muse generally does so to gain a deeper understanding of what that muse represents and how to best convey that understanding to others through performance.",
                                        "If your bard character has a muse, it could be one of the three described here, or one of your own devising.",
                                        {
                                            "type": "entries",
                                            "entries": [
                                                {
                                                    "type": "entries",
                                                    "name": "Nature",
                                                    "entries": [
                                                        "You feel a kinship with the natural world, and its beauty and mystery inspire you. For you, a tree is deeply symbolic, its roots delving into the dark unknown to draw forth the power of the earth, while its branches reach toward the sun to nourish their flowers and fruit. Nature is the ancient witness who has seen every kingdom rise and fall, even those whose names have been forgotten and wait to be rediscovered. The gods of nature share their secrets with druids and sages, opening their hearts and minds to new ways of seeing, and as with those individuals, you find that your creativity blossoms while you wander in an open field of waving grass or walk in silent reverence through a grove of ancient oaks."
                                                    ]
                                                },
                                                {
                                                    "type": "entries",
                                                    "name": "Love",
                                                    "entries": [
                                                        "You are on a quest to identify the essence of true love. Though you do not disdain the superficial love of flesh and form, the deeper form of love that can inspire thousands or bring joy to one's every moment is what you are interested in. Love of this sort takes on many forms, and you can see its presence everywhere\u2014from the sparkling of a beautiful gem to the song of a simple fisher thanking the sea for its bounty. You are on the trail of love, that most precious and mysterious of emotions, and your search fills your stories and your songs with vitality and passion."
                                                    ]
                                                },
                                                {
                                                    "type": "entries",
                                                    "name": "Conflict",
                                                    "entries": [
                                                        "Drama embodies conflict, and the best stories have conflict as a key element. From the morning-after tale of a tavern brawl to the saga of an epic battle, from a lover's spat to a rift between powerful dynasties, conflict is what inspires tale-tellers like you to create your best work. Conflict can bring out the best in some people, causing their heroic nature to shine forth and transform the world, but it can cause others to gravitate toward darkness and fall under the sway of evil. You strive to experience or witness all forms of conflict, great and small, so as to study this eternal aspect of life and immortalize it in your words and music."
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "source": "XGE",
                            "page": 12
                        }
                    ]
                }
            ],
            "subclass": [
                {
                    "name": "College of Lore",
                    "shortName": "Lore",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 54,
                    "srd": true,
                    "additionalSpells": [
                        {
                            "name": "Additional Magical Secrets",
                            "known": {
                                "6": [
                                    {
                                        "choose": "level=0;1;2;3"
                                    },
                                    {
                                        "choose": "level=0;1;2;3"
                                    }
                                ]
                            }
                        }
                    ],
                    "subclassFeatures": [
                        "College of Lore|Bard||Lore||3",
                        "Additional Magical Secrets|Bard||Lore||6",
                        "Peerless Skill|Bard||Lore||14"
                    ]
                },
                {
                    "name": "College of Valor",
                    "shortName": "Valor",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 55,
                    "subclassFeatures": [
                        "College of Valor|Bard||Valor||3",
                        "Extra Attack|Bard||Valor||6",
                        "Battle Magic|Bard||Valor||14"
                    ]
                },
                {
                    "name": "College of Glamour",
                    "shortName": "Glamour",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 14,
                    "additionalSpells": [
                        {
                            "innate": {
                                "6": [
                                    "command"
                                ]
                            }
                        }
                    ],
                    "subclassFeatures": [
                        "College of Glamour|Bard||Glamour|XGE|3",
                        "Mantle of Majesty|Bard||Glamour|XGE|6",
                        "Unbreakable Majesty|Bard||Glamour|XGE|14"
                    ]
                },
                {
                    "name": "College of Swords",
                    "shortName": "Swords",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 15,
                    "optionalfeatureProgression": [
                        {
                            "name": "Fighting Style",
                            "featureType": [
                                "FS:B"
                            ],
                            "progression": {
                                "3": 1
                            }
                        }
                    ],
                    "subclassFeatures": [
                        "College of Swords|Bard||Swords|XGE|3",
                        "Extra Attack|Bard||Swords|XGE|6",
                        "Master's Flourish|Bard||Swords|XGE|14"
                    ]
                },
                {
                    "name": "College of Whispers",
                    "shortName": "Whispers",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 16,
                    "subclassFeatures": [
                        "College of Whispers|Bard||Whispers|XGE|3",
                        "Mantle of Whispers|Bard||Whispers|XGE|6",
                        "Shadow Lore|Bard||Whispers|XGE|14"
                    ]
                },
                {
                    "name": "College of Creation",
                    "shortName": "Creation",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 28,
                    "subclassFeatures": [
                        "College of Creation|Bard||Creation|TCE|3",
                        "Animating Performance|Bard||Creation|TCE|6",
                        "Creative Crescendo|Bard||Creation|TCE|14"
                    ]
                },
                {
                    "name": "College of Eloquence",
                    "shortName": "Eloquence",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 29,
                    "otherSources": [
                        {
                            "source": "MOT",
                            "page": 28
                        }
                    ],
                    "subclassFeatures": [
                        "College of Eloquence|Bard||Eloquence|TCE|3",
                        "Unfailing Inspiration|Bard||Eloquence|TCE|6",
                        "Universal Speech|Bard||Eloquence|TCE|6",
                        "Infectious Inspiration|Bard||Eloquence|TCE|14"
                    ]
                },
                {
                    "name": "College of Spirits",
                    "shortName": "Spirits",
                    "source": "VRGR",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 28,
                    "additionalSpells": [
                        {
                            "known": {
                                "3": [
                                    "guidance#c"
                                ]
                            }
                        }
                    ],
                    "subclassFeatures": [
                        "College of Spirits|Bard||Spirits|VRGR|3",
                        "Spirit Session|Bard||Spirits|VRGR|6",
                        "Mystical Connection|Bard||Spirits|VRGR|14"
                    ]
                },
                {
                    "name": "College of Tragedy",
                    "shortName": "Tragedy",
                    "source": "TDCSR",
                    "className": "Bard",
                    "classSource": "PHB",
                    "page": 167,
                    "subclassFeatures": [
                        "College of Tragedy|Bard|PHB|Tragedy|TDCSR|3",
                        "Tale of Hubris|Bard|PHB|Tragedy|TDCSR|6",
                        "Impending Misfortune|Bard|PHB|Tragedy|TDCSR|6",
                        "Tale of Hubris (14th Level)|Bard|PHB|Tragedy|TDCSR|14",
                        "Nimbus of Pathos|Bard|PHB|Tragedy|TDCSR|14"
                    ]
                }
            ],
            "classFeature": [
                {
                    "name": "Bardic Inspiration",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 1,
                    "entries": [
                        "You can inspire others through stirring words or music. To do so, you use a bonus action on your turn to choose one creature other than yourself within 60 feet of you who can hear you. That creature gains one Bardic Inspiration die, a {@dice d6}.",
                        "Once within the next 10 minutes, the creature can roll the die and add the number rolled to one ability check, attack roll, or saving throw it makes. The creature can wait until after it rolls the {@dice d20} before deciding to use the Bardic Inspiration die, but must decide before the DM says whether the roll succeeds or fails. Once the Bardic Inspiration die is rolled, it is lost. A creature can have only one Bardic Inspiration die at a time.",
                        "You can use this feature a number of times equal to your Charisma modifier (a minimum of once). You regain any expended uses when you finish a long rest.",
                        "Your Bardic Inspiration die changes when you reach certain levels in this class. The die becomes a {@dice d8} at 5th level, a {@dice d10} at 10th level, and a {@dice d12} at 15th level."
                    ]
                },
                {
                    "name": "Spellcasting",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 1,
                    "entries": [
                        "You have learned to untangle and reshape the fabric of reality in harmony with your wishes and music. Your spells are part of your vast repertoire, magic that you can tune to different situations. See {@book chapter 10|PHB|10} for the general rules of spellcasting and {@book chapter 11|PHB|11} for the {@filter bard spell list|spells|class=bard}.",
                        {
                            "type": "entries",
                            "name": "Cantrips",
                            "entries": [
                                "You know two cantrips of your choice from the bard spell list. You learn additional bard cantrips of your choice at higher levels, learning a 3rd cantrip at 4th level and a 4th at 10th level."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spell Slots",
                            "entries": [
                                "The Bard table shows how many spell slots you have to cast your {@filter bard spells|spells|class=bard} of 1st level and higher. To cast one of these spells, you must expend a slot of the spell's level or higher. You regain all expended spell slots when you finish a long rest.",
                                "For example, if you know the 1st-level spell {@spell cure wounds} and have a 1st-level and a 2nd-level spell slot available, you can cast {@spell cure wounds} using either slot."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spells Known of 1st Level and Higher",
                            "entries": [
                                "You know four 1st-level spells of your choice from the bard spell list.",
                                "You learn an additional bard spell of your choice at each level except 12th, 16th, 19th, and 20th. Each of these spells must be of a level for which you have spell slots. For instance, when you reach 3rd level in this class, you can learn one new spell of 1st or 2nd level.",
                                "Additionally, when you gain a level in this class, you can choose one of the bard spells you know and replace it with another spell from the bard spell list, which also must be of a level for which you have spell slots."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spellcasting Ability",
                            "entries": [
                                "Charisma is your spellcasting ability for your bard spells. Your magic comes from the heart and soul you pour into the performance of your music or oration. You use your Charisma whenever a spell refers to your spellcasting ability. In addition, you use your Charisma modifier when setting the saving throw DC for a bard spell you cast and when making an attack roll with one.",
                                {
                                    "type": "abilityDc",
                                    "name": "Spell",
                                    "attributes": [
                                        "cha"
                                    ]
                                },
                                {
                                    "type": "abilityAttackMod",
                                    "name": "Spell",
                                    "attributes": [
                                        "cha"
                                    ]
                                }
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Ritual Casting",
                            "entries": [
                                "You can cast any bard spell you know as a ritual if that spell has the ritual tag."
                            ]
                        },
                        {
                            "type": "entries",
                            "name": "Spellcasting Focus",
                            "entries": [
                                "You can use a {@item musical instrument|PHB} as a spellcasting focus for your bard spells."
                            ]
                        }
                    ]
                },
                {
                    "name": "Jack of All Trades",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 2,
                    "entries": [
                        "Starting at 2nd level, you can add half your proficiency bonus, rounded down, to any ability check you make that doesn't already include your proficiency bonus."
                    ]
                },
                {
                    "name": "Magical Inspiration",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 2,
                    "isClassFeatureVariant": true,
                    "entries": [
                        "{@i 2nd-level bard {@variantrule optional class features|tce|optional feature}}",
                        "If a creature has a Bardic Inspiration die from you and casts a spell that restores hit points or deals damage, the creature can roll that die and choose a target affected by the spell. Add the number rolled as a bonus to the hit points regained or the damage dealt. The Bardic Inspiration die is then lost."
                    ]
                },
                {
                    "name": "Song of Rest (d6)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 2,
                    "entries": [
                        "Beginning at 2nd level, you can use soothing music or oration to help revitalize your wounded allies during a short rest. If you or any friendly creatures who can hear your performance regain hit points by spending Hit Dice at the end of the short rest, each of those creatures regains an extra {@dice 1d6} hit points.",
                        "The extra hit points increase when you reach certain levels in this class: to {@dice 1d8} at 9th level, to {@dice 1d10} at 13th level, and to {@dice 1d12} at 17th level."
                    ]
                },
                {
                    "name": "Bard College",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 3,
                    "entries": [
                        "At 3rd level, you delve into the advanced techniques of a bard college of your choice from the list of available colleges. Your choice grants you features at 3rd level and again at 6th and 14th level."
                    ]
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 3,
                    "entries": [
                        "At 3rd level, choose two of your skill proficiencies. Your proficiency bonus is doubled for any ability check you make that uses either of the chosen proficiencies.",
                        "At 10th level, you can choose another two skill proficiencies to gain this benefit."
                    ]
                },
                {
                    "name": "Ability Score Improvement",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 4,
                    "entries": [
                        "When you reach 4th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                        "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                    ]
                },
                {
                    "name": "Bardic Versatility",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 4,
                    "isClassFeatureVariant": true,
                    "entries": [
                        "{@i 4th-level bard {@variantrule optional class features|tce|optional feature}}",
                        "Whenever you reach a level in this class that grants the Ability Score Improvement feature, you can do one of the following, representing a change in focus as you use your skills and magic:",
                        {
                            "type": "list",
                            "items": [
                                "Replace one of the skills you chose for the Expertise feature with one of your other skill proficiencies that isn't benefiting from Expertise.",
                                "Replace one cantrip you learned from this class's Spellcasting feature with another cantrip from the {@filter bard spell list|spells|level=0|class=bard}."
                            ]
                        }
                    ]
                },
                {
                    "name": "Bardic Inspiration (d8)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 5,
                    "entries": [
                        "At 5th level, your Bardic Inspiration die changes to a {@dice d8}."
                    ]
                },
                {
                    "name": "Font of Inspiration",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 5,
                    "entries": [
                        "Beginning when you reach 5th level, you regain all of your expended uses of Bardic Inspiration when you finish a short or long rest."
                    ]
                },
                {
                    "name": "Bard College feature",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 6,
                    "entries": [
                        "At 6th level, you gain a feature from your Bard College."
                    ]
                },
                {
                    "name": "Countercharm",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 6,
                    "entries": [
                        "At 6th level, you gain the ability to use musical notes or words of power to disrupt mind-influencing effects. As an action, you can start a performance that lasts until the end of your next turn. During that time, you and any friendly creatures within 30 feet of you have advantage on saving throws against being {@condition frightened} or {@condition charmed}. A creature must be able to hear you to gain this benefit. The performance ends early if you are {@condition incapacitated} or silenced or if you voluntarily end it (no action required)."
                    ]
                },
                {
                    "name": "Ability Score Improvement",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 8,
                    "entries": [
                        "When you reach 8th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                        "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                    ]
                },
                {
                    "name": "Song of Rest (d8)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 9,
                    "entries": [
                        "At 9th level, the extra hit points gained from Song of Rest increases to {@dice 1d8}."
                    ]
                },
                {
                    "name": "Bardic Inspiration (d10)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 10,
                    "entries": [
                        "At 10th level, your Bardic Inspiration die changes to a {@dice d10}."
                    ]
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 10,
                    "entries": [
                        "At 10th level, you can choose another two skill proficiencies. Your proficiency bonus is doubled for any ability check you make that uses either of the chosen proficiencies."
                    ]
                },
                {
                    "name": "Magical Secrets",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 10,
                    "entries": [
                        "By 10th level, you have plundered magical knowledge from a wide spectrum of disciplines. Choose two spells from any classes, including this one. A spell you choose must be of a level you can cast, as shown on the Bard table, or a cantrip.",
                        "The chosen spells count as bard spells for you and are included in the number in the Spells Known column of the Bard table.",
                        "You learn two additional spells from any classes at 14th level and again at 18th level."
                    ]
                },
                {
                    "name": "Ability Score Improvement",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 12,
                    "entries": [
                        "When you reach 12th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                        "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                    ]
                },
                {
                    "name": "Song of Rest (d10)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 13,
                    "entries": [
                        "At 13th level, the extra hit points gained from Song of Rest increases to {@dice 1d10}."
                    ]
                },
                {
                    "name": "Bard College feature",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 14,
                    "entries": [
                        "At 14th level, you gain a feature from your Bard College."
                    ]
                },
                {
                    "name": "Magical Secrets",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 14,
                    "entries": [
                        "At 14th level, choose two additional spells from any classes, including this one. A spell you choose must be of a level you can cast, as shown on the Bard table, or a cantrip.",
                        "The chosen spells count as bard spells for you and are included in the number in the Spells Known column of the Bard table."
                    ]
                },
                {
                    "name": "Bardic Inspiration (d12)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 15,
                    "entries": [
                        "At 15th level, your Bardic Inspiration die changes to a {@dice d12}."
                    ]
                },
                {
                    "name": "Ability Score Improvement",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 16,
                    "entries": [
                        "When you reach 16th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                        "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                    ]
                },
                {
                    "name": "Song of Rest (d12)",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 17,
                    "entries": [
                        "At 17th level, the extra hit points gained from Song of Rest increases to {@dice 1d12}."
                    ]
                },
                {
                    "name": "Magical Secrets",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 18,
                    "entries": [
                        "At 18th level, choose two additional spells from any class, including this one. A spell you choose must be of a level you can cast, as shown on the Bard table, or a cantrip.",
                        "The chosen spells count as bard spells for you and are included in the number in the Spells Known column of the Bard table."
                    ]
                },
                {
                    "name": "Ability Score Improvement",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 19,
                    "entries": [
                        "When you reach 19th level, you can increase one ability score of your choice by 2, or you can increase two ability scores of your choice by 1. As normal, you can't increase an ability score above 20 using this feature.",
                        "If your DM allows the use of feats, you may instead take a {@5etools feat|feats.html}."
                    ]
                },
                {
                    "name": "Superior Inspiration",
                    "source": "PHB",
                    "page": 51,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 20,
                    "entries": [
                        "At 20th level, when you roll initiative and have no uses of Bardic Inspiration left, you regain one use."
                    ]
                }
            ],
            "subclassFeature": [
                {
                    "name": "College of Lore",
                    "source": "PHB",
                    "page": 54,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entries": [
                        "Bards of the College of Lore know something about most things, collecting bits of knowledge from sources as diverse as scholarly tomes and peasant tales. Whether singing folk ballads in taverns or elaborate compositions in royal courts, these bards use their gifts to hold audiences spellbound. When the applause dies down, the audience members might find themselves questioning everything they held to be true, from their faith in the priesthood of the local temple to their loyalty to the king.",
                        "The loyalty of these bards lies in the pursuit of beauty and truth, not in fealty to a monarch or following the tenets of a deity. A noble who keeps such a bard as a herald or advisor knows that the bard would rather be honest than politic.",
                        "The college's members gather in libraries and sometimes in actual colleges, complete with classrooms and dormitories, to share their lore with one another. They also meet at festivals or affairs of state, where they can expose corruption, unravel lies, and poke fun at self-important figures of authority.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Bonus Proficiencies|Bard||Lore||3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Cutting Words|Bard||Lore||3"
                        }
                    ]
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "page": 54,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Lore at 3rd level, you gain proficiency with three skills of your choice."
                    ]
                },
                {
                    "name": "Cutting Words",
                    "source": "PHB",
                    "page": 54,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "Also at 3rd level, you learn how to use your wit to distract, confuse, and otherwise sap the confidence and competence of others. When a creature that you can see within 60 feet of you makes an attack roll, an ability check, or a damage roll, you can use your reaction to expend one of your uses of Bardic Inspiration, rolling a Bardic Inspiration die and subtracting the number rolled from the creature's roll. You can choose to use this feature after the creature makes its roll, but before the DM determines whether the attack roll or ability check succeeds or fails, or before the creature deals its damage. The creature is immune if it can't hear you or if it's immune to being {@condition charmed}."
                    ]
                },
                {
                    "name": "Additional Magical Secrets",
                    "source": "PHB",
                    "page": 54,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "At 6th level, you learn two spells of your choice from any class. A spell you choose must be of a level you can cast, as shown on the Bard table, or a cantrip. The chosen spells count as bard spells for you but don't count against the number of bard spells you know."
                    ]
                },
                {
                    "name": "Peerless Skill",
                    "source": "PHB",
                    "page": 54,
                    "srd": true,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "Starting at 14th level, when you make an ability check, you can expend one use of Bardic Inspiration. Roll a Bardic Inspiration die and add the number rolled to your ability check. You can choose to do so after you roll the die for the ability check, but before the DM tells you whether you succeed or fail."
                    ]
                },
                {
                    "name": "College of Valor",
                    "source": "PHB",
                    "page": 55,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entries": [
                        "Bards of the College of Valor are daring skalds whose tales keep alive the memory of the great heroes of the past, and thereby inspire a new generation of heroes. These bards gather in mead halls or around great bonfires to sing the deeds of the mighty, both past and present. They travel the land to witness great events firsthand and to ensure that the memory of those events doesn't pass from the world. With their songs, they inspire others to reach the same heights of accomplishment as the heroes of old.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Bonus Proficiencies|Bard||Valor||3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Combat Inspiration|Bard||Valor||3"
                        }
                    ]
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "page": 55,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Valor at 3rd level, you gain proficiency with medium armor, shields, and martial weapons."
                    ]
                },
                {
                    "name": "Combat Inspiration",
                    "source": "PHB",
                    "page": 55,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "Also at 3rd level, you learn to inspire others in battle. A creature that has a Bardic Inspiration die from you can roll that die and add the number rolled to a weapon damage roll it just made. Alternatively, when an attack roll is made against the creature, it can use its reaction to roll the Bardic Inspiration die and add the number rolled to its AC against that attack, after seeing the roll but before knowing whether it hits or misses."
                    ]
                },
                {
                    "name": "Extra Attack",
                    "source": "PHB",
                    "page": 55,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "Starting at 6th level, you can attack twice, instead of once, whenever you take the {@action Attack} action on your turn."
                    ]
                },
                {
                    "name": "Battle Magic",
                    "source": "PHB",
                    "page": 55,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "At 14th level, you have mastered the art of weaving spellcasting and weapon use into a single harmonious act. When you use your action to cast a bard spell, you can make one weapon attack as a bonus action."
                    ]
                },
                {
                    "name": "College of Creation",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entries": [
                        "Bards believe the cosmos is a work of art-the creation of the first dragons and gods. That creative work included harmonies that continue to resound through existence today, a power known as the Song of Creation. The bards of the College of Creation draw on that primeval song through dance, music, and poetry, and their teachers share this lesson:",
                        "\"Before the sun and the moon, there was the Song, and its music awoke the first dawn. Its melodies so delighted the stones and trees that some of them gained a voice of their own. And now they sing too. Learn the Song, students, and you too can teach the mountains to sing and dance.\"",
                        "Dwarves and gnomes often encourage their bards to become students of the Song of Creation. And among dragonborn, the Song of Creation is revered, for legends portray Bahamut and Tiamat-the greatest of dragons-as two of the song's first singers.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Mote of Potential|Bard||Creation|TCE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Performance of Creation|Bard||Creation|TCE|3"
                        }
                    ]
                },
                {
                    "name": "Mote of Potential",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Creation feature}",
                        "Whenever you give a creature a Bardic Inspiration die, you can utter a note from the Song of Creation to create a Tiny mote of potential, which orbits within 5 feet of that creature. The mote is intangible and invulnerable, and it lasts until the Bardic Inspiration die is lost. The mote looks like a musical note, a star, a flower, or another symbol of art or life that you choose.",
                        "When the creature uses the Bardic Inspiration die, the mote provides an additional effect based on whether the die benefits an ability check, an attack roll, or a saving throw, as detailed below:",
                        {
                            "type": "list",
                            "style": "list-hang-notitle",
                            "items": [
                                {
                                    "type": "item",
                                    "name": "Ability Check",
                                    "entry": "When the creature rolls the Bardic Inspiration die to add it to an ability check, the creature can roll the Bardic Inspiration die again and choose which roll to use, as the mote pops and emits colorful, harmless sparks for a moment."
                                },
                                {
                                    "type": "item",
                                    "name": "Attack Roll",
                                    "entry": "Immediately after the creature rolls the Bardic Inspiration die to add it to an attack roll against a target, the mote thunderously shatters. The target and each creature of your choice that you can see within 5 feet of it must succeed on a Constitution saving throw against your spell save DC or take thunder damage equal to the number rolled on the Bardic Inspiration die."
                                },
                                {
                                    "type": "item",
                                    "name": "Saving Throw",
                                    "entry": "Immediately after the creature rolls the Bardic Inspiration die and adds it to a saving throw, the mote vanishes with the sound of soft music, causing the creature to gain temporary hit points equal to the number rolled on the Bardic Inspiration die plus your Charisma modifier (minimum of 1 temporary hit point)."
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Performance of Creation",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Creation feature}",
                        "As an action, you can channel the magic of the Song of Creation to create one nonmagical item of your choice in an unoccupied space within 10 feet of you. The item must appear on a surface or in a liquid that can support it. The gp value of the item can't be more than 20 times your bard level, and the item must be Medium or smaller. The item glimmers softly, and a creature can faintly hear music when touching it. The created item disappears after a number of hours equal to your proficiency bonus. For examples of items you can create, see the equipment chapter of the {@book Player's Handbook|PHB|5}.",
                        "Once you create an item with this feature, you can't do so again until you finish a long rest, unless you expend a spell slot of 2nd level or higher to use this feature again. You can have only one item created by this feature at a time; if you use this action and already have an item from this feature, the first one immediately vanishes.",
                        "The size of the item you can create with this feature increases by one size category when you reach 6th level (Large) and 14th level (Huge)."
                    ]
                },
                {
                    "name": "Animating Performance",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "{@i 6th-level College of Creation feature}",
                        "As an action, you can animate one Large or smaller nonmagical item within 30 feet of you that isn't being worn or carried. The animate item uses the {@creature Dancing Item|TCE} stat block, which uses your proficiency bonus (PB). The item is friendly to you and your companions and obeys your commands. It lives for 1 hour, until it is reduced to 0 hit points, or until you die.",
                        "In combat, the item shares your initiative count, but it takes its turn immediately after yours. It can move and use its reaction on its own, but the only action it takes on its turn is the {@action Dodge} action, unless you take a bonus action on your turn to command it to take another action. That action can be one in its stat block or some other action. If you are {@condition incapacitated}, the item can take any action of its choice, not just {@action Dodge}.",
                        "When you use your Bardic Inspiration feature, you can command the item as part of the same bonus action you use for Bardic Inspiration.",
                        "Once you animate an item with this feature, you can't do so again until you finish a long rest, unless you expend a spell slot of 3rd level or higher to use this feature again. You can have only one item animated by this feature at a time; if you use this action and already have a {@creature dancing item|TCE} from this feature, the first one immediately becomes inanimate."
                    ]
                },
                {
                    "name": "Creative Crescendo",
                    "source": "TCE",
                    "page": 27,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "{@i 14th-level College of Creation feature}",
                        "When you use your Performance of Creation feature, you can create more than one item at once. The number of items equals your Charisma modifier (minimum of two items). If you create an item that would exceed that number, you choose which of the previously created items disappears. Only one of these items can be of the maximum size you can create; the rest must be Small or Tiny.",
                        "You are no longer limited by gp value when creating items with Performance of Creation."
                    ]
                },
                {
                    "name": "College of Eloquence",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entries": [
                        "Adherents of the College of Eloquence master the art of oratory. Persuasion is regarded as a high art, and a well-reasoned, well-spoken argument often proves more persuasive than facts. These bards wield a blend of logic and theatrical wordplay, winning over skeptics and detractors with logical arguments and plucking at heartstrings to appeal to the emotions of audiences.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Silver Tongue|Bard||Eloquence|TCE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Unsettling Words|Bard||Eloquence|TCE|3"
                        }
                    ]
                },
                {
                    "name": "Silver Tongue",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Eloquence feature}",
                        "You are a master at saying the right thing at the right time. When you make a Charisma ({@skill Persuasion}) or Charisma ({@skill Deception}) check, you can treat a {@dice d20} roll of 9 or lower as a 10."
                    ]
                },
                {
                    "name": "Unsettling Words",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Eloquence feature}",
                        "You can spin words laced with magic that unsettle a creature and cause it to doubt itself. As a bonus action, you can expend one use of your Bardic Inspiration and choose one creature you can see within 60 feet of you. Roll the Bardic Inspiration die. The creature must subtract the number rolled from the next saving throw it makes before the start of your next turn."
                    ]
                },
                {
                    "name": "Unfailing Inspiration",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "{@i 6th-level College of Eloquence feature}",
                        "Your inspiring words are so persuasive that others feel driven to succeed. When a creature adds one of your Bardic Inspiration dice to its ability check, attack roll, or saving throw and the roll fails, the creature can keep the Bardic Inspiration die."
                    ]
                },
                {
                    "name": "Universal Speech",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "{@i 6th-level College of Eloquence feature}",
                        "You have gained the ability to make your speech intelligible to any creature. As an action, choose one or more creatures within 60 feet of you, up to a number equal to your Charisma modifier (minimum of one creature). The chosen creatures can magically understand you, regardless of the language you speak, for 1 hour.",
                        "Once you use this feature, you can't use it again until you finish a long rest, unless you expend a spell slot to use it again."
                    ]
                },
                {
                    "name": "Infectious Inspiration",
                    "source": "TCE",
                    "page": 29,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "{@i 14th-level College of Eloquence feature}",
                        "When you successfully inspire someone, the power of your eloquence can now spread to someone else. When a creature within 60 feet of you adds one of your Bardic Inspiration dice to its ability check, attack roll, or saving throw and the roll succeeds, you can use your reaction to encourage a different creature (other than yourself) that can hear you within 60 feet of you, giving it a Bardic Inspiration die without expending any of your Bardic Inspiration uses.",
                        "You can use this reaction a number of times equal to your Charisma modifier (minimum of once), and you regain all expended uses when you finish a long rest."
                    ]
                },
                {
                    "name": "College of Tragedy",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 3,
                    "entries": [
                        "Not all grand stories conclude in triumphant victory. Many tales end with death and despair, and bards of the College of Tragedy know that sorrow and pathos are emotions just as potent as joy and delight. These bards specialize in the power of tragic storytelling, weaving words and spells together to dramatic and devastating effect.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Poetry in Misery|Bard|PHB|Tragedy|TDCSR|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Sorrowful Fate|Bard|PHB|Tragedy|TDCSR|3"
                        }
                    ]
                },
                {
                    "name": "Poetry in Misery",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Tragedy at 3rd level, you learn to harness the beauty in failure, finding inspiration in even the direst twists of fate. Whenever you or an ally within 30 feet of you rolls a 1 on the {@dice d20} for an attack roll, an ability check, or a {@quickref saving throws|PHB|2|1|saving throw}, you can use your reaction to soliloquize and regain one expended use of your Bardic Inspiration feature."
                    ]
                },
                {
                    "name": "Sorrowful Fate",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "Starting at 3rd level, you exploit a foe's peril to instill deep feelings of sorrow and doom. When you or an ally you can see forces a creature to make a {@quickref saving throws|PHB|2|1|saving throw}, you can expend one use of your Bardic Inspiration to change the type of {@quickref saving throws|PHB|2|1|saving throw} to a Charisma save instead.",
                        "If the target fails this save, roll a Bardic Inspiration die. The target takes psychic damage equal to the result, and is plagued with regret for 1 minute. If the target is reduced to 0 hit points during this time and can speak, they are magically compelled to utter darkly poetic final words before succumbing to their injuries.",
                        "Once you use this feature, you can't use it again until you finish a {@quickref resting|PHB|2|0|short or long rest}."
                    ]
                },
                {
                    "name": "Impending Misfortune",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "Also at 6th level, your words can twist the power of fate to create triumph from the promise of future despair. When you make an attack roll or a {@quickref saving throws|PHB|2|1|saving throw}, you can gain a +10 bonus to the roll, but the next attack roll or {@quickref saving throws|PHB|2|1|saving throw} you make takes a \u221210 penalty. If not used, this penalty disappears when you finish a {@quickref resting|PHB|2|0|short or long rest}.",
                        "You can't use this feature again until you finish a {@quickref resting|PHB|2|0|short or long rest}, or until you are reduced to 0 hit points."
                    ]
                },
                {
                    "name": "Tale of Hubris",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "At 6th level, you learn to weave a magical narrative that draws out the fatal arrogance of your foes. When a creature scores a critical hit against you or an ally within 60 feet of you that you can see, you can use your reaction and expend one use of your Bardic Inspiration to target the attacking creature and evoke the story of their downfall. For 1 minute or until the target suffers a critical hit, any weapon attack against the target scores a critical hit on a roll of 18\u201320."
                    ]
                },
                {
                    "name": "Nimbus of Pathos",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "Upon reaching 14th level, you can touch a willing creature as an action and empower it with tragic heroism. For 1 minute, the creature is surrounded by mournful music and ghostly singing, granting it the following benefits and drawbacks:",
                        {
                            "type": "list",
                            "items": [
                                "The creature has a +4 bonus to AC.",
                                "It has {@quickref Advantage and Disadvantage|PHB|2|0|advantage} on attack rolls and {@quickref saving throws|PHB|2|1}.",
                                "When the creature hits a target with a weapon attack or spell attack, that target takes an extra {@damage 1d10} radiant damage.",
                                "Any weapon attack against the creature scores a critical hit on a roll of 18\u201320."
                            ]
                        },
                        "When this effect ends, the creature immediately drops to 0 hit points and is dying. Once you use this feature, you can't use it again until you finish a {@quickref resting|PHB|2|0|long rest}."
                    ]
                },
                {
                    "name": "Tale of Hubris (14th Level)",
                    "source": "TDCSR",
                    "page": 167,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Tragedy",
                    "subclassSource": "TDCSR",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "At 14th level, the critical hit range of this feature increases to 17\u201320."
                    ]
                },
                {
                    "name": "College of Spirits",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "entries": [
                        "Bards of the College of Spirits seek tales with inherent power\u2014be they legends, histories, or fictions\u2014and bring their subjects to life. Using occult trappings, these bards conjure spiritual embodiments of powerful forces to change the world once more. Such spirits are capricious, though, and what a bard summons isn't always entirely under their control.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Guiding Whispers|Bard||Spirits|VRGR|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Spiritual Focus|Bard||Spirits|VRGR|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Tales from Beyond|Bard||Spirits|VRGR|3"
                        }
                    ]
                },
                {
                    "name": "Guiding Whispers",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Spirits feature}",
                        "You can reach out to spirits to guide you and others. You learn the {@spell guidance} cantrip, which doesn't count against the number of bard cantrips you know. For you, it has a range of 60 feet when you cast it."
                    ]
                },
                {
                    "name": "Spiritual Focus",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Spirits feature}",
                        "You employ tools that aid you in channeling spirits, be they historical figures or fictional archetypes. You can use the following objects as a spellcasting focus for your bard spells: a candle, crystal ball, skull, spirit board, or {@deck tarokka deck|CoS}.",
                        "Starting at 6th level, when you cast a bard spell that deals damage or restores hit points through the Spiritual Focus, roll a {@dice d6}, and you gain a bonus to one damage or healing roll of the spell equal to the number rolled."
                    ]
                },
                {
                    "name": "Tales from Beyond",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "{@i 3rd-level College of Spirits feature}",
                        "You reach out to spirits who tell their tales through you. While you are holding your Spiritual Focus, you can use a bonus action to expend one use of your Bardic Inspiration and roll on the Spirit Tales table using your Bardic Inspiration die to determine the tale the spirits direct you to tell. You retain the tale in mind until you bestow the tale's effect or you finish a short or long rest.",
                        "You can use an action to choose one creature you can see within 30 feet of you (this can be you) to be the target of the tale's effect. Once you do so, you can't bestow the tale's effect again until you roll it again.",
                        "You can retain only one of these tales in mind at a time, and rolling on the Spirit Tales table immediately ends the effect of the previous tale.",
                        "If the tale requires a saving throw, the DC equals your spell save DC.",
                        {
                            "type": "table",
                            "caption": "Spirit Tales",
                            "colLabels": [
                                "Bardic Insp. Die",
                                "Tale Told Through You"
                            ],
                            "colStyles": [
                                "col-2 text-center",
                                "col-10"
                            ],
                            "rows": [
                                [
                                    "1",
                                    "Tale of the Clever Animal. For the next 10 minutes, whenever the target makes an Intelligence, a Wisdom, or a Charisma check, the target can roll an extra die immediately after rolling the {@dice d20} and add the extra die's number to the check. The extra die is the same type as your Bardic Inspiration die."
                                ],
                                [
                                    "2",
                                    "Tale of the Renowned Duelist. You make a melee spell attack against the target. On a hit, the target takes force damage equal to two rolls of your Bardic Inspiration die + your Charisma modifier."
                                ],
                                [
                                    "3",
                                    "Tale of the Beloved Friends. The target and another creature of its choice it can see within 5 feet of it gains temporary hit points equal to a roll of your Bardic Inspiration die + your Charisma modifier."
                                ],
                                [
                                    "4",
                                    "Tale of the Runaway. The target can immediately use its reaction to teleport up to 30 feet to an unoccupied space it can see. When the target teleports, it can choose a number of creatures it can see within 30 feet of it up to your Charisma modifier (minimum of 0) to immediately use the same reaction."
                                ],
                                [
                                    "5",
                                    "Tale of the Avenger. For 1 minute, any creature that hits the target with a melee attack takes force damage equal to a roll of your Bardic Inspiration die."
                                ],
                                [
                                    "6",
                                    "Tale of the Traveler. The target gains temporary hit points equal to a roll of your Bardic Inspiration die + your bard level. While it has these temporary hit points, the target's walking speed increases by 10 feet and it gains a +1 bonus to its AC."
                                ],
                                [
                                    "7",
                                    "Tale of the Beguiler. The target must succeed on a Wisdom saving throw or take psychic damage equal to two rolls of your Bardic Inspiration die, and the target is {@condition incapacitated} until the end of its next turn."
                                ],
                                [
                                    "8",
                                    "Tale of the Phantom. The target becomes {@condition invisible} until the end of its next turn or until it hits a creature with an attack. If the target hits a creature with an attack during this invisibility, the creature it hits takes necrotic damage equal to a roll of your Bardic Inspiration die and is {@condition frightened} of the target until the end of the {@condition frightened} creature's next turn."
                                ],
                                [
                                    "9",
                                    "Tale of the Brute. Each creature of the target's choice it can see within 30 feet of it must make a Strength saving throw. On a failed save, a creature takes thunder damage equal to three rolls of your Bardic Inspiration die and is knocked {@condition prone}. A creature that succeeds on its saving throw takes half as much damage and isn't knocked {@condition prone}."
                                ],
                                [
                                    "10",
                                    "Tale of the Dragon. The target spews fire from the mouth in a 30-foot cone. Each creature in that area must make a Dexterity saving throw, taking fire damage equal to four rolls of your Bardic Inspiration die on a failed save, or half as much damage on a successful one."
                                ],
                                [
                                    "11",
                                    "Tale of the Angel. The target regains hit points equal to two rolls of your Bardic Inspiration die + your Charisma modifier, and you end one condition from the following list affecting the target: {@condition blinded}, {@condition deafened}, {@condition paralyzed}, {@condition petrified}, or {@condition poisoned}."
                                ],
                                [
                                    "12",
                                    "Tale of the Mind-Bender. You evoke an incomprehensible fable from an otherworldly being. The target must succeed on an Intelligence saving throw or take psychic damage equal to three rolls of your Bardic Inspiration die and be {@condition stunned} until the end of its next turn."
                                ]
                            ]
                        }
                    ]
                },
                {
                    "name": "Spirit Session",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "{@i 6th-level College of Spirits feature}",
                        "Spirits provide you with supernatural insights. You can conduct an hour-long ritual channeling spirits (which can be done during a short or long rest) using your Spiritual Focus. You can conduct the ritual with a number of willing creatures equal to your proficiency bonus (including yourself). At the end of the ritual, you temporarily learn {@filter one spell of your choice from any class|spells|school=d;n|level=0;1;2;3;4;5;6}.",
                        "The spell you choose must be of a level equal to the number of creatures that conducted the ritual or less, the spell must be of a level you can cast, and it must be in the school of divination or necromancy. The chosen spell counts as a bard spell for you but doesn't count against the number of bard spells you know.",
                        "Once you perform the ritual, you can't do so again until you start a long rest, and you know the chosen spell until you start a long rest."
                    ]
                },
                {
                    "name": "Mystical Connection",
                    "source": "VRGR",
                    "page": 28,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "{@i 14th-level College of Spirits feature}",
                        "You now have the ability to nudge the spirits of Tales from Beyond toward certain tales. Whenever you roll on the Spirit Tales table, you can roll the die twice and choose which of the two effects to bestow. If you roll the same number on both dice, you can ignore the number and choose any effect on the table.",
                        {
                            "type": "inset",
                            "name": "Spirit Tales",
                            "entries": [
                                "Storytellers, like bards of the College of Spirits, often give voice to tales inspired by some greater theme or body of work. When determining what stories you tell, consider what unites them. Do they all feature characters from a specific group, like archetypes from the {@deck tarokka deck|CoS}, figures from constellations, childhood imaginary friends, or characters in a particular storybook? Or are your inspirations more general, incorporating historic champions, mythological heroes, or urban legends? Use the tales you tell to define your niche as a storytelling adventurer."
                            ]
                        }
                    ]
                },
                {
                    "name": "College of Glamour",
                    "source": "XGE",
                    "page": 14,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "The College of Glamour is the home of bards who mastered their craft in the vibrant realm of the Feywild or under the tutelage of someone who dwelled there. Tutored by satyrs, eladrin, and other fey, these bards learn to use their magic to delight and captivate others.",
                        "The bards of this college are regarded with a mixture of awe and fear. Their performances are the stuff of legend. These bards are so eloquent that a speech or song that one of them performs can cause captors to release the bard unharmed and can lull a furious dragon into complacency. The same magic that allows them to quell beasts can also bend minds. Villainous bards of this college can leech off a community for weeks, misusing their magic to turn their hosts into thralls. Heroic bards of this college instead use this power to gladden the downtrodden and undermine oppressors.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Mantle of Inspiration|Bard||Glamour|XGE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Enthralling Performance|Bard||Glamour|XGE|3"
                        }
                    ]
                },
                {
                    "name": "Enthralling Performance",
                    "source": "XGE",
                    "page": 14,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "Starting at 3rd level, you can charge your performance with seductive, fey magic.",
                        "If you perform for at least 1 minute, you can attempt to inspire wonder in your audience by singing, reciting a poem, or dancing. At the end of the performance, choose a number of humanoids within 60 feet of you who watched and listened to all of it, up to a number equal to your Charisma modifier (minimum of one). Each target must succeed on a Wisdom saving throw against your spell save DC or be {@condition charmed} by you. While {@condition charmed} in this way, the target idolizes you, it speaks glowingly of you to anyone who talks to it, and it hinders anyone who opposes you, although it avoids violence unless it was already inclined to fight on your behalf. This effect ends on a target after 1 hour, if it takes any damage, if you attack it, or if it witnesses you attacking or damaging any of its allies.",
                        "If a target succeeds on its saving throw, the target has no hint that you tried to charm it.",
                        "Once you use this feature, you can't use it again until you finish a short or long rest."
                    ]
                },
                {
                    "name": "Mantle of Inspiration",
                    "source": "XGE",
                    "page": 14,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Glamour at 3rd level, you gain the ability to weave a song of fey magic that imbues your allies with vigor and speed.",
                        "As a bonus action, you can expend one use of your Bardic Inspiration to grant yourself a wondrous appearance. When you do so, choose a number of creatures you can see and that can see you within 60 feet of you, up to a number equal to your Charisma modifier (minimum of one). Each of them gains 5 temporary hit points. When a creature gains these temporary hit points, it can immediately use its reaction to move up to its speed, without provoking opportunity attacks.",
                        "The number of temporary hit points increases when you reach certain levels in this class, increasing to 8 at 5th level, 11 at 10th level, and 14 at 15th level."
                    ]
                },
                {
                    "name": "Mantle of Majesty",
                    "source": "XGE",
                    "page": 14,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "At 6th level, you gain the ability to cloak yourself in a fey magic that makes others want to serve you. As a bonus action, you cast {@spell command}, without expending a spell slot, and you take on an appearance of unearthly beauty for 1 minute or until your {@status concentration} ends (as if you were {@status concentration||concentrating} on a spell). During this time, you can cast {@spell command} as a bonus action on each of your turns, without expending a spell slot.",
                        "Any creature {@condition charmed} by you automatically fails its saving throw against the {@spell command} you cast with this feature.",
                        "Once you use this feature, you can't use it again until you finish a long rest."
                    ]
                },
                {
                    "name": "Unbreakable Majesty",
                    "source": "XGE",
                    "page": 14,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "At 14th level, your appearance permanently gains an otherworldly aspect that makes you look more lovely and fierce.",
                        "In addition, as a bonus action, you can assume a magically majestic presence for 1 minute or until you are {@condition incapacitated}. For the duration, whenever any creature tries to attack you for the first time on a turn, the attacker must make a Charisma saving throw against your spell save DC. On a failed save, it can't attack you on this turn, and it must choose a new target for its attack or the attack is wasted. On a successful save, it can attack you on this turn, but it has disadvantage on any saving throw it makes against your spells on your next turn.",
                        "Once you assume this majestic presence, you can't do so again until you finish a short or long rest."
                    ]
                },
                {
                    "name": "College of Swords",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "Bards of the College of Swords are called blades, and they entertain through daring feats of weapon prowess. Blades perform stunts such as sword swallowing, knife throwing and juggling, and mock combats. Though they use their weapons to entertain, they are also highly trained and skilled warriors in their own right.",
                        "Their talent with weapons inspires many blades to lead double lives. One blade might use a circus troupe as cover for nefarious deeds such as assassination, robbery, and blackmail. Other blades strike at the wicked, bringing justice to bear against the cruel and powerful. Most troupes are happy to accept a blade's talent for the excitement it adds to a performance, but few entertainers fully trust a blade in their ranks.",
                        "Blades who abandon their lives as entertainers have often run into trouble that makes maintaining their secret activities impossible. A blade caught stealing or engaging in vigilante justice is too great a liability for most troupes. With their weapon skills and magic, these blades either take up work as enforcers for thieves' guilds or strike out on their own as adventurers.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Bonus Proficiencies|Bard||Swords|XGE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Fighting Style|Bard||Swords|XGE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Blade Flourish|Bard||Swords|XGE|3"
                        }
                    ]
                },
                {
                    "name": "Blade Flourish",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "At 3rd level, you learn to perform impressive displays of martial prowess and speed.",
                        "Whenever you take the {@action Attack} action on your turn, your walking speed increases by 10 feet until the end of the turn, and if a weapon attack that you make as part of this action hits a creature, you can use one of the following Blade Flourish options of your choice. You can use only one Blade Flourish option per turn.",
                        {
                            "type": "options",
                            "entries": [
                                {
                                    "type": "refSubclassFeature",
                                    "subclassFeature": "Defensive Flourish|Bard|XGE|Swords|XGE|3"
                                },
                                {
                                    "type": "refSubclassFeature",
                                    "subclassFeature": "Slashing Flourish|Bard|XGE|Swords|XGE|3"
                                },
                                {
                                    "type": "refSubclassFeature",
                                    "subclassFeature": "Mobile Flourish|Bard|XGE|Swords|XGE|3"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Swords at 3rd level, you gain proficiency with medium armor and the {@item scimitar|phb}.",
                        "If you're proficient with a simple or martial melee weapon, you can use it as a spellcasting focus for your bard spells."
                    ]
                },
                {
                    "name": "Fighting Style",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "At 3rd level, you adopt a style of fighting as your specialty. Choose one of the following options. You can't take a Fighting Style option more than once, even if something in the game lets you choose again.",
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Dueling"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Two-Weapon Fighting"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Extra Attack",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "Starting at 6th level, you can attack twice, instead of once, whenever you take the {@action Attack} action on your turn."
                    ]
                },
                {
                    "name": "Master's Flourish",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "Starting at 14th level, whenever you use a Blade Flourish option, you can roll a {@dice d6} and use it instead of expending a Bardic Inspiration die."
                    ]
                },
                {
                    "name": "College of Whispers",
                    "source": "XGE",
                    "page": 16,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "Most folk are happy to welcome a bard into their midst. Bards of the College of Whispers use this to their advantage. They appear to be like other bards, sharing news, singing songs, and telling tales to the audiences they gather. In truth, the College of Whispers teaches its students that they are wolves among sheep. These bards use their knowledge and magic to uncover secrets and turn them against others through extortion and threats.",
                        "Many other bards hate the College of Whispers, viewing it as a parasite that uses a bard's reputation to acquire wealth and power. For this reason, members of this college rarely reveal their true nature. They typically claim to follow some other college, or they keep their actual calling secret in order to infiltrate and exploit royal courts and other settings of power.",
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Psychic Blades|Bard||Whispers|XGE|3"
                        },
                        {
                            "type": "refSubclassFeature",
                            "subclassFeature": "Words of Terror|Bard||Whispers|XGE|3"
                        }
                    ]
                },
                {
                    "name": "Psychic Blades",
                    "source": "XGE",
                    "page": 16,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "When you join the College of Whispers at 3rd level, you gain the ability to make your weapon attacks magically toxic to a creature's mind.",
                        "When you hit a creature with a weapon attack, you can expend one use of your Bardic Inspiration to deal an extra {@damage 2d6} psychic damage to that target. You can do so only once per round on your turn.",
                        "The psychic damage increases when you reach certain levels in this class, increasing to {@dice 3d6} at 5th level, {@dice 5d6} at 10th level, and {@dice 8d6} at 15th level."
                    ]
                },
                {
                    "name": "Words of Terror",
                    "source": "XGE",
                    "page": 16,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "header": 1,
                    "entries": [
                        "At 3rd level, you learn to infuse innocent-seeming words with an insidious magic that can inspire terror.",
                        "If you speak to a humanoid alone for at least 1 minute, you can attempt to seed paranoia in its mind. At the end of the conversation, the target must succeed on a Wisdom saving throw against your spell save DC or be {@condition frightened} of you or another creature of your choice. The target is {@condition frightened} in this way for 1 hour, until it is attacked or damaged, or until it witnesses its allies being attacked or damaged.",
                        "If the target succeeds on its saving throw, the target has no hint that you tried to frighten it.",
                        "Once you use this feature, you can't use it again until you finish a short or long rest."
                    ]
                },
                {
                    "name": "Mantle of Whispers",
                    "source": "XGE",
                    "page": 16,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 6,
                    "header": 2,
                    "entries": [
                        "At 6th level, you gain the ability to adopt a humanoid's persona. When a humanoid dies within 30 feet of you, you can magically capture its shadow using your reaction. You retain this shadow until you use it or you finish a long rest.",
                        "You can use the shadow as an action. When you do so, it vanishes, magically transforming into a disguise that appears on you. You now look like the dead person, but healthy and alive. This disguise lasts for 1 hour or until you end it as a bonus action.",
                        "While you're in the disguise, you gain access to all information that the humanoid would freely share with a casual acquaintance. Such information includes general details on its background and personal life, but doesn't include secrets. The information is enough that you can pass yourself off as the person by drawing on its memories.",
                        "Another creature can see through this disguise by succeeding on a Wisdom ({@skill Insight}) check contested by your Charisma ({@skill Deception}) check. You gain a +5 bonus to your check.",
                        "Once you capture a shadow with this feature, you can't capture another one with it until you finish a short or long rest."
                    ]
                },
                {
                    "name": "Shadow Lore",
                    "source": "XGE",
                    "page": 16,
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 14,
                    "header": 2,
                    "entries": [
                        "At 14th level, you gain the ability to weave dark magic into your words and tap into a creature's deepest fears.",
                        "As an action, you magically whisper a phrase that only one creature of your choice within 30 feet of you can hear. The target must make a Wisdom saving throw against your spell save DC. It automatically succeeds if it doesn't share a language with you or if it can't hear you. On a successful saving throw, your whisper sounds like unintelligible mumbling and has no effect.",
                        "On a failed saving throw, the target is {@condition charmed} by you for the next 8 hours or until you or your allies attack it, damage it, or force it to make a saving throw. It interprets the whispers as a description of its most mortifying secret. You gain no knowledge of this secret, but the target is convinced you know it.",
                        "The {@condition charmed} creature obeys your commands for fear that you will reveal its secret. It won't risk its life for you or fight for you, unless it was already inclined to do so. It grants you favors and gifts it would offer to a close friend.",
                        "When the effect ends, the creature has no understanding of why it held you in such fear.",
                        "Once you use this feature, you can't use it again until you finish a long rest."
                    ]
                },
                {
                    "name": "Defensive Flourish",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "XGE",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "You can expend one use of your Bardic Inspiration to cause the weapon to deal extra damage to the target you hit. The damage equals the number you roll on the Bardic Inspiration die. You also add the number rolled to your AC until the start of your next turn."
                    ]
                },
                {
                    "name": "Mobile Flourish",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "XGE",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "You can expend one use of your Bardic Inspiration to cause the weapon to deal extra damage to the target you hit. The damage equals the number you roll on the Bardic Inspiration die. You can also push the target up to 5 feet away from you, plus a number of feet equal to the number you roll on that die. You can then immediately use your reaction to move up to your walking speed to an unoccupied space within 5 feet of the target."
                    ]
                },
                {
                    "name": "Slashing Flourish",
                    "source": "XGE",
                    "page": 15,
                    "className": "Bard",
                    "classSource": "XGE",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "You can expend one use of your Bardic Inspiration to cause the weapon to deal extra damage to the target you hit and to any other creature of your choice that you can see within 5 feet of you. The damage equals the number you roll on the Bardic Inspiration die."
                    ]
                }
            ]
        }
        `;
        
        let data = {class: [], subclass:[], classFeature:[], subclassFeature:[]};
        let jsons = [class_barbarian, class_bard];
        for(let str of jsons){
            let parsed = JSON.parse(str);
            data.class = data.class.concat(parsed.class);
            data.subclass = data.subclass.concat(parsed.subclass);
            data.classFeature = data.classFeature.concat(parsed.classFeature);
            data.subclassFeature = data.subclassFeature.concat(parsed.subclassFeature);
        }
        return data;
    }
    /**Grabs JSON information from a file filled with information used in specific circumstances, such as figuring out class feature options (which proficiencies you get to choose between)
     * when you level up as one of the base classes
     */
    static _getFoundryData(){
        const _foundry = `{
            "class": [
                {
                    "name": "Sorcerer",
                    "source": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "sorcery-points",
                                "type": "number",
                                "scale": {
                                    "2": {
                                        "value": 2
                                    },
                                    "3": {
                                        "value": 3
                                    },
                                    "4": {
                                        "value": 4
                                    },
                                    "5": {
                                        "value": 5
                                    },
                                    "6": {
                                        "value": 6
                                    },
                                    "7": {
                                        "value": 7
                                    },
                                    "8": {
                                        "value": 8
                                    },
                                    "9": {
                                        "value": 9
                                    },
                                    "10": {
                                        "value": 10
                                    },
                                    "11": {
                                        "value": 11
                                    },
                                    "12": {
                                        "value": 12
                                    },
                                    "13": {
                                        "value": 13
                                    },
                                    "14": {
                                        "value": 14
                                    },
                                    "15": {
                                        "value": 15
                                    },
                                    "16": {
                                        "value": 16
                                    },
                                    "17": {
                                        "value": 17
                                    },
                                    "18": {
                                        "value": 18
                                    },
                                    "19": {
                                        "value": 19
                                    },
                                    "20": {
                                        "value": 20
                                    }
                                }
                            },
                            "title": "Sorcery Points"
                        }
                    ]
                }
            ],
            "subclass": [
                {
                    "name": "Nature Domain",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "Trickery Domain",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "Death Domain",
                    "source": "DMG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "College of Whispers",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "psychic-blades",
                                "type": "dice",
                                "scale": {
                                    "3": {
                                        "n": 2,
                                        "die": 6
                                    },
                                    "5": {
                                        "n": 3,
                                        "die": 6
                                    },
                                    "10": {
                                        "n": 5,
                                        "die": 6
                                    },
                                    "15": {
                                        "n": 8,
                                        "die": 6
                                    }
                                }
                            },
                            "title": "Psychic Blades"
                        }
                    ]
                },
                {
                    "name": "Forge Domain",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                },
                {
                    "name": "Order Domain",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "advancement": [
                        {
                            "type": "ScaleValue",
                            "configuration": {
                                "identifier": "divine-strike",
                                "type": "dice",
                                "scale": {
                                    "8": {
                                        "n": 1,
                                        "die": 8
                                    },
                                    "14": {
                                        "n": 2,
                                        "die": 8
                                    }
                                }
                            },
                            "title": "Divine Strike"
                        }
                    ]
                }
            ],
            "classFeature": [
                {
                    "name": "Unarmored Defense",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 1,
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Primal Knowledge",
                    "source": "TCE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "athletics",
                                        "intimidation",
                                        "nature",
                                        "perception",
                                        "survival"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Fast Movement",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 5,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ 10"
                                }
                            ]
                        }
                    ],
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Brutal Critical (1 die)",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 9,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.meleeCriticalDamageDice",
                                    "mode": "UPGRADE",
                                    "value": 1
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Brutal Critical (2 dice)",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 13,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.meleeCriticalDamageDice",
                                    "mode": "UPGRADE",
                                    "value": 2
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Brutal Critical (3 dice)",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 17,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.meleeCriticalDamageDice",
                                    "mode": "UPGRADE",
                                    "value": 3
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Primal Champion",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "level": 20,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.abilities.str.value",
                                    "mode": "ADD",
                                    "value": "+ 4"
                                },
                                {
                                    "key": "data.abilities.con.value",
                                    "mode": "ADD",
                                    "value": "+ 4"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Jack of All Trades",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 2,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.jackOfAllTrades",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Harness Divine Power",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "level": 2,
                    "system": {
                        "uses.per": "day",
                        "uses.value": 1,
                        "uses.max": "1 + min(floor(@classes.cleric.levels / 6), 1) + min(floor(@classes.cleric.levels / 18), 1)"
                    }
                },
                {
                    "name": "Channel Divinity",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "level": 6,
                    "isIgnored": true
                },
                {
                    "name": "Channel Divinity",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "level": 18,
                    "isIgnored": true
                },
                {
                    "name": "Druidic",
                    "source": "PHB",
                    "className": "Druid",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "druidic": true
                            }
                        ]
                    }
                },
                {
                    "name": "Fighting Style",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "level": 1,
                    "isIgnored": true
                },
                {
                    "name": "Martial Arts",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 1,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Unarmed Strike (Monk)",
                                "source": "PHB",
                                "page": 76,
                                "srd": true,
                                "type": "M",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "entries": [
                                    {
                                        "type": "quote",
                                        "entries": [
                                            "Tether even a roasted chicken."
                                        ],
                                        "by": "Yamamoto Tsunetomo",
                                        "from": "Hagakure Kikigaki"
                                    }
                                ],
                                "foundrySystem": {
                                    "equipped": true,
                                    "damage.parts": [
                                        [
                                            "@scale.monk.die + @mod",
                                            "bludgeoning"
                                        ]
                                    ],
                                    "ability": "dex"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Unarmored Defense",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 1,
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Unarmored Movement",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 2,
                    "effects": [
                        {
                            "name": "Unarmored Movement",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.walk) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.burrow",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.burrow) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.climb",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.climb) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.fly",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.fly) * @scale.monk.unarmored-movement)"
                                },
                                {
                                    "key": "data.attributes.movement.swim",
                                    "mode": "ADD",
                                    "value": "+ (sign(@attributes.movement.swim) * @scale.monk.unarmored-movement)"
                                }
                            ]
                        }
                    ],
                    "ignoreSrdEffects": true
                },
                {
                    "name": "Diamond Soul",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "level": 14,
                    "effects": [
                        {
                            "changes": [
                                {
                                    "key": "flags.dnd5e.diamondSoul",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Fighting Style",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "level": 2,
                    "isIgnored": true
                },
                {
                    "name": "Divine Health",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "level": 3,
                    "effects": [
                        {
                            "name": "Disease Immunity",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.traits.ci.value",
                                    "mode": "ADD",
                                    "value": "diseased"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Deft Explorer",
                    "source": "TCE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "any": 2
                            }
                        ],
                        "expertise": [
                            {
                                "anyProficientSkill": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Fighting Style",
                    "source": "PHB",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "level": 2,
                    "isIgnored": true
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            },
                            {
                                "anyProficientSkill": 1,
                                "thieves' tools": true
                            }
                        ]
                    }
                },
                {
                    "name": "Thieves' Cant",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "thieves' cant": true
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 6,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            },
                            {
                                "anyProficientSkill": 1,
                                "thieves' tools": true
                            }
                        ]
                    }
                },
                {
                    "name": "Reliable Talent",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 11,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.reliableTalent",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Blindsense",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 14,
                    "entryData": {
                        "senses": [
                            {
                                "blindsight": 10
                            }
                        ]
                    }
                },
                {
                    "name": "Slippery Mind",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "level": 15,
                    "entryData": {
                        "savingThrowProficiencies": [
                            {
                                "wis": true
                            }
                        ]
                    }
                },
                {
                    "name": "Font of Magic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 2,
                    "system": {
                        "activation.type": null,
                        "uses.per": null,
                        "uses.value": null,
                        "uses.max": null
                    }
                },
                {
                    "name": "Sorcery Points",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 2,
                    "system": {
                        "uses.per": "lr",
                        "uses.max": "@scale.sorcerer.sorcery-points"
                    },
                    "img": "icons/magic/control/silhouette-hold-change-blue.webp"
                },
                {
                    "name": "Metamagic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 3,
                    "entries": [
                        "At 3rd level, you gain the ability to twist your spells to suit your needs. You gain two Metamagic options of your choice. You gain another one at 10th and 17th level.",
                        "You can use only one Metamagic option on a spell when you cast it, unless otherwise noted."
                    ]
                },
                {
                    "name": "Metamagic Options",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Metamagic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Metamagic",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "level": 17,
                    "isIgnored": true
                },
                {
                    "name": "Eldritch Invocations",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "level": 2,
                    "entries": [
                        "In your study of occult lore, you have unearthed eldritch invocations, fragments of forbidden knowledge that imbue you with an abiding magical ability.",
                        "At 2nd level, you gain two eldritch invocations of your choice. Your invocation options are detailed at the end of the class description. When you gain certain warlock levels, you gain additional invocations of your choice, as shown in the Invocations Known column of the Warlock table.",
                        "Additionally, when you gain a level in this class, you can choose one of the invocations you know and replace it with another invocation that you could learn at that level.",
                        "If an eldritch invocation has prerequisites, you must meet them to learn it. You can learn the invocation at the same time that you meet its prerequisites. A level prerequisite refers to your level in this class."
                    ]
                },
                {
                    "name": "Pact Boon",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Infusions Known",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "level": 2,
                    "isIgnored": true
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Expert Sidekick",
                    "classSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "light": true
                            }
                        ],
                        "savingThrowProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "dex",
                                        "int",
                                        "cha"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "skillProficiencies": [
                            {
                                "any": 5
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "TCE",
                    "className": "Expert Sidekick",
                    "classSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Expertise",
                    "source": "TCE",
                    "className": "Expert Sidekick",
                    "classSource": "TCE",
                    "level": 15,
                    "entryData": {
                        "expertise": [
                            {
                                "anyProficientSkill": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Spellcaster Sidekick",
                    "classSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "light": true
                            }
                        ],
                        "savingThrowProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "wis",
                                        "int",
                                        "cha"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "insight",
                                        "investigation",
                                        "medicine",
                                        "performance",
                                        "persuasion",
                                        "religion"
                                    ],
                                    "count": 2
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Warrior Sidekick",
                    "classSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "light": true,
                                "medium": true,
                                "heavy": true
                            }
                        ],
                        "savingThrowProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "str",
                                        "dex",
                                        "con"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "acrobatics",
                                        "animal handling",
                                        "athletics",
                                        "intimidation",
                                        "nature",
                                        "perception",
                                        "survival"
                                    ],
                                    "count": 2
                                }
                            }
                        ]
                    }
                }
            ],
            "subclassFeature": [
                {
                    "name": "Eagle",
                    "source": "PHB",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Totem Warrior",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "activation.type": "bonus",
                        "activation.cost": 1
                    }
                },
                {
                    "name": "Call the Hunt",
                    "source": "TCE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Beast",
                    "subclassSource": "TCE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft"
                    }
                },
                {
                    "name": "Magic Awareness",
                    "source": "TCE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Wild Magic",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft"
                    }
                },
                {
                    "name": "Divine Fury",
                    "source": "XGE",
                    "className": "Barbarian",
                    "classSource": "PHB",
                    "subclassShortName": "Zealot",
                    "subclassSource": "XGE",
                    "level": 3,
                    "isChooseSystemRenderEntries": true,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "While you're raging, the first creature you hit on each of your turns with a weapon attack"
                    },
                    "chooseSystem": [
                        {
                            "name": "Necrotic Damage",
                            "system": {
                                "damage.parts": [
                                    [
                                        "1d6 + floor(@classes.barbarian.levels / 2)",
                                        "necrotic"
                                    ]
                                ]
                            }
                        },
                        {
                            "name": "Radiant Damage",
                            "system": {
                                "damage.parts": [
                                    [
                                        "1d6 + floor(@classes.barbarian.levels / 2)",
                                        "radiant"
                                    ]
                                ]
                            }
                        }
                    ]
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Lore",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "any": 3
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Valor",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "medium": true,
                                "shield|phb": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Performance of Creation",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "object",
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Animating Performance",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Creation",
                    "subclassSource": "TCE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "object",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Unsettling Words",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Universal Speech",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 6,
                    "system": {
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Infectious Inspiration",
                    "source": "TCE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Eloquence",
                    "subclassSource": "TCE",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Tales from Beyond",
                    "source": "VRGR",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Spirits",
                    "subclassSource": "VRGR",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Enthralling Performance",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Glamour",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "activation.type": "minute",
                        "activation.cost": 1,
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "medium": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "scimitar|phb": true
                            }
                        ]
                    }
                },
                {
                    "name": "Fighting Style",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Swords",
                    "subclassSource": "XGE",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Psychic Blades",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "When you hit a creature with a weapon attack",
                        "damage.parts": [
                            [
                                "@scale.college-of-whispers.psychic-blades",
                                "psychic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Words of Terror",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "activation.type": "minute",
                        "activation.cost": 1,
                        "target.value": 1,
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Mantle of Whispers",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Shadow Lore",
                    "source": "XGE",
                    "className": "Bard",
                    "classSource": "PHB",
                    "subclassShortName": "Whispers",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Channel Divinity: Touch of Death",
                    "source": "DMG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Death",
                    "subclassSource": "DMG",
                    "level": 2,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "When the cleric hits a creature with a melee attack",
                        "damage.parts": [
                            [
                                "5 + (2 * @classes.cleric.levels)",
                                "necrotic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "DMG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Death",
                    "subclassSource": "DMG",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.death-domain.divine-strike",
                                "necrotic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Blessings of Knowledge",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 2
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Knowledge of the Ages",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "duration.value": 10,
                        "duration.units": "minute"
                    }
                },
                {
                    "name": "Channel Divinity: Read Thoughts",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Visions of the Past",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Knowledge",
                    "subclassSource": "PHB",
                    "level": 17,
                    "system": {
                        "activation.type": "minute",
                        "activation.cost": 1
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Life",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ]
                    }
                },
                {
                    "name": "Disciple of Life",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Life",
                    "subclassSource": "PHB",
                    "level": 1,
                    "effects": [
                        {
                            "name": "Bonus Healing",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.bonuses.heal.damage",
                                    "mode": "ADD",
                                    "value": "+ @item.level + 2"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Channel Divinity: Radiance of the Dawn",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Light",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "damage.parts": [
                            [
                                "2d10 + @classes.cleric.levels",
                                "radiant"
                            ]
                        ],
                        "formula": ""
                    }
                },
                {
                    "name": "Corona of Light",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Light",
                    "subclassSource": "PHB",
                    "level": 17,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Acolyte of Nature",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "nature",
                                        "survival"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Charm Animals and Plants",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "damage.parts": [
                            [
                                "2d10 + @classes.cleric.levels",
                                "radiant"
                            ]
                        ]
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Nature",
                    "subclassSource": "PHB",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.nature-domain.divine-strike",
                                "cold"
                            ],
                            [
                                "@scale.nature-domain.divine-strike",
                                "fire"
                            ],
                            [
                                "@scale.nature-domain.divine-strike",
                                "lightning"
                            ]
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Tempest",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Invoke Duplicity",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Trickery",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Trickery",
                    "subclassSource": "PHB",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.order-domain.divine-strike",
                                "poison"
                            ]
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "War",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Acolyte of Strength",
                    "source": "PSA",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Strength (PSA)",
                    "subclassSource": "PSA",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "athletics",
                                        "nature",
                                        "survival"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Arcane Initiate",
                    "source": "SCAG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Arcana",
                    "subclassSource": "SCAG",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "arcana": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Arcane Abjuration",
                    "source": "SCAG",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Arcana",
                    "subclassSource": "SCAG",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Order",
                    "subclassSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "intimidation",
                                        "persuasion"
                                    ]
                                }
                            }
                        ],
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Order's Demand",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Order",
                    "subclassSource": "TCE",
                    "level": 2,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Order",
                    "subclassSource": "TCE",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.order-domain.divine-strike",
                                "psychic"
                            ]
                        ]
                    }
                },
                {
                    "name": "Emboldening Bond",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Peace",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Implement of Peace",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Peace",
                    "subclassSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "insight",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Twilight",
                    "subclassSource": "TCE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Eyes of Night",
                    "source": "TCE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Twilight",
                    "subclassSource": "TCE",
                    "level": 1,
                    "actorTokenMod": {
                        "dimSight": [
                            {
                                "mode": "setMax",
                                "value": 300
                            }
                        ]
                    },
                    "system": {
                        "target.type": "creature",
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TDCSR",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Blood",
                    "subclassSource": "TDCSR",
                    "level": 1,
                    "entryData": {
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Forge",
                    "subclassSource": "XGE",
                    "level": 1,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            }
                        ]
                    }
                },
                {
                    "name": "Divine Strike",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Forge",
                    "subclassSource": "XGE",
                    "level": 8,
                    "system": {
                        "damage.parts": [
                            [
                                "@scale.forge-domain.divine-strike",
                                "fire"
                            ]
                        ]
                    }
                },
                {
                    "name": "Saint of Forge and Fire",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Forge",
                    "subclassSource": "XGE",
                    "level": 17,
                    "entryData": {
                        "immune": [
                            "fire"
                        ]
                    }
                },
                {
                    "name": "Channel Divinity: Path to the Grave",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Grave",
                    "subclassSource": "XGE",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Sentinel at Death's Door",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Grave",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Keeper of Souls",
                    "source": "XGE",
                    "className": "Cleric",
                    "classSource": "PHB",
                    "subclassShortName": "Grave",
                    "subclassSource": "XGE",
                    "level": 17,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Nature's Ward",
                    "source": "PHB",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Land",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "immune": [
                            "poison"
                        ],
                        "conditionImmune": [
                            "disease",
                            "poisoned"
                        ]
                    }
                },
                {
                    "name": "Halo of Spores",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Spores",
                    "subclassSource": "TCE",
                    "level": 2,
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "range.units": "self"
                    }
                },
                {
                    "name": "Spreading Spores",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Spores",
                    "subclassSource": "TCE",
                    "level": 10,
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "cube",
                        "range.value": 30,
                        "range.units": "ft",
                        "duration.value": 1,
                        "duration.units": "minute"
                    }
                },
                {
                    "name": "Fungal Body",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Spores",
                    "subclassSource": "TCE",
                    "level": 14,
                    "entryData": {
                        "conditionImmune": [
                            "blinded",
                            "deafened",
                            "frightened",
                            "poisoned"
                        ]
                    }
                },
                {
                    "name": "Summon Wildfire Spirit",
                    "source": "TCE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Wildfire",
                    "subclassSource": "TCE",
                    "level": 2,
                    "system": {
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Incarnation of Corruption",
                    "source": "TDCSR",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Blighted",
                    "subclassSource": "TDCSR",
                    "level": 14,
                    "entryData": {
                        "resist": [
                            "necrotic"
                        ]
                    }
                },
                {
                    "name": "Balm of the Summer Court",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Dreams",
                    "subclassSource": "XGE",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 120,
                        "range.units": "ft",
                        "uses.per": "charges",
                        "uses.value": 2,
                        "uses.max": "@classes.druid.levels",
                        "uses.recovery": "@classes.druid.levels",
                        "formula": "1d6",
                        "actionType": "healing"
                    }
                },
                {
                    "name": "Hearth of Moonlight and Shadow",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Dreams",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Hidden Paths",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Dreams",
                    "subclassSource": "XGE",
                    "level": 10,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Speech of the Woods",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Shepherd",
                    "subclassSource": "XGE",
                    "level": 2,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "sylvan": true
                            }
                        ]
                    }
                },
                {
                    "name": "Spirit Totem",
                    "source": "XGE",
                    "className": "Druid",
                    "classSource": "PHB",
                    "subclassShortName": "Shepherd",
                    "subclassSource": "XGE",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Unleash Incarnation",
                    "source": "EGW",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Echo Knight",
                    "subclassSource": "EGW",
                    "level": 3,
                    "system": {
                        "activation.type": "special",
                        "activation.condition": "Whenever you take the Attack action",
                        "activation.cost": 1
                    }
                },
                {
                    "name": "Combat Superiority",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "resources": [
                            {
                                "name": "Superiority Die",
                                "type": "dicePool",
                                "recharge": "restShort",
                                "count": "floor((<$level$> + 1) / 8) + 4",
                                "number": 1,
                                "faces": "8 + (sign(ceil((<$level$> - 2) / 8) - 1) * 2)"
                            }
                        ]
                    },
                    "system": {
                        "activation.type": null,
                        "uses.value": null,
                        "uses.max": null
                    }
                },
                {
                    "name": "Maneuver Options",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Student of War",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Additional Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 7,
                    "isIgnored": true
                },
                {
                    "name": "Additional Superiority Die",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 7,
                    "isIgnored": true
                },
                {
                    "name": "Additional Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Improved Combat Superiority (d10)",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Additional Maneuvers",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 15,
                    "isIgnored": true
                },
                {
                    "name": "Additional Superiority Die",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 15,
                    "isIgnored": true
                },
                {
                    "name": "Improved Combat Superiority (d12)",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Battle Master",
                    "subclassSource": "PHB",
                    "level": 18,
                    "isIgnored": true
                },
                {
                    "name": "Improved Critical",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Champion",
                    "subclassSource": "PHB",
                    "level": 3,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.weaponCriticalThreshold",
                                    "mode": "OVERRIDE",
                                    "value": 19
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Remarkable Athlete",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Champion",
                    "subclassSource": "PHB",
                    "level": 7,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "flags.dnd5e.remarkableAthlete",
                                    "mode": "OVERRIDE",
                                    "value": true
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Additional Fighting Style",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Champion",
                    "subclassSource": "PHB",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Arcane Charge",
                    "source": "PHB",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Eldritch Knight",
                    "subclassSource": "PHB",
                    "level": 15,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Rallying Cry",
                    "source": "SCAG",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Purple Dragon Knight (Banneret)",
                    "subclassSource": "SCAG",
                    "level": 3,
                    "system": {
                        "target.value": 3,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Royal Envoy",
                    "source": "SCAG",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Purple Dragon Knight (Banneret)",
                    "subclassSource": "SCAG",
                    "level": 7,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "insight",
                                        "intimidation",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ],
                        "expertise": [
                            {
                                "persuasion": true
                            }
                        ]
                    }
                },
                {
                    "name": "Inspiring Surge",
                    "source": "SCAG",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Purple Dragon Knight (Banneret)",
                    "subclassSource": "SCAG",
                    "level": 10,
                    "system": {
                        "target.value": 1,
                        "target.type": "ally",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Psionic Power",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Psi Warrior",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "resources": [
                            {
                                "name": "Psionic Energy Die",
                                "type": "dicePool",
                                "recharge": "restLong",
                                "count": "2 * PB",
                                "number": 1,
                                "faces": "(6 + ((ceil((<$level$> + 2) / 6) - 1) * 2))"
                            }
                        ]
                    }
                },
                {
                    "name": "Guarded Mind",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Psi Warrior",
                    "subclassSource": "TCE",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "psychic"
                        ]
                    }
                },
                {
                    "name": "Bulwark of Force",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Psi Warrior",
                    "subclassSource": "TCE",
                    "level": 15,
                    "system": {
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "giant": true
                            }
                        ]
                    }
                },
                {
                    "name": "Rune Carver",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entries": [
                        "{@i 3rd-level Rune Knight feature}",
                        "You can use magic runes to enhance your gear. You learn two runes of your choice, from among the runes described below, and each time you gain a level in this class, you can replace one rune you know with a different one from this feature. When you reach certain levels in this class, you learn additional runes, as shown in the Runes Known table.",
                        "Whenever you finish a long rest, you can touch a number of objects equal to the number of runes you know, and you inscribe a different rune onto each of the objects. To be eligible, an object must be a weapon, a suit of armor, a shield, a piece of jewelry, or something else you can wear or hold in a hand. Your rune remains on an object until you finish a long rest, and an object can bear only one of your runes at a time.",
                        {
                            "type": "table",
                            "caption": "Runes Known",
                            "colLabels": [
                                "Fighter Level",
                                "Number of Runes"
                            ],
                            "colStyles": [
                                "col-6 text-center",
                                "col-6 text-center"
                            ],
                            "rows": [
                                [
                                    "3rd",
                                    "2"
                                ],
                                [
                                    "7th",
                                    "3"
                                ],
                                [
                                    "10th",
                                    "4"
                                ],
                                [
                                    "15th",
                                    "5"
                                ]
                            ]
                        },
                        "If a rune has a level requirement, you must be at least that level in this class to learn the rune. If a rune requires a saving throw, your Rune Magic save DC equals 8 + your proficiency bonus + your Constitution modifier."
                    ]
                },
                {
                    "name": "Additional Rune Known",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 7,
                    "entries": [
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Cloud Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Fire Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Frost Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Stone Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Hill Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Storm Rune|TCE"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Runic Shield",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 7,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Additional Rune Known",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 10,
                    "entries": [
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Cloud Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Fire Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Frost Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Stone Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Hill Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Storm Rune|TCE"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Additional Rune Known",
                    "source": "TCE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Rune Knight",
                    "subclassSource": "TCE",
                    "level": 15,
                    "entries": [
                        {
                            "type": "options",
                            "count": 1,
                            "entries": [
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Cloud Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Fire Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Frost Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Stone Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Hill Rune|TCE"
                                },
                                {
                                    "type": "refOptionalfeature",
                                    "optionalfeature": "Storm Rune|TCE"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Arcane Archer Lore",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "nature"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Arcane Shot",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "uses.per": "sr",
                        "uses.value": 2,
                        "uses.max": 2
                    }
                },
                {
                    "name": "Arcane Shot Options",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entries": [
                        "Arcane shots are all magical effects, and each one is associated with one of the schools of magic.",
                        "If an option requires a saving throw, your Arcane Shot save DC is calculated as follows:",
                        {
                            "type": "abilityDc",
                            "name": "Arcane Shot",
                            "attributes": [
                                "int"
                            ]
                        }
                    ]
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 7,
                    "isIgnored": true
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 10,
                    "isIgnored": true
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 15,
                    "isIgnored": true
                },
                {
                    "name": "Additional Arcane Shot Option",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Arcane Archer",
                    "subclassSource": "XGE",
                    "level": 18,
                    "isIgnored": true
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Cavalier",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "animal handling",
                                        "history",
                                        "insight",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiency",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Samurai",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "history",
                                        "insight",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Elegant Courtier",
                    "source": "XGE",
                    "className": "Fighter",
                    "classSource": "PHB",
                    "subclassShortName": "Samurai",
                    "subclassSource": "XGE",
                    "level": 7,
                    "entryData": {
                        "savingThrowProficiencies": [
                            {
                                "wis": true
                            },
                            {
                                "choose": {
                                    "from": [
                                        "int",
                                        "cha"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Draconic Disciple",
                    "source": "FTD",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Ascendant Dragon",
                    "subclassSource": "FTD",
                    "level": 3,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Elemental Disciplines",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 3,
                    "isIgnored": true
                },
                {
                    "name": "Extra Elemental Discipline",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 6,
                    "isIgnored": true
                },
                {
                    "name": "Extra Elemental Discipline",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 11,
                    "isIgnored": true
                },
                {
                    "name": "Extra Elemental Discipline",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Four Elements",
                    "subclassSource": "PHB",
                    "level": 17,
                    "isIgnored": true
                },
                {
                    "name": "Shadow Step",
                    "source": "PHB",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Shadow",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "space"
                    }
                },
                {
                    "name": "Hour of Reaping",
                    "source": "SCAG",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Long Death",
                    "subclassSource": "SCAG",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Implements of Mercy",
                    "source": "TCE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Mercy",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "insight": true,
                                "medicine": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "herbalism kit": true
                            }
                        ]
                    }
                },
                {
                    "name": "Mystical Erudition",
                    "source": "TDCSR",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Cobalt Soul",
                    "subclassSource": "TDCSR",
                    "level": 6,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "investigation",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Mystical Erudition (11th Level)",
                    "source": "TDCSR",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Cobalt Soul",
                    "subclassSource": "TDCSR",
                    "level": 11,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "investigation",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Mystical Erudition (17th Level)",
                    "source": "TDCSR",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Cobalt Soul",
                    "subclassSource": "TDCSR",
                    "level": 17,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "arcana",
                                        "history",
                                        "investigation",
                                        "nature",
                                        "religion"
                                    ],
                                    "count": 1
                                }
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Drunken Master",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "performance": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "brewer's supplies": true
                            }
                        ]
                    }
                },
                {
                    "name": "Path of the Kensei",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Kensei",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "calligrapher's supplies",
                                        "painter's supplies"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Radiant Sun Bolt",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Sun Soul",
                    "subclassSource": "XGE",
                    "level": 3,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Radiant Sun Bolt",
                                "source": "XGE",
                                "page": 35,
                                "type": "R",
                                "range": "30",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "entries": [
                                    "This special attack is a ranged spell attack with a range of 30 feet. You are proficient with it, and you add your Dexterity modifier to its attack and damage rolls.",
                                    "When you take the {@action Attack} action on your turn and use this special attack as part of it, you can spend 1 ki point to make this special attack twice as a bonus action. When you gain the Extra Attack feature, this special attack can be used for any of the attacks you make as part of the {@action Attack} action."
                                ],
                                "foundrySystem": {
                                    "equipped": true,
                                    "damage.parts": [
                                        [
                                            "@scale.monk.die + @mod",
                                            "radiant"
                                        ]
                                    ],
                                    "ability": "dex"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Searing Sunburst",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Sun Soul",
                    "subclassSource": "XGE",
                    "level": 11,
                    "system": {
                        "target.value": 20,
                        "target.units": "ft",
                        "target.type": "sphere",
                        "range.value": 150,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Sun Shield",
                    "source": "XGE",
                    "className": "Monk",
                    "classSource": "PHB",
                    "subclassShortName": "Sun Soul",
                    "subclassSource": "XGE",
                    "level": 17,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Control Undead",
                    "source": "DMG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Oathbreaker",
                    "subclassSource": "DMG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Dreadful Aspect",
                    "source": "DMG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Oathbreaker",
                    "subclassSource": "DMG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Nature's Wrath",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Ancients",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Turn the Faithless",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Ancients",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Sacred Weapon",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Devotion",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 40,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Turn the Unholy",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Devotion",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Holy Nimbus",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Devotion",
                    "subclassSource": "PHB",
                    "level": 20,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Abjure Enemy",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Vengeance",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Vow of Enmity",
                    "source": "PHB",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Vengeance",
                    "subclassSource": "PHB",
                    "level": 3,
                    "system": {
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Champion Challenge",
                    "source": "SCAG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Crown",
                    "subclassSource": "SCAG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Turn the Tide",
                    "source": "SCAG",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Crown",
                    "subclassSource": "SCAG",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Inspiring Smite",
                    "source": "TCE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Glory",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Glorious Defense",
                    "source": "TCE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Glory",
                    "subclassSource": "TCE",
                    "level": 15,
                    "system": {
                        "range.value": 10,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Vigilant Rebuke",
                    "source": "TCE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Watchers",
                    "subclassSource": "TCE",
                    "level": 15,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Conquering Presence",
                    "source": "XGE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Conquest",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "creature"
                    }
                },
                {
                    "name": "Rebuke the Violent",
                    "source": "XGE",
                    "className": "Paladin",
                    "classSource": "PHB",
                    "subclassShortName": "Redemption",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Draconic Gift",
                    "source": "FTD",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Drakewarden",
                    "subclassSource": "FTD",
                    "level": 3,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "any": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Otherworldly Glamour",
                    "source": "TCE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Fey Wanderer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "deception",
                                        "performance",
                                        "persuasion"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Beguiling Twist",
                    "source": "TCE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Fey Wanderer",
                    "subclassSource": "TCE",
                    "level": 7,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Umbral Sight",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Gloom Stalker",
                    "subclassSource": "XGE",
                    "level": 3,
                    "actorTokenMod": {
                        "_": [
                            {
                                "mode": "conditionals",
                                "conditionals": [
                                    {
                                        "condition": "!PLUT_CONTEXT?.actor?.data?.token?.dimSight",
                                        "mod": {
                                            "dimSight": [
                                                {
                                                    "mode": "set",
                                                    "value": 60
                                                }
                                            ]
                                        }
                                    },
                                    {
                                        "mod": {
                                            "dimSight": [
                                                {
                                                    "mode": "scalarAdd",
                                                    "scalar": 30
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        ]
                    }
                },
                {
                    "name": "Iron Mind",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Gloom Stalker",
                    "subclassSource": "XGE",
                    "level": 7,
                    "entryData": {
                        "savingThrowProficiencies": [
                            {
                                "wis": true
                            },
                            {
                                "choose": {
                                    "from": [
                                        "int",
                                        "cha"
                                    ]
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Hunter's Sense",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Monster Slayer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Slayer's Prey",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Monster Slayer",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Magic-User's Nemesis",
                    "source": "XGE",
                    "className": "Ranger",
                    "classSource": "PHB",
                    "subclassShortName": "Monster Slayer",
                    "subclassSource": "XGE",
                    "level": 11,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bonus Proficiencies",
                    "source": "PHB",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Assassin",
                    "subclassSource": "PHB",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "disguise kit": true,
                                "poisoner's kit": true
                            }
                        ]
                    }
                },
                {
                    "name": "Wails from the Grave",
                    "source": "TCE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Phantom",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Psionic Power",
                    "source": "TCE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Soulknife",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "resources": [
                            {
                                "name": "Psionic Energy Die",
                                "type": "dicePool",
                                "recharge": "restLong",
                                "count": "2 * PB",
                                "number": 1,
                                "faces": "(6 + (ceil((<$level$> + 2) / 6) - 1) * 2)"
                            }
                        ]
                    }
                },
                {
                    "name": "Master of Intrigue",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Mastermind",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "disguise kit": true,
                                "forgery kit": true,
                                "gaming set": true
                            }
                        ],
                        "languageProficiencies": [
                            {
                                "any": 2
                            }
                        ]
                    }
                },
                {
                    "name": "Master of Tactics",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Mastermind",
                    "subclassSource": "XGE",
                    "level": 3,
                    "system": {
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Survivalist",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Scout",
                    "subclassSource": "XGE",
                    "level": 3,
                    "entryData": {
                        "expertise": [
                            {
                                "nature": true,
                                "survival": true
                            }
                        ]
                    }
                },
                {
                    "name": "Superior Mobility",
                    "source": "XGE",
                    "className": "Rogue",
                    "classSource": "PHB",
                    "subclassShortName": "Scout",
                    "subclassSource": "XGE",
                    "level": 9,
                    "effects": [
                        {
                            "name": "Superior Mobility",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ 10"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Draconic Resilience",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 1,
                    "effects": [
                        {
                            "name": "Natural Armor",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.ac.calc",
                                    "mode": "OVERRIDE",
                                    "value": "draconic"
                                }
                            ]
                        },
                        {
                            "name": "HP Increase",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.hp.max",
                                    "mode": "ADD",
                                    "value": "+ @classes.sorcerer.levels"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Dragon Ancestor",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "draconic": true
                            }
                        ]
                    }
                },
                {
                    "name": "Dragon Wings",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 14,
                    "effects": [
                        {
                            "name": "Flying Speed",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.fly",
                                    "mode": "UPGRADE",
                                    "value": "@attributes.movement.walk"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Draconic Presence",
                    "source": "PHB",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Draconic",
                    "subclassSource": "PHB",
                    "level": 18,
                    "system": {
                        "target.value": 60,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Telepathic Speech",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Aberrant Mind",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Warping Implosion",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Aberrant Mind",
                    "subclassSource": "TCE",
                    "level": 18,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Restore Balance",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Clockwork Soul",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Bastion of Law",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Clockwork Soul",
                    "subclassSource": "TCE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Clockwork Cavalcade",
                    "source": "TCE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Clockwork Soul",
                    "subclassSource": "TCE",
                    "level": 18,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "cube"
                    }
                },
                {
                    "name": "Hound of Ill Omen",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Shadow",
                    "subclassSource": "XGE",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Shadow Walk",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Shadow",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 120,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Wind Speaker",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Storm",
                    "subclassSource": "XGE",
                    "level": 1,
                    "entryData": {
                        "languageProficiencies": [
                            {
                                "primordial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Heart of the Storm",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Storm",
                    "subclassSource": "XGE",
                    "level": 6,
                    "entryData": {
                        "resist": [
                            "lightning",
                            "thunder"
                        ]
                    },
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Wind Soul",
                    "source": "XGE",
                    "className": "Sorcerer",
                    "classSource": "PHB",
                    "subclassShortName": "Storm",
                    "subclassSource": "XGE",
                    "level": 18,
                    "entryData": {
                        "immune": [
                            "lightning",
                            "thunder"
                        ]
                    }
                },
                {
                    "name": "Fey Presence",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 1,
                    "system": {
                        "target.value": 10,
                        "target.units": "ft",
                        "target.type": "cube"
                    }
                },
                {
                    "name": "Misty Escape",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Beguiling Defenses",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "conditionImmune": [
                            "charmed"
                        ]
                    }
                },
                {
                    "name": "Dark Delirium",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Archfey",
                    "subclassSource": "PHB",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Awakened Mind",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Great Old One",
                    "subclassSource": "PHB",
                    "level": 1,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Thought Shield",
                    "source": "PHB",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Great Old One",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "psychic"
                        ]
                    }
                },
                {
                    "name": "Gift of the Sea",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 1,
                    "effects": [
                        {
                            "name": "Gift of the Sea",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.swim",
                                    "mode": "UPGRADE",
                                    "value": "40"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Tentacle of the Deeps",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 1,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Oceanic Soul",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 6,
                    "entryData": {
                        "resist": [
                            "cold"
                        ]
                    }
                },
                {
                    "name": "Fathomless Plunge",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Fathomless",
                    "subclassSource": "TCE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "radius",
                        "range.value": 1,
                        "range.units": "mi"
                    }
                },
                {
                    "name": "Sanctuary Vessel",
                    "source": "TCE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Genie",
                    "subclassSource": "TCE",
                    "level": 10,
                    "system": {
                        "target.value": 5,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Necrotic Husk",
                    "source": "VRGR",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Undead",
                    "subclassSource": "VRGR",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "necrotic"
                        ]
                    },
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "radius"
                    }
                },
                {
                    "name": "Radiant Soul",
                    "source": "XGE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Celestial",
                    "subclassSource": "XGE",
                    "level": 6,
                    "entryData": {
                        "resist": [
                            "radiant"
                        ]
                    }
                },
                {
                    "name": "Searing Vengeance",
                    "source": "XGE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Celestial",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Hex Warrior",
                    "source": "XGE",
                    "className": "Warlock",
                    "classSource": "PHB",
                    "subclassShortName": "Hexblade",
                    "subclassSource": "XGE",
                    "level": 1,
                    "entryData": {
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ],
                        "armorProficiencies": [
                            {
                                "shield|phb": true,
                                "medium": true
                            }
                        ]
                    }
                },
                {
                    "name": "Chronal Shift",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 2,
                    "system": {
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Temporal Awareness",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 2,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.init.total",
                                    "mode": "ADD",
                                    "value": "+ @abilities.int.mod"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Momentary Stasis",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 6,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Convergent Future",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Chronurgy",
                    "subclassSource": "EGW",
                    "level": 14,
                    "system": {
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Adjust Density",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Graviturgy",
                    "subclassSource": "EGW",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Violent Attraction",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Graviturgy",
                    "subclassSource": "EGW",
                    "level": 10,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Event Horizon",
                    "source": "EGW",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Graviturgy",
                    "subclassSource": "EGW",
                    "level": 14,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Arcane Ward",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Abjuration",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "activation.type": "special",
                        "activation.cost": null,
                        "uses.per": null,
                        "uses.max": "2 * @classes.wizard.levels + floor((@abilities.int.value - 10) / 2)"
                    }
                },
                {
                    "name": "Projected Ward",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Abjuration",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 30,
                        "target.units": "ft",
                        "target.type": "sphere"
                    }
                },
                {
                    "name": "Benign Transposition",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Conjuration",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "space",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Hypnotic Gaze",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Enchantment",
                    "subclassSource": "PHB",
                    "level": 2,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 5,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Instinctive Charm",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Enchantment",
                    "subclassSource": "PHB",
                    "level": 6,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 30,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Inured to Undeath",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Necromancy",
                    "subclassSource": "PHB",
                    "level": 10,
                    "entryData": {
                        "resist": [
                            "necrotic"
                        ]
                    }
                },
                {
                    "name": "Command Undead",
                    "source": "PHB",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Necromancy",
                    "subclassSource": "PHB",
                    "level": 14,
                    "system": {
                        "target.value": 1,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Training in War and Song (Bladesinging)",
                    "source": "TCE",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "Bladesinging",
                    "subclassSource": "TCE",
                    "level": 2,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "performance": true
                            }
                        ],
                        "armorProficiencies": [
                            {
                                "light": true
                            }
                        ],
                        "weaponProficiencies": [
                            {
                                "choose": {
                                    "fromFilter": "type=melee weapon|property=!two-handed|rarity=none"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Deflecting Shroud",
                    "source": "XGE",
                    "className": "Wizard",
                    "classSource": "PHB",
                    "subclassShortName": "War",
                    "subclassSource": "XGE",
                    "level": 14,
                    "system": {
                        "target.value": 3,
                        "target.type": "creature",
                        "range.value": 60,
                        "range.units": "ft"
                    }
                },
                {
                    "name": "Tiger",
                    "source": "SCAG",
                    "className": "Barbarian",
                    "classSource": "SCAG",
                    "subclassShortName": "Totem Warrior",
                    "subclassSource": "PHB",
                    "level": 6,
                    "entryData": {
                        "skillProficiencies": [
                            {
                                "choose": {
                                    "from": [
                                        "athletics",
                                        "acrobatics",
                                        "stealth",
                                        "survival"
                                    ],
                                    "count": 2
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Tool Proficiency",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Alchemist",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "alchemist's supplies": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Chemical Mastery",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Alchemist",
                    "subclassSource": "TCE",
                    "level": 15,
                    "entryData": {
                        "resist": [
                            "acid",
                            "poison"
                        ],
                        "conditionImmune": [
                            "poisoned"
                        ]
                    }
                },
                {
                    "name": "Armor Model",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "uses.value": null,
                        "uses.max": null,
                        "uses.per": null
                    }
                },
                {
                    "name": "Defensive Field",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "actionType": "heal",
                        "damage.parts": [
                            [
                                "@classes.artificer.levels",
                                "temphp"
                            ]
                        ]
                    }
                },
                {
                    "name": "Lightning Launcher",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Lightning Launcher",
                                "source": "TCE",
                                "page": 15,
                                "srd": true,
                                "type": "R",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "dmg1": "1d6",
                                "dmgType": "L",
                                "range": "90/300",
                                "entries": [
                                    "This weapon is part of the Infiltrator armor model. When you attack with that weapon, you can add your Intelligence modifier, instead of Strength or Dexterity, to the attack and damage rolls.",
                                    "Once on each of your turns when you hit a creature with the launcher, you can deal an extra {@damage 1d6} lightning damage to that target."
                                ],
                                "foundrySystem": {
                                    "ability": "int"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Powered Steps",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "effects": [
                        {
                            "name": "Powered Steps",
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.attributes.movement.walk",
                                    "mode": "ADD",
                                    "value": "+ 5"
                                }
                            ],
                            "disabled": true
                        }
                    ]
                },
                {
                    "name": "Thunder Gauntlets",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "subEntities": {
                        "item": [
                            {
                                "name": "Thunder Gauntlets",
                                "source": "TCE",
                                "page": 15,
                                "srd": true,
                                "type": "M",
                                "rarity": "none",
                                "weaponCategory": "simple",
                                "dmg1": "1d8",
                                "dmgType": "T",
                                "entries": [
                                    "This weapon is part of the Guardian armor model. When you attack with that weapon, you can add your Intelligence modifier, instead of Strength or Dexterity, to the attack and damage rolls.",
                                    "A creature hit by the gauntlet has disadvantage on attack rolls against targets other than you until the start of your next turn, as the armor magically emits a distracting pulse when the creature attacks someone else."
                                ],
                                "foundrySystem": {
                                    "ability": "int"
                                }
                            }
                        ]
                    }
                },
                {
                    "name": "Tools of the Trade",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Armorer",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "armorProficiencies": [
                            {
                                "heavy": true
                            }
                        ],
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Eldritch Cannon",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Artillerist",
                    "subclassSource": "TCE",
                    "level": 3,
                    "system": {
                        "damage.parts": [
                            [
                                "2d8",
                                "fire"
                            ],
                            [
                                "2d8",
                                "force"
                            ]
                        ],
                        "formula": "1d8 + @abilities.int.mod"
                    }
                },
                {
                    "name": "Tool Proficiency",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Artillerist",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "woodcarver's tools": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                },
                {
                    "name": "Arcane Firearm",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Artillerist",
                    "subclassSource": "TCE",
                    "level": 5,
                    "effects": [
                        {
                            "transfer": true,
                            "changes": [
                                {
                                    "key": "data.bonuses.msak.damage",
                                    "mode": "ADD",
                                    "value": "+ 1d8"
                                },
                                {
                                    "key": "data.bonuses.rsak.damage",
                                    "mode": "ADD",
                                    "value": "+ 1d8"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Battle Ready",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Battle Smith",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "weaponProficiencies": [
                            {
                                "martial": true
                            }
                        ]
                    }
                },
                {
                    "name": "Tool Proficiency",
                    "source": "TCE",
                    "className": "Artificer",
                    "classSource": "TCE",
                    "subclassShortName": "Battle Smith",
                    "subclassSource": "TCE",
                    "level": 3,
                    "entryData": {
                        "toolProficiencies": [
                            {
                                "smith's tools": true
                            },
                            {
                                "anyArtisansTool": 1
                            }
                        ]
                    }
                }
            ]
        }
        `;
        let parsed = JSON.parse(_foundry);
        return parsed;
    }
    static getClasses(){
        return ContentGetter._getBase().class;
    }
    static getSubclasses(){
        return ContentGetter._getBase().subclass;
    }
    static getFeaturesFromClass(cls){
        return this._getBase().classFeature.filter(f => f.className == cls.name && f.classSource == cls.source);
    }
    static getFeaturesFromSubclass(sc){
        return this._getBase().subclassFeature.filter(f =>
            f.className == sc.className &&
            f.classSource == sc.classSource &&
            f.subclassSource == sc.source &&
            f.subclassShortName == sc.shortName);
    }
    static getClassByNameAndSource(name, source){
        return ContentGetter.getClasses().filter(cls => cls.name == name && cls.source == source);
    }
    static getClassFeatureByUID(featureUID){
        const unpacked = MyDataUtil.unpackUidClassFeature(featureUID);
        const foundClasses = this.getClassByNameAndSource(unpacked.className, unpacked.classSource);
        if(foundClasses.length<1){console.error("Did not find any classes with name and source ", unpacked.className, unpacked.classSource);}
        if(foundClasses.length>1){console.error("Found too many classes with name and source ", unpacked.className, unpacked.classSource);}
        const cls = foundClasses[0];
        const allFeatures = ContentGetter.getFeaturesFromClass(cls);
        return allFeatures.filter(f => f.name == unpacked.name && f.level == unpacked.level)[0];
    }
    _cookData(){
        //Prep class feature info
        const isIgnoredLookup = {
            "elemental disciplines|monk||four elements||3":true,
            "fighting style|bard||swords|xge|3":true,
            "infusions known|artificer|tce|2":true,
            "maneuver options|fighter||battle master||3|tce":true,
            "maneuvers|fighter||battle master||3":true
        };
        const opts = {actor: this._actor, isIgnoredLookup: isIgnoredLookup};
        for(let j = 0; j < this._data.class.length; ++j)
        {
            let cls = this._data.class[j];
            //Make sure the classFeatures aren't just strings, look like this:
            //{classFeature: "string"}
            for(let i = 0; i < cls.classFeatures.length; ++i){
            let f = cls.classFeatures[i];
            if (typeof f !== "object") {cls.classFeatures[i] = {classFeature: f};}
            }
    
            //Now we need to flesh out some more data about the class features, using just the UID we can get a lot of such info.
            await (cls.classFeatures || []).pSerialAwaitMap(cf => MyDataUtil.pInitClassFeatureLoadeds({...opts, classFeature: cf, className: cls.name}));
    
            if (cls.classFeatures) {cls.classFeatures = cls.classFeatures.filter(it => !it.isIgnored);}
            this._data.class[j] = cls;
    
            /* for (const sc of cls.subclasses || []) {
            await (sc.subclassFeatures || []).pSerialAwaitMap(scf => this.pInitSubclassFeatureLoadeds({...opts, subclassFeature: scf, className: cls.name, subclassName: sc.name}));
    
            if (sc.subclassFeatures) sc.subclassFeatures = sc.subclassFeatures.filter(it => !it.isIgnored);
        } */
        }
    }
    /**Sligtly parses the class features a bit to prepare them with loadeds, a property needed to convert them to option sets later. */
    static async cookClassFeatures(cls){
        const isIgnoredLookup = {
            "elemental disciplines|monk||four elements||3":true,
            "fighting style|bard||swords|xge|3":true,
            "infusions known|artificer|tce|2":true,
            "maneuver options|fighter||battle master||3|tce":true,
            "maneuvers|fighter||battle master||3":true
        };
        const opts = {isIgnoredLookup: isIgnoredLookup};

        //We just need the UID of the classFeatures stored directly in the class
        for(let i = 0; i < cls.classFeatures.length; ++i){
            let f = cls.classFeatures[i];
            if (typeof f !== "object") {cls.classFeatures[i] = {classFeature: f};}
        }
    
        //Now we need to flesh out some more data about the class features, using just the UID we can get a lot of such info.
        await (cls.classFeatures || []).pSerialAwaitMap(cf => MyDataUtil.pInitClassFeatureLoadeds({...opts, classFeature: cf, className: cls.name}));

        if (cls.classFeatures) {cls.classFeatures = cls.classFeatures.filter(it => !it.isIgnored);}

        return cls.classFeatures;
    }
}
//#endregion

//#region UtilPrePreInit
class UtilPrePreInit {
    static _IS_GM = null;

    static isGM() {
        return true;
        //return UtilPrePreInit._IS_GM = UtilPrePreInit._IS_GM ?? game.data.users.find(it=>it._id === game.userId).role >= CONST.USER_ROLES.ASSISTANT;
    }
}
//#endregion


//#region CleanUtil
globalThis.CleanUtil = {
    getCleanJson(data, {isMinify=false, isFast=true}={}) {
        data = MiscUtil.copy(data);
        data = MiscUtil.getWalker().walk(data, {
            string: (str)=>CleanUtil.getCleanString(str, {
                isFast
            })
        });
        let str = isMinify ? JSON.stringify(data) : `${JSON.stringify(data, null, "\t")}\n`;
        return str.replace(CleanUtil.STR_REPLACEMENTS_REGEX, (match)=>CleanUtil.STR_REPLACEMENTS[match]);
    },

    getCleanString(str, {isFast=true}={}) {
        str = str.replace(CleanUtil.SHARED_REPLACEMENTS_REGEX, (match)=>CleanUtil.SHARED_REPLACEMENTS[match]).replace(CleanUtil._SOFT_HYPHEN_REMOVE_REGEX, "");

        if (isFast)
            return str;

        const ptrStack = {
            _: ""
        };
        CleanUtil._getCleanString_walkerStringHandler(ptrStack, 0, str);
        return ptrStack._;
    },

    _getCleanString_walkerStringHandler(ptrStack, tagCount, str) {
        const tagSplit = Renderer.splitByTags(str);
        const len = tagSplit.length;
        for (let i = 0; i < len; ++i) {
            const s = tagSplit[i];
            if (!s)
                continue;
            if (s.startsWith("{@")) {
                const [tag,text] = Renderer.splitFirstSpace(s.slice(1, -1));

                ptrStack._ += `{${tag}${text.length ? " " : ""}`;
                this._getCleanString_walkerStringHandler(ptrStack, tagCount + 1, text);
                ptrStack._ += `}`;
            } else {
                if (tagCount) {
                    ptrStack._ += s;
                } else {
                    ptrStack._ += s.replace(CleanUtil._DASH_COLLAPSE_REGEX, "$1").replace(CleanUtil._ELLIPSIS_COLLAPSE_REGEX, "$1");
                }
            }
        }
    },
};
CleanUtil.SHARED_REPLACEMENTS = {
    "’": "'",
    "‘": "'",
    "": "'",
    "…": "...",
    "\u200B": "",
    "\u2002": " ",
    "ﬀ": "ff",
    "ﬃ": "ffi",
    "ﬄ": "ffl",
    "ﬁ": "fi",
    "ﬂ": "fl",
    "Ĳ": "IJ",
    "ĳ": "ij",
    "Ǉ": "LJ",
    "ǈ": "Lj",
    "ǉ": "lj",
    "Ǌ": "NJ",
    "ǋ": "Nj",
    "ǌ": "nj",
    "ﬅ": "ft",
    "“": `"`,
    "”": `"`,
    "\u201a": ",",
};
CleanUtil.STR_REPLACEMENTS = {
    "—": "\\u2014",
    "–": "\\u2013",
    "‑": "\\u2011",
    "−": "\\u2212",
    " ": "\\u00A0",
    " ": "\\u2007",
};
CleanUtil.SHARED_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.SHARED_REPLACEMENTS).join("|"),"g");
CleanUtil.STR_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.STR_REPLACEMENTS).join("|"),"g");
CleanUtil._SOFT_HYPHEN_REMOVE_REGEX = /\u00AD *\r?\n?\r?/g;
CleanUtil._ELLIPSIS_COLLAPSE_REGEX = /\s*(\.\s*\.\s*\.)/g;
CleanUtil._DASH_COLLAPSE_REGEX = /[ ]*([\u2014\u2013])[ ]*/g;

//#endregion


//#region Extension Functions
String.prototype.toAscii = String.prototype.toAscii || function() {
    return this.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/Æ/g, "AE").replace(/æ/g, "ae");
};
Array.prototype.mergeMap || Object.defineProperty(Array.prototype, "mergeMap", {
    enumerable: false,
    writable: true,
    value: function(fnMap) {
        return this.map((...args)=>fnMap(...args)).filter(it=>it != null).reduce((a,b)=>Object.assign(a, b), {});
    },
});
String.prototype.toUrlified = String.prototype.toUrlified || function() {
    return encodeURIComponent(this.toLowerCase()).toLowerCase();
}
;
String.prototype.qq = String.prototype.qq || function() {
    return this.escapeQuotes();
}
;
String.prototype.escapeQuotes = String.prototype.escapeQuotes || function() {
    return this.replace(/'/g, `&apos;`).replace(/"/g, `&quot;`).replace(/</g, `&lt;`).replace(/>/g, `&gt;`);
}
;
Array.prototype.pSerialAwaitMap || Object.defineProperty(Array.prototype, "pSerialAwaitMap", {
	enumerable: false,
	writable: true,
	value: async function (fnMap) {
		const out = [];
		for (let i = 0, len = this.length; i < len; ++i) out.push(await fnMap(this[i], i, this));
		return out;
	},
});
//#endregion

//#region Jquery Extensions
globalThis.JqueryUtil = {
    _isEnhancementsInit: false,
    initEnhancements() {
        if (JqueryUtil._isEnhancementsInit)
            return;
        JqueryUtil._isEnhancementsInit = true;

        JqueryUtil.addSelectors();

        window.$$ = function(parts, ...args) {
            if (parts instanceof jQuery || parts instanceof HTMLElement) {
                return (...passed)=>{
                    const parts2 = [...passed[0]];
                    const args2 = passed.slice(1);
                    parts2[0] = `<div>${parts2[0]}`;
                    parts2.last(`${parts2.last()}</div>`);

                    const $temp = $$(parts2, ...args2);
                    $temp.children().each((i,e)=>$(e).appendTo(parts));
                    return parts;
                }
                ;
            } else {
                const $eles = [];
                let ixArg = 0;

                const handleArg = (arg)=>{
                    if (arg instanceof $) {
                        $eles.push(arg);
                        return `<${arg.tag()} data-r="true"></${arg.tag()}>`;
                    } else if (arg instanceof HTMLElement) {
                        return handleArg($(arg));
                    } else
                        return arg;
                }
                ;
                const raw = parts.reduce((html,p)=>{
                    const myIxArg = ixArg++;
                    if (args[myIxArg] == null)
                        return `${html}${p}`;
                    if (args[myIxArg]instanceof Array)
                        return `${html}${args[myIxArg].map(arg=>handleArg(arg)).join("")}${p}`;
                    else
                        return `${html}${handleArg(args[myIxArg])}${p}`;
                }
                );
                const $res = $(raw);

                if ($res.length === 1) {
                    if ($res.attr("data-r") === "true")
                        return $eles[0];
                    else
                        $res.find(`[data-r=true]`).replaceWith(i=>$eles[i]);
                } else {
                    const $tmp = $(`<div></div>`);
                    $tmp.append($res);
                    $tmp.find(`[data-r=true]`).replaceWith(i=>$eles[i]);
                    return $tmp.children();
                }

                return $res;
            }
        }
        ;

        $.fn.extend({
            disableSpellcheck: function() {
                return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false");
            },
            tag: function() {
                return this.prop("tagName").toLowerCase();
            },
            title: function(...args) {
                return this.attr("title", ...args);
            },
            placeholder: function(...args) {
                return this.attr("placeholder", ...args);
            },
            disable: function() {
                return this.attr("disabled", true);
            },

            fastSetHtml: function(html) {
                if (!this.length)
                    return this;
                let tgt = this[0];
                while (tgt.children.length) {
                    tgt = tgt.children[0];
                }
                tgt.innerHTML = html;
                return this;
            },

            blurOnEsc: function() {
                return this.keydown(evt=>{
                    if (evt.which === 27)
                        this.blur();
                }
                );
            },

            hideVe: function() {
                return this.addClass("ve-hidden");
            },
            showVe: function() {
                return this.removeClass("ve-hidden");
            },
            toggleVe: function(val) {
                if (val === undefined)
                    return this.toggleClass("ve-hidden", !this.hasClass("ve-hidden"));
                else
                    return this.toggleClass("ve-hidden", !val);
            },
        });

        $.event.special.destroyed = {
            remove: function(o) {
                if (o.handler)
                    o.handler();
            },
        };
    },

    addSelectors() {
        $.expr[":"].textEquals = (el,i,m)=>$(el).text().toLowerCase().trim() === m[3].unescapeQuotes();

        $.expr[":"].containsInsensitive = (el,i,m)=>{
            const searchText = m[3];
            const textNode = $(el).contents().filter((i,e)=>e.nodeType === 3)[0];
            if (!textNode)
                return false;
            const match = textNode.nodeValue.toLowerCase().trim().match(`${searchText.toLowerCase().trim().escapeRegexp()}`);
            return match && match.length > 0;
        }
        ;
    },

    showCopiedEffect(eleOr$Ele, text="Copied!", bubble) {
        const $ele = eleOr$Ele instanceof $ ? eleOr$Ele : $(eleOr$Ele);

        const top = $(window).scrollTop();
        const pos = $ele.offset();

        const animationOptions = {
            top: "-=8",
            opacity: 0,
        };
        if (bubble) {
            animationOptions.left = `${Math.random() > 0.5 ? "-" : "+"}=${~~(Math.random() * 17)}`;
        }
        const seed = Math.random();
        const duration = bubble ? 250 + seed * 200 : 250;
        const offsetY = bubble ? 16 : 0;

        const $dispCopied = $(`<div class="clp__disp-copied ve-flex-vh-center py-2 px-4"></div>`);
        $dispCopied.html(text).css({
            top: (pos.top - 24) + offsetY - top,
            left: pos.left + ($ele.width() / 2),
        }).appendTo(document.body).animate(animationOptions, {
            duration,
            complete: ()=>$dispCopied.remove(),
            progress: (_,progress)=>{
                if (bubble) {
                    const diffProgress = 0.5 - progress;
                    animationOptions.top = `${diffProgress > 0 ? "-" : "+"}=40`;
                    $dispCopied.css("transform", `rotate(${seed > 0.5 ? "-" : ""}${seed * 500 * progress}deg)`);
                }
            }
            ,
        }, );
    },

    _dropdownInit: false,
    bindDropdownButton($ele) {
        if (!JqueryUtil._dropdownInit) {
            JqueryUtil._dropdownInit = true;
            document.addEventListener("click", ()=>[...document.querySelectorAll(`.open`)].filter(ele=>!(ele.className || "").split(" ").includes(`dropdown--navbar`)).forEach(ele=>ele.classList.remove("open")));
        }
        $ele.click(()=>setTimeout(()=>$ele.parent().addClass("open"), 1));
    },

    _WRP_TOAST: null,
    _ACTIVE_TOAST: [],
    doToast(options) {
        if (typeof window === "undefined")
            return;

        if (JqueryUtil._WRP_TOAST == null) {
            JqueryUtil._WRP_TOAST = e_({
                tag: "div",
                clazz: "toast__container no-events w-100 overflow-y-hidden ve-flex-col",
            });
            document.body.appendChild(JqueryUtil._WRP_TOAST);
        }

        if (typeof options === "string") {
            options = {
                content: options,
                type: "info",
            };
        }
        options.type = options.type || "info";

        options.isAutoHide = options.isAutoHide ?? true;
        options.autoHideTime = options.autoHideTime ?? 5000;

        const eleToast = e_({
            tag: "div",
            clazz: `toast toast--type-${options.type} events-initial relative my-2 mx-auto`,
            children: [e_({
                tag: "div",
                clazz: "toast__wrp-content",
                children: [options.content instanceof $ ? options.content[0] : options.content, ],
            }), e_({
                tag: "div",
                clazz: "toast__wrp-control",
                children: [e_({
                    tag: "button",
                    clazz: "btn toast__btn-close",
                    children: [e_({
                        tag: "span",
                        clazz: "glyphicon glyphicon-remove",
                    }), ],
                }), ],
            }), ],
            mousedown: evt=>{
                evt.preventDefault();
            }
            ,
            click: evt=>{
                evt.preventDefault();
                JqueryUtil._doToastCleanup(toastMeta);

                if (!evt.shiftKey)
                    return;
                [...JqueryUtil._ACTIVE_TOAST].forEach(toastMeta=>JqueryUtil._doToastCleanup(toastMeta));
            }
            ,
        });

        eleToast.prependTo(JqueryUtil._WRP_TOAST);

        const toastMeta = {
            isAutoHide: !!options.isAutoHide,
            eleToast
        };
        JqueryUtil._ACTIVE_TOAST.push(toastMeta);

        AnimationUtil.pRecomputeStyles().then(()=>{
            eleToast.addClass(`toast--animate`);

            if (options.isAutoHide) {
                setTimeout(()=>{
                    JqueryUtil._doToastCleanup(toastMeta);
                }
                , options.autoHideTime);
            }

            if (JqueryUtil._ACTIVE_TOAST.length >= 3) {
                JqueryUtil._ACTIVE_TOAST.filter(({isAutoHide})=>!isAutoHide).forEach(toastMeta=>{
                    JqueryUtil._doToastCleanup(toastMeta);
                }
                );
            }
        }
        );
    },

    _doToastCleanup(toastMeta) {
        toastMeta.eleToast.removeClass("toast--animate");
        JqueryUtil._ACTIVE_TOAST.splice(JqueryUtil._ACTIVE_TOAST.indexOf(toastMeta), 1);
        setTimeout(()=>toastMeta.eleToast.parentElement && toastMeta.eleToast.remove(), 85);
    },

    isMobile() {
        if (navigator?.userAgentData?.mobile)
            return true;
        return window.matchMedia("(max-width: 768px)").matches;
    },
};
//#endregion
//#region SourceUtil
globalThis.SourceUtil = {
    ADV_BOOK_GROUPS: [{
        group: "core",
        displayName: "Core"
    }, {
        group: "supplement",
        displayName: "Supplements"
    }, {
        group: "setting",
        displayName: "Settings"
    }, {
        group: "setting-alt",
        displayName: "Additional Settings"
    }, {
        group: "supplement-alt",
        displayName: "Extras"
    }, {
        group: "prerelease",
        displayName: "Prerelease"
    }, {
        group: "homebrew",
        displayName: "Homebrew"
    }, {
        group: "screen",
        displayName: "Screens"
    }, {
        group: "recipe",
        displayName: "Recipes"
    }, {
        group: "other",
        displayName: "Miscellaneous"
    }, ],

    _subclassReprintLookup: {},
    async pInitSubclassReprintLookup() {
        SourceUtil._subclassReprintLookup = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`);
    },

    isSubclassReprinted(className, classSource, subclassShortName, subclassSource) {
        const fromLookup = MiscUtil.get(SourceUtil._subclassReprintLookup, classSource, className, subclassSource, subclassShortName);
        return fromLookup ? fromLookup.isReprinted : false;
    },

    isSiteSource(source) {
        return !!Parser.SOURCE_JSON_TO_FULL[source];
    },

    isAdventure(source) {
        if (source instanceof FilterItem)
            source = source.item;
        return Parser.SOURCES_ADVENTURES.has(source);
    },

    isCoreOrSupplement(source) {
        if (source instanceof FilterItem)
            source = source.item;
        return Parser.SOURCES_CORE_SUPPLEMENTS.has(source);
    },

    isNonstandardSource(source) {
        if (source == null)
            return false;
        return ((typeof BrewUtil2 === "undefined" || !BrewUtil2.hasSourceJson(source)) && SourceUtil.isNonstandardSourceWotc(source)) || SourceUtil.isPrereleaseSource(source);
    },

    isPartneredSourceWotc(source) {
        if (source == null)
            return false;
        return Parser.SOURCES_PARTNERED_WOTC.has(source);
    },

    isPrereleaseSource(source) {
        if (source == null)
            return false;
        if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source))
            return true;
        return source.startsWith(Parser.SRC_UA_PREFIX) || source.startsWith(Parser.SRC_UA_ONE_PREFIX);
    },

    isNonstandardSourceWotc(source) {
        return SourceUtil.isPrereleaseSource(source) || source.startsWith(Parser.SRC_PS_PREFIX) || source.startsWith(Parser.SRC_AL_PREFIX) || source.startsWith(Parser.SRC_MCVX_PREFIX) || Parser.SOURCES_NON_STANDARD_WOTC.has(source);
    },

    FILTER_GROUP_STANDARD: 0,
    FILTER_GROUP_PARTNERED: 1,
    FILTER_GROUP_NON_STANDARD: 2,
    FILTER_GROUP_HOMEBREW: 3,

    getFilterGroup(source) {
        if (source instanceof FilterItem)
            source = source.item;
        if ((typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) || SourceUtil.isNonstandardSource(source))
            return SourceUtil.FILTER_GROUP_NON_STANDARD;
        if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source))
            return SourceUtil.FILTER_GROUP_HOMEBREW;
        if (SourceUtil.isPartneredSourceWotc(source))
            return SourceUtil.FILTER_GROUP_PARTNERED;
        return SourceUtil.FILTER_GROUP_STANDARD;
    },

    getAdventureBookSourceHref(source, page) {
        if (!source)
            return null;
        source = source.toLowerCase();

        let docPage, mappedSource;
        if (Parser.SOURCES_AVAILABLE_DOCS_BOOK[source]) {
            docPage = UrlUtil.PG_BOOK;
            mappedSource = Parser.SOURCES_AVAILABLE_DOCS_BOOK[source];
        } else if (Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source]) {
            docPage = UrlUtil.PG_ADVENTURE;
            mappedSource = Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source];
        }
        if (!docPage)
            return null;

        mappedSource = mappedSource.toLowerCase();

        return `${docPage}#${[mappedSource, page ? `page:${page}` : null].filter(Boolean).join(HASH_PART_SEP)}`;
    },

    getEntitySource(it) {
        return it.source || it.inherits?.source;
    },
};
//#endregion
//#region MiscUtil
globalThis.MiscUtil = {
    COLOR_HEALTHY: "#00bb20",
    COLOR_HURT: "#c5ca00",
    COLOR_BLOODIED: "#f7a100",
    COLOR_DEFEATED: "#cc0000",

    copy(obj, {isSafe=false, isPreserveUndefinedValueKeys=false}={}) {
        if (isSafe && obj === undefined)
            return undefined;
        return JSON.parse(JSON.stringify(obj));
    },

    copyFast(obj) {
        if ((typeof obj !== "object") || obj == null)
            return obj;

        if (obj instanceof Array)
            return obj.map(MiscUtil.copyFast);

        const cpy = {};
        for (const k of Object.keys(obj))
            cpy[k] = MiscUtil.copyFast(obj[k]);
        return cpy;
    },

    async pCopyTextToClipboard(text) {
        function doCompatibilityCopy() {
            const $iptTemp = $(`<textarea class="clp__wrp-temp"></textarea>`).appendTo(document.body).val(text).select();
            document.execCommand("Copy");
            $iptTemp.remove();
        }

        if (navigator && navigator.permissions) {
            try {
                const access = await navigator.permissions.query({
                    name: "clipboard-write"
                });
                if (access.state === "granted" || access.state === "prompt") {
                    await navigator.clipboard.writeText(text);
                } else
                    doCompatibilityCopy();
            } catch (e) {
                doCompatibilityCopy();
            }
        } else
            doCompatibilityCopy();
    },

    checkProperty(object, ...path) {
        for (let i = 0; i < path.length; ++i) {
            object = object[path[i]];
            if (object == null)
                return false;
        }
        return true;
    },

    get(object, ...path) {
        if (object == null)
            return null;
        for (let i = 0; i < path.length; ++i) {
            object = object[path[i]];
            if (object == null)
                return object;
        }
        return object;
    },

    set(object, ...pathAndVal) {
        if (object == null)
            return null;

        const val = pathAndVal.pop();
        if (!pathAndVal.length)
            return null;

        const len = pathAndVal.length;
        for (let i = 0; i < len; ++i) {
            const pathPart = pathAndVal[i];
            if (i === len - 1)
                object[pathPart] = val;
            else
                object = (object[pathPart] = object[pathPart] || {});
        }

        return val;
    },

    getOrSet(object, ...pathAndVal) {
        if (pathAndVal.length < 2)
            return null;
        const existing = MiscUtil.get(object, ...pathAndVal.slice(0, -1));
        if (existing != null)
            return existing;
        return MiscUtil.set(object, ...pathAndVal);
    },

    getThenSetCopy(object1, object2, ...path) {
        const val = MiscUtil.get(object1, ...path);
        return MiscUtil.set(object2, ...path, MiscUtil.copyFast(val, {
            isSafe: true
        }));
    },

    delete(object, ...path) {
        if (object == null)
            return object;
        for (let i = 0; i < path.length - 1; ++i) {
            object = object[path[i]];
            if (object == null)
                return object;
        }
        return delete object[path.last()];
    },

    deleteObjectPath(object, ...path) {
        const stack = [object];

        if (object == null)
            return object;
        for (let i = 0; i < path.length - 1; ++i) {
            object = object[path[i]];
            stack.push(object);
            if (object === undefined)
                return object;
        }
        const out = delete object[path.last()];

        for (let i = path.length - 1; i > 0; --i) {
            if (!Object.keys(stack[i]).length)
                delete stack[i - 1][path[i - 1]];
        }

        return out;
    },

    merge(obj1, obj2) {
        obj2 = MiscUtil.copyFast(obj2);

        Object.entries(obj2).forEach(([k,v])=>{
            if (obj1[k] == null) {
                obj1[k] = v;
                return;
            }

            if (typeof obj1[k] === "object" && typeof v === "object" && !(obj1[k]instanceof Array) && !(v instanceof Array)) {
                MiscUtil.merge(obj1[k], v);
                return;
            }

            obj1[k] = v;
        }
        );

        return obj1;
    },

    mix: (superclass)=>new MiscUtil._MixinBuilder(superclass),
    _MixinBuilder: function(superclass) {
        this.superclass = superclass;

        this.with = function(...mixins) {
            return mixins.reduce((c,mixin)=>mixin(c), this.superclass);
        }
        ;
    },

    clearSelection() {
        if (document.getSelection) {
            document.getSelection().removeAllRanges();
            document.getSelection().addRange(document.createRange());
        } else if (window.getSelection) {
            if (window.getSelection().removeAllRanges) {
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(document.createRange());
            } else if (window.getSelection().empty) {
                window.getSelection().empty();
            }
        } else if (document.selection) {
            document.selection.empty();
        }
    },

    randomColor() {
        let r;
        let g;
        let b;
        const h = RollerUtil.randomise(30, 0) / 30;
        const i = ~~(h * 6);
        const f = h * 6 - i;
        const q = 1 - f;
        switch (i % 6) {
        case 0:
            r = 1;
            g = f;
            b = 0;
            break;
        case 1:
            r = q;
            g = 1;
            b = 0;
            break;
        case 2:
            r = 0;
            g = 1;
            b = f;
            break;
        case 3:
            r = 0;
            g = q;
            b = 1;
            break;
        case 4:
            r = f;
            g = 0;
            b = 1;
            break;
        case 5:
            r = 1;
            g = 0;
            b = q;
            break;
        }
        return `#${`00${(~~(r * 255)).toString(16)}`.slice(-2)}${`00${(~~(g * 255)).toString(16)}`.slice(-2)}${`00${(~~(b * 255)).toString(16)}`.slice(-2)}`;
    },

    invertColor(hex, opts) {
        opts = opts || {};

        hex = hex.slice(1);
        let r = parseInt(hex.slice(0, 2), 16);
        let g = parseInt(hex.slice(2, 4), 16);
        let b = parseInt(hex.slice(4, 6), 16);

        const isDark = (r * 0.299 + g * 0.587 + b * 0.114) > 186;
        if (opts.dark && opts.light)
            return isDark ? opts.dark : opts.light;
        else if (opts.bw)
            return isDark ? "#000000" : "#FFFFFF";

        r = (255 - r).toString(16);
        g = (255 - g).toString(16);
        b = (255 - b).toString(16);
        return `#${[r, g, b].map(it=>it.padStart(2, "0")).join("")}`;
    },

    scrollPageTop() {
        document.body.scrollTop = document.documentElement.scrollTop = 0;
    },

    expEval(str) {
        return new Function(`return ${str.replace(/[^-()\d/*+.]/g, "")}`)();
    },

    parseNumberRange(input, min=Number.MIN_SAFE_INTEGER, max=Number.MAX_SAFE_INTEGER) {
        if (!input || !input.trim())
            return null;

        const errInvalid = input=>{
            throw new Error(`Could not parse range input "${input}"`);
        }
        ;

        const errOutOfRange = ()=>{
            throw new Error(`Number was out of range! Range was ${min}-${max} (inclusive).`);
        }
        ;

        const isOutOfRange = (num)=>num < min || num > max;

        const addToRangeVal = (range,num)=>range.add(num);

        const addToRangeLoHi = (range,lo,hi)=>{
            for (let i = lo; i <= hi; ++i)
                range.add(i);
        }
        ;

        const clean = input.replace(/\s*/g, "");
        if (!/^((\d+-\d+|\d+),)*(\d+-\d+|\d+)$/.exec(clean))
            errInvalid();

        const parts = clean.split(",");
        const out = new Set();

        for (const part of parts) {
            if (part.includes("-")) {
                const spl = part.split("-");
                const numLo = Number(spl[0]);
                const numHi = Number(spl[1]);

                if (isNaN(numLo) || isNaN(numHi) || numLo === 0 || numHi === 0 || numLo > numHi)
                    errInvalid();

                if (isOutOfRange(numLo) || isOutOfRange(numHi))
                    errOutOfRange();

                if (numLo === numHi)
                    addToRangeVal(out, numLo);
                else
                    addToRangeLoHi(out, numLo, numHi);
                continue;
            }

            const num = Number(part);
            if (isNaN(num) || num === 0)
                errInvalid();

            if (isOutOfRange(num))
                errOutOfRange();
            addToRangeVal(out, num);
        }

        return out;
    },

    findCommonPrefix(strArr, {isRespectWordBoundaries}={}) {
        if (isRespectWordBoundaries) {
            return MiscUtil._findCommonPrefixSuffixWords({
                strArr
            });
        }

        let prefix = null;
        strArr.forEach(s=>{
            if (prefix == null) {
                prefix = s;
                return;
            }

            const minLen = Math.min(s.length, prefix.length);
            for (let i = 0; i < minLen; ++i) {
                const cp = prefix[i];
                const cs = s[i];
                if (cp !== cs) {
                    prefix = prefix.substring(0, i);
                    break;
                }
            }
        }
        );
        return prefix;
    },

    findCommonSuffix(strArr, {isRespectWordBoundaries}={}) {
        if (!isRespectWordBoundaries)
            throw new Error(`Unimplemented!`);

        return MiscUtil._findCommonPrefixSuffixWords({
            strArr,
            isSuffix: true
        });
    },

    _findCommonPrefixSuffixWords({strArr, isSuffix}) {
        let prefixTks = null;
        let lenMax = -1;

        strArr.map(str=>{
            lenMax = Math.max(lenMax, str.length);
            return str.split(" ");
        }
        ).forEach(tks=>{
            if (isSuffix)
                tks.reverse();

            if (prefixTks == null)
                return prefixTks = [...tks];

            const minLen = Math.min(tks.length, prefixTks.length);
            while (prefixTks.length > minLen)
                prefixTks.pop();

            for (let i = 0; i < minLen; ++i) {
                const cp = prefixTks[i];
                const cs = tks[i];
                if (cp !== cs) {
                    prefixTks = prefixTks.slice(0, i);
                    break;
                }
            }
        }
        );

        if (isSuffix)
            prefixTks.reverse();

        if (!prefixTks.length)
            return "";

        const out = prefixTks.join(" ");
        if (out.length === lenMax)
            return out;

        return isSuffix ? ` ${prefixTks.join(" ")}` : `${prefixTks.join(" ")} `;
    },

    calculateBlendedColor(fgHexTarget, fgOpacity, bgHex) {
        const fgDcTarget = CryptUtil.hex2Dec(fgHexTarget);
        const bgDc = CryptUtil.hex2Dec(bgHex);
        return ((fgDcTarget - ((1 - fgOpacity) * bgDc)) / fgOpacity).toString(16);
    },

    debounce(func, wait, options) {
        let lastArgs;
        let lastThis;
        let maxWait;
        let result;
        let timerId;
        let lastCallTime;
        let lastInvokeTime = 0;
        let leading = false;
        let maxing = false;
        let trailing = true;

        wait = Number(wait) || 0;
        if (typeof options === "object") {
            leading = !!options.leading;
            maxing = "maxWait"in options;
            maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing"in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
            let args = lastArgs;
            let thisArg = lastThis;

            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
        }

        function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
            let timeSinceLastCall = time - lastCallTime;
            let timeSinceLastInvoke = time - lastInvokeTime;
            let result = wait - timeSinceLastCall;
            return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result;
        }

        function shouldInvoke(time) {
            let timeSinceLastCall = time - lastCallTime;
            let timeSinceLastInvoke = time - lastInvokeTime;

            return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
        }

        function timerExpired() {
            const time = Date.now();
            if (shouldInvoke(time)) {
                return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
            timerId = undefined;

            if (trailing && lastArgs)
                return invokeFunc(time);
            lastArgs = lastThis = undefined;
            return result;
        }

        function cancel() {
            if (timerId !== undefined)
                clearTimeout(timerId);
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
            return timerId === undefined ? result : trailingEdge(Date.now());
        }

        function debounced() {
            let time = Date.now();
            let isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;

            if (isInvoking) {
                if (timerId === undefined)
                    return leadingEdge(lastCallTime);
                if (maxing) {
                    timerId = setTimeout(timerExpired, wait);
                    return invokeFunc(lastCallTime);
                }
            }
            if (timerId === undefined)
                timerId = setTimeout(timerExpired, wait);
            return result;
        }

        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
    },

    throttle(func, wait, options) {
        let leading = true;
        let trailing = true;

        if (typeof options === "object") {
            leading = "leading"in options ? !!options.leading : leading;
            trailing = "trailing"in options ? !!options.trailing : trailing;
        }

        return this.debounce(func, wait, {
            leading,
            maxWait: wait,
            trailing
        });
    },

    pDelay(msecs, resolveAs) {
        return new Promise(resolve=>setTimeout(()=>resolve(resolveAs), msecs));
    },

    GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST: new Set(["caption", "type", "colLabels", "colLabelGroups", "name", "colStyles", "style", "shortName", "subclassShortName", "id", "path"]),

    getWalker(opts) {
        opts = opts || {};

        if (opts.isBreakOnReturn && !opts.isNoModification)
            throw new Error(`"isBreakOnReturn" may only be used in "isNoModification" mode!`);

        const keyBlocklist = opts.keyBlocklist || new Set();

        const getMappedPrimitive = (obj,primitiveHandlers,lastKey,stack,prop,propPre,propPost)=>{
            if (primitiveHandlers[propPre])
                MiscUtil._getWalker_runHandlers({
                    handlers: primitiveHandlers[propPre],
                    obj,
                    lastKey,
                    stack
                });
            if (primitiveHandlers[prop]) {
                const out = MiscUtil._getWalker_applyHandlers({
                    opts,
                    handlers: primitiveHandlers[prop],
                    obj,
                    lastKey,
                    stack
                });
                if (out === VeCt.SYM_WALKER_BREAK)
                    return out;
                if (!opts.isNoModification)
                    obj = out;
            }
            if (primitiveHandlers[propPost])
                MiscUtil._getWalker_runHandlers({
                    handlers: primitiveHandlers[propPost],
                    obj,
                    lastKey,
                    stack
                });
            return obj;
        }
        ;

        const doObjectRecurse = (obj,primitiveHandlers,stack)=>{
            for (const k of Object.keys(obj)) {
                if (keyBlocklist.has(k))
                    continue;

                const out = fn(obj[k], primitiveHandlers, k, stack);
                if (out === VeCt.SYM_WALKER_BREAK)
                    return VeCt.SYM_WALKER_BREAK;
                if (!opts.isNoModification)
                    obj[k] = out;
            }
        }
        ;

        const fn = (obj,primitiveHandlers,lastKey,stack)=>{
            if (obj === null)
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "null", "preNull", "postNull");

            switch (typeof obj) {
            case "undefined":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "undefined", "preUndefined", "postUndefined");
            case "boolean":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "boolean", "preBoolean", "postBoolean");
            case "number":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "number", "preNumber", "postNumber");
            case "string":
                return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "string", "preString", "postString");
            case "object":
                {
                    if (obj instanceof Array) {
                        if (primitiveHandlers.preArray)
                            MiscUtil._getWalker_runHandlers({
                                handlers: primitiveHandlers.preArray,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            const out = new Array(obj.length);
                            for (let i = 0, len = out.length; i < len; ++i) {
                                out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
                                if (out[i] === VeCt.SYM_WALKER_BREAK)
                                    return out[i];
                            }
                            if (!opts.isNoModification)
                                obj = out;
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.array) {
                                const out = MiscUtil._getWalker_applyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (out === VeCt.SYM_WALKER_BREAK)
                                    return out;
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.array) {
                                const out = MiscUtil._getWalker_applyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (out === VeCt.SYM_WALKER_BREAK)
                                    return out;
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj != null) {
                                const out = new Array(obj.length);
                                for (let i = 0, len = out.length; i < len; ++i) {
                                    if (stack)
                                        stack.push(obj);
                                    out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
                                    if (stack)
                                        stack.pop();
                                    if (out[i] === VeCt.SYM_WALKER_BREAK)
                                        return out[i];
                                }
                                if (!opts.isNoModification)
                                    obj = out;
                            } else {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        }
                        if (primitiveHandlers.postArray)
                            MiscUtil._getWalker_runHandlers({
                                handlers: primitiveHandlers.postArray,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    }

                    if (primitiveHandlers.preObject)
                        MiscUtil._getWalker_runHandlers({
                            handlers: primitiveHandlers.preObject,
                            obj,
                            lastKey,
                            stack
                        });
                    if (opts.isDepthFirst) {
                        if (stack)
                            stack.push(obj);
                        const flag = doObjectRecurse(obj, primitiveHandlers, stack);
                        if (stack)
                            stack.pop();
                        if (flag === VeCt.SYM_WALKER_BREAK)
                            return flag;

                        if (primitiveHandlers.object) {
                            const out = MiscUtil._getWalker_applyHandlers({
                                opts,
                                handlers: primitiveHandlers.object,
                                obj,
                                lastKey,
                                stack
                            });
                            if (out === VeCt.SYM_WALKER_BREAK)
                                return out;
                            if (!opts.isNoModification)
                                obj = out;
                        }
                        if (obj == null) {
                            if (!opts.isAllowDeleteObjects)
                                throw new Error(`Object handler(s) returned null!`);
                        }
                    } else {
                        if (primitiveHandlers.object) {
                            const out = MiscUtil._getWalker_applyHandlers({
                                opts,
                                handlers: primitiveHandlers.object,
                                obj,
                                lastKey,
                                stack
                            });
                            if (out === VeCt.SYM_WALKER_BREAK)
                                return out;
                            if (!opts.isNoModification)
                                obj = out;
                        }
                        if (obj == null) {
                            if (!opts.isAllowDeleteObjects)
                                throw new Error(`Object handler(s) returned null!`);
                        } else {
                            if (stack)
                                stack.push(obj);
                            const flag = doObjectRecurse(obj, primitiveHandlers, stack);
                            if (stack)
                                stack.pop();
                            if (flag === VeCt.SYM_WALKER_BREAK)
                                return flag;
                        }
                    }
                    if (primitiveHandlers.postObject)
                        MiscUtil._getWalker_runHandlers({
                            handlers: primitiveHandlers.postObject,
                            obj,
                            lastKey,
                            stack
                        });
                    return obj;
                }
            default:
                throw new Error(`Unhandled type "${typeof obj}"`);
            }
        }
        ;

        return {
            walk: fn
        };
    },

    _getWalker_applyHandlers({opts, handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        const didBreak = handlers.some(h=>{
            const out = h(obj, lastKey, stack);
            if (opts.isBreakOnReturn && out)
                return true;
            if (!opts.isNoModification)
                obj = out;
        }
        );
        if (didBreak)
            return VeCt.SYM_WALKER_BREAK;
        return obj;
    },

    _getWalker_runHandlers({handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        handlers.forEach(h=>h(obj, lastKey, stack));
    },

    getAsyncWalker(opts) {
        opts = opts || {};
        const keyBlocklist = opts.keyBlocklist || new Set();

        const pFn = async(obj,primitiveHandlers,lastKey,stack)=>{
            if (obj == null) {
                if (primitiveHandlers.null)
                    return MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.null,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            }

            const pDoObjectRecurse = async()=>{
                await Object.keys(obj).pSerialAwaitMap(async k=>{
                    const v = obj[k];
                    if (keyBlocklist.has(k))
                        return;
                    const out = await pFn(v, primitiveHandlers, k, stack);
                    if (!opts.isNoModification)
                        obj[k] = out;
                }
                );
            }
            ;

            const to = typeof obj;
            switch (to) {
            case undefined:
                if (primitiveHandlers.preUndefined)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preUndefined,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.undefined) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.undefined,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postUndefined)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postUndefined,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "boolean":
                if (primitiveHandlers.preBoolean)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preBoolean,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.boolean) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.boolean,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postBoolean)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postBoolean,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "number":
                if (primitiveHandlers.preNumber)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preNumber,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.number) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.number,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postNumber)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postNumber,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "string":
                if (primitiveHandlers.preString)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.preString,
                        obj,
                        lastKey,
                        stack
                    });
                if (primitiveHandlers.string) {
                    const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                        opts,
                        handlers: primitiveHandlers.string,
                        obj,
                        lastKey,
                        stack
                    });
                    if (!opts.isNoModification)
                        obj = out;
                }
                if (primitiveHandlers.postString)
                    await MiscUtil._getAsyncWalker_pRunHandlers({
                        handlers: primitiveHandlers.postString,
                        obj,
                        lastKey,
                        stack
                    });
                return obj;
            case "object":
                {
                    if (obj instanceof Array) {
                        if (primitiveHandlers.preArray)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.preArray,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            const out = await obj.pSerialAwaitMap(it=>pFn(it, primitiveHandlers, lastKey, stack));
                            if (!opts.isNoModification)
                                obj = out;
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.array) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.array) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.array,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj != null) {
                                const out = await obj.pSerialAwaitMap(it=>pFn(it, primitiveHandlers, lastKey, stack));
                                if (!opts.isNoModification)
                                    obj = out;
                            } else {
                                if (!opts.isAllowDeleteArrays)
                                    throw new Error(`Array handler(s) returned null!`);
                            }
                        }
                        if (primitiveHandlers.postArray)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.postArray,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    } else {
                        if (primitiveHandlers.preObject)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.preObject,
                                obj,
                                lastKey,
                                stack
                            });
                        if (opts.isDepthFirst) {
                            if (stack)
                                stack.push(obj);
                            await pDoObjectRecurse();
                            if (stack)
                                stack.pop();

                            if (primitiveHandlers.object) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.object,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteObjects)
                                    throw new Error(`Object handler(s) returned null!`);
                            }
                        } else {
                            if (primitiveHandlers.object) {
                                const out = await MiscUtil._getAsyncWalker_pApplyHandlers({
                                    opts,
                                    handlers: primitiveHandlers.object,
                                    obj,
                                    lastKey,
                                    stack
                                });
                                if (!opts.isNoModification)
                                    obj = out;
                            }
                            if (obj == null) {
                                if (!opts.isAllowDeleteObjects)
                                    throw new Error(`Object handler(s) returned null!`);
                            } else {
                                await pDoObjectRecurse();
                            }
                        }
                        if (primitiveHandlers.postObject)
                            await MiscUtil._getAsyncWalker_pRunHandlers({
                                handlers: primitiveHandlers.postObject,
                                obj,
                                lastKey,
                                stack
                            });
                        return obj;
                    }
                }
            default:
                throw new Error(`Unhandled type "${to}"`);
            }
        }
        ;

        return {
            pWalk: pFn
        };
    },

    async _getAsyncWalker_pApplyHandlers({opts, handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        await handlers.pSerialAwaitMap(async pH=>{
            const out = await pH(obj, lastKey, stack);
            if (!opts.isNoModification)
                obj = out;
        }
        );
        return obj;
    },

    async _getAsyncWalker_pRunHandlers({handlers, obj, lastKey, stack}) {
        handlers = handlers instanceof Array ? handlers : [handlers];
        await handlers.pSerialAwaitMap(pH=>pH(obj, lastKey, stack));
    },

    pDefer(fn) {
        return (async()=>fn())();
    },
};
//#endregion
//#region UrlUtil
globalThis.UrlUtil = {
    encodeForHash(toEncode) {
        if (toEncode instanceof Array)
            return toEncode.map(it=>`${it}`.toUrlified()).join(HASH_LIST_SEP);
        else
            return `${toEncode}`.toUrlified();
    },

    encodeArrayForHash(...toEncodes) {
        return toEncodes.map(UrlUtil.encodeForHash).join(HASH_LIST_SEP);
    },

    autoEncodeHash(obj) {
        const curPage = UrlUtil.getCurrentPage();
        const encoder = UrlUtil.URL_TO_HASH_BUILDER[curPage];
        if (!encoder)
            throw new Error(`No encoder found for page ${curPage}`);
        return encoder(obj);
    },

    decodeHash(hash) {
        return hash.split(HASH_LIST_SEP).map(it=>decodeURIComponent(it));
    },

    getSluggedHash(hash) {
        return Parser.stringToSlug(decodeURIComponent(hash)).replace(/_/g, "-");
    },

    getCurrentPage() {
        if (typeof window === "undefined")
            return VeCt.PG_NONE;
        const pSplit = window.location.pathname.split("/");
        let out = pSplit[pSplit.length - 1];
        if (!out.toLowerCase().endsWith(".html"))
            out += ".html";
        return out;
    },

    link(href, {isBustCache=false}={}) {
        if (isBustCache)
            return UrlUtil._link_getWithParam(href, {
                param: `t=${Date.now()}`
            });
        return href;
    },

    _link_getWithParam(href, {param=`v=${VERSION_NUMBER}`}={}) {
        if (href.includes("?"))
            return `${href}&${param}`;
        return `${href}?${param}`;
    },

    unpackSubHash(subHash, unencode) {
        if (subHash.includes(HASH_SUB_KV_SEP)) {
            const keyValArr = subHash.split(HASH_SUB_KV_SEP).map(s=>s.trim());
            const out = {};
            let k = keyValArr[0].toLowerCase();
            if (unencode)
                k = decodeURIComponent(k);
            let v = keyValArr[1].toLowerCase();
            if (unencode)
                v = decodeURIComponent(v);
            out[k] = v.split(HASH_SUB_LIST_SEP).map(s=>s.trim());
            if (out[k].length === 1 && out[k] === HASH_SUB_NONE)
                out[k] = [];
            return out;
        } else {
            throw new Error(`Badly formatted subhash ${subHash}`);
        }
    },

    packSubHash(key, values, opts) {
        opts = opts || {};
        if (opts.isEncodeBoth || opts.isEncodeKey)
            key = key.toUrlified();
        if (opts.isEncodeBoth || opts.isEncodeValues)
            values = values.map(it=>it.toUrlified());
        return `${key}${HASH_SUB_KV_SEP}${values.join(HASH_SUB_LIST_SEP)}`;
    },

    categoryToPage(category) {
        return UrlUtil.CAT_TO_PAGE[category];
    },
    categoryToHoverPage(category) {
        return UrlUtil.CAT_TO_HOVER_PAGE[category] || UrlUtil.categoryToPage(category);
    },

    pageToDisplayPage(page) {
        return UrlUtil.PG_TO_NAME[page] || page;
    },

    getFilename(url) {
        return url.slice(url.lastIndexOf("/") + 1);
    },

    isFullUrl(url) {
        return url && /^.*?:\/\//.test(url);
    },

    mini: {
        compress(primitive) {
            const type = typeof primitive;
            if (primitive === undefined)
                return "u";
            if (primitive === null)
                return "x";
            switch (type) {
            case "boolean":
                return `b${Number(primitive)}`;
            case "number":
                return `n${primitive}`;
            case "string":
                return `s${primitive.toUrlified()}`;
            default:
                throw new Error(`Unhandled type "${type}"`);
            }
        },

        decompress(raw) {
            const [type,data] = [raw.slice(0, 1), raw.slice(1)];
            switch (type) {
            case "u":
                return undefined;
            case "x":
                return null;
            case "b":
                return !!Number(data);
            case "n":
                return Number(data);
            case "s":
                return decodeURIComponent(String(data));
            default:
                throw new Error(`Unhandled type "${type}"`);
            }
        },
    },

    class: {
        getIndexedClassEntries(cls) {
            const out = [];

            (cls.classFeatures || []).forEach((lvlFeatureList,ixLvl)=>{
                lvlFeatureList.filter(feature=>(!feature.gainSubclassFeature || feature.gainSubclassFeatureHasContent) && feature.name !== "Ability Score Improvement" && feature.name !== "Proficiency Versatility").forEach((feature,ixFeature)=>{
                    const name = Renderer.findName(feature);
                    if (!name) {
                        if (BrewUtil2.hasSourceJson(cls.source))
                            return;
                        else
                            throw new Error("Class feature had no name!");
                    }
                    out.push({
                        _type: "classFeature",
                        source: cls.source.source || cls.source,
                        name,
                        hash: `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](cls)}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                            feature: {
                                ixLevel: ixLvl,
                                ixFeature: ixFeature
                            }
                        })}`,
                        entry: feature,
                        level: ixLvl + 1,
                    });
                }
                );
            }
            );

            return out;
        },

        getIndexedSubclassEntries(sc) {
            const out = [];

            const lvlFeatures = sc.subclassFeatures || [];
            sc.source = sc.source || sc.classSource;
            lvlFeatures.forEach(lvlFeature=>{
                lvlFeature.forEach((feature,ixFeature)=>{
                    const subclassFeatureHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
                        name: sc.className,
                        source: sc.classSource
                    })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                        subclass: sc,
                        feature: {
                            ixLevel: feature.level - 1,
                            ixFeature: ixFeature
                        }
                    })}`;

                    const name = Renderer.findName(feature);
                    if (!name) {
                        if (BrewUtil2.hasSourceJson(sc.source))
                            return;
                        else
                            throw new Error("Subclass feature had no name!");
                    }
                    out.push({
                        _type: "subclassFeature",
                        name,
                        subclassName: sc.name,
                        subclassShortName: sc.shortName,
                        source: sc.source.source || sc.source,
                        hash: subclassFeatureHash,
                        entry: feature,
                        level: feature.level,
                    });

                    if (feature.entries) {
                        const namedFeatureParts = feature.entries.filter(it=>it.name);
                        namedFeatureParts.forEach(it=>{
                            if (out.find(existing=>it.name === existing.name && feature.level === existing.level))
                                return;
                            out.push({
                                _type: "subclassFeaturePart",
                                name: it.name,
                                subclassName: sc.name,
                                subclassShortName: sc.shortName,
                                source: sc.source.source || sc.source,
                                hash: subclassFeatureHash,
                                entry: feature,
                                level: feature.level,
                            });
                        }
                        );
                    }
                }
                );
            }
            );

            return out;
        },
    },

    getStateKeySubclass(sc) {
        return Parser.stringToSlug(`sub ${sc.shortName || sc.name} ${sc.source}`);
    },

    getClassesPageStatePart(opts) {
        if (!opts.subclass && !opts.feature)
            return "";

        if (!opts.feature)
            return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_subclass(opts.subclass)]);
        if (!opts.subclass)
            return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_feature(opts.feature)]);

        return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_subclass(opts.subclass), UrlUtil._getClassesPageStatePart_feature(opts.feature), ], );
    },

    _getClassesPageStatePart_subclass(sc) {
        return `${UrlUtil.getStateKeySubclass(sc)}=${UrlUtil.mini.compress(true)}`;
    },
    _getClassesPageStatePart_feature(feature) {
        return `feature=${UrlUtil.mini.compress(`${feature.ixLevel}-${feature.ixFeature}`)}`;
    },
};

UrlUtil.PG_BESTIARY = "bestiary.html";
UrlUtil.PG_SPELLS = "spells.html";
UrlUtil.PG_BACKGROUNDS = "backgrounds.html";
UrlUtil.PG_ITEMS = "items.html";
UrlUtil.PG_CLASSES = "classes.html";
UrlUtil.PG_CONDITIONS_DISEASES = "conditionsdiseases.html";
UrlUtil.PG_FEATS = "feats.html";
UrlUtil.PG_OPT_FEATURES = "optionalfeatures.html";
UrlUtil.PG_PSIONICS = "psionics.html";
UrlUtil.PG_RACES = "races.html";
UrlUtil.PG_REWARDS = "rewards.html";
UrlUtil.PG_VARIANTRULES = "variantrules.html";
UrlUtil.PG_ADVENTURE = "adventure.html";
UrlUtil.PG_ADVENTURES = "adventures.html";
UrlUtil.PG_BOOK = "book.html";
UrlUtil.PG_BOOKS = "books.html";
UrlUtil.PG_DEITIES = "deities.html";
UrlUtil.PG_CULTS_BOONS = "cultsboons.html";
UrlUtil.PG_OBJECTS = "objects.html";
UrlUtil.PG_TRAPS_HAZARDS = "trapshazards.html";
UrlUtil.PG_QUICKREF = "quickreference.html";
UrlUtil.PG_MANAGE_BREW = "managebrew.html";
UrlUtil.PG_MANAGE_PRERELEASE = "manageprerelease.html";
UrlUtil.PG_MAKE_BREW = "makebrew.html";
UrlUtil.PG_DEMO_RENDER = "renderdemo.html";
UrlUtil.PG_TABLES = "tables.html";
UrlUtil.PG_VEHICLES = "vehicles.html";
UrlUtil.PG_CHARACTERS = "characters.html";
UrlUtil.PG_ACTIONS = "actions.html";
UrlUtil.PG_LANGUAGES = "languages.html";
UrlUtil.PG_STATGEN = "statgen.html";
UrlUtil.PG_LIFEGEN = "lifegen.html";
UrlUtil.PG_NAMES = "names.html";
UrlUtil.PG_DM_SCREEN = "dmscreen.html";
UrlUtil.PG_CR_CALCULATOR = "crcalculator.html";
UrlUtil.PG_ENCOUNTERGEN = "encountergen.html";
UrlUtil.PG_LOOTGEN = "lootgen.html";
UrlUtil.PG_TEXT_CONVERTER = "converter.html";
UrlUtil.PG_CHANGELOG = "changelog.html";
UrlUtil.PG_CHAR_CREATION_OPTIONS = "charcreationoptions.html";
UrlUtil.PG_RECIPES = "recipes.html";
UrlUtil.PG_CLASS_SUBCLASS_FEATURES = "classfeatures.html";
UrlUtil.PG_CREATURE_FEATURES = "creaturefeatures.html";
UrlUtil.PG_VEHICLE_FEATURES = "vehiclefeatures.html";
UrlUtil.PG_OBJECT_FEATURES = "objectfeatures.html";
UrlUtil.PG_TRAP_FEATURES = "trapfeatures.html";
UrlUtil.PG_MAPS = "maps.html";
UrlUtil.PG_SEARCH = "search.html";
UrlUtil.PG_DECKS = "decks.html";

UrlUtil.URL_TO_HASH_GENERIC = (it)=>UrlUtil.encodeArrayForHash(it.name, it.source);

UrlUtil.URL_TO_HASH_BUILDER = {};
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE] = (it)=>UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK] = (it)=>UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.pantheon, it.source);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES] = (it)=>`${UrlUtil.encodeArrayForHash(it.name, it.source)}${it._scaleFactor ? `${HASH_PART_SEP}${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}${it._scaleFactor}` : ""}`;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASS_SUBCLASS_FEATURES] = (it)=>(it.__prop === "subclassFeature" || it.subclassSource) ? UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](it) : UrlUtil.URL_TO_HASH_BUILDER["classFeature"](it);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CREATURE_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLE_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECT_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAP_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_QUICKREF] = ({name, ixChapter, ixHeader})=>{
    const hashParts = ["bookref-quick", ixChapter, UrlUtil.encodeForHash(name.toLowerCase())];
    if (ixHeader)
        hashParts.push(ixHeader);
    return hashParts.join(HASH_PART_SEP);
}
;

UrlUtil.URL_TO_HASH_BUILDER["monster"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY];
UrlUtil.URL_TO_HASH_BUILDER["spell"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS];
UrlUtil.URL_TO_HASH_BUILDER["background"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS];
UrlUtil.URL_TO_HASH_BUILDER["item"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["itemGroup"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["baseitem"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["magicvariant"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["class"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES];
UrlUtil.URL_TO_HASH_BUILDER["condition"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["disease"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["status"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["feat"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS];
UrlUtil.URL_TO_HASH_BUILDER["optionalfeature"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES];
UrlUtil.URL_TO_HASH_BUILDER["psionic"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS];
UrlUtil.URL_TO_HASH_BUILDER["race"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES];
UrlUtil.URL_TO_HASH_BUILDER["subrace"] = (it)=>UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES]({
    name: `${it.name} (${it.raceName})`,
    source: it.source
});
UrlUtil.URL_TO_HASH_BUILDER["reward"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS];
UrlUtil.URL_TO_HASH_BUILDER["variantrule"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES];
UrlUtil.URL_TO_HASH_BUILDER["adventure"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES];
UrlUtil.URL_TO_HASH_BUILDER["adventureData"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES];
UrlUtil.URL_TO_HASH_BUILDER["book"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS];
UrlUtil.URL_TO_HASH_BUILDER["bookData"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS];
UrlUtil.URL_TO_HASH_BUILDER["deity"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES];
UrlUtil.URL_TO_HASH_BUILDER["cult"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS];
UrlUtil.URL_TO_HASH_BUILDER["boon"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS];
UrlUtil.URL_TO_HASH_BUILDER["object"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS];
UrlUtil.URL_TO_HASH_BUILDER["trap"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS];
UrlUtil.URL_TO_HASH_BUILDER["hazard"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS];
UrlUtil.URL_TO_HASH_BUILDER["table"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES];
UrlUtil.URL_TO_HASH_BUILDER["tableGroup"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES];
UrlUtil.URL_TO_HASH_BUILDER["vehicle"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES];
UrlUtil.URL_TO_HASH_BUILDER["vehicleUpgrade"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES];
UrlUtil.URL_TO_HASH_BUILDER["action"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS];
UrlUtil.URL_TO_HASH_BUILDER["language"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES];
UrlUtil.URL_TO_HASH_BUILDER["charoption"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS];
UrlUtil.URL_TO_HASH_BUILDER["recipe"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES];
UrlUtil.URL_TO_HASH_BUILDER["deck"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS];

UrlUtil.URL_TO_HASH_BUILDER["subclass"] = it=>{
    return Hist.util.getCleanHash(`${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
        name: it.className,
        source: it.classSource
    })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
        subclass: it
    })}`, );
}
;
UrlUtil.URL_TO_HASH_BUILDER["classFeature"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.className, it.classSource, it.level, it.source);
UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.className, it.classSource, it.subclassShortName, it.subclassSource, it.level, it.source);
UrlUtil.URL_TO_HASH_BUILDER["card"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.set, it.source);
UrlUtil.URL_TO_HASH_BUILDER["legendaryGroup"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["itemEntry"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["itemProperty"] = (it)=>UrlUtil.encodeArrayForHash(it.abbreviation, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemType"] = (it)=>UrlUtil.encodeArrayForHash(it.abbreviation, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemTypeAdditionalEntries"] = (it)=>UrlUtil.encodeArrayForHash(it.appliesTo, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemMastery"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["skill"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["sense"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["raceFeature"] = (it)=>UrlUtil.encodeArrayForHash(it.name, it.raceName, it.raceSource, it.source);
UrlUtil.URL_TO_HASH_BUILDER["citation"] = UrlUtil.URL_TO_HASH_GENERIC;

Object.keys(UrlUtil.URL_TO_HASH_BUILDER).filter(k=>!k.endsWith(".html") && k.toLowerCase() !== k).forEach(k=>UrlUtil.URL_TO_HASH_BUILDER[k.toLowerCase()] = UrlUtil.URL_TO_HASH_BUILDER[k]);

Object.keys(UrlUtil.URL_TO_HASH_BUILDER).filter(k=>!k.endsWith(".html")).forEach(k=>UrlUtil.URL_TO_HASH_BUILDER[`raw_${k}`] = UrlUtil.URL_TO_HASH_BUILDER[k]);

Object.keys(UrlUtil.URL_TO_HASH_BUILDER).filter(k=>!k.endsWith(".html")).forEach(k=>{
    UrlUtil.URL_TO_HASH_BUILDER[`${k}Fluff`] = UrlUtil.URL_TO_HASH_BUILDER[k];
    UrlUtil.URL_TO_HASH_BUILDER[`${k}Template`] = UrlUtil.URL_TO_HASH_BUILDER[k];
}
);

UrlUtil.PG_TO_NAME = {};
UrlUtil.PG_TO_NAME[UrlUtil.PG_BESTIARY] = "Bestiary";
UrlUtil.PG_TO_NAME[UrlUtil.PG_SPELLS] = "Spells";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BACKGROUNDS] = "Backgrounds";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ITEMS] = "Items";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CLASSES] = "Classes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CONDITIONS_DISEASES] = "Conditions & Diseases";
UrlUtil.PG_TO_NAME[UrlUtil.PG_FEATS] = "Feats";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OPT_FEATURES] = "Other Options and Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_PSIONICS] = "Psionics";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RACES] = "Races";
UrlUtil.PG_TO_NAME[UrlUtil.PG_REWARDS] = "Supernatural Gifts & Rewards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VARIANTRULES] = "Optional, Variant, and Expanded Rules";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ADVENTURES] = "Adventures";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BOOKS] = "Books";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEITIES] = "Deities";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CULTS_BOONS] = "Cults & Supernatural Boons";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OBJECTS] = "Objects";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TRAPS_HAZARDS] = "Traps & Hazards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_QUICKREF] = "Quick Reference";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_BREW] = "Homebrew Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_PRERELEASE] = "Prerelease Content Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAKE_BREW] = "Homebrew Builder";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEMO_RENDER] = "Renderer Demo";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TABLES] = "Tables";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VEHICLES] = "Vehicles";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ACTIONS] = "Actions";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LANGUAGES] = "Languages";
UrlUtil.PG_TO_NAME[UrlUtil.PG_STATGEN] = "Stat Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LIFEGEN] = "This Is Your Life";
UrlUtil.PG_TO_NAME[UrlUtil.PG_NAMES] = "Names";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DM_SCREEN] = "DM Screen";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CR_CALCULATOR] = "CR Calculator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ENCOUNTERGEN] = "Encounter Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LOOTGEN] = "Loot Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TEXT_CONVERTER] = "Text Converter";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHANGELOG] = "Changelog";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHAR_CREATION_OPTIONS] = "Other Character Creation Options";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RECIPES] = "Recipes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CREATURE_FEATURES] = "Creature Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VEHICLE_FEATURES] = "Vehicle Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OBJECT_FEATURES] = "Object Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TRAP_FEATURES] = "Trap Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAPS] = "Maps";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DECKS] = "Decks";

UrlUtil.CAT_TO_PAGE = {};
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CREATURE] = UrlUtil.PG_BESTIARY;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SPELL] = UrlUtil.PG_SPELLS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BACKGROUND] = UrlUtil.PG_BACKGROUNDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ITEM] = UrlUtil.PG_ITEMS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CONDITION] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FEAT] = UrlUtil.PG_FEATS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELDRITCH_INVOCATION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_METAMAGIC] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_CAVALIER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARCANE_SHOT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FIGHTING_STYLE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PSIONIC] = UrlUtil.PG_PSIONICS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RACE] = UrlUtil.PG_RACES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OTHER_REWARD] = UrlUtil.PG_REWARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = UrlUtil.PG_VARIANTRULES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ADVENTURE] = UrlUtil.PG_ADVENTURE;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DEITY] = UrlUtil.PG_DEITIES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OBJECT] = UrlUtil.PG_OBJECTS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TRAP] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_HAZARD] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_QUICKREF] = UrlUtil.PG_QUICKREF;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CULT] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOON] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DISEASE] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE_GROUP] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VEHICLE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PACT_BOON] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARTIFICER_INFUSION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SHIP_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ONOMANCY_RESONANT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ALCHEMICAL_FORMULA] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ACTION] = UrlUtil.PG_ACTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LANGUAGE] = UrlUtil.PG_LANGUAGES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOOK] = UrlUtil.PG_BOOK;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PAGE] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = UrlUtil.PG_CHAR_CREATION_OPTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RECIPES] = UrlUtil.PG_RECIPES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_STATUS] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DECK] = UrlUtil.PG_DECKS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CARD] = "card";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SKILLS] = "skill";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SENSES] = "sense";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";

UrlUtil.CAT_TO_HOVER_PAGE = {};
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CLASS_FEATURE] = "classfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CARD] = "card";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SKILLS] = "skill";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SENSES] = "sense";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";

/* UrlUtil.HASH_START_CREATURE_SCALED = `${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_SPELL_SUMMON = `${VeCt.HASH_SCALED_SPELL_SUMMON}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_CLASS_SUMMON = `${VeCt.HASH_SCALED_CLASS_SUMMON}${HASH_SUB_KV_SEP}`; */

UrlUtil.SUBLIST_PAGES = {
    [UrlUtil.PG_BESTIARY]: true,
    [UrlUtil.PG_SPELLS]: true,
    [UrlUtil.PG_BACKGROUNDS]: true,
    [UrlUtil.PG_ITEMS]: true,
    [UrlUtil.PG_CONDITIONS_DISEASES]: true,
    [UrlUtil.PG_FEATS]: true,
    [UrlUtil.PG_OPT_FEATURES]: true,
    [UrlUtil.PG_PSIONICS]: true,
    [UrlUtil.PG_RACES]: true,
    [UrlUtil.PG_REWARDS]: true,
    [UrlUtil.PG_VARIANTRULES]: true,
    [UrlUtil.PG_DEITIES]: true,
    [UrlUtil.PG_CULTS_BOONS]: true,
    [UrlUtil.PG_OBJECTS]: true,
    [UrlUtil.PG_TRAPS_HAZARDS]: true,
    [UrlUtil.PG_TABLES]: true,
    [UrlUtil.PG_VEHICLES]: true,
    [UrlUtil.PG_ACTIONS]: true,
    [UrlUtil.PG_LANGUAGES]: true,
    [UrlUtil.PG_CHAR_CREATION_OPTIONS]: true,
    [UrlUtil.PG_RECIPES]: true,
    [UrlUtil.PG_DECKS]: true,
};

UrlUtil.PAGE_TO_PROPS = {};
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_SPELLS] = ["spell"];
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_ITEMS] = ["item", "itemGroup", "itemType", "itemEntry", "itemProperty", "itemTypeAdditionalEntries", "itemMastery", "baseitem", "magicvariant"];
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_RACES] = ["race", "subrace"];
//#endregion

//#region VeTools
globalThis.VeLock = function({name=null, isDbg=false}={}) {
    this._name = name;
    this._isDbg = isDbg;
    this._lockMeta = null;

    this._getCaller = ()=>{
        return (new Error()).stack.split("\n")[3].trim();
    }
    ;

    this.pLock = async({token=null}={})=>{
        if (token != null && this._lockMeta?.token === token) {
            ++this._lockMeta.depth;
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" add (now ${this._lockMeta.depth}) at ${this._getCaller()}`);
            return token;
        }

        while (this._lockMeta)
            await this._lockMeta.lock;

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" acquired at ${this._getCaller()}`);

        let unlock = null;
        const lock = new Promise(resolve=>unlock = resolve);
        this._lockMeta = {
            lock,
            unlock,
            token: CryptUtil.uid(),
            depth: 0,
        };

        return this._lockMeta.token;
    }
    ;

    this.unlock = ()=>{
        if (!this._lockMeta)
            return;

        if (this._lockMeta.depth > 0) {
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" sub (now ${this._lockMeta.depth - 1}) at ${this._getCaller()}`);
            return --this._lockMeta.depth;
        }

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" released at ${this._getCaller()}`);

        const lockMeta = this._lockMeta;
        this._lockMeta = null;
        lockMeta.unlock();
    }
    ;
}
;
class Vetools {
    static PRERELEASE_INDEX__SOURCE = {};
    static PRERELEASE_INDEX__PROP = {};
    static PRERELEASE_INDEX__META = {};

    static BREW_INDEX__SOURCE = {};
    static BREW_INDEX__PROP = {};
    static BREW_INDEX__META = {};

    static async pDoPreload() {
        if (Config.get("dataSources", "isNoPrereleaseBrewIndexes"))
            return;

        Vetools._pGetPrereleaseBrewIndices().then(({propPrerelease, sourcePrerelease, metaPrerelease, sourceBrew, propBrew, metaBrew})=>{
            Vetools.PRERELEASE_INDEX__PROP = propPrerelease;
            Vetools.PRERELEASE_INDEX__SOURCE = sourcePrerelease;
            Vetools.PRERELEASE_INDEX__META = metaPrerelease;

            Vetools.BREW_INDEX__PROP = propBrew;
            Vetools.BREW_INDEX__SOURCE = sourceBrew;
            Vetools.BREW_INDEX__META = metaBrew;

            console.log(...LGT, "Loaded prerelease/homebrew indexes.");
        }
        ).catch(e=>{
            Vetools.PRERELEASE_INDEX__SOURCE = {};
            Vetools.PRERELEASE_INDEX__PROP = {};
            Vetools.PRERELEASE_INDEX__META = {};

            Vetools.BREW_INDEX__PROP = {};
            Vetools.BREW_INDEX__SOURCE = {};
            Vetools.BREW_INDEX__META = {};

            ui.notifications.error(`Failed to load prerelease/homebrew indexes! ${VeCt.STR_SEE_CONSOLE}`);
            setTimeout(()=>{
                throw e;
            }
            );
        }
        );
    }

    static withUnpatchedDiceRendering(fn) {
        Renderer.getRollableEntryDice = Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE;
        const out = fn();
        Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
        return out;
    }

    static withCustomDiceRenderingPatch(fn, fnRender) {
        Renderer.getRollableEntryDice = fnRender;
        const out = fn();
        Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
        return out;
    }

    static getCleanDiceString(diceString) {
        return diceString.replace(/×/g, "*").replace(/÷/g, "/").replace(/#\$.*?\$#/g, "0");
    }

    static doMonkeyPatchPreConfig() {
        VeCt.STR_SEE_CONSOLE = "See the console (F12 or CTRL+SHIFT+J) for details.";

        StorageUtil.pSet = GameStorage.pSetClient.bind(GameStorage);
        StorageUtil.pGet = GameStorage.pGetClient.bind(GameStorage);
        StorageUtil.pRemove = GameStorage.pRemoveClient.bind(GameStorage);

        ["monster", "vehicle", "object", "trap", "race", "background"].forEach(prop=>{
            const propFullName = `${prop}Name`;
            const propFullSource = `${prop}Source`;
            (Renderer[prop].CHILD_PROPS_EXTENDED || Renderer[prop].CHILD_PROPS || ["feature"]).forEach(propChild=>{
                const propChildFull = `${prop}${propChild.uppercaseFirst()}`;
                if (UrlUtil.URL_TO_HASH_BUILDER[propChildFull])
                    return;
                UrlUtil.URL_TO_HASH_BUILDER[propChildFull] = it=>UrlUtil.encodeForHash([it.name, it[propFullName], it[propFullSource], it.source]);
            }
            );
        }
        );
    }

    static _CACHED_DATA_UTIL_LOAD_JSON = null;
    static _CACHED_DATA_UTIL_LOAD_RAW_JSON = null;

    static doMonkeyPatchPostConfig() {
        JqueryExtension.init();
        this._initSourceLookup();

        UtilsChangelog._RELEASE_URL = "https://github.com/TheGiddyLimit/plutonium-next/tags";

        const hkSetRendererUrls = ()=>{
            Renderer.get().setBaseUrl(Vetools.BASE_SITE_URL);

            if (Config.get("import", "isUseLocalImages")) {
                const localImageDirPath = `${Config.get("import", "localImageDirectoryPath")}/`.replace(/\/+$/, "/");
                Renderer.get().setBaseMediaUrl("img", localImageDirPath);
                return;
            }

            if (this._isCustomBaseSiteUrl()) {
                Renderer.get().setBaseMediaUrl("img", Vetools.BASE_SITE_URL);
                return;
            }

            Renderer.get().setBaseMediaUrl("img", null);
        }
        ;
        hkSetRendererUrls();

        UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, hkSetRendererUrls);

        Renderer.hover.MIN_Z_INDEX = Consts.Z_INDEX_MAX_FOUNDRY + 1;
        Renderer.hover._MAX_Z_INDEX = Renderer.hover.MIN_Z_INDEX + 10;

        Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE = Renderer.getRollableEntryDice;
        Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE = (entry,name,toDisplay,{isAddHandlers=true, pluginResults=null, }={},)=>{
            const cpy = MiscUtil.copy(entry);

            if (typeof cpy.toRoll !== "string") {
                cpy.toRoll = Renderer.legacyDiceToString(cpy.toRoll);
            }

            if (cpy.prompt) {
                const minAdditionalDiceLevel = Math.min(...Object.keys(cpy.prompt.options).map(it=>Number(it)).filter(it=>cpy.prompt.options[it]));
                cpy.toRoll = cpy.prompt.options[minAdditionalDiceLevel];
            }

            const toRollClean = this.getCleanDiceString(cpy.toRoll);

            if (Config.get("import", "isRendererDiceDisabled"))
                return toDisplay || toRollClean;

            const ptDisplay = toRollClean.toLowerCase().trim() !== toDisplay.toLowerCase().trim() ? `{${toDisplay}}` : "";

            if (cpy.autoRoll)
                return `[[${toRollClean}]]${ptDisplay}`;

            if (Config.get("import", "isRenderCustomDiceEnrichers") && entry.subtype === "damage") {
                return `[[/damage ${toRollClean} ${cpy.damageType ? `type=${cpy.damageType}` : ""}]]${ptDisplay}`;
            }

            return `[[/r ${toRollClean}]]${ptDisplay}`;
        }
        ;

        Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;

        const cachedRenderHoverMethods = {};
        const renderHoverMethods = ["$getHoverContent_stats", "$getHoverContent_fluff", "$getHoverContent_statsCode", "$getHoverContent_miscCode", "$getHoverContent_generic", ];
        renderHoverMethods.forEach(methodName=>{
            cachedRenderHoverMethods[methodName] = Renderer.hover[methodName];
            Renderer.hover[methodName] = (...args)=>{
                Renderer.getRollableEntryDice = Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE;
                const out = cachedRenderHoverMethods[methodName](...args);
                Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
                return out;
            }
            ;
        }
        );

        const cachedGetMakePredefinedHover = Renderer.hover.getMakePredefinedHover.bind(Renderer.hover);
        Renderer.hover.getMakePredefinedHover = (entry,opts)=>{
            const out = cachedGetMakePredefinedHover(entry, opts);
            out.html = `data-plut-hover="${true}" data-plut-hover-preload="${true}" data-plut-hover-preload-id="${out.id}" ${opts ? `data-plut-hover-preload-options="${JSON.stringify(opts).qq()}"` : ""}`;
            return out;
        }
        ;

        const cachedGetInlineHover = Renderer.hover.getInlineHover.bind(Renderer.hover);
        Renderer.hover.getInlineHover = (entry,opts)=>{
            const out = cachedGetInlineHover(entry, opts);
            out.html = `data-plut-hover="${true}" data-plut-hover-inline="${true}" data-plut-hover-inline-entry="${JSON.stringify(entry).qq()}" ${opts ? `data-plut-hover-inline-options="${JSON.stringify(opts).qq()}"` : ""}`;
            return out;
        }
        ;

        Renderer.dice.rollerClick = (evtMock,ele,packed,name)=>{
            const entry = JSON.parse(packed);
            if (entry.toRoll)
                (new Roll(entry.toRoll)).toMessage();
        }
        ;

        Renderer.dice.pRollEntry = (entry,rolledBy,opts)=>{
            if (entry.toRoll)
                (new Roll(entry.toRoll)).toMessage();
        }
        ;

        Renderer.dice.pRoll2 = async(str,rolledBy,opts)=>{
            const roll = new Roll(str);
            await roll.evaluate({
                async: true
            });
            await roll.toMessage();
            return roll.total;
        }
        ;

        Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS = Renderer.monster.doBindCompactContentHandlers;
        Renderer.monster.doBindCompactContentHandlers = (opts)=>{
            const nxtOpts = {
                ...opts
            };
            nxtOpts.fnRender = (...args)=>Vetools.withUnpatchedDiceRendering(()=>opts.fnRender(...args));
            return Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS(nxtOpts);
        }
        ;

        JqueryUtil.doToast = (options)=>{
            if (typeof options === "string") {
                options = {
                    content: options,
                    type: "info",
                };
            }
            options.type = options.type || "info";

            switch (options.type) {
            case "warning":
                return ui.notifications.warn(options.content);
            case "danger":
                return ui.notifications.error(options.content);
            default:
                return ui.notifications.info(options.content);
            }
        }
        ;

        UiUtil.pGetShowModal = opts=>UtilApplications.pGetShowApplicationModal(opts);
        InputUiUtil._pGetShowModal = opts=>UtilApplications.pGetShowApplicationModal(opts);

        this._CACHED_DATA_UTIL_LOAD_JSON = DataUtil.loadJSON.bind(DataUtil);
        this._CACHED_DATA_UTIL_LOAD_RAW_JSON = DataUtil.loadRawJSON.bind(DataUtil);

        DataUtil.loadJSON = async(url,...rest)=>Vetools._CACHED_DATA_UTIL_LOAD_JSON(this._getMaybeLocalUrl(url), ...rest);
        DataUtil.loadRawJSON = async(url,...rest)=>Vetools._CACHED_DATA_UTIL_LOAD_RAW_JSON(this._getMaybeLocalUrl(url), ...rest);

        Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET = DataLoader.pCacheAndGet.bind(DataLoader);
        DataLoader.pCacheAndGet = async function(page, source, ...others) {
            const sourceLower = `${source}`.toLowerCase();
            if (!Vetools._VET_SOURCE_LOOKUP[sourceLower]) {
                Vetools._pCachingLocalPrerelease = Vetools._pCachingLocalPrerelease || Vetools._pDoCacheLocalPrerelease();
                Vetools._pCachingLocalBrew = Vetools._pCachingLocalBrew || Vetools._pDoCacheLocalBrew();

                await Promise.all([Vetools._pCachingLocalPrerelease, Vetools._pCachingLocalBrew, ]);
            }

            return Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET(page, source, ...others);
        }
        ;

        PrereleaseUtil._storage = new StorageUtilMemory();
        BrewUtil2._storage = new StorageUtilMemory();
    }

    static _initSourceLookup() {
        Object.keys(Parser.SOURCE_JSON_TO_FULL).forEach(source=>Vetools._VET_SOURCE_LOOKUP[source.toLowerCase()] = true);
    }

    static _pCachingLocalPrerelease = null;
    static _pCachingLocalBrew = null;

    static async _pDoCacheLocalPrerelease() {
        await this.pGetLocalPrereleaseSources();
    }
    static async _pDoCacheLocalBrew() {
        await this.pGetLocalBrewSources();
    }

    static _getMaybeLocalUrl(url) {
        if (!url.includes("?"))
            url = `${url}?t=${Consts.RUN_TIME}`;

        const parts = url.split(Vetools._RE_HTTP_URL).filter(Boolean);
        parts[parts.length - 1] = parts.last().replace(/\/+/g, "/");
        url = parts.join("");

        if (!Config.get("dataSources", "isNoLocalData") && (url.startsWith(`${Vetools.BASE_SITE_URL}data/`) || url.startsWith(`${Vetools.BASE_SITE_URL}search/`)) && url !== this._getChangelogUrl()) {
            const urlPart = url.split(Vetools.BASE_SITE_URL).slice(1).join(Vetools.BASE_SITE_URL);
            return `modules/${SharedConsts.MODULE_ID}/${urlPart}`;
        } else {
            return url;
        }
    }

    static _CACHE_IMPORTER_SOURCE_SPECIAL = {};

    static async pLoadImporterSourceSpecial(source) {
        if (!source.special.cacheKey)
            return source.special.pGet();

        this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey] = this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey] || source.special.pGet();

        return this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey];
    }

    static _getChangelogUrl() {
        return `${Vetools.BASE_SITE_URL}data/changelog.json`;
    }
    static async pGetChangelog() {
        return DataUtil.loadJSON(this._getChangelogUrl());
    }

    static async pGetPackageIndex() {
        return DataUtil.loadJSON(Config.get("importAdventure", "indexUrl"));
    }

    static async pGetItems() {
        return {
            item: (await Renderer.item.pBuildList()).filter(it=>!it._isItemGroup)
        };
    }

    static async pGetPrereleaseItems(data) {
        return this._pGetPrereleaseBrewItems({
            data,
            pFnGetItems: Renderer.item.pGetItemsFromPrerelease.bind(Renderer.item)
        });
    }

    static async pGetBrewItems(data) {
        return this._pGetPrereleaseBrewItems({
            data,
            pFnGetItems: Renderer.item.pGetItemsFromBrew.bind(Renderer.item)
        });
    }

    static async _pGetPrereleaseBrewItems({data, pFnGetItems}) {
        const sources = new Set();
        ["item", "magicvariant", "baseitem"].forEach(prop=>{
            if (!data[prop])
                return;
            data[prop].forEach(ent=>sources.add(SourceUtil.getEntitySource(ent)));
        }
        );
        return (await pFnGetItems()).filter(ent=>sources.has(SourceUtil.getEntitySource(ent)));
    }

    static async pGetRaces(opts) {
        return DataUtil.race.loadJSON(opts);
    }

    static async pGetClasses() {
        return DataUtil.class.loadRawJSON();
    }

    static async pGetClassSubclassFeatures() {
        return DataUtil.class.loadRawJSON();
    }

    static async pGetRollableTables() {
        return DataUtil.table.loadJSON();
    }

    static async pGetDecks() {
        return DataUtil.deck.loadJSON();
    }

    static async _pGetAdventureBookIndex(filename, {prop, fnGetUrl}) {
        const url = `${Vetools.BASE_SITE_URL}data/${filename}`;
        const index = await DataUtil.loadJSON(url);
        index[prop].forEach(it=>{
            it._pubDate = new Date(it.published || "1970-01-01");
            it._url = fnGetUrl(it.id);
        }
        );
        return index;
    }

    static async pGetAdventureIndex() {
        return this._pGetAdventureBookIndex("adventures.json", {
            prop: "adventure",
            fnGetUrl: Vetools.getAdventureUrl.bind(Vetools)
        });
    }

    static async pGetBookIndex() {
        return this._pGetAdventureBookIndex("books.json", {
            prop: "book",
            fnGetUrl: Vetools.getBookUrl.bind(Vetools)
        });
    }

    static _getAdventureBookUrl(type, id) {
        return `${Vetools.BASE_SITE_URL}data/${type}/${type}-${id.toLowerCase()}.json`;
    }

    static getAdventureUrl(id) {
        return this._getAdventureBookUrl("adventure", id);
    }

    static getBookUrl(id) {
        return this._getAdventureBookUrl("book", id);
    }

    static pGetImageUrlFromFluff(fluff) {
        if (!fluff?.images?.length)
            return;

        const imgEntry = fluff.images[0];
        if (!imgEntry?.href)
            return;

        const urlsWarn = [];
        const out = fluff.images.first(imgEntry=>{
            const url = this._pGetImageUrlFromFluff_getUrlFromEntry({
                imgEntry
            });
            if (!this._isValidImageUrl({
                url
            })) {
                urlsWarn.push(url);
                return null;
            }
            return url;
        }
        );

        if (urlsWarn.length)
            ui.notifications.warn(`Image URL${urlsWarn.length === 1 ? "" : "s"} did not have valid extensions: ${urlsWarn.map(it=>`"${it}"`).join(", ")}`);

        return out;
    }

    static _pGetImageUrlFromFluff_getUrlFromEntry({imgEntry}) {
        if (imgEntry.href.type === "internal") {
            return imgEntry.href.path ? `${Vetools.getInternalImageUrl(imgEntry.href.path)}` : null;
        }

        if (imgEntry.href.type === "external") {
            return imgEntry.href.url ? imgEntry.href.url : null;
        }
    }

    static _isValidImageUrl({url}) {
        return foundry.data.validators.hasFileExtension(url, Object.keys(CONST.IMAGE_FILE_EXTENSIONS));
    }

    static async pHasTokenUrl(entityType, it, opts) {
        return (await Vetools._pGetTokenUrl(entityType, it, opts))?.hasToken;
    }

    static async pGetTokenUrl(entityType, it, opts) {
        return (await Vetools._pGetTokenUrl(entityType, it, opts))?.url;
    }

    static _isSaveableToServerUrl(originalUrl) {
        return originalUrl && typeof originalUrl === "string" && Vetools._RE_HTTP_URL.test(originalUrl);
    }
    static _isSaveTypedImagesToServer({imageType="image"}={}) {
        switch (imageType) {
        case "image":
            return Config.get("import", "isSaveImagesToServer");
        case "token":
            return Config.get("import", "isSaveTokensToServer");
        default:
            throw new Error(`Unhandled type "${imageType}"!`);
        }
    }

    static async _pGetTokenUrl(entityType, it, {isSilent=false}={}) {
        if (it.tokenUrl)
            return {
                url: it.tokenUrl,
                hasToken: true
            };

        const fallbackMeta = {
            url: this.getBlankTokenUrl(),
            hasToken: false,
        };

        switch (entityType) {
        case "monster":
        case "vehicle":
        case "object":
            {
                const fnGets = {
                    "monster": Renderer.monster.getTokenUrl,
                    "vehicle": Renderer.vehicle.getTokenUrl,
                    "object": Renderer.object.getTokenUrl,
                };
                const fnGet = fnGets[entityType];
                if (!fnGet)
                    throw new Error(`Missing getter!`);

                if (it.hasToken)
                    return {
                        url: fnGet(it),
                        hasToken: true
                    };
                if (it._versionBase_hasToken)
                    return {
                        url: fnGet({
                            name: it._versionBase_name,
                            source: it._versionBase_source
                        }),
                        hasToken: true
                    };

                return fallbackMeta;
            }
        case "trap":
            return fallbackMeta;
        default:
            {
                if (isSilent)
                    return null;
                throw new Error(`Unhandled entity type "${entityType}"`);
            }
        }
    }

    static getBlankTokenUrl() {
        return UrlUtil.link(`${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/blank.png`);
    }

    static getImageUrl(entry) {
        if (entry?.href.type === "internal")
            return Vetools.getInternalImageUrl(entry.href.path, {
                isSkipEncode: true
            });
        return entry.href?.url;
    }

    static getInternalImageUrl(path, {isSkipEncode=false}={}) {
        if (!path)
            return null;
        const fnEncode = isSkipEncode ? it=>it : encodeURI;

        const out = `${fnEncode(Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl)}img/${fnEncode(path)}`;

        if (isSkipEncode)
            return out;
        return out.replace(/'/g, "%27");
    }

    static async pOptionallySaveImageToServerAndGetUrl(originalUrl, {imageType="image"}={}) {
        if (this._isLocalUrl({
            originalUrl
        }))
            return originalUrl;
        if (!this._isSaveTypedImagesToServer({
            imageType
        }))
            return originalUrl;
        return this.pSaveImageToServerAndGetUrl({
            originalUrl
        });
    }

    static _isLocalUrl({originalUrl}) {
        return new URL(document.baseURI).origin === new URL(originalUrl,document.baseURI).origin;
    }

    static getImageSavedToServerUrl({originalUrl=null, path, isSaveToRoot=false}={}) {
        if (!path && !this._isSaveableToServerUrl(originalUrl))
            return originalUrl;

        const pathPart = (new URL(path ? `https://example.com/${path}` : originalUrl)).pathname;
        return `${isSaveToRoot ? "" : `${Config.get("import", "localImageDirectoryPath")}/`}${decodeURI(pathPart)}`.replace(/\/+/g, "/");
    }

    static _getImageSavedToServerUrlMeta({originalUrl=null, path, isSaveToRoot=false}) {
        const cleanOutPath = this.getImageSavedToServerUrl({
            originalUrl,
            path,
            isSaveToRoot
        });
        const serverUrlPathParts = cleanOutPath.split("/");
        const serverUrlDirParts = serverUrlPathParts.slice(0, -1);
        const serverUrlDir = serverUrlDirParts.join("/");

        return {
            serverUrl: cleanOutPath,
            serverUrlPathParts,
            serverUrlDir,
            serverUrlDirParts,
        };
    }

    static async pSaveImageToServerAndGetUrl({originalUrl=null, blob, force=false, path=null, isSaveToRoot=false}={}) {
        if (blob && originalUrl)
            throw new Error(`"blob" and "originalUrl" arguments are mutually exclusive!`);

        if (!blob && !this._isSaveableToServerUrl(originalUrl))
            return originalUrl;

        let out;
        try {
            await Vetools._LOCK_DOWNLOAD_IMAGE.pLock();
            out = await this._pSaveImageToServerAndGetUrl_({
                originalUrl,
                blob,
                force,
                path,
                isSaveToRoot
            });
        } finally {
            Vetools._LOCK_DOWNLOAD_IMAGE.unlock();
        }
        return out;
    }

    static async _pSaveImageToServerAndGetUrl_({originalUrl=null, blob, force=false, path=null, isSaveToRoot=false}={}) {
        if (blob && originalUrl)
            throw new Error(`"blob" and "originalUrl" arguments are mutually exclusive!`);

        const {serverUrl, serverUrlPathParts, serverUrlDir, serverUrlDirParts, } = this._getImageSavedToServerUrlMeta({
            originalUrl,
            path,
            isSaveToRoot
        });

        const {dirListing, isDirExists, isError: isErrorDirListing, } = await this.pGetDirectoryListing({
            originalUrl,
            path,
            isSaveToRoot
        });

        if (isErrorDirListing) {
            const msgStart = `Could not check for existing files when saving imported images to server!`;
            if (!force && blob)
                throw new Error(msgStart);

            const msg = `${msgStart}${force ? "" : ` The original image URL will be used instead.`}`;
            UtilNotifications.notifyOnce({
                type: "warn",
                message: msg
            });
            return force ? serverUrl : originalUrl;
        }

        if (dirListing?.files && dirListing?.files.map(it=>UtilFileBrowser.decodeUrl(it)).includes(serverUrl))
            return serverUrl;

        if (!this._canUploadFiles()) {
            if (!force && blob)
                throw new Error(`Your permission levels do not allow you to upload files!`);

            const msg = `You have the "Save Imported Images to Server" config option enabled, but your permission levels do not allow you to upload files!${force ? "" : ` The original image URL will be used instead.`}`;
            UtilNotifications.notifyOnce({
                type: "warn",
                message: msg
            });
            return force ? serverUrl : originalUrl;
        }

        if (!isDirExists) {
            try {
                await this._pSaveImageToServerAndGetUrl_pCreateDirectories(serverUrlDirParts);
            } catch (e) {
                const msgStart = `Could not create required directories when saving imported images to server!`;
                if (!force && blob)
                    throw new Error(msgStart);

                const msg = `${msgStart}${force ? "" : ` The original image URL will be used instead.`}`;
                UtilNotifications.notifyOnce({
                    type: "warn",
                    message: msg
                });
                return force ? serverUrl : originalUrl;
            }
        }

        try {
            blob = blob || await this._pSaveImageToServerAndGetUrl_pGetBlob(originalUrl);
        } catch (e) {
            const msg = `Failed to download image "${originalUrl}" when saving imported images to server!${force ? "" : ` The original image URL will be used instead.`} ${VeCt.STR_SEE_CONSOLE}`;
            UtilNotifications.notifyOnce({
                type: "warn",
                message: msg
            });
            console.error(...LGT, e);
            return force ? serverUrl : originalUrl;
        }

        const name = serverUrlPathParts.last();
        let mimeType = `image/${(name.split(".").last() || "").trim().toLowerCase()}`;
        if (mimeType === "image/jpg")
            mimeType = "image/jpeg";

        const resp = await FilePicker.upload("data", serverUrlDir, new File([blob],name,{
            lastModified: Date.now(),
            type: mimeType,
        },), {}, {
            notify: false,
        }, );
        if (resp?.path)
            return UtilFileBrowser.decodeUrl(resp.path);

        return force ? serverUrl : originalUrl;
    }

    static async _pSaveImageToServerAndGetUrl_pGetBlob(originalUrl) {
        const isBackend = await UtilBackend.pGetBackendVersion();

        try {
            const blobResp = await fetch(originalUrl);
            return blobResp.blob();
        } catch (e) {
            if (!isBackend)
                throw e;
            console.warn(...LGT, `Could not directly load image from ${originalUrl}\u2014falling back on alternate loader (backend mod).`);
        }

        const blobResp = await fetch(Config.backendEndpoint, {
            method: "post",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                type: "getBinaryData",
                url: originalUrl,
            }),
        }, );
        return blobResp.blob();
    }

    static async _pSaveImageToServerAndGetUrl_pCreateDirectories(serverUrlDirParts) {
        if (!serverUrlDirParts.length)
            return;
        for (let i = 0; i < serverUrlDirParts.length; ++i) {
            const dirPartSlice = serverUrlDirParts.slice(0, i + 1);
            try {
                await FilePicker.createDirectory("data", dirPartSlice.join("/"));
            } catch (e) {
                if (/EEXIST/.test(`${e}`))
                    continue;
                throw new Error(e);
            }
        }
    }

    static _canUploadFiles() {
        return game.isAdmin || (game.user && game.user.can("FILES_UPLOAD"));
    }

    static async pGetDirectoryListing({originalUrl=null, path=null, isSaveToRoot=false, isDirPath=false}) {
        if (originalUrl && isDirPath)
            throw new Error(`Arguments "originalUrl" and "isDirPath" are mutually exclusive`);
        if (!path && isDirPath)
            throw new Error(`Argument "isDirPath" requires the "path" argument to be passed!`);

        const {serverUrlDir} = this._getImageSavedToServerUrlMeta({
            originalUrl,
            path: path && isDirPath ? `${path}/stub` : path,
            isSaveToRoot,
        });

        let dirListing = null;
        let isDirExists = false;
        let isError = false;
        try {
            dirListing = await FilePicker.browse("data", serverUrlDir);
            if (dirListing?.target)
                isDirExists = true;
        } catch (e) {
            isError = !/Directory .*? does not exist/.test(`${e}`);
        }

        return {
            dirListing,
            isDirExists,
            isError,
        };
    }

    static async pGetAllSpells({isFilterNonStandard=false, additionalSourcesPrerelease=[], additionalSourcesBrew=[], isIncludeLoadedBrew=false, isIncludeLoadedPrerelease=false, isApplyBlocklist=false, }={}, ) {
        let spells = MiscUtil.copyFast(await DataUtil.spell.pLoadAll());

        if (isFilterNonStandard)
            spells = spells.filter(sp=>!SourceUtil.isNonstandardSource(sp.source));

        if (isIncludeLoadedPrerelease) {
            const prerelease = await PrereleaseUtil.pGetBrewProcessed();
            if (prerelease.spell?.length)
                spells = spells.concat(prerelease.spell);
        }

        if (isIncludeLoadedBrew) {
            const brew = await BrewUtil2.pGetBrewProcessed();
            if (brew.spell?.length)
                spells = spells.concat(brew.spell);
        }

        const pHandleAdditionalSources = async({additionalSources, pFnLoad})=>{
            for (const src of additionalSources) {
                const json = await pFnLoad(src);
                if (!json)
                    continue;
                if (json.spell?.length)
                    spells = spells.concat(json.spell);
            }
        }
        ;

        if (additionalSourcesPrerelease?.length)
            await pHandleAdditionalSources({
                additionalSources: additionalSourcesPrerelease,
                pFnLoad: DataUtil.pLoadPrereleaseBySource.bind(DataUtil)
            });
        if (additionalSourcesBrew?.length)
            await pHandleAdditionalSources({
                additionalSources: additionalSourcesBrew,
                pFnLoad: DataUtil.pLoadBrewBySource.bind(DataUtil)
            });

        if (isApplyBlocklist) {
            spells = spells.filter(sp=>!ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS](sp), "spell", sp.source, {
                isNoCount: true
            }, ), );
        }

        spells.forEach(sp=>Renderer.spell.initBrewSources(sp));

        return {
            spell: spells
        };
    }

    static async pGetAllCreatures(isFilterNonStandard=false) {
        let creatures = await DataUtil.monster.pLoadAll();

        if (isFilterNonStandard)
            creatures = creatures.filter(mon=>!SourceUtil.isNonstandardSource(mon.source));

        return {
            monster: creatures
        };
    }

    static async _pGetPrereleaseBrewIndices() {
        const out = {
            sourcePrerelease: {},
            propPrerelease: {},
            metaPrerelease: {},

            sourceBrew: {},
            propBrew: {},
            metaBrew: {},
        };

        try {
            const [sourceIndexPrerelease,propIndexPrerelease,metaIndexPrerelease,
            sourceIndexBrew,propIndexBrew,metaIndexBrew,] = await Promise.all([DataUtil.prerelease.pLoadSourceIndex(Config.get("dataSources", "basePrereleaseUrl")), DataUtil.prerelease.pLoadPropIndex(Config.get("dataSources", "basePrereleaseUrl")), DataUtil.prerelease.pLoadMetaIndex(Config.get("dataSources", "basePrereleaseUrl")),
            DataUtil.brew.pLoadSourceIndex(Config.get("dataSources", "baseBrewUrl")), DataUtil.brew.pLoadPropIndex(Config.get("dataSources", "baseBrewUrl")), DataUtil.brew.pLoadMetaIndex(Config.get("dataSources", "baseBrewUrl")), ]);

            out.sourcePrerelease = sourceIndexPrerelease;
            out.propPrerelease = propIndexPrerelease;
            out.metaPrerelease = metaIndexPrerelease;

            out.sourceBrew = sourceIndexBrew;
            out.propBrew = propIndexBrew;
            out.metaBrew = metaIndexBrew;
        } catch (e) {
            ui.notifications.error(`Failed to load prerelease/homebrew index! ${VeCt.STR_SEE_CONSOLE}`);
            setTimeout(()=>{
                throw e;
            }
            );
        }

        return out;
    }

    static async pGetPrereleaseSources(...dirs) {
        return this._pGetPrereleaseBrewSources({
            dirs,
            brewUtil: PrereleaseUtil,
            indexProp: Vetools.PRERELEASE_INDEX__PROP,
            indexMeta: Vetools.PRERELEASE_INDEX__META,
            configKey: "basePrereleaseUrl",
        });
    }

    static async pGetBrewSources(...dirs) {
        return this._pGetPrereleaseBrewSources({
            dirs,
            brewUtil: BrewUtil2,
            indexProp: Vetools.BREW_INDEX__PROP,
            indexMeta: Vetools.BREW_INDEX__META,
            configKey: "baseBrewUrl",
        });
    }

    static async _pGetPrereleaseBrewSources({dirs, brewUtil, indexProp, indexMeta, configKey}) {
        const urlRoot = Config.get("dataSources", configKey);

        let paths;
        if (dirs.includes("*")) {
            paths = Object.values(indexProp).map(obj=>Object.keys(obj)).flat().unique();
        } else {
            paths = dirs.map(dir=>Object.keys(indexProp[brewUtil.getDirProp(dir)] || {})).flat().unique();
        }

        return paths.map((path)=>{
            const metaName = UrlUtil.getFilename(path);
            return ({
                url: brewUtil.getFileUrl(path, urlRoot),
                name: this._getPrereleaseBrewName(path),
                abbreviations: indexMeta[metaName]?.a || [],
            });
        }
        ).sort((a,b)=>SortUtil.ascSortLower(a.name, b.name));
    }

    static _getPrereleaseBrewName(brewPath) {
        return brewPath.split("/").slice(-1).join("").replace(/\.json$/i, "");
    }

    static _LOCAL_PRERELEASE_SOURCE_SEEN_URLS = new Set();
    static async pGetLocalPrereleaseSources(...dirs) {
        return this._pGetLocalPrereleaseBrewSources({
            brewUtil: PrereleaseUtil,
            dirs,
            displayName: "prerelease",
            configKeyLocal: "localPrerelease",
            configKeyIsLoadIndex: "isLoadLocalPrereleaseIndex",
            configKeyIsUseIndex: "isUseLocalPrereleaseIndexJson",
            configKeyDirectoryPath: "localPrereleaseDirectoryPath",
            setSeenUrls: this._LOCAL_PRERELEASE_SOURCE_SEEN_URLS,
        });
    }

    static _LOCAL_BREW_SOURCE_SEEN_URLS = new Set();
    static async pGetLocalBrewSources(...dirs) {
        return this._pGetLocalPrereleaseBrewSources({
            brewUtil: BrewUtil2,
            dirs,
            displayName: "homebrew",
            configKeyLocal: "localHomebrew",
            configKeyIsLoadIndex: "isLoadLocalHomebrewIndex",
            configKeyIsUseIndex: "isUseLocalHomebrewIndexJson",
            configKeyDirectoryPath: "localHomebrewDirectoryPath",
            setSeenUrls: this._LOCAL_BREW_SOURCE_SEEN_URLS,
        });
    }

    static async _pGetLocalPrereleaseBrewSources({brewUtil, dirs, displayName, configKeyLocal, configKeyIsLoadIndex, configKeyIsUseIndex, configKeyDirectoryPath, setSeenUrls}) {
        try {
            const listLocal = await this._pGetLocalPrereleaseBrewList({
                displayName,
                configKeyIsLoadIndex,
                configKeyIsUseIndex,
                configKeyDirectoryPath,
            });

            const allFilenames = [...(listLocal || []), ...(Config.get("dataSources", configKeyLocal) || []), ];

            if (!allFilenames.length)
                return [];

            await allFilenames.pSerialAwaitMap(async name=>{
                if (setSeenUrls.has(name))
                    return;
                setSeenUrls.add(name);
                await brewUtil.pAddBrewFromUrl(name, {
                    isLazy: true
                });
            }
            );
            await brewUtil.pAddBrewsLazyFinalize();

            const brews = await allFilenames.pSerialAwaitMap(async name=>({
                url: name,
                data: await DataUtil.loadJSON(name),
                name: this._getPrereleaseBrewName(name),
            }));

            const desiredProps = new Set(dirs.map(dir=>brewUtil.getDirProp(dir)));

            return brews.filter(({data})=>{
                if (desiredProps.has("*"))
                    return true;

                const propsInBrew = new Set([...Object.keys(data || {}).filter(it=>!it.startsWith("_")), ...Object.keys(data?._meta?.includes || {}), ]);

                return [...desiredProps].some(it=>propsInBrew.has(it));
            }
            ).map(it=>{
                it.abbreviations = (it.data?._meta?.sources || []).map(it=>it.abbreviation).filter(Boolean);
                return it;
            }
            ).map(({name, url, abbreviations})=>({
                name,
                url,
                abbreviations
            }));
        } catch (e) {
            const msg = `Failed to load local homebrew index!`;
            console.error(...LGT, msg, e);
            ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
        }
        return [];
    }

    static async _pGetLocalPrereleaseBrewList({displayName, configKeyIsLoadIndex, configKeyIsUseIndex, configKeyDirectoryPath}) {
        if (!Config.get("dataSources", configKeyIsLoadIndex))
            return null;

        const isUseIndexJson = Config.get("dataSources", configKeyIsUseIndex);

        if (isUseIndexJson) {
            const indexUrl = `${Config.get("dataSources", configKeyDirectoryPath)}/index.json`.replace(/\/+/g, "/");
            const index = await DataUtil.loadJSON(indexUrl);
            if (!index?.toImport)
                return [];
            return index.toImport.map(it=>{
                if (Vetools._RE_HTTP_URL.test(it))
                    return it;

                return [...indexUrl.split("/").slice(0, -1), it].join("/");
            }
            );
        }

        try {
            const existingFiles = await FilePicker.browse("data", Config.get("dataSources", configKeyDirectoryPath));
            if (!existingFiles?.files?.length)
                return null;

            return existingFiles.files.map(it=>decodeURIComponent(it));
        } catch (e) {
            const ptReason = /You do not have permission to browse the host file system/i.test(e.message) ? `You do not have "Use File Browser" permissions!` : `Does the ${isUseIndexJson ? "file" : "directory"} "<data_dir>/${Config.get("dataSources", configKeyDirectoryPath)}${isUseIndexJson ? "/index.json" : ""}" exist?`;
            const msg = `Failed to load local ${displayName}${isUseIndexJson ? " index" : ""}! ${ptReason}`;
            console.error(...LGT, msg, e);
            ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
            return null;
        }
    }

    static async pGetSpellSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/spells/foundry.json`);
    }
    static async pGetOptionalFeatureSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-optionalfeatures.json`);
    }
    static async pGetClassSubclassSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/class/foundry.json`);
    }
    static async pGetRaceSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-races.json`);
    }
    static async pGetItemSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-items.json`);
    }
    static async pGetFeatSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-feats.json`);
    }
    static async pGetRewardSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-rewards.json`);
    }
    static async pGetActionSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-actions.json`);
    }
    static async pGetVehicleUpgradeSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-vehicles.json`);
    }
    static async pGetCreatureSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/bestiary/foundry.json`);
    }
    static async pGeBackgroundSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-backgrounds.json`);
    }
    static async pGetPsionicsSideData() {
        return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-psionics.json`);
    }

    static async pGetConditionDiseaseSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-conditionsdiseases.json`);
    }
    static async pGetObjectSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-objects.json`);
    }
    static async pGetVehicleSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-vehicles.json`);
    }
    static async pGetCharCreationOptionSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-charcreationoptions.json`);
    }
    static async pGetCultBoonSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-cultsboons.json`);
    }
    static async pGetTrapHazardSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-trapshazards.json`);
    }
    static async pGetDeckSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-decks.json`);
    }
    static async pGetDeitySideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-deities.json`);
    }
    static async pGetTableSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-tables.json`);
    }
    static async pGetLanguageSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-languages.json`);
    }
    static async pGetRecipeSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-recipes.json`);
    }
    static async pGetVariantruleSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-variantrules.json`);
    }

    static async pGetCreatureFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }
    static async pGetObjectFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }
    static async pGetVehicleFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }
    static async pGetTrapFeatureSideData() {
        return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-todo.json`);
    }

    static getModuleDataUrl(filename) {
        return `modules/${SharedConsts.MODULE_ID}/data/${filename}`;
    }

    static async pGetIconLookup(entityType) {
        return DataUtil.loadJSON(this.getModuleDataUrl(`icon-${entityType}s.json`));
    }

    static get BASE_SITE_URL() {
        if (this._isCustomBaseSiteUrl()) {
            return Util.getCleanServerUrl(Config.get("dataSources", "baseSiteUrl"));
        }
        return Vetools._BASE_SITE_URL;
    }

    static _isCustomBaseSiteUrl() {
        const val = Config.get("dataSources", "baseSiteUrl");
        return !!(val && val.trim());
    }

    static get DATA_URL_FEATS() {
        return `${Vetools.BASE_SITE_URL}data/feats.json`;
    }
    static get DATA_URL_BACKGROUNDS() {
        return `${Vetools.BASE_SITE_URL}data/backgrounds.json`;
    }
    static get DATA_URL_VARIANTRULES() {
        return `${Vetools.BASE_SITE_URL}data/variantrules.json`;
    }
    static get DATA_URL_PSIONICS() {
        return `${Vetools.BASE_SITE_URL}data/psionics.json`;
    }
    static get DATA_URL_OPTIONALFEATURES() {
        return `${Vetools.BASE_SITE_URL}data/optionalfeatures.json`;
    }
    static get DATA_URL_CONDITIONSDISEASES() {
        return `${Vetools.BASE_SITE_URL}data/conditionsdiseases.json`;
    }
    static get DATA_URL_VEHICLES() {
        return `${Vetools.BASE_SITE_URL}data/vehicles.json`;
    }
    static get DATA_URL_REWARDS() {
        return `${Vetools.BASE_SITE_URL}data/rewards.json`;
    }
    static get DATA_URL_OBJECTS() {
        return `${Vetools.BASE_SITE_URL}data/objects.json`;
    }
    static get DATA_URL_DEITIES() {
        return `${Vetools.BASE_SITE_URL}data/deities.json`;
    }
    static get DATA_URL_RECIPES() {
        return `${Vetools.BASE_SITE_URL}data/recipes.json`;
    }
    static get DATA_URL_CHAR_CREATION_OPTIONS() {
        return `${Vetools.BASE_SITE_URL}data/charcreationoptions.json`;
    }
    static get DATA_URL_CULTSBOONS() {
        return `${Vetools.BASE_SITE_URL}data/cultsboons.json`;
    }
    static get DATA_URL_ACTIONS() {
        return `${Vetools.BASE_SITE_URL}data/actions.json`;
    }
    static get DATA_URL_LANGUAGES() {
        return `${Vetools.BASE_SITE_URL}data/languages.json`;
    }
    static get DATA_URL_TRAPS_HAZARDS() {
        return `${Vetools.BASE_SITE_URL}data/trapshazards.json`;
    }
}
Vetools._RE_HTTP_URL = /(^https?:\/\/)/;
Vetools._BASE_SITE_URL = "https://5etools-mirror-1.github.io/";
Vetools.BESTIARY_FLUFF_INDEX = null;
Vetools.BESTIARY_TOKEN_LOOKUP = null;
Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE = null;
Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE = null;
Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS = null;
Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET = null;
Vetools._LOCK_DOWNLOAD_IMAGE = new VeLock();
Vetools._VET_SOURCE_LOOKUP = {};
//#endregion

//#region SharedConsts
class SharedConsts {
    static MODULE_TITLE = "Plutonium";
    static MODULE_TITLE_FAKE = "SRD: Enhanced";
    static MODULE_ID = "plutonium";
    static MODULE_ID_FAKE = "srd5e";

    static PACK_NAME_CREATURES = "creatures";
    static PACK_NAME_SPELLS = "spells";
    static PACK_NAME_ITEMS = "items";

    static MODULE_LOCATION = `modules/${SharedConsts.MODULE_ID}`;

    static SYSTEM_ID_DND5E = "dnd5e";
}
//#endregion

//#region Util
class Util {
    static _getLogTag() {
        return [`%cPlutonium`, `color: #337ab7; font-weight: bold;`, `|`, ];
    }

    static isDebug() {
        return !!CONFIG?.debug?.module?.[SharedConsts.MODULE_ID];
    }

    static _HEIGHT_MAX_OFFSET = 160;
    static getMaxWindowHeight(desiredHeight) {
        const targetHeight = Math.min(desiredHeight || Number.MAX_SAFE_INTEGER, document.documentElement.clientHeight - this._HEIGHT_MAX_OFFSET);
        return Math.max(this._HEIGHT_MAX_OFFSET, targetHeight);
    }

    static _WIDTH_MAX_OFFSET = 250;
    static getMaxWindowWidth(desiredWidth) {
        const targetWidth = Math.min(desiredWidth || Number.MAX_SAFE_INTEGER, document.documentElement.clientWidth - this._WIDTH_MAX_OFFSET);
        return Math.max(this._WIDTH_MAX_OFFSET, targetWidth);
    }

    static getWithoutParens(str) {
        return str.replace(/\([^)]+\)/g, "").trim();
    }
    static getTokens(str) {
        return str.split(/([ ,:;()"])/g).filter(Boolean);
    }
    static isPunctuation(token) {
        return /[,:;()"]/.test(token);
    }
    static isCapsFirst(word) {
        return /^[A-Z]/.test(word);
    }
    static getSentences(str) {
        return str.replace(/ +/g, " ").split(/[.?!]/g).map(it=>it.trim()).filter(Boolean);
    }

    static getRounded(n, dp) {
        return Number(n.toFixed(dp));
    }

    static trimObject(obj) {
        const walker = MiscUtil.getWalker({
            isAllowDeleteObjects: true,
            isDepthFirst: true,
        });

        return walker.walk(obj, {
            object: (it)=>{
                Object.entries(it).forEach(([k,v])=>{
                    if (v === undefined)
                        delete it[k];
                }
                );
                if (!Object.keys(it).length)
                    return undefined;
                return it;
            }
            ,
        }, );
    }

    static getCleanServerUrl(url) {
        return url.replace(/^(.*?)\/*$/, "$1/");
    }
}
Util.Fvtt = class {
    static getOwnershipEnum({isIncludeDefault=false}={}) {
        return [isIncludeDefault ? {
            value: -1,
            name: "Default"
        } : null, ...Object.entries(CONST.DOCUMENT_OWNERSHIP_LEVELS).map(([name,value])=>({
            value,
            name: name.toTitleCase(),
        })), ].filter(Boolean);
    }

    static getMinimumRolesEnum() {
        return [...Object.entries(CONST.USER_ROLES).map(([name,value])=>({
            value,
            name: name.toTitleCase(),
        })), {
            value: CONST.USER_ROLES.GAMEMASTER + 1,
            name: `Cheater (Disable Feature)`,
        }, ];
    }

    static canUserCreateFolders() {
        return game.user.isGM;
    }
}
;
//#endregion
//#region UtilCompat
class UtilCompat {
    static isModuleActive(moduleId) {
        return !!game.modules.get(moduleId)?.active;
    }

    static _MODULE_LIB_WRAPPER = "lib-wrapper";
    static MODULE_DAE = "dae";
    static _MODULE_DRAG_UPLOAD = "dragupload";
    static MODULE_MIDI_QOL = "midi-qol";
    static MODULE_KANKA_FOUNDRY = "kanka-foundry";
    static MODULE_SMOL_FOUNDRY = "smol-foundry";
    static MODULE_PERMISSION_VIEWER = "permission_viewer";
    static _MODULE_TWILIGHT_UI = "twilight-ui";
    static MODULE_TIDY5E_SHEET = "tidy5e-sheet";
    static _MODULE_OBSIDIAN = "obsidian";
    static MODULE_BABELE = "babele";
    static MODULE_MONKS_LITTLE_DETAILS = "monks-little-details";
    static MODULE_MONKS_BLOODSPLATS = "monks-bloodsplats";
    static MODULE_MONKS_ENHANCED_JOURNAL = "monks-enhanced-journal";
    static MODULE_BETTER_ROLLTABLES = "better-rolltables";
    static _MODULE_BETTER_ROLLTABLES = "item-piles";
    static MODULE_PLUTONIUM_ADDON_AUTOMATION = "plutonium-addon-automation";
    static MODULE_LEVELS = "levels";
    static MODULE_MULTICLASS_SPELLBOOK_FILTER = "spell-class-filter-for-5e";
    static MODULE_ROLLDATA_AWARE_ACTIVE_EFFECTS = "fvtt-rolldata-aware-active-effects";
    static MODULE_QUICK_INSERT = "quick-insert";
    static MODULE_PF2E_TOKENS_BESTIARIES = "pf2e-tokens-bestiaries";
    static _MODULE_DFREDS_CONVENIENT_EFFECTS = "dfreds-convenient-effects";
    static MODULE_LEVELS_3D_PREVIEW = "levels-3d-preview";
    static _MODULE_CANVAS_3D_COMPENDIUM = "canvas3dcompendium";
    static _MODULE_CANVAS_3D_TOKEN_COMPENDIUM = "canvas3dtokencompendium";
    static _MODULE_FOUNDRY_SUMMONS = "foundry-summons";
    static _MODULE_TOKEN_ACTION_HUD = "token-action-hud";
    static _MODULE_TOKEN_ACTION_HUD_CORE = "token-action-hud-core";
    static MODULE_SIMPLE_CALENDAR = "foundryvtt-simple-calendar";

    static isLibWrapperActive() {
        return this.isModuleActive(UtilCompat._MODULE_LIB_WRAPPER);
    }
    static isDaeActive() {
        return this.isModuleActive(UtilCompat.MODULE_DAE);
    }
    static isDragUploadActive() {
        return this.isModuleActive(UtilCompat._MODULE_DRAG_UPLOAD);
    }
    static isPermissionViewerActive() {
        return this.isModuleActive(UtilCompat.MODULE_PERMISSION_VIEWER);
    }
    static isSmolFoundryActive() {
        return this.isModuleActive(UtilCompat.MODULE_SMOL_FOUNDRY);
    }
    static isTwilightUiActive() {
        return this.isModuleActive(UtilCompat._MODULE_TWILIGHT_UI);
    }
    static isTidy5eSheetActive() {
        return this.isModuleActive(UtilCompat.MODULE_TIDY5E_SHEET);
    }
    static isObsidianActive() {
        return this.isModuleActive(UtilCompat._MODULE_OBSIDIAN);
    }
    static isBabeleActive() {
        return this.isModuleActive(UtilCompat.MODULE_BABELE);
    }
    static isMonksLittleDetailsActive() {
        return this.isModuleActive(UtilCompat.MODULE_MONKS_LITTLE_DETAILS);
    }
    static isMonksBloodsplatsActive() {
        return this.isModuleActive(UtilCompat.MODULE_MONKS_BLOODSPLATS);
    }
    static isBetterRolltablesActive() {
        return this.isModuleActive(UtilCompat.MODULE_BETTER_ROLLTABLES);
    }
    static isItemPilesActive() {
        return this.isModuleActive(UtilCompat._MODULE_BETTER_ROLLTABLES);
    }
    static isPlutoniumAddonAutomationActive() {
        return this.isModuleActive(UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION);
    }
    static isMidiQolActive() {
        return this.isModuleActive(UtilCompat.MODULE_MIDI_QOL);
    }
    static isModuleMulticlassSpellbookFilterActive() {
        return this.isModuleActive(UtilCompat.MODULE_MULTICLASS_SPELLBOOK_FILTER);
    }
    static isQuickInsertActive() {
        return this.isModuleActive(UtilCompat.MODULE_QUICK_INSERT);
    }
    static isPf2eTokensBestiaryActive() {
        return this.isModuleActive(UtilCompat.MODULE_PF2E_TOKENS_BESTIARIES);
    }
    static isDfredsConvenientEffectsActive() {
        return this.isModuleActive(UtilCompat._MODULE_DFREDS_CONVENIENT_EFFECTS);
    }
    static isLevels3dPreviewActive() {
        return this.isModuleActive(UtilCompat.MODULE_LEVELS_3D_PREVIEW);
    }
    static _isCanvas3dCompendiumActive() {
        return this.isModuleActive(UtilCompat._MODULE_CANVAS_3D_COMPENDIUM);
    }
    static _iCanvas3dTokenCompendiumActive() {
        return this.isModuleActive(UtilCompat._MODULE_CANVAS_3D_TOKEN_COMPENDIUM);
    }
    static isFoundrySummonsActive() {
        return this.isModuleActive(UtilCompat._MODULE_FOUNDRY_SUMMONS);
    }
    static isTokenActionHudActive() {
        return this.isModuleActive(UtilCompat._MODULE_TOKEN_ACTION_HUD) || this.isModuleActive(UtilCompat._MODULE_TOKEN_ACTION_HUD_CORE);
    }
    static isSimpleCalendarActive() {
        return this.isModuleActive(UtilCompat.MODULE_SIMPLE_CALENDAR);
    }

    static isThreeDiTokensActive() {
        return this.isLevels3dPreviewActive() && this._isCanvas3dCompendiumActive() && this._iCanvas3dTokenCompendiumActive();
    }

    static getApi(moduleName) {
        if (!this.isModuleActive(moduleName))
            return null;
        return game.modules.get(moduleName).api;
    }

    static getName(moduleName) {
        if (!this.isModuleActive(moduleName))
            return null;
        return game.modules.get(moduleName).title;
    }

    static isDaeGeneratingArmorEffects() {
        if (!this.isDaeActive())
            return false;
        return !!UtilGameSettings.getSafe(UtilCompat.MODULE_DAE, "calculateArmor");
    }

    static getFeatureFlags({isReaction}) {
        const out = {};

        if (isReaction) {
            out.adnd5e = {
                itemInfo: {
                    type: "reaction"
                }
            };
        }

        return out;
    }

    static MonksLittleDetails = class {
        static isDefeated(token) {
            return ((token.combatant && token.isDefeated) || token.actor?.effects.some(it=>it.statuses.has(CONFIG.specialStatusEffects.DEFEATED)) || token.document.overlayEffect === CONFIG.controlIcons.defeated);
        }
    }
    ;

    static DfredsConvenientEffects = class {
        static getCustomEffectsItemId() {
            return UtilGameSettings.getSafe(UtilCompat._MODULE_DFREDS_CONVENIENT_EFFECTS, "customEffectsItemId");
        }
    }
    ;

    static FoundrySummons = class {
        static getBlankNpcIds() {
            return (UtilGameSettings.getSafe(UtilCompat._MODULE_FOUNDRY_SUMMONS, "blankNPC") || []).map(it=>it?.id).filter(Boolean);
        }
    }
    ;
}
//#endregion
//#region ConfigConsts
class ConfigConsts {
    static ["_flushCaches"]() {
      this._DEFAULT_CONFIG = null;
      this._DEFAULT_CONFIG_SORTED = null;
      this._DEFAULT_CONFIG_SORTED_FLAT = null;
    }
    static ['_IMPORTERS'] = {};
    static ["registerImporter"]({
      id: _0x17cd9e,
      name: _0x948c81
    }) {
      this._IMPORTERS[_0x17cd9e] = _0x948c81;
      this._flushCaches();
    }
    static ["_template_getImporterToggles"]() {
      return {
        'hiddenImporterIds': {
          'name': "Hidden Importers",
          'help': "Importers which should not be shown in the Import Wizard UI.",
          'default': {
            'background-features': true,
            'race-and-subrace-features': true
          },
          'type': 'multipleChoice',
          'choices': Object.entries(this._IMPORTERS).map(([_0x40fcfd, _0x286521]) => ({
            'name': _0x286521,
            'value': _0x40fcfd
          })).sort(({
            name: _0x5ca503
          }, {
            name: _0x44f71d
          }) => SortUtil.ascSortLower(_0x5ca503, _0x44f71d))
        }
      };
    }
    static ['_getModelBarAttributes'](_0x2c6d2c) {
      if (!_0x2c6d2c) {
        return [];
      }
      return Object.values(TokenDocument.implementation.getTrackedAttributeChoices(TokenDocument.implementation.getTrackedAttributes(_0x2c6d2c))).flat();
    }
    static ['_template_getEntityOwnership'](_0x1b27c6) {
      const _0x2971c8 = MiscUtil.copy(ConfigConsts._TEMPLATE_ENTITY_OWNERSHIP);
      _0x2971c8.values = Util.Fvtt.getOwnershipEnum();
      _0x2971c8.help = _0x1b27c6;
      return _0x2971c8;
    }
    static ["_template_getTokenSettings"]({
      actorType: _0x1701bd
    }) {
      return {
        'tokenNameDisplay': {
          'name': "Token Name Display Mode",
          'help': "The default Display Name mode for imported tokens.",
          'default': 0x14,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...Object.entries({
            ...CONST.TOKEN_DISPLAY_MODES
          }).sort(([, _0x11b4dd], [, _0x418ae3]) => SortUtil.ascSort(_0x11b4dd, _0x418ae3)).map(([_0x1c91ac, _0x536776]) => ({
            'value': _0x536776,
            'fnGetName': () => game.i18n.localize('TOKEN.DISPLAY_' + _0x1c91ac)
          }))]
        },
        'tokenDisposition': {
          'name': "Token Disposition",
          'help': "The default Token Disposition mode for imported tokens.",
          'default': -0x1,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...Object.entries(CONST.TOKEN_DISPOSITIONS).sort(([, _0x153b2c], [, _0x397446]) => SortUtil.ascSort(_0x153b2c, _0x397446)).map(([_0x2e1787, _0x29a452]) => ({
            'value': _0x29a452,
            'fnGetName': () => game.i18n.localize("TOKEN.DISPOSITION." + _0x2e1787)
          }))]
        },
        'tokenLockRotation': {
          'name': "Token Lock Rotation",
          'help': "The default Lock Rotation mode for imported tokens.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenIsAddVision': {
          'name': "Enable Token Vision",
          'help': "Enable vision for tokens.",
          'default': ConfigConsts.C_BOOL_ENABLED,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_BOOL_DISABLED,
            'name': "Disabled"
          }, {
            'value': ConfigConsts.C_BOOL_ENABLED,
            'name': 'Enabled'
          }]
        },
        'tokenSightRange': {
          'name': "Token Vision Range",
          'help': "How token Vision Range should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenSightVisionMode': {
          'name': "Token Vision Mode",
          'help': "How token Vision Mode should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenSightAngle': {
          'name': "Token Sight Angle",
          'help': "How token Sight Angle (Degrees) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenDetectionModes': {
          'name': "Token Detection Modes",
          'help': "How token Detection Modes should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenVisionSaturation': {
          'name': "Token Vision Saturation",
          'help': "How token vision Saturation should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenDimLight': {
          'name': "Token Dim Light Radius",
          'help': "How token Dim Light Radius (Distance) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenBrightLight': {
          'name': "Token Bright Light Radius",
          'help': "How token Bright Light Radius (Distance) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAngle': {
          'name': "Token Light Emission Angle",
          'help': "How token Light Emission (Angle) should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightColor': {
          'name': "Token Light Color",
          'help': "How token Light Color should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAlpha': {
          'name': "Token Light Intensity",
          'help': "How token Color Intensity should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAnimationType': {
          'name': "Token Light Animation Type",
          'help': "How token Light Animation Type should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAnimationSpeed': {
          'name': "Token Light Animation Speed",
          'help': "How token Light Animation Speed should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': "enum",
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenLightAnimationIntensity': {
          'name': "Token Light Animation Intensity",
          'help': "How token Light Animation Intensity should be set.",
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }]
        },
        'tokenBarDisplay': {
          'name': "Token Bar Display Mode",
          'help': "The default Display Bars mode for imported tokens.",
          'default': 0x28,
          'type': 'enum',
          'values': [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, {
            'value': 0x0,
            'name': "None"
          }, {
            'value': 0xa,
            'name': 'Control'
          }, {
            'value': 0x14,
            'name': "Owner Hover"
          }, {
            'value': 0x1e,
            'name': 'Hover'
          }, {
            'value': 0x28,
            'name': 'Owner'
          }, {
            'value': 0x32,
            'name': "Always"
          }]
        },
        'tokenBar1Attribute': {
          'name': "Token Bar 1 Attribute",
          'help': "The default token bar 1 attribute for imported tokens.",
          'default': "attributes.hp",
          'type': "enum",
          'values': () => [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...ConfigConsts._getModelBarAttributes(_0x1701bd)],
          'isNullable': true
        },
        'tokenBar2Attribute': {
          'name': "Token Bar 2 Attribute",
          'help': "The default token bar 2 attribute for imported tokens.",
          'default': null,
          'type': "enum",
          'values': () => [{
            'value': ConfigConsts.C_USE_GAME_DEFAULT,
            'name': "Use game setting"
          }, ...ConfigConsts._getModelBarAttributes(_0x1701bd)],
          'isNullable': true
        },
        'tokenScale': {
          'name': "Token Scale",
          'help': "The default token scale for imported tokens.",
          'default': null,
          'type': "number",
          'placeholder': "(Use default)",
          'min': 0.2,
          'max': 0x3,
          'isNullable': true
        },
        'isTokenMetric': {
          'name': "Convert Token Vision Ranges to Metric",
          'help': "Whether or not token vision range units should be converted to an approximate metric equivalent (5 feet ≈ 1.5 metres).",
          'default': false,
          'type': "boolean"
        }
      };
    }
    static ["_template_getSceneImportSettings"]() {
      return {
        'scenePadding': {
          'name': "Scene Padding",
          'help': "The amount of scene padding to apply when creating a scene.",
          'default': 0x0,
          'type': "number",
          'min': 0x0,
          'max': 0.5
        },
        'sceneBackgroundColor': {
          'name': "Scene Background Color",
          'help': "The background color to apply when creating a scene.",
          'default': "#222222",
          'type': "color"
        },
        'isSceneTokenVision': {
          'name': "Scene Token Vision",
          'help': "Whether or not token vision should be enabled for a created scene.",
          'default': true,
          'type': "boolean"
        },
        'isSceneFogExploration': {
          'name': "Scene Fog Exploration",
          'help': "Whether or not fog exploration should be enabled for a created scene.",
          'default': true,
          'type': "boolean"
        },
        'isSceneAddToNavigation': {
          'name': "Add Scenes to Navigation",
          'help': "Whether or not a created scene should be added to the navigation bar.",
          'default': false,
          'type': "boolean"
        },
        'isSceneGenerateThumbnail': {
          'name': "Generate Scene Thumbnails",
          'help': "Whether or not a thumbnail should be generated for a created scene. Note that this greatly slows down the scene creation process.",
          'default': true,
          'type': "boolean"
        },
        'isSceneGridMetric': {
          'name': "Convert Scene Grid Distances to Metric",
          'help': "Whether or not scene grid distances should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + "; " + ConfigConsts._DISP_METRIC_MILES + ').',
          'default': false,
          'type': "boolean"
        }
      };
    }
    static ["_template_getActiveEffectsDisabledTransferSettings"]({
      name: _0x535a83
    }) {
      return {
        'setEffectDisabled': {
          'name': "Override Effect &quot;Disabled&quot; Value",
          'help': "If set, overrides the \"Disabled\" value present on any effects tied to imported " + _0x535a83 + '.',
          'type': 'enum',
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'compatibilityModeValues': {
            [UtilCompat.MODULE_MIDI_QOL]: {
              'value': ConfigConsts.C_USE_PLUT_VALUE,
              'name': "Allow importer to set"
            }
          },
          'values': [{
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }, {
            'value': ConfigConsts.C_BOOL_DISABLED,
            'name': "Set to \"False\""
          }, {
            'value': ConfigConsts.C_BOOL_ENABLED,
            'name': "Set to \"True\""
          }]
        },
        'setEffectTransfer': {
          'name': "Override Effect &quot;Transfer&quot; Value",
          'help': "If set, overrides the \"Transfer to Actor\" value present on any effects tied to imported " + _0x535a83 + '.',
          'type': 'enum',
          'default': ConfigConsts.C_USE_PLUT_VALUE,
          'compatibilityModeValues': {
            [UtilCompat.MODULE_MIDI_QOL]: {
              'value': ConfigConsts.C_USE_PLUT_VALUE,
              'name': "Allow importer to set"
            }
          },
          'values': [{
            'value': ConfigConsts.C_USE_PLUT_VALUE,
            'name': "Allow importer to set"
          }, {
            'value': ConfigConsts.C_BOOL_DISABLED,
            'name': "Set to \"False\""
          }, {
            'value': ConfigConsts.C_BOOL_ENABLED,
            'name': "Set to \"True\""
          }]
        }
      };
    }
    static ["_template_getMinimumRole"]({
      name: _0x2cb847,
      help: _0x713a
    }) {
      const _0xdadcbd = MiscUtil.copy(ConfigConsts._TEMPALTE_MINIMUM_ROLE);
      _0xdadcbd.values = Util.Fvtt.getMinimumRolesEnum();
      _0xdadcbd.name = _0x2cb847;
      _0xdadcbd.help = _0x713a;
      return _0xdadcbd;
    }
    static ['_template_getModuleFauxCompendiumIndexSettings']({
      moduleName: _0x5afcb7
    }) {
      return {
        'isEnabled': {
          'name': "Enabled",
          'help': "If enabled, and the " + _0x5afcb7 + " module is active, Plutonium content will be indexed by " + _0x5afcb7 + '.',
          'default': true,
          'type': "boolean",
          'isReloadRequired': true
        },
        'isFilterSourcesUa': {
          'name': "Exclude UA/etc.",
          'help': "If Unearthed Arcana and other unofficial source content should be excluded from the index.",
          'default': true,
          'type': "boolean",
          'isReloadRequired': true
        }
      };
    }
    static ["_template_getActorImportOverwriteSettings"]() {
      return {
        'isDisableActorOverwriteWarning': {
          'name': "Disable Actor Overwrite Warning",
          'help': "Disable the warning confirmation dialogue shown when importing to an existing actor.",
          'default': false,
          'type': "boolean",
          'isPlayerEditable': true
        }
      };
    }
    static ["_template_getTargetTemplatePrompt"]({
      namePlural: _0x1f80cf
    }) {
      return {
        'isTargetTemplatePrompt': {
          'name': "Enable &quot;Template Prompt&quot;s",
          'help': "If enabled, the \"Template Prompt\" option will be set on imported " + _0x1f80cf + '.',
          'default': true,
          'type': "boolean",
          'isPlayerEditable': true
        }
      };
    }
    static ["_DEFAULT_CONFIG"] = null;
    static ["getDefaultConfig_"]() {
      return this._DEFAULT_CONFIG = this._DEFAULT_CONFIG || {
        'ui': {
          'name': 'UI',
          'settings': {
            'isStreamerMode': {
              'name': "Streamer Mode",
              'help': "Remove identifiable 5etools/Plutonium references from the UI, and replaces them with \"SRD Enhanced.\"",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true,
              'isPlayerEditable': true
            },
            'isShowPopout': {
              'name': "Enable Sheet Popout Buttons",
              'help': "Add a \"Popout\" button to sheet headers, which opens the sheet as a popup browser window.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isCompactWindowBar': {
              'name': "Compact Header Buttons",
              'help': "Re-style header buttons to better support the compact, no-text buttons used by Plutonium.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactDirectoryButtons': {
              'name': "Compact Directory Buttons",
              'help': "Reduce the height of \"Create X\"/\"Create Folder\" buttons in the directory, to offset the additional space requirements of Plutonium's UI.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactChat': {
              'name': "Compact Chat",
              'help': "Make various tweaks to the appearance of chat, in order to fit more on-screen. Hold down SHIFT while hovering over a message to expand it, revealing its header and delete button.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactScenes': {
              'name': "Compact Scenes Directory",
              'help': "Reduce the height of scene thumbnails in the Scenes Directory, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactActors': {
              'name': "Compact Actors Directory",
              'help': "Reduce the height of Actors Directory directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactItems': {
              'name': "Compact Items Directory",
              'help': "Reduce the height of Items Directory directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactJournal': {
              'name': "Compact Journal Entries",
              'help': "Reduce the height of Journal Entries directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactTables': {
              'name': "Compact Rollable Tables",
              'help': "Reduce the height of Rollable Tables directory items, to fit more on-screen.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isCompactCards': {
              'name': "Compact Card Stacks",
              'help': "Reduce the height of Card Stacks directory items, to fit more on-screen.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isCompactCompendiums': {
              'name': "Compact Compendium Packs",
              'help': "Reduce the height of Compendium Packs directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isCompactMacros': {
              'name': "Compact Macros",
              'help': "Reduce the height of Macro directory items, to fit more on-screen.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isHidePlutoniumDirectoryButtons': {
              'name': "Hide Directory Buttons",
              'help': "Hide the Plutonium directory buttons.",
              'default': false,
              'type': 'boolean'
            },
            'isNameTabFromScene': {
              'name': "Prepend Active Scene Name to Browser Tab Name",
              'help': "Sets the browser tab name to be that of the currently-active scene.",
              'default': true,
              'type': 'boolean'
            },
            'tabNameSuffix': {
              'name': "Tab Name Suffix",
              'help': "Requires the \"Name Browser Tab After Active Scene\" option to be enabled. A custom name suffix to append to the scene name displayed in the tab (separated by a Foundry-style bullet character).",
              'default': null,
              'isNullable': true,
              'type': "string"
            },
            'isDisplayBackendStatus': {
              'name': "Display Detected Backend",
              'help': "Adds a cool green hacker tint to the Foundry \"anvil\" logo in the top-left corner of the screen if Plutonium's backend is detected.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isExpandActiveEffectConfig': {
              'name': "Enhance Active Effect Config UI",
              'help': "Adds a list of potential active effect attribute keys to the Configure Active Effect window's \"Effects\" tab, and a field for configuring priority.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_DAE]: false
              }
            },
            'isAddDeleteToSceneNavOptions': {
              'name': "Add \"Delete\" to Navbar Scene Context Menu",
              'help': "Adds a \"Delete\" option to the context menu found when right-clicking a scene in the navigation bar. Note that this does not include the currently-active scene.",
              'default': true,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'isHideGmOnlyConfig': {
              'name': "Hide GM-Only Config",
              'help': "If enabled, a player viewing the config will see only the limited subset of settings they are allowed to modify. If disabled, a player viewing the config will see all settings, regardless of whether or not they can modify those settings.",
              'default': true,
              'type': 'boolean'
            },
            'isDisableLargeImportWarning': {
              'name': "Disable Large Import Warning",
              'help': "Disable the warning confirmation dialogue shown when importing a large number of entities.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          },
          'settingsHacks': {
            'isFastAnimations': {
              'name': "Fast Animations",
              'help': "Increase the speed of various UI animations.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isFastTooltips': {
              'name': "Fast Tooltips",
              'help': "Increase the speed of tooltip animations, and reduce the delay before tooltips appear.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isFixEscapeKey': {
              'name': "Fix ESC Key",
              'help': "Bind the \"Escape\" key to (in this order): de-select active input fields; de-select selected canvas elements; close context menus; close individual windows in most-recently-active-first order; toggle the main menu.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isAddOpenMainMenuButtonToSettings': {
              'name': "Add \"Open Game Menu\" Button if &quot;Fix ESC Key&quot; Is Enabled",
              'help': "Add an alternate \"Open Game Menu\" button to the Settings tab if the \"Fix ESC Key\" Config option is enabled. This allows you to quickly open the main menu without first having to close all open windows.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isFixDrawingFreehandMinDistance': {
              'name': "Fix Freehand Drawing Minimum Distance",
              'help': "Reduce the minimum mouse movement distance required to start a freehand drawing.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isEnableIncreasedFolderDepth': {
              'name': "Render >3 Levels of Folder Nesting",
              'help': "If enabled, Foundry's default folder nesting limit (of 3) will be bypassed, for the purpose of rendering directories. Note that this does not necessarily allow you to create additionally-nested folders without using the game API.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_BETTER_ROLLTABLES]: false
              }
            },
            'isEnableFolderNameWrap': {
              'name': "Wrap Long Folder Names",
              'help': "Wrap long folder names over multiple lines, instead of clipping the name.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isEnableSubPopouts': {
              'name': "Allow Popout Chaining",
              'help': "Automatically pop out apps opened from within popped-out apps. If disabled, apps opened from within popped-out apps will appear in the main window, instead.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isSuppressMissingRollDataNotifications': {
              'name': "Suppress &quot;Missing Roll Data&quot; Notifications",
              'help': "If enabled, notification warning  messages of the form \"The attribute <X> was not present in the provided roll data.\" will be suppressed, and logged as console warnings instead.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isLazyActorAndItemRendering': {
              'name': "Minimize Actor/Item Re-Renders",
              'help': "If enabled, actor/item sheet re-rendering will be skipped where possible. This may reduce UI flickering, and may reduce unexpected input deselection when tabbing or clicking through fields. It may also horribly break your game, and is not expected to work with anything except default dnd5e sheets. Use with caution.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true,
              'isReloadRequired': true
            },
            'isAlwaysResizableApps': {
              'name': "Default Resizeable Applications",
              'help': "If enabled, applications will be resizeable by default. Note that specific applications may still override this.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          }
        },
        'tokens': {
          'name': 'Tokens',
          'settings': {
            'isDisplayDamageDealt': {
              'name': "Display Missing Health",
              'help': "This allows players to see \"damage dealt\" to a token, without revealing the token's total health. If enabled, each token's missing health is displayed as a number in the bottom-right corner of the token.",
              'default': false,
              'type': "boolean"
            },
            'damageDealtBloodiedThreshold': {
              'name': "Display Missing Health &quot;Wounded&quot; Threshold",
              'help': "The health-loss threshold at which the Missing Health text turns red.",
              'default': 0.5,
              'type': "percentage",
              'min': 0x0,
              'max': 0x1
            },
            'isDamageDealtBelowToken': {
              'name': "Missing Health Below Token",
              'help': "If the Missing Health text should be displayed beneath a token, rather than as an overlay.",
              'default': false,
              'type': 'boolean'
            },
            'nameplateFontSizeMultiplier': {
              'name': "Font Size Multiplier",
              'help': "A multiplier which is applied to token nameplate/tooltip font size, e.g. a value of \"0.5\" will decrease token nameplate/tooltip font size by half.",
              'default': null,
              'type': "number",
              'placeholder': "(Use default)",
              'min': 0.1,
              'max': 0xa,
              'isNullable': true
            },
            'isAllowNameplateFontWrap': {
              'name': "Allow Text Wrap",
              'help': "If enabled, token nameplate/tooltip text will wrap.",
              'default': ConfigConsts.C_USE_GAME_DEFAULT,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_USE_GAME_DEFAULT,
                'name': "Use Foundry default"
              }, {
                'value': false,
                'name': "Disabled"
              }, {
                'value': true,
                'name': 'Enabled'
              }]
            },
            'nameplateFontWrapWidthMultiplier': {
              'name': "Text Wrap Max Width Multiplier",
              'help': "A multiplier which is applied to token nameplate/tooltip text wrapping maximum size, e.g. a value of \"0.5\" will force token nameplates/tooltips to wrap at half their usual length. The base value to which this multiplier is applied is: \"2.5 × token width\".",
              'default': null,
              'type': "number",
              'placeholder': "(Use default)",
              'min': 0.1,
              'max': 0xa,
              'isNullable': true
            },
            'isNameplateOnToken': {
              'name': "Move Token Name Onto Token",
              'help': "If a token's name should be displayed on the token, rather than below it.",
              'default': false,
              'type': "boolean"
            },
            'npcHpRollMode': {
              'name': "NPC HP Roll Mode",
              'help': "Determines whether or not token HP, for NPC tokens which are not linked to their actor's data, should be rolled upon token creation. If a mode other than \"None\" is selected, and the token has a valid HP dice formula, the token will roll for HP. For example, a Goblin (7 HP; formula is 2d6) could be created with anywhere between 2 and 12 HP (inclusive).",
              'default': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE,
              'type': 'enum',
              'values': [{
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE,
                'name': "None",
                'help': "Do not roll NPC token health."
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_STANDARD,
                'name': "Standard Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_GM,
                'name': "GM Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_BLIND,
                'name': "Blind Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_SELF,
                'name': "Self Roll"
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_HIDDEN,
                'name': "Hidden Roll",
                'help': "Roll NPC token health, but do not post the result to chat."
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MIN,
                'name': "Minimum Value",
                'help': "Use the minimum possible roll value."
              }, {
                'value': ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MAX,
                'name': "Maximum Value",
                'help': "Use the maximum possible roll value."
              }]
            },
            'isDisableAnimations': {
              'name': "Disable Animations",
              'help': "Disable token animations.",
              'default': false,
              'type': "boolean"
            },
            'animationSpeedMultiplier': {
              'name': "Animation Speed",
              'help': "Multiplies token animation movement speed by the factor provided.",
              'default': null,
              'type': "number",
              'isNullable': true,
              'min': 0.1,
              'max': 0xa
            }
          },
          'settingsAdvanced': {
            'missingHealthAttribute': {
              'name': "Health Attribute",
              'help': "The sheet attribute used to fetch current/max health when the \"Display Missing Health\" option is enabled.",
              'default': "attributes.hp",
              'type': "string",
              'additionalStyleClasses': "code"
            }
          },
          'settingsHacks': {
            'isIgnoreDisableAnimationsForWaypointMovement': {
              'name': "Avoid Disabling Animations for Ruler Movement",
              'help': "Suppresses the \"Disable Animations\" option for a token being moved via ruler waypoints (i.e. when CTRL-dragging from a token and pressing SPACE). Note that dismissing the ruler during the move will end this suppression.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'import': {
          'name': "Import",
          'settings': {
            'isAddSourceToName': {
              'name': "Add Source to Names",
              'help': "If the source of each imported entry (e.g. \"MM\" for Monster Manual) should be appended to the name of the entry.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isRenderLinksAsTags': {
              'name': "Render Links as &quot;@tag&quot;s",
              'help': "If links found in description text should be rendered as Plutonium-specific @tag syntax, e.g. a link to \"goblin\" would be rendered as \"@creature[goblin|mm]\". (By default, a link to the 5etools page will be rendered instead.)",
              'default': true,
              'type': 'boolean'
            },
            'isRendererLinksDisabled': {
              'name': "Disable 5etools Links",
              'help': "Prevents links to other 5etools content from being added to the text of imported 5etools content.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isRendererDiceDisabled': {
              'name': "Render Dice as Plain Text",
              'help': "Forces dice expressions, usually rendered as \"[[/r XdY + Z ...]]\", to be rendered as plain text when importing 5etools content.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isRenderCustomDiceEnrichers': {
              'name': "Render Dice as Custom Enrichers",
              'help': "If enabled, importers will make use of dnd5e-specific custom enrichers when rendering dice. For example, damage rolls may be rendered as \"[[/damage ...]]\" instead of \"[[/r ...]]\", changing the on-click behaviour.",
              'default': true,
              'type': 'boolean'
            },
            'deduplicationMode': {
              'name': "Duplicate Handling Mode",
              'help': "Determines what action is taken when importing duplicate content to a directory or compendium. An entity is considered a duplicate if and only if its name and source match an existing entity. Note that this does not function when importing to actor sheets.",
              'default': ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE,
                'name': "None",
                'help': "No deduplication is done."
              }, {
                'value': ConfigConsts.C_IMPORT_DEDUPE_MODE_SKIP,
                'name': "Skip duplicates",
                'help': "If a duplicate is found for a would-be imported entity, that entity is not imported."
              }, {
                'value': ConfigConsts.C_IMPORT_DEDUPE_MODE_OVERWRITE,
                'name': "Update existing",
                'help': "If a duplicate is found for a would-be import entity, the existing entity is updated."
              }]
            },
            'isDuplicateHandlingMaintainImage': {
              'name': "Maintain Images when Overwriting Duplicates",
              'help': "If enabled, sheet and token images will be maintained when overwriting an existing document in \"Update Existing\" Duplicate Handling Mode.",
              'default': false,
              'type': 'boolean'
            },
            /* 'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Import",
              'help': "\"Import\" buttons will be hidden for any user with a role less than the chosen role."
            }), */
            'dragDropMode': {
              'name': "Use Importer when Drag-Dropping Items to Actors",
              'help': "Some Foundry items (backgrounds, races, spells, items, etc.), when imported via Plutonium and later drag-dropped to an actor sheet, have special handling allowing for greater functionality (such as populating skills and features). This allows you to control whether or not that special handling is used, rather than the baseline Foundry drag-drop. Note that if you modify an item, the changes will not be reflected in the version imported to the sheet by Plutonium.",
              'default': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_NEVER,
                'name': "Never"
              }, {
                'value': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT,
                'name': "Prompt"
              }, {
                'value': ConfigConsts.C_IMPORT_DRAG_DROP_MODE_ALWAYS,
                'name': "Always"
              }],
              'isPlayerEditable': true
            },
            'isUseOtherFormulaFieldForSaveHalvesDamage': {
              'name': "Treat &quot;Save Halves&quot; Additional Attack Damage as &quot;Other Formula&quot;",
              'help': "This moves extra attack damage rolls (for example, the poison damage done by a Giant Spider's bite) to the \"Other Formula\" dice field, which can improve compatibility with some modules.",
              'default': false,
              'type': 'boolean',
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isUseOtherFormulaFieldForOtherDamage': {
              'name': "Treat &quot;Alternate&quot; Attack Damage as &quot;Other Formula&quot;",
              'help': "This moves alternate non-versatile attack damage rolls (for example, Egg Hunter Hatchling's &quot;Egg Tooth&quot; damage when targeting an object) to the \"Other Formula\" dice field, which can improve compatibility with some modules.",
              'default': false,
              'type': 'boolean',
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isGlobalMetricDistance': {
              'name': "Prefer Metric Distance/Speed (Where Available)",
              'help': "If enabled, metric distance/speed units will be preferred, where the importer supports them. Enabling this option effectively overrides all other metric distance/speed options, causing the importer to treat each as though it was enabled.",
              'default': false,
              'type': 'boolean'
            },
            'isGlobalMetricWeight': {
              'name': "Prefer Metric Weight (Where Available)",
              'help': "If enabled, metric weight units will be preferred, where the importer supports them. Enabling this option effectively overrides all other metric weight options, causing the importer to treat each as though it was enabled.",
              'default': false,
              'type': "boolean"
            },
            'isShowVariantsInLists': {
              'name': "Show Variants/Versions",
              'help': "If variants/versions of base entries should be shown in list views (with grayed-out names).",
              'default': true,
              'type': "boolean"
            },
            'isSaveImagesToServer': {
              'name': "Save Imported Images to Server",
              'help': "If images referenced in imported content should be saved to your server files, rather than referenced from an external server.",
              'default': false,
              'type': "boolean"
            },
            'isSaveTokensToServer': {
              'name': "Save Imported Tokens to Server",
              'help': "If tokens for imported actors should be saved to your server files, rather than referenced from an external server.",
              'default': true,
              'type': "boolean"
            },
            'localImageDirectoryPath': {
              'name': "Image/Token Directory",
              'help': "The sub-directory of the \"User Data\" directory where imported images/tokens will be saved to when using the \"Save Imported Images to Server\" option or the \"Save Imported Tokens to Server\" option. If the \"Use Local Images\" option is enabled, images will be loaded from this directory by default.",
              'default': "assets/" + SharedConsts.MODULE_ID_FAKE,
              'type': "string",
              'additionalStyleClasses': 'code'
            },
            'isPreferFoundryImages': {
              'name': "Prefer Foundry/System Images",
              'help': "If enabled, portraits for actors and images for items will be sourced from built-in compendiums first, then Plutonium second. If disabled, portraits/images will be sourced from Plutonium first, then built-in compendiums second.",
              'default': false,
              'type': "boolean"
            },
            'isPreferFoundryTokens': {
              'name': "Prefer Foundry/System Tokens",
              'help': "If enabled, tokens will be sourced from built-in compendiums first, then Plutonium second. If disabled, tokens will be sourced from Plutonium first, then built-in compendiums second.",
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getImporterToggles(),
            'isTreatJournalEntriesAsFolders': {
              'name': "Treat Journal Entries as Folders",
              'help': "If enabled, Journal Entries are treated as an additional folder level for the purpose of organising imports, etc.",
              'default': true,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isUseLocalImages': {
              'name': "Use Local Images",
              'help': "If enabled, images will be sourced from the \"Image/Token Directory\" directory, defined above.",
              'default': false,
              'type': 'boolean'
            },
            'isStrictMatching': {
              'name': "Use Strict Entity Matching",
              'help': "If enabled, any Plutonium feature which searches for existing data (for example, the class importer attempting to find existing class levels in a given class) will match by name and source. If disabled, only name is used.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'tempFolderName': {
              'name': "Temp Folder Name",
              'help': "The name of a temporary folder created/deleted by some operations. Note that the importer will delete this folder regardless of its contents, as anything contained within it is assumed to be a temporary entity created by the importer.",
              'type': 'string',
              'default': "Temp"
            },
            'isAutoAddAdditionalFonts': {
              'name': "Automatically Add Extra Fonts",
              'help': "If enabled, and you import content which requires additional fonts, these fonts will be added to your game's \"Additional Fonts\" setting.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importCreature': {
          'name': "Import (Creatures)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported creature."),
            'isImportBio': {
              'name': "Import Fluff to Biography",
              'help': "If enabled, any fluff text which is available for a creature will be imported into that creature's biography.",
              'default': true,
              'type': "boolean"
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Biography",
              'help': "If enabled, any fluff image which is available for a creature will be imported into that creature's biography.",
              'default': false,
              'type': 'boolean'
            },
            'isImportBioVariants': {
              'name': "Include Variants in Biography",
              'help': "If enabled, any inset variant boxes associated with a creature will be imported into that creature's biography.",
              'default': true,
              'type': "boolean"
            },
            'isImportVariantsAsFeatures': {
              'name': "Import Variants as Features",
              'help': "If enabled, any inset variant boxes associated with a creature will be imported into that creature's features.",
              'default': false,
              'type': "boolean"
            },
           /*  ...ConfigConsts._template_getTokenSettings({
              'actorType': "npc"
            }), */
            'itemWeightAndValueSizeScaling': {
              'name': "Item Weight & Value Scaling",
              'help': "The method by which to scale the weights and values of non-standard-sizes items carried by creatures.",
              'default': 0x1,
              'type': 'enum',
              'values': [{
                'value': 0x1,
                'name': "No scaling"
              }, {
                'value': 0x2,
                'name': "\"Barding\" scaling (multiplicative)",
                'help': "Based on the rules for calculating the weight and cost of barding, as presented in the Player's Handbook (p. 155)."
              }, {
                'value': 0x3,
                'name': "\"Gurt's Greataxe\" scaling (exponential)",
                'help': "Based on the giant-size greateaxe of the same name found in Storm King's Thunder (p. 234)."
              }]
            },
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not creature speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            },
            'spellcastingPrimaryTraitMode': {
              'name': "Spellcasting Primary Trait Selection Method",
              'help': "The method by which a primary spellcasting trait (i.e., the spellcasting trait used to set spellcasting ability, spell DC, and spell attack bonus) is selected if a creature has multiple spellcasting traits with associated ability scores.",
              'default': 0x1,
              'type': 'enum',
              'values': [{
                'value': 0x1,
                'name': "Highest spell count",
                'help': "Use whichever spellcasting trait has the most spells listed."
              }, {
                'value': 0x2,
                'name': "Highest ability score",
                'help': "Use whichever spellcasting trait has the highest associated ability score. Note that this may prefer innate spellcasting traits over spellcasting class levels."
              }]
            },
            'nameTags': {
              'name': "Add Tag Suffixes to Names",
              'help': "Add tags to an imported creature's name, to allow easier searching (especially within compendiums).",
              'default': {
                [ConfigConsts.C_CREATURE_NAMETAGS_CR]: false,
                [ConfigConsts.C_CREATURE_NAMETAGS_TYPE]: false,
                [ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS]: false
              },
              'type': 'multipleChoice',
              'choices': [{
                'value': ConfigConsts.C_CREATURE_NAMETAGS_CR,
                'name': "Add [CR] tag"
              }, {
                'value': ConfigConsts.C_CREATURE_NAMETAGS_TYPE,
                'name': "Add [type] tag"
              }, {
                'value': ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS,
                'name': "Add [type (with tags)] tag"
              }]
            },
            'isAddSoundEffect': {
              'name': "MLD: Add Audio as Sound Effect",
              'help': "If, when the Monk's Little Details module is active, an imported creature should have its sound effect set, where an audio clip is available (for official data, this will usually be an audio clip of the creature's name being pronounced).",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Creature Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CREATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums (Features)",
              'help': "A comma-separated list of compendiums that the Creature Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CREATURE_FEATURES.join(", "),
              'type': 'string',
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'isUseTokenImageAsPortrait': {
              'name': "Use Token Image as Portrait",
              'help': "If enabled, a creature's token image will be preferred over its portrait image when populating its sheet portrait during import.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getActorImportOverwriteSettings(),
            'isAddFakeClassToCharacter': {
              'name': "Add Class to Creatures Imported as Player Characters",
              'help': "If enabled, when importing a creature as a Player Character (\"character\"-type actor) a class item will be added to the actor's sheet, in order to set proficiency bonus and spellcasting levels.",
              'default': true,
              'type': 'boolean'
            },
            'isUseStaticAc': {
              'name': "Use Static AC Values",
              'help': "If enabled, creature AC will be imported as a static number (rather than relying on the sheet's formula calculation), and creature armor will be imported as unequipped.",
              'default': false,
              'type': "boolean"
            },
            'isUseCustomNaturalAc': {
              'name': "Use Custom Natural Armor Formula",
              'help': "If enabled, creatures with natural armor will have their armor formula broken down as \"@attributes.ac.armor + @attributes.ac.dex + <naturalBonus>\", allowing any later Dexterity score changes to be reflected in the creatures AC.",
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsHacks': {
            'isUsePathfinderTokenPackBestiariesImages': {
              'name': "Use &quot;Pathfinder Token Pack: Bestiaries&quot; Tokens/Portraits",
              'help': "If enabled, and the \"Pathfinder Token Pack: Bestiaries\" module is installed and enabled, the importer will attempt to use token and portrait art from the \"Pathfinder Token Pack: Bestiaries\" module.",
              'default': false,
              'type': "boolean"
            }
          }
        },
        'importCreatureFeature': {
          'name': "Import (Creature Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported creature feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "creature features"
            }), */
            'isSecretWrapAttacks': {
              'name': "&quot;Secret&quot; Attack Descriptions",
              'help': "If enabled, creature attack descriptions will be wrapped in \"Secret\" blocks, which are not shown when rolling.",
              'default': false,
              'type': "boolean"
            },
            'isScaleToTargetActor': {
              'name': "Scale to Target Actor CR",
              'help': "If enabled, creature features imported to existing NPC actors will be automatically scaled (altering to-hit bonuses, damage rolls, DCs, etc.) based on the difference between the original creature's CR and the target actor's CR.",
              'default': true,
              'type': 'boolean'
            },
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not creature feature range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "creature features"
            }),
            'isSplitMeleeRangedAttack': {
              'name': "Split &quot;Melee or Ranged Attack&quot; Actions",
              'help': "If enabled, the importer will create two sheet items per \"Melee or Ranged Attack\" action, each with the appropriate range set.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isSplitConditionalDamageAttack': {
              'name': "Split Conditional Damage Actions",
              'help': "If enabled, the importer will create two sheet items (\"Base\" and \"Full\") per \"... plus <x> damage if <y>\" action, where the \"base\" item does not include the conditional damage, and the \"full\" item does include the conditional damage.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isPreferFlatSavingThrows': {
              'name': "Prefer Flat Saving Throws",
              'help': "If enabled, a saving throw for a sheet item will always have \"flat\" scaling, with the flat DC value set to match the number in the creature's stat block. If disabled, a sheet item's saving throw scaling may be set as an ability score, provided that doing so produces the same value for the DC as is listed in the creature's stat block.",
              'default': false,
              'type': "boolean"
            }
          }
        },
        'importVehicle': {
          'name': "Import (Vehicles)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported vehicle."),
            ...ConfigConsts._template_getTokenSettings({
              'actorType': "vehicle"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not vehicle speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + "; " + ConfigConsts._DISP_METRIC_MILES + ').',
              'default': false,
              'type': "boolean"
            },
            'isImportBio': {
              'name': "Import Fluff to Description",
              'help': "If enabled, any fluff text which is available for a vehicle will be imported into that vehicle's description.",
              'default': true,
              'type': 'boolean'
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Description",
              'help': "If enabled, any fluff image which is available for a vehicle will be imported into that vehicle's description.",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the vehicle importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': '',
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'isUseTokenImageAsPortrait': {
              'name': "Use Token Image as Portrait",
              'help': "If enabled, a vehicle's token image will be preferred over its portrait image when populating its sheet portrait during import.",
              'default': false,
              'type': 'boolean'
            },
            ...ConfigConsts._template_getActorImportOverwriteSettings(),
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': 'vehicles'
            })
          }
        },
        'importVehicleUpgrade': {
          'name': "Import (Vehicle Upgrades)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported vehicle upgrades."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "vehicle upgrades"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not vehicle upgrade speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "vehicle upgrades"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a vehicle upgrade's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importObject': {
          'name': "Import (Objects)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported object."),
            ...ConfigConsts._template_getTokenSettings({
              'actorType': 'vehicle'
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not object speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            },
            'isImportBio': {
              'name': "Import Fluff to Description",
              'help': "If enabled, any fluff text which is available for an object will be imported into that object's description.",
              'default': true,
              'type': "boolean"
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Description",
              'help': "If enabled, any fluff image which is available for an object will be imported into that object's description.",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'isUseTokenImageAsPortrait': {
              'name': "Use Token Image as Portrait",
              'help': "If enabled, an object's token image will be preferred over its portrait image when populating its sheet portrait during import.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getActorImportOverwriteSettings()
          }
        },
        'importObjectFeature': {
          'name': "Import (Object Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported object feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "object features"
            }), */
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not object feature range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "object features"
            })
          }
        },
        'importFeat': {
          'name': "Import (Feats)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported feat."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': 'feats'
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not feat speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "feats"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a feat's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importBackground': {
          'name': "Import (Backgrounds)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported background.")
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums (Backgrounds)",
              'help': "A comma-separated list of compendiums that the background importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums (Features)",
              'help': "A comma-separated list of compendiums that the background importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "backgrounds"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a background's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importBackgroundFeature': {
          'name': "Import (Background Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported background feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "background features"
            }) */
          }
        },
        'importClass': {
          'name': "Import (Classes & Subclasses)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported class or subclass."),
            'isAddUnarmedStrike': {
              'name': "Add Unarmed Strike",
              'help': "If enabled, importing a class to an actor will create an \"Unarmed Strike\" weapon, unless one already exists.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isImportClassTable': {
              'name': "Import Class Table to Description",
              'help': "If enabled, a class's table will be imported as part of the class item's description.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isAddLevelUpButton': {
              'name': "Add &quot;Level Up&quot; Button to Character Sheets",
              'help': "If enabled, a \"Level Up\" button will be displayed in the top-right corner of a character's sheet (assuming the default dnd5e sheet is used).",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isSetXp': {
              'name': "Set Minimum Actor XP on Class Import",
              'help': "If enabled, during class import, actor XP will be set to the minimum XP value required for the actor's new level, if the actor's current XP is insufficient for them to reach their new level.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'hpIncreaseMode': {
              'name': "Hit Points Increase Mode",
              'help': "Determines how Hit Points are calculated when using the Class Importer to level up. If left unspecified, a user will be prompted to choose the mode each time their Hit Points are increased by the Class Importer.",
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM]
              }, {
                'value': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE,
                'name': ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE]
              }],
              'default': null,
              'isNullable': true
            },
            'hpIncreaseModeCustomRollFormula': {
              'name': "Hit Points Increase Custom Roll Formula",
              'help': "A custom roll formula to be used when gaining HP on level up. Used if either the \"Hit Points Increase Mode\" option is set to \"" + ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM] + "\", or if a player chooses \"" + ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM] + "\" when prompted to select their Hit Points Increase Mode. Use \"@hd.faces\" for the type of dice (i.e., the \"8\" in \"1d8\"), and \"@hd.number\" for \"number of dice\" (i.e., the \"1\" in \"1d8\"). Note that backticks (`) around an expression will also be replaced so \"`@hd.number`d`@hd.faces`\" will produce e.g. \"1d8\", should you need to avoid using brackets.",
              'placeholder': "(@hd.number)d(@hd.faces)",
              'type': "string",
              'additionalStyleClasses': "code",
              'default': null,
              'isNullable': true
            }
          },
          'settingsAdvanced': {
            'isDisplayOnLevelZeroCharacters': {
              'name': "Display &quot;Level Up&quot; Button on New Characters",
              'help': "If enabled, the \"Level Up\" button will be displayed on character actors with no levels.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isLevelUpButtonDisabledUntilEnoughExperience': {
              'name': "Disable the &quot;Level Up&quot; Button Until Character Has Enough XP",
              'help': "If enabled, the \"Level Up\" button will be disabled (though still visible) on characters who do not have sufficient XP to level up.",
              'default': true,
              'type': 'boolean'
            },
            'isLegacyLevelUpButton': {
              'name': "Prefer legacy &quot;Level Up&quot; Button",
              'help': "If disabled, the \"Level Up\" button will attempt to open the Charactermancer, a Patron-only feature which requires you to log in. If enabled, a dialogue of options will be presented, via which the Class Importer can be directly invoked.",
              'default': true,
              'type': "boolean"
            },
            'additionalDataCompendiumClasses': {
              'name': "Additional Data Compendiums (Classes)",
              'help': "A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CLASSES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumSubclasses': {
              'name': "Additional Data Compendiums (Subclasses)",
              'help': "A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_SUBCLASSES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums (Features)",
              'help': "A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_CLASS_FEATURES.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "class"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a class's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            },
            'isUseDefaultSubclassImage': {
              'name': "Subclass Default Image Fallback",
              'help': "If enabled, when importing a subclass which has no well-defined image, use a default image based on class. If disabled, a generic black and white image will be used as a fallback instead.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isHideSubclassRows': {
              'name': "Hide Subclasses in Class Importer",
              'help': "If enabled, the class/subclass list in the Class Importer will only show classes.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            }
          }
        },
        'importClassSubclassFeature': {
          'name': "Import (Class & Sub. Features)",
          'help': "Import (Class & Subclass Features)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported class/subclass feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "class/subclass features"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not class/subclass feature speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "class features"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a class/subclass feature's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importItem': {
          'name': "Import (Items)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported item."),
            'isAddActiveEffects': {
              'name': "Populate Active Effects",
              'help': "If items should have active effects created during import.",
              'default': true,
              'type': 'boolean'
            },
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not item range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            },
            'isMetricWeight': {
              'name': "Convert Item Weights to Metric",
              'help': "Whether or not item weight units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_POUNDS + ').',
              'default': false,
              'type': 'boolean'
            },
            'inventoryStackingMode': {
              'name': "Inventory Stacking Mode",
              'help': "If imported items should \"stack\" with existing items when imported to an actor's inventory. If stacking is allowed, the importer will check for an existing item when importing an item to an actor's sheet. If the item already exists, the importer will increase the quantity of that item in the actor's inventory, rather than create a new copy of the item in the actor's inventory.",
              'default': ConfigConsts.C_ITEM_ATTUNEMENT_SMART,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_NEVER,
                'name': "Never Stack"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_SMART,
                'name': "Sometimes Stack (e.g. consumables, throwables)"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_ALWAYS,
                'name': "Always Stack"
              }]
            },
            'isSplitPacksActor': {
              'name': "Import Packs to Actors as Constituent Items",
              'help': "If \"pack\" items (explorer's pack, dungeoneer's pack) should be broken down and imported as their constituent items when importing to an actor's items.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isSplitAtomicPacksActor': {
              'name': "Import Item Stacks to Actors as Constituent Items",
              'help': "If an item which is formed of multiple constituent items of the same type, such as \"Bag of Ball Bearings (1,000)\", should be split up into its constituent items (a \"Ball Bearing\" item with its sheet quantity set to 1,000, in this example).",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'throwables': {
              'name': "Throwing Items",
              'help': "A list of items which are imported with their usage set to deplete their own quantity when used.",
              'default': ["Handaxe", "Javelin", "Light Hammer", "Dart", 'Net'],
              'type': 'arrayStringShort',
              'isPlayerEditable': true
            },
            'altAbilityScoreByClass': {
              'name': "Alt Ability Scores by Class",
              'help': "A list of <class>-<item>-<score> mappings, an entry in which, when importing an item, will change the default ability score used by an item for a member of that class.",
              'default': ['monk:club:dex', "monk:dagger:dex", 'monk:handaxe:dex', "monk:javelin:dex", "monk:light hammer:dex", "monk:mace:dex", "monk:quarterstaff:dex", 'monk:shortsword:dex', 'monk:sickle:dex', "monk:spear:dex"],
              'type': "arrayStringShort",
              'isPlayerEditable': true
            },
            'attunementType': {
              'name': "Attunement when Importing to Directory/Compendium",
              'help': "The attunement type to use when importing an item which can be attuned.",
              'default': ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
              'type': 'enum',
              'values': [{
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_NONE,
                'name': "None"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
                'name': "Attunement required"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
                'name': "Attuned"
              }]
            },
            'attunementTypeActor': {
              'name': "Attunement when Importing to Actors",
              'help': "The attunement type to use when importing an item which can be attuned.",
              'default': ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_NONE,
                'name': "None"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
                'name': "Attunement required"
              }, {
                'value': ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
                'name': "Attuned"
              }]
            },
            'isImportDescriptionHeader': {
              'name': "Include Damage, Properties, Rarity, and Attunement in Description",
              'help': "If enabled, an imported item's description will include text generated from its rarity, attunement requirements, damage, and other properties.",
              'default': false,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isUseOtherFormulaFieldForExtraDamage': {
              'name': "Treat Extra Damage as &quot;Other Formula&quot;",
              'help': "This moves extra damage rolls to the \"Other Formula\" dice field, which can improve compatibility with some modules.",
              'default': false,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Item Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_ITEMS.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            'replacementDataCompendium': {
              'name': "Replacement Data Compendiums",
              'help': "A comma-separated list of compendiums that the Item Importer will attempt to pull items from, rather than using the data Plutonium would otherwise generate. This is useful when the Item Importer is used by other importers, e.g. when the Creature Importer is adding items to newly-created actors.",
              'default': '',
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "items"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, an item's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importPsionic': {
          'name': "Import (Psionics)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported psionic."),
            'psiPointsResource': {
              'name': "Psi Points Resource",
              'help': "The resource consumed by psionics.",
              'default': "resources.primary",
              'type': "enum",
              'values': [{
                'value': "resources.primary"
              }, {
                'value': 'resources.secondary'
              }, {
                'value': "resources.tertiary"
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM,
                'name': "\"Psi Points\" sheet item"
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM,
                'name': "Custom (see below)"
              }],
              'isPlayerEditable': true
            },
            'psiPointsResourceCustom': {
              'name': "Psi Points Custom Resource",
              'help': "The name of the custom resource to use if \"Custom\" is selected for \"Psi Points Resource\", above. This supports modules that expand the number of available sheet resources, such as \"5e-Sheet Resources Plus\" (which adds e.g. \"resources.fourth\", \"resources.fifth\", ...).",
              'type': 'string',
              'additionalStyleClasses': 'code',
              'default': null,
              'isNullable': true,
              'isPlayerEditable': true
            },
            'isImportAsSpell': {
              'name': "Import as Spells",
              'help': "If enabled, psionics will be imported as spells, rather than features.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "psionics"
            })
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': 'psionic'
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a psionic's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importRace': {
          'name': "Import (Races)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported race."),
           /*  ...ConfigConsts._template_getTokenSettings({
              'actorType': "character"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not race speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the race importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "races"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a race's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importRaceFeature': {
          'name': "Import (Race Features)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported race feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "race features"
            }) */
          },
          'settingsAdvanced': {
            'additionalDataCompendiumFeatures': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the race feature importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES.join(", "),
              'type': "string",
              'typeSub': 'compendiums',
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "race features"
            })
          }
        },
        'importTable': {
          'name': "Import (Table)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported table.")
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Table Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_TABLES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': 'code',
              'isNullable': true
            }
          }
        },
        'importSpell': {
          'name': "Import (Spells)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported spell."),
            'prepareActorSpells': {
              'name': "Prepare Actor Spells",
              'help': "Whether or not spells that are imported to actor sheets should be prepared by default.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'prepareSpellItems': {
              'name': "Prepare Spell Items",
              'help': "Whether or not spells that are imported to the items directory should be prepared by default.",
              'default': false,
              'type': 'boolean'
            },
            'actorSpellPreparationMode': {
              'name': "Actor Spell Preparation Mode",
              'help': "The default spell preparation mode for spells imported to actor sheets.",
              'default': "prepared",
              'type': "enum",
              'values': [{
                'value': '',
                'name': "(None)"
              }, {
                'value': "always",
                'name': "Always Prepared"
              }, {
                'value': "prepared",
                'name': "Prepared"
              }, {
                'value': "innate",
                'name': "Innate Spellcasting"
              }, {
                'value': "pact",
                'name': "Pact Magic"
              }],
              'isPlayerEditable': true
            },
            'isAutoDetectActorSpellPreparationMode': {
              'name': "Auto-Detect Actor Spell Preparation Mode",
              'help': "If enabled, the default spell preparation mode for spells imported to actor sheets (as defined by \"Actor Spell Preparation Mode\") may be automatically overridden, e.g. \"pact magic\" is automatically used when importing to a warlock.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'spellItemPreparationMode': {
              'name': "Spell Item Preparation Mode",
              'help': "The default spell preparation mode for spells imported to the items directory.",
              'default': "prepared",
              'type': "enum",
              'values': [{
                'value': '',
                'name': '(None)'
              }, {
                'value': "always",
                'name': "Always Prepared"
              }, {
                'value': "prepared",
                'name': "Prepared"
              }, {
                'value': 'innate',
                'name': "Innate Spellcasting"
              }, {
                'value': "pact",
                'name': "Pact Magic"
              }]
            },
            'spellPointsMode': {
              'name': "Use Spell Points",
              'help': "If enabled, imported spells which would use spell slots will instead be marked as \"at will\" and set to consume an a sheet or feature resource. (The \"Spell Points\" variant rule can be found in the DMG, page 288.)",
              'default': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
              'type': 'enum',
              'values': [{
                'name': "Disabled",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED
              }, {
                'name': 'Enabled',
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED
              }, {
                'name': "Enabled, and Use 99 Slots",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS,
                'help': "If enabled, an imported spells will retain its \"Spell Preparation Mode\" in addition to consuming a \"Spell Points\" sheet/feature resource. This improves compatibility with many sheets and modules. To allow \"unlimited\" spellcasting at each spell level, a character's spell slots for each level will be set to 99."
              }],
              'isPlayerEditable': true
            },
            'spellPointsResource': {
              'name': "Spell Points Resource",
              'help': "The resource consumed by spells imported with \"Use Spell Points\" enabled.",
              'default': "resources.primary.value",
              'type': "enum",
              'values': [{
                'value': "resources.primary"
              }, {
                'value': 'resources.secondary'
              }, {
                'value': 'resources.tertiary'
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM,
                'name': "\"Spell Points\" sheet item"
              }, {
                'value': ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM,
                'name': "Custom (see below)"
              }],
              'isPlayerEditable': true
            },
            'spellPointsResourceCustom': {
              'name': "Spell Points Custom Resource",
              'help': "The name of the custom resource to use if \"Custom\" is selected for \"Spell Points Resource\", above. This supports modules that expand the number of available sheet resources, such as \"5e-Sheet Resources Plus\" (which adds e.g. \"resources.fourth\", \"resources.fifth\", ...).",
              'type': 'string',
              'additionalStyleClasses': "code",
              'default': null,
              'isNullable': true,
              'isPlayerEditable': true
            },
            'isIncludeClassesInDescription': {
              'name': "Include Caster Classes in Spell Description",
              'help': "If enabled, an imported spell's description will include the list of classes which have the spell on their spell list.",
              'default': false,
              'type': "boolean"
            },
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': 'spells'
            }),
            'isMetricDistance': {
              'name': "Convert Ranges and Areas to Metric",
              'help': "Whether or not spell range/area units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + "; " + ConfigConsts._DISP_METRIC_MILES + ').',
              'default': false,
              'type': "boolean"
            },
            'isFilterOnOpen': {
              'name': "Apply Class Filter when Opening on Actor",
              'help': "If enabled, and the importer is opened from an actor, the spell list will be filtered according to that actor's current class(es).",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the Spell Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_SPELLS.join(", "),
              'type': 'string',
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'replacementDataCompendium': {
              'name': "Replacement Data Compendiums",
              'help': "A comma-separated list of compendiums that the Spell Importer will attempt to pull spells from, rather than using the data Plutonium would otherwise generate. This is useful when the Spell Importer is used by other importers, e.g. when the Creature Importer is adding spells to newly-created actors.",
              'default': '',
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': 'spells'
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a spell's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            },
            'isUseCustomSrdIcons': {
              'name': "Use Custom Icons for SRD Spells",
              'help': "If enabled, imported SRD spells will use an alternate icon set, as curated by the community.",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            },
            'isUseDefaultSchoolImage': {
              'name': "School Default Image Fallback",
              'help': "If enabled, when importing a spell which has no well-defined image, use a default image based on the school of the spell. If disabled, a generic black and white image will be used as a fallback instead.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'spellPointsModeNpc': {
              'name': "Use Spell Points (NPCs)",
              'help': "If enabled, a spell imported to an NPC which would use spell slots will instead be marked as \"at will\" and set to consume an a sheet or feature resource. (The \"Spell Points\" variant rule can be found in the DMG, page 288.)",
              'default': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
              'type': "enum",
              'values': [{
                'name': "Disabled",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__DISABLED
              }, {
                'name': "Enabled",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED
              }, {
                'name': "Enabled, but Use 99 Slots",
                'value': ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS,
                'help': "If enabled, imported spells will retain their \"prepared\"/etc. types in addition to consuming a \"Spell Points\" sheet/feature resource. This allows easier organisation of spells, and better compatibility with many modules. To allow \"unlimited\" spellcasting at each spell level, a character's spell slots for each level will be set to 99."
              }]
            }
          }
        },
        'importRule': {
          'name': "Import (Rules)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported rule.")
          }
        },
        'importLanguage': {
          'name': "Import (Languages)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported language.")
          }
        },
        'importOptionalFeature': {
          'name': "Import (Options & Features)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported option/feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "optional features"
            }),
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not optional feature speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            'additionalDataCompendium': {
              'name': "Additional Data Compendiums",
              'help': "A comma-separated list of compendiums that the optional feature importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.",
              'default': ConfigConsts.SRD_COMPENDIUMS_OPTIONAL_FEATURES.join(", "),
              'type': "string",
              'typeSub': "compendiums",
              'additionalStyleClasses': 'code',
              'isNullable': true
            },
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "optional features"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, an optional feature's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importConditionDisease': {
          'name': "Import (Conditions & Diseases)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported condition/diseases.")
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "conditions/diseases"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a condition/disease's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importCultBoon': {
          'name': "Import (Cults & Supernatural Boons)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported cult/boon.")
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "cults/boons"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a cult/boon's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importAction': {
          'name': "Import (Actions)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported action.")
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "actions"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a action's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importReward': {
          'name': "Import (Gifts & Rewards)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported supernatural gift/reward."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "supernatural gift/rewards"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not gift/reward speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "gift/rewards"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a supernatural gift/reward's text will be imported as item description.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'importCharCreationOption': {
          'name': "Import (Char. Creation Options)",
          'help': "Import (Character Creation Options)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported character creation option."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "character creation options"
            }), */
            'isMetricDistance': {
              'name': "Convert Speeds to Metric",
              'help': "Whether or not character creation option speed units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "character creation options"
            }),
            'isImportDescription': {
              'name': "Import Text as Description",
              'help': "If enabled, a character creation option's text will be imported as item description.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'importDeity': {
          'name': "Import (Deities)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported deity.")
          }
        },
        'importRecipe': {
          'name': "Import (Recipes)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported recipe.")
          }
        },
        'importTrap': {
          'name': "Import (Traps)",
          'settings': {
           /*  'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported trap."),
            ...ConfigConsts._template_getTokenSettings({
              'actorType': "npc"
            }), */
            'isImportBio': {
              'name': "Import Fluff to Description",
              'help': "If enabled, any fluff text which is available for a trap will be imported into that trap's description.",
              'default': true,
              'type': 'boolean'
            },
            'isImportBioImages': {
              'name': "Include Fluff Image in Description",
              'help': "If enabled, any fluff image which is available for a trap will be imported into that trap's description.",
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActorImportOverwriteSettings()
          }
        },
        'importTrapFeature': {
          'name': "Import (Trap Features)",
          'settings': {
            /* 'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported trap feature."),
            ...ConfigConsts._template_getTargetTemplatePrompt({
              'namePlural': "trap features"
            }), */
            'isMetricDistance': {
              'name': "Convert Ranges to Metric",
              'help': "Whether or not trap feature range units should be converted to an approximate metric equivalent (" + ConfigConsts._DISP_METRIC_FEET + ').',
              'default': false,
              'type': "boolean"
            }
          },
          'settingsAdvanced': {
            ...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({
              'name': "trap features"
            })
          }
        },
        'importHazard': {
          'name': "Import (Hazards)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported hazard.")
          }
        },
        'importAdventure': {
          'name': "Import (Adventures)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported adventure."),
            'isUseModdedInstaller': {
              'name': "Use Modded Package Installer",
              'help': "If the modded Plutonium backend is installed, adventure packages (modules/worlds) will be installed, automatically, using the mod, rather than providing you with a list of links to copy-paste into Foundry's \"Setup\".",
              'type': 'boolean',
              'default': false
            },
            'isUseLegacyImporter': {
              'name': "Enable Legacy Package Importer",
              'help': "If Plutonium should allow adventure packages (modules/worlds) to be imported directly, rather than providing references for the user to investigate themselves.",
              'type': "boolean",
              'default': false,
              'unlockCode': "unlock"
            },
            'indexUrl': {
              'name': "Package Index URL",
              'help': "The URL of the index file from which world/module package metadata is loaded.",
              'type': 'url',
              'default': "https://raw.githubusercontent.com/DMsGuild201/Foundry_Resources/master/worlds/index.json",
              'additionalStyleClasses': 'code',
              'isReloadRequired': true
            }
          }
        },
        'importBook': {
          'name': "Import (Books)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported book.")
          }
        },
        'importMap': {
          'name': "Import (Maps)",
          'settings': {
            //...ConfigConsts._template_getSceneImportSettings()
          }
        },
        'importDeck': {
          'name': "Import (Decks)",
          'settings': {
            //'ownership': ConfigConsts._template_getEntityOwnership("The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported deck.")
          }
        },
        'actor': {
          'name': 'Actors',
          'settings': {
            'isRefreshOtherOwnedSheets': {
              'name': "Refresh Sheets using &quot;@" + SharedConsts.MODULE_ID_FAKE + ".userchar&quot; when Updating Player Character",
              'help': "Player only. If enabled, when you update your character, the sheets of other actors you control which use \"@" + SharedConsts.MODULE_ID_FAKE + ".userchar. ...\" attributes will be automatically refreshed to reflect any changes made to your character. If disabled, you may notice a \"lag\" between updating your character and seeing the changes reflected in other sheets (a refresh can be forced manually by editing any field on the other sheet, or refreshing your browser tab).",
              'default': true,
              'type': 'boolean',
              'isPlayerEditable': true
            }
          },
          'settingsAdvanced': {
            'isAddRollDataItemsFeat': {
              'name': "Add &quot;@items&quot; to Roll Data (Features)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true
              }
            },
            'isAddRollDataItemsItem': {
              'name': "Add &quot;@items&quot; to Roll Data (Inventory)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': 'boolean'
            },
            'isAddRollDataItemsSpell': {
              'name': "Add &quot;@items&quot; to Roll Data (Spells)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': "boolean"
            },
            'isAddRollDataItemsOther': {
              'name': "Add &quot;@items&quot; to Roll Data (Other)",
              'help': "If actor roll data should be modified to allow access owned items, via data paths of the form \"@items.<itemName>. ...\" (for example, \"@items.big-sword.system.attackBonus\" would be substituted with the attack bonus of the owned item \"Big Sword\").",
              'default': false,
              'type': 'boolean'
            }
          },
          'settingsHacks': {
            'isAutoMultiattack': {
              'name': "Auto-Roll Multiattacks",
              'help': "Attempt to detect and automatically roll components of a creature's \"Multiattack\" sheet item on activation.",
              'default': false,
              'type': "boolean"
            },
            'autoMultiattackDelay': {
              'name': "Time Between Multiattack Rolls (ms)",
              'help': "A number of milliseconds to wait between each roll of a multiattack when using the \"Auto-Roll Multiattacks\" option. A value of 2000-2500 is recommended when using the \"Automated Animations\" module.",
              'default': null,
              'type': 'number',
              'min': 0x0,
              'isNullable': true
            },
            'isUseExtendedActiveEffectsParser': {
              'name': "Support Variables in Active Effect Values",
              'help': "Allows the use of roll syntax, and notably variables (such as \"@abilities.dex.mod\"), in active effect values.",
              'default': true,
              'type': "boolean",
              'compatibilityModeValues': {
                [UtilCompat.MODULE_DAE]: false,
                [UtilCompat.MODULE_ROLLDATA_AWARE_ACTIVE_EFFECTS]: false
              }
            }
          }
        },
        'item': {
          'name': "Items",
          'settingsHacks': {
            'isSuppressAdvancementsOnImportedDrop': {
              'name': "Suppress Advancements During Drop Flow",
              'help': "If enabled, dropping a Plutonium-imported item to a sheet will briefly disable the default advancement workflow, potentially allowing Plutonium's importer to run instead.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'rivet': {
          'name': "Rivet",
          'settings': {
            'targetDocumentId': {
              'name': "Target Document",
              'help': "The ID of an actor or compendium to which Rivet content should be imported.",
              'default': '',
              'type': "string",
              'additionalStyleClasses': "code",
              'isPlayerEditable': true
            },
            'isDisplayStatus': {
              'name': "Display Extension Detected",
              'help': "Adds a \"paper plane\" icon to the Foundry \"anvil\" logo in the top-left corner of the screen if Rivet is detected.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            /* 'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level",
              'help': "Rivet will cease to function for any user user with a role less than the chosen role. Directory \"Set as Rivet Target\" context menu option will also be hidden for any user with a role less than the chosen role."
            }) */
          }
        },
        'artBrowser': {
          'name': "Art Browser",
          'settings': {
            'importImagesAs': {
              'name': "Drag-Drop Images As",
              'help': "The type of canvas object that should be created when drag-dropping images from the art browser to the canvas.",
              'default': ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
                'name': 'Tokens'
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_TILE,
                'name': "Tiles"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_NOTE,
                'name': "Journal notes"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_SCENE,
                'name': "Scenes"
              }]
            },
            'dropAnchor': {
              'name': "Drag-Drop Position Anchor",
              'help': "The origin point of the image used for the purpose of dropping it to the canvas. \"Center\" will place the center of the image at the drop position, whereas \"Top-Left Corner\" will place the top-left corner of the image at the drop position.",
              'default': 0x0,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ART_DROP_ANCHOR_CENTER,
                'name': "Center"
              }, {
                'value': ConfigConsts.C_ART_DROP_ANCHOR_TOP_LEFT,
                'name': "Top-Left Corner"
              }]
            },
            'scale': {
              'name': "Tile/Scene Scaling",
              'help': "A factor by which to scale placed tiles, and by which to scale scene backgrounds.",
              'default': 0x1,
              'type': 'number',
              'min': 0.01,
              'max': 0x64
            },
            ...ConfigConsts._template_getSceneImportSettings(),
            'tokenSize': {
              'name': "Token Size",
              'help': "The default size of placed tokens.",
              'default': 0x1,
              'type': "enum",
              'values': [{
                'value': 0x1,
                'name': "Medium or smaller"
              }, {
                'value': 0x2,
                'name': 'Large'
              }, {
                'value': 0x3,
                'name': "Huge"
              }, {
                'value': 0x4,
                'name': "Gargantuan or larger"
              }]
            },
            'isSwitchToCreatedScene': {
              'name': "Activate Scenes on Creation",
              'help': "If enabled, a scene will be activated upon creation (by drag-dropping an image to the canvas).",
              'default': true,
              'type': "boolean"
            },
            'isDisplaySheetCreatedScene': {
              'name': "Display Scene Sheets on Creation",
              'help': "If enabled, the \"sheet\" (i.e., configuration UI) for a scene will be shown upon creation (by drag-dropping an image to the canvas).",
              'default': true,
              'type': 'boolean'
            },
            'artDirectoryPath': {
              'name': "User Art Directory",
              'help': "The sub-directory of the \"User Data\" directory where downloaded images and image packs will be saved.",
              'default': "assets/art",
              'type': 'string',
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'buttonDisplay': {
              'name': "Add Button To",
              'help': "The place(s) where the Art Browser button should be visible.",
              'default': {
                [ConfigConsts.C_ART_IMAGE_MODE_TOKEN]: false,
                [ConfigConsts.C_ART_IMAGE_MODE_TILE]: true,
                [ConfigConsts.C_ART_IMAGE_MODE_NOTE]: false,
                [ConfigConsts.C_ART_IMAGE_MODE_SCENE]: true
              },
              'type': "multipleChoice",
              'choices': [{
                'value': ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
                'name': "Token scene controls"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_TILE,
                'name': "Tile scene controls"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_NOTE,
                'name': "Note scene controls"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_MODE_SCENE,
                'name': "Scene controls"
              }]
            },
            'imageSaveMode': {
              'name': "Image Saving Mode",
              'help': "How images should be saved to the server. If \"Default\" is selected, an imported image will only be saved if it cannot be referenced via URL. If \"Always\" is selected, an imported image will be saved to the server, regardless of whether or not it can be referenced via URL. If \"Never\" is selected, an imported image will only be referenced by URL; if it cannot be referenced via URL, the import will fail. Note that saving images requires the Plutonium backend mod to be installed.",
              'default': ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT,
              'type': "enum",
              'values': [{
                'value': ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT,
                'name': "Default"
              }, {
                'value': ConfigConsts.C_ART_IMAGE_SAVE_MODE__ALWAYS,
                'name': 'Always'
              }, {
                'value': ConfigConsts.C_ART_IMAGE_SAVE_MODE__NEVER,
                'name': "Never"
              }]
            }
          },
          'settingsAdvanced': {
            'isSwitchLayerOnDrop': {
              'name': "Switch to Layer on Drop",
              'help': "If, when dropping an image into a given layer, the canvas should switch to that layer.",
              'default': true,
              'type': "boolean"
            },
            'isShowMissingBackendWarning': {
              'name': "Show &quot;Missing Backend&quot; Warning",
              'help': "If enabled, and the Plutonium backend mod is not installed, a warning will be shown in the Art Browser.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'journalEntries': {
          'name': "Journal Entries",
          'settings': {
            'isAutoExpandJournalEmbeds': {
              'name': "Auto-Expand Page Embeds",
              'help': "If enabled, journal pages embedded using \"@EmbedUUID[JournalEntry. ... JournalEntryPage. ...]{...}\" will be expanded by default.",
              'default': true,
              'type': "boolean"
            },
            'isEnableNoteHeaderAnchor': {
              'name': "Allow &quot;Header Anchors&quot; in Notes",
              'help': "If enabled, a \"Header Anchor\" may be specified when creating or editing a map note. When opening a journal entry via a map note with a Header Anchor set, the journal entry will scroll to that header.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'tools': {
          'name': "Tools",
          'settings': {
            'isDeduplicateIgnoreType': {
              'name': "Ignore Types When Deduplicating",
              'help': "If enabled, the Collection Deduplicator will ignore entity types, treating e.g. a PC sheet and an NPC sheet with the same name as a set of duplicates.",
              'default': false,
              'type': "boolean"
            },
           /*  'minimumRolePolymorph': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Polymorph Tool",
              'help': "Actor \"Polymorph\" buttons will be hidden for any user with a role less than the chosen role."
            }),
            'minimumRoleActorTools': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Other Actor Tools",
              'help': "Actor \"Feature/Spell Cleaner,\" \"Prepared Spell Mass-Toggler,\" etc. buttons will be hidden for any user with a role less than the chosen role."
            }),
            'minimumRoleTableTools': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level for Other Table Tools",
              'help': "Table \"Row Cleaner\" button will be hidden for any user with a role less than the chosen role."
            }), */
            'isAddClearFlagsContextMenu': {
              'name': "Add &quot;Clear Flags&quot; Context Option",
              'help': "If enabled a \"Clear Flags\" option will be added to directory document context menus. This option will clear all \"plutonium\" flags from a document, and the document's embedded documents. Note that this will negatively impact Plutonium functionality for the document.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            }
          }
        },
        'text': {
          'name': "Text and Tags",
          'settings': {
            'isEnableHoverForLinkTags': {
              'name': "Enable Hover Popups for &quot;@tag&quot; Links",
              'help': "If links rendered from @tag syntax should display popups when hovered.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isAutoRollActorItemTags': {
              'name': "Roll Items Linked by @UUID[Actor.Item.] on Click",
              'help': "If enabled, clicking a rendered @UUID[Actor. ... Item. ...] tag will roll the linked embedded item. If disabled, or on SHIFT-click, the default action (opening the item's sheet) is taken.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isJumpToFolderTags': {
              'name': "Show Folder Linked by @UUID[Folder.] on Click",
              'help': "If enabled, clicking a rendered @UUID[Folder. ...] tag will switch to that folder's tab and scroll the folder into view. If disabled, or on SHIFT-click, the default action (opening the folder's sheet) is taken.",
              'default': true,
              'type': "boolean",
              'isPlayerEditable': true
            },
            'isShowLinkParent': {
              'name': "Show Parent Icon/Name For Child @UUIDs",
              'help': "If enabled, a rendered @UUID[<parentDocumentName>.<parentId>.<documentName>.<documentId>] tag will display the icon of the parent document type and the name of the parent document, in addition to the usual icon of the document type and the name of the document.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          }
        },
        'misc': {
          'name': "Miscellaneous",
          'settings': {
            'isSkipAddonAutomationCheck': {
              'name': "Skip Addon: Automation Check",
              'help': "Avoid posting to chat if the Addon: Automation companion model is not installed.",
              'default': false,
              'type': "boolean"
            },
            'isSkipBackendCheck': {
              'name': "Skip Backend Check",
              'help': "Avoid sending a network request during module initialisation to check if the modded Plutonium backend is installed.",
              'default': false,
              'type': "boolean",
              'isPlayerEditable': true
            }
          },
          'settingsAdvanced': {
            'baseSiteUrl': {
              'name': "Master of Ceremonies Server URL",
              'help': "The root server URL for the Mater of Ceremonies app, used to verify and unlock Patron benefits.",
              'type': 'url',
              'default': "https://plutonium.giddy.cyou",
              'isNullable': true,
              'isReloadRequired': true,
              'unlockCode': 'unlock'
            },
            'backendEndpoint': {
              'name': "Custom Backend Endpoint",
              'help': "The API endpoint used to make calls to the modded Plutonium backend, if available. Note that this API is considered \"internal,\" and is therefore undocumented, and may change on a per-version basis.",
              'default': null,
              'placeholder': "(Use default)",
              'type': "url",
              'additionalStyleClasses': "code",
              'isNullable': true
            },
            'isPatchFromUuid': {
              'name': "Patch <code>fromUuid</code>",
              'help': "Patch the built-in Foundry function \"fromUuid\" to allow Plutonium-specific UUIDs to be processed. This improves compatibility with some modules.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'equipmentShop': {
          'name': "Equipment Shop",
          'settings': {
            'priceMultiplier': {
              'name': "Price Multiplier",
              'help': "A factor by which the prices in the equipment shop are multiplied.",
              'default': 0x1,
              'type': 'percentage',
              'min': 0.0001
            },
            'startingGold': {
              'name': "Class Starting Gold",
              'help': "A starting gold amount to use instead of a class's starting gold, when using the equipment shop during class creation.",
              'default': null,
              'type': "number",
              'isNullable': true
            },
           /*  'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level",
              'help': "\"Equipment Shop\" button will be hidden for any user with a role less than the chosen role."
            }) */
          }
        },
        'currency': {
          'name': 'Currency',
          'settingsAdvanced': {
            'isNpcUseCurrencySheetItems': {
              'name': "Import Currency as Sheet Item for NPCs",
              'help': "If enabled, the currency component of loot drag-dropped to an NPC sheet will be added as a sheet item. If disabled, it will be added as \"currency\" data instead, which the default " + SharedConsts.SYSTEM_ID_DND5E + " sheet does not display.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'dataSources': {
          'name': "Data Sources",
          'btnsAdditional': [{
            'name': "World Data Source Selector",
            'icon': "fas fa-fw fa-globe-africa",
            'onClick': async () => {
              const {
                WorldDataSourceSelector: _0x3787e7
              } = await Promise.resolve().then(function () {
                return WorldDataSourceSelector$1;
              });
              _0x3787e7.pHandleButtonClick().then(null);
            }
          }, {
            'name': "World Content Blocklist",
            'icon': "fas fa-fw fa-ban",
            'onClick': async () => {
              const {
                WorldContentBlocklistSourceSelector: _0x2b04fc
              } = await Promise.resolve().then(function () {
                return WorldContentBlocklist$1;
              });
              _0x2b04fc.pHandleButtonClick().then(null);
            }
          }],
          'settings': {
            'isPlayerEnableSourceSelection': {
              'name': "Enable Data Source Filtering for Players",
              'help': "Whether or not " + ConfigConsts._STR_DATA_SOURCES + " are filtered down to only those chosen in the \"World Data Source Selector\" application. Applies to players only.",
              'default': false,
              'type': 'boolean',
              'isReloadRequired': true
            },
            'isGmEnableSourceSelection': {
              'name': "Enable Data Source Filtering for GMs",
              'help': "Whether or not " + ConfigConsts._STR_DATA_SOURCES + " are filtered down to only those chosen in the \"World Data Source Selector\" application. Applies to GMs only.",
              'default': false,
              'type': 'boolean',
              'isReloadRequired': true
            },
            'isPlayerForceSelectAllowedSources': {
              'name': "Force Select All for Players",
              'help': "Whether or not all available " + ConfigConsts._STR_DATA_SOURCES + " are forcibly selected for players. Note that this can seriously degrade performance for players if data source filtering is not also enabled.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isGmForceSelectAllowedSources': {
              'name': "Force Select All for GMs",
              'help': "Whether or not all available " + ConfigConsts._STR_DATA_SOURCES + " are forcibly selected for GMs. Note that this can seriously degrade performance for GMs if data source filtering is not also enabled.",
              'default': false,
              'type': "boolean",
              'isReloadRequired': true
            },
            'isLoadLocalPrereleaseIndex': {
              'name': "Load Local Prerelease Content",
              'help': "If enabled, the directory specified by the \"Local Prerelease Content Directory\" option will be read, and its contents added to the list of available sources.",
              'default': false,
              'type': "boolean"
            },
            'localPrereleaseDirectoryPath': {
              'name': "Local Prerelease Content Directory",
              'help': "The sub-directory of the \"User Data\" directory from which prerelease content should be automatically loaded if the \"Load Local Prerelease\" option is enabled.",
              'default': "assets/prerelease",
              'type': "string",
              'additionalStyleClasses': "code"
            },
            'isUseLocalPrereleaseIndexJson': {
              'name': "Use <code>index.json</code> for Local Prerelease Content",
              'help': "If, rather than read the local prerelease content directory directly, an \"index.json\" file should be read when loading local prerelease content. This file should be of the form: {\"toImport\": [ ... list of filenames ... ]}. Note that this is required if players do not have \"Use File Browser\" permissions.",
              'default': false,
              'type': "boolean"
            },
            'localPrerelease': {
              'name': "Additional Prerelease Files",
              'help': "Prerelease files which should be automatically loaded and added to the list of available sources.",
              'default': [],
              'type': "arrayStringShort",
              'isCaseSensitive': true
            },
            'isLoadLocalHomebrewIndex': {
              'name': "Load Local Homebrew",
              'help': "If enabled, the directory specified by the \"Local Homebrew Directory\" option will be read, and its contents added to the list of available sources.",
              'default': false,
              'type': "boolean"
            },
            'localHomebrewDirectoryPath': {
              'name': "Local Homebrew Directory",
              'help': "The sub-directory of the \"User Data\" directory from which homebrew should be automatically loaded if the \"Load Local Homebrew\" option is enabled.",
              'default': "assets/homebrew",
              'type': "string",
              'additionalStyleClasses': "code"
            },
            'isUseLocalHomebrewIndexJson': {
              'name': "Use <code>index.json</code> for Local Homebrew",
              'help': "If, rather than read the local homebrew directory directly, an \"index.json\" file should be read when loading local homebrew. This file should be of the form: {\"toImport\": [ ... list of filenames ... ]}. Note that this is required if players do not have \"Use File Browser\" permissions.",
              'default': false,
              'type': "boolean"
            },
            'localHomebrew': {
              'name': "Additional Homebrew Files",
              'help': "Homebrew files which should be automatically loaded and added to the list of available sources.",
              'default': [],
              'type': "arrayStringShort",
              'isCaseSensitive': true
            }
          },
          'settingsAdvanced': {
            'tooManySourcesWarningThreshold': {
              'name': "Auto-Selected Source Count Warning Threshold",
              'help': "If set, a warning will be shown when auto-selecting a number of sources greater than this value, which usually occurs if a \"Force Select All...\" option is set, without also \"Enabl[ing] Data Source Filtering.\"",
              'default': 0x32,
              'type': "integer",
              'isNullable': true
            },
            'baseSiteUrl': {
              'name': "Base Site URL",
              'help': "The root server URL from which to load data and source images, and to link in rendered text. Note that, where possible, the module will use its own built-in data files, rather than call out to a remote server.",
              'type': "url",
              'additionalStyleClasses': "code",
              'default': null,
              'isNullable': true,
              'isReloadRequired': true
            },
            'isNoLocalData': {
              'name': "Avoid Loading Local Data",
              'help': "If enabled, any data which would normally be loaded from the module's local copies is instead loaded from the sites URL (which may be customised by editing the \"Base Site Url\" config option).",
              'default': false,
              'type': "boolean"
            },
            'isNoPrereleaseBrewIndexes': {
              'name': "Avoid Loading Prerelease/Homebrew Indexes on Startup",
              'help': "If enabled, prerelease/homebrew repository indexes won't be loaded during initial module load. This will effectively prevent any prerelease/homebrew sources from appearing in source listings. Note that these indexes are loaded in the background/asynchronously during normal operation, so should not negatively impact game load times, unless you have a particularly terrible internet connection.",
              'default': false,
              'type': "boolean"
            },
            'basePrereleaseUrl': {
              'name': "Base Prerelease Repository URL",
              'help': "The root GitHub repository URL from which to load data and source images, and to link in rendered text, when importing prerelease content. URLs should be of the form \"https://raw.githubusercontent.com/[username]/[repository name]/master\".",
              'type': "url",
              'additionalStyleClasses': 'code',
              'default': null,
              'isNullable': true,
              'isReloadRequired': true
            },
            'baseBrewUrl': {
              'name': "Base Homebrew Repository URL",
              'help': "The root GitHub repository URL from which to load data and source images, and to link in rendered text, when importing homebrew content. URLs should be of the form \"https://raw.githubusercontent.com/[username]/[repository name]/master\".",
              'type': "url",
              'additionalStyleClasses': 'code',
              'default': null,
              'isNullable': true,
              'isReloadRequired': true
            }
          }
        },
        /* 'integrationQuickInsert': {
          'name': "Integrations (Quick Insert)",
          'settings': {
            ...ConfigConsts._template_getModuleFauxCompendiumIndexSettings({
              'moduleName': "Quick Insert"
            }),
            'pagesHidden': {
              'name': "Hidden Categories",
              'help': "Categories of entity which should not be indexed.",
              'default': ConfigConsts._QUICK_INSERT_PAGE_METAS.mergeMap(({
                page: _0x25cba7
              }) => ({
                [_0x25cba7]: _0x25cba7 === UrlUtil.PG_RECIPES
              })),
              'type': "multipleChoice",
              'choices': ConfigConsts._QUICK_INSERT_PAGE_METAS.map(({
                page: _0x365d30,
                displayPage: _0x31cbd1
              }) => ({
                'value': _0x365d30,
                'name': _0x31cbd1
              }))
            },
            'isDisplaySource': {
              'name': "Display Sources",
              'help': "If enabled, a source abbreviation will be displayed on each result. If disabled, the module name will be shown instead.",
              'default': true,
              'type': 'boolean'
            }
          }
        },
        'integrationFoundrySummons': {
          'name': "Integrations (Foundry Summons)",
          'settings': {
            ...ConfigConsts._template_getModuleFauxCompendiumIndexSettings({
              'moduleName': "Foundry Summons"
            })
          }
        },
        'integrationBabele': {
          'name': "Integrations (Babele)",
          'settings': {
            'isEnabled': {
              'name': "Enabled",
              'help': "If enabled, and the Babele module is active, Plutonium will attempt to translate parts of imported content.",
              'default': true,
              'type': "boolean"
            },
            'isUseTranslatedDescriptions': {
              'name': "Use Translated Descriptions",
              'help': "If enabled, and a translated description is found for a document during import, that description will be used instead of the Plutonium default. Note that this may result in embedded functionality (for example, links between documents) being removed.",
              'default': true,
              'type': "boolean"
            }
          }
        },
        'integrationThreeDiCanvas': {
          'name': "Integrations (3D Canvas)",
          'settings': {
            'isSetThreeDiModels': {
              'name': "Allow Importer to Set 3D Models",
              'help': "If enabled, and the 3D Canvas, 3D Canvas Mapmaking Pack, and 3D Canvas Token Collection modules are active, Plutonium will attempt to set the \"3D Model\" field on imported tokens.",
              'default': true,
              'type': 'boolean',
              'isReloadRequired': true
            }
          }
        }, */
        'charactermancer': {
          'name': "Charactermancer",
          'settings': {
           /*  'minimumRole': ConfigConsts._template_getMinimumRole({
              'name': "Minimum Permission Level",
              'help': "Actor \"Charactermancer\" buttons will be hidden for any user with a role less than the chosen role."
            }) */
          }
        }
      };
    }
    static ["_DEFAULT_CONFIG_SORTED"] = null;
    static ["getDefaultConfigSorted_"]() {
      return this._DEFAULT_CONFIG_SORTED = this._DEFAULT_CONFIG_SORTED || Object.entries(this.getDefaultConfig_()).sort(([, _0xb7c8c5], [, _0x343b25]) => SortUtil.ascSortLower(_0xb7c8c5.name, _0x343b25.name));
    }
    static ["_DEFAULT_CONFIG_SORTED_FLAT"] = null;
    static ["getDefaultConfigSortedFlat_"]() {
      if (this._DEFAULT_CONFIG_SORTED_FLAT) {
        return this._DEFAULT_CONFIG_SORTED_FLAT;
      }
      return this._DEFAULT_CONFIG_SORTED_FLAT = this._DEFAULT_CONFIG_SORTED_FLAT || this.getDefaultConfigSorted_().map(([_0x102f4b, _0x540fe5]) => {
        const _0x417b84 = {};
        this._KEYS_SETTINGS_METAS.forEach(_0x48a0c5 => {
          Object.entries(_0x540fe5[_0x48a0c5] || {}).forEach(([_0x70d0f8, _0x41ed31]) => {
            _0x417b84[_0x70d0f8] = _0x41ed31;
          });
        });
        return [_0x102f4b, _0x417b84];
      });
    }
    static ["getCompendiumPaths"]() {
      const _0x525cb1 = [];
      Object.entries(this.getDefaultConfig_()).forEach(([_0x3661aa, _0x57ce92]) => {
        this._KEYS_SETTINGS_METAS.forEach(_0x435517 => {
          if (!_0x57ce92[_0x435517]) {
            return;
          }
          Object.entries(_0x57ce92[_0x435517]).forEach(([_0x57b4d8, _0x1b0cb0]) => {
            if (_0x1b0cb0.typeSub !== "compendiums") {
              return;
            }
            _0x525cb1.push([_0x3661aa, _0x57b4d8]);
          });
        });
      });
      return _0x525cb1;
    }
  }
  ConfigConsts._STR_DATA_SOURCES = "\"data sources\" (e.g. those displayed in the Import Wizard)";
  ConfigConsts._KEYS_SETTINGS_METAS = ["settings", "settingsHacks", "settingsAdvanced"];
  ConfigConsts._TEMPLATE_ENTITY_OWNERSHIP = {
    'name': "Default Ownership",
    'default': 0x0,
    'type': "enum"
  };
  ConfigConsts._TEMPALTE_MINIMUM_ROLE = {
    'default': 0x0,
    'type': "enum",
    'isReloadRequired': true
  };
  ConfigConsts._DISP_METRIC_POUNDS = "1 pound ≈ 0.5 kilograms";
  ConfigConsts._DISP_METRIC_FEET = "5 feet ≈ 1.5 metres";
  ConfigConsts._DISP_METRIC_MILES = "1 mile ≈ 1.6 kilometres";
  ConfigConsts.SRD_COMPENDIUMS_CREATURES = [SharedConsts.SYSTEM_ID_DND5E + ".monsters"];
  ConfigConsts.SRD_COMPENDIUMS_CREATURE_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".monsterfeatures"];
  ConfigConsts.SRD_COMPENDIUMS_CLASSES = [SharedConsts.SYSTEM_ID_DND5E + ".classes"];
  ConfigConsts.SRD_COMPENDIUMS_SUBCLASSES = [SharedConsts.SYSTEM_ID_DND5E + ".subclasses"];
  ConfigConsts.SRD_COMPENDIUMS_CLASS_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".classfeatures"];
  ConfigConsts.SRD_COMPENDIUMS_ITEMS = [SharedConsts.SYSTEM_ID_DND5E + '.items', SharedConsts.SYSTEM_ID_DND5E + ".tradegoods"];
  ConfigConsts.SRD_COMPENDIUMS_SPELLS = [SharedConsts.SYSTEM_ID_DND5E + '.spells'];
  ConfigConsts.SRD_COMPENDIUMS_OPTIONAL_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".classfeatures"];
  ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".races"];
  ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES = [SharedConsts.SYSTEM_ID_DND5E + ".backgrounds"];
  ConfigConsts.SRD_COMPENDIUMS_TABLES = [SharedConsts.SYSTEM_ID_DND5E + ".tables"];
  /* ConfigConsts._QUICK_INSERT_PAGE_METAS = [...new Set(Renderer.tag.TAGS.filter(_0x244883 => _0x244883.page).map(_0x2e0a71 => _0x2e0a71.page).filter(_0x5b9350 => ![UrlUtil.PG_QUICKREF, "skill", "sense", "card", 'legroup'].includes(_0x5b9350)))].map(_0x207d8d => {
    let _0x1333af = UrlUtil.pageToDisplayPage(_0x207d8d);
    if (_0x1333af === _0x207d8d) {
      _0x1333af = Parser.getPropDisplayName(_0x207d8d);
    }
    return {
      'page': _0x207d8d,
      'displayPage': _0x1333af
    };
  }).sort(({
    displayPage: _0xb12442
  }, {
    displayPage: _0xb84237
  }) => SortUtil.ascSortLower(_0xb12442, _0xb84237)); */
  ConfigConsts.C_ART_IMAGE_MODE_TOKEN = 0x0;
  ConfigConsts.C_ART_IMAGE_MODE_TILE = 0x1;
  ConfigConsts.C_ART_IMAGE_MODE_NOTE = 0x2;
  ConfigConsts.C_ART_IMAGE_MODE_SCENE = 0x3;
  ConfigConsts.C_ART_DROP_ANCHOR_CENTER = 0x0;
  ConfigConsts.C_ART_DROP_ANCHOR_TOP_LEFT = 0x1;
  ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT = 0x0;
  ConfigConsts.C_ART_IMAGE_SAVE_MODE__ALWAYS = 0x1;
  ConfigConsts.C_ART_IMAGE_SAVE_MODE__NEVER = 0x2;
  ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE = 0x0;
  ConfigConsts.C_IMPORT_DEDUPE_MODE_SKIP = 0x1;
  ConfigConsts.C_IMPORT_DEDUPE_MODE_OVERWRITE = 0x2;
  ConfigConsts.C_IMPORT_DRAG_DROP_MODE_NEVER = 0x0;
  ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT = 0x1;
  ConfigConsts.C_IMPORT_DRAG_DROP_MODE_ALWAYS = 0x2;
  ConfigConsts.C_CREATURE_NAMETAGS_CR = 0x0;
  ConfigConsts.C_CREATURE_NAMETAGS_TYPE = 0x1;
  ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS = 0x2;
  ConfigConsts.C_SPELL_POINTS_MODE__DISABLED = 0x0;
  ConfigConsts.C_SPELL_POINTS_MODE__ENABLED = 0x1;
  ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS = 0x2;
  ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM = "sheetItem";
  ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM = "attributeCustom";
  ConfigConsts.C_ITEM_ATTUNEMENT_NONE = 0x0;
  ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED = 0x1;
  ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED = 0x2;
  ConfigConsts.C_ITEM_ATTUNEMENT_NEVER = 0x0;
  ConfigConsts.C_ITEM_ATTUNEMENT_SMART = 0x1;
  ConfigConsts.C_ITEM_ATTUNEMENT_ALWAYS = 0x2;
  ConfigConsts.C_USE_GAME_DEFAULT = 'VE_USE_GAME_DEFAULT';
  ConfigConsts.C_USE_PLUT_VALUE = "VE_USE_MODULE_VALUE";
  ConfigConsts.C_BOOL_DISABLED = 0x0;
  ConfigConsts.C_BOOL_ENABLED = 0x1;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE = 0x0;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_STANDARD = 0x1;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_GM = 0x2;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_BLIND = 0x3;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_SELF = 0x4;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_HIDDEN = 0x5;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MIN = 0x6;
  ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MAX = 0x7;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE = 0x0;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN = 0x1;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX = 0x2;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL = 0x3;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM = 0x4;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE = 0x5;
  ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES = {
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE]: "Take Average",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN]: "Minimum Value",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX]: "Maximum Value",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL]: "Roll",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM]: "Roll (Custom Formula)",
    [ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE]: "Do Not Increase HP"
  };
//#endregion

//#region Renderer
globalThis.Renderer = function() {
    this.wrapperTag = "div";
    this.baseUrl = "";
    this.baseMediaUrls = {};

    if (globalThis.DEPLOYED_IMG_ROOT) {
        this.baseMediaUrls["img"] = globalThis.DEPLOYED_IMG_ROOT;
    }

    this._lazyImages = false;
    this._subVariant = false;
    this._firstSection = true;
    this._isAddHandlers = true;
    this._headerIndex = 1;
    this._tagExportDict = null;
    this._roll20Ids = null;
    this._trackTitles = {
        enabled: false,
        titles: {}
    };
    this._enumerateTitlesRel = {
        enabled: false,
        titles: {}
    };
    this._isHeaderIndexIncludeTableCaptions = false;
    this._isHeaderIndexIncludeImageTitles = false;
    this._plugins = {};
    this._fnPostProcess = null;
    this._extraSourceClasses = null;
    this._depthTracker = null;
    this._depthTrackerAdditionalProps = [];
    this._depthTrackerAdditionalPropsInherited = [];
    this._lastDepthTrackerInheritedProps = {};
    this._isInternalLinksDisabled = false;
    this._isPartPageExpandCollapseDisabled = false;
    this._fnsGetStyleClasses = {};

    this.setLazyImages = function(bool) {
        if (typeof IntersectionObserver === "undefined")
            this._lazyImages = false;
        else
            this._lazyImages = !!bool;
        return this;
    }
    ;

    this.setWrapperTag = function(tag) {
        this.wrapperTag = tag;
        return this;
    }
    ;

    this.setBaseUrl = function(url) {
        this.baseUrl = url;
        return this;
    }
    ;

    this.setBaseMediaUrl = function(mediaDir, url) {
        this.baseMediaUrls[mediaDir] = url;
        return this;
    }
    ;

    this.setFirstSection = function(bool) {
        this._firstSection = bool;
        return this;
    }
    ;

    this.setAddHandlers = function(bool) {
        this._isAddHandlers = bool;
        return this;
    }
    ;

    this.setFnPostProcess = function(fn) {
        this._fnPostProcess = fn;
        return this;
    }
    ;

    this.setExtraSourceClasses = function(arr) {
        this._extraSourceClasses = arr;
        return this;
    }
    ;

    this.resetHeaderIndex = function() {
        this._headerIndex = 1;
        this._trackTitles.titles = {};
        this._enumerateTitlesRel.titles = {};
        return this;
    }
    ;

    this.getHeaderIndex = function() {
        return this._headerIndex;
    }
    ;

    this.setHeaderIndexTableCaptions = function(bool) {
        this._isHeaderIndexIncludeTableCaptions = bool;
        return this;
    }
    ;
    this.setHeaderIndexImageTitles = function(bool) {
        this._isHeaderIndexIncludeImageTitles = bool;
        return this;
    }
    ;

    this.doExportTags = function(toObj) {
        this._tagExportDict = toObj;
        return this;
    }
    ;

    this.resetExportTags = function() {
        this._tagExportDict = null;
        return this;
    }
    ;

    this.setRoll20Ids = function(roll20Ids) {
        this._roll20Ids = roll20Ids;
        return this;
    }
    ;

    this.resetRoll20Ids = function() {
        this._roll20Ids = null;
        return this;
    }
    ;

    this.setInternalLinksDisabled = function(val) {
        this._isInternalLinksDisabled = !!val;
        return this;
    }
    ;
    this.isInternalLinksDisabled = function() {
        return !!this._isInternalLinksDisabled;
    }
    ;

    this.setPartPageExpandCollapseDisabled = function(val) {
        this._isPartPageExpandCollapseDisabled = !!val;
        return this;
    }
    ;

    this.setFnGetStyleClasses = function(identifier, fn) {
        if (fn == null) {
            delete this._fnsGetStyleClasses[identifier];
            return this;
        }

        this._fnsGetStyleClasses[identifier] = fn;
        return this;
    }
    ;

    this.setEnumerateTitlesRel = function(bool) {
        this._enumerateTitlesRel.enabled = bool;
        return this;
    }
    ;

    this._getEnumeratedTitleRel = function(name) {
        if (this._enumerateTitlesRel.enabled && name) {
            const clean = name.toLowerCase();
            this._enumerateTitlesRel.titles[clean] = this._enumerateTitlesRel.titles[clean] || 0;
            return `data-title-relative-index="${this._enumerateTitlesRel.titles[clean]++}"`;
        } else
            return "";
    }
    ;

    this.setTrackTitles = function(bool) {
        this._trackTitles.enabled = bool;
        return this;
    }
    ;

    this.getTrackedTitles = function() {
        return MiscUtil.copyFast(this._trackTitles.titles);
    }
    ;

    this.getTrackedTitlesInverted = function({isStripTags=false}={}) {
        const trackedTitlesInverse = {};
        Object.entries(this._trackTitles.titles || {}).forEach(([titleIx,titleName])=>{
            if (isStripTags)
                titleName = Renderer.stripTags(titleName);
            titleName = titleName.toLowerCase().trim();
            (trackedTitlesInverse[titleName] = trackedTitlesInverse[titleName] || []).push(titleIx);
        }
        );
        return trackedTitlesInverse;
    }
    ;

    this._handleTrackTitles = function(name, {isTable=false, isImage=false}={}) {
        if (!this._trackTitles.enabled)
            return;
        if (isTable && !this._isHeaderIndexIncludeTableCaptions)
            return;
        if (isImage && !this._isHeaderIndexIncludeImageTitles)
            return;
        this._trackTitles.titles[this._headerIndex] = name;
    }
    ;

    this._handleTrackDepth = function(entry, depth) {
        if (!entry.name || !this._depthTracker)
            return;

        this._lastDepthTrackerInheritedProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        if (entry.source)
            this._lastDepthTrackerInheritedProps.source = entry.source;
        if (this._depthTrackerAdditionalPropsInherited?.length) {
            this._depthTrackerAdditionalPropsInherited.forEach(prop=>this._lastDepthTrackerInheritedProps[prop] = entry[prop] || this._lastDepthTrackerInheritedProps[prop]);
        }

        const additionalData = this._depthTrackerAdditionalProps.length ? this._depthTrackerAdditionalProps.mergeMap(it=>({
            [it]: entry[it]
        })) : {};

        this._depthTracker.push({
            ...this._lastDepthTrackerInheritedProps,
            ...additionalData,
            depth,
            name: entry.name,
            type: entry.type,
            ixHeader: this._headerIndex,
            source: this._lastDepthTrackerInheritedProps.source,
            data: entry.data,
            page: entry.page,
            alias: entry.alias,
            entry,
        });
    }
    ;

    this.addPlugin = function(pluginType, fnPlugin) {
        MiscUtil.getOrSet(this._plugins, pluginType, []).push(fnPlugin);
    }
    ;

    this.removePlugin = function(pluginType, fnPlugin) {
        if (!fnPlugin)
            return;
        const ix = (MiscUtil.get(this._plugins, pluginType) || []).indexOf(fnPlugin);
        if (~ix)
            this._plugins[pluginType].splice(ix, 1);
    }
    ;

    this.removePlugins = function(pluginType) {
        MiscUtil.delete(this._plugins, pluginType);
    }
    ;

    this._getPlugins = function(pluginType) {
        return this._plugins[pluginType] || [];
    }
    ;

    this.withPlugin = function({pluginTypes, fnPlugin, fn}) {
        for (const pt of pluginTypes)
            this.addPlugin(pt, fnPlugin);
        try {
            return fn(this);
        } finally {
            for (const pt of pluginTypes)
                this.removePlugin(pt, fnPlugin);
        }
    }
    ;

    this.pWithPlugin = async function({pluginTypes, fnPlugin, pFn}) {
        for (const pt of pluginTypes)
            this.addPlugin(pt, fnPlugin);
        try {
            const out = await pFn(this);
            return out;
        } finally {
            for (const pt of pluginTypes)
                this.removePlugin(pt, fnPlugin);
        }
    }
    ;

    this.setDepthTracker = function(arr, {additionalProps, additionalPropsInherited}={}) {
        this._depthTracker = arr;
        this._depthTrackerAdditionalProps = additionalProps || [];
        this._depthTrackerAdditionalPropsInherited = additionalPropsInherited || [];
        return this;
    }
    ;

    this.getLineBreak = function() {
        return "<br>";
    }
    ;

    this.recursiveRender = function(entry, textStack, meta, options) {
        if (entry instanceof Array) {
            entry.forEach(nxt=>this.recursiveRender(nxt, textStack, meta, options));
            setTimeout(()=>{
                throw new Error(`Array passed to renderer! The renderer only guarantees support for primitives and basic objects.`);
            }
            );
            return this;
        }

        if (textStack.length === 0)
            textStack[0] = "";
        else
            textStack.reverse();

        meta = meta || {};
        meta._typeStack = [];
        meta.depth = meta.depth == null ? 0 : meta.depth;

        this._recursiveRender(entry, textStack, meta, options);
        if (this._fnPostProcess)
            textStack[0] = this._fnPostProcess(textStack[0]);
        textStack.reverse();

        return this;
    }
    ;

    this._recursiveRender = function(entry, textStack, meta, options) {
        if (entry == null)
            return;
        if (!textStack)
            throw new Error("Missing stack!");
        if (!meta)
            throw new Error("Missing metadata!");
        if (entry.type === "section")
            meta.depth = -1;

        options = options || {};

        meta._didRenderPrefix = false;
        meta._didRenderSuffix = false;

        if (typeof entry === "object") {
            const type = entry.type == null || entry.type === "section" ? "entries" : entry.type;

            if (type === "wrapper")
                return this._recursiveRender(entry.wrapped, textStack, meta, options);

            meta._typeStack.push(type);

            switch (type) {
            case "entries":
                this._renderEntries(entry, textStack, meta, options);
                break;
            case "options":
                this._renderOptions(entry, textStack, meta, options);
                break;
            case "list":
                this._renderList(entry, textStack, meta, options);
                break;
            case "table":
                this._renderTable(entry, textStack, meta, options);
                break;
            case "tableGroup":
                this._renderTableGroup(entry, textStack, meta, options);
                break;
            case "inset":
                this._renderInset(entry, textStack, meta, options);
                break;
            case "insetReadaloud":
                this._renderInsetReadaloud(entry, textStack, meta, options);
                break;
            case "variant":
                this._renderVariant(entry, textStack, meta, options);
                break;
            case "variantInner":
                this._renderVariantInner(entry, textStack, meta, options);
                break;
            case "variantSub":
                this._renderVariantSub(entry, textStack, meta, options);
                break;
            case "spellcasting":
                this._renderSpellcasting(entry, textStack, meta, options);
                break;
            case "quote":
                this._renderQuote(entry, textStack, meta, options);
                break;
            case "optfeature":
                this._renderOptfeature(entry, textStack, meta, options);
                break;
            case "patron":
                this._renderPatron(entry, textStack, meta, options);
                break;

            case "abilityDc":
                this._renderAbilityDc(entry, textStack, meta, options);
                break;
            case "abilityAttackMod":
                this._renderAbilityAttackMod(entry, textStack, meta, options);
                break;
            case "abilityGeneric":
                this._renderAbilityGeneric(entry, textStack, meta, options);
                break;

            case "inline":
                this._renderInline(entry, textStack, meta, options);
                break;
            case "inlineBlock":
                this._renderInlineBlock(entry, textStack, meta, options);
                break;
            case "bonus":
                this._renderBonus(entry, textStack, meta, options);
                break;
            case "bonusSpeed":
                this._renderBonusSpeed(entry, textStack, meta, options);
                break;
            case "dice":
                this._renderDice(entry, textStack, meta, options);
                break;
            case "link":
                this._renderLink(entry, textStack, meta, options);
                break;
            case "actions":
                this._renderActions(entry, textStack, meta, options);
                break;
            case "attack":
                this._renderAttack(entry, textStack, meta, options);
                break;
            case "ingredient":
                this._renderIngredient(entry, textStack, meta, options);
                break;

            case "item":
                this._renderItem(entry, textStack, meta, options);
                break;
            case "itemSub":
                this._renderItemSub(entry, textStack, meta, options);
                break;
            case "itemSpell":
                this._renderItemSpell(entry, textStack, meta, options);
                break;

            case "statblockInline":
                this._renderStatblockInline(entry, textStack, meta, options);
                break;
            case "statblock":
                this._renderStatblock(entry, textStack, meta, options);
                break;

            case "image":
                this._renderImage(entry, textStack, meta, options);
                break;
            case "gallery":
                this._renderGallery(entry, textStack, meta, options);
                break;

            case "flowchart":
                this._renderFlowchart(entry, textStack, meta, options);
                break;
            case "flowBlock":
                this._renderFlowBlock(entry, textStack, meta, options);
                break;

            case "homebrew":
                this._renderHomebrew(entry, textStack, meta, options);
                break;

            case "code":
                this._renderCode(entry, textStack, meta, options);
                break;
            case "hr":
                this._renderHr(entry, textStack, meta, options);
                break;
            }

            meta._typeStack.pop();
        } else if (typeof entry === "string") {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderString(entry, textStack, meta, options);
            this._renderSuffix(entry, textStack, meta, options);
        } else {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderPrimitive(entry, textStack, meta, options);
            this._renderSuffix(entry, textStack, meta, options);
        }
    }
    ;

    this._RE_TEXT_CENTER = /\btext-center\b/;

    this._getMutatedStyleString = function(str) {
        if (!str)
            return str;
        return str.replace(this._RE_TEXT_CENTER, "ve-text-center");
    }
    ;

    this._adjustDepth = function(meta, dDepth) {
        const cachedDepth = meta.depth;
        meta.depth += dDepth;
        meta.depth = Math.min(Math.max(-1, meta.depth), 2);
        return cachedDepth;
    }
    ;

    this._renderPrefix = function(entry, textStack, meta, options) {
        if (meta._didRenderPrefix)
            return;
        if (options.prefix != null) {
            textStack[0] += options.prefix;
            meta._didRenderPrefix = true;
        }
    }
    ;

    this._renderSuffix = function(entry, textStack, meta, options) {
        if (meta._didRenderSuffix)
            return;
        if (options.suffix != null) {
            textStack[0] += options.suffix;
            meta._didRenderSuffix = true;
        }
    }
    ;

    this._renderImage = function(entry, textStack, meta, options) {
        if (entry.title)
            this._handleTrackTitles(entry.title, {
                isImage: true
            });

        textStack[0] += `<div class="float-clear"></div>`;

        if (entry.imageType === "map" || entry.imageType === "mapPlayer")
            textStack[0] += `<div class="rd__wrp-map">`;
        textStack[0] += `<div class="${meta._typeStack.includes("gallery") ? "rd__wrp-gallery-image" : ""}">`;

        const href = this._renderImage_getUrl(entry);
        const svg = this._lazyImages && entry.width != null && entry.height != null ? `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="${entry.width}" height="${entry.height}"><rect width="100%" height="100%" fill="#ccc3"></rect></svg>`)}` : null;
        const ptTitleCreditTooltip = this._renderImage_getTitleCreditTooltipText(entry);
        const ptTitle = ptTitleCreditTooltip ? `title="${ptTitleCreditTooltip}"` : "";
        const pluginDataIsNoLink = this._getPlugins("image_isNoLink").map(plugin=>plugin(entry, textStack, meta, options)).some(Boolean);

        textStack[0] += `<div class="${this._renderImage_getWrapperClasses(entry, meta)}" ${entry.title && this._isHeaderIndexIncludeImageTitles ? `data-title-index="${this._headerIndex++}"` : ""}>
			${pluginDataIsNoLink ? "" : `<a href="${href}" target="_blank" rel="noopener noreferrer" ${ptTitle}>`}
				<img class="${this._renderImage_getImageClasses(entry, meta)}" src="${svg || href}" ${pluginDataIsNoLink ? ptTitle : ""} ${entry.altText || entry.title ? `alt="${Renderer.stripTags((entry.altText || entry.title)).qq()}"` : ""} ${svg ? `data-src="${href}"` : `loading="lazy"`} ${this._renderImage_getStylePart(entry)}>
			${pluginDataIsNoLink ? "" : `</a>`}
		</div>`;

        if (!this._renderImage_isComicStyling(entry) && (entry.title || entry.credit || entry.mapRegions)) {
            const ptAdventureBookMeta = entry.mapRegions && meta.adventureBookPage && meta.adventureBookSource && meta.adventureBookHash ? `data-rd-adventure-book-map-page="${meta.adventureBookPage.qq()}" data-rd-adventure-book-map-source="${meta.adventureBookSource.qq()}" data-rd-adventure-book-map-hash="${meta.adventureBookHash.qq()}"` : "";

            textStack[0] += `<div class="rd__image-title">`;

            if (entry.title && !entry.mapRegions)
                textStack[0] += `<div class="rd__image-title-inner">${this.render(entry.title)}</div>`;

            if (entry.mapRegions && !IS_VTT) {
                textStack[0] += `<button class="btn btn-xs btn-default rd__image-btn-viewer" onclick="RenderMap.pShowViewer(event, this)" data-rd-packed-map="${this._renderImage_getMapRegionData(entry)}" ${ptAdventureBookMeta} title="Open Dynamic Viewer (SHIFT to Open in New Window)"><span class="glyphicon glyphicon-picture"></span> ${Renderer.stripTags(entry.title) || "Dynamic Viewer"}</button>`;
            }

            if (entry.credit)
                textStack[0] += `<div class="rd__image-credit ve-muted"><span class="glyphicon glyphicon-pencil" title="Art Credit"></span> ${this.render(entry.credit)}</div>`;

            textStack[0] += `</div>`;
        }

        if (entry._galleryTitlePad)
            textStack[0] += `<div class="rd__image-title">&nbsp;</div>`;
        if (entry._galleryCreditPad)
            textStack[0] += `<div class="rd__image-credit">&nbsp;</div>`;

        textStack[0] += `</div>`;
        if (entry.imageType === "map" || entry.imageType === "mapPlayer")
            textStack[0] += `</div>`;
    }
    ;

    this._renderImage_getTitleCreditTooltipText = function(entry) {
        if (!entry.title && !entry.credit)
            return null;
        return Renderer.stripTags([entry.title, entry.credit ? `Art credit: ${entry.credit}` : null].filter(Boolean).join(". "), ).qq();
    }
    ;

    this._renderImage_getStylePart = function(entry) {
        const styles = [entry.maxWidth ? `max-width: min(100%, ${entry.maxWidth}${entry.maxWidthUnits || "px"})` : "", entry.maxHeight ? `max-height: min(60vh, ${entry.maxHeight}${entry.maxHeightUnits || "px"})` : "", ].filter(Boolean).join("; ");
        return styles ? `style="${styles}"` : "";
    }
    ;

    this._renderImage_getMapRegionData = function(entry) {
        return JSON.stringify(this.getMapRegionData(entry)).escapeQuotes();
    }
    ;

    this.getMapRegionData = function(entry) {
        return {
            regions: entry.mapRegions,
            width: entry.width,
            height: entry.height,
            href: this._renderImage_getUrl(entry),
            hrefThumbnail: this._renderImage_getUrlThumbnail(entry),
            page: entry.page,
            source: entry.source,
            hash: entry.hash,
        };
    }
    ;

    this._renderImage_isComicStyling = function(entry) {
        if (!entry.style)
            return false;
        return ["comic-speaker-left", "comic-speaker-right"].includes(entry.style);
    }
    ;

    this._renderImage_getWrapperClasses = function(entry) {
        const out = ["rd__wrp-image", "relative"];
        if (entry.style) {
            switch (entry.style) {
            case "comic-speaker-left":
                out.push("rd__comic-img-speaker", "rd__comic-img-speaker--left");
                break;
            case "comic-speaker-right":
                out.push("rd__comic-img-speaker", "rd__comic-img-speaker--right");
                break;
            }
        }
        return out.join(" ");
    }
    ;

    this._renderImage_getImageClasses = function(entry) {
        const out = ["rd__image"];
        if (entry.style) {
            switch (entry.style) {
            case "deity-symbol":
                out.push("rd__img-small");
                break;
            }
        }
        return out.join(" ");
    }
    ;

    this._renderImage_getUrl = function(entry) {
        let url = Renderer.utils.getMediaUrl(entry, "href", "img");
        for (const plugin of this._getPlugins(`image_urlPostProcess`)) {
            url = plugin(entry, url) || url;
        }
        return url;
    }
    ;

    this._renderImage_getUrlThumbnail = function(entry) {
        let url = Renderer.utils.getMediaUrl(entry, "hrefThumbnail", "img");
        for (const plugin of this._getPlugins(`image_urlThumbnailPostProcess`)) {
            url = plugin(entry, url) || url;
        }
        return url;
    }
    ;

    this._renderList_getListCssClasses = function(entry, textStack, meta, options) {
        const out = [`rd__list`];
        if (entry.style || entry.columns) {
            if (entry.style)
                out.push(...entry.style.split(" ").map(it=>`rd__${it}`));
            if (entry.columns)
                out.push(`columns-${entry.columns}`);
        }
        return out.join(" ");
    }
    ;

    this._renderTableGroup = function(entry, textStack, meta, options) {
        const len = entry.tables.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.tables[i], textStack, meta);
    }
    ;

    this._renderTable = function(entry, textStack, meta, options) {
        if (entry.intro) {
            const len = entry.intro.length;
            for (let i = 0; i < len; ++i) {
                this._recursiveRender(entry.intro[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
            }
        }

        textStack[0] += `<table class="w-100 rd__table ${this._getMutatedStyleString(entry.style || "")} ${entry.isStriped === false ? "" : "stripe-odd-table"}">`;

        const headerRowMetas = Renderer.table.getHeaderRowMetas(entry);
        const autoRollMode = Renderer.table.getAutoConvertedRollMode(entry, {
            headerRowMetas
        });
        const toRenderLabel = autoRollMode ? RollerUtil.getFullRollCol(headerRowMetas.last()[0]) : null;
        const isInfiniteResults = autoRollMode === RollerUtil.ROLL_COL_VARIABLE;

        if (entry.caption != null) {
            this._handleTrackTitles(entry.caption, {
                isTable: true
            });
            textStack[0] += `<caption ${this._isHeaderIndexIncludeTableCaptions ? `data-title-index="${this._headerIndex++}"` : ""}>${entry.caption}</caption>`;
        }

        const rollCols = [];
        let bodyStack = [""];
        bodyStack[0] += "<tbody>";
        const lenRows = entry.rows.length;
        for (let ixRow = 0; ixRow < lenRows; ++ixRow) {
            bodyStack[0] += "<tr>";
            const r = entry.rows[ixRow];
            let roRender = r.type === "row" ? r.row : r;

            const len = roRender.length;
            for (let ixCell = 0; ixCell < len; ++ixCell) {
                rollCols[ixCell] = rollCols[ixCell] || false;

                if (autoRollMode && ixCell === 0) {
                    roRender = Renderer.getRollableRow(roRender, {
                        isForceInfiniteResults: isInfiniteResults,
                        isFirstRow: ixRow === 0,
                        isLastRow: ixRow === lenRows - 1,
                    }, );
                    rollCols[ixCell] = true;
                }

                let toRenderCell;
                if (roRender[ixCell].type === "cell") {
                    if (roRender[ixCell].roll) {
                        rollCols[ixCell] = true;
                        if (roRender[ixCell].entry) {
                            toRenderCell = roRender[ixCell].entry;
                        } else if (roRender[ixCell].roll.exact != null) {
                            toRenderCell = roRender[ixCell].roll.pad ? StrUtil.padNumber(roRender[ixCell].roll.exact, 2, "0") : roRender[ixCell].roll.exact;
                        } else {

                            const dispMin = roRender[ixCell].roll.displayMin != null ? roRender[ixCell].roll.displayMin : roRender[ixCell].roll.min;
                            const dispMax = roRender[ixCell].roll.displayMax != null ? roRender[ixCell].roll.displayMax : roRender[ixCell].roll.max;

                            if (dispMax === Renderer.dice.POS_INFINITE) {
                                toRenderCell = roRender[ixCell].roll.pad ? `${StrUtil.padNumber(dispMin, 2, "0")}+` : `${dispMin}+`;
                            } else {
                                toRenderCell = roRender[ixCell].roll.pad ? `${StrUtil.padNumber(dispMin, 2, "0")}-${StrUtil.padNumber(dispMax, 2, "0")}` : `${dispMin}-${dispMax}`;
                            }
                        }
                    } else if (roRender[ixCell].entry) {
                        toRenderCell = roRender[ixCell].entry;
                    }
                } else {
                    toRenderCell = roRender[ixCell];
                }
                bodyStack[0] += `<td ${this._renderTable_makeTableTdClassText(entry, ixCell)} ${this._renderTable_getCellDataStr(roRender[ixCell])} ${roRender[ixCell].type === "cell" && roRender[ixCell].width ? `colspan="${roRender[ixCell].width}"` : ""}>`;
                if (r.style === "row-indent-first" && ixCell === 0)
                    bodyStack[0] += `<div class="rd__tab-indent"></div>`;
                const cacheDepth = this._adjustDepth(meta, 1);
                this._recursiveRender(toRenderCell, bodyStack, meta);
                meta.depth = cacheDepth;
                bodyStack[0] += "</td>";
            }
            bodyStack[0] += "</tr>";
        }
        bodyStack[0] += "</tbody>";

        if (headerRowMetas) {
            textStack[0] += "<thead>";

            for (let ixRow = 0, lenRows = headerRowMetas.length; ixRow < lenRows; ++ixRow) {
                textStack[0] += "<tr>";

                const headerRowMeta = headerRowMetas[ixRow];
                for (let ixCell = 0, lenCells = headerRowMeta.length; ixCell < lenCells; ++ixCell) {
                    const lbl = headerRowMeta[ixCell];
                    textStack[0] += `<th ${this._renderTable_getTableThClassText(entry, ixCell)} data-rd-isroller="${rollCols[ixCell]}" ${entry.isNameGenerator ? `data-rd-namegeneratorrolls="${headerRowMeta.length - 1}"` : ""}>`;
                    this._recursiveRender(autoRollMode && ixCell === 0 ? RollerUtil.getFullRollCol(lbl) : lbl, textStack, meta);
                    textStack[0] += `</th>`;
                }

                textStack[0] += "</tr>";
            }

            textStack[0] += "</thead>";
        }

        textStack[0] += bodyStack[0];

        if (entry.footnotes != null) {
            textStack[0] += "<tfoot>";
            const len = entry.footnotes.length;
            for (let i = 0; i < len; ++i) {
                textStack[0] += `<tr><td colspan="99">`;
                const cacheDepth = this._adjustDepth(meta, 1);
                this._recursiveRender(entry.footnotes[i], textStack, meta);
                meta.depth = cacheDepth;
                textStack[0] += "</td></tr>";
            }
            textStack[0] += "</tfoot>";
        }
        textStack[0] += "</table>";

        if (entry.outro) {
            const len = entry.outro.length;
            for (let i = 0; i < len; ++i) {
                this._recursiveRender(entry.outro[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
            }
        }
    }
    ;

    this._renderTable_getCellDataStr = function(ent) {
        function convertZeros(num) {
            if (num === 0)
                return 100;
            return num;
        }

        if (ent.roll) {
            return `data-roll-min="${convertZeros(ent.roll.exact != null ? ent.roll.exact : ent.roll.min)}" data-roll-max="${convertZeros(ent.roll.exact != null ? ent.roll.exact : ent.roll.max)}"`;
        }

        return "";
    }
    ;

    this._renderTable_getTableThClassText = function(entry, i) {
        return entry.colStyles == null || i >= entry.colStyles.length ? "" : `class="${this._getMutatedStyleString(entry.colStyles[i])}"`;
    }
    ;

    this._renderTable_makeTableTdClassText = function(entry, i) {
        if (entry.rowStyles != null)
            return i >= entry.rowStyles.length ? "" : `class="${this._getMutatedStyleString(entry.rowStyles[i])}"`;
        else
            return this._renderTable_getTableThClassText(entry, i);
    }
    ;

    this._renderEntries = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, true);
    }
    ;

    this._getPagePart = function(entry, isInset) {
        if (!Renderer.utils.isDisplayPage(entry.page))
            return "";
        return ` <span class="rd__title-link ${isInset ? `rd__title-link--inset` : ""}">${entry.source ? `<span class="help-subtle" title="${Parser.sourceJsonToFull(entry.source)}">${Parser.sourceJsonToAbv(entry.source)}</span> ` : ""}p${entry.page}</span>`;
    }
    ;

    this._renderEntriesSubtypes = function(entry, textStack, meta, options, incDepth) {
        const type = entry.type || "entries";
        const isInlineTitle = meta.depth >= 2;
        const isAddPeriod = isInlineTitle && entry.name && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
        const pagePart = !this._isPartPageExpandCollapseDisabled && !isInlineTitle ? this._getPagePart(entry) : "";
        const partExpandCollapse = !this._isPartPageExpandCollapseDisabled && !isInlineTitle ? `<span class="rd__h-toggle ml-2 clickable no-select" data-rd-h-toggle-button="true" title="Toggle Visibility (CTRL to Toggle All)">[\u2013]</span>` : "";
        const partPageExpandCollapse = !this._isPartPageExpandCollapseDisabled && (pagePart || partExpandCollapse) ? `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>` : "";
        const nextDepth = incDepth && meta.depth < 2 ? meta.depth + 1 : meta.depth;
        const styleString = this._renderEntriesSubtypes_getStyleString(entry, meta, isInlineTitle);
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);

        const headerTag = isInlineTitle ? "span" : `h${Math.min(Math.max(meta.depth + 2, 1), 6)}`;
        const headerClass = `rd__h--${meta.depth + 1}`;
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, meta.depth);

        const pluginDataNamePrefix = this._getPlugins(`${type}_namePrefix`).map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);

        const headerSpan = entry.name ? `<${headerTag} class="rd__h ${headerClass}" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}> <span class="entry-title-inner${!pagePart && entry.source ? ` help-subtle` : ""}"${!pagePart && entry.source ? ` title="Source: ${Parser.sourceJsonToFull(entry.source)}${entry.page ? `, p${entry.page}` : ""}"` : ""}>${pluginDataNamePrefix.join("")}${this.render({
            type: "inline",
            entries: [entry.name]
        })}${isAddPeriod ? "." : ""}</span>${partPageExpandCollapse}</${headerTag}> ` : "";

        if (meta.depth === -1) {
            if (!this._firstSection)
                textStack[0] += `<hr class="rd__hr rd__hr--section">`;
            this._firstSection = false;
        }

        if (entry.entries || entry.name) {
            textStack[0] += `<${this.wrapperTag} ${dataString} ${styleString}>${headerSpan}`;
            this._renderEntriesSubtypes_renderPreReqText(entry, textStack, meta);
            if (entry.entries) {
                const cacheDepth = meta.depth;
                const len = entry.entries.length;
                for (let i = 0; i < len; ++i) {
                    meta.depth = nextDepth;
                    this._recursiveRender(entry.entries[i], textStack, meta, {
                        prefix: "<p>",
                        suffix: "</p>"
                    });
                    if (i === 0 && cacheDepth >= 2)
                        textStack[0] += `<div class="rd__spc-inline-post"></div>`;
                }
                meta.depth = cacheDepth;
            }
            textStack[0] += `</${this.wrapperTag}>`;
        }

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderEntriesSubtypes_getDataString = function(entry) {
        let dataString = "";
        if (entry.source)
            dataString += `data-source="${entry.source}"`;
        if (entry.data) {
            for (const k in entry.data) {
                if (!k.startsWith("rd-"))
                    continue;
                dataString += ` data-${k}="${`${entry.data[k]}`.escapeQuotes()}"`;
            }
        }
        return dataString;
    }
    ;

    this._renderEntriesSubtypes_renderPreReqText = function(entry, textStack, meta) {
        if (entry.prerequisite) {
            textStack[0] += `<span class="rd__prerequisite">Prerequisite: `;
            this._recursiveRender({
                type: "inline",
                entries: [entry.prerequisite]
            }, textStack, meta);
            textStack[0] += `</span>`;
        }
    }
    ;

    this._renderEntriesSubtypes_getStyleString = function(entry, meta, isInlineTitle) {
        const styleClasses = ["rd__b"];
        styleClasses.push(this._getStyleClass(entry.type || "entries", entry));
        if (isInlineTitle) {
            if (this._subVariant)
                styleClasses.push(Renderer.HEAD_2_SUB_VARIANT);
            else
                styleClasses.push(Renderer.HEAD_2);
        } else
            styleClasses.push(meta.depth === -1 ? Renderer.HEAD_NEG_1 : meta.depth === 0 ? Renderer.HEAD_0 : Renderer.HEAD_1);
        return styleClasses.length > 0 ? `class="${styleClasses.join(" ")}"` : "";
    }
    ;

    this._renderOptions = function(entry, textStack, meta, options) {
        if (!entry.entries)
            return;
        entry.entries = entry.entries.sort((a,b)=>a.name && b.name ? SortUtil.ascSort(a.name, b.name) : a.name ? -1 : b.name ? 1 : 0);

        if (entry.style && entry.style === "list-hang-notitle") {
            const fauxEntry = {
                type: "list",
                style: "list-hang-notitle",
                items: entry.entries.map(ent=>{
                    if (typeof ent === "string")
                        return ent;
                    if (ent.type === "item")
                        return ent;

                    const out = {
                        ...ent,
                        type: "item"
                    };
                    if (ent.name)
                        out.name = Renderer._INLINE_HEADER_TERMINATORS.has(ent.name[ent.name.length - 1]) ? out.name : `${out.name}.`;
                    return out;
                }
                ),
            };
            this._renderList(fauxEntry, textStack, meta, options);
        } else
            this._renderEntriesSubtypes(entry, textStack, meta, options, false);
    }
    ;

    this._renderList = function(entry, textStack, meta, options) {
        if (entry.items) {
            const tag = entry.start ? "ol" : "ul";
            const cssClasses = this._renderList_getListCssClasses(entry, textStack, meta, options);
            textStack[0] += `<${tag} ${cssClasses ? `class="${cssClasses}"` : ""} ${entry.start ? `start="${entry.start}"` : ""}>`;
            if (entry.name)
                textStack[0] += `<li class="rd__list-name">${entry.name}</li>`;
            const isListHang = entry.style && entry.style.split(" ").includes("list-hang");
            const len = entry.items.length;
            for (let i = 0; i < len; ++i) {
                const item = entry.items[i];
                if (item.type !== "list") {
                    const className = `${this._getStyleClass(entry.type, item)}${item.type === "itemSpell" ? " rd__li-spell" : ""}`;
                    textStack[0] += `<li class="rd__li ${className}">`;
                }
                if (isListHang && typeof item === "string")
                    textStack[0] += "<div>";
                this._recursiveRender(item, textStack, meta);
                if (isListHang && typeof item === "string")
                    textStack[0] += "</div>";
                if (item.type !== "list")
                    textStack[0] += "</li>";
            }
            textStack[0] += `</${tag}>`;
        }
    }
    ;

    this._getPtExpandCollapseSpecial = function() {
        return `<span class="rd__h-toggle ml-2 clickable no-select" data-rd-h-special-toggle-button="true" title="Toggle Visibility (CTRL to Toggle All)">[\u2013]</span>`;
    }
    ;

    this._renderInset = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset ${this._getMutatedStyleString(entry.style || "")}" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4>${partPageExpandCollapse}</span>`;
        } else {
            textStack[0] += `<span class="rd__h rd__h--2-inset rd__h--2-inset-no-name">${partPageExpandCollapse}</span>`;
        }

        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i) {
                const cacheDepth = meta.depth;
                meta.depth = 2;
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
                meta.depth = cacheDepth;
            }
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderInsetReadaloud = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset rd__b-inset--readaloud ${this._getMutatedStyleString(entry.style || "")}" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4>${this._getPagePart(entry, true)}</span>`;
        } else {
            textStack[0] += `<span class="rd__h rd__h--2-inset rd__h--2-inset-no-name">${partPageExpandCollapse}</span>`;
        }

        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariant = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        const pagePart = this._getPagePart(entry, true);
        const partExpandCollapse = this._getPtExpandCollapseSpecial();
        const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset" ${dataString}>`;
        textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">Variant: ${entry.name}</h4>${partPageExpandCollapse}</span>`;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        if (entry.source)
            textStack[0] += Renderer.utils.getSourceAndPageTrHtml({
                source: entry.source,
                page: entry.page
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariantInner = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        textStack[0] += `<${this.wrapperTag} class="rd__b-inset-inner" ${dataString}>`;
        textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4></span>`;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            const cacheDepth = meta.depth;
            meta.depth = 2;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
            meta.depth = cacheDepth;
        }
        if (entry.source)
            textStack[0] += Renderer.utils.getSourceAndPageTrHtml({
                source: entry.source,
                page: entry.page
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderVariantSub = function(entry, textStack, meta, options) {
        this._subVariant = true;
        const fauxEntry = entry;
        fauxEntry.type = "entries";
        const cacheDepth = meta.depth;
        meta.depth = 3;
        this._recursiveRender(fauxEntry, textStack, meta, {
            prefix: "<p>",
            suffix: "</p>"
        });
        meta.depth = cacheDepth;
        this._subVariant = false;
    }
    ;

    this._renderSpellcasting_getEntries = function(entry) {
        const hidden = new Set(entry.hidden || []);
        const toRender = [{
            type: "entries",
            name: entry.name,
            entries: entry.headerEntries ? MiscUtil.copyFast(entry.headerEntries) : []
        }];

        if (entry.constant || entry.will || entry.recharge || entry.charges || entry.rest || entry.daily || entry.weekly || entry.yearly || entry.ritual) {
            const tempList = {
                type: "list",
                style: "list-hang-notitle",
                items: [],
                data: {
                    isSpellList: true
                }
            };
            if (entry.constant && !hidden.has("constant"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `Constant:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.constant).join(", ")
                });
            if (entry.will && !hidden.has("will"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `At will:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.will).join(", ")
                });

            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "recharge",
                fnGetDurationText: num=>`{@recharge ${num}|m}`,
                isSkipPrefix: true
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "charges",
                fnGetDurationText: num=>` charge${num === 1 ? "" : "s"}`
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "rest",
                durationText: "/rest"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "daily",
                durationText: "/day"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "weekly",
                durationText: "/week"
            });
            this._renderSpellcasting_getEntries_procPerDuration({
                entry,
                tempList,
                hidden,
                prop: "yearly",
                durationText: "/year"
            });

            if (entry.ritual && !hidden.has("ritual"))
                tempList.items.push({
                    type: "itemSpell",
                    name: `Rituals:`,
                    entry: this._renderSpellcasting_getRenderableList(entry.ritual).join(", ")
                });
            tempList.items = tempList.items.filter(it=>it.entry !== "");
            if (tempList.items.length)
                toRender[0].entries.push(tempList);
        }

        if (entry.spells && !hidden.has("spells")) {
            const tempList = {
                type: "list",
                style: "list-hang-notitle",
                items: [],
                data: {
                    isSpellList: true
                }
            };

            const lvls = Object.keys(entry.spells).map(lvl=>Number(lvl)).sort(SortUtil.ascSort);

            for (const lvl of lvls) {
                const spells = entry.spells[lvl];
                if (spells) {
                    let levelCantrip = `${Parser.spLevelToFull(lvl)}${(lvl === 0 ? "s" : " level")}`;
                    let slotsAtWill = ` (at will)`;
                    const slots = spells.slots;
                    if (slots >= 0)
                        slotsAtWill = slots > 0 ? ` (${slots} slot${slots > 1 ? "s" : ""})` : ``;
                    if (spells.lower && spells.lower !== lvl) {
                        levelCantrip = `${Parser.spLevelToFull(spells.lower)}-${levelCantrip}`;
                        if (slots >= 0)
                            slotsAtWill = slots > 0 ? ` (${slots} ${Parser.spLevelToFull(lvl)}-level slot${slots > 1 ? "s" : ""})` : ``;
                    }
                    tempList.items.push({
                        type: "itemSpell",
                        name: `${levelCantrip}${slotsAtWill}:`,
                        entry: this._renderSpellcasting_getRenderableList(spells.spells).join(", ") || "\u2014"
                    });
                }
            }

            toRender[0].entries.push(tempList);
        }

        if (entry.footerEntries)
            toRender.push({
                type: "entries",
                entries: entry.footerEntries
            });
        return toRender;
    }
    ;

    this._renderSpellcasting_getEntries_procPerDuration = function({entry, hidden, tempList, prop, durationText, fnGetDurationText, isSkipPrefix}) {
        if (!entry[prop] || hidden.has(prop))
            return;

        for (let lvl = 9; lvl > 0; lvl--) {
            const perDur = entry[prop];
            if (perDur[lvl]) {
                tempList.items.push({
                    type: "itemSpell",
                    name: `${isSkipPrefix ? "" : lvl}${fnGetDurationText ? fnGetDurationText(lvl) : durationText}:`,
                    entry: this._renderSpellcasting_getRenderableList(perDur[lvl]).join(", "),
                });
            }

            const lvlEach = `${lvl}e`;
            if (perDur[lvlEach]) {
                const isHideEach = !perDur[lvl] && perDur[lvlEach].length === 1;
                tempList.items.push({
                    type: "itemSpell",
                    name: `${isSkipPrefix ? "" : lvl}${fnGetDurationText ? fnGetDurationText(lvl) : durationText}${isHideEach ? "" : ` each`}:`,
                    entry: this._renderSpellcasting_getRenderableList(perDur[lvlEach]).join(", "),
                });
            }
        }
    }
    ;

    this._renderSpellcasting_getRenderableList = function(spellList) {
        return spellList.filter(it=>!it.hidden).map(it=>it.entry || it);
    }
    ;

    this._renderSpellcasting = function(entry, textStack, meta, options) {
        const toRender = this._renderSpellcasting_getEntries(entry);
        if (!toRender?.[0].entries?.length)
            return;
        this._recursiveRender({
            type: "entries",
            entries: toRender
        }, textStack, meta);
    }
    ;

    this._renderQuote = function(entry, textStack, meta, options) {
        textStack[0] += `<div class="${this._renderList_getQuoteCssClasses(entry, textStack, meta, options)}">`;

        const len = entry.entries.length;
        for (let i = 0; i < len; ++i) {
            textStack[0] += `<p class="rd__quote-line ${i === len - 1 && entry.by ? `rd__quote-line--last` : ""}">${i === 0 && !entry.skipMarks ? "&ldquo;" : ""}`;
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: entry.skipItalics ? "" : "<i>",
                suffix: entry.skipItalics ? "" : "</i>"
            });
            textStack[0] += `${i === len - 1 && !entry.skipMarks ? "&rdquo;" : ""}</p>`;
        }

        if (entry.by || entry.from) {
            textStack[0] += `<p>`;
            const tempStack = [""];
            const byArr = this._renderQuote_getBy(entry);
            if (byArr) {
                for (let i = 0, len = byArr.length; i < len; ++i) {
                    const by = byArr[i];
                    this._recursiveRender(by, tempStack, meta);
                    if (i < len - 1)
                        tempStack[0] += "<br>";
                }
            }
            textStack[0] += `<span class="rd__quote-by">\u2014 ${byArr ? tempStack.join("") : ""}${byArr && entry.from ? `, ` : ""}${entry.from ? `<i>${entry.from}</i>` : ""}</span>`;
            textStack[0] += `</p>`;
        }

        textStack[0] += `</div>`;
    }
    ;

    this._renderList_getQuoteCssClasses = function(entry, textStack, meta, options) {
        const out = [`rd__quote`];
        if (entry.style) {
            if (entry.style)
                out.push(...entry.style.split(" ").map(it=>`rd__${it}`));
        }
        return out.join(" ");
    }
    ;

    this._renderQuote_getBy = function(entry) {
        if (!entry.by?.length)
            return null;
        return entry.by instanceof Array ? entry.by : [entry.by];
    }
    ;

    this._renderOptfeature = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, true);
    }
    ;

    this._renderPatron = function(entry, textStack, meta, options) {
        this._renderEntriesSubtypes(entry, textStack, meta, options, false);
    }
    ;

    this._renderAbilityDc = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center"><b>`;
        this._recursiveRender(entry.name, textStack, meta);
        textStack[0] += ` save DC</b> = 8 + your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderAbilityAttackMod = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center"><b>`;
        this._recursiveRender(entry.name, textStack, meta);
        textStack[0] += ` attack modifier</b> = your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderAbilityGeneric = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="ve-text-center">`;
        if (entry.name)
            this._recursiveRender(entry.name, textStack, meta, {
                prefix: "<b>",
                suffix: "</b> = "
            });
        textStack[0] += `${entry.text}${entry.attributes ? ` ${Parser.attrChooseToFull(entry.attributes)}` : ""}</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderInline = function(entry, textStack, meta, options) {
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta);
        }
    }
    ;

    this._renderInlineBlock = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta);
        }
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderBonus = function(entry, textStack, meta, options) {
        textStack[0] += (entry.value < 0 ? "" : "+") + entry.value;
    }
    ;

    this._renderBonusSpeed = function(entry, textStack, meta, options) {
        textStack[0] += entry.value === 0 ? "\u2014" : `${entry.value < 0 ? "" : "+"}${entry.value} ft.`;
    }
    ;

    this._renderDice = function(entry, textStack, meta, options) {
        const pluginResults = this._getPlugins("dice").map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);

        textStack[0] += Renderer.getEntryDice(entry, entry.name, {
            isAddHandlers: this._isAddHandlers,
            pluginResults
        });
    }
    ;

    this._renderActions = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);

        if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
            this._handleTrackTitles(entry.name);
        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 2);

        textStack[0] += `<${this.wrapperTag} class="${Renderer.HEAD_2}" ${dataString}><span class="rd__h rd__h--3" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><span class="entry-title-inner">${entry.name}.</span></span> `;
        const len = entry.entries.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.entries[i], textStack, meta, {
                prefix: "<p>",
                suffix: "</p>"
            });
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderAttack = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<i>${Parser.attackTypeToFull(entry.attackType)}:</i> `;
        const len = entry.attackEntries.length;
        for (let i = 0; i < len; ++i)
            this._recursiveRender(entry.attackEntries[i], textStack, meta);
        textStack[0] += ` <i>Hit:</i> `;
        const len2 = entry.hitEntries.length;
        for (let i = 0; i < len2; ++i)
            this._recursiveRender(entry.hitEntries[i], textStack, meta);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderIngredient = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        this._recursiveRender(entry.entry, textStack, meta);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItem = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<p class="rd__p-list-item"><span class="${this._getMutatedStyleString(entry.style) || "bold"} rd__list-item-name">${this.render(entry.name)}${this._renderItem_isAddPeriod(entry) ? "." : ""}</span> `;
        if (entry.entry)
            this._recursiveRender(entry.entry, textStack, meta);
        else if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: i > 0 ? `<span class="rd__p-cont-indent">` : "",
                    suffix: i > 0 ? "</span>" : ""
                });
        }
        textStack[0] += "</p>";
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItem_isAddPeriod = function(entry) {
        return entry.name && entry.nameDot !== false && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
    }
    ;

    this._renderItemSub = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        const isAddPeriod = entry.name && entry.nameDot !== false && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
        this._recursiveRender(entry.entry, textStack, meta, {
            prefix: `<p class="rd__p-list-item"><span class="italic rd__list-item-name">${entry.name}${isAddPeriod ? "." : ""}</span> `,
            suffix: "</p>"
        });
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderItemSpell = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);

        const tempStack = [""];
        this._recursiveRender(entry.name || "", tempStack, meta);

        this._recursiveRender(entry.entry, textStack, meta, {
            prefix: `<p>${tempStack.join("")} `,
            suffix: "</p>"
        });
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._InlineStatblockStrategy = function({pFnPreProcess, }, ) {
        this.pFnPreProcess = pFnPreProcess;
    }
    ;

    this._INLINE_STATBLOCK_STRATEGIES = {
        "item": new this._InlineStatblockStrategy({
            pFnPreProcess: async(ent)=>{
                await Renderer.item.pPopulatePropertyAndTypeReference();
                Renderer.item.enhanceItem(ent);
                return ent;
            }
            ,
        }),
    };

    this._renderStatblockInline = function(entry, textStack, meta, options) {
        const fnGetRenderCompact = Renderer.hover.getFnRenderCompact(entry.dataType);

        const headerName = entry.displayName || entry.data?.name;
        const headerStyle = entry.style;

        if (!fnGetRenderCompact) {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderDataHeader(textStack, headerName, headerStyle);
            textStack[0] += `<tr>
				<td colspan="6">
					<i class="text-danger">Cannot render &quot;${entry.type}&quot;&mdash;unknown data type &quot;${entry.dataType}&quot;!</i>
				</td>
			</tr>`;
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);
            return;
        }

        const strategy = this._INLINE_STATBLOCK_STRATEGIES[entry.dataType];

        if (!strategy?.pFnPreProcess && !entry.data?._copy) {
            this._renderPrefix(entry, textStack, meta, options);
            this._renderDataHeader(textStack, headerName, headerStyle, {
                isCollapsed: entry.collapsed
            });
            textStack[0] += fnGetRenderCompact(entry.data, {
                isEmbeddedEntity: true
            });
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);
            return;
        }

        this._renderPrefix(entry, textStack, meta, options);
        this._renderDataHeader(textStack, headerName, headerStyle, {
            isCollapsed: entry.collapsed
        });

        const id = CryptUtil.uid();
        Renderer._cache.inlineStatblock[id] = {
            pFn: async(ele)=>{
                const entLoaded = entry.data?._copy ? (await DataUtil.pDoMetaMergeSingle(entry.dataType, {
                    dependencies: {
                        [entry.dataType]: entry.dependencies
                    }
                }, entry.data, )) : entry.data;

                const ent = strategy?.pFnPreProcess ? await strategy.pFnPreProcess(entLoaded) : entLoaded;

                const tbl = ele.closest("table");
                const nxt = e_({
                    outer: Renderer.utils.getEmbeddedDataHeader(headerName, headerStyle, {
                        isCollapsed: entry.collapsed
                    }) + fnGetRenderCompact(ent, {
                        isEmbeddedEntity: true
                    }) + Renderer.utils.getEmbeddedDataFooter(),
                });
                tbl.parentNode.replaceChild(nxt, tbl, );
            }
            ,
        };

        textStack[0] += `<tr><td colspan="6"><style data-rd-cache-id="${id}" data-rd-cache="inlineStatblock" onload="Renderer._cache.pRunFromEle(this)"></style></td></tr>`;
        this._renderDataFooter(textStack);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderDataHeader = function(textStack, name, style, {isCollapsed=false}={}) {
        textStack[0] += Renderer.utils.getEmbeddedDataHeader(name, style, {
            isCollapsed
        });
    }
    ;

    this._renderDataFooter = function(textStack) {
        textStack[0] += Renderer.utils.getEmbeddedDataFooter();
    }
    ;

    this._renderStatblock = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);

        const page = entry.prop || Renderer.tag.getPage(entry.tag);
        const source = Parser.getTagSource(entry.tag, entry.source);
        const hash = entry.hash || (UrlUtil.URL_TO_HASH_BUILDER[page] ? UrlUtil.URL_TO_HASH_BUILDER[page]({
            ...entry,
            name: entry.name,
            source
        }) : null);

        const asTag = `{@${entry.tag} ${entry.name}|${source}${entry.displayName ? `|${entry.displayName}` : ""}}`;

        if (!page || !source || !hash) {
            this._renderDataHeader(textStack, entry.name, entry.style);
            textStack[0] += `<tr>
				<td colspan="6">
					<i class="text-danger">Cannot load ${entry.tag ? `&quot;${asTag}&quot;` : entry.displayName || entry.name}! An unknown tag/prop, source, or hash was provided.</i>
				</td>
			</tr>`;
            this._renderDataFooter(textStack);
            this._renderSuffix(entry, textStack, meta, options);

            return;
        }

        this._renderDataHeader(textStack, entry.displayName || entry.name, entry.style, {
            isCollapsed: entry.collapsed
        });
        textStack[0] += `<tr>
			<td colspan="6" data-rd-tag="${(entry.tag || "").qq()}" data-rd-page="${(page || "").qq()}" data-rd-source="${(source || "").qq()}" data-rd-hash="${(hash || "").qq()}" data-rd-name="${(entry.name || "").qq()}" data-rd-display-name="${(entry.displayName || "").qq()}" data-rd-style="${(entry.style || "").qq()}">
				<i>Loading ${entry.tag ? `${Renderer.get().render(asTag)}` : entry.displayName || entry.name}...</i>
				<style onload="Renderer.events.handleLoad_inlineStatblock(this)"></style>
			</td>
		</tr>`;
        this._renderDataFooter(textStack);
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderGallery = function(entry, textStack, meta, options) {
        if (entry.name)
            textStack[0] += `<h5 class="rd__gallery-name">${entry.name}</h5>`;
        textStack[0] += `<div class="rd__wrp-gallery">`;
        const len = entry.images.length;
        const anyNamed = entry.images.some(it=>it.title);
        const isAnyCredited = entry.images.some(it=>it.credit);
        for (let i = 0; i < len; ++i) {
            const img = MiscUtil.copyFast(entry.images[i]);

            if (anyNamed && !img.title)
                img._galleryTitlePad = true;
            if (isAnyCredited && !img.credit)
                img._galleryCreditPad = true;

            delete img.imageType;
            this._recursiveRender(img, textStack, meta, options);
        }
        textStack[0] += `</div>`;
    }
    ;

    this._renderFlowchart = function(entry, textStack, meta, options) {
        textStack[0] += `<div class="rd__wrp-flowchart">`;
        const len = entry.blocks.length;
        for (let i = 0; i < len; ++i) {
            this._recursiveRender(entry.blocks[i], textStack, meta, options);
            if (i !== len - 1) {
                textStack[0] += `<div class="rd__s-v-flow"></div>`;
            }
        }
        textStack[0] += `</div>`;
    }
    ;

    this._renderFlowBlock = function(entry, textStack, meta, options) {
        const dataString = this._renderEntriesSubtypes_getDataString(entry);
        textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-flow ve-text-center" ${dataString}>`;

        const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
        this._handleTrackDepth(entry, 1);

        if (entry.name != null) {
            if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type])
                this._handleTrackTitles(entry.name);
            textStack[0] += `<span class="rd__h rd__h--2-flow-block" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${this.render({
                type: "inline",
                entries: [entry.name]
            })}</h4></span>`;
        }
        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i) {
                const cacheDepth = meta.depth;
                meta.depth = 2;
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
                meta.depth = cacheDepth;
            }
        }
        textStack[0] += `<div class="float-clear"></div>`;
        textStack[0] += `</${this.wrapperTag}>`;

        this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
    }
    ;

    this._renderHomebrew = function(entry, textStack, meta, options) {
        this._renderPrefix(entry, textStack, meta, options);
        textStack[0] += `<div class="homebrew-section"><div class="homebrew-float"><span class="homebrew-notice"></span>`;

        if (entry.oldEntries) {
            const hoverMeta = Renderer.hover.getInlineHover({
                type: "entries",
                name: "Homebrew",
                entries: entry.oldEntries
            });
            let markerText;
            if (entry.movedTo) {
                markerText = "(See moved content)";
            } else if (entry.entries) {
                markerText = "(See replaced content)";
            } else {
                markerText = "(See removed content)";
            }
            textStack[0] += `<span class="homebrew-old-content" href="#${window.location.hash}" ${hoverMeta.html}>${markerText}</span>`;
        }

        textStack[0] += `</div>`;

        if (entry.entries) {
            const len = entry.entries.length;
            for (let i = 0; i < len; ++i)
                this._recursiveRender(entry.entries[i], textStack, meta, {
                    prefix: "<p>",
                    suffix: "</p>"
                });
        } else if (entry.movedTo) {
            textStack[0] += `<i>This content has been moved to ${entry.movedTo}.</i>`;
        } else {
            textStack[0] += "<i>This content has been deleted.</i>";
        }

        textStack[0] += `</div>`;
        this._renderSuffix(entry, textStack, meta, options);
    }
    ;

    this._renderCode = function(entry, textStack, meta, options) {
        const isWrapped = !!StorageUtil.syncGet("rendererCodeWrap");
        textStack[0] += `
			<div class="ve-flex-col h-100">
				<div class="ve-flex no-shrink pt-1">
					<button class="btn btn-default btn-xs mb-1 mr-2" onclick="Renderer.events.handleClick_copyCode(event, this)">Copy Code</button>
					<button class="btn btn-default btn-xs mb-1 ${isWrapped ? "active" : ""}" onclick="Renderer.events.handleClick_toggleCodeWrap(event, this)">Word Wrap</button>
				</div>
				<pre class="h-100 w-100 mb-1 ${isWrapped ? "rd__pre-wrap" : ""}">${entry.preformatted}</pre>
			</div>
		`;
    }
    ;

    this._renderHr = function(entry, textStack, meta, options) {
        textStack[0] += `<hr class="rd__hr">`;
    }
    ;

    this._getStyleClass = function(entryType, entry) {
        const outList = [];

        const pluginResults = this._getPlugins(`${entryType}_styleClass_fromSource`).map(plugin=>plugin(entryType, entry)).filter(Boolean);

        if (!pluginResults.some(it=>it.isSkip)) {
            if (SourceUtil.isNonstandardSource(entry.source) || (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(entry.source)))
                outList.push("spicy-sauce");
            if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(entry.source))
                outList.push("refreshing-brew");
        }

        if (this._extraSourceClasses)
            outList.push(...this._extraSourceClasses);
        for (const k in this._fnsGetStyleClasses) {
            const fromFn = this._fnsGetStyleClasses[k](entry);
            if (fromFn)
                outList.push(...fromFn);
        }
        if (entry.style)
            outList.push(this._getMutatedStyleString(entry.style));
        return outList.join(" ");
    }
    ;

    this._renderString = function(entry, textStack, meta, options) {
        const tagSplit = Renderer.splitByTags(entry);
        const len = tagSplit.length;
        for (let i = 0; i < len; ++i) {
            const s = tagSplit[i];
            if (!s)
                continue;
            if (s.startsWith("{@")) {
                const [tag,text] = Renderer.splitFirstSpace(s.slice(1, -1));
                this._renderString_renderTag(textStack, meta, options, tag, text);
            } else
                textStack[0] += s;
        }
    }
    ;

    this._renderString_renderTag = function(textStack, meta, options, tag, text) {
        for (const plugin of this._getPlugins("string_tag")) {
            const out = plugin(tag, text, textStack, meta, options);
            if (out)
                return void (textStack[0] += out);
        }

        for (const plugin of this._getPlugins(`string_${tag}`)) {
            const out = plugin(tag, text, textStack, meta, options);
            if (out)
                return void (textStack[0] += out);
        }

        switch (tag) {
        case "@b":
        case "@bold":
            textStack[0] += `<b>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</b>`;
            break;
        case "@i":
        case "@italic":
            textStack[0] += `<i>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</i>`;
            break;
        case "@s":
        case "@strike":
            textStack[0] += `<s>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</s>`;
            break;
        case "@u":
        case "@underline":
            textStack[0] += `<u>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</u>`;
            break;
        case "@sup":
            textStack[0] += `<sup>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</sup>`;
            break;
        case "@sub":
            textStack[0] += `<sub>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</sub>`;
            break;
        case "@kbd":
            textStack[0] += `<kbd>`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</kbd>`;
            break;
        case "@code":
            textStack[0] += `<span class="code">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@style":
            {
                const [displayText,styles] = Renderer.splitTagByPipe(text);
                const classNames = (styles || "").split(";").map(it=>Renderer._STYLE_TAG_ID_TO_STYLE[it.trim()]).filter(Boolean).join(" ");
                textStack[0] += `<span class="${classNames}">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@font":
            {
                const [displayText,fontFamily] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span style="font-family: '${fontFamily}'">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@note":
            textStack[0] += `<i class="ve-muted">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</i>`;
            break;
        case "@tip":
            {
                const [displayText,titielText] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span title="${titielText.qq()}">`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@atk":
            textStack[0] += `<i>${Renderer.attackTagToFull(text)}</i>`;
            break;
        case "@h":
            textStack[0] += `<i>Hit:</i> `;
            break;
        case "@m":
            textStack[0] += `<i>Miss:</i> `;
            break;
        case "@color":
            {
                const [toDisplay,color] = Renderer.splitTagByPipe(text);
                const ptColor = this._renderString_renderTag_getBrewColorPart(color);

                textStack[0] += `<span class="rd__color" style="color: ${ptColor}">`;
                this._recursiveRender(toDisplay, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }
        case "@highlight":
            {
                const [toDisplay,color] = Renderer.splitTagByPipe(text);
                const ptColor = this._renderString_renderTag_getBrewColorPart(color);

                textStack[0] += ptColor ? `<span style="background-color: ${ptColor}">` : `<span class="rd__highlight">`;
                textStack[0] += toDisplay;
                textStack[0] += `</span>`;
                break;
            }
        case "@help":
            {
                const [toDisplay,title=""] = Renderer.splitTagByPipe(text);
                textStack[0] += `<span class="help" title="${title.qq()}">`;
                this._recursiveRender(toDisplay, textStack, meta);
                textStack[0] += `</span>`;
                break;
            }

        case "@unit":
            {
                const [amount,unitSingle,unitPlural] = Renderer.splitTagByPipe(text);
                textStack[0] += isNaN(amount) ? unitSingle : Number(amount) > 1 ? (unitPlural || unitSingle.toPlural()) : unitSingle;
                break;
            }

        case "@comic":
            textStack[0] += `<span class="rd__comic">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH1":
            textStack[0] += `<span class="rd__comic rd__comic--h1">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH2":
            textStack[0] += `<span class="rd__comic rd__comic--h2">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH3":
            textStack[0] += `<span class="rd__comic rd__comic--h3">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicH4":
            textStack[0] += `<span class="rd__comic rd__comic--h4">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;
        case "@comicNote":
            textStack[0] += `<span class="rd__comic rd__comic--note">`;
            this._recursiveRender(text, textStack, meta);
            textStack[0] += `</span>`;
            break;

        case "@dc":
            {
                const [dcText,displayText] = Renderer.splitTagByPipe(text);
                textStack[0] += `DC <span class="rd__dc">${displayText || dcText}</span>`;
                break;
            }

        case "@dcYourSpellSave":
            {
                const [displayText] = Renderer.splitTagByPipe(text);
                textStack[0] += displayText || "your spell save DC";
                break;
            }

        case "@dice":
        case "@autodice":
        case "@damage":
        case "@hit":
        case "@d20":
        case "@chance":
        case "@coinflip":
        case "@recharge":
        case "@ability":
        case "@savingThrow":
        case "@skillCheck":
            {
                const fauxEntry = Renderer.utils.getTagEntry(tag, text);

                if (tag === "@recharge") {
                    const [,flagsRaw] = Renderer.splitTagByPipe(text);
                    const flags = flagsRaw ? flagsRaw.split("") : null;
                    textStack[0] += `${flags && flags.includes("m") ? "" : "("}Recharge `;
                    this._recursiveRender(fauxEntry, textStack, meta);
                    textStack[0] += `${flags && flags.includes("m") ? "" : ")"}`;
                } else {
                    this._recursiveRender(fauxEntry, textStack, meta);
                }

                break;
            }

        case "@hitYourSpellAttack":
            this._renderString_renderTag_hitYourSpellAttack(textStack, meta, options, tag, text);
            break;

        case "@scaledice":
        case "@scaledamage":
            {
                const fauxEntry = Renderer.parseScaleDice(tag, text);
                this._recursiveRender(fauxEntry, textStack, meta);
                break;
            }

        case "@filter":
            {
                const [displayText,page,...filters] = Renderer.splitTagByPipe(text);

                const filterSubhashMeta = Renderer.getFilterSubhashes(filters);

                const fauxEntry = {
                    type: "link",
                    text: displayText,
                    href: {
                        type: "internal",
                        path: `${page}.html`,
                        hash: HASH_BLANK,
                        hashPreEncoded: true,
                        subhashes: filterSubhashMeta.subhashes,
                    },
                };

                if (filterSubhashMeta.customHash)
                    fauxEntry.href.hash = filterSubhashMeta.customHash;

                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        case "@link":
            {
                const [displayText,url] = Renderer.splitTagByPipe(text);
                let outUrl = url == null ? displayText : url;
                if (!outUrl.startsWith("http"))
                    outUrl = `http://${outUrl}`;
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "external",
                        url: outUrl,
                    },
                    text: displayText,
                };
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        case "@5etools":
            {
                const [displayText,page,hash] = Renderer.splitTagByPipe(text);
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                    },
                    text: displayText,
                };
                if (hash) {
                    fauxEntry.hash = hash;
                    fauxEntry.hashPreEncoded = true;
                }
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }

        case "@footnote":
            {
                const [displayText,footnoteText,optTitle] = Renderer.splitTagByPipe(text);
                const hoverMeta = Renderer.hover.getInlineHover({
                    type: "entries",
                    name: optTitle ? optTitle.toTitleCase() : "Footnote",
                    entries: [footnoteText, optTitle ? `{@note ${optTitle}}` : ""].filter(Boolean),
                });
                textStack[0] += `<span class="help" ${hoverMeta.html}>`;
                this._recursiveRender(displayText, textStack, meta);
                textStack[0] += `</span>`;

                break;
            }
        case "@homebrew":
            {
                const [newText,oldText] = Renderer.splitTagByPipe(text);
                const tooltipEntries = [];
                if (newText && oldText) {
                    tooltipEntries.push("{@b This is a homebrew addition, replacing the following:}");
                } else if (newText) {
                    tooltipEntries.push("{@b This is a homebrew addition.}");
                } else if (oldText) {
                    tooltipEntries.push("{@b The following text has been removed with this homebrew:}");
                }
                if (oldText) {
                    tooltipEntries.push(oldText);
                }
                const hoverMeta = Renderer.hover.getInlineHover({
                    type: "entries",
                    name: "Homebrew Modifications",
                    entries: tooltipEntries,
                });
                textStack[0] += `<span class="homebrew-inline" ${hoverMeta.html}>`;
                this._recursiveRender(newText || "[...]", textStack, meta);
                textStack[0] += `</span>`;

                break;
            }
        case "@area":
            {
                const {areaId, displayText} = Renderer.tag.TAG_LOOKUP.area.getMeta(tag, text);

                if (typeof BookUtil === "undefined") {
                    textStack[0] += displayText;
                } else {
                    const area = BookUtil.curRender.headerMap[areaId] || {
                        entry: {
                            name: ""
                        }
                    };
                    const hoverMeta = Renderer.hover.getInlineHover(area.entry, {
                        isLargeBookContent: true,
                        depth: area.depth
                    });
                    textStack[0] += `<a href="#${BookUtil.curRender.curBookId},${area.chapter},${UrlUtil.encodeForHash(area.entry.name)},0" ${hoverMeta.html}>${displayText}</a>`;
                }

                break;
            }

        case "@loader":
            {
                const {name, path, mode} = this._renderString_getLoaderTagMeta(text);

                const brewUtilName = mode === "homebrew" ? "BrewUtil2" : mode === "prerelease" ? "PrereleaseUtil" : null;
                const brewUtil = globalThis[brewUtilName];

                if (!brewUtil) {
                    textStack[0] += `<span class="text-danger" title="Unknown loader mode &quot;${mode.qq()}&quot;!">${name}<span class="glyphicon glyphicon-alert rd__loadbrew-icon rd__loadbrew-icon"></span></span>`;

                    break;
                }

                textStack[0] += `<span onclick="${brewUtilName}.pAddBrewFromLoaderTag(this)" data-rd-loader-path="${path.escapeQuotes()}" data-rd-loader-name="${name.escapeQuotes()}" class="rd__wrp-loadbrew--ready" title="Click to install ${brewUtil.DISPLAY_NAME}">${name}<span class="glyphicon glyphicon-download-alt rd__loadbrew-icon rd__loadbrew-icon"></span></span>`;
                break;
            }

        case "@book":
        case "@adventure":
            {
                const page = tag === "@book" ? "book.html" : "adventure.html";
                const [displayText,book,chapter,section,rawNumber] = Renderer.splitTagByPipe(text);
                const number = rawNumber || 0;
                const hash = `${book}${chapter ? `${HASH_PART_SEP}${chapter}${section ? `${HASH_PART_SEP}${UrlUtil.encodeForHash(section)}${number != null ? `${HASH_PART_SEP}${UrlUtil.encodeForHash(number)}` : ""}` : ""}` : ""}`;
                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                        hash,
                        hashPreEncoded: true,
                    },
                    text: displayText,
                };
                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }

        default:
            {
                const {name, source, displayText, others, page, hash, hashPreEncoded, pageHover, hashHover, hashPreEncodedHover, preloadId, linkText, subhashes, subhashesHover, isFauxPage} = Renderer.utils.getTagMeta(tag, text);

                const fauxEntry = {
                    type: "link",
                    href: {
                        type: "internal",
                        path: page,
                        hash,
                        hover: {
                            page,
                            isFauxPage,
                            source,
                        },
                    },
                    text: (displayText || name),
                };

                if (hashPreEncoded != null)
                    fauxEntry.href.hashPreEncoded = hashPreEncoded;
                if (pageHover != null)
                    fauxEntry.href.hover.page = pageHover;
                if (hashHover != null)
                    fauxEntry.href.hover.hash = hashHover;
                if (hashPreEncodedHover != null)
                    fauxEntry.href.hover.hashPreEncoded = hashPreEncodedHover;
                if (preloadId != null)
                    fauxEntry.href.hover.preloadId = preloadId;
                if (linkText)
                    fauxEntry.text = linkText;
                if (subhashes)
                    fauxEntry.href.subhashes = subhashes;
                if (subhashesHover)
                    fauxEntry.href.hover.subhashes = subhashesHover;

                this._recursiveRender(fauxEntry, textStack, meta);

                break;
            }
        }
    }
    ;

    this._renderString_renderTag_getBrewColorPart = function(color) {
        if (!color)
            return "";
        const scrubbedColor = BrewUtilShared.getValidColor(color, {
            isExtended: true
        });
        return scrubbedColor.startsWith("--") ? `var(${scrubbedColor})` : `#${scrubbedColor}`;
    }
    ;

    this._renderString_renderTag_hitYourSpellAttack = function(textStack, meta, options, tag, text) {
        const [displayText] = Renderer.splitTagByPipe(text);

        const fauxEntry = {
            type: "dice",
            rollable: true,
            subType: "d20",
            displayText: displayText || "your spell attack modifier",
            toRoll: `1d20 + #$prompt_number:title=Enter your Spell Attack Modifier$#`,
        };
        return this._recursiveRender(fauxEntry, textStack, meta);
    }
    ;

    this._renderString_getLoaderTagMeta = function(text, {isDefaultUrl=false}={}) {
        const [name,file,mode="homebrew"] = Renderer.splitTagByPipe(text);

        if (!isDefaultUrl)
            return {
                name,
                path: file,
                mode
            };

        const path = /^.*?:\/\//.test(file) ? file : `${VeCt.URL_ROOT_BREW}${file}`;
        return {
            name,
            path,
            mode
        };
    }
    ;

    this._renderPrimitive = function(entry, textStack, meta, options) {
        textStack[0] += entry;
    }
    ;

    this._renderLink = function(entry, textStack, meta, options) {
        let href = this._renderLink_getHref(entry);

        if (entry.href.hover && this._roll20Ids) {
            const procHash = UrlUtil.encodeForHash(entry.href.hash);
            const id = this._roll20Ids[procHash];
            if (id) {
                href = `http://journal.roll20.net/${id.type}/${id.roll20Id}`;
            }
        }

        const pluginData = this._getPlugins("link").map(plugin=>plugin(entry, textStack, meta, options)).filter(Boolean);
        const isDisableEvents = pluginData.some(it=>it.isDisableEvents);
        const additionalAttributes = pluginData.map(it=>it.attributes).filter(Boolean);

        if (this._isInternalLinksDisabled && entry.href.type === "internal") {
            textStack[0] += `<span class="bold" ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</span>`;
        } else if (entry.href.hover?.isFauxPage) {
            textStack[0] += `<span class="help help--hover" ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</span>`;
        } else {
            textStack[0] += `<a href="${href.qq()}" ${entry.href.type === "internal" ? "" : `target="_blank" rel="noopener noreferrer"`} ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</a>`;
        }
    }
    ;

    this._renderLink_getHref = function(entry) {
        let href;
        if (entry.href.type === "internal") {
            href = `${this.baseUrl}${entry.href.path}#`;
            if (entry.href.hash != null) {
                href += entry.href.hashPreEncoded ? entry.href.hash : UrlUtil.encodeForHash(entry.href.hash);
            }
            if (entry.href.subhashes != null) {
                href += Renderer.utils.getLinkSubhashString(entry.href.subhashes);
            }
        } else if (entry.href.type === "external") {
            href = entry.href.url;
        }
        return href;
    }
    ;

    this._renderLink_getHoverString = function(entry) {
        if (!entry.href.hover || !this._isAddHandlers)
            return "";

        let procHash = entry.href.hover.hash ? entry.href.hover.hashPreEncoded ? entry.href.hover.hash : UrlUtil.encodeForHash(entry.href.hover.hash) : entry.href.hashPreEncoded ? entry.href.hash : UrlUtil.encodeForHash(entry.href.hash);

        if (this._tagExportDict) {
            this._tagExportDict[procHash] = {
                page: entry.href.hover.page,
                source: entry.href.hover.source,
                hash: procHash,
            };
        }

        if (entry.href.hover.subhashes) {
            procHash += Renderer.utils.getLinkSubhashString(entry.href.hover.subhashes);
        }

        const pluginData = this._getPlugins("link_attributesHover").map(plugin=>plugin(entry, procHash)).filter(Boolean);
        const replacementAttributes = pluginData.map(it=>it.attributesHoverReplace).filter(Boolean);
        if (replacementAttributes.length)
            return replacementAttributes.join(" ");

        return `onmouseover="Renderer.hover.pHandleLinkMouseOver(event, this)" onmouseleave="Renderer.hover.handleLinkMouseLeave(event, this)" onmousemove="Renderer.hover.handleLinkMouseMove(event, this)" data-vet-page="${entry.href.hover.page.qq()}" data-vet-source="${entry.href.hover.source.qq()}" data-vet-hash="${procHash.qq()}" ${entry.href.hover.preloadId != null ? `data-vet-preload-id="${`${entry.href.hover.preloadId}`.qq()}"` : ""} ${entry.href.hover.isFauxPage ? `data-vet-is-faux-page="true"` : ""} ${Renderer.hover.getPreventTouchString()}`;
    }
    ;

    this.render = function(entry, depth=0) {
        const tempStack = [];
        this.recursiveRender(entry, tempStack, {
            depth
        });
        return tempStack.join("");
    }
    ;
}
;

Renderer.ENTRIES_WITH_ENUMERATED_TITLES = [{
    type: "section",
    key: "entries",
    depth: -1
}, {
    type: "entries",
    key: "entries",
    depthIncrement: 1
}, {
    type: "options",
    key: "entries"
}, {
    type: "inset",
    key: "entries",
    depth: 2
}, {
    type: "insetReadaloud",
    key: "entries",
    depth: 2
}, {
    type: "variant",
    key: "entries",
    depth: 2
}, {
    type: "variantInner",
    key: "entries",
    depth: 2
}, {
    type: "actions",
    key: "entries",
    depth: 2
}, {
    type: "flowBlock",
    key: "entries",
    depth: 2
}, {
    type: "optfeature",
    key: "entries",
    depthIncrement: 1
}, {
    type: "patron",
    key: "entries"
}, ];

Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP = Renderer.ENTRIES_WITH_ENUMERATED_TITLES.mergeMap(it=>({
    [it.type]: it
}));

Renderer.ENTRIES_WITH_CHILDREN = [...Renderer.ENTRIES_WITH_ENUMERATED_TITLES, {
    type: "list",
    key: "items"
}, {
    type: "table",
    key: "rows"
}, ];

Renderer._INLINE_HEADER_TERMINATORS = new Set([".", ",", "!", "?", ";", ":", `"`]);

Renderer._STYLE_TAG_ID_TO_STYLE = {
    "small-caps": "small-caps",
    "small": "ve-small",
    "capitalize": "capitalize",
    "dnd-font": "dnd-font",
};

Renderer.get = ()=>{
    if (!Renderer.defaultRenderer)
        Renderer.defaultRenderer = new Renderer();
    return Renderer.defaultRenderer;
}
;

Renderer.applyProperties = function(entry, object) {
    const propSplit = Renderer.splitByPropertyInjectors(entry);
    const len = propSplit.length;
    if (len === 1)
        return entry;

    let textStack = "";

    for (let i = 0; i < len; ++i) {
        const s = propSplit[i];
        if (!s)
            continue;

        if (!s.startsWith("{=")) {
            textStack += s;
            continue;
        }

        if (s.startsWith("{=")) {
            const [path,modifiers] = s.slice(2, -1).split("/");
            let fromProp = object[path];

            if (!modifiers) {
                textStack += fromProp;
                continue;
            }

            if (fromProp == null)
                throw new Error(`Could not apply property in "${s}"; "${path}" value was null!`);

            modifiers.split("").sort((a,b)=>Renderer.applyProperties._OP_ORDER.indexOf(a) - Renderer.applyProperties._OP_ORDER.indexOf(b));

            for (const modifier of modifiers) {
                switch (modifier) {
                case "a":
                    fromProp = Renderer.applyProperties._LEADING_AN.has(fromProp[0].toLowerCase()) ? "an" : "a";
                    break;

                case "l":
                    fromProp = fromProp.toLowerCase();
                    break;
                case "t":
                    fromProp = fromProp.toTitleCase();
                    break;
                case "u":
                    fromProp = fromProp.toUpperCase();
                    break;
                case "v":
                    fromProp = Parser.numberToVulgar(fromProp);
                    break;
                case "x":
                    fromProp = Parser.numberToText(fromProp);
                    break;
                case "r":
                    fromProp = Math.round(fromProp);
                    break;
                case "f":
                    fromProp = Math.floor(fromProp);
                    break;
                case "c":
                    fromProp = Math.ceil(fromProp);
                    break;
                default:
                    throw new Error(`Unhandled property modifier "${modifier}"`);
                }
            }

            textStack += fromProp;
        }
    }

    return textStack;
}
;
Renderer.applyProperties._LEADING_AN = new Set(["a", "e", "i", "o", "u"]);
Renderer.applyProperties._OP_ORDER = ["r", "f", "c", "v", "x", "l", "t", "u", "a", ];

Renderer.applyAllProperties = function(entries, object=null) {
    let lastObj = null;
    const handlers = {
        object: (obj)=>{
            lastObj = obj;
            return obj;
        }
        ,
        string: (str)=>Renderer.applyProperties(str, object || lastObj),
    };
    return MiscUtil.getWalker().walk(entries, handlers);
}
;

Renderer.attackTagToFull = function(tagStr) {
    function renderTag(tags) {
        return `${tags.includes("m") ? "Melee " : tags.includes("r") ? "Ranged " : tags.includes("g") ? "Magical " : tags.includes("a") ? "Area " : ""}${tags.includes("w") ? "Weapon " : tags.includes("s") ? "Spell " : tags.includes("p") ? "Power " : ""}`;
    }

    const tagGroups = tagStr.toLowerCase().split(",").map(it=>it.trim()).filter(it=>it).map(it=>it.split(""));
    if (tagGroups.length > 1) {
        const seen = new Set(tagGroups.last());
        for (let i = tagGroups.length - 2; i >= 0; --i) {
            tagGroups[i] = tagGroups[i].filter(it=>{
                const out = !seen.has(it);
                seen.add(it);
                return out;
            }
            );
        }
    }
    return `${tagGroups.map(it=>renderTag(it)).join(" or ")}Attack:`;
}
;

Renderer.splitFirstSpace = function(string) {
    const firstIndex = string.indexOf(" ");
    return firstIndex === -1 ? [string, ""] : [string.substr(0, firstIndex), string.substr(firstIndex + 1)];
}
;

Renderer._splitByTagsBase = function(leadingCharacter) {
    return function(string) {
        let tagDepth = 0;
        let char, char2;
        const out = [];
        let curStr = "";
        let isLastOpen = false;

        const len = string.length;
        for (let i = 0; i < len; ++i) {
            char = string[i];
            char2 = string[i + 1];

            switch (char) {
            case "{":
                isLastOpen = true;
                if (char2 === leadingCharacter) {
                    if (tagDepth++ > 0) {
                        curStr += "{";
                    } else {
                        out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));
                        curStr = `{${leadingCharacter}`;
                        ++i;
                    }
                } else
                    curStr += "{";
                break;

            case "}":
                isLastOpen = false;
                curStr += "}";
                if (tagDepth !== 0 && --tagDepth === 0) {
                    out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));
                    curStr = "";
                }
                break;

            case leadingCharacter:
                {
                    if (!isLastOpen)
                        curStr += "<VE_LEAD>";
                    else
                        curStr += leadingCharacter;
                    break;
                }

            default:
                isLastOpen = false;
                curStr += char;
                break;
            }
        }

        if (curStr)
            out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));

        return out;
    }
    ;
}
;

Renderer.splitByTags = Renderer._splitByTagsBase("@");
Renderer.splitByPropertyInjectors = Renderer._splitByTagsBase("=");

Renderer._splitByPipeBase = function(leadingCharacter) {
    return function(string) {
        let tagDepth = 0;
        let char, char2;
        const out = [];
        let curStr = "";

        const len = string.length;
        for (let i = 0; i < len; ++i) {
            char = string[i];
            char2 = string[i + 1];

            switch (char) {
            case "{":
                if (char2 === leadingCharacter)
                    tagDepth++;
                curStr += "{";

                break;

            case "}":
                if (tagDepth)
                    tagDepth--;
                curStr += "}";

                break;

            case "|":
                {
                    if (tagDepth)
                        curStr += "|";
                    else {
                        out.push(curStr);
                        curStr = "";
                    }
                    break;
                }

            default:
                {
                    curStr += char;
                    break;
                }
            }
        }

        if (curStr)
            out.push(curStr);
        return out;
    }
    ;
}
;

Renderer.splitTagByPipe = Renderer._splitByPipeBase("@");

Renderer.getEntryDice = function(entry, name, opts={}) {
    const toDisplay = Renderer.getEntryDiceDisplayText(entry);
    const disable_rollable = true; //DEBUG

    if (entry.rollable === true && !disable_rollable)
        return Renderer.getRollableEntryDice(entry, name, toDisplay, opts);
    else
        return toDisplay;
}
;

Renderer.getRollableEntryDice = function(entry, name, toDisplay, {isAddHandlers=true, pluginResults=null, }={}, ) {
    const toPack = MiscUtil.copyFast(entry);
    if (typeof toPack.toRoll !== "string") {
        toPack.toRoll = Renderer.legacyDiceToString(toPack.toRoll);
    }

    const handlerPart = isAddHandlers ? `onmousedown="event.preventDefault()" data-packed-dice='${JSON.stringify(toPack).qq()}'` : "";

    const rollableTitlePart = isAddHandlers ? Renderer.getEntryDiceTitle(toPack.subType) : null;
    const titlePart = isAddHandlers ? `title="${[name, rollableTitlePart].filter(Boolean).join(". ").qq()}" ${name ? `data-roll-name="${name}"` : ""}` : name ? `title="${name.qq()}" data-roll-name="${name.qq()}"` : "";

    const additionalDataPart = (pluginResults || []).filter(it=>it.additionalData).map(it=>{
        return Object.entries(it.additionalData).map(([dataKey,val])=>`${dataKey}='${typeof val === "object" ? JSON.stringify(val).qq() : `${val}`.qq()}'`).join(" ");
    }
    ).join(" ");

    toDisplay = (pluginResults || []).filter(it=>it.toDisplay)[0]?.toDisplay ?? toDisplay;

    const ptRoll = Renderer.getRollableEntryDice._getPtRoll(toPack);

    return `<span class="roller render-roller" ${titlePart} ${handlerPart} ${additionalDataPart}>${toDisplay}</span>${ptRoll}`;
}
;

Renderer.getRollableEntryDice._getPtRoll = (toPack)=>{
    if (!toPack.autoRoll)
        return "";

    const r = Renderer.dice.parseRandomise2(toPack.toRoll);
    return ` (<span data-rd-is-autodice-result="true">${r}</span>)`;
}
;

Renderer.getEntryDiceTitle = function(subType) {
    return `Click to roll. ${subType === "damage" ? "SHIFT to roll a critical hit, CTRL to half damage (rounding down)." : subType === "d20" ? "SHIFT to roll with advantage, CTRL to roll with disadvantage." : "SHIFT/CTRL to roll twice."}`;
}
;

Renderer.legacyDiceToString = function(array) {
    let stack = "";
    array.forEach(r=>{
        stack += `${r.neg ? "-" : stack === "" ? "" : "+"}${r.number || 1}d${r.faces}${r.mod ? r.mod > 0 ? `+${r.mod}` : r.mod : ""}`;
    }
    );
    return stack;
}
;

Renderer.getEntryDiceDisplayText = function(entry) {
    if (entry.displayText)
        return entry.displayText;
    return Renderer._getEntryDiceDisplayText_getDiceAsStr(entry);
}
;

Renderer._getEntryDiceDisplayText_getDiceAsStr = function(entry) {
    if (entry.successThresh != null)
        return `${entry.successThresh} percent`;
    if (typeof entry.toRoll === "string")
        return entry.toRoll;
    return Renderer.legacyDiceToString(entry.toRoll);
}
;

Renderer.parseScaleDice = function(tag, text) {
    const [baseRoll,progression,addPerProgress,renderMode,displayText] = Renderer.splitTagByPipe(text);
    const progressionParse = MiscUtil.parseNumberRange(progression, 1, 9);
    const baseLevel = Math.min(...progressionParse);
    const options = {};
    const isMultableDice = /^(\d+)d(\d+)$/i.exec(addPerProgress);

    const getSpacing = ()=>{
        let diff = null;
        const sorted = [...progressionParse].sort(SortUtil.ascSort);
        for (let i = 1; i < sorted.length; ++i) {
            const prev = sorted[i - 1];
            const curr = sorted[i];
            if (diff == null)
                diff = curr - prev;
            else if (curr - prev !== diff)
                return null;
        }
        return diff;
    }
    ;

    const spacing = getSpacing();
    progressionParse.forEach(k=>{
        const offset = k - baseLevel;
        if (isMultableDice && spacing != null) {
            options[k] = offset ? `${Number(isMultableDice[1]) * (offset / spacing)}d${isMultableDice[2]}` : "";
        } else {
            options[k] = offset ? [...new Array(Math.floor(offset / spacing))].map(_=>addPerProgress).join("+") : "";
        }
    }
    );

    const out = {
        type: "dice",
        rollable: true,
        toRoll: baseRoll,
        displayText: displayText || addPerProgress,
        prompt: {
            entry: renderMode === "psi" ? "Spend Psi Points..." : "Cast at...",
            mode: renderMode,
            options,
        },
    };
    if (tag === "@scaledamage")
        out.subType = "damage";

    return out;
}
;

Renderer.getAbilityData = function(abArr, {isOnlyShort, isCurrentLineage}={}) {
    if (isOnlyShort && isCurrentLineage)
        return new Renderer._AbilityData({
            asTextShort: "Lineage (choose)"
        });

    const outerStack = (abArr || [null]).map(it=>Renderer.getAbilityData._doRenderOuter(it));
    if (outerStack.length <= 1)
        return outerStack[0];
    return new Renderer._AbilityData({
        asText: `Choose one of: ${outerStack.map((it,i)=>`(${Parser.ALPHABET[i].toLowerCase()}) ${it.asText}`).join(" ")}`,
        asTextShort: `${outerStack.map((it,i)=>`(${Parser.ALPHABET[i].toLowerCase()}) ${it.asTextShort}`).join(" ")}`,
        asCollection: [...new Set(outerStack.map(it=>it.asCollection).flat())],
        areNegative: [...new Set(outerStack.map(it=>it.areNegative).flat())],
    });
}
;

Renderer.getAbilityData._doRenderOuter = function(abObj) {
    const mainAbs = [];
    const asCollection = [];
    const areNegative = [];
    const toConvertToText = [];
    const toConvertToShortText = [];

    if (abObj != null) {
        handleAllAbilities(abObj);
        handleAbilitiesChoose();
        return new Renderer._AbilityData({
            asText: toConvertToText.join("; "),
            asTextShort: toConvertToShortText.join("; "),
            asCollection: asCollection,
            areNegative: areNegative,
        });
    }

    return new Renderer._AbilityData();

    function handleAllAbilities(abObj, targetList) {
        MiscUtil.copyFast(Parser.ABIL_ABVS).sort((a,b)=>SortUtil.ascSort(abObj[b] || 0, abObj[a] || 0)).forEach(shortLabel=>handleAbility(abObj, shortLabel, targetList));
    }

    function handleAbility(abObj, shortLabel, optToConvertToTextStorage) {
        if (abObj[shortLabel] != null) {
            const isNegMod = abObj[shortLabel] < 0;
            const toAdd = `${shortLabel.uppercaseFirst()} ${(isNegMod ? "" : "+")}${abObj[shortLabel]}`;

            if (optToConvertToTextStorage) {
                optToConvertToTextStorage.push(toAdd);
            } else {
                toConvertToText.push(toAdd);
                toConvertToShortText.push(toAdd);
            }

            mainAbs.push(shortLabel.uppercaseFirst());
            asCollection.push(shortLabel);
            if (isNegMod)
                areNegative.push(shortLabel);
        }
    }

    function handleAbilitiesChoose() {
        if (abObj.choose != null) {
            const ch = abObj.choose;
            let outStack = "";
            if (ch.weighted) {
                const w = ch.weighted;
                const froms = w.from.map(it=>it.uppercaseFirst());
                const isAny = froms.length === 6;
                const isAllEqual = w.weights.unique().length === 1;
                let cntProcessed = 0;

                const weightsIncrease = w.weights.filter(it=>it >= 0).sort(SortUtil.ascSort).reverse();
                const weightsReduce = w.weights.filter(it=>it < 0).map(it=>-it).sort(SortUtil.ascSort);

                const areIncreaseShort = [];
                const areIncrease = isAny && isAllEqual && w.weights.length > 1 && w.weights[0] >= 0 ? (()=>{
                    weightsIncrease.forEach(it=>areIncreaseShort.push(`+${it}`));
                    return [`${cntProcessed ? "choose " : ""}${Parser.numberToText(w.weights.length)} different +${weightsIncrease[0]}`];
                }
                )() : weightsIncrease.map(it=>{
                    areIncreaseShort.push(`+${it}`);
                    if (isAny)
                        return `${cntProcessed ? "choose " : ""}any ${cntProcessed++ ? `other ` : ""}+${it}`;
                    return `one ${cntProcessed++ ? `other ` : ""}ability to increase by ${it}`;
                }
                );

                const areReduceShort = [];
                const areReduce = isAny && isAllEqual && w.weights.length > 1 && w.weights[0] < 0 ? (()=>{
                    weightsReduce.forEach(it=>areReduceShort.push(`-${it}`));
                    return [`${cntProcessed ? "choose " : ""}${Parser.numberToText(w.weights.length)} different -${weightsReduce[0]}`];
                }
                )() : weightsReduce.map(it=>{
                    areReduceShort.push(`-${it}`);
                    if (isAny)
                        return `${cntProcessed ? "choose " : ""}any ${cntProcessed++ ? `other ` : ""}-${it}`;
                    return `one ${cntProcessed++ ? `other ` : ""}ability to decrease by ${it}`;
                }
                );

                const startText = isAny ? `Choose ` : `From ${froms.joinConjunct(", ", " and ")} choose `;

                const ptAreaIncrease = isAny ? areIncrease.concat(areReduce).join("; ") : areIncrease.concat(areReduce).joinConjunct(", ", isAny ? "; " : " and ");
                toConvertToText.push(`${startText}${ptAreaIncrease}`);
                toConvertToShortText.push(`${isAny ? "Any combination " : ""}${areIncreaseShort.concat(areReduceShort).join("/")}${isAny ? "" : ` from ${froms.join("/")}`}`);
            } else {
                const allAbilities = ch.from.length === 6;
                const allAbilitiesWithParent = isAllAbilitiesWithParent(ch);
                let amount = ch.amount === undefined ? 1 : ch.amount;
                amount = (amount < 0 ? "" : "+") + amount;
                if (allAbilities) {
                    outStack += "any ";
                } else if (allAbilitiesWithParent) {
                    outStack += "any other ";
                }
                if (ch.count != null && ch.count > 1) {
                    outStack += `${Parser.numberToText(ch.count)} `;
                }
                if (allAbilities || allAbilitiesWithParent) {
                    outStack += `${ch.count > 1 ? "unique " : ""}${amount}`;
                } else {
                    for (let j = 0; j < ch.from.length; ++j) {
                        let suffix = "";
                        if (ch.from.length > 1) {
                            if (j === ch.from.length - 2) {
                                suffix = " or ";
                            } else if (j < ch.from.length - 2) {
                                suffix = ", ";
                            }
                        }
                        let thsAmount = ` ${amount}`;
                        if (ch.from.length > 1) {
                            if (j !== ch.from.length - 1) {
                                thsAmount = "";
                            }
                        }
                        outStack += ch.from[j].uppercaseFirst() + thsAmount + suffix;
                    }
                }
            }

            if (outStack.trim()) {
                toConvertToText.push(`Choose ${outStack}`);
                toConvertToShortText.push(outStack.uppercaseFirst());
            }
        }
    }

    function isAllAbilitiesWithParent(chooseAbs) {
        const tempAbilities = [];
        for (let i = 0; i < mainAbs.length; ++i) {
            tempAbilities.push(mainAbs[i].toLowerCase());
        }
        for (let i = 0; i < chooseAbs.from.length; ++i) {
            const ab = chooseAbs.from[i].toLowerCase();
            if (!tempAbilities.includes(ab))
                tempAbilities.push(ab);
            if (!asCollection.includes(ab.toLowerCase))
                asCollection.push(ab.toLowerCase());
        }
        return tempAbilities.length === 6;
    }
}
;

Renderer._AbilityData = function({asText, asTextShort, asCollection, areNegative}={}) {
    this.asText = asText || "";
    this.asTextShort = asTextShort || "";
    this.asCollection = asCollection || [];
    this.areNegative = areNegative || [];
}
;

Renderer.getFilterSubhashes = function(filters, namespace=null) {
    let customHash = null;

    const subhashes = filters.map(f=>{
        const [fName,fVals,fMeta,fOpts] = f.split("=").map(s=>s.trim());
        const isBoxData = fName.startsWith("fb");
        const key = isBoxData ? `${fName}${namespace ? `.${namespace}` : ""}` : `flst${namespace ? `.${namespace}` : ""}${UrlUtil.encodeForHash(fName)}`;

        let value;
        if (isBoxData) {
            return {
                key,
                value: fVals,
                preEncoded: true,
            };
        } else if (fName === "search") {
            return {
                key: VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX,
                value: UrlUtil.encodeForHash(fVals),
                preEncoded: true,
            };
        } else if (fName === "hash") {
            customHash = fVals;
            return null;
        } else if (fVals.startsWith("[") && fVals.endsWith("]")) {
            const [min,max] = fVals.substring(1, fVals.length - 1).split(";").map(it=>it.trim());
            if (max == null) {
                value = [`min=${min}`, `max=${min}`, ].join(HASH_SUB_LIST_SEP);
            } else {
                value = [min ? `min=${min}` : "", max ? `max=${max}` : "", ].filter(Boolean).join(HASH_SUB_LIST_SEP);
            }
        } else if (fVals.startsWith("::") && fVals.endsWith("::")) {
            value = fVals.substring(2, fVals.length - 2).split(";").map(it=>it.trim()).map(it=>{
                if (it.startsWith("!"))
                    return `${UrlUtil.encodeForHash(it.slice(1))}=${UrlUtil.mini.compress(false)}`;
                return `${UrlUtil.encodeForHash(it)}=${UrlUtil.mini.compress(true)}`;
            }
            ).join(HASH_SUB_LIST_SEP);
        } else {
            value = fVals.split(";").map(s=>s.trim()).filter(Boolean).map(s=>{
                if (s.startsWith("!"))
                    return `${UrlUtil.encodeForHash(s.slice(1))}=2`;
                return `${UrlUtil.encodeForHash(s)}=1`;
            }
            ).join(HASH_SUB_LIST_SEP);
        }

        const out = [{
            key,
            value,
            preEncoded: true,
        }];

        if (fMeta) {
            out.push({
                key: `flmt${UrlUtil.encodeForHash(fName)}`,
                value: fMeta,
                preEncoded: true,
            });
        }

        if (fOpts) {
            out.push({
                key: `flop${UrlUtil.encodeForHash(fName)}`,
                value: fOpts,
                preEncoded: true,
            });
        }

        return out;
    }
    ).flat().filter(Boolean);

    return {
        customHash,
        subhashes,
    };
}
;

Renderer._cache = {
    inlineStatblock: {},

    async pRunFromEle(ele) {
        const cached = Renderer._cache[ele.dataset.rdCache][ele.dataset.rdCacheId];
        await cached.pFn(ele);
    },
};

Renderer.utils = {
    getBorderTr: (optText=null)=>{
        return `<tr><th class="border" colspan="6">${optText || ""}</th></tr>`;
    }
    ,

    getDividerTr: ()=>{
        return `<tr><td class="divider" colspan="6"><div></div></td></tr>`;
    }
    ,

    getSourceSubText(it) {
        return it.sourceSub ? ` \u2014 ${it.sourceSub}` : "";
    },

    getNameTr: (it,opts)=>{
        opts = opts || {};

        let dataPart = "";
        let pageLinkPart;
        if (opts.page) {
            const hash = UrlUtil.URL_TO_HASH_BUILDER[opts.page](it);
            dataPart = `data-page="${opts.page}" data-source="${it.source.escapeQuotes()}" data-hash="${hash.escapeQuotes()}" ${opts.extensionData != null ? `data-extension='${JSON.stringify(opts.extensionData).escapeQuotes()}` : ""}'`;
            pageLinkPart = SourceUtil.getAdventureBookSourceHref(it.source, it.page);

            if (opts.isEmbeddedEntity)
                ExtensionUtil.addEmbeddedToCache(opts.page, it.source, hash, it);
        }

        const tagPartSourceStart = `<${pageLinkPart ? `a href="${Renderer.get().baseUrl}${pageLinkPart}"` : "span"}`;
        const tagPartSourceEnd = `</${pageLinkPart ? "a" : "span"}>`;

        const ptBrewSourceLink = Renderer.utils._getNameTr_getPtPrereleaseBrewSourceLink({
            ent: it,
            brewUtil: PrereleaseUtil
        }) || Renderer.utils._getNameTr_getPtPrereleaseBrewSourceLink({
            ent: it,
            brewUtil: BrewUtil2
        });

        const $ele = $$`<tr>
			<th class="rnd-name ${opts.extraThClasses ? opts.extraThClasses.join(" ") : ""}" colspan="6" ${dataPart}>
				<div class="name-inner">
					<div class="ve-flex-v-center">
						<h1 class="stats-name copyable m-0" onmousedown="event.preventDefault()" onclick="Renderer.utils._pHandleNameClick(this)">${opts.prefix || ""}${it._displayName || it.name}${opts.suffix || ""}</h1>
						${opts.controlRhs || ""}
						${!IS_VTT && ExtensionUtil.ACTIVE && opts.page ? Renderer.utils.getBtnSendToFoundryHtml() : ""}
					</div>
					<div class="stats-source ve-flex-v-baseline">
						${tagPartSourceStart} class="help-subtle stats-source-abbreviation ${it.source ? `${Parser.sourceJsonToColor(it.source)}" title="${Parser.sourceJsonToFull(it.source)}${Renderer.utils.getSourceSubText(it)}` : ""}" ${Parser.sourceJsonToStyle(it.source)}>${it.source ? Parser.sourceJsonToAbv(it.source) : ""}${tagPartSourceEnd}

						${Renderer.utils.isDisplayPage(it.page) ? ` ${tagPartSourceStart} class="rd__stats-name-page ml-1" title="Page ${it.page}">p${it.page}${tagPartSourceEnd}` : ""}

						${ptBrewSourceLink}
					</div>
				</div>
			</th>
		</tr>`;

        if (opts.asJquery)
            return $ele;
        else
            return $ele[0].outerHTML;
    }
    ,

    _getNameTr_getPtPrereleaseBrewSourceLink({ent, brewUtil}) {
        if (!brewUtil.hasSourceJson(ent.source) || !brewUtil.sourceJsonToSource(ent.source)?.url)
            return "";

        return `<a href="${brewUtil.sourceJsonToSource(ent.source).url}" title="View ${brewUtil.DISPLAY_NAME.toTitleCase()} Source" class="ve-self-flex-center ml-2 ve-muted rd__stats-name-brew-link" target="_blank" rel="noopener noreferrer"><span class="	glyphicon glyphicon-share"></span></a>`;
    },

    getBtnSendToFoundryHtml({isMb=true}={}) {
        return `<button title="Send to Foundry (SHIFT for Temporary Import)" class="btn btn-xs btn-default btn-stats-name mx-2 ${isMb ? "mb-2" : ""} ve-self-flex-end" onclick="ExtensionUtil.pDoSendStats(event, this)" draggable="true" ondragstart="ExtensionUtil.doDragStart(event, this)"><span class="glyphicon glyphicon-send"></span></button>`;
    },

    isDisplayPage(page) {
        return page != null && ((!isNaN(page) && page > 0) || isNaN(page));
    },

    getExcludedTr({entity, dataProp, page, isExcluded}) {
        const excludedHtml = Renderer.utils.getExcludedHtml({
            entity,
            dataProp,
            page,
            isExcluded
        });
        if (!excludedHtml)
            return "";
        return `<tr><td colspan="6" class="pt-3">${excludedHtml}</td></tr>`;
    },

    getExcludedHtml({entity, dataProp, page, isExcluded}) {
        if (isExcluded != null && !isExcluded)
            return "";
        if (isExcluded == null) {
            if (!ExcludeUtil.isInitialised)
                return "";
            if (page && !UrlUtil.URL_TO_HASH_BUILDER[page])
                return "";
            const hash = page ? UrlUtil.URL_TO_HASH_BUILDER[page](entity) : UrlUtil.autoEncodeHash(entity);
            isExcluded = isExcluded || dataProp === "item" ? Renderer.item.isExcluded(entity, {
                hash
            }) : ExcludeUtil.isExcluded(hash, dataProp, entity.source);
        }
        return isExcluded ? `<div class="ve-text-center text-danger"><b><i>Warning: This content has been <a href="blocklist.html">blocklisted</a>.</i></b></div>` : "";
    },

    getSourceAndPageTrHtml(it, {tag, fnUnpackUid}={}) {
        const html = Renderer.utils.getSourceAndPageHtml(it, {
            tag,
            fnUnpackUid
        });
        return html ? `<b>Source:</b> ${html}` : "";
    },

    _getAltSourceHtmlOrText(it, prop, introText, isText) {
        if (!it[prop] || !it[prop].length)
            return "";

        return `${introText} ${it[prop].map(as=>{
            if (as.entry)
                return (isText ? Renderer.stripTags : Renderer.get().render)(as.entry);
            return `${isText ? "" : `<i class="help-subtle" title="${Parser.sourceJsonToFull(as.source).qq()}">`}${Parser.sourceJsonToAbv(as.source)}${isText ? "" : `</i>`}${Renderer.utils.isDisplayPage(as.page) ? `, page ${as.page}` : ""}`;
        }
        ).join("; ")}`;
    },

    _getReprintedAsHtmlOrText(ent, {isText, tag, fnUnpackUid}={}) {
        if (!ent.reprintedAs)
            return "";
        if (!tag || !fnUnpackUid)
            return "";

        const ptReprinted = ent.reprintedAs.map(it=>{
            const uid = it.uid ?? it;
            const tag_ = it.tag ?? tag;

            const {name, source, displayText} = fnUnpackUid(uid);

            if (isText) {
                return `${Renderer.stripTags(displayText || name)} in ${Parser.sourceJsonToAbv(source)}`;
            }

            const asTag = `{@${tag_} ${name}|${source}${displayText ? `|${displayText}` : ""}}`;

            return `${Renderer.get().render(asTag)} in <i class="help-subtle" title="${Parser.sourceJsonToFull(source).qq()}">${Parser.sourceJsonToAbv(source)}</i>`;
        }
        ).join("; ");

        return `Reprinted as ${ptReprinted}`;
    },

    getSourceAndPageHtml(it, {tag, fnUnpackUid}={}) {
        return this._getSourceAndPageHtmlOrText(it, {
            tag,
            fnUnpackUid
        });
    },
    getSourceAndPageText(it, {tag, fnUnpackUid}={}) {
        return this._getSourceAndPageHtmlOrText(it, {
            isText: true,
            tag,
            fnUnpackUid
        });
    },

    _getSourceAndPageHtmlOrText(it, {isText, tag, fnUnpackUid}={}) {
        const sourceSub = Renderer.utils.getSourceSubText(it);
        const baseText = `${isText ? `` : `<i title="${Parser.sourceJsonToFull(it.source)}${sourceSub}">`}${Parser.sourceJsonToAbv(it.source)}${sourceSub}${isText ? "" : `</i>`}${Renderer.utils.isDisplayPage(it.page) ? `, page ${it.page}` : ""}`;
        const reprintedAsText = Renderer.utils._getReprintedAsHtmlOrText(it, {
            isText,
            tag,
            fnUnpackUid
        });
        const addSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "additionalSources", "Additional information from", isText);
        const otherSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "otherSources", "Also found in", isText);
        const externalSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "externalSources", "External sources:", isText);

        const srdText = it.srd ? `${isText ? "" : `the <span title="Systems Reference Document">`}SRD${isText ? "" : `</span>`}${typeof it.srd === "string" ? ` (as &quot;${it.srd}&quot;)` : ""}` : "";
        const basicRulesText = it.basicRules ? `the Basic Rules${typeof it.basicRules === "string" ? ` (as &quot;${it.basicRules}&quot;)` : ""}` : "";
        const srdAndBasicRulesText = (srdText || basicRulesText) ? `Available in ${[srdText, basicRulesText].filter(it=>it).join(" and ")}` : "";

        return `${[baseText, addSourceText, reprintedAsText, otherSourceText, srdAndBasicRulesText, externalSourceText].filter(it=>it).join(". ")}${baseText && (addSourceText || otherSourceText || srdAndBasicRulesText || externalSourceText) ? "." : ""}`;
    },

    async _pHandleNameClick(ele) {
        await MiscUtil.pCopyTextToClipboard($(ele).text());
        JqueryUtil.showCopiedEffect($(ele));
    },

    getPageTr(it, {tag, fnUnpackUid}={}) {
        return `<tr><td colspan=6>${Renderer.utils.getSourceAndPageTrHtml(it, {
            tag,
            fnUnpackUid
        })}</td></tr>`;
    },

    getAbilityRollerEntry(statblock, ability) {
        if (statblock[ability] == null)
            return "\u2014";
        return `{@ability ${ability} ${statblock[ability]}}`;
    },

    getAbilityRoller(statblock, ability) {
        return Renderer.get().render(Renderer.utils.getAbilityRollerEntry(statblock, ability));
    },

    getEmbeddedDataHeader(name, style, {isCollapsed=false}={}) {
        return `<table class="rd__b-special rd__b-data ${style ? `rd__b-data--${style}` : ""}">
		<thead><tr><th class="rd__data-embed-header" colspan="6" data-rd-data-embed-header="true"><span class="rd__data-embed-name ${isCollapsed ? "" : `ve-hidden`}">${name}</span><span class="rd__data-embed-toggle">[${isCollapsed ? "+" : "\u2013"}]</span></th></tr></thead><tbody class="${isCollapsed ? `ve-hidden` : ""}" data-rd-embedded-data-render-target="true">`;
    },

    getEmbeddedDataFooter() {
        return `</tbody></table>`;
    },

    TabButton: function({label, fnChange, fnPopulate, isVisible}) {
        this.label = label;
        this.fnChange = fnChange;
        this.fnPopulate = fnPopulate;
        this.isVisible = isVisible;
    },

    _tabs: {},
    _curTab: null,
    _tabsPreferredLabel: null,
    bindTabButtons({tabButtons, tabLabelReference, $wrpTabs, $pgContent}) {
        Renderer.utils._tabs = {};
        Renderer.utils._curTab = null;

        $wrpTabs.find(`.stat-tab-gen`).remove();

        tabButtons.forEach((tb,i)=>{
            tb.ix = i;

            tb.$t = $(`<button class="ui-tab__btn-tab-head btn btn-default stat-tab-gen">${tb.label}</button>`).click(()=>tb.fnActivateTab({
                isUserInput: true
            }));

            tb.fnActivateTab = ({isUserInput=false}={})=>{
                const curTab = Renderer.utils._curTab;
                const tabs = Renderer.utils._tabs;

                if (!curTab || curTab.label !== tb.label) {
                    if (curTab)
                        curTab.$t.removeClass(`ui-tab__btn-tab-head--active`);
                    Renderer.utils._curTab = tb;
                    tb.$t.addClass(`ui-tab__btn-tab-head--active`);
                    if (curTab)
                        tabs[curTab.label].$content = $pgContent.children().detach();

                    tabs[tb.label] = tb;
                    if (!tabs[tb.label].$content && tb.fnPopulate)
                        tb.fnPopulate();
                    else
                        $pgContent.append(tabs[tb.label].$content);
                    if (tb.fnChange)
                        tb.fnChange();
                }

                if (isUserInput)
                    Renderer.utils._tabsPreferredLabel = tb.label;
            }
            ;
        }
        );

        if (tabButtons.length !== 1)
            tabButtons.slice().reverse().forEach(tb=>$wrpTabs.prepend(tb.$t));

        if (!Renderer.utils._tabsPreferredLabel)
            return tabButtons[0].fnActivateTab();

        const tabButton = tabButtons.find(tb=>tb.label === Renderer.utils._tabsPreferredLabel);
        if (tabButton)
            return tabButton.fnActivateTab();

        const ixDesired = tabLabelReference.indexOf(Renderer.utils._tabsPreferredLabel);
        if (!~ixDesired)
            return tabButtons[0].fnActivateTab();
        const ixsAvailableMetas = tabButtons.map(tb=>{
            const ixMapped = tabLabelReference.indexOf(tb.label);
            if (!~ixMapped)
                return null;
            return {
                ixMapped,
                label: tb.label,
            };
        }
        ).filter(Boolean);
        if (!ixsAvailableMetas.length)
            return tabButtons[0].fnActivateTab();
        const ixMetaHigher = ixsAvailableMetas.find(({ixMapped})=>ixMapped > ixDesired);
        if (ixMetaHigher != null)
            return (tabButtons.find(it=>it.label === ixMetaHigher.label) || tabButtons[0]).fnActivateTab();

        const ixMetaMax = ixsAvailableMetas.last();
        (tabButtons.find(it=>it.label === ixMetaMax.label) || tabButtons[0]).fnActivateTab();
    },

    _pronounceButtonsBound: false,
    bindPronounceButtons() {
        if (Renderer.utils._pronounceButtonsBound)
            return;
        Renderer.utils._pronounceButtonsBound = true;
        $(`body`).on("click", ".btn-name-pronounce", function() {
            const audio = $(this).find(`.name-pronounce`)[0];
            audio.currentTime = 0;
            audio.play();
        });
    },

    async pHasFluffText(entity, prop) {
        return entity.hasFluff || ((await Renderer.utils.pGetPredefinedFluff(entity, prop))?.entries?.length || 0) > 0;
    },

    async pHasFluffImages(entity, prop) {
        return entity.hasFluffImages || (((await Renderer.utils.pGetPredefinedFluff(entity, prop))?.images?.length || 0) > 0);
    },

    async pGetPredefinedFluff(entry, prop) {
        if (!entry.fluff)
            return null;

        const mappedProp = `_${prop}`;
        const mappedPropAppend = `_append${prop.uppercaseFirst()}`;
        const fluff = {};

        const assignPropsIfExist = (fromObj,...props)=>{
            props.forEach(prop=>{
                if (fromObj[prop])
                    fluff[prop] = fromObj[prop];
            }
            );
        }
        ;

        assignPropsIfExist(entry.fluff, "name", "type", "entries", "images");

        if (entry.fluff[mappedProp]) {
            const fromList = [...((await PrereleaseUtil.pGetBrewProcessed())[prop] || []), ...((await BrewUtil2.pGetBrewProcessed())[prop] || []), ].find(it=>it.name === entry.fluff[mappedProp].name && it.source === entry.fluff[mappedProp].source, );
            if (fromList) {
                assignPropsIfExist(fromList, "name", "type", "entries", "images");
            }
        }

        if (entry.fluff[mappedPropAppend]) {
            const fromList = [...((await PrereleaseUtil.pGetBrewProcessed())[prop] || []), ...((await BrewUtil2.pGetBrewProcessed())[prop] || []), ].find(it=>it.name === entry.fluff[mappedPropAppend].name && it.source === entry.fluff[mappedPropAppend].source, );
            if (fromList) {
                if (fromList.entries) {
                    fluff.entries = MiscUtil.copyFast(fluff.entries || []);
                    fluff.entries.push(...MiscUtil.copyFast(fromList.entries));
                }
                if (fromList.images) {
                    fluff.images = MiscUtil.copyFast(fluff.images || []);
                    fluff.images.push(...MiscUtil.copyFast(fromList.images));
                }
            }
        }

        return fluff;
    },

    async pGetFluff({entity, pFnPostProcess, fnGetFluffData, fluffUrl, fluffBaseUrl, fluffProp}={}) {
        let predefinedFluff = await Renderer.utils.pGetPredefinedFluff(entity, fluffProp);
        if (predefinedFluff) {
            if (pFnPostProcess)
                predefinedFluff = await pFnPostProcess(predefinedFluff);
            return predefinedFluff;
        }
        if (!fnGetFluffData && !fluffBaseUrl && !fluffUrl)
            return null;

        const fluffIndex = fluffBaseUrl ? await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffBaseUrl}fluff-index.json`) : null;
        if (fluffIndex && !fluffIndex[entity.source])
            return null;

        const data = fnGetFluffData ? await fnGetFluffData() : fluffIndex && fluffIndex[entity.source] ? await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffBaseUrl}${fluffIndex[entity.source]}`) : await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffUrl}`);
        if (!data)
            return null;

        let fluff = (data[fluffProp] || []).find(it=>it.name === entity.name && it.source === entity.source);
        if (!fluff && entity._versionBase_name && entity._versionBase_source)
            fluff = (data[fluffProp] || []).find(it=>it.name === entity._versionBase_name && it.source === entity._versionBase_source);
        if (!fluff)
            return null;

        if (pFnPostProcess)
            fluff = await pFnPostProcess(fluff);
        return fluff;
    },

    _TITLE_SKIP_TYPES: new Set(["entries", "section"]),
    async pBuildFluffTab({isImageTab, $content, entity, $headerControls, pFnGetFluff}={}) {
        $content.append(Renderer.utils.getBorderTr());
        $content.append(Renderer.utils.getNameTr(entity, {
            controlRhs: $headerControls,
            asJquery: true
        }));
        const $td = $(`<td colspan="6" class="text"></td>`);
        $$`<tr class="text">${$td}</tr>`.appendTo($content);
        $content.append(Renderer.utils.getBorderTr());

        const fluff = MiscUtil.copyFast((await pFnGetFluff(entity)) || {});
        fluff.entries = fluff.entries || [Renderer.utils.HTML_NO_INFO];
        fluff.images = fluff.images || [Renderer.utils.HTML_NO_IMAGES];

        $td.fastSetHtml(Renderer.utils.getFluffTabContent({
            entity,
            fluff,
            isImageTab
        }));
    },

    getFluffTabContent({entity, fluff, isImageTab=false}) {
        Renderer.get().setFirstSection(true);
        return (fluff[isImageTab ? "images" : "entries"] || []).map((ent,i)=>{
            if (isImageTab)
                return Renderer.get().render(ent);

            if (i === 0 && ent.name && entity.name && (Renderer.utils._TITLE_SKIP_TYPES).has(ent.type)) {
                const entryLowName = ent.name.toLowerCase().trim();
                const entityLowName = entity.name.toLowerCase().trim();

                if (entryLowName.includes(entityLowName) || entityLowName.includes(entryLowName)) {
                    const cpy = MiscUtil.copyFast(ent);
                    delete cpy.name;
                    return Renderer.get().render(cpy);
                } else
                    return Renderer.get().render(ent);
            } else {
                if (typeof ent === "string")
                    return `<p>${Renderer.get().render(ent)}</p>`;
                else
                    return Renderer.get().render(ent);
            }
        }
        ).join("");
    },

    HTML_NO_INFO: "<i>No information available.</i>",
    HTML_NO_IMAGES: "<i>No images available.</i>",

    prerequisite: class {
        static _WEIGHTS = ["level", "pact", "patron", "spell", "race", "alignment", "ability", "proficiency", "spellcasting", "spellcasting2020", "spellcastingFeature", "spellcastingPrepared", "psionics", "feature", "feat", "background", "item", "itemType", "itemProperty", "campaign", "group", "other", "otherSummary", undefined, ].mergeMap((k,i)=>({
            [k]: i
        }));

        static _getShortClassName(className) {
            const ixFirstVowel = /[aeiou]/.exec(className).index;
            const start = className.slice(0, ixFirstVowel + 1);
            let end = className.slice(ixFirstVowel + 1);
            end = end.replace(/[aeiou]/g, "");
            return `${start}${end}`.toTitleCase();
        }

        static getHtml(prerequisites, {isListMode=false, blocklistKeys=new Set(), isTextOnly=false, isSkipPrefix=false}={}) {
            if (!prerequisites?.length)
                return isListMode ? "\u2014" : "";

            const prereqsShared = prerequisites.length === 1 ? {} : Object.entries(prerequisites.slice(1).reduce((a,b)=>CollectionUtil.objectIntersect(a, b), prerequisites[0]), ).filter(([k,v])=>prerequisites.every(pre=>CollectionUtil.deepEquals(pre[k], v))).mergeMap(([k,v])=>({
                [k]: v
            }));

            const shared = Object.keys(prereqsShared).length ? this.getHtml([prereqsShared], {
                isListMode,
                blocklistKeys,
                isTextOnly,
                isSkipPrefix: true
            }) : null;

            let cntPrerequisites = 0;
            let hasNote = false;
            const listOfChoices = prerequisites.map(pr=>{
                const ptNote = !isListMode && pr.note ? Renderer.get().render(pr.note) : null;
                if (ptNote) {
                    hasNote = true;
                }

                const prereqsToJoin = Object.entries(pr).filter(([k])=>!prereqsShared[k]).sort(([kA],[kB])=>this._WEIGHTS[kA] - this._WEIGHTS[kB]).map(([k,v])=>{
                    if (k === "note" || blocklistKeys.has(k))
                        return false;

                    cntPrerequisites += 1;

                    switch (k) {
                    case "level":
                        return this._getHtml_level({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "pact":
                        return this._getHtml_pact({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "patron":
                        return this._getHtml_patron({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spell":
                        return this._getHtml_spell({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "feat":
                        return this._getHtml_feat({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "feature":
                        return this._getHtml_feature({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "item":
                        return this._getHtml_item({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "itemType":
                        return this._getHtml_itemType({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "itemProperty":
                        return this._getHtml_itemProperty({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "otherSummary":
                        return this._getHtml_otherSummary({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "other":
                        return this._getHtml_other({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "race":
                        return this._getHtml_race({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "background":
                        return this._getHtml_background({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "ability":
                        return this._getHtml_ability({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "proficiency":
                        return this._getHtml_proficiency({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcasting":
                        return this._getHtml_spellcasting({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcasting2020":
                        return this._getHtml_spellcasting2020({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcastingFeature":
                        return this._getHtml_spellcastingFeature({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "spellcastingPrepared":
                        return this._getHtml_spellcastingPrepared({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "psionics":
                        return this._getHtml_psionics({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "alignment":
                        return this._getHtml_alignment({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "campaign":
                        return this._getHtml_campaign({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    case "group":
                        return this._getHtml_group({
                            v,
                            isListMode,
                            isTextOnly
                        });
                    default:
                        throw new Error(`Unhandled key: ${k}`);
                    }
                }
                ).filter(Boolean);

                const ptPrereqs = prereqsToJoin.join(prereqsToJoin.some(it=>/ or /.test(it)) ? "; " : ", ");

                return [ptPrereqs, ptNote].filter(Boolean).join(". ");
            }
            ).filter(Boolean);

            if (!listOfChoices.length && !shared)
                return isListMode ? "\u2014" : "";
            if (isListMode)
                return [shared, listOfChoices.join("/")].filter(Boolean).join(" + ");

            const sharedSuffix = MiscUtil.findCommonSuffix(listOfChoices, {
                isRespectWordBoundaries: true
            });
            const listOfChoicesTrimmed = sharedSuffix ? listOfChoices.map(it=>it.slice(0, -sharedSuffix.length)) : listOfChoices;

            const joinedChoices = (hasNote ? listOfChoicesTrimmed.join(" Or, ") : listOfChoicesTrimmed.joinConjunct(listOfChoicesTrimmed.some(it=>/ or /.test(it)) ? "; " : ", ", " or ")) + sharedSuffix;
            return `${isSkipPrefix ? "" : `Prerequisite${cntPrerequisites === 1 ? "" : "s"}: `}${[shared, joinedChoices].filter(Boolean).join(", plus ")}`;
        }

        static _getHtml_level({v, isListMode}) {
            if (typeof v === "number") {
                if (isListMode)
                    return `Lvl ${v}`;
                else
                    return `${Parser.getOrdinalForm(v)} level`;
            } else if (!v.class && !v.subclass) {
                if (isListMode)
                    return `Lvl ${v.level}`;
                else
                    return `${Parser.getOrdinalForm(v.level)} level`;
            }

            const isLevelVisible = v.level !== 1;
            const isSubclassVisible = v.subclass && v.subclass.visible;
            const isClassVisible = v.class && (v.class.visible || isSubclassVisible);
            if (isListMode) {
                const shortNameRaw = isClassVisible ? this._getShortClassName(v.class.name) : null;
                return `${isClassVisible ? `${shortNameRaw.slice(0, 4)}${isSubclassVisible ? "*" : "."}` : ""}${isLevelVisible ? ` Lvl ${v.level}` : ""}`;
            } else {
                let classPart = "";
                if (isClassVisible && isSubclassVisible)
                    classPart = ` ${v.class.name} (${v.subclass.name})`;
                else if (isClassVisible)
                    classPart = ` ${v.class.name}`;
                else if (isSubclassVisible)
                    classPart = ` &lt;remember to insert class name here&gt; (${v.subclass.name})`;
                return `${isLevelVisible ? `${Parser.getOrdinalForm(v.level)} level` : ""}${isClassVisible ? ` ${classPart}` : ""}`;
            }
        }

        static _getHtml_pact({v, isListMode}) {
            return Parser.prereqPactToFull(v);
        }

        static _getHtml_patron({v, isListMode}) {
            return isListMode ? `${Parser.prereqPatronToShort(v)} patron` : `${v} patron`;
        }

        static _getHtml_spell({v, isListMode, isTextOnly}) {
            return isListMode ? v.map(sp=>{
                if (typeof sp === "string")
                    return sp.split("#")[0].split("|")[0].toTitleCase();
                return sp.entrySummary || sp.entry;
            }
            ).join("/") : v.map(sp=>{
                if (typeof sp === "string")
                    return Parser.prereqSpellToFull(sp, {
                        isTextOnly
                    });
                return isTextOnly ? Renderer.stripTags(sp.entry) : Renderer.get().render(`{@filter ${sp.entry}|spells|${sp.choose}}`);
            }
            ).joinConjunct(", ", " or ");
        }

        static _getHtml_feat({v, isListMode, isTextOnly}) {
            return isListMode ? v.map(x=>x.split("|")[0].toTitleCase()).join("/") : v.map(it=>(isTextOnly ? Renderer.stripTags.bind(Renderer) : Renderer.get().render.bind(Renderer.get()))(`{@feat ${it}} feat`)).joinConjunct(", ", " or ");
        }

        static _getHtml_feature({v, isListMode, isTextOnly}) {
            return isListMode ? v.map(x=>Renderer.stripTags(x).toTitleCase()).join("/") : v.map(it=>isTextOnly ? Renderer.stripTags(it) : Renderer.get().render(it)).joinConjunct(", ", " or ");
        }

        static _getHtml_item({v, isListMode}) {
            return isListMode ? v.map(x=>x.toTitleCase()).join("/") : v.joinConjunct(", ", " or ");
        }

        static _getHtml_itemType({v, isListMode}) {
            return isListMode ? v.map(it=>Renderer.item.getType(it)).map(it=>it?.abbreviation).join("+") : v.map(it=>Renderer.item.getType(it)).map(it=>it?.name?.toTitleCase()).joinConjunct(", ", " and ");
        }

        static _getHtml_itemProperty({v, isListMode}) {
            if (v == null)
                return isListMode ? "No Prop." : "No Other Properties";

            return isListMode ? v.map(it=>Renderer.item.getProperty(it)).map(it=>it?.abbreviation).join("+") : (`${v.map(it=>Renderer.item.getProperty(it)).map(it=>it?.name?.toTitleCase()).joinConjunct(", ", " and ")} Property`);
        }

        static _getHtml_otherSummary({v, isListMode, isTextOnly}) {
            return isListMode ? (v.entrySummary || Renderer.stripTags(v.entry)) : (isTextOnly ? Renderer.stripTags(v.entry) : Renderer.get().render(v.entry));
        }

        static _getHtml_other({v, isListMode, isTextOnly}) {
            return isListMode ? "Special" : (isTextOnly ? Renderer.stripTags(v) : Renderer.get().render(v));
        }

        static _getHtml_race({v, isListMode, isTextOnly}) {
            const parts = v.map((it,i)=>{
                if (isListMode) {
                    return `${it.name.toTitleCase()}${it.subrace != null ? ` (${it.subrace})` : ""}`;
                } else {
                    const raceName = it.displayEntry ? (isTextOnly ? Renderer.stripTags(it.displayEntry) : Renderer.get().render(it.displayEntry)) : i === 0 ? it.name.toTitleCase() : it.name;
                    return `${raceName}${it.subrace != null ? ` (${it.subrace})` : ""}`;
                }
            }
            );
            return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
        }

        static _getHtml_background({v, isListMode, isTextOnly}) {
            const parts = v.map((it,i)=>{
                if (isListMode) {
                    return `${it.name.toTitleCase()}`;
                } else {
                    return it.displayEntry ? (isTextOnly ? Renderer.stripTags(it.displayEntry) : Renderer.get().render(it.displayEntry)) : i === 0 ? it.name.toTitleCase() : it.name;
                }
            }
            );
            return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
        }

        static _getHtml_ability({v, isListMode, isTextOnly}) {

            let hadMultipleInner = false;
            let hadMultiMultipleInner = false;
            let allValuesEqual = null;

            outer: for (const abMeta of v) {
                for (const req of Object.values(abMeta)) {
                    if (allValuesEqual == null)
                        allValuesEqual = req;
                    else {
                        if (req !== allValuesEqual) {
                            allValuesEqual = null;
                            break outer;
                        }
                    }
                }
            }

            const abilityOptions = v.map(abMeta=>{
                if (allValuesEqual) {
                    const abList = Object.keys(abMeta);
                    hadMultipleInner = hadMultipleInner || abList.length > 1;
                    return isListMode ? abList.map(ab=>ab.uppercaseFirst()).join(", ") : abList.map(ab=>Parser.attAbvToFull(ab)).joinConjunct(", ", " and ");
                } else {
                    const groups = {};

                    Object.entries(abMeta).forEach(([ab,req])=>{
                        (groups[req] = groups[req] || []).push(ab);
                    }
                    );

                    let isMulti = false;
                    const byScore = Object.entries(groups).sort(([reqA],[reqB])=>SortUtil.ascSort(Number(reqB), Number(reqA))).map(([req,abs])=>{
                        hadMultipleInner = hadMultipleInner || abs.length > 1;
                        if (abs.length > 1)
                            hadMultiMultipleInner = isMulti = true;

                        abs = abs.sort(SortUtil.ascSortAtts);
                        return isListMode ? `${abs.map(ab=>ab.uppercaseFirst()).join(", ")} ${req}+` : `${abs.map(ab=>Parser.attAbvToFull(ab)).joinConjunct(", ", " and ")} ${req} or higher`;
                    }
                    );

                    return isListMode ? `${isMulti || byScore.length > 1 ? "(" : ""}${byScore.join(" & ")}${isMulti || byScore.length > 1 ? ")" : ""}` : isMulti ? byScore.joinConjunct("; ", " and ") : byScore.joinConjunct(", ", " and ");
                }
            }
            );

            if (isListMode) {
                return `${abilityOptions.join("/")}${allValuesEqual != null ? ` ${allValuesEqual}+` : ""}`;
            } else {
                const isComplex = hadMultiMultipleInner || hadMultipleInner || allValuesEqual == null;
                const joined = abilityOptions.joinConjunct(hadMultiMultipleInner ? " - " : hadMultipleInner ? "; " : ", ", isComplex ? (isTextOnly ? ` /or/ ` : ` <i>or</i> `) : " or ", );
                return `${joined}${allValuesEqual != null ? ` ${allValuesEqual} or higher` : ""}`;
            }
        }

        static _getHtml_proficiency({v, isListMode}) {
            const parts = v.map(obj=>{
                return Object.entries(obj).map(([profType,prof])=>{
                    switch (profType) {
                    case "armor":
                        {
                            return isListMode ? `Prof ${Parser.armorFullToAbv(prof)} armor` : `Proficiency with ${prof} armor`;
                        }
                    case "weapon":
                        {
                            return isListMode ? `Prof ${Parser.weaponFullToAbv(prof)} weapon` : `Proficiency with a ${prof} weapon`;
                        }
                    case "weaponGroup":
                        {
                            return isListMode ? `Prof ${Parser.weaponFullToAbv(prof)} weapons` : `${prof.toTitleCase()} Proficiency`;
                        }
                    default:
                        throw new Error(`Unhandled proficiency type: "${profType}"`);
                    }
                }
                );
            }
            );
            return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
        }

        static _getHtml_spellcasting({v, isListMode}) {
            return isListMode ? "Spellcasting" : "The ability to cast at least one spell";
        }

        static _getHtml_spellcasting2020({v, isListMode}) {
            return isListMode ? "Spellcasting" : "Spellcasting or Pact Magic feature";
        }

        static _getHtml_spellcastingFeature({v, isListMode}) {
            return isListMode ? "Spellcasting" : "Spellcasting Feature";
        }

        static _getHtml_spellcastingPrepared({v, isListMode}) {
            return isListMode ? "Spellcasting" : "Spellcasting feature from a class that prepares spells";
        }

        static _getHtml_psionics({v, isListMode, isTextOnly}) {
            return isListMode ? "Psionics" : (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))("Psionic Talent feature or Wild Talent feat");
        }

        static _getHtml_alignment({v, isListMode}) {
            return isListMode ? Parser.alignmentListToFull(v).replace(/\bany\b/gi, "").trim().replace(/\balignment\b/gi, "align").trim().toTitleCase() : Parser.alignmentListToFull(v);
        }

        static _getHtml_campaign({v, isListMode}) {
            return isListMode ? v.join("/") : `${v.joinConjunct(", ", " or ")} Campaign`;
        }

        static _getHtml_group({v, isListMode}) {
            return isListMode ? v.map(it=>it.toTitleCase()).join("/") : `${v.map(it=>it.toTitleCase()).joinConjunct(", ", " or ")} Group`;
        }
    }
    ,

    getRepeatableEntry(ent) {
        if (!ent.repeatable)
            return null;
        return `{@b Repeatable:} ${ent.repeatableNote || (ent.repeatable ? "Yes" : "No")}`;
    },

    getRepeatableHtml(ent, {isListMode=false}={}) {
        const entryRepeatable = Renderer.utils.getRepeatableEntry(ent);
        if (entryRepeatable == null)
            return isListMode ? "\u2014" : "";
        return Renderer.get().render(entryRepeatable);
    },

    getRenderedSize(size) {
        return [...(size ? [size].flat() : [])].sort(SortUtil.ascSortSize).map(sz=>Parser.sizeAbvToFull(sz)).joinConjunct(", ", " or ");
    },

    getMediaUrl(entry, prop, mediaDir) {
        if (!entry[prop])
            return "";

        let href = "";
        if (entry[prop].type === "internal") {
            const baseUrl = Renderer.get().baseMediaUrls[mediaDir] || Renderer.get().baseUrl;
            const mediaPart = `${mediaDir}/${entry[prop].path}`;
            href = baseUrl !== "" ? `${baseUrl}${mediaPart}` : UrlUtil.link(mediaPart);
        } else if (entry[prop].type === "external") {
            href = entry[prop].url;
        }
        return href;
    },

    getTagEntry(tag, text) {
        switch (tag) {
        case "@dice":
        case "@autodice":
        case "@damage":
        case "@hit":
        case "@d20":
        case "@chance":
        case "@recharge":
            {
                const fauxEntry = {
                    type: "dice",
                    rollable: true,
                };
                const [rollText,displayText,name,...others] = Renderer.splitTagByPipe(text);
                if (displayText)
                    fauxEntry.displayText = displayText;

                if ((!fauxEntry.displayText && (rollText || "").includes("summonSpellLevel")) || (fauxEntry.displayText && fauxEntry.displayText.includes("summonSpellLevel")))
                    fauxEntry.displayText = (fauxEntry.displayText || rollText || "").replace(/summonSpellLevel/g, "the spell's level");

                if ((!fauxEntry.displayText && (rollText || "").includes("summonClassLevel")) || (fauxEntry.displayText && fauxEntry.displayText.includes("summonClassLevel")))
                    fauxEntry.displayText = (fauxEntry.displayText || rollText || "").replace(/summonClassLevel/g, "your class level");

                if (name)
                    fauxEntry.name = name;

                switch (tag) {
                case "@dice":
                case "@autodice":
                case "@damage":
                    {
                        fauxEntry.toRoll = rollText;

                        if (!fauxEntry.displayText && (rollText || "").includes(";"))
                            fauxEntry.displayText = rollText.replace(/;/g, "/");
                        if ((!fauxEntry.displayText && (rollText || "").includes("#$")) || (fauxEntry.displayText && fauxEntry.displayText.includes("#$")))
                            fauxEntry.displayText = (fauxEntry.displayText || rollText).replace(/#\$prompt_number[^$]*\$#/g, "(n)");
                        fauxEntry.displayText = fauxEntry.displayText || fauxEntry.toRoll;

                        if (tag === "@damage")
                            fauxEntry.subType = "damage";
                        if (tag === "@autodice")
                            fauxEntry.autoRoll = true;

                        return fauxEntry;
                    }
                case "@d20":
                case "@hit":
                    {
                        let mod;
                        if (!isNaN(rollText)) {
                            const n = Number(rollText);
                            mod = `${n >= 0 ? "+" : ""}${n}`;
                        } else
                            mod = /^\s+[-+]/.test(rollText) ? rollText : `+${rollText}`;
                        fauxEntry.displayText = fauxEntry.displayText || mod;
                        fauxEntry.toRoll = `1d20${mod}`;
                        fauxEntry.subType = "d20";
                        fauxEntry.d20mod = mod;
                        if (tag === "@hit")
                            fauxEntry.context = {
                                type: "hit"
                            };
                        return fauxEntry;
                    }
                case "@chance":
                    {
                        const [textSuccess,textFailure] = others;
                        fauxEntry.toRoll = `1d100`;
                        fauxEntry.successThresh = Number(rollText);
                        fauxEntry.chanceSuccessText = textSuccess;
                        fauxEntry.chanceFailureText = textFailure;
                        return fauxEntry;
                    }
                case "@recharge":
                    {
                        const flags = displayText ? displayText.split("") : null;
                        fauxEntry.toRoll = "1d6";
                        const asNum = Number(rollText || 6);
                        fauxEntry.successThresh = 7 - asNum;
                        fauxEntry.successMax = 6;
                        fauxEntry.displayText = `${asNum}${asNum < 6 ? `\u20136` : ""}`;
                        fauxEntry.chanceSuccessText = "Recharged!";
                        fauxEntry.chanceFailureText = "Did not recharge";
                        fauxEntry.isColorSuccessFail = true;
                        return fauxEntry;
                    }
                }

                return fauxEntry;
            }

        case "@ability":
        case "@savingThrow":
            {
                const fauxEntry = {
                    type: "dice",
                    rollable: true,
                    subType: "d20",
                    context: {
                        type: tag === "@ability" ? "abilityCheck" : "savingThrow"
                    },
                };

                const [abilAndScoreOrScore,displayText,name,...others] = Renderer.splitTagByPipe(text);

                let[abil,...rawScoreOrModParts] = abilAndScoreOrScore.split(" ").map(it=>it.trim()).filter(Boolean);
                abil = abil.toLowerCase();

                fauxEntry.context.ability = abil;

                if (name)
                    fauxEntry.name = name;
                else {
                    if (tag === "@ability")
                        fauxEntry.name = Parser.attAbvToFull(abil);
                    else if (tag === "@savingThrow")
                        fauxEntry.name = `${Parser.attAbvToFull(abil)} save`;
                }

                const rawScoreOrMod = rawScoreOrModParts.join(" ");
                if (isNaN(rawScoreOrMod) && tag === "@savingThrow") {
                    if (displayText)
                        fauxEntry.displayText = displayText;
                    else
                        fauxEntry.displayText = rawScoreOrMod;

                    fauxEntry.toRoll = `1d20${rawScoreOrMod}`;
                    fauxEntry.d20mod = rawScoreOrMod;
                } else {
                    const scoreOrMod = Number(rawScoreOrMod) || 0;
                    const mod = (tag === "@ability" ? Parser.getAbilityModifier : UiUtil.intToBonus)(scoreOrMod);

                    if (displayText)
                        fauxEntry.displayText = displayText;
                    else {
                        if (tag === "@ability")
                            fauxEntry.displayText = `${scoreOrMod} (${mod})`;
                        else
                            fauxEntry.displayText = mod;
                    }

                    fauxEntry.toRoll = `1d20${mod}`;
                    fauxEntry.d20mod = mod;
                }

                return fauxEntry;
            }

        case "@skillCheck":
            {
                const fauxEntry = {
                    type: "dice",
                    rollable: true,
                    subType: "d20",
                    context: {
                        type: "skillCheck"
                    },
                };

                const [skillAndMod,displayText,name,...others] = Renderer.splitTagByPipe(text);

                const parts = skillAndMod.split(" ").map(it=>it.trim()).filter(Boolean);
                const namePart = parts.shift();
                const bonusPart = parts.join(" ");
                const skill = namePart.replace(/_/g, " ");

                let mod = bonusPart;
                if (!isNaN(bonusPart))
                    mod = UiUtil.intToBonus(Number(bonusPart) || 0);
                else if (bonusPart.startsWith("#$"))
                    mod = `+${bonusPart}`;

                fauxEntry.context.skill = skill;
                fauxEntry.displayText = displayText || mod;

                if (name)
                    fauxEntry.name = name;
                else
                    fauxEntry.name = skill.toTitleCase();

                fauxEntry.toRoll = `1d20${mod}`;
                fauxEntry.d20mod = mod;

                return fauxEntry;
            }

        case "@coinflip":
            {
                const [displayText,name,textSuccess,textFailure] = Renderer.splitTagByPipe(text);

                const fauxEntry = {
                    type: "dice",
                    toRoll: "1d2",
                    successThresh: 1,
                    successMax: 2,
                    displayText: displayText || "flip a coin",
                    chanceSuccessText: textSuccess || `Heads`,
                    chanceFailureText: textFailure || `Tails`,
                    isColorSuccessFail: !textSuccess && !textFailure,
                    rollable: true,
                };

                return fauxEntry;
            }

        default:
            throw new Error(`Unhandled tag "${tag}"`);
        }
    },

    getTagMeta(tag, text) {
        switch (tag) {
        case "@deity":
            {
                let[name,pantheon,source,displayText,...others] = Renderer.splitTagByPipe(text);
                pantheon = pantheon || "forgotten realms";
                source = source || Parser.getTagSource(tag, source);
                const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES]({
                    name,
                    pantheon,
                    source
                });

                return {
                    name,
                    displayText,
                    others,

                    page: UrlUtil.PG_DEITIES,
                    source,
                    hash,

                    hashPreEncoded: true,
                };
            }

        case "@card":
            {
                const unpacked = DataUtil.deck.unpackUidCard(text);
                const {name, set, source, displayText} = unpacked;
                const hash = UrlUtil.URL_TO_HASH_BUILDER["card"]({
                    name,
                    set,
                    source
                });

                return {
                    name,
                    displayText,

                    isFauxPage: true,
                    page: "card",
                    source,
                    hash,
                    hashPreEncoded: true,
                };
            }

        case "@classFeature":
            {
                const unpacked = DataUtil.class.unpackUidClassFeature(text);

                const classPageHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
                    name: unpacked.className,
                    source: unpacked.classSource
                })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                    feature: {
                        ixLevel: unpacked.level - 1,
                        ixFeature: 0
                    }
                })}`;

                return {
                    name: unpacked.name,
                    displayText: unpacked.displayText,

                    page: UrlUtil.PG_CLASSES,
                    source: unpacked.source,
                    hash: classPageHash,
                    hashPreEncoded: true,

                    pageHover: "classfeature",
                    hashHover: UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked),
                    hashPreEncodedHover: true,
                };
            }

        case "@subclassFeature":
            {
                const unpacked = DataUtil.class.unpackUidSubclassFeature(text);

                const classPageHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({
                    name: unpacked.className,
                    source: unpacked.classSource
                })}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({
                    feature: {
                        ixLevel: unpacked.level - 1,
                        ixFeature: 0
                    }
                })}`;

                return {
                    name: unpacked.name,
                    displayText: unpacked.displayText,

                    page: UrlUtil.PG_CLASSES,
                    source: unpacked.source,
                    hash: classPageHash,
                    hashPreEncoded: true,

                    pageHover: "subclassfeature",
                    hashHover: UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked),
                    hashPreEncodedHover: true,
                };
            }

        case "@quickref":
            {
                const unpacked = DataUtil.quickreference.unpackUid(text);

                const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_QUICKREF](unpacked);

                return {
                    name: unpacked.name,
                    displayText: unpacked.displayText,

                    page: UrlUtil.PG_QUICKREF,
                    source: unpacked.source,
                    hash,
                    hashPreEncoded: true,
                };
            }

        default:
            return Renderer.utils._getTagMeta_generic(tag, text);
        }
    },

    _getTagMeta_generic(tag, text) {
        const {name, source, displayText, others} = DataUtil.generic.unpackUid(text, tag);
        const hash = UrlUtil.encodeForHash([name, source]);

        const out = {
            name,
            displayText,
            others,

            page: null,
            source,
            hash,

            preloadId: null,
            subhashes: null,
            linkText: null,

            hashPreEncoded: true,
        };

        switch (tag) {
        case "@spell":
            out.page = UrlUtil.PG_SPELLS;
            break;
        case "@item":
            out.page = UrlUtil.PG_ITEMS;
            break;
        case "@condition":
        case "@disease":
        case "@status":
            out.page = UrlUtil.PG_CONDITIONS_DISEASES;
            break;
        case "@background":
            out.page = UrlUtil.PG_BACKGROUNDS;
            break;
        case "@race":
            out.page = UrlUtil.PG_RACES;
            break;
        case "@optfeature":
            out.page = UrlUtil.PG_OPT_FEATURES;
            break;
        case "@reward":
            out.page = UrlUtil.PG_REWARDS;
            break;
        case "@feat":
            out.page = UrlUtil.PG_FEATS;
            break;
        case "@psionic":
            out.page = UrlUtil.PG_PSIONICS;
            break;
        case "@object":
            out.page = UrlUtil.PG_OBJECTS;
            break;
        case "@boon":
        case "@cult":
            out.page = UrlUtil.PG_CULTS_BOONS;
            break;
        case "@trap":
        case "@hazard":
            out.page = UrlUtil.PG_TRAPS_HAZARDS;
            break;
        case "@variantrule":
            out.page = UrlUtil.PG_VARIANTRULES;
            break;
        case "@table":
            out.page = UrlUtil.PG_TABLES;
            break;
        case "@vehicle":
        case "@vehupgrade":
            out.page = UrlUtil.PG_VEHICLES;
            break;
        case "@action":
            out.page = UrlUtil.PG_ACTIONS;
            break;
        case "@language":
            out.page = UrlUtil.PG_LANGUAGES;
            break;
        case "@charoption":
            out.page = UrlUtil.PG_CHAR_CREATION_OPTIONS;
            break;
        case "@recipe":
            out.page = UrlUtil.PG_RECIPES;
            break;
        case "@deck":
            out.page = UrlUtil.PG_DECKS;
            break;

        case "@legroup":
            {
                out.page = "legendaryGroup";
                out.isFauxPage = true;
                break;
            }

        case "@creature":
            {
                out.page = UrlUtil.PG_BESTIARY;

                if (others.length) {
                    const [type,value] = others[0].split("=").map(it=>it.trim().toLowerCase()).filter(Boolean);
                    if (type && value) {
                        switch (type) {
                        case VeCt.HASH_SCALED:
                            {
                                const targetCrNum = Parser.crToNumber(value);
                                out.preloadId = Renderer.monster.getCustomHashId({
                                    name,
                                    source,
                                    _isScaledCr: true,
                                    _scaledCr: targetCrNum
                                });
                                out.subhashes = [{
                                    key: VeCt.HASH_SCALED,
                                    value: targetCrNum
                                }, ];
                                out.linkText = displayText || `${name} (CR ${value})`;
                                break;
                            }

                        case VeCt.HASH_SCALED_SPELL_SUMMON:
                            {
                                const scaledSpellNum = Number(value);
                                out.preloadId = Renderer.monster.getCustomHashId({
                                    name,
                                    source,
                                    _isScaledSpellSummon: true,
                                    _scaledSpellSummonLevel: scaledSpellNum
                                });
                                out.subhashes = [{
                                    key: VeCt.HASH_SCALED_SPELL_SUMMON,
                                    value: scaledSpellNum
                                }, ];
                                out.linkText = displayText || `${name} (Spell Level ${value})`;
                                break;
                            }

                        case VeCt.HASH_SCALED_CLASS_SUMMON:
                            {
                                const scaledClassNum = Number(value);
                                out.preloadId = Renderer.monster.getCustomHashId({
                                    name,
                                    source,
                                    _isScaledClassSummon: true,
                                    _scaledClassSummonLevel: scaledClassNum
                                });
                                out.subhashes = [{
                                    key: VeCt.HASH_SCALED_CLASS_SUMMON,
                                    value: scaledClassNum
                                }, ];
                                out.linkText = displayText || `${name} (Class Level ${value})`;
                                break;
                            }
                        }
                    }
                }

                break;
            }

        case "@class":
            {
                out.page = UrlUtil.PG_CLASSES;

                if (others.length) {
                    const [subclassShortName,subclassSource,featurePart] = others;

                    if (subclassSource)
                        out.source = subclassSource;

                    const classStateOpts = {
                        subclass: {
                            shortName: subclassShortName.trim(),
                            source: subclassSource ? subclassSource.trim() : Parser.SRC_PHB,
                        },
                    };

                    const hoverSubhashObj = UrlUtil.unpackSubHash(UrlUtil.getClassesPageStatePart(classStateOpts));
                    out.subhashesHover = [{
                        key: "state",
                        value: hoverSubhashObj.state,
                        preEncoded: true
                    }];

                    if (featurePart) {
                        const featureParts = featurePart.trim().split("-");
                        classStateOpts.feature = {
                            ixLevel: featureParts[0] || "0",
                            ixFeature: featureParts[1] || "0",
                        };
                    }

                    const subhashObj = UrlUtil.unpackSubHash(UrlUtil.getClassesPageStatePart(classStateOpts));

                    out.subhashes = [{
                        key: "state",
                        value: subhashObj.state.join(HASH_SUB_LIST_SEP),
                        preEncoded: true
                    }, {
                        key: "fltsource",
                        value: "clear"
                    }, {
                        key: "flstmiscellaneous",
                        value: "clear"
                    }, ];
                }

                break;
            }

        case "@skill":
            {
                out.isFauxPage = true;
                out.page = "skill";
                break;
            }
        case "@sense":
            {
                out.isFauxPage = true;
                out.page = "sense";
                break;
            }
        case "@itemMastery":
            {
                out.isFauxPage = true;
                out.page = "itemMastery";
                break;
            }
        case "@cite":
            {
                out.isFauxPage = true;
                out.page = "citation";
                break;
            }

        default:
            throw new Error(`Unhandled tag "${tag}"`);
        }

        return out;
    },

    applyTemplate(ent, templateString, {fnPreApply, mapCustom}={}) {
        return templateString.replace(/{{([^}]+)}}/g, (fullMatch,strArgs)=>{
            if (fnPreApply)
                fnPreApply(fullMatch, strArgs);

            if (strArgs === "item.dmg1") {
                return Renderer.item._getTaggedDamage(ent.dmg1);
            } else if (strArgs === "item.dmg2") {
                return Renderer.item._getTaggedDamage(ent.dmg2);
            }

            if (mapCustom && mapCustom[strArgs])
                return mapCustom[strArgs];

            const args = strArgs.split(" ").map(arg=>arg.trim()).filter(Boolean);

            if (args.length === 1) {
                return Renderer.utils._applyTemplate_getValue(ent, args[0]);
            } else if (args.length === 2) {
                const val = Renderer.utils._applyTemplate_getValue(ent, args[1]);
                switch (args[0]) {
                case "getFullImmRes":
                    return Parser.getFullImmRes(val);
                default:
                    throw new Error(`Unknown template function "${args[0]}"`);
                }
            } else
                throw new Error(`Unhandled number of arguments ${args.length}`);
        }
        );
    },

    _applyTemplate_getValue(ent, prop) {
        const spl = prop.split(".");
        switch (spl[0]) {
        case "item":
            {
                const path = spl.slice(1);
                if (!path.length)
                    return `{@i missing key path}`;
                return MiscUtil.get(ent, ...path);
            }
        default:
            return `{@i unknown template root: "${spl[0]}"}`;
        }
    },

    getFlatEntries(entry) {
        const out = [];
        const depthStack = [];

        const recurse = ({obj})=>{
            let isPopDepth = false;

            Renderer.ENTRIES_WITH_ENUMERATED_TITLES.forEach(meta=>{
                if (obj.type !== meta.type)
                    return;

                const kName = "name";
                if (obj[kName] == null)
                    return;

                isPopDepth = true;

                const curDepth = depthStack.length ? depthStack.last() : 0;
                const nxtDepth = meta.depth ? meta.depth : meta.depthIncrement ? curDepth + meta.depthIncrement : curDepth;

                depthStack.push(Math.min(nxtDepth, 2, ), );

                const cpyObj = MiscUtil.copyFast(obj);

                out.push({
                    depth: curDepth,
                    entry: cpyObj,
                    key: meta.key,
                    ix: out.length,
                    name: cpyObj.name,
                });

                cpyObj[meta.key] = cpyObj[meta.key].map(child=>{
                    if (!child.type)
                        return child;
                    const childMeta = Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[child.type];
                    if (!childMeta)
                        return child;

                    const kNameChild = "name";
                    if (child[kName] == null)
                        return child;

                    const ixNextRef = out.length;

                    recurse({
                        obj: child
                    });

                    return {
                        IX_FLAT_REF: ixNextRef
                    };
                }
                );
            }
            );

            if (isPopDepth)
                depthStack.pop();
        }
        ;

        recurse({
            obj: entry
        });

        return out;
    },

    getLinkSubhashString(subhashes) {
        let out = "";
        const len = subhashes.length;
        for (let i = 0; i < len; ++i) {
            const subHash = subhashes[i];
            if (subHash.preEncoded)
                out += `${HASH_PART_SEP}${subHash.key}${HASH_SUB_KV_SEP}`;
            else
                out += `${HASH_PART_SEP}${UrlUtil.encodeForHash(subHash.key)}${HASH_SUB_KV_SEP}`;
            if (subHash.value != null) {
                if (subHash.preEncoded)
                    out += subHash.value;
                else
                    out += UrlUtil.encodeForHash(subHash.value);
            } else {
                out += subHash.values.map(v=>UrlUtil.encodeForHash(v)).join(HASH_SUB_LIST_SEP);
            }
        }
        return out;
    },

    initFullEntries_(ent, {propEntries="entries", propFullEntries="_fullEntries"}={}) {
        ent[propFullEntries] = ent[propFullEntries] || (ent[propEntries] ? MiscUtil.copyFast(ent[propEntries]) : []);
    },

    lazy: {
        _getIntersectionConfig() {
            return {
                rootMargin: "150px 0px",
                threshold: 0.01,
            };
        },

        _OBSERVERS: {},
        getCreateObserver({observerId, fnOnObserve}) {
            if (!Renderer.utils.lazy._OBSERVERS[observerId]) {
                const observer = Renderer.utils.lazy._OBSERVERS[observerId] = new IntersectionObserver(Renderer.utils.lazy.getFnOnIntersect({
                    observerId,
                    fnOnObserve,
                }),Renderer.utils.lazy._getIntersectionConfig(),);

                observer._TRACKED = new Set();

                observer.track = it=>{
                    observer._TRACKED.add(it);
                    return observer.observe(it);
                }
                ;

                observer.untrack = it=>{
                    observer._TRACKED.delete(it);
                    return observer.unobserve(it);
                }
                ;

                observer._printListener = evt=>{
                    if (!observer._TRACKED.size)
                        return;

                    [...observer._TRACKED].forEach(it=>{
                        observer.untrack(it);
                        fnOnObserve({
                            observer,
                            entry: {
                                target: it,
                            },
                        });
                    }
                    );

                    alert(`All content must be loaded prior to printing. Please cancel the print and wait a few moments for loading to complete!`);
                }
                ;
                window.addEventListener("beforeprint", observer._printListener);
            }
            return Renderer.utils.lazy._OBSERVERS[observerId];
        },

        destroyObserver({observerId}) {
            const observer = Renderer.utils.lazy._OBSERVERS[observerId];
            if (!observer)
                return;

            observer.disconnect();
            window.removeEventListener("beforeprint", observer._printListener);
        },

        getFnOnIntersect({observerId, fnOnObserve}) {
            return obsEntries=>{
                const observer = Renderer.utils.lazy._OBSERVERS[observerId];

                obsEntries.forEach(entry=>{
                    if (entry.intersectionRatio <= 0)
                        return;

                    observer.untrack(entry.target);
                    fnOnObserve({
                        observer,
                        entry,
                    });
                }
                );
            }
            ;
        },
    },
};

Renderer.tag = class {
    static _TagBase = class {
        tagName;
        defaultSource = null;
        page = null;

        get tag() {
            return `@${this.tagName}`;
        }

        getStripped(tag, text) {
            text = text.replace(/<\$([^$]+)\$>/gi, "");
            return this._getStripped(tag, text);
        }

        _getStripped(tag, text) {
            throw new Error("Unimplemented!");
        }

        getMeta(tag, text) {
            return this._getMeta(tag, text);
        }
        _getMeta(tag, text) {
            throw new Error("Unimplemented!");
        }
    }
    ;

    static _TagBaseAt = class extends this._TagBase {
        get tag() {
            return `@${this.tagName}`;
        }
    }
    ;

    static _TagBaseHash = class extends this._TagBase {
        get tag() {
            return `#${this.tagName}`;
        }
    }
    ;

    static _TagTextStyle = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            return text;
        }
    }
    ;

    static TagBoldShort = class extends this._TagTextStyle {
        tagName = "b";
    }
    ;

    static TagBoldLong = class extends this._TagTextStyle {
        tagName = "bold";
    }
    ;

    static TagItalicShort = class extends this._TagTextStyle {
        tagName = "i";
    }
    ;

    static TagItalicLong = class extends this._TagTextStyle {
        tagName = "italic";
    }
    ;

    static TagStrikethroughShort = class extends this._TagTextStyle {
        tagName = "s";
    }
    ;

    static TagStrikethroughLong = class extends this._TagTextStyle {
        tagName = "strike";
    }
    ;

    static TagUnderlineShort = class extends this._TagTextStyle {
        tagName = "u";
    }
    ;

    static TagUnderlineLong = class extends this._TagTextStyle {
        tagName = "underline";
    }
    ;

    static TagSup = class extends this._TagTextStyle {
        tagName = "sup";
    }
    ;

    static TagSub = class extends this._TagTextStyle {
        tagName = "sub";
    }
    ;

    static TagKbd = class extends this._TagTextStyle {
        tagName = "kbd";
    }
    ;

    static TagCode = class extends this._TagTextStyle {
        tagName = "code";
    }
    ;

    static TagStyle = class extends this._TagTextStyle {
        tagName = "style";
    }
    ;

    static TagFont = class extends this._TagTextStyle {
        tagName = "font";
    }
    ;

    static TagComic = class extends this._TagTextStyle {
        tagName = "comic";
    }
    ;

    static TagComicH1 = class extends this._TagTextStyle {
        tagName = "comicH1";
    }
    ;

    static TagComicH2 = class extends this._TagTextStyle {
        tagName = "comicH2";
    }
    ;

    static TagComicH3 = class extends this._TagTextStyle {
        tagName = "comicH3";
    }
    ;

    static TagComicH4 = class extends this._TagTextStyle {
        tagName = "comicH4";
    }
    ;

    static TagComicNote = class extends this._TagTextStyle {
        tagName = "comicNote";
    }
    ;

    static TagNote = class extends this._TagTextStyle {
        tagName = "note";
    }
    ;

    static TagTip = class extends this._TagTextStyle {
        tagName = "tip";
    }
    ;

    static TagUnit = class extends this._TagBaseAt {
        tagName = "unit";

        _getStripped(tag, text) {
            const [amount,unitSingle,unitPlural] = Renderer.splitTagByPipe(text);
            return isNaN(amount) ? unitSingle : Number(amount) > 1 ? (unitPlural || unitSingle.toPlural()) : unitSingle;
        }
    }
    ;

    static TagHit = class extends this._TagBaseAt {
        tagName = "h";

        _getStripped(tag, text) {
            return "Hit: ";
        }
    }
    ;

    static TagMiss = class extends this._TagBaseAt {
        tagName = "m";

        _getStripped(tag, text) {
            return "Miss: ";
        }
    }
    ;

    static TagAtk = class extends this._TagBaseAt {
        tagName = "atk";

        _getStripped(tag, text) {
            return Renderer.attackTagToFull(text);
        }
    }
    ;

    static TagHitYourSpellAttack = class extends this._TagBaseAt {
        tagName = "hitYourSpellAttack";

        _getStripped(tag, text) {
            const [displayText] = Renderer.splitTagByPipe(text);
            return displayText || "your spell attack modifier";
        }
    }
    ;

    static TagDc = class extends this._TagBaseAt {
        tagName = "dc";

        _getStripped(tag, text) {
            const [dcText,displayText] = Renderer.splitTagByPipe(text);
            return `DC ${displayText || dcText}`;
        }
    }
    ;

    static TagDcYourSpellSave = class extends this._TagBaseAt {
        tagName = "dcYourSpellSave";

        _getStripped(tag, text) {
            const [displayText] = Renderer.splitTagByPipe(text);
            return displayText || "your spell save DC";
        }
    }
    ;

    static _TagDiceFlavor = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const [rollText,displayText] = Renderer.splitTagByPipe(text);
            switch (tag) {
            case "@damage":
            case "@dice":
            case "@autodice":
                {
                    return displayText || rollText.replace(/;/g, "/");
                }
            case "@d20":
            case "@hit":
                {
                    return displayText || (()=>{
                        const n = Number(rollText);
                        if (!isNaN(n))
                            return `${n >= 0 ? "+" : ""}${n}`;
                        return rollText;
                    }
                    )();
                }
            case "@recharge":
                {
                    const asNum = Number(rollText || 6);
                    if (isNaN(asNum)) {
                        throw new Error(`Could not parse "${rollText}" as a number!`);
                    }
                    return `(Recharge ${asNum}${asNum < 6 ? `\u20136` : ""})`;
                }
            case "@chance":
                {
                    return displayText || `${rollText} percent`;
                }
            case "@ability":
                {
                    const [,rawScore] = rollText.split(" ").map(it=>it.trim().toLowerCase()).filter(Boolean);
                    const score = Number(rawScore) || 0;
                    return displayText || `${score} (${Parser.getAbilityModifier(score)})`;
                }
            case "@savingThrow":
            case "@skillCheck":
                {
                    return displayText || rollText;
                }
            }
            throw new Error(`Unhandled tag: ${tag}`);
        }
    }
    ;

    static TaChance = class extends this._TagDiceFlavor {
        tagName = "chance";
    }
    ;

    static TaD20 = class extends this._TagDiceFlavor {
        tagName = "d20";
    }
    ;

    static TaDamage = class extends this._TagDiceFlavor {
        tagName = "damage";
    }
    ;

    static TaDice = class extends this._TagDiceFlavor {
        tagName = "dice";
    }
    ;

    static TaAutodice = class extends this._TagDiceFlavor {
        tagName = "autodice";
    }
    ;

    static TaHit = class extends this._TagDiceFlavor {
        tagName = "hit";
    }
    ;

    static TaRecharge = class extends this._TagDiceFlavor {
        tagName = "recharge";
    }
    ;

    static TaAbility = class extends this._TagDiceFlavor {
        tagName = "ability";
    }
    ;

    static TaSavingThrow = class extends this._TagDiceFlavor {
        tagName = "savingThrow";
    }
    ;

    static TaSkillCheck = class extends this._TagDiceFlavor {
        tagName = "skillCheck";
    }
    ;

    static _TagDiceFlavorScaling = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const [,,addPerProgress,,displayText] = Renderer.splitTagByPipe(text);
            return displayText || addPerProgress;
        }
    }
    ;

    static TagScaledice = class extends this._TagDiceFlavorScaling {
        tagName = "scaledice";
    }
    ;

    static TagScaledamage = class extends this._TagDiceFlavorScaling {
        tagName = "scaledamage";
    }
    ;

    static TagCoinflip = class extends this._TagBaseAt {
        tagName = "coinflip";

        _getStripped(tag, text) {
            const [displayText] = Renderer.splitTagByPipe(text);
            return displayText || "flip a coin";
        }
    }
    ;

    static _TagPipedNoDisplayText = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts[0];
        }
    }
    ;

    static Tag5etools = class extends this._TagPipedNoDisplayText {
        tagName = "5etools";
    }
    ;

    static TagAdventure = class extends this._TagPipedNoDisplayText {
        tagName = "adventure";
    }
    ;

    static TagBook = class extends this._TagPipedNoDisplayText {
        tagName = "book";
    }
    ;

    static TagFilter = class extends this._TagPipedNoDisplayText {
        tagName = "filter";
    }
    ;

    static TagFootnote = class extends this._TagPipedNoDisplayText {
        tagName = "footnote";
    }
    ;

    static TagLink = class extends this._TagPipedNoDisplayText {
        tagName = "link";
    }
    ;

    static TagLoader = class extends this._TagPipedNoDisplayText {
        tagName = "loader";
    }
    ;

    static TagColor = class extends this._TagPipedNoDisplayText {
        tagName = "color";
    }
    ;

    static TagHighlight = class extends this._TagPipedNoDisplayText {
        tagName = "highlight";
    }
    ;

    static TagHelp = class extends this._TagPipedNoDisplayText {
        tagName = "help";
    }
    ;

    static _TagPipedDisplayTextThird = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 3 ? parts[2] : parts[0];
        }
    }
    ;

    static TagAction = class extends this._TagPipedDisplayTextThird {
        tagName = "action";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_ACTIONS;
    }
    ;

    static TagBackground = class extends this._TagPipedDisplayTextThird {
        tagName = "background";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_BACKGROUNDS;
    }
    ;

    static TagBoon = class extends this._TagPipedDisplayTextThird {
        tagName = "boon";
        defaultSource = Parser.SRC_MTF;
        page = UrlUtil.PG_CULTS_BOONS;
    }
    ;

    static TagCharoption = class extends this._TagPipedDisplayTextThird {
        tagName = "charoption";
        defaultSource = Parser.SRC_MOT;
        page = UrlUtil.PG_CHAR_CREATION_OPTIONS;
    }
    ;

    static TagClass = class extends this._TagPipedDisplayTextThird {
        tagName = "class";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CLASSES;
    }
    ;

    static TagCondition = class extends this._TagPipedDisplayTextThird {
        tagName = "condition";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CONDITIONS_DISEASES;
    }
    ;

    static TagCreature = class extends this._TagPipedDisplayTextThird {
        tagName = "creature";
        defaultSource = Parser.SRC_MM;
        page = UrlUtil.PG_BESTIARY;
    }
    ;

    static TagCult = class extends this._TagPipedDisplayTextThird {
        tagName = "cult";
        defaultSource = Parser.SRC_MTF;
        page = UrlUtil.PG_CULTS_BOONS;
    }
    ;

    static TagDeck = class extends this._TagPipedDisplayTextThird {
        tagName = "deck";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_DECKS;
    }
    ;

    static TagDisease = class extends this._TagPipedDisplayTextThird {
        tagName = "disease";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_CONDITIONS_DISEASES;
    }
    ;

    static TagFeat = class extends this._TagPipedDisplayTextThird {
        tagName = "feat";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_FEATS;
    }
    ;

    static TagHazard = class extends this._TagPipedDisplayTextThird {
        tagName = "hazard";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_TRAPS_HAZARDS;
    }
    ;

    static TagItem = class extends this._TagPipedDisplayTextThird {
        tagName = "item";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_ITEMS;
    }
    ;

    static TagItemMastery = class extends this._TagPipedDisplayTextThird {
        tagName = "itemMastery";
        defaultSource = VeCt.STR_GENERIC;
        page = "itemMastery";
    }
    ;

    static TagLanguage = class extends this._TagPipedDisplayTextThird {
        tagName = "language";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_LANGUAGES;
    }
    ;

    static TagLegroup = class extends this._TagPipedDisplayTextThird {
        tagName = "legroup";
        defaultSource = Parser.SRC_MM;
        page = "legendaryGroup";
    }
    ;

    static TagObject = class extends this._TagPipedDisplayTextThird {
        tagName = "object";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_OBJECTS;
    }
    ;

    static TagOptfeature = class extends this._TagPipedDisplayTextThird {
        tagName = "optfeature";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_OPT_FEATURES;
    }
    ;

    static TagPsionic = class extends this._TagPipedDisplayTextThird {
        tagName = "psionic";
        defaultSource = Parser.SRC_UATMC;
        page = UrlUtil.PG_PSIONICS;
    }
    ;

    static TagRace = class extends this._TagPipedDisplayTextThird {
        tagName = "race";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_RACES;
    }
    ;

    static TagRecipe = class extends this._TagPipedDisplayTextThird {
        tagName = "recipe";
        defaultSource = Parser.SRC_HF;
        page = UrlUtil.PG_RECIPES;
    }
    ;

    static TagReward = class extends this._TagPipedDisplayTextThird {
        tagName = "reward";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_REWARDS;
    }
    ;

    static TagVehicle = class extends this._TagPipedDisplayTextThird {
        tagName = "vehicle";
        defaultSource = Parser.SRC_GoS;
        page = UrlUtil.PG_VEHICLES;
    }
    ;

    static TagVehupgrade = class extends this._TagPipedDisplayTextThird {
        tagName = "vehupgrade";
        defaultSource = Parser.SRC_GoS;
        page = UrlUtil.PG_VEHICLES;
    }
    ;

    static TagSense = class extends this._TagPipedDisplayTextThird {
        tagName = "sense";
        defaultSource = Parser.SRC_PHB;
        page = "sense";
    }
    ;

    static TagSkill = class extends this._TagPipedDisplayTextThird {
        tagName = "skill";
        defaultSource = Parser.SRC_PHB;
        page = "skill";
    }
    ;

    static TagSpell = class extends this._TagPipedDisplayTextThird {
        tagName = "spell";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_SPELLS;
    }
    ;

    static TagStatus = class extends this._TagPipedDisplayTextThird {
        tagName = "status";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CONDITIONS_DISEASES;
    }
    ;

    static TagTable = class extends this._TagPipedDisplayTextThird {
        tagName = "table";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_TABLES;
    }
    ;

    static TagTrap = class extends this._TagPipedDisplayTextThird {
        tagName = "trap";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_TRAPS_HAZARDS;
    }
    ;

    static TagVariantrule = class extends this._TagPipedDisplayTextThird {
        tagName = "variantrule";
        defaultSource = Parser.SRC_DMG;
        page = UrlUtil.PG_VARIANTRULES;
    }
    ;

    static TagCite = class extends this._TagPipedDisplayTextThird {
        tagName = "cite";
        defaultSource = Parser.SRC_PHB;
        page = "citation";
    }
    ;

    static _TagPipedDisplayTextFourth = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 4 ? parts[3] : parts[0];
        }
    }
    ;

    static TagCard = class extends this._TagPipedDisplayTextFourth {
        tagName = "card";
        defaultSource = Parser.SRC_DMG;
        page = "card";
    }
    ;

    static TagDeity = class extends this._TagPipedDisplayTextFourth {
        tagName = "deity";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_DEITIES;
    }
    ;

    static _TagPipedDisplayTextSixth = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 6 ? parts[5] : parts[0];
        }
    }
    ;

    static TagClassFeature = class extends this._TagPipedDisplayTextSixth {
        tagName = "classFeature";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CLASSES;
    }
    ;

    static _TagPipedDisplayTextEight = class extends this._TagBaseAt {
        _getStripped(tag, text) {
            const parts = Renderer.splitTagByPipe(text);
            return parts.length >= 8 ? parts[7] : parts[0];
        }
    }
    ;

    static TagSubclassFeature = class extends this._TagPipedDisplayTextEight {
        tagName = "subclassFeature";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_CLASSES;
    }
    ;

    static TagQuickref = class extends this._TagBaseAt {
        tagName = "quickref";
        defaultSource = Parser.SRC_PHB;
        page = UrlUtil.PG_QUICKREF;

        _getStripped(tag, text) {
            const {name, displayText} = DataUtil.quickreference.unpackUid(text);
            return displayText || name;
        }
    }
    ;

    static TagArea = class extends this._TagBaseAt {
        tagName = "area";

        _getStripped(tag, text) {
            const [compactText,,flags] = Renderer.splitTagByPipe(text);

            return flags && flags.includes("x") ? compactText : `${flags && flags.includes("u") ? "A" : "a"}rea ${compactText}`;
        }

        _getMeta(tag, text) {
            const [compactText,areaId,flags] = Renderer.splitTagByPipe(text);

            const displayText = flags && flags.includes("x") ? compactText : `${flags && flags.includes("u") ? "A" : "a"}rea ${compactText}`;

            return {
                areaId,
                displayText,
            };
        }
    }
    ;

    static TagHomebrew = class extends this._TagBaseAt {
        tagName = "homebrew";

        _getStripped(tag, text) {
            const [newText,oldText] = Renderer.splitTagByPipe(text);
            if (newText && oldText) {
                return `${newText} [this is a homebrew addition, replacing the following: "${oldText}"]`;
            } else if (newText) {
                return `${newText} [this is a homebrew addition]`;
            } else if (oldText) {
                return `[the following text has been removed due to homebrew: ${oldText}]`;
            } else
                throw new Error(`Homebrew tag had neither old nor new text!`);
        }
    }
    ;

    static TagItemEntry = class extends this._TagBaseHash {
        tagName = "itemEntry";
        defaultSource = Parser.SRC_DMG;
    }
    ;

    static TAGS = [new this.TagBoldShort(), new this.TagBoldLong(), new this.TagItalicShort(), new this.TagItalicLong(), new this.TagStrikethroughShort(), new this.TagStrikethroughLong(), new this.TagUnderlineShort(), new this.TagUnderlineLong(), new this.TagSup(), new this.TagSub(), new this.TagKbd(), new this.TagCode(), new this.TagStyle(), new this.TagFont(),
    new this.TagComic(), new this.TagComicH1(), new this.TagComicH2(), new this.TagComicH3(), new this.TagComicH4(), new this.TagComicNote(),
    new this.TagNote(), new this.TagTip(),
    new this.TagUnit(),
    new this.TagHit(), new this.TagMiss(),
    new this.TagAtk(),
    new this.TagHitYourSpellAttack(),
    new this.TagDc(),
    new this.TagDcYourSpellSave(),
    new this.TaChance(), new this.TaD20(), new this.TaDamage(), new this.TaDice(), new this.TaAutodice(), new this.TaHit(), new this.TaRecharge(), new this.TaAbility(), new this.TaSavingThrow(), new this.TaSkillCheck(),
    new this.TagScaledice(), new this.TagScaledamage(),
    new this.TagCoinflip(),
    new this.Tag5etools(), new this.TagAdventure(), new this.TagBook(), new this.TagFilter(), new this.TagFootnote(), new this.TagLink(), new this.TagLoader(), new this.TagColor(), new this.TagHighlight(), new this.TagHelp(),
    new this.TagQuickref(),
    new this.TagArea(),
    new this.TagAction(), new this.TagBackground(), new this.TagBoon(), new this.TagCharoption(), new this.TagClass(), new this.TagCondition(), new this.TagCreature(), new this.TagCult(), new this.TagDeck(), new this.TagDisease(), new this.TagFeat(), new this.TagHazard(), new this.TagItem(), new this.TagItemMastery(), new this.TagLanguage(), new this.TagLegroup(), new this.TagObject(), new this.TagOptfeature(), new this.TagPsionic(), new this.TagRace(), new this.TagRecipe(), new this.TagReward(), new this.TagVehicle(), new this.TagVehupgrade(), new this.TagSense(), new this.TagSkill(), new this.TagSpell(), new this.TagStatus(), new this.TagTable(), new this.TagTrap(), new this.TagVariantrule(), new this.TagCite(),
    new this.TagCard(), new this.TagDeity(),
    new this.TagClassFeature({
        tagName: "classFeature"
    }),
    new this.TagSubclassFeature({
        tagName: "subclassFeature"
    }),
    new this.TagHomebrew(),
    new this.TagItemEntry(), ];

    static TAG_LOOKUP = {};

    static _init() {
        this.TAGS.forEach(tag=>{
            this.TAG_LOOKUP[tag.tag] = tag;
            this.TAG_LOOKUP[tag.tagName] = tag;
        }
        );

        return null;
    }

    static _ = this._init();

    static getPage(tag) {
        const tagInfo = this.TAG_LOOKUP[tag];
        return tagInfo?.page;
    }
}
;

Renderer.events = class {
    static handleClick_copyCode(evt, ele) {
        const $e = $(ele).parent().next("pre");
        MiscUtil.pCopyTextToClipboard($e.text());
        JqueryUtil.showCopiedEffect($e);
    }

    static handleClick_toggleCodeWrap(evt, ele) {
        const nxt = !StorageUtil.syncGet("rendererCodeWrap");
        StorageUtil.syncSet("rendererCodeWrap", nxt);
        const $btn = $(ele).toggleClass("active", nxt);
        const $e = $btn.parent().next("pre");
        $e.toggleClass("rd__pre-wrap", nxt);
    }

    static bindGeneric({element=document.body}={}) {
        const $ele = $(element).on("click", `[data-rd-data-embed-header]`, evt=>{
            Renderer.events.handleClick_dataEmbedHeader(evt, evt.currentTarget);
        }
        );

        Renderer.events._HEADER_TOGGLE_CLICK_SELECTORS.forEach(selector=>{
            $ele.on("click", selector, evt=>{
                Renderer.events.handleClick_headerToggleButton(evt, evt.currentTarget, {
                    selector
                });
            }
            );
        }
        );
    }

    static handleClick_dataEmbedHeader(evt, ele) {
        evt.stopPropagation();
        evt.preventDefault();

        const $ele = $(ele);
        $ele.find(".rd__data-embed-name").toggleVe();
        $ele.find(".rd__data-embed-toggle").text($ele.text().includes("+") ? "[\u2013]" : "[+]");
        $ele.closest("table").find("tbody").toggleVe();
    }

    static _HEADER_TOGGLE_CLICK_SELECTORS = [`[data-rd-h-toggle-button]`, `[data-rd-h-special-toggle-button]`, ];

    static handleClick_headerToggleButton(evt, ele, {selector=false}={}) {
        evt.stopPropagation();
        evt.preventDefault();

        const isShow = this._handleClick_headerToggleButton_doToggleEle(ele, {
            selector
        });

        if (!EventUtil.isCtrlMetaKey(evt))
            return;

        Renderer.events._HEADER_TOGGLE_CLICK_SELECTORS.forEach(selector=>{
            [...document.querySelectorAll(selector)].filter(eleOther=>eleOther !== ele).forEach(eleOther=>{
                Renderer.events._handleClick_headerToggleButton_doToggleEle(eleOther, {
                    selector,
                    force: isShow
                });
            }
            );
        }
        );
    }

    static _handleClick_headerToggleButton_doToggleEle(ele, {selector=false, force=null}={}) {
        const isShow = force != null ? force : ele.innerHTML.includes("+");

        let eleNxt = ele.closest(".rd__h").nextElementSibling;

        while (eleNxt) {
            if (eleNxt.classList.contains("float-clear")) {
                eleNxt = eleNxt.nextElementSibling;
                continue;
            }

            if (selector !== `[data-rd-h-special-toggle-button]`) {
                const eleToCheck = Renderer.events._handleClick_headerToggleButton_getEleToCheck(eleNxt);
                if (eleToCheck.classList.contains("rd__b-special") || (eleToCheck.classList.contains("rd__h") && !eleToCheck.classList.contains("rd__h--3")) || (eleToCheck.classList.contains("rd__b") && !eleToCheck.classList.contains("rd__b--3")))
                    break;
            }

            eleNxt.classList.toggle("rd__ele-toggled-hidden", !isShow);
            eleNxt = eleNxt.nextElementSibling;
        }

        ele.innerHTML = isShow ? "[\u2013]" : "[+]";

        return isShow;
    }

    static _handleClick_headerToggleButton_getEleToCheck(eleNxt) {
        if (eleNxt.type === 3)
            return eleNxt;
        if (!eleNxt.classList.contains("rd__b") || eleNxt.classList.contains("rd__b--3"))
            return eleNxt;
        const childNodes = [...eleNxt.childNodes].filter(it=>(it.type === 3 && (it.textContent || "").trim()) || it.type !== 3);
        if (childNodes.length !== 1)
            return eleNxt;
        if (childNodes[0].classList.contains("rd__b"))
            return Renderer.events._handleClick_headerToggleButton_getEleToCheck(childNodes[0]);
        return eleNxt;
    }

    static handleLoad_inlineStatblock(ele) {
        const observer = Renderer.utils.lazy.getCreateObserver({
            observerId: "inlineStatblock",
            fnOnObserve: Renderer.events._handleLoad_inlineStatblock_fnOnObserve.bind(Renderer.events),
        });

        observer.track(ele.parentNode);
    }

    static _handleLoad_inlineStatblock_fnOnObserve({entry}) {
        const ele = entry.target;

        const tag = ele.dataset.rdTag.uq();
        const page = ele.dataset.rdPage.uq();
        const source = ele.dataset.rdSource.uq();
        const name = ele.dataset.rdName.uq();
        const displayName = ele.dataset.rdDisplayName.uq();
        const hash = ele.dataset.rdHash.uq();
        const style = ele.dataset.rdStyle.uq();

        DataLoader.pCacheAndGet(page, Parser.getTagSource(tag, source), hash).then(toRender=>{
            const tr = ele.closest("tr");

            if (!toRender) {
                tr.innerHTML = `<td colspan="6"><i class="text-danger">Failed to load ${tag ? Renderer.get().render(`{@${tag} ${name}|${source}${displayName ? `|${displayName}` : ""}}`) : displayName || name}!</i></td>`;
                throw new Error(`Could not find tag: "${tag}" (page/prop: "${page}") hash: "${hash}"`);
            }

            const headerName = displayName || (name ?? toRender.name ?? (toRender.entries?.length ? toRender.entries?.[0]?.name : "(Unknown)"));

            const fnRender = Renderer.hover.getFnRenderCompact(page);
            const tbl = tr.closest("table");
            const nxt = e_({
                outer: Renderer.utils.getEmbeddedDataHeader(headerName, style) + fnRender(toRender, {
                    isEmbeddedEntity: true
                }) + Renderer.utils.getEmbeddedDataFooter(),
            });
            tbl.parentNode.replaceChild(nxt, tbl, );

            const nxtTgt = nxt.querySelector(`[data-rd-embedded-data-render-target="true"]`);

            const fnBind = Renderer.hover.getFnBindListenersCompact(page);
            if (fnBind)
                fnBind(toRender, nxtTgt);
        }
        );
    }
}
;

Renderer.feat = class {
    static _mergeAbilityIncrease_getListItemText(abilityObj) {
        return Renderer.feat._mergeAbilityIncrease_getText(abilityObj);
    }

    static _mergeAbilityIncrease_getListItemItem(abilityObj) {
        return {
            type: "item",
            name: "Ability Score Increase.",
            entry: Renderer.feat._mergeAbilityIncrease_getText(abilityObj),
        };
    }

    static _mergeAbilityIncrease_getText(abilityObj) {
        const maxScore = abilityObj.max ?? 20;

        if (!abilityObj.choose) {
            return Object.keys(abilityObj).filter(k=>k !== "max").map(ab=>`Increase your ${Parser.attAbvToFull(ab)} score by ${abilityObj[ab]}, to a maximum of ${maxScore}.`).join(" ");
        }

        if (abilityObj.choose.from.length === 6) {
            return abilityObj.choose.entry ? Renderer.get().render(abilityObj.choose.entry) : `Increase one ability score of your choice by ${abilityObj.choose.amount ?? 1}, to a maximum of ${maxScore}.`;
        }

        const abbChoicesText = abilityObj.choose.from.map(it=>Parser.attAbvToFull(it)).joinConjunct(", ", " or ");
        return `Increase your ${abbChoicesText} by ${abilityObj.choose.amount ?? 1}, to a maximum of ${maxScore}.`;
    }

    static initFullEntries(feat) {
        if (!feat.ability || feat._fullEntries || !feat.ability.length)
            return;

        const abilsToDisplay = feat.ability.filter(it=>!it.hidden);
        if (!abilsToDisplay.length)
            return;

        Renderer.utils.initFullEntries_(feat);

        const targetList = feat._fullEntries.find(e=>e.type === "list");

        if (targetList && targetList.items.every(it=>it.type === "item")) {
            abilsToDisplay.forEach(abilObj=>targetList.items.unshift(Renderer.feat._mergeAbilityIncrease_getListItemItem(abilObj)));
            return;
        }

        if (targetList) {
            abilsToDisplay.forEach(abilObj=>targetList.items.unshift(Renderer.feat._mergeAbilityIncrease_getListItemText(abilObj)));
            return;
        }

        abilsToDisplay.forEach(abilObj=>feat._fullEntries.unshift(Renderer.feat._mergeAbilityIncrease_getListItemText(abilObj)));

        setTimeout(()=>{
            throw new Error(`Could not find object of type "list" in "entries" for feat "${feat.name}" from source "${feat.source}" when merging ability scores! Reformat the feat to include a "list"-type entry.`);
        }
        , 1);
    }

    static getFeatRendereableEntriesMeta(ent) {
        Renderer.feat.initFullEntries(ent);
        return {
            entryMain: {
                entries: ent._fullEntries || ent.entries
            },
        };
    }

    static getJoinedCategoryPrerequisites(category, rdPrereqs) {
        const ptCategory = category ? `${category.toTitleCase()} Feat` : "";

        return ptCategory && rdPrereqs ? `${ptCategory} (${rdPrereqs})` : (ptCategory || rdPrereqs);
    }

    static getCompactRenderedString(feat, opts) {
        opts = opts || {};

        const renderer = Renderer.get().setFirstSection(true);
        const renderStack = [];

        const ptCategoryPrerequisite = Renderer.feat.getJoinedCategoryPrerequisites(feat.category, Renderer.utils.prerequisite.getHtml(feat.prerequisite), );
        const ptRepeatable = Renderer.utils.getRepeatableHtml(feat);

        renderStack.push(`
			${Renderer.utils.getExcludedTr({
            entity: feat,
            dataProp: "feat",
            page: UrlUtil.PG_FEATS
        })}
			${opts.isSkipNameRow ? "" : Renderer.utils.getNameTr(feat, {
            page: UrlUtil.PG_FEATS
        })}
			<tr class="text"><td colspan="6" class="text">
			${ptCategoryPrerequisite ? `<p>${ptCategoryPrerequisite}</p>` : ""}
			${ptRepeatable ? `<p>${ptRepeatable}</p>` : ""}
		`);
        renderer.recursiveRender(Renderer.feat.getFeatRendereableEntriesMeta(feat)?.entryMain, renderStack, {
            depth: 2
        });
        renderStack.push(`</td></tr>`);

        return renderStack.join("");
    }

    static pGetFluff(feat) {
        return Renderer.utils.pGetFluff({
            entity: feat,
            fnGetFluffData: DataUtil.featFluff.loadJSON.bind(DataUtil.featFluff),
            fluffProp: "featFluff",
        });
    }
}
;

Renderer.class = class {
    static getCompactRenderedString(cls) {
        if (cls.__prop === "subclass")
            return Renderer.subclass.getCompactRenderedString(cls);

        const clsEntry = {
            type: "section",
            name: cls.name,
            source: cls.source,
            page: cls.page,
            entries: MiscUtil.copyFast((cls.classFeatures || []).flat()),
        };

        return Renderer.hover.getGenericCompactRenderedString(clsEntry);
    }

    static getHitDiceEntry(clsHd) {
        return clsHd ? {
            toRoll: `${clsHd.number}d${clsHd.faces}`,
            rollable: true
        } : null;
    }
    static getHitPointsAtFirstLevel(clsHd) {
        return clsHd ? `${clsHd.number * clsHd.faces} + your Constitution modifier` : null;
    }
    static getHitPointsAtHigherLevels(className, clsHd, hdEntry) {
        return className && clsHd && hdEntry ? `${Renderer.getEntryDice(hdEntry, "Hit die")} (or ${((clsHd.number * clsHd.faces) / 2 + 1)}) + your Constitution modifier per ${className} level after 1st` : null;
    }

    static getRenderedArmorProfs(armorProfs) {
        return armorProfs.map(a=>Renderer.get().render(a.full ? a.full : a === "light" || a === "medium" || a === "heavy" ? `{@filter ${a} armor|items|type=${a} armor}` : a)).join(", ");
    }
    static getRenderedWeaponProfs(weaponProfs) {
        return weaponProfs.map(w=>Renderer.get().render(w === "simple" || w === "martial" ? `{@filter ${w} weapons|items|type=${w} weapon}` : w.optional ? `<span class="help help--hover" title="Optional Proficiency">${w.proficiency}</span>` : w)).join(", ");
    }
    static getRenderedToolProfs(toolProfs) {
        return toolProfs.map(it=>Renderer.get().render(it)).join(", ");
    }
    static getRenderedSkillProfs(skills) {
        return `${Parser.skillProficienciesToFull(skills).uppercaseFirst()}.`;
    }

    static getWalkerFilterDereferencedFeatures() {
        return MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
            isAllowDeleteObjects: true,
            isDepthFirst: true,
        });
    }

    static mutFilterDereferencedClassFeatures({walker, cpyCls, pageFilter, filterValues, isUseSubclassSources=false, }, ) {
        walker = walker || Renderer.class.getWalkerFilterDereferencedFeatures();

        cpyCls.classFeatures = cpyCls.classFeatures.map((lvlFeatures,ixLvl)=>{
            return walker.walk(lvlFeatures, {
                object: (obj)=>{
                    if (!obj.source)
                        return obj;
                    const fText = obj.isClassFeatureVariant ? {
                        isClassFeatureVariant: true
                    } : null;

                    const isDisplay = [obj.source, ...(obj.otherSources || []).map(it=>it.source)].some(src=>pageFilter.filterBox.toDisplayByFilters(filterValues, ...[{
                        filter: pageFilter.sourceFilter,
                        value: isUseSubclassSources && src === cpyCls.source ? pageFilter.getActiveSource(filterValues) : src,
                    }, pageFilter.levelFilter ? {
                        filter: pageFilter.levelFilter,
                        value: ixLvl + 1,
                    } : null, {
                        filter: pageFilter.optionsFilter,
                        value: fText,
                    }, ].filter(Boolean), ));

                    return isDisplay ? obj : null;
                }
                ,
                array: (arr)=>{
                    return arr.filter(it=>it != null);
                }
                ,
            }, );
        }
        );
    }

    static mutFilterDereferencedSubclassFeatures({walker, cpySc, pageFilter, filterValues, }, ) {
        walker = walker || Renderer.class.getWalkerFilterDereferencedFeatures();

        cpySc.subclassFeatures = cpySc.subclassFeatures.map(lvlFeatures=>{
            const level = CollectionUtil.bfs(lvlFeatures, {
                prop: "level"
            });

            return walker.walk(lvlFeatures, {
                object: (obj)=>{
                    if (obj.entries && !obj.entries.length)
                        return null;
                    if (!obj.source)
                        return obj;
                    const fText = obj.isClassFeatureVariant ? {
                        isClassFeatureVariant: true
                    } : null;

                    const isDisplay = [obj.source, ...(obj.otherSources || []).map(it=>it.source)].some(src=>pageFilter.filterBox.toDisplayByFilters(filterValues, ...[{
                        filter: pageFilter.sourceFilter,
                        value: src,
                    }, pageFilter.levelFilter ? {
                        filter: pageFilter.levelFilter,
                        value: level,
                    } : null, {
                        filter: pageFilter.optionsFilter,
                        value: fText,
                    }, ].filter(Boolean), ));

                    return isDisplay ? obj : null;
                }
                ,
                array: (arr)=>{
                    return arr.filter(it=>it != null);
                }
                ,
            }, );
        }
        );
    }
}
;

Renderer.subclass = class {
    static getCompactRenderedString(sc) {
        const scEntry = {
            type: "section",
            name: sc.name,
            source: sc.source,
            page: sc.page,
            entries: MiscUtil.copyFast((sc.subclassFeatures || []).flat()),
        };

        return Renderer.hover.getGenericCompactRenderedString(scEntry);
    }
}
;

Renderer.spell = class {
    static getCompactRenderedString(spell, opts) {
        opts = opts || {};

        const renderer = Renderer.get();
        const renderStack = [];

        renderStack.push(`
			${Renderer.utils.getExcludedTr({
            entity: spell,
            dataProp: "spell",
            page: UrlUtil.PG_SPELLS
        })}
			${Renderer.utils.getNameTr(spell, {
            page: UrlUtil.PG_SPELLS,
            isEmbeddedEntity: opts.isEmbeddedEntity
        })}
			<tr><td colspan="6">
				<table class="w-100 summary stripe-even-table">
					<tr>
						<th colspan="1">Level</th>
						<th colspan="1">School</th>
						<th colspan="2">Casting Time</th>
						<th colspan="2">Range</th>
					</tr>
					<tr>
						<td colspan="1">${Parser.spLevelToFull(spell.level)}${Parser.spMetaToFull(spell.meta)}</td>
						<td colspan="1">${Parser.spSchoolAndSubschoolsAbvsToFull(spell.school, spell.subschools)}</td>
						<td colspan="2">${Parser.spTimeListToFull(spell.time)}</td>
						<td colspan="2">${Parser.spRangeToFull(spell.range)}</td>
					</tr>
					<tr>
						<th colspan="4">Components</th>
						<th colspan="2">Duration</th>
					</tr>
					<tr>
						<td colspan="4">${Parser.spComponentsToFull(spell.components, spell.level)}</td>
						<td colspan="2">${Parser.spDurationToFull(spell.duration)}</td>
					</tr>
				</table>
			</td></tr>
		`);

        renderStack.push(`<tr class="text"><td colspan="6" class="text">`);
        const entryList = {
            type: "entries",
            entries: spell.entries
        };
        renderer.recursiveRender(entryList, renderStack, {
            depth: 1
        });
        if (spell.entriesHigherLevel) {
            const higherLevelsEntryList = {
                type: "entries",
                entries: spell.entriesHigherLevel
            };
            renderer.recursiveRender(higherLevelsEntryList, renderStack, {
                depth: 2
            });
        }
        const fromClassList = Renderer.spell.getCombinedClasses(spell, "fromClassList");
        if (fromClassList.length) {
            const [current] = Parser.spClassesToCurrentAndLegacy(fromClassList);
            renderStack.push(`<div><span class="bold">Classes: </span>${Parser.spMainClassesToFull(current)}</div>`);
        }
        renderStack.push(`</td></tr>`);

        return renderStack.join("");
    }

    static _SpellSourceManager = class {
        _cache = null;

        populate({brew, isForce=false}) {
            if (this._cache && !isForce)
                return;

            this._cache = {
                classes: {},

                groups: {},

                races: {},
                backgrounds: {},
                feats: {},
                optionalfeatures: {},
            };

            (brew.class || []).forEach(c=>{
                c.source = c.source || Parser.SRC_PHB;

                (c.classSpells || []).forEach(itm=>{
                    this._populate_fromClass_classSubclass({
                        itm,
                        className: c.name,
                        classSource: c.source,
                    });

                    this._populate_fromClass_group({
                        itm,
                        className: c.name,
                        classSource: c.source,
                    });
                }
                );
            }
            );

            (brew.subclass || []).forEach(sc=>{
                sc.classSource = sc.classSource || Parser.SRC_PHB;
                sc.shortName = sc.shortName || sc.name;
                sc.source = sc.source || sc.classSource;

                (sc.subclassSpells || []).forEach(itm=>{
                    this._populate_fromClass_classSubclass({
                        itm,
                        className: sc.className,
                        classSource: sc.classSource,
                        subclassShortName: sc.shortName,
                        subclassName: sc.name,
                        subclassSource: sc.source,
                    });

                    this._populate_fromClass_group({
                        itm,
                        className: sc.className,
                        classSource: sc.classSource,
                        subclassShortName: sc.shortName,
                        subclassName: sc.name,
                        subclassSource: sc.source,
                    });
                }
                );

                Object.entries(sc.subSubclassSpells || {}).forEach(([subSubclassName,arr])=>{
                    arr.forEach(itm=>{
                        this._populate_fromClass_classSubclass({
                            itm,
                            className: sc.className,
                            classSource: sc.classSource,
                            subclassShortName: sc.shortName,
                            subclassName: sc.name,
                            subclassSource: sc.source,
                            subSubclassName,
                        });

                        this._populate_fromClass_group({
                            itm,
                            className: sc.className,
                            classSource: sc.classSource,
                            subclassShortName: sc.shortName,
                            subclassName: sc.name,
                            subclassSource: sc.source,
                            subSubclassName,
                        });
                    }
                    );
                }
                );
            }
            );

            (brew.spellList || []).forEach(spellList=>this._populate_fromGroup_group({
                spellList
            }));
        }

        _populate_fromClass_classSubclass({itm, className, classSource, subclassShortName, subclassName, subclassSource, subSubclassName, }, ) {
            if (itm.groupName)
                return;

            if (itm.className) {
                return this._populate_fromClass_doAdd({
                    tgt: MiscUtil.getOrSet(this._cache.classes, "class", (itm.classSource || Parser.SRC_PHB).toLowerCase(), itm.className.toLowerCase(), {}, ),
                    className,
                    classSource,
                    subclassShortName,
                    subclassName,
                    subclassSource,
                    subSubclassName,
                });
            }

            let[name,source] = `${itm}`.toLowerCase().split("|");
            source = source || Parser.SRC_PHB.toLowerCase();

            this._populate_fromClass_doAdd({
                tgt: MiscUtil.getOrSet(this._cache.classes, "spell", source, name, {
                    fromClassList: [],
                    fromSubclass: []
                }, ),
                className,
                classSource,
                subclassShortName,
                subclassName,
                subclassSource,
                subSubclassName,
            });
        }

        _populate_fromClass_doAdd({tgt, className, classSource, subclassShortName, subclassName, subclassSource, subSubclassName, schools, }, ) {
            if (subclassShortName) {
                const toAdd = {
                    class: {
                        name: className,
                        source: classSource
                    },
                    subclass: {
                        name: subclassName || subclassShortName,
                        shortName: subclassShortName,
                        source: subclassSource
                    },
                };
                if (subSubclassName)
                    toAdd.subclass.subSubclass = subSubclassName;
                if (schools)
                    toAdd.schools = schools;

                tgt.fromSubclass = tgt.fromSubclass || [];
                tgt.fromSubclass.push(toAdd);
                return;
            }

            const toAdd = {
                name: className,
                source: classSource
            };
            if (schools)
                toAdd.schools = schools;

            tgt.fromClassList = tgt.fromClassList || [];
            tgt.fromClassList.push(toAdd);
        }

        _populate_fromClass_group({itm, className, classSource, subclassShortName, subclassName, subclassSource, subSubclassName, }, ) {
            if (!itm.groupName)
                return;

            return this._populate_fromClass_doAdd({
                tgt: MiscUtil.getOrSet(this._cache.classes, "group", (itm.groupSource || Parser.SRC_PHB).toLowerCase(), itm.groupName.toLowerCase(), {}, ),
                className,
                classSource,
                subclassShortName,
                subclassName,
                subclassSource,
                subSubclassName,
                schools: itm.spellSchools,
            });
        }

        _populate_fromGroup_group({spellList, }, ) {
            const spellListSourceLower = (spellList.source || "").toLowerCase();
            const spellListNameLower = (spellList.name || "").toLowerCase();

            spellList.spells.forEach(spell=>{
                if (typeof spell === "string") {
                    const {name, source} = DataUtil.proxy.unpackUid("spell", spell, "spell", {
                        isLower: true
                    });
                    return MiscUtil.set(this._cache.groups, "spell", source, name, spellListSourceLower, spellListNameLower, {
                        name: spellList.name,
                        source: spellList.source
                    });
                }

                throw new Error(`Grouping spells based on other spell lists is not yet supported!`);
            }
            );
        }

        mutateSpell({spell: sp, lowName, lowSource}) {
            lowName = lowName || sp.name.toLowerCase();
            lowSource = lowSource || sp.source.toLowerCase();

            this._mutateSpell_brewGeneric({
                sp,
                lowName,
                lowSource,
                propSpell: "races",
                prop: "race"
            });
            this._mutateSpell_brewGeneric({
                sp,
                lowName,
                lowSource,
                propSpell: "backgrounds",
                prop: "background"
            });
            this._mutateSpell_brewGeneric({
                sp,
                lowName,
                lowSource,
                propSpell: "feats",
                prop: "feat"
            });
            this._mutateSpell_brewGeneric({
                sp,
                lowName,
                lowSource,
                propSpell: "optionalfeatures",
                prop: "optionalfeature"
            });
            this._mutateSpell_brewGroup({
                sp,
                lowName,
                lowSource
            });
            this._mutateSpell_brewClassesSubclasses({
                sp,
                lowName,
                lowSource
            });
        }

        _mutateSpell_brewClassesSubclasses({sp, lowName, lowSource}) {
            if (!this._cache?.classes)
                return;

            if (this._cache.classes.spell?.[lowSource]?.[lowName]?.fromClassList?.length) {
                sp._tmpClasses.fromClassList = sp._tmpClasses.fromClassList || [];
                sp._tmpClasses.fromClassList.push(...this._cache.classes.spell[lowSource][lowName].fromClassList);
            }

            if (this._cache.classes.spell?.[lowSource]?.[lowName]?.fromSubclass?.length) {
                sp._tmpClasses.fromSubclass = sp._tmpClasses.fromSubclass || [];
                sp._tmpClasses.fromSubclass.push(...this._cache.classes.spell[lowSource][lowName].fromSubclass);
            }

            if (this._cache.classes.class && sp.classes?.fromClassList) {
                (sp._tmpClasses = sp._tmpClasses || {}).fromClassList = sp._tmpClasses.fromClassList || [];

                outer: for (const srcLower in this._cache.classes.class) {
                    const searchForClasses = this._cache.classes.class[srcLower];

                    for (const clsLowName in searchForClasses) {
                        const spellHasClass = sp.classes?.fromClassList?.some(cls=>(cls.source || "").toLowerCase() === srcLower && cls.name.toLowerCase() === clsLowName);
                        if (!spellHasClass)
                            continue;

                        const fromDetails = searchForClasses[clsLowName];

                        if (fromDetails.fromClassList) {
                            sp._tmpClasses.fromClassList.push(...this._mutateSpell_getListFilteredBySchool({
                                sp,
                                arr: fromDetails.fromClassList
                            }));
                        }

                        if (fromDetails.fromSubclass) {
                            sp._tmpClasses.fromSubclass = sp._tmpClasses.fromSubclass || [];
                            sp._tmpClasses.fromSubclass.push(...this._mutateSpell_getListFilteredBySchool({
                                sp,
                                arr: fromDetails.fromSubclass
                            }));
                        }

                        break outer;
                    }
                }
            }

            if (this._cache.classes.group && (sp.groups?.length || sp._tmpGroups?.length)) {
                const groups = Renderer.spell.getCombinedGeneric(sp, {
                    propSpell: "groups"
                });

                (sp._tmpClasses = sp._tmpClasses || {}).fromClassList = sp._tmpClasses.fromClassList || [];

                outer: for (const srcLower in this._cache.classes.group) {
                    const searchForGroups = this._cache.classes.group[srcLower];

                    for (const groupLowName in searchForGroups) {
                        const spellHasGroup = groups?.some(grp=>(grp.source || "").toLowerCase() === srcLower && grp.name.toLowerCase() === groupLowName);
                        if (!spellHasGroup)
                            continue;

                        const fromDetails = searchForGroups[groupLowName];

                        if (fromDetails.fromClassList) {
                            sp._tmpClasses.fromClassList.push(...this._mutateSpell_getListFilteredBySchool({
                                sp,
                                arr: fromDetails.fromClassList
                            }));
                        }

                        if (fromDetails.fromSubclass) {
                            sp._tmpClasses.fromSubclass = sp._tmpClasses.fromSubclass || [];
                            sp._tmpClasses.fromSubclass.push(...this._mutateSpell_getListFilteredBySchool({
                                sp,
                                arr: fromDetails.fromSubclass
                            }));
                        }

                        break outer;
                    }
                }
            }
        }

        _mutateSpell_getListFilteredBySchool({arr, sp}) {
            return arr.filter(it=>{
                if (!it.schools)
                    return true;
                return it.schools.includes(sp.school);
            }
            ).map(it=>{
                if (!it.schools)
                    return it;
                const out = MiscUtil.copyFast(it);
                delete it.schools;
                return it;
            }
            );
        }

        _mutateSpell_brewGeneric({sp, lowName, lowSource, propSpell, prop}) {
            if (!this._cache?.[propSpell])
                return;

            const propTmp = `_tmp${propSpell.uppercaseFirst()}`;

            if (this._cache[propSpell]?.spell?.[lowSource]?.[lowName]?.length) {
                (sp[propTmp] = sp[propTmp] || []).push(...this._cache[propSpell].spell[lowSource][lowName]);
            }

            if (this._cache?.[propSpell]?.[prop] && sp[propSpell]) {
                sp[propTmp] = sp[propTmp] || [];

                outer: for (const srcLower in this._cache[propSpell][prop]) {
                    const searchForExisting = this._cache[propSpell][prop][srcLower];

                    for (const lowName in searchForExisting) {
                        const spellHasEnt = sp[propSpell].some(it=>(it.source || "").toLowerCase() === srcLower && it.name.toLowerCase() === lowName);
                        if (!spellHasEnt)
                            continue;

                        const fromDetails = searchForExisting[lowName];

                        sp[propTmp].push(...fromDetails);

                        break outer;
                    }
                }
            }
        }

        _mutateSpell_brewGroup({sp, lowName, lowSource}) {
            if (!this._cache?.groups)
                return;

            if (this._cache.groups.spell?.[lowSource]?.[lowName]) {
                Object.values(this._cache.groups.spell[lowSource][lowName]).forEach(bySource=>{
                    Object.values(bySource).forEach(byName=>{
                        sp._tmpGroups.push(byName);
                    }
                    );
                }
                );
            }

        }
    }
    ;

    static populatePrereleaseLookup(brew, {isForce=false}={}) {
        Renderer.spell._spellSourceManagerPrerelease.populate({
            brew,
            isForce
        });
    }

    static populateBrewLookup(brew, {isForce=false}={}) {
        Renderer.spell._spellSourceManagerBrew.populate({
            brew,
            isForce
        });
    }

    static prePopulateHover(data) {
        (data.spell || []).forEach(sp=>Renderer.spell.initBrewSources(sp));
    }

    static prePopulateHoverPrerelease(data) {
        Renderer.spell.populatePrereleaseLookup(data);
    }

    static prePopulateHoverBrew(data) {
        Renderer.spell.populateBrewLookup(data);
    }

    static _BREW_SOURCES_TMP_PROPS = ["_tmpSourcesInit", "_tmpClasses", "_tmpRaces", "_tmpBackgrounds", "_tmpFeats", "_tmpOptionalfeatures", "_tmpGroups", ];
    static uninitBrewSources(sp) {
        Renderer.spell._BREW_SOURCES_TMP_PROPS.forEach(prop=>delete sp[prop]);
    }

    static initBrewSources(sp) {
        if (sp._tmpSourcesInit)
            return;
        sp._tmpSourcesInit = true;

        sp._tmpClasses = {};
        sp._tmpRaces = [];
        sp._tmpBackgrounds = [];
        sp._tmpFeats = [];
        sp._tmpOptionalfeatures = [];
        sp._tmpGroups = [];

        const lowName = sp.name.toLowerCase();
        const lowSource = sp.source.toLowerCase();

        for (const manager of [Renderer.spell._spellSourceManagerPrerelease, Renderer.spell._spellSourceManagerBrew]) {
            manager.mutateSpell({
                spell: sp,
                lowName,
                lowSource
            });
        }
    }

    static getCombinedClasses(sp, prop) {
        return [...((sp.classes || {})[prop] || []), ...((sp._tmpClasses || {})[prop] || []), ].filter(it=>{
            if (!ExcludeUtil.isInitialised)
                return true;

            switch (prop) {
            case "fromClassList":
            case "fromClassListVariant":
                {
                    const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](it);
                    if (ExcludeUtil.isExcluded(hash, "class", it.source, {
                        isNoCount: true
                    }))
                        return false;

                    if (prop !== "fromClassListVariant")
                        return true;
                    if (it.definedInSource)
                        return !ExcludeUtil.isExcluded("*", "classFeature", it.definedInSource, {
                            isNoCount: true
                        });

                    return true;
                }
            case "fromSubclass":
            case "fromSubclassVariant":
                {
                    const hash = UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
                        name: it.subclass.name,
                        shortName: it.subclass.shortName,
                        source: it.subclass.source,
                        className: it.class.name,
                        classSource: it.class.source,
                    });

                    if (prop !== "fromSubclassVariant")
                        return !ExcludeUtil.isExcluded(hash, "subclass", it.subclass.source, {
                            isNoCount: true
                        });
                    if (it.class.definedInSource)
                        return !Renderer.spell.isExcludedSubclassVariantSource({
                            classDefinedInSource: it.class.definedInSource
                        });

                    return true;
                }
            default:
                throw new Error(`Unhandled prop "${prop}"`);
            }
        }
        );
    }

    static isExcludedSubclassVariantSource({classDefinedInSource, subclassDefinedInSource}) {
        return (classDefinedInSource != null && ExcludeUtil.isExcluded("*", "classFeature", classDefinedInSource, {
            isNoCount: true
        })) || (subclassDefinedInSource != null && ExcludeUtil.isExcluded("*", "subclassFeature", subclassDefinedInSource, {
            isNoCount: true
        }));
    }

    static getCombinedGeneric(sp, {propSpell, prop}) {
        const propSpellTmp = `_tmp${propSpell.uppercaseFirst()}`;
        return [...(sp[propSpell] || []), ...(sp[propSpellTmp] || []), ].filter(it=>{
            if (!ExcludeUtil.isInitialised || !prop)
                return true;
            const hash = UrlUtil.URL_TO_HASH_BUILDER[prop](it);
            return !ExcludeUtil.isExcluded(hash, prop, it.source, {
                isNoCount: true
            });
        }
        ).sort(SortUtil.ascSortGenericEntity.bind(SortUtil));
    }

    static pGetFluff(sp) {
        return Renderer.utils.pGetFluff({
            entity: sp,
            fluffBaseUrl: `data/spells/`,
            fluffProp: "spellFluff",
        });
    }
}
;

Renderer.spell._spellSourceManagerPrerelease = new Renderer.spell._SpellSourceManager();
Renderer.spell._spellSourceManagerBrew = new Renderer.spell._SpellSourceManager();

Renderer.condition = class {
    static getCompactRenderedString(cond) {
        const renderer = Renderer.get();
        const renderStack = [];

        renderStack.push(`
			${Renderer.utils.getExcludedTr({
            entity: cond,
            dataProp: cond.__prop || cond._type,
            page: UrlUtil.PG_CONDITIONS_DISEASES
        })}
			${Renderer.utils.getNameTr(cond, {
            page: UrlUtil.PG_CONDITIONS_DISEASES
        })}
			<tr class="text"><td colspan="6">
		`);
        renderer.recursiveRender({
            entries: cond.entries
        }, renderStack);
        renderStack.push(`</td></tr>`);

        return renderStack.join("");
    }

    static pGetFluff(it) {
        return Renderer.utils.pGetFluff({
            entity: it,
            fnGetFluffData: it.__prop === "condition" ? DataUtil.conditionFluff.loadJSON.bind(DataUtil.conditionFluff) : null,
            fluffProp: it.__prop === "condition" ? "conditionFluff" : "diseaseFluff",
        });
    }
}
;

Renderer.background = class {
    static getCompactRenderedString(bg) {
        return Renderer.generic.getCompactRenderedString(bg, {
            dataProp: "background",
            page: UrlUtil.PG_BACKGROUNDS,
        }, );
    }

    static pGetFluff(bg) {
        return Renderer.utils.pGetFluff({
            entity: bg,
            fnGetFluffData: DataUtil.backgroundFluff.loadJSON.bind(DataUtil.backgroundFluff),
            fluffProp: "backgroundFluff",
        });
    }
}
;

Renderer.backgroundFeature = class {
    static getCompactRenderedString(ent) {
        return Renderer.generic.getCompactRenderedString(ent);
    }
}
;

Renderer.optionalfeature = class {
    static getListPrerequisiteLevelText(prerequisites) {
        if (!prerequisites || !prerequisites.some(it=>it.level))
            return "\u2014";
        const levelPart = prerequisites.find(it=>it.level).level;
        return levelPart.level || levelPart;
    }

    static getPreviouslyPrintedEntry(ent) {
        if (!ent.previousVersion)
            return null;
        return `{@i An earlier version of this ${ent.featureType.map(t=>Parser.optFeatureTypeToFull(t)).join("/")} is available in }${Parser.sourceJsonToFull(ent.previousVersion.source)} {@i as {@optfeature ${ent.previousVersion.name}|${ent.previousVersion.source}}.}`;
    }

    static getTypeEntry(ent) {
        return `{@note Type: ${Renderer.optionalfeature.getTypeText(ent)}}`;
    }

    static getCostEntry(ent) {
        if (!ent.consumes?.name)
            return null;

        const ptPrefix = "Cost: ";
        const tksUnit = ent.consumes.name.split(" ").map(it=>it.trim()).filter(Boolean);
        tksUnit.last(tksUnit.last()[ent.consumes.amount != null && ent.consumes.amount !== 1 ? "toPlural" : "toString"]());
        const ptUnit = ` ${tksUnit.join(" ")}`;

        if (ent.consumes?.amountMin != null && ent.consumes?.amountMax != null)
            return `{@i ${ptPrefix}${ent.consumes.amountMin}\u2013${ent.consumes.amountMax}${ptUnit}}`;
        return `{@i ${ptPrefix}${ent.consumes.amount ?? 1}${ptUnit}}`;
    }

    static getPreviouslyPrintedText(ent) {
        const entry = Renderer.optionalfeature.getPreviouslyPrintedEntry(ent);
        if (!entry)
            return "";
        return `<tr><td colspan="6"><p class="mt-2">${Renderer.get().render(entry)}</p></td></tr>`;
    }

    static getTypeText(ent) {
        const commonPrefix = ent.featureType.length > 1 ? MiscUtil.findCommonPrefix(ent.featureType.map(fs=>Parser.optFeatureTypeToFull(fs)), {
            isRespectWordBoundaries: true
        }) : "";

        return [commonPrefix.trim() || null, ent.featureType.map(ft=>Parser.optFeatureTypeToFull(ft).substring(commonPrefix.length)).join("/"), ].filter(Boolean).join(" ");
    }

    static getCostHtml(ent) {
        const entry = Renderer.optionalfeature.getCostEntry(ent);
        if (!entry)
            return "";

        return Renderer.get().render(entry);
    }

    static getCompactRenderedString(ent) {
        const ptCost = Renderer.optionalfeature.getCostHtml(ent);
        return `
			${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "optionalfeature",
            page: UrlUtil.PG_OPT_FEATURES
        })}
			${Renderer.utils.getNameTr(ent, {
            page: UrlUtil.PG_OPT_FEATURES
        })}
			<tr class="text"><td colspan="6">
			${ent.prerequisite ? `<p>${Renderer.utils.prerequisite.getHtml(ent.prerequisite)}</p>` : ""}
			${ptCost ? `<p>${ptCost}</p>` : ""}
			${Renderer.get().render({
            entries: ent.entries
        }, 1)}
			</td></tr>
			${Renderer.optionalfeature.getPreviouslyPrintedText(ent)}
			<tr><td colspan="6"><p>${Renderer.get().render(Renderer.optionalfeature.getTypeEntry(ent))}</p></td></tr>
		`;
    }
}
;

Renderer.reward = class {
    static getRewardRenderableEntriesMeta(ent) {
        const ptSubtitle = [(ent.type || "").toTitleCase(), ent.rarity ? ent.rarity.toTitleCase() : "", ].filter(Boolean).join(", ");

        return {
            entriesContent: [ptSubtitle ? `{@i ${ptSubtitle}}` : "", ...ent.entries, ].filter(Boolean),
        };
    }

    static getRenderedString(ent) {
        const entriesMeta = Renderer.reward.getRewardRenderableEntriesMeta(ent);
        return `<tr class="text"><td colspan="6">${Renderer.get().setFirstSection(true).render({
            entries: entriesMeta.entriesContent
        }, 1)}</td></tr>`;
    }

    static getCompactRenderedString(ent) {
        return `
			${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "reward",
            page: UrlUtil.PG_REWARDS
        })}
			${Renderer.utils.getNameTr(ent, {
            page: UrlUtil.PG_REWARDS
        })}
			${Renderer.reward.getRenderedString(ent)}
		`;
    }

    static pGetFluff(ent) {
        return Renderer.utils.pGetFluff({
            entity: ent,
            fnGetFluffData: DataUtil.rewardFluff.loadJSON.bind(DataUtil.rewardFluff),
            fluffProp: "rewardFluff",
        });
    }
}
;

Renderer.race = class {
    static getRaceRenderableEntriesMeta(race) {
        return {
            entryMain: race._isBaseRace ? {
                type: "entries",
                entries: race._baseRaceEntries
            } : {
                type: "entries",
                entries: race.entries
            },
        };
    }

    static getCompactRenderedString(race, {isStatic=false}={}) {
        const renderer = Renderer.get();
        const renderStack = [];

        renderStack.push(`
			${Renderer.utils.getExcludedTr({
            entity: race,
            dataProp: "race",
            page: UrlUtil.PG_RACES
        })}
			${Renderer.utils.getNameTr(race, {
            page: UrlUtil.PG_RACES
        })}
			<tr><td colspan="6">
				<table class="w-100 summary stripe-even-table">
					<tr>
						<th class="col-4 ve-text-center">Ability Scores</th>
						<th class="col-4 ve-text-center">Size</th>
						<th class="col-4 ve-text-center">Speed</th>
					</tr>
					<tr>
						<td class="ve-text-center">${Renderer.getAbilityData(race.ability).asText}</td>
						<td class="ve-text-center">${(race.size || [Parser.SZ_VARIES]).map(sz=>Parser.sizeAbvToFull(sz)).join("/")}</td>
						<td class="ve-text-center">${Parser.getSpeedString(race)}</td>
					</tr>
				</table>
			</td></tr>
			<tr class="text"><td colspan="6">
		`);
        renderer.recursiveRender(Renderer.race.getRaceRenderableEntriesMeta(race).entryMain, renderStack, {
            depth: 1
        });
        renderStack.push("</td></tr>");

        const ptHeightWeight = Renderer.race.getHeightAndWeightPart(race, {
            isStatic
        });
        if (ptHeightWeight)
            renderStack.push(`<tr class="text"><td colspan="6"><hr class="rd__hr">${ptHeightWeight}</td></tr>`);

        return renderStack.join("");
    }

    static getRenderedSize(race) {
        return (race.size || [Parser.SZ_VARIES]).map(sz=>Parser.sizeAbvToFull(sz)).join("/");
    }

    static getHeightAndWeightPart(race, {isStatic=false}={}) {
        if (!race.heightAndWeight)
            return null;
        if (race._isBaseRace)
            return null;
        return Renderer.get().render({
            entries: Renderer.race.getHeightAndWeightEntries(race, {
                isStatic
            })
        });
    }

    static getHeightAndWeightEntries(race, {isStatic=false}={}) {
        const colLabels = ["Base Height", "Base Weight", "Height Modifier", "Weight Modifier"];
        const colStyles = ["col-2-3 ve-text-center", "col-2-3 ve-text-center", "col-2-3 ve-text-center", "col-2 ve-text-center"];

        const cellHeightMod = !isStatic ? `+<span data-race-heightmod="true">${race.heightAndWeight.heightMod}</span>` : `+${race.heightAndWeight.heightMod}`;
        const cellWeightMod = !isStatic ? `× <span data-race-weightmod="true">${race.heightAndWeight.weightMod || "1"}</span> lb.` : `× ${race.heightAndWeight.weightMod || "1"} lb.`;

        const row = [Renderer.race.getRenderedHeight(race.heightAndWeight.baseHeight), `${race.heightAndWeight.baseWeight} lb.`, cellHeightMod, cellWeightMod, ];

        if (!isStatic) {
            colLabels.push("");
            colStyles.push("col-3-1 ve-text-center");
            row.push(`<div class="ve-flex-vh-center">
				<div class="ve-hidden race__disp-result-height-weight ve-flex-v-baseline">
					<div class="mr-1">=</div>
					<div class="race__disp-result-height"></div>
					<div class="mr-2">; </div>
					<div class="race__disp-result-weight mr-1"></div>
					<div class="small">lb.</div>
				</div>
				<button class="btn btn-default btn-xs my-1 race__btn-roll-height-weight">Roll</button>
			</div>`);
        }

        return ["You may roll for your character's height and weight on the Random Height and Weight table. The roll in the Height Modifier column adds a number (in inches) to the character's base height. To get a weight, multiply the number you rolled for height by the roll in the Weight Modifier column and add the result (in pounds) to the base weight.", {
            type: "table",
            caption: "Random Height and Weight",
            colLabels,
            colStyles,
            rows: [row],
        }, ];
    }

    static getRenderedHeight(height) {
        const heightFeet = Number(Math.floor(height / 12).toFixed(3));
        const heightInches = Number((height % 12).toFixed(3));
        return `${heightFeet ? `${heightFeet}'` : ""}${heightInches ? `${heightInches}"` : ""}`;
    }

    static mergeSubraces(races, opts) {
        opts = opts || {};

        const out = [];
        races.forEach(r=>{
            if (r.size && typeof r.size === "string")
                r.size = [r.size];

            if (r.lineage && r.lineage !== true) {
                r = MiscUtil.copyFast(r);

                if (r.lineage === "VRGR") {
                    r.ability = r.ability || [{
                        choose: {
                            weighted: {
                                from: [...Parser.ABIL_ABVS],
                                weights: [2, 1],
                            },
                        },
                    }, {
                        choose: {
                            weighted: {
                                from: [...Parser.ABIL_ABVS],
                                weights: [1, 1, 1],
                            },
                        },
                    }, ];
                } else if (r.lineage === "UA1") {
                    r.ability = r.ability || [{
                        choose: {
                            weighted: {
                                from: [...Parser.ABIL_ABVS],
                                weights: [2, 1],
                            },
                        },
                    }, ];
                }

                r.entries = r.entries || [];
                r.entries.push({
                    type: "entries",
                    name: "Languages",
                    entries: ["You can speak, read, and write Common and one other language that you and your DM agree is appropriate for your character."],
                });

                r.languageProficiencies = r.languageProficiencies || [{
                    "common": true,
                    "anyStandard": 1
                }];
            }

            if (r.subraces && !r.subraces.length)
                delete r.subraces;

            if (r.subraces) {
                r.subraces.forEach(sr=>{
                    sr.source = sr.source || r.source;
                    sr._isSubRace = true;
                }
                );

                r.subraces.sort((a,b)=>SortUtil.ascSortLower(a.name || "_", b.name || "_") || SortUtil.ascSortLower(Parser.sourceJsonToAbv(a.source), Parser.sourceJsonToAbv(b.source)));
            }

            if (opts.isAddBaseRaces && r.subraces) {
                const baseRace = MiscUtil.copyFast(r);

                baseRace._isBaseRace = true;

                const isAnyNoName = r.subraces.some(it=>!it.name);
                if (isAnyNoName) {
                    baseRace._rawName = baseRace.name;
                    baseRace.name = `${baseRace.name} (Base)`;
                }

                const nameCounts = {};
                r.subraces.filter(sr=>sr.name).forEach(sr=>nameCounts[sr.name.toLowerCase()] = (nameCounts[sr.name.toLowerCase()] || 0) + 1);
                nameCounts._ = r.subraces.filter(sr=>!sr.name).length;

                const lst = {
                    type: "list",
                    items: r.subraces.map(sr=>{
                        const count = nameCounts[(sr.name || "_").toLowerCase()];
                        const idName = Renderer.race.getSubraceName(r.name, sr.name);
                        return `{@race ${idName}|${sr.source}${count > 1 ? `|${idName} (<span title="${Parser.sourceJsonToFull(sr.source).escapeQuotes()}">${Parser.sourceJsonToAbv(sr.source)}</span>)` : ""}}`;
                    }
                    ),
                };

                Renderer.race._mutBaseRaceEntries(baseRace, lst);
                baseRace._subraces = r.subraces.map(sr=>({
                    name: Renderer.race.getSubraceName(r.name, sr.name),
                    source: sr.source
                }));

                delete baseRace.subraces;

                out.push(baseRace);
            }

            out.push(...Renderer.race._mergeSubraces(r));
        }
        );

        return out;
    }

    static _mutMakeBaseRace(baseRace) {
        if (baseRace._isBaseRace)
            return;

        baseRace._isBaseRace = true;

        Renderer.race._mutBaseRaceEntries(baseRace, {
            type: "list",
            items: []
        });
    }

    static _mutBaseRaceEntries(baseRace, lst) {
        baseRace._baseRaceEntries = [{
            type: "section",
            entries: ["This race has multiple subraces, as listed below:", lst, ],
        }, {
            type: "section",
            entries: [{
                type: "entries",
                entries: [{
                    type: "entries",
                    name: "Traits",
                    entries: [...MiscUtil.copyFast(baseRace.entries), ],
                }, ],
            }, ],
        }, ];
    }

    static getSubraceName(raceName, subraceName) {
        if (!subraceName)
            return raceName;

        const mBrackets = /^(.*?)(\(.*?\))$/i.exec(raceName || "");
        if (!mBrackets)
            return `${raceName} (${subraceName})`;

        const bracketPart = mBrackets[2].substring(1, mBrackets[2].length - 1);
        return `${mBrackets[1]}(${[bracketPart, subraceName].join("; ")})`;
    }

    static _mergeSubraces(race) {
        if (!race.subraces)
            return [race];
        return MiscUtil.copyFast(race.subraces).map(s=>Renderer.race._getMergedSubrace(race, s));
    }

    static _getMergedSubrace(race, cpySr) {
        const cpy = MiscUtil.copyFast(race);
        cpy._baseName = cpy.name;
        cpy._baseSource = cpy.source;
        cpy._baseSrd = cpy.srd;
        cpy._baseBasicRules = cpy.basicRules;
        delete cpy.subraces;
        delete cpy.srd;
        delete cpy.basicRules;
        delete cpy._versions;
        delete cpy.hasFluff;
        delete cpy.hasFluffImages;
        delete cpySr.__prop;

        if (cpySr.name) {
            cpy._subraceName = cpySr.name;

            if (cpySr.alias) {
                cpy.alias = cpySr.alias.map(it=>Renderer.race.getSubraceName(cpy.name, it));
                delete cpySr.alias;
            }

            cpy.name = Renderer.race.getSubraceName(cpy.name, cpySr.name);
            delete cpySr.name;
        }
        if (cpySr.ability) {
            if ((cpySr.overwrite && cpySr.overwrite.ability) || !cpy.ability)
                cpy.ability = cpySr.ability.map(()=>({}));

            if (cpy.ability.length !== cpySr.ability.length)
                throw new Error(`Race and subrace ability array lengths did not match!`);
            cpySr.ability.forEach((obj,i)=>Object.assign(cpy.ability[i], obj));
            delete cpySr.ability;
        }
        if (cpySr.entries) {
            cpySr.entries.forEach(ent=>{
                if (!ent.data?.overwrite)
                    return cpy.entries.push(ent);

                const toOverwrite = cpy.entries.findIndex(it=>it.name?.toLowerCase()?.trim() === ent.data.overwrite.toLowerCase().trim());
                if (~toOverwrite)
                    cpy.entries[toOverwrite] = ent;
                else
                    cpy.entries.push(ent);
            }
            );
            delete cpySr.entries;
        }

        if (cpySr.traitTags) {
            if (cpySr.overwrite && cpySr.overwrite.traitTags)
                cpy.traitTags = cpySr.traitTags;
            else
                cpy.traitTags = (cpy.traitTags || []).concat(cpySr.traitTags);
            delete cpySr.traitTags;
        }

        if (cpySr.languageProficiencies) {
            if (cpySr.overwrite && cpySr.overwrite.languageProficiencies)
                cpy.languageProficiencies = cpySr.languageProficiencies;
            else
                cpy.languageProficiencies = cpy.languageProficiencies = (cpy.languageProficiencies || []).concat(cpySr.languageProficiencies);
            delete cpySr.languageProficiencies;
        }

        if (cpySr.skillProficiencies) {
            if (!cpy.skillProficiencies || (cpySr.overwrite && cpySr.overwrite["skillProficiencies"]))
                cpy.skillProficiencies = cpySr.skillProficiencies;
            else {
                if (!cpySr.skillProficiencies.length || !cpy.skillProficiencies.length)
                    throw new Error(`No items!`);
                if (cpySr.skillProficiencies.length > 1 || cpy.skillProficiencies.length > 1)
                    throw new Error(`Subrace merging does not handle choices!`);
                if (cpySr.skillProficiencies.choose) {
                    if (cpy.skillProficiencies.choose)
                        throw new Error(`Subrace choose merging is not supported!!`);
                    cpy.skillProficiencies.choose = cpySr.skillProficiencies.choose;
                    delete cpySr.skillProficiencies.choose;
                }
                Object.assign(cpy.skillProficiencies[0], cpySr.skillProficiencies[0]);
            }

            delete cpySr.skillProficiencies;
        }

        Object.assign(cpy, cpySr);

        Object.entries(cpy).forEach(([k,v])=>{
            if (v != null)
                return;
            delete cpy[k];
        }
        );

        return cpy;
    }

    static adoptSubraces(allRaces, subraces) {
        const nxtData = [];

        subraces.forEach(sr=>{
            if (!sr.raceName || !sr.raceSource)
                throw new Error(`Subrace was missing parent "raceName" and/or "raceSource"!`);

            const _baseRace = allRaces.find(r=>r.name === sr.raceName && r.source === sr.raceSource);
            if (!_baseRace)
                throw new Error(`Could not find parent race for subrace "${sr.name}" (${sr.source})!`);

            if ((_baseRace._seenSubraces || []).some(it=>it.name === sr.name && it.source === sr.source))
                return;
            (_baseRace._seenSubraces = _baseRace._seenSubraces || []).push({
                name: sr.name,
                source: sr.source
            });

            if (!_baseRace._isBaseRace && (PrereleaseUtil.hasSourceJson(_baseRace.source) || BrewUtil2.hasSourceJson(_baseRace.source))) {
                Renderer.race._mutMakeBaseRace(_baseRace);
            }

            if (_baseRace._isBaseRace) {
                const subraceListEntry = ((_baseRace._baseRaceEntries[0] || {}).entries || []).find(it=>it.type === "list");
                subraceListEntry.items.push(`{@race ${_baseRace._rawName || _baseRace.name} (${sr.name})|${sr.source || _baseRace.source}}`);
            }

            let baseRace = nxtData.find(r=>r.name === sr.raceName && r.source === sr.raceSource);
            if (!baseRace) {
                baseRace = MiscUtil.copyFast(_baseRace);
                if (baseRace._rawName) {
                    baseRace.name = baseRace._rawName;
                    delete baseRace._rawName;
                }
                delete baseRace._isBaseRace;
                delete baseRace._baseRaceEntries;

                nxtData.push(baseRace);
            }

            baseRace.subraces = baseRace.subraces || [];
            baseRace.subraces.push(sr);
        }
        );

        return nxtData;
    }

    static bindListenersHeightAndWeight(race, ele) {
        if (!race.heightAndWeight)
            return;
        if (race._isBaseRace)
            return;

        const $render = $(ele);

        const $dispResult = $render.find(`.race__disp-result-height-weight`);
        const $dispHeight = $render.find(`.race__disp-result-height`);
        const $dispWeight = $render.find(`.race__disp-result-weight`);

        const lock = new VeLock();
        let hasRolled = false;
        let resultHeight;
        let resultWeightMod;

        const $btnRollHeight = $render.find(`[data-race-heightmod="true"]`).html(race.heightAndWeight.heightMod).addClass("roller").mousedown(evt=>evt.preventDefault()).click(async()=>{
            try {
                await lock.pLock();

                if (!hasRolled)
                    return pDoFullRoll(true);
                await pRollHeight();
                updateDisplay();
            } finally {
                lock.unlock();
            }
        }
        );

        const isWeightRoller = race.heightAndWeight.weightMod && isNaN(race.heightAndWeight.weightMod);
        const $btnRollWeight = $render.find(`[data-race-weightmod="true"]`).html(isWeightRoller ? `(<span class="roller">${race.heightAndWeight.weightMod}</span>)` : race.heightAndWeight.weightMod || "1").click(async()=>{
            try {
                await lock.pLock();

                if (!hasRolled)
                    return pDoFullRoll(true);
                await pRollWeight();
                updateDisplay();
            } finally {
                lock.unlock();
            }
        }
        );
        if (isWeightRoller)
            $btnRollWeight.mousedown(evt=>evt.preventDefault());

        const $btnRoll = $render.find(`button.race__btn-roll-height-weight`).click(async()=>pDoFullRoll());

        const pRollHeight = async()=>{
            const mResultHeight = await Renderer.dice.pRoll2(race.heightAndWeight.heightMod, {
                isUser: false,
                label: "Height Modifier",
                name: race.name,
            });
            if (mResultHeight == null)
                return;
            resultHeight = mResultHeight;
        }
        ;

        const pRollWeight = async()=>{
            const weightModRaw = race.heightAndWeight.weightMod || "1";
            const mResultWeightMod = isNaN(weightModRaw) ? await Renderer.dice.pRoll2(weightModRaw, {
                isUser: false,
                label: "Weight Modifier",
                name: race.name,
            }) : Number(weightModRaw);
            if (mResultWeightMod == null)
                return;
            resultWeightMod = mResultWeightMod;
        }
        ;

        const updateDisplay = ()=>{
            const renderedHeight = Renderer.race.getRenderedHeight(race.heightAndWeight.baseHeight + resultHeight);
            const totalWeight = race.heightAndWeight.baseWeight + (resultWeightMod * resultHeight);
            $dispHeight.text(renderedHeight);
            $dispWeight.text(Number(totalWeight.toFixed(3)));
        }
        ;

        const pDoFullRoll = async isPreLocked=>{
            try {
                if (!isPreLocked)
                    await lock.pLock();

                $btnRoll.parent().removeClass(`ve-flex-vh-center`).addClass(`split-v-center`);
                await pRollHeight();
                await pRollWeight();
                $dispResult.removeClass(`ve-hidden`);
                updateDisplay();

                hasRolled = true;
            } finally {
                if (!isPreLocked)
                    lock.unlock();
            }
        }
        ;
    }

    static bindListenersCompact(race, ele) {
        Renderer.race.bindListenersHeightAndWeight(race, ele);
    }

    static pGetFluff(race) {
        return Renderer.utils.pGetFluff({
            entity: race,
            fnGetFluffData: DataUtil.raceFluff.loadJSON.bind(DataUtil.raceFluff),
            fluffProp: "raceFluff",
        });
    }
}
;

Renderer.raceFeature = class {
    static getCompactRenderedString(ent) {
        return Renderer.generic.getCompactRenderedString(ent);
    }
}
;

Renderer.deity = class {
    static _BASE_PART_TRANSLATORS = {
        "alignment": {
            name: "Alignment",
            displayFn: (it)=>it.map(a=>Parser.alignmentAbvToFull(a)).join(" ").toTitleCase(),
        },
        "pantheon": {
            name: "Pantheon",
        },
        "category": {
            name: "Category",
            displayFn: it=>typeof it === "string" ? it : it.join(", "),
        },
        "domains": {
            name: "Domains",
            displayFn: (it)=>it.join(", "),
        },
        "province": {
            name: "Province",
        },
        "altNames": {
            name: "Alternate Names",
            displayFn: (it)=>it.join(", "),
        },
        "symbol": {
            name: "Symbol",
        },
    };

    static getDeityRenderableEntriesMeta(ent) {
        return {
            entriesAttributes: [...Object.entries(Renderer.deity._BASE_PART_TRANSLATORS).map(([prop,{name, displayFn}])=>{
                if (ent[prop] == null)
                    return null;

                const displayVal = displayFn ? displayFn(ent[prop]) : ent[prop];
                return {
                    name,
                    entry: `{@b ${name}:} ${displayVal}`,
                };
            }
            ).filter(Boolean), ...Object.entries(ent.customProperties || {}).map(([name,val])=>({
                name,
                entry: `{@b ${name}:} ${val}`,
            })), ].sort(({name: nameA},{name: nameB})=>SortUtil.ascSortLower(nameA, nameB)).map(({entry})=>entry),
        };
    }

    static getCompactRenderedString(ent) {
        const renderer = Renderer.get();
        const entriesMeta = Renderer.deity.getDeityRenderableEntriesMeta(ent);
        return `
			${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "deity",
            page: UrlUtil.PG_DEITIES
        })}
			${Renderer.utils.getNameTr(ent, {
            suffix: ent.title ? `, ${ent.title.toTitleCase()}` : "",
            page: UrlUtil.PG_DEITIES
        })}
			<tr><td colspan="6">
				${entriesMeta.entriesAttributes.map(entry=>`<div class="my-1p">${Renderer.get().render(entry)}</div>`).join("")}
			</td>
			${ent.entries ? `<tr><td colspan="6"><div class="border"></div></td></tr><tr><td colspan="6">${renderer.render({
            entries: ent.entries
        }, 1)}</td></tr>` : ""}
		`;
    }
}
;

Renderer.object = class {
    static CHILD_PROPS = ["actionEntries"];

    static RENDERABLE_ENTRIES_PROP_ORDER__ATTRIBUTES = ["entryCreatureCapacity", "entryCargoCapacity", "entryArmorClass", "entryHitPoints", "entrySpeed", "entryAbilityScores", "entryDamageImmunities", "entryDamageResistances", "entryDamageVulnerabilities", "entryConditionImmunities", ];

    static getObjectRenderableEntriesMeta(ent) {
        return {
            entrySize: `{@i ${ent.objectType !== "GEN" ? `${Renderer.utils.getRenderedSize(ent.size)} ${ent.creatureType ? Parser.monTypeToFullObj(ent.creatureType).asText : "object"}` : `Variable size object`}}`,

            entryCreatureCapacity: ent.capCrew != null || ent.capPassenger != null ? `{@b Creature Capacity:} ${Renderer.vehicle.getShipCreatureCapacity(ent)}` : null,
            entryCargoCapacity: ent.capCargo != null ? `{@b Cargo Capacity:} ${Renderer.vehicle.getShipCargoCapacity(ent)}` : null,
            entryArmorClass: ent.ac != null ? `{@b Armor Class:} ${ent.ac.special ?? ent.ac}` : null,
            entryHitPoints: ent.hp != null ? `{@b Hit Points:} ${ent.hp.special ?? ent.hp}` : null,
            entrySpeed: ent.speed != null ? `{@b Speed:} ${Parser.getSpeedString(ent)}` : null,
            entryAbilityScores: Parser.ABIL_ABVS.some(ab=>ent[ab] != null) ? `{@b Ability Scores:} ${Parser.ABIL_ABVS.filter(ab=>ent[ab] != null).map(ab=>`${ab.toUpperCase()} ${Renderer.utils.getAbilityRollerEntry(ent, ab)}`).join(", ")}` : null,
            entryDamageImmunities: ent.immune != null ? `{@b Damage Immunities:} ${Parser.getFullImmRes(ent.immune)}` : null,
            entryDamageResistances: ent.resist ? `{@b Damage Resistances:} ${Parser.getFullImmRes(ent.resist)}` : null,
            entryDamageVulnerabilities: ent.vulnerable ? `{@b Damage Vulnerabilities:} ${Parser.getFullImmRes(ent.vulnerable)}` : null,
            entryConditionImmunities: ent.conditionImmune ? `{@b Condition Immunities:} ${Parser.getFullCondImm(ent.conditionImmune, {
                isEntry: true
            })}` : null,
        };
    }

    static getCompactRenderedString(obj, opts) {
        return Renderer.object.getRenderedString(obj, {
            ...opts,
            isCompact: true
        });
    }

    static getRenderedString(ent, opts) {
        opts = opts || {};

        const renderer = Renderer.get().setFirstSection(true);

        const hasToken = ent.tokenUrl || ent.hasToken;
        const extraThClasses = !opts.isCompact && hasToken ? ["objs__name--token"] : null;

        const entriesMeta = Renderer.object.getObjectRenderableEntriesMeta(ent);

        const ptAttribs = Renderer.object.RENDERABLE_ENTRIES_PROP_ORDER__ATTRIBUTES.filter(prop=>entriesMeta[prop]).map(prop=>`${Renderer.get().render(entriesMeta[prop])}<br>`).join("");

        return `
			${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "object",
            page: opts.page || UrlUtil.PG_OBJECTS
        })}
			${Renderer.utils.getNameTr(ent, {
            page: opts.page || UrlUtil.PG_OBJECTS,
            extraThClasses,
            isEmbeddedEntity: opts.isEmbeddedEntity
        })}
			<tr class="text"><td colspan="6">${Renderer.get().render(entriesMeta.entrySize)}</td></tr>
			<tr class="text"><td colspan="6">${ptAttribs}</td></tr>
			<tr class="text"><td colspan="6">
			${ent.entries ? renderer.render({
            entries: ent.entries
        }, 2) : ""}
			${ent.actionEntries ? renderer.render({
            entries: ent.actionEntries
        }, 2) : ""}
			</td></tr>
		`;
    }

    static getTokenUrl(obj) {
        return obj.tokenUrl || UrlUtil.link(`${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/objects/tokens/${Parser.sourceJsonToAbv(obj.source)}/${Parser.nameToTokenName(obj.name)}.png`);
    }

    static pGetFluff(obj) {
        return Renderer.utils.pGetFluff({
            entity: obj,
            fnGetFluffData: DataUtil.objectFluff.loadJSON.bind(DataUtil.objectFluff),
            fluffProp: "objectFluff",
        });
    }
}
;

Renderer.trap = class {
    static CHILD_PROPS = ["trigger", "effect", "eActive", "eDynamic", "eConstant", "countermeasures"];

    static getTrapRenderableEntriesMeta(ent) {
        return {
            entriesAttributes: [ent.trigger ? {
                type: "entries",
                name: "Trigger",
                entries: ent.trigger,
            } : null,
            ent.effect ? {
                type: "entries",
                name: "Effect",
                entries: ent.effect,
            } : null,
            ent.initiative ? {
                type: "entries",
                name: "Initiative",
                entries: Renderer.trap.getTrapInitiativeEntries(ent),
            } : null, ent.eActive ? {
                type: "entries",
                name: "Active Elements",
                entries: ent.eActive,
            } : null, ent.eDynamic ? {
                type: "entries",
                name: "Dynamic Elements",
                entries: ent.eDynamic,
            } : null, ent.eConstant ? {
                type: "entries",
                name: "Constant Elements",
                entries: ent.eConstant,
            } : null,
            ent.countermeasures ? {
                type: "entries",
                name: "Countermeasures",
                entries: ent.countermeasures,
            } : null, ].filter(Boolean),
        };
    }

    static getTrapInitiativeEntries(ent) {
        return [`The trap acts on ${Parser.trapInitToFull(ent.initiative)}${ent.initiativeNote ? ` (${ent.initiativeNote})` : ""}.`];
    }

    static getRenderedTrapPart(renderer, ent) {
        const entriesMeta = Renderer.trap.getTrapRenderableEntriesMeta(ent);
        if (!entriesMeta.entriesAttributes.length)
            return "";
        return renderer.render({
            entries: entriesMeta.entriesAttributes
        }, 1);
    }

    static getCompactRenderedString(ent, opts) {
        return Renderer.traphazard.getCompactRenderedString(ent, opts);
    }

    static pGetFluff(ent) {
        return Renderer.traphazard.pGetFluff(ent);
    }
}
;

Renderer.hazard = class {
    static getCompactRenderedString(ent, opts) {
        return Renderer.traphazard.getCompactRenderedString(ent, opts);
    }

    static pGetFluff(ent) {
        return Renderer.traphazard.pGetFluff(ent);
    }
}
;

Renderer.traphazard = class {
    static getSubtitle(ent) {
        const type = ent.trapHazType || "HAZ";
        if (type === "GEN")
            return null;

        const ptThreat = ent.threat ? ent.threat.toTitleCase() : null;

        const ptTypeThreat = [Parser.trapHazTypeToFull(type), ent.threat ? ent.threat.toTitleCase() : null, ].filter(Boolean).join(", ");

        const parenPart = [ent.tier ? Parser.tierToFullLevel(ent.tier) : null, Renderer.traphazard.getTrapLevelPart(ent), ].filter(Boolean).join(", ");

        return parenPart ? `${ptTypeThreat} (${parenPart})` : ptTypeThreat;
    }

    static getTrapLevelPart(ent) {
        return ent.level?.min != null && ent.level?.max != null ? `level ${ent.level.min}${ent.level.min !== ent.level.max ? `\u2013${ent.level.max}` : ""}` : null;
    }

    static getCompactRenderedString(ent, opts) {
        opts = opts || {};

        const renderer = Renderer.get();
        const subtitle = Renderer.traphazard.getSubtitle(ent);
        return `
			${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: ent.__prop,
            page: UrlUtil.PG_TRAPS_HAZARDS
        })}
			${Renderer.utils.getNameTr(ent, {
            page: UrlUtil.PG_TRAPS_HAZARDS,
            isEmbeddedEntity: opts.isEmbeddedEntity
        })}
			${subtitle ? `<tr class="text"><td colspan="6"><i>${subtitle}</i></td></tr>` : ""}
			<tr class="text"><td colspan="6">
			${renderer.render({
            entries: ent.entries
        }, 2)}
			${Renderer.trap.getRenderedTrapPart(renderer, ent)}
			</td></tr>
		`;
    }

    static pGetFluff(ent) {
        return Renderer.utils.pGetFluff({
            entity: ent,
            fnGetFluffData: ent.__prop === "trap" ? DataUtil.trapFluff.loadJSON.bind(DataUtil.trapFluff) : DataUtil.hazardFluff.loadJSON.bind(DataUtil.hazardFluff),
            fluffProp: ent.__prop === "trap" ? "trapFluff" : "hazardFluff",
        });
    }
}
;

Renderer.cultboon = class {
    static getCultRenderableEntriesMeta(ent) {
        if (!ent.goal && !ent.cultists && !ent.signaturespells)
            return null;

        const fauxList = {
            type: "list",
            style: "list-hang-notitle",
            items: [],
        };

        if (ent.goal) {
            fauxList.items.push({
                type: "item",
                name: "Goals:",
                entry: ent.goal.entry,
            });
        }

        if (ent.cultists) {
            fauxList.items.push({
                type: "item",
                name: "Typical Cultists:",
                entry: ent.cultists.entry,
            });
        }
        if (ent.signaturespells) {
            fauxList.items.push({
                type: "item",
                name: "Signature Spells:",
                entry: ent.signaturespells.entry,
            });
        }

        return {
            listGoalsCultistsSpells: fauxList
        };
    }

    static doRenderCultParts(ent, renderer, renderStack) {
        const cultEntriesMeta = Renderer.cultboon.getCultRenderableEntriesMeta(ent);
        if (!cultEntriesMeta)
            return;
        renderer.recursiveRender(cultEntriesMeta.listGoalsCultistsSpells, renderStack, {
            depth: 2
        });
    }

    static getBoonRenderableEntriesMeta(ent) {
        if (!ent.ability && !ent.signaturespells)
            return null;

        const benefits = {
            type: "list",
            style: "list-hang-notitle",
            items: []
        };

        if (ent.ability) {
            benefits.items.push({
                type: "item",
                name: "Ability Score Adjustment:",
                entry: ent.ability ? ent.ability.entry : "None",
            });
        }

        if (ent.signaturespells) {
            benefits.items.push({
                type: "item",
                name: "Signature Spells:",
                entry: ent.signaturespells ? ent.signaturespells.entry : "None",
            });
        }

        return {
            listBenefits: benefits
        };
    }

    static doRenderBoonParts(ent, renderer, renderStack) {
        const boonEntriesMeta = Renderer.cultboon.getBoonRenderableEntriesMeta(ent);
        if (!boonEntriesMeta)
            return;
        renderer.recursiveRender(boonEntriesMeta.listBenefits, renderStack, {
            depth: 1
        });
    }

    static _getCompactRenderedString_cult({ent, renderer}) {
        const renderStack = [];

        Renderer.cultboon.doRenderCultParts(ent, renderer, renderStack);
        renderer.recursiveRender({
            entries: ent.entries
        }, renderStack, {
            depth: 2
        });

        return `${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "cult",
            page: UrlUtil.PG_CULTS_BOONS
        })}
		${Renderer.utils.getNameTr(ent, {
            page: UrlUtil.PG_CULTS_BOONS
        })}
		<tr id="text"><td class="divider" colspan="6"><div></div></td></tr>
		<tr class="text"><td colspan="6" class="text">${renderStack.join("")}</td></tr>`;
    }

    static _getCompactRenderedString_boon({ent, renderer}) {
        const renderStack = [];

        Renderer.cultboon.doRenderBoonParts(ent, renderer, renderStack);
        renderer.recursiveRender({
            entries: ent.entries
        }, renderStack, {
            depth: 1
        });
        ent._displayName = ent._displayName || ent.name;

        return `${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "boon",
            page: UrlUtil.PG_CULTS_BOONS
        })}
		${Renderer.utils.getNameTr(ent, {
            page: UrlUtil.PG_CULTS_BOONS
        })}
		<tr class="text"><td colspan="6">${renderStack.join("")}</td></tr>`;
    }

    static getCompactRenderedString(ent) {
        const renderer = Renderer.get();
        switch (ent.__prop) {
        case "cult":
            return Renderer.cultboon._getCompactRenderedString_cult({
                ent,
                renderer
            });
        case "boon":
            return Renderer.cultboon._getCompactRenderedString_boon({
                ent,
                renderer
            });
        default:
            throw new Error(`Unhandled prop "${ent.__prop}"`);
        }
    }
}
;


Renderer.legendaryGroup = class {
    static getCompactRenderedString(legGroup, opts) {
        opts = opts || {};

        const ent = Renderer.legendaryGroup.getSummaryEntry(legGroup);
        if (!ent)
            return "";

        return `
		${Renderer.utils.getNameTr(legGroup, {
            isEmbeddedEntity: opts.isEmbeddedEntity
        })}
		<tr class="text"><td colspan="6">
		${Renderer.get().setFirstSection(true).render(ent)}
		</td></tr>
		${Renderer.utils.getPageTr(legGroup)}`;
    }

    static getSummaryEntry(legGroup) {
        if (!legGroup || (!legGroup.lairActions && !legGroup.regionalEffects && !legGroup.mythicEncounter))
            return null;

        return {
            type: "section",
            entries: [legGroup.lairActions ? {
                name: "Lair Actions",
                type: "entries",
                entries: legGroup.lairActions
            } : null, legGroup.regionalEffects ? {
                name: "Regional Effects",
                type: "entries",
                entries: legGroup.regionalEffects
            } : null, legGroup.mythicEncounter ? {
                name: "As a Mythic Encounter",
                type: "entries",
                entries: legGroup.mythicEncounter
            } : null, ].filter(Boolean),
        };
    }
}
;

Renderer.item = class {
    static _sortProperties(a, b) {
        return SortUtil.ascSort(Renderer.item.getProperty(a, {
            isIgnoreMissing: true
        })?.name || "", Renderer.item.getProperty(b, {
            isIgnoreMissing: true
        })?.name || "");
    }

    static _getPropertiesText(item, {renderer=null}={}) {
        renderer = renderer || Renderer.get();

        if (!item.property) {
            const parts = [];
            if (item.dmg2)
                parts.push(`alt. ${Renderer.item._renderDamage(item.dmg2, {
                    renderer
                })}`);
            if (item.range)
                parts.push(`range ${item.range} ft.`);
            return `${item.dmg1 && parts.length ? " - " : ""}${parts.join(", ")}`;
        }

        let renderedDmg2 = false;

        const renderedProperties = item.property.sort(Renderer.item._sortProperties).map(p=>{
            const pFull = Renderer.item.getProperty(p);

            if (pFull.template) {
                const toRender = Renderer.utils.applyTemplate(item, pFull.template, {
                    fnPreApply: (fullMatch,variablePath)=>{
                        if (variablePath === "item.dmg2")
                            renderedDmg2 = true;
                    }
                    ,
                    mapCustom: {
                        "prop_name": pFull.name
                    },
                }, );

                return renderer.render(toRender);
            } else
                return pFull.name;
        }
        );

        if (!renderedDmg2 && item.dmg2)
            renderedProperties.unshift(`alt. ${Renderer.item._renderDamage(item.dmg2, {
                renderer
            })}`);

        return `${item.dmg1 && renderedProperties.length ? " - " : ""}${renderedProperties.join(", ")}`;
    }

    static _getTaggedDamage(dmg, {renderer=null}={}) {
        if (!dmg)
            return "";

        renderer = renderer || Renderer.get();

        Renderer.stripTags(dmg.trim());

        return renderer.render(`{@damage ${dmg}}`);
    }

    static _renderDamage(dmg, {renderer=null}={}) {
        renderer = renderer || Renderer.get();
        return renderer.render(Renderer.item._getTaggedDamage(dmg, {
            renderer
        }));
    }

    static getDamageAndPropertiesText(item, {renderer=null}={}) {
        renderer = renderer || Renderer.get();

        const damagePartsPre = [];
        const damageParts = [];

        if (item.mastery)
            damagePartsPre.push(`Mastery: ${item.mastery.map(it=>renderer.render(`{@itemMastery ${it}}`)).join(", ")}`);

        if (item.ac != null) {
            const prefix = item.type === "S" ? "+" : "";
            const suffix = (item.type === "LA" || item.bardingType === "LA") || ((item.type === "MA" || item.bardingType === "MA") && item.dexterityMax === null) ? " + Dex" : (item.type === "MA" || item.bardingType === "MA") ? ` + Dex (max ${item.dexterityMax ?? 2})` : "";
            damageParts.push(`AC ${prefix}${item.ac}${suffix}`);
        }
        if (item.acSpecial != null)
            damageParts.push(item.ac != null ? item.acSpecial : `AC ${item.acSpecial}`);

        if (item.dmg1)
            damageParts.push(Renderer.item._renderDamage(item.dmg1, {
                renderer
            }));

        if (item.speed != null)
            damageParts.push(`Speed: ${item.speed}`);
        if (item.carryingCapacity)
            damageParts.push(`Carrying Capacity: ${item.carryingCapacity} lb.`);

        if (item.vehSpeed || item.capCargo || item.capPassenger || item.crew || item.crewMin || item.crewMax || item.vehAc || item.vehHp || item.vehDmgThresh || item.travelCost || item.shippingCost) {
            const vehPartUpper = item.vehSpeed ? `Speed: ${Parser.numberToVulgar(item.vehSpeed)} mph` : null;

            const vehPartMiddle = item.capCargo || item.capPassenger ? `Carrying Capacity: ${[item.capCargo ? `${Parser.numberToFractional(item.capCargo)} ton${item.capCargo === 0 || item.capCargo > 1 ? "s" : ""} cargo` : null, item.capPassenger ? `${item.capPassenger} passenger${item.capPassenger === 1 ? "" : "s"}` : null].filter(Boolean).join(", ")}` : null;

            const {travelCostFull, shippingCostFull} = Parser.itemVehicleCostsToFull(item);

            const vehPartLower = [item.crew ? `Crew ${item.crew}` : null, item.crewMin && item.crewMax ? `Crew ${item.crewMin}-${item.crewMax}` : null, item.vehAc ? `AC ${item.vehAc}` : null, item.vehHp ? `HP ${item.vehHp}${item.vehDmgThresh ? `, Damage Threshold ${item.vehDmgThresh}` : ""}` : null, ].filter(Boolean).join(", ");

            damageParts.push([vehPartUpper, vehPartMiddle,
            travelCostFull ? `Personal Travel Cost: ${travelCostFull} per mile per passenger` : null, shippingCostFull ? `Shipping Cost: ${shippingCostFull} per 100 pounds per mile` : null,
            vehPartLower, ].filter(Boolean).join(renderer.getLineBreak()));
        }

        const damage = [damagePartsPre.join(", "), damageParts.join(", "), ].filter(Boolean).join(renderer.getLineBreak());
        const damageType = item.dmgType ? Parser.dmgTypeToFull(item.dmgType) : "";
        const propertiesTxt = Renderer.item._getPropertiesText(item, {
            renderer
        });

        return [damage, damageType, propertiesTxt];
    }

    static getTypeRarityAndAttunementText(item) {
        const typeRarity = [item._typeHtml === "other" ? "" : item._typeHtml, (item.rarity && Renderer.item.doRenderRarity(item.rarity) ? item.rarity : ""), ].filter(Boolean).join(", ");

        return [item.reqAttune ? `${typeRarity} ${item._attunement}` : typeRarity, item._subTypeHtml || "", item.tier ? `${item.tier} tier` : "", ];
    }

    static getAttunementAndAttunementCatText(item, prop="reqAttune") {
        let attunement = null;
        let attunementCat = VeCt.STR_NO_ATTUNEMENT;
        if (item[prop] != null && item[prop] !== false) {
            if (item[prop] === true) {
                attunementCat = "Requires Attunement";
                attunement = "(requires attunement)";
            } else if (item[prop] === "optional") {
                attunementCat = "Attunement Optional";
                attunement = "(attunement optional)";
            } else if (item[prop].toLowerCase().startsWith("by")) {
                attunementCat = "Requires Attunement By...";
                attunement = `(requires attunement ${Renderer.get().render(item[prop])})`;
            } else {
                attunementCat = "Requires Attunement";
                attunement = `(requires attunement ${Renderer.get().render(item[prop])})`;
            }
        }
        return [attunement, attunementCat];
    }

    static getHtmlAndTextTypes(item) {
        const typeHtml = [];
        const typeListText = [];
        const subTypeHtml = [];

        let showingBase = false;
        if (item.wondrous) {
            typeHtml.push(`wondrous item${item.tattoo ? ` (tattoo)` : ""}`);
            typeListText.push("wondrous item");
        }
        if (item.tattoo) {
            typeListText.push("tattoo");
        }
        if (item.staff) {
            typeHtml.push("staff");
            typeListText.push("staff");
        }
        if (item.ammo) {
            typeHtml.push(`ammunition`);
            typeListText.push("ammunition");
        }
        if (item.firearm) {
            subTypeHtml.push("firearm");
            typeListText.push("firearm");
        }
        if (item.age) {
            subTypeHtml.push(item.age);
            typeListText.push(item.age);
        }
        if (item.weaponCategory) {
            typeHtml.push(`weapon${item.baseItem ? ` (${Renderer.get().render(`{@item ${item.baseItem}}`)})` : ""}`);
            subTypeHtml.push(`${item.weaponCategory} weapon`);
            typeListText.push(`${item.weaponCategory} weapon`);
            showingBase = true;
        }
        if (item.staff && (item.type !== "M" && item.typeAlt !== "M")) {
            subTypeHtml.push("melee weapon");
            typeListText.push("melee weapon");
        }
        if (item.type)
            Renderer.item._getHtmlAndTextTypes_type({
                type: item.type,
                typeHtml,
                typeListText,
                subTypeHtml,
                showingBase,
                item
            });
        if (item.typeAlt)
            Renderer.item._getHtmlAndTextTypes_type({
                type: item.typeAlt,
                typeHtml,
                typeListText,
                subTypeHtml,
                showingBase,
                item
            });
        if (item.poison) {
            typeHtml.push(`poison${item.poisonTypes ? ` (${item.poisonTypes.joinConjunct(", ", " or ")})` : ""}`);
            typeListText.push("poison");
        }
        return [typeListText, typeHtml.join(", "), subTypeHtml.join(", ")];
    }

    static _getHtmlAndTextTypes_type({type, typeHtml, typeListText, subTypeHtml, showingBase, item}) {
        const fullType = Renderer.item.getItemTypeName(type);

        const isSub = (typeListText.some(it=>it.includes("weapon")) && fullType.includes("weapon")) || (typeListText.some(it=>it.includes("armor")) && fullType.includes("armor"));

        if (!showingBase && !!item.baseItem)
            (isSub ? subTypeHtml : typeHtml).push(`${fullType} (${Renderer.get().render(`{@item ${item.baseItem}}`)})`);
        else if (type === "S")
            (isSub ? subTypeHtml : typeHtml).push(Renderer.get().render(`armor ({@item shield|phb})`));
        else
            (isSub ? subTypeHtml : typeHtml).push(fullType);

        typeListText.push(fullType);
    }

    static _GET_RENDERED_ENTRIES_WALKER = null;

    static getRenderedEntries(item, {isCompact=false, wrappedTypeAllowlist=null}={}) {
        const renderer = Renderer.get();

        Renderer.item._GET_RENDERED_ENTRIES_WALKER = Renderer.item._GET_RENDERED_ENTRIES_WALKER || MiscUtil.getWalker({
            keyBlocklist: new Set([...MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST, "data", ]),
        });

        const handlersName = {
            string: (str)=>Renderer.item._getRenderedEntries_handlerConvertNamesToItalics.bind(Renderer.item, item, item.name)(str),
        };

        const handlersVariantName = item._variantName == null ? null : {
            string: (str)=>Renderer.item._getRenderedEntries_handlerConvertNamesToItalics.bind(Renderer.item, item, item._variantName)(str),
        };

        const renderStack = [];
        if (item._fullEntries || item.entries?.length) {
            const entry = MiscUtil.copyFast({
                type: "entries",
                entries: item._fullEntries || item.entries
            });
            let procEntry = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(entry, handlersName);
            if (handlersVariantName)
                procEntry = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(entry, handlersVariantName);
            if (wrappedTypeAllowlist)
                procEntry.entries = procEntry.entries.filter(it=>!it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG] || wrappedTypeAllowlist.has(it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]));
            renderer.recursiveRender(procEntry, renderStack, {
                depth: 1
            });
        }

        if (item._fullAdditionalEntries || item.additionalEntries) {
            const additionEntries = MiscUtil.copyFast({
                type: "entries",
                entries: item._fullAdditionalEntries || item.additionalEntries
            });
            let procAdditionEntries = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(additionEntries, handlersName);
            if (handlersVariantName)
                procAdditionEntries = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(additionEntries, handlersVariantName);
            if (wrappedTypeAllowlist)
                procAdditionEntries.entries = procAdditionEntries.entries.filter(it=>!it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG] || wrappedTypeAllowlist.has(it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]));
            renderer.recursiveRender(procAdditionEntries, renderStack, {
                depth: 1
            });
        }

        if (!isCompact && item.lootTables) {
            renderStack.push(`<div><span class="bold">Found On: </span>${item.lootTables.sort(SortUtil.ascSortLower).map(tbl=>renderer.render(`{@table ${tbl}}`)).join(", ")}</div>`);
        }

        return renderStack.join("").trim();
    }

    static _getRenderedEntries_handlerConvertNamesToItalics(item, baseName, str) {
        if (item._fIsMundane)
            return str;

        const stack = [];
        let depth = 0;

        const tgtLen = baseName.length;
        const tgtName = item.sentient ? baseName : baseName.toLowerCase();

        const tgtNamePlural = tgtName.toPlural();
        const tgtLenPlural = tgtNamePlural.length;

        const tgtNameNoBraces = tgtName.replace(/ \(.*$/, "");
        const tgtLenNoBraces = tgtNameNoBraces.length;

        const len = str.length;
        for (let i = 0; i < len; ++i) {
            const c = str[i];

            switch (c) {
            case "{":
                {
                    if (str[i + 1] === "@")
                        depth++;
                    stack.push(c);
                    break;
                }
            case "}":
                {
                    if (depth)
                        depth--;
                    stack.push(c);
                    break;
                }
            default:
                stack.push(c);
                break;
            }

            if (depth)
                continue;

            if (stack.slice(-tgtLen).join("")[item.sentient ? "toString" : "toLowerCase"]() === tgtName) {
                stack.splice(stack.length - tgtLen, tgtLen, `{@i ${stack.slice(-tgtLen).join("")}}`);
            } else if (stack.slice(-tgtLenPlural).join("")[item.sentient ? "toString" : "toLowerCase"]() === tgtNamePlural) {
                stack.splice(stack.length - tgtLenPlural, tgtLenPlural, `{@i ${stack.slice(-tgtLenPlural).join("")}}`);
            } else if (stack.slice(-tgtLenNoBraces).join("")[item.sentient ? "toString" : "toLowerCase"]() === tgtNameNoBraces) {
                stack.splice(stack.length - tgtLenNoBraces, tgtLenNoBraces, `{@i ${stack.slice(-tgtLenNoBraces).join("")}}`);
            }
        }

        return stack.join("");
    }

    static getCompactRenderedString(item, opts) {
        opts = opts || {};

        const [damage,damageType,propertiesTxt] = Renderer.item.getDamageAndPropertiesText(item);
        const [typeRarityText,subTypeText,tierText] = Renderer.item.getTypeRarityAndAttunementText(item);

        return `
		${Renderer.utils.getExcludedTr({
            entity: item,
            dataProp: "item",
            page: UrlUtil.PG_ITEMS
        })}
		${Renderer.utils.getNameTr(item, {
            page: UrlUtil.PG_ITEMS,
            isEmbeddedEntity: opts.isEmbeddedEntity
        })}
		<tr><td class="rd-item__type-rarity-attunement" colspan="6">${Renderer.item.getTypeRarityAndAttunementHtml(typeRarityText, subTypeText, tierText)}</td></tr>
		<tr>
			<td colspan="2">${[Parser.itemValueToFullMultiCurrency(item), Parser.itemWeightToFull(item)].filter(Boolean).join(", ").uppercaseFirst()}</td>
			<td class="text-right" colspan="4">${damage} ${damageType} ${propertiesTxt}</td>
		</tr>
		${Renderer.item.hasEntries(item) ? `${Renderer.utils.getDividerTr()}<tr class="text"><td colspan="6" class="text">${Renderer.item.getRenderedEntries(item, {
            isCompact: true
        })}</td></tr>` : ""}`;
    }

    static hasEntries(item) {
        return item._fullAdditionalEntries?.length || item._fullEntries?.length || item.entries?.length;
    }

    static getTypeRarityAndAttunementHtml(typeRarityText, subTypeText, tierText) {
        return `<div class="ve-flex-col">
			${typeRarityText || tierText ? `<div class="split ${subTypeText ? "mb-1" : ""}">
				<div class="italic">${(typeRarityText || "").uppercaseFirst()}</div>
				<div class="no-wrap ${tierText ? `ml-2` : ""}">${(tierText || "").uppercaseFirst()}</div>
			</div>` : ""}
			${subTypeText ? `<div class="italic">${subTypeText.uppercaseFirst()}</div>` : ""}
		</div>`;
    }

    static _hiddenRarity = new Set(["none", "unknown", "unknown (magic)", "varies"]);
    static doRenderRarity(rarity) {
        return !Renderer.item._hiddenRarity.has(rarity);
    }

    static _propertyMap = {};
    static _addProperty(prt) {
        if (Renderer.item._propertyMap[prt.abbreviation])
            return;
        const cpy = MiscUtil.copyFast(prt);
        Renderer.item._propertyMap[prt.abbreviation] = prt.name ? cpy : {
            ...cpy,
            name: (prt.entries || prt.entriesTemplate)[0].name.toLowerCase(),
        };
    }

    static getProperty(abbv, {isIgnoreMissing=false}={}) {
        if (!isIgnoreMissing && !Renderer.item._propertyMap[abbv])
            throw new Error(`Item property ${abbv} not found. You probably meant to load the property reference first.`);
        return Renderer.item._propertyMap[abbv];
    }

    static _typeMap = {};
    static _addType(typ) {
        if (Renderer.item._typeMap[typ.abbreviation]?.entries || Renderer.item._typeMap[typ.abbreviation]?.entriesTemplate)
            return;
        const cpy = MiscUtil.copyFast(typ);

        Object.entries(Renderer.item._typeMap[typ.abbreviation] || {}).forEach(([k,v])=>{
            if (cpy[k])
                return;
            cpy[k] = v;
        }
        );

        cpy.name = cpy.name || (cpy.entries || cpy.entriesTemplate)[0].name.toLowerCase();

        Renderer.item._typeMap[typ.abbreviation] = cpy;
    }

    static getType(abbv) {
        if (!Renderer.item._typeMap[abbv])
            throw new Error(`Item type ${abbv} not found. You probably meant to load the type reference first.`);
        return Renderer.item._typeMap[abbv];
    }

    static entryMap = {};
    static _addEntry(ent) {
        if (Renderer.item.entryMap[ent.source]?.[ent.name])
            return;
        MiscUtil.set(Renderer.item.entryMap, ent.source, ent.name, ent);
    }

    static _additionalEntriesMap = {};
    static _addAdditionalEntries(ent) {
        if (Renderer.item._additionalEntriesMap[ent.appliesTo])
            return;
        Renderer.item._additionalEntriesMap[ent.appliesTo] = MiscUtil.copyFast(ent.entries);
    }

    static _masteryMap = {};
    static _addMastery(ent) {
        const lookupSource = ent.source.toLowerCase();
        const lookupName = ent.name.toLowerCase();
        if (Renderer.item._masteryMap[lookupSource]?.[lookupName])
            return;
        MiscUtil.set(Renderer.item._masteryMap, lookupSource, lookupName, ent);
    }

    static _getMastery(uid) {
        const {name, source} = DataUtil.proxy.unpackUid("itemMastery", uid, "itemMastery", {
            isLower: true
        });
        const out = MiscUtil.get(Renderer.item._masteryMap, source, name);
        if (!out)
            throw new Error(`Item mastry ${uid} not found. You probably meant to load the mastery reference first.`);
        return out;
    }

    static async _pAddPrereleaseBrewPropertiesAndTypes() {
        if (typeof PrereleaseUtil !== "undefined")
            Renderer.item.addPrereleaseBrewPropertiesAndTypesFrom({
                data: await PrereleaseUtil.pGetBrewProcessed()
            });
        if (typeof BrewUtil2 !== "undefined")
            Renderer.item.addPrereleaseBrewPropertiesAndTypesFrom({
                data: await BrewUtil2.pGetBrewProcessed()
            });
    }

    static addPrereleaseBrewPropertiesAndTypesFrom({data}) {
        (data.itemProperty || []).forEach(it=>Renderer.item._addProperty(it));
        (data.itemType || []).forEach(it=>Renderer.item._addType(it));
        (data.itemEntry || []).forEach(it=>Renderer.item._addEntry(it));
        (data.itemTypeAdditionalEntries || []).forEach(it=>Renderer.item._addAdditionalEntries(it));
        (data.itemMastery || []).forEach(it=>Renderer.item._addMastery(it));
    }

    static _addBasePropertiesAndTypes(baseItemData) {
        Object.entries(Parser.ITEM_TYPE_JSON_TO_ABV).forEach(([abv,name])=>Renderer.item._addType({
            abbreviation: abv,
            name
        }));

        (baseItemData.itemProperty || []).forEach(it=>Renderer.item._addProperty(it));
        (baseItemData.itemType || []).forEach(it=>Renderer.item._addType(it));
        (baseItemData.itemEntry || []).forEach(it=>Renderer.item._addEntry(it));
        (baseItemData.itemTypeAdditionalEntries || []).forEach(it=>Renderer.item._addAdditionalEntries(it));
        (baseItemData.itemMastery || []).forEach(it=>Renderer.item._addMastery(it));

        baseItemData.baseitem.forEach(it=>it._isBaseItem = true);
    }

    static async _pGetSiteUnresolvedRefItems_pLoadItems() {
        const itemData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items.json`);
        const items = itemData.item;
        itemData.itemGroup.forEach(it=>it._isItemGroup = true);
        return [...items, ...itemData.itemGroup];
    }

    static async pGetSiteUnresolvedRefItems() {
        const itemList = await Renderer.item._pGetSiteUnresolvedRefItems_pLoadItems();
        const baseItemsJson = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items-base.json`);
        const baseItems = await Renderer.item._pGetAndProcBaseItems(baseItemsJson);
        const {genericVariants, linkedLootTables} = await Renderer.item._pGetCacheSiteGenericVariants();
        const specificVariants = Renderer.item._createSpecificVariants(baseItems, genericVariants, {
            linkedLootTables
        });
        const allItems = [...itemList, ...baseItems, ...genericVariants, ...specificVariants];
        Renderer.item._enhanceItems(allItems);

        return {
            item: allItems,
            itemEntry: baseItemsJson.itemEntry,
        };
    }

    static _pGettingSiteGenericVariants = null;
    static async _pGetCacheSiteGenericVariants() {
        Renderer.item._pGettingSiteGenericVariants = Renderer.item._pGettingSiteGenericVariants || (async()=>{
            const [genericVariants,linkedLootTables] = Renderer.item._getAndProcGenericVariants(await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/magicvariants.json`));
            return {
                genericVariants,
                linkedLootTables
            };
        }
        )();
        return Renderer.item._pGettingSiteGenericVariants;
    }

    static async pBuildList() {
        return DataLoader.pCacheAndGetAllSite(UrlUtil.PG_ITEMS);
    }

    static async _pGetAndProcBaseItems(baseItemData) {
        Renderer.item._addBasePropertiesAndTypes(baseItemData);
        await Renderer.item._pAddPrereleaseBrewPropertiesAndTypes();
        return baseItemData.baseitem;
    }

    static _getAndProcGenericVariants(variantData) {
        variantData.magicvariant.forEach(Renderer.item._genericVariants_addInheritedPropertiesToSelf);
        return [variantData.magicvariant, variantData.linkedLootTables];
    }

    static _initFullEntries(item) {
        Renderer.utils.initFullEntries_(item);
    }

    static _initFullAdditionalEntries(item) {
        Renderer.utils.initFullEntries_(item, {
            propEntries: "additionalEntries",
            propFullEntries: "_fullAdditionalEntries"
        });
    }

    static _createSpecificVariants(baseItems, genericVariants, opts) {
        opts = opts || {};

        const genericAndSpecificVariants = [];
        baseItems.forEach((curBaseItem)=>{
            curBaseItem._category = "Basic";
            if (curBaseItem.entries == null)
                curBaseItem.entries = [];

            if (curBaseItem.packContents)
                return;
            genericVariants.forEach((curGenericVariant)=>{
                if (!Renderer.item._createSpecificVariants_hasRequiredProperty(curBaseItem, curGenericVariant))
                    return;
                if (Renderer.item._createSpecificVariants_hasExcludedProperty(curBaseItem, curGenericVariant))
                    return;

                genericAndSpecificVariants.push(Renderer.item._createSpecificVariants_createSpecificVariant(curBaseItem, curGenericVariant, opts));
            }
            );
        }
        );
        return genericAndSpecificVariants;
    }

    static _createSpecificVariants_hasRequiredProperty(baseItem, genericVariant) {
        return genericVariant.requires.some(req=>Renderer.item._createSpecificVariants_isRequiresExcludesMatch(baseItem, req, "every"));
    }

    static _createSpecificVariants_hasExcludedProperty(baseItem, genericVariant) {
        const curExcludes = genericVariant.excludes || {};
        return Renderer.item._createSpecificVariants_isRequiresExcludesMatch(baseItem, genericVariant.excludes, "some");
    }

    static _createSpecificVariants_isRequiresExcludesMatch(candidate, requirements, method) {
        if (candidate == null || requirements == null)
            return false;

        return Object.entries(requirements)[method](([reqKey,reqVal])=>{
            if (reqVal instanceof Array) {
                return candidate[reqKey]instanceof Array ? candidate[reqKey].some(it=>reqVal.includes(it)) : reqVal.includes(candidate[reqKey]);
            }

            if (reqVal != null && typeof reqVal === "object") {
                return Renderer.item._createSpecificVariants_isRequiresExcludesMatch(candidate[reqKey], reqVal, method);
            }

            return candidate[reqKey]instanceof Array ? candidate[reqKey].some(it=>reqVal === it) : reqVal === candidate[reqKey];
        }
        );
    }

    static _createSpecificVariants_createSpecificVariant(baseItem, genericVariant, opts) {
        const inherits = genericVariant.inherits;
        const specificVariant = MiscUtil.copyFast(baseItem);

        specificVariant.__prop = "item";

        delete specificVariant._isBaseItem;

        specificVariant._isEnhanced = false;
        delete specificVariant._fullEntries;

        specificVariant._baseName = baseItem.name;
        specificVariant._baseSrd = baseItem.srd;
        specificVariant._baseBasicRules = baseItem.basicRules;
        if (baseItem.source !== inherits.source)
            specificVariant._baseSource = baseItem.source;

        specificVariant._variantName = genericVariant.name;

        delete specificVariant.value;

        delete specificVariant.srd;
        delete specificVariant.basicRules;
        delete specificVariant.page;

        delete specificVariant.hasFluff;
        delete specificVariant.hasFluffImages;

        specificVariant._category = "Specific Variant";
        Object.entries(inherits).forEach(([inheritedProperty,val])=>{
            switch (inheritedProperty) {
            case "namePrefix":
                specificVariant.name = `${val}${specificVariant.name}`;
                break;
            case "nameSuffix":
                specificVariant.name = `${specificVariant.name}${val}`;
                break;
            case "entries":
                {
                    Renderer.item._initFullEntries(specificVariant);

                    const appliedPropertyEntries = Renderer.applyAllProperties(val, Renderer.item._getInjectableProps(baseItem, inherits));
                    appliedPropertyEntries.forEach((ent,i)=>specificVariant._fullEntries.splice(i, 0, ent));
                    break;
                }
            case "vulnerable":
            case "resist":
            case "immune":
                {
                    break;
                }
            case "conditionImmune":
                {
                    specificVariant[inheritedProperty] = [...specificVariant[inheritedProperty] || [], ...val].unique();
                    break;
                }
            case "nameRemove":
                {
                    specificVariant.name = specificVariant.name.replace(new RegExp(val.escapeRegexp(),"g"), "");

                    break;
                }
            case "weightExpression":
            case "valueExpression":
                {
                    const exp = Renderer.item._createSpecificVariants_evaluateExpression(baseItem, specificVariant, inherits, inheritedProperty);

                    const result = Renderer.dice.parseRandomise2(exp);
                    if (result != null) {
                        switch (inheritedProperty) {
                        case "weightExpression":
                            specificVariant.weight = result;
                            break;
                        case "valueExpression":
                            specificVariant.value = result;
                            break;
                        }
                    }

                    break;
                }
            case "barding":
                {
                    specificVariant.bardingType = baseItem.type;
                    break;
                }
            case "propertyAdd":
                {
                    specificVariant.property = [...(specificVariant.property || []), ...val.filter(it=>!specificVariant.property || !specificVariant.property.includes(it)), ];
                    break;
                }
            case "propertyRemove":
                {
                    if (specificVariant.property) {
                        specificVariant.property = specificVariant.property.filter(it=>!val.includes(it));
                        if (!specificVariant.property.length)
                            delete specificVariant.property;
                    }
                    break;
                }
            default:
                specificVariant[inheritedProperty] = val;
            }
        }
        );

        Renderer.item._createSpecificVariants_mergeVulnerableResistImmune({
            specificVariant,
            inherits
        });

        genericVariant.variants = genericVariant.variants || [];
        if (!genericVariant.variants.some(it=>it.base?.name === baseItem.name && it.base?.source === baseItem.source))
            genericVariant.variants.push({
                base: baseItem,
                specificVariant
            });

        specificVariant.genericVariant = {
            name: genericVariant.name,
            source: genericVariant.source,
        };

        if (opts.linkedLootTables && opts.linkedLootTables[specificVariant.source] && opts.linkedLootTables[specificVariant.source][specificVariant.name]) {
            (specificVariant.lootTables = specificVariant.lootTables || []).push(...opts.linkedLootTables[specificVariant.source][specificVariant.name]);
        }

        if (baseItem.source !== Parser.SRC_PHB && baseItem.source !== Parser.SRC_DMG) {
            Renderer.item._initFullEntries(specificVariant);
            specificVariant._fullEntries.unshift({
                type: "wrapper",
                wrapped: `{@note The {@item ${baseItem.name}|${baseItem.source}|base item} can be found in ${Parser.sourceJsonToFull(baseItem.source)}${baseItem.page ? `, page ${baseItem.page}` : ""}.}`,
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "note",
                },
            });
        }

        return specificVariant;
    }

    static _createSpecificVariants_evaluateExpression(baseItem, specificVariant, inherits, inheritedProperty) {
        return inherits[inheritedProperty].replace(/\[\[([^\]]+)]]/g, (...m)=>{
            const propPath = m[1].split(".");
            return propPath[0] === "item" ? MiscUtil.get(specificVariant, ...propPath.slice(1)) : propPath[0] === "baseItem" ? MiscUtil.get(baseItem, ...propPath.slice(1)) : MiscUtil.get(specificVariant, ...propPath);
        }
        );
    }

    static _PROPS_VULN_RES_IMMUNE = ["vulnerable", "resist", "immune", ];
    static _createSpecificVariants_mergeVulnerableResistImmune({specificVariant, inherits}) {
        const fromBase = {};
        Renderer.item._PROPS_VULN_RES_IMMUNE.filter(prop=>specificVariant[prop]).forEach(prop=>fromBase[prop] = [...specificVariant[prop]]);

        Renderer.item._PROPS_VULN_RES_IMMUNE.forEach(prop=>{
            const val = inherits[prop];

            if (val === undefined)
                return;

            if (val == null)
                return delete fromBase[prop];

            const valSet = new Set();
            val.forEach(it=>{
                if (typeof it === "string")
                    valSet.add(it);
                if (!it?.[prop]?.length)
                    return;
                it?.[prop].forEach(itSub=>{
                    if (typeof itSub === "string")
                        valSet.add(itSub);
                }
                );
            }
            );

            Renderer.item._PROPS_VULN_RES_IMMUNE.filter(it=>it !== prop).forEach(propOther=>{
                if (!fromBase[propOther])
                    return;

                fromBase[propOther] = fromBase[propOther].filter(it=>{
                    if (typeof it === "string")
                        return !valSet.has(it);

                    if (it?.[propOther]?.length) {
                        it[propOther] = it[propOther].filter(itSub=>{
                            if (typeof itSub === "string")
                                return !valSet.has(itSub);
                            return true;
                        }
                        );
                    }

                    return true;
                }
                );

                if (!fromBase[propOther].length)
                    delete fromBase[propOther];
            }
            );
        }
        );

        Renderer.item._PROPS_VULN_RES_IMMUNE.forEach(prop=>{
            if (fromBase[prop] || inherits[prop])
                specificVariant[prop] = [...(fromBase[prop] || []), ...(inherits[prop] || [])].unique();
            else
                delete specificVariant[prop];
        }
        );
    }

    static _enhanceItems(allItems) {
        allItems.forEach((item)=>Renderer.item.enhanceItem(item));
        return allItems;
    }

    static async pGetGenericAndSpecificVariants(genericVariants, opts) {
        opts = opts || {};

        let baseItems;
        if (opts.baseItems) {
            baseItems = opts.baseItems;
        } else {
            const baseItemData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items-base.json`);
            Renderer.item._addBasePropertiesAndTypes(baseItemData);
            baseItems = [...baseItemData.baseitem, ...(opts.additionalBaseItems || [])];
        }

        await Renderer.item._pAddPrereleaseBrewPropertiesAndTypes();
        genericVariants.forEach(Renderer.item._genericVariants_addInheritedPropertiesToSelf);
        const specificVariants = Renderer.item._createSpecificVariants(baseItems, genericVariants);
        const outSpecificVariants = Renderer.item._enhanceItems(specificVariants);

        if (opts.isSpecificVariantsOnly)
            return outSpecificVariants;

        const outGenericVariants = Renderer.item._enhanceItems(genericVariants);
        return [...outGenericVariants, ...outSpecificVariants];
    }

    static _getInjectableProps(baseItem, inherits) {
        return {
            baseName: baseItem.name,
            dmgType: baseItem.dmgType ? Parser.dmgTypeToFull(baseItem.dmgType) : null,
            bonusAc: inherits.bonusAc,
            bonusWeapon: inherits.bonusWeapon,
            bonusWeaponAttack: inherits.bonusWeaponAttack,
            bonusWeaponDamage: inherits.bonusWeaponDamage,
            bonusWeaponCritDamage: inherits.bonusWeaponCritDamage,
            bonusSpellAttack: inherits.bonusSpellAttack,
            bonusSpellSaveDc: inherits.bonusSpellSaveDc,
            bonusSavingThrow: inherits.bonusSavingThrow,
        };
    }

    static _INHERITED_PROPS_BLOCKLIST = new Set(["entries", "rarity",
    "namePrefix", "nameSuffix", ]);
    static _genericVariants_addInheritedPropertiesToSelf(genericVariant) {
        if (genericVariant._isInherited)
            return;
        genericVariant._isInherited = true;

        for (const prop in genericVariant.inherits) {
            if (Renderer.item._INHERITED_PROPS_BLOCKLIST.has(prop))
                continue;

            const val = genericVariant.inherits[prop];

            if (val == null)
                delete genericVariant[prop];
            else if (genericVariant[prop]) {
                if (genericVariant[prop]instanceof Array && val instanceof Array)
                    genericVariant[prop] = MiscUtil.copyFast(genericVariant[prop]).concat(val);
                else
                    genericVariant[prop] = val;
            } else
                genericVariant[prop] = genericVariant.inherits[prop];
        }

        if (!genericVariant.entries && genericVariant.inherits.entries) {
            genericVariant.entries = MiscUtil.copyFast(Renderer.applyAllProperties(genericVariant.inherits.entries, genericVariant.inherits));
        }

        if (genericVariant.inherits.rarity == null)
            delete genericVariant.rarity;
        else if (genericVariant.inherits.rarity === "varies") {} else
            genericVariant.rarity = genericVariant.inherits.rarity;

        if (genericVariant.requires.armor)
            genericVariant.armor = genericVariant.requires.armor;
    }

    static getItemTypeName(t) {
        return Renderer.item.getType(t).name?.toLowerCase() || t;
    }

    static enhanceItem(item) {
        if (item._isEnhanced)
            return;
        item._isEnhanced = true;
        if (item.noDisplay)
            return;
        if (item.type === "GV")
            item._category = "Generic Variant";
        if (item._category == null)
            item._category = "Other";
        if (item.entries == null)
            item.entries = [];
        if (item.type && (Renderer.item.getType(item.type)?.entries || Renderer.item.getType(item.type)?.entriesTemplate)) {
            Renderer.item._initFullEntries(item);

            const propetyEntries = Renderer.item._enhanceItem_getItemPropertyTypeEntries({
                item,
                ent: Renderer.item.getType(item.type)
            });
            propetyEntries.forEach(e=>item._fullEntries.push({
                type: "wrapper",
                wrapped: e,
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                }
            }));
        }
        if (item.property) {
            item.property.forEach(p=>{
                const entProperty = Renderer.item.getProperty(p);
                if (!entProperty.entries && !entProperty.entriesTemplate)
                    return;

                Renderer.item._initFullEntries(item);

                const propetyEntries = Renderer.item._enhanceItem_getItemPropertyTypeEntries({
                    item,
                    ent: entProperty
                });
                propetyEntries.forEach(e=>item._fullEntries.push({
                    type: "wrapper",
                    wrapped: e,
                    data: {
                        [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "property"
                    }
                }));
            }
            );
        }
        if (item.type === "LA" || item.type === "MA" || item.type === "HA") {
            if (item.stealth) {
                Renderer.item._initFullEntries(item);
                item._fullEntries.push({
                    type: "wrapper",
                    wrapped: "The wearer has disadvantage on Dexterity ({@skill Stealth}) checks.",
                    data: {
                        [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                    }
                });
            }
            if (item.type === "HA" && item.strength) {
                Renderer.item._initFullEntries(item);
                item._fullEntries.push({
                    type: "wrapper",
                    wrapped: `If the wearer has a Strength score lower than ${item.strength}, their speed is reduced by 10 feet.`,
                    data: {
                        [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                    }
                });
            }
        }
        if (item.type === "SCF") {
            if (item._isItemGroup) {
                if (item.scfType === "arcane" && item.source !== Parser.SRC_ERLW) {
                    Renderer.item._initFullEntries(item);
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "An arcane focus is a special item\u2014an orb, a crystal, a rod, a specially constructed staff, a wand-like length of wood, or some similar item\u2014designed to channel the power of arcane spells. A sorcerer, warlock, or wizard can use such an item as a spellcasting focus.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
                if (item.scfType === "druid") {
                    Renderer.item._initFullEntries(item);
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "A druidic focus might be a sprig of mistletoe or holly, a wand or scepter made of yew or another special wood, a staff drawn whole out of a living tree, or a totem object incorporating feathers, fur, bones, and teeth from sacred animals. A druid can use such an object as a spellcasting focus.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
                if (item.scfType === "holy") {
                    Renderer.item._initFullEntries(item);
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "A holy symbol is a representation of a god or pantheon. It might be an amulet depicting a symbol representing a deity, the same symbol carefully engraved or inlaid as an emblem on a shield, or a tiny box holding a fragment of a sacred relic. A cleric or paladin can use a holy symbol as a spellcasting focus. To use the symbol in this way, the caster must hold it in hand, wear it visibly, or bear it on a shield.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
            } else {
                if (item.scfType === "arcane") {
                    Renderer.item._initFullEntries(item);
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "An arcane focus is a special item designed to channel the power of arcane spells. A sorcerer, warlock, or wizard can use such an item as a spellcasting focus.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
                if (item.scfType === "druid") {
                    Renderer.item._initFullEntries(item);
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "A druid can use this object as a spellcasting focus.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
                if (item.scfType === "holy") {
                    Renderer.item._initFullEntries(item);

                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "A holy symbol is a representation of a god or pantheon.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                    item._fullEntries.push({
                        type: "wrapper",
                        wrapped: "A cleric or paladin can use a holy symbol as a spellcasting focus. To use the symbol in this way, the caster must hold it in hand, wear it visibly, or bear it on a shield.",
                        data: {
                            [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type.SCF"
                        }
                    });
                }
            }
        }

        (item.mastery || []).forEach(uid=>{
            const mastery = Renderer.item._getMastery(uid);

            if (!mastery)
                throw new Error(`Item mastery ${uid} not found. You probably meant to load the property/type reference first; see \`Renderer.item.pPopulatePropertyAndTypeReference()\`.`);
            if (!mastery.entries && !mastery.entriesTemplate)
                return;

            Renderer.item._initFullEntries(item);

            item._fullEntries.push({
                type: "wrapper",
                wrapped: {
                    type: "entries",
                    name: `Mastery: ${mastery.name}`,
                    source: mastery.source,
                    page: mastery.page,
                    entries: Renderer.item._enhanceItem_getItemPropertyTypeEntries({
                        item,
                        ent: mastery
                    }),
                },
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "mastery",
                },
            });
        }
        );

        if (item.type === "T" || item.type === "AT" || item.type === "INS" || item.type === "GS") {
            Renderer.item._initFullAdditionalEntries(item);
            item._fullAdditionalEntries.push({
                type: "wrapper",
                wrapped: {
                    type: "hr"
                },
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                }
            });
            item._fullAdditionalEntries.push({
                type: "wrapper",
                wrapped: `{@note See the {@variantrule Tool Proficiencies|XGE} entry for more information.}`,
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                }
            });
        }

        if (item.type === "INS" || item.type === "GS")
            item.additionalSources = item.additionalSources || [];
        if (item.type === "INS") {
            if (!item.additionalSources.find(it=>it.source === "XGE" && it.page === 83))
                item.additionalSources.push({
                    "source": "XGE",
                    "page": 83
                });
        } else if (item.type === "GS") {
            if (!item.additionalSources.find(it=>it.source === "XGE" && it.page === 81))
                item.additionalSources.push({
                    "source": "XGE",
                    "page": 81
                });
        }

        if (item.type && Renderer.item._additionalEntriesMap[item.type]) {
            Renderer.item._initFullAdditionalEntries(item);
            const additional = Renderer.item._additionalEntriesMap[item.type];
            item._fullAdditionalEntries.push({
                type: "wrapper",
                wrapped: {
                    type: "entries",
                    entries: additional
                },
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"
                }
            });
        }

        const [typeListText,typeHtml,subTypeHtml] = Renderer.item.getHtmlAndTextTypes(item);
        item._typeListText = typeListText;
        item._typeHtml = typeHtml;
        item._subTypeHtml = subTypeHtml;

        const [attune,attuneCat] = Renderer.item.getAttunementAndAttunementCatText(item);
        item._attunement = attune;
        item._attunementCategory = attuneCat;

        if (item.reqAttuneAlt) {
            const [attuneAlt,attuneCatAlt] = Renderer.item.getAttunementAndAttunementCatText(item, "reqAttuneAlt");
            item._attunementCategory = [attuneCat, attuneCatAlt];
        }

        if (item._isItemGroup) {
            Renderer.item._initFullEntries(item);
            item._fullEntries.push({
                type: "wrapper",
                wrapped: "Multiple variations of this item exist, as listed below:",
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "magicvariant"
                }
            });
            item._fullEntries.push({
                type: "wrapper",
                wrapped: {
                    type: "list",
                    items: item.items.map(it=>typeof it === "string" ? `{@item ${it}}` : `{@item ${it.name}|${it.source}}`),
                },
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "magicvariant"
                },
            });
        }

        if (item.variants && item.variants.length) {
            item.variants.sort((a,b)=>SortUtil.ascSortLower(a.base.name, b.base.name) || SortUtil.ascSortLower(a.base.source, b.base.source));

            Renderer.item._initFullEntries(item);
            item._fullEntries.push({
                type: "wrapper",
                wrapped: {
                    type: "entries",
                    name: "Base items",
                    entries: ["This item variant can be applied to the following base items:", {
                        type: "list",
                        items: item.variants.map(({base, specificVariant})=>{
                            return `{@item ${base.name}|${base.source}} ({@item ${specificVariant.name}|${specificVariant.source}})`;
                        }
                        ),
                    }, ],
                },
                data: {
                    [VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "magicvariant"
                },
            });
        }
    }

    static _enhanceItem_getItemPropertyTypeEntries({item, ent}) {
        if (!ent.entriesTemplate)
            return MiscUtil.copyFast(ent.entries);
        return MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
        }).walk(MiscUtil.copyFast(ent.entriesTemplate), {
            string: (str)=>{
                return Renderer.utils.applyTemplate(item, str, );
            }
            ,
        }, );
    }

    static unenhanceItem(item) {
        if (!item._isEnhanced)
            return;
        delete item._isEnhanced;
        delete item._fullEntries;
    }

    static async pGetSiteUnresolvedRefItemsFromPrereleaseBrew({brewUtil, brew=null}) {
        if (brewUtil == null && brew == null)
            return [];

        brew = brew || await brewUtil.pGetBrewProcessed();

        (brew.itemProperty || []).forEach(p=>Renderer.item._addProperty(p));
        (brew.itemType || []).forEach(t=>Renderer.item._addType(t));
        (brew.itemEntry || []).forEach(it=>Renderer.item._addEntry(it));
        (brew.itemTypeAdditionalEntries || []).forEach(it=>Renderer.item._addAdditionalEntries(it));

        let items = [...(brew.baseitem || []), ...(brew.item || [])];

        if (brew.itemGroup) {
            const itemGroups = MiscUtil.copyFast(brew.itemGroup);
            itemGroups.forEach(it=>it._isItemGroup = true);
            items = [...items, ...itemGroups];
        }

        Renderer.item._enhanceItems(items);

        let isReEnhanceVariants = false;

        if (brew.baseitem && brew.baseitem.length) {
            isReEnhanceVariants = true;

            const {genericVariants} = await Renderer.item._pGetCacheSiteGenericVariants();

            const variants = await Renderer.item.pGetGenericAndSpecificVariants(genericVariants, {
                baseItems: brew.baseitem || [],
                isSpecificVariantsOnly: true
            }, );
            items = [...items, ...variants];
        }

        if (brew.magicvariant && brew.magicvariant.length) {
            isReEnhanceVariants = true;

            const variants = await Renderer.item.pGetGenericAndSpecificVariants(brew.magicvariant, {
                additionalBaseItems: brew.baseitem || []
            }, );
            items = [...items, ...variants];
        }

        if (isReEnhanceVariants) {
            const {genericVariants} = await Renderer.item._pGetCacheSiteGenericVariants();
            genericVariants.forEach(item=>{
                Renderer.item.unenhanceItem(item);
                Renderer.item.enhanceItem(item);
            }
            );
        }

        return items;
    }

    static async pGetItemsFromPrerelease() {
        return DataLoader.pCacheAndGetAllPrerelease(UrlUtil.PG_ITEMS);
    }

    static async pGetItemsFromBrew() {
        return DataLoader.pCacheAndGetAllBrew(UrlUtil.PG_ITEMS);
    }

    static _pPopulatePropertyAndTypeReference = null;
    static pPopulatePropertyAndTypeReference() {
        return Renderer.item._pPopulatePropertyAndTypeReference || (async()=>{
            const data = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items-base.json`);

            Object.entries(Parser.ITEM_TYPE_JSON_TO_ABV).forEach(([abv,name])=>Renderer.item._addType({
                abbreviation: abv,
                name
            }));
            data.itemProperty.forEach(p=>Renderer.item._addProperty(p));
            data.itemType.forEach(t=>Renderer.item._addType(t));
            data.itemEntry.forEach(it=>Renderer.item._addEntry(it));
            data.itemTypeAdditionalEntries.forEach(e=>Renderer.item._addAdditionalEntries(e));

            await Renderer.item._pAddPrereleaseBrewPropertiesAndTypes();
        }
        )();
    }

    static async getAllIndexableItems(rawVariants, rawBaseItems) {
        const basicItems = await Renderer.item._pGetAndProcBaseItems(rawBaseItems);
        const [genericVariants,linkedLootTables] = await Renderer.item._getAndProcGenericVariants(rawVariants);
        const specificVariants = Renderer.item._createSpecificVariants(basicItems, genericVariants, {
            linkedLootTables
        });

        [...genericVariants, ...specificVariants].forEach(item=>{
            if (item.variants)
                delete item.variants;
        }
        );

        return specificVariants;
    }

    static isMundane(item) {
        return item.rarity === "none" || item.rarity === "unknown" || item._category === "Basic";
    }

    static isExcluded(item, {hash=null}={}) {
        const name = item.name;
        const source = item.source || item.inherits?.source;

        hash = hash || UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
            name,
            source
        });

        if (ExcludeUtil.isExcluded(hash, "item", source))
            return true;

        if (item._isBaseItem)
            return ExcludeUtil.isExcluded(hash, "baseitem", source);
        if (item._isItemGroup)
            return ExcludeUtil.isExcluded(hash, "itemGroup", source);
        if (item._variantName) {
            if (ExcludeUtil.isExcluded(hash, "_specificVariant", source))
                return true;

            const baseHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
                name: item._baseName,
                source: item._baseSource || source
            });
            if (ExcludeUtil.isExcluded(baseHash, "baseitem", item._baseSource || source))
                return true;

            const variantHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
                name: item._variantName,
                source: source
            });
            return ExcludeUtil.isExcluded(variantHash, "magicvariant", source);
        }
        if (item.type === "GV")
            return ExcludeUtil.isExcluded(hash, "magicvariant", source);

        return false;
    }

    static pGetFluff(item) {
        return Renderer.utils.pGetFluff({
            entity: item,
            fnGetFluffData: DataUtil.itemFluff.loadJSON.bind(DataUtil.itemFluff),
            fluffProp: "itemFluff",
        });
    }
}
;

Renderer.psionic = class {
    static enhanceMode(mode) {
        if (mode._isEnhanced)
            return;

        mode.name = [mode.name, Renderer.psionic._enhanceMode_getModeTitleBracketPart({
            mode: mode
        })].filter(Boolean).join(" ");

        if (mode.submodes) {
            mode.submodes.forEach(sm=>{
                sm.name = [sm.name, Renderer.psionic._enhanceMode_getModeTitleBracketPart({
                    mode: sm
                })].filter(Boolean).join(" ");
            }
            );
        }

        mode._isEnhanced = true;
    }

    static _enhanceMode_getModeTitleBracketPart({mode}) {
        const modeTitleBracketArray = [];

        if (mode.cost)
            modeTitleBracketArray.push(Renderer.psionic._enhanceMode_getModeTitleCost({
                mode
            }));
        if (mode.concentration)
            modeTitleBracketArray.push(Renderer.psionic._enhanceMode_getModeTitleConcentration({
                mode
            }));

        if (modeTitleBracketArray.length === 0)
            return null;
        return `(${modeTitleBracketArray.join("; ")})`;
    }

    static _enhanceMode_getModeTitleCost({mode}) {
        const costMin = mode.cost.min;
        const costMax = mode.cost.max;
        const costString = costMin === costMax ? costMin : `${costMin}-${costMax}`;
        return `${costString} psi`;
    }

    static _enhanceMode_getModeTitleConcentration({mode}) {
        return `conc., ${mode.concentration.duration} ${mode.concentration.unit}.`;
    }

    static getPsionicRenderableEntriesMeta(ent) {
        const entriesContent = [];

        return {
            entryTypeOrder: `{@i ${Renderer.psionic.getTypeOrderString(ent)}}`,
            entryContent: ent.entries ? {
                entries: ent.entries,
                type: "entries"
            } : null,
            entryFocus: ent.focus ? `{@b {@i Psychic Focus.}} ${ent.focus}` : null,
            entriesModes: ent.modes ? ent.modes.flatMap(mode=>Renderer.psionic._getModeEntries(mode)) : null,
        };
    }

    static _getModeEntries(mode, renderer) {
        Renderer.psionic.enhanceMode(mode);

        return [{
            type: mode.type || "entries",
            name: mode.name,
            entries: mode.entries,
        }, mode.submodes ? Renderer.psionic._getSubModesEntry(mode.submodes) : null, ].filter(Boolean);
    }

    static _getSubModesEntry(subModes) {
        return {
            type: "list",
            style: "list-hang-notitle",
            items: subModes.map(sm=>({
                type: "item",
                name: sm.name,
                entries: sm.entries,
            })),
        };
    }

    static getTypeOrderString(psi) {
        const typeMeta = Parser.psiTypeToMeta(psi.type);
        return typeMeta.hasOrder ? typeMeta.isAltDisplay ? `${typeMeta.full} (${psi.order})` : `${psi.order} ${typeMeta.full}` : typeMeta.full;
    }

    static getBodyHtml(ent, {renderer=null, entriesMeta=null}={}) {
        renderer ||= Renderer.get().setFirstSection(true);
        entriesMeta ||= Renderer.psionic.getPsionicRenderableEntriesMeta(ent);

        return `${entriesMeta.entryContent ? renderer.render(entriesMeta.entryContent) : ""}
		${entriesMeta.entryFocus ? `<p>${renderer.render(entriesMeta.entryFocus)}</p>` : ""}
		${entriesMeta.entriesModes ? entriesMeta.entriesModes.map(entry=>renderer.render(entry, 2)).join("") : ""}`;
    }

    static getCompactRenderedString(ent) {
        const renderer = Renderer.get().setFirstSection(true);
        const entriesMeta = Renderer.psionic.getPsionicRenderableEntriesMeta(ent);

        return `
			${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "psionic",
            page: UrlUtil.PG_PSIONICS
        })}
			${Renderer.utils.getNameTr(ent, {
            page: UrlUtil.PG_PSIONICS
        })}
			<tr class="text"><td colspan="6">
			<p>${renderer.render(entriesMeta.entryTypeOrder)}</p>
			${Renderer.psionic.getBodyHtml(ent, {
            renderer,
            entriesMeta
        })}
			</td></tr>
		`;
    }
}
;

Renderer.rule = class {
    static getCompactRenderedString(rule) {
        return `
			<tr><td colspan="6">
			${Renderer.get().setFirstSection(true).render(rule)}
			</td></tr>
		`;
    }
}
;

Renderer.variantrule = class {
    static getCompactRenderedString(rule) {
        const cpy = MiscUtil.copyFast(rule);
        delete cpy.name;
        return `
			${Renderer.utils.getExcludedTr({
            entity: rule,
            dataProp: "variantrule",
            page: UrlUtil.PG_VARIANTRULES
        })}
			${Renderer.utils.getNameTr(rule, {
            page: UrlUtil.PG_VARIANTRULES
        })}
			<tr><td colspan="6">
			${Renderer.get().setFirstSection(true).render(cpy)}
			</td></tr>
		`;
    }
}
;

Renderer.table = class {
    static getCompactRenderedString(it) {
        it.type = it.type || "table";
        const cpy = MiscUtil.copyFast(it);
        delete cpy.name;
        return `
			${Renderer.utils.getExcludedTr({
            entity: it,
            dataProp: "table",
            page: UrlUtil.PG_TABLES
        })}
			${Renderer.utils.getNameTr(it, {
            page: UrlUtil.PG_TABLES
        })}
			<tr><td colspan="6">
			${Renderer.get().setFirstSection(true).render(it)}
			</td></tr>
		`;
    }

    static getConvertedEncounterOrNamesTable({group, tableRaw, fnGetNameCaption, colLabel1}) {
        const getPadded = (number)=>{
            if (tableRaw.diceExpression === "d100")
                return String(number).padStart(2, "0");
            return String(number);
        }
        ;

        const nameCaption = fnGetNameCaption(group, tableRaw);
        return {
            name: nameCaption,
            type: "table",
            source: group?.source,
            page: group?.page,
            caption: nameCaption,
            colLabels: [`{@dice ${tableRaw.diceExpression}}`, colLabel1, tableRaw.rollAttitude ? `Attitude` : null, ].filter(Boolean),
            colStyles: ["col-2 text-center", tableRaw.rollAttitude ? "col-8" : "col-10", tableRaw.rollAttitude ? `col-2 text-center` : null, ].filter(Boolean),
            rows: tableRaw.table.map(it=>[`${getPadded(it.min)}${it.max != null && it.max !== it.min ? `-${getPadded(it.max)}` : ""}`, it.result, tableRaw.rollAttitude ? it.resultAttitude || "\u2014" : null, ].filter(Boolean)),
            footnotes: tableRaw.footnotes,
        };
    }

    static getConvertedEncounterTableName(group, tableRaw) {
        return `${group.name}${tableRaw.caption ? ` ${tableRaw.caption}` : ""}${/\bencounters?\b/i.test(group.name) ? "" : " Encounters"}${tableRaw.minlvl && tableRaw.maxlvl ? ` (Levels ${tableRaw.minlvl}\u2014${tableRaw.maxlvl})` : ""}`;
    }

    static getConvertedNameTableName(group, tableRaw) {
        return `${group.name} Names \u2013 ${tableRaw.option}`;
    }

    static getHeaderRowMetas(ent) {
        if (!ent.colLabels?.length && !ent.colLabelGroups?.length)
            return null;

        if (ent.colLabels?.length)
            return [ent.colLabels];

        const maxHeight = Math.max(...ent.colLabelGroups.map(clg=>clg.colLabels?.length || 0));

        const padded = ent.colLabelGroups.map(clg=>{
            const out = [...(clg.colLabels || [])];
            while (out.length < maxHeight)
                out.unshift("");
            return out;
        }
        );

        return [...new Array(maxHeight)].map((_,i)=>padded.map(lbls=>lbls[i]));
    }

    static _RE_TABLE_ROW_DASHED_NUMBERS = /^\d+([-\u2012\u2013]\d+)?/;
    static getAutoConvertedRollMode(table, {headerRowMetas}={}) {
        if (headerRowMetas === undefined)
            headerRowMetas = Renderer.table.getHeaderRowMetas(table);

        if (!headerRowMetas || headerRowMetas.last().length < 2)
            return RollerUtil.ROLL_COL_NONE;

        const rollColMode = RollerUtil.getColRollType(headerRowMetas.last()[0]);
        if (!rollColMode)
            return RollerUtil.ROLL_COL_NONE;

        if (!Renderer.table.isEveryRowRollable(table.rows))
            return RollerUtil.ROLL_COL_NONE;

        return rollColMode;
    }

    static isEveryRowRollable(rows) {
        return rows.every(row=>{
            if (!row)
                return false;
            const [cell] = row;
            return Renderer.table.isRollableCell(cell);
        }
        );
    }

    static isRollableCell(cell) {
        if (cell == null)
            return false;
        if (cell?.roll)
            return true;

        if (typeof cell === "number")
            return Number.isInteger(cell);

        return typeof cell === "string" && Renderer.table._RE_TABLE_ROW_DASHED_NUMBERS.test(cell);
    }
}
;

Renderer.vehicle = class {
    static CHILD_PROPS = ["movement", "weapon", "other", "action", "trait", "reaction", "control", "actionStation"];

    static getVehicleRenderableEntriesMeta(ent) {
        return {
            entryDamageImmunities: ent.immune ? `{@b Damage Immunities} ${Parser.getFullImmRes(ent.immune)}` : null,
            entryConditionImmunities: ent.conditionImmune ? `{@b Condition Immunities} ${Parser.getFullCondImm(ent.conditionImmune, {
                isEntry: true
            })}` : null,
        };
    }

    static getCompactRenderedString(veh, opts) {
        return Renderer.vehicle.getRenderedString(veh, {
            ...opts,
            isCompact: true
        });
    }

    static getRenderedString(ent, opts) {
        opts = opts || {};

        if (ent.upgradeType)
            return Renderer.vehicleUpgrade.getCompactRenderedString(ent, opts);

        ent.vehicleType ||= "SHIP";
        switch (ent.vehicleType) {
        case "SHIP":
            return Renderer.vehicle._getRenderedString_ship(ent, opts);
        case "SPELLJAMMER":
            return Renderer.vehicle._getRenderedString_spelljammer(ent, opts);
        case "INFWAR":
            return Renderer.vehicle._getRenderedString_infwar(ent, opts);
        case "CREATURE":
            return Renderer.monster.getCompactRenderedString(ent, {
                ...opts,
                isHideLanguages: true,
                isHideSenses: true,
                isCompact: opts.isCompact ?? false,
                page: UrlUtil.PG_VEHICLES
            });
        case "OBJECT":
            return Renderer.object.getCompactRenderedString(ent, {
                ...opts,
                isCompact: opts.isCompact ?? false,
                page: UrlUtil.PG_VEHICLES
            });
        default:
            throw new Error(`Unhandled vehicle type "${ent.vehicleType}"`);
        }
    }

    static ship = class {
        static PROPS_RENDERABLE_ENTRIES_ATTRIBUTES = ["entryCreatureCapacity", "entryCargoCapacity", "entryTravelPace", "entryTravelPaceNote", ];

        static getVehicleShipRenderableEntriesMeta(ent) {
            const entriesOtherActions = (ent.other || []).filter(it=>it.name === "Actions");
            const entriesOtherOthers = (ent.other || []).filter(it=>it.name !== "Actions");

            return {
                entrySizeDimensions: `{@i ${Parser.sizeAbvToFull(ent.size)} vehicle${ent.dimensions ? ` (${ent.dimensions.join(" by ")})` : ""}}`,
                entryCreatureCapacity: ent.capCrew != null || ent.capPassenger != null ? `{@b Creature Capacity} ${Renderer.vehicle.getShipCreatureCapacity(ent)}` : null,
                entryCargoCapacity: ent.capCargo != null ? `{@b Cargo Capacity} ${Renderer.vehicle.getShipCargoCapacity(ent)}` : null,
                entryTravelPace: ent.pace != null ? `{@b Travel Pace} ${ent.pace} miles per hour (${ent.pace * 24} miles per day)` : null,
                entryTravelPaceNote: ent.pace != null ? `[{@b Speed} ${ent.pace * 10} ft.]` : null,
                entryTravelPaceNoteTitle: ent.pace != null ? `Based on "Special Travel Pace," DMG p242` : null,

                entriesOtherActions: entriesOtherActions.length ? entriesOtherActions : null,
                entriesOtherOthers: entriesOtherOthers.length ? entriesOtherOthers : null,
            };
        }

        static getLocomotionEntries(loc) {
            return {
                type: "list",
                style: "list-hang-notitle",
                items: [{
                    type: "item",
                    name: `Locomotion (${loc.mode})`,
                    entries: loc.entries,
                }, ],
            };
        }

        static getSpeedEntries(spd) {
            return {
                type: "list",
                style: "list-hang-notitle",
                items: [{
                    type: "item",
                    name: `Speed (${spd.mode})`,
                    entries: spd.entries,
                }, ],
            };
        }

        static getActionPart_(renderer, veh) {
            return renderer.render({
                entries: veh.action
            });
        }

        static getSectionTitle_(title) {
            return `<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">${title}</h3></td></tr>`;
        }

        static getSectionHpEntriesMeta_({entry, isEach=false}) {
            return {
                entryArmorClass: entry.ac ? `{@b Armor Class} ${entry.ac}` : null,
                entryHitPoints: entry.hp ? `{@b Hit Points} ${entry.hp}${isEach ? ` each` : ""}${entry.dt ? ` (damage threshold ${entry.dt})` : ""}${entry.hpNote ? `; ${entry.hpNote}` : ""}` : null,
            };
        }

        static getSectionHpPart_(renderer, entry, isEach) {
            const entriesMetaSection = Renderer.vehicle.ship.getSectionHpEntriesMeta_({
                entry,
                isEach
            });

            const props = ["entryArmorClass", "entryHitPoints", ];

            if (!props.some(prop=>entriesMetaSection[prop]))
                return "";

            return props.map(prop=>`<div>${renderer.render(entriesMetaSection[prop])}</div>`).join("");
        }

        static getControlSection_(renderer, control) {
            if (!control)
                return "";
            return `
				<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">Control: ${control.name}</h3></td></tr>
				<tr><td colspan="6" class="mon__sect-row-inner">
				${Renderer.vehicle.ship.getSectionHpPart_(renderer, control)}
				<div class="rd__b--1">${renderer.render({
                entries: control.entries
            })}</div>
				</td></tr>
			`;
        }

        static _getMovementSection_getLocomotionSection({renderer, entry}) {
            const asList = Renderer.vehicle.ship.getLocomotionEntries(entry);
            return `<div class="rd__b--1">${renderer.render(asList)}</div>`;
        }

        static _getMovementSection_getSpeedSection({renderer, entry}) {
            const asList = Renderer.vehicle.ship.getSpeedEntries(entry);
            return `<div class="rd__b--1">${renderer.render(asList)}</div>`;
        }

        static getMovementSection_(renderer, move) {
            if (!move)
                return "";

            return `
				<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">${move.isControl ? `Control and ` : ""}Movement: ${move.name}</h3></td></tr>
				<tr><td colspan="6" class="mon__sect-row-inner">
				${Renderer.vehicle.ship.getSectionHpPart_(renderer, move)}
				${(move.locomotion || []).map(entry=>Renderer.vehicle.ship._getMovementSection_getLocomotionSection({
                renderer,
                entry
            })).join("")}
				${(move.speed || []).map(entry=>Renderer.vehicle.ship._getMovementSection_getSpeedSection({
                renderer,
                entry
            })).join("")}
				</td></tr>
			`;
        }

        static getWeaponSection_(renderer, weap) {
            return `
				<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">Weapons: ${weap.name}${weap.count ? ` (${weap.count})` : ""}</h3></td></tr>
				<tr><td colspan="6" class="mon__sect-row-inner">
				${Renderer.vehicle.ship.getSectionHpPart_(renderer, weap, !!weap.count)}
				${renderer.render({
                entries: weap.entries
            })}
				</td></tr>
			`;
        }

        static getOtherSection_(renderer, oth) {
            return `
				<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">${oth.name}</h3></td></tr>
				<tr><td colspan="6" class="mon__sect-row-inner">
				${Renderer.vehicle.ship.getSectionHpPart_(renderer, oth)}
				${renderer.render({
                entries: oth.entries
            })}
				</td></tr>
			`;
        }

        static getCrewCargoPaceSection_(ent, {entriesMetaShip=null}={}) {
            entriesMetaShip ||= Renderer.vehicle.ship.getVehicleShipRenderableEntriesMeta(ent);
            if (!Renderer.vehicle.ship.PROPS_RENDERABLE_ENTRIES_ATTRIBUTES.some(prop=>entriesMetaShip[prop]))
                return "";

            return `<tr class="text"><td colspan="6">
				${entriesMetaShip.entryCreatureCapacity ? `<div>${Renderer.get().render(entriesMetaShip.entryCreatureCapacity)}</div>` : ""}
				${entriesMetaShip.entryCargoCapacity ? `<div>${Renderer.get().render(entriesMetaShip.entryCargoCapacity)}</div>` : ""}
				${entriesMetaShip.entryTravelPace ? `<div>${Renderer.get().render(entriesMetaShip.entryTravelPace)}</div>` : ""}
				${entriesMetaShip.entryTravelPaceNote ? `<div class="ve-muted ve-small help-subtle ml-2" ${entriesMetaShip.entryTravelPaceNoteTitle ? `title="${entriesMetaShip.entryTravelPaceNote.qq()}"` : ""}>${Renderer.get().render(entriesMetaShip.entryTravelPaceNote)}</div>` : ""}
			</td></tr>`;
        }
    }
    ;

    static spelljammer = class {
        static getVehicleSpelljammerRenderableEntriesMeta(ent) {
            const ptAc = ent.hull?.ac ? `${ent.hull.ac}${ent.hull.acFrom ? ` (${ent.hull.acFrom.join(", ")})` : ""}` : "\u2014";

            const ptSpeed = ent.speed != null ? Parser.getSpeedString(ent, {
                isSkipZeroWalk: true
            }) : "";
            const ptPace = Renderer.vehicle.spelljammer._getVehicleSpelljammerRenderableEntriesMeta_getPtPace({
                ent
            });

            const ptSpeedPace = [ptSpeed, ptPace].filter(Boolean).join(" ");

            return {
                entryTableSummary: {
                    type: "table",
                    style: "summary",
                    colStyles: ["col-6", "col-6"],
                    rows: [[`{@b Armor Class:} ${ptAc}`, `{@b Cargo:} ${ent.capCargo ? `${ent.capCargo} ton${ent.capCargo === 1 ? "" : "s"}` : "\u2014"}`, ], [`{@b Hit Points:} ${ent.hull?.hp ?? "\u2014"}`, `{@b Crew:} ${ent.capCrew ?? "\u2014"}${ent.capCrewNote ? ` ${ent.capCrewNote}` : ""}`, ], [`{@b Damage Threshold:} ${ent.hull?.dt ?? "\u2014"}`, `{@b Keel/Beam:} ${(ent.dimensions || ["\u2014"]).join("/")}`, ], [`{@b Speed:} ${ptSpeedPace}`, `{@b Cost:} ${ent.cost != null ? Parser.vehicleCostToFull(ent) : "\u2014"}`, ], ],
                },
            };
        }

        static _getVehicleSpelljammerRenderableEntriesMeta_getPtPace(ent) {
            if (!ent.pace)
                return "";

            const isMulti = Object.keys(ent.pace).length > 1;

            const out = Parser.SPEED_MODES.map(mode=>{
                const pace = ent.pace[mode];
                if (!pace)
                    return null;

                const asNum = Parser.vulgarToNumber(pace);
                return `{@tip ${isMulti && mode !== "walk" ? `${mode} ` : ""}${pace} mph|${asNum * 24} miles per day}`;
            }
            ).filter(Boolean).join(", ");

            return `(${out})`;
        }

        static getSummarySection_(renderer, ent) {
            const entriesMetaSpelljammer = Renderer.vehicle.spelljammer.getVehicleSpelljammerRenderableEntriesMeta(ent);

            return `<tr><td colspan="6">${renderer.render(entriesMetaSpelljammer.entryTableSummary)}</td></tr>`;
        }

        static getSectionWeaponEntriesMeta(entry) {
            const isMultiple = entry.count != null && entry.count > 1;

            return {
                entryName: `${isMultiple ? `${entry.count} ` : ""}${entry.name}${entry.crew ? ` (Crew: ${entry.crew}${isMultiple ? " each" : ""})` : ""}`,
            };
        }

        static getWeaponSection_(renderer, entry) {
            const entriesMetaSectionWeapon = Renderer.vehicle.spelljammer.getSectionWeaponEntriesMeta(entry);

            const ptAction = entry.action?.length ? entry.action.map(act=>`<div class="mt-1">${renderer.render(act, 2)}</div>`).join("") : "";
            return `
				<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">${entriesMetaSectionWeapon.entryName}</h3></td></tr>
				<tr><td colspan="6" class="mon__sect-row-inner">
				${Renderer.vehicle.spelljammer.getSectionHpCostPart_(renderer, entry)}
				${entry.entries?.length ? `<div>${renderer.render({
                entries: entry.entries
            })}</div>` : ""}
				${ptAction}
				</td></tr>
			`;
        }

        static getSectionHpCostEntriesMeta(entry) {
            const ptCosts = entry.costs?.length ? entry.costs.map(cost=>{
                return `${Parser.vehicleCostToFull(cost) || "\u2014"}${cost.note ? ` (${cost.note})` : ""}`;
            }
            ).join(", ") : "\u2014";

            return {
                entryArmorClass: `{@b Armor Class:} ${entry.ac == null ? "\u2014" : entry.ac}`,
                entryHitPoints: `{@b Hit Points:} ${entry.hp == null ? "\u2014" : entry.hp}`,
                entryCost: `{@b Cost:} ${ptCosts}`,
            };
        }

        static getSectionHpCostPart_(renderer, entry) {
            const entriesMetaSectionHpCost = Renderer.vehicle.spelljammer.getSectionHpCostEntriesMeta(entry);

            return `
				<div>${renderer.render(entriesMetaSectionHpCost.entryArmorClass)}</div>
				<div>${renderer.render(entriesMetaSectionHpCost.entryHitPoints)}</div>
				<div class="mb-2">${renderer.render(entriesMetaSectionHpCost.entryCost)}</div>
			`;
        }
    }
    ;

    static _getAbilitySection(veh) {
        return Parser.ABIL_ABVS.some(it=>veh[it] != null) ? `<tr><td colspan="6">
			<table class="w-100 summary stripe-even-table">
				<tr>
					<th class="col-2 ve-text-center">STR</th>
					<th class="col-2 ve-text-center">DEX</th>
					<th class="col-2 ve-text-center">CON</th>
					<th class="col-2 ve-text-center">INT</th>
					<th class="col-2 ve-text-center">WIS</th>
					<th class="col-2 ve-text-center">CHA</th>
				</tr>
				<tr>
					<td class="ve-text-center">${Renderer.utils.getAbilityRoller(veh, "str")}</td>
					<td class="ve-text-center">${Renderer.utils.getAbilityRoller(veh, "dex")}</td>
					<td class="ve-text-center">${Renderer.utils.getAbilityRoller(veh, "con")}</td>
					<td class="ve-text-center">${Renderer.utils.getAbilityRoller(veh, "int")}</td>
					<td class="ve-text-center">${Renderer.utils.getAbilityRoller(veh, "wis")}</td>
					<td class="ve-text-center">${Renderer.utils.getAbilityRoller(veh, "cha")}</td>
				</tr>
			</table>
		</td></tr>` : "";
    }

    static _getResImmVulnSection(ent, {entriesMeta=null}={}) {
        entriesMeta ||= Renderer.vehicle.getVehicleRenderableEntriesMeta(ent);

        const props = ["entryDamageImmunities", "entryConditionImmunities", ];

        if (!props.some(prop=>entriesMeta[prop]))
            return "";

        return `<tr class="text"><td colspan="6">
			${props.filter(prop=>entriesMeta[prop]).map(prop=>`<div>${Renderer.get().render(entriesMeta[prop])}</div>`).join("")}
		</td></tr>`;
    }

    static _getTraitSection(renderer, veh) {
        return veh.trait ? `<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">Traits</h3></td></tr>
		<tr><td colspan="6"><div class="border"></div></td></tr>
		<tr class="text"><td colspan="6">
		${Renderer.monster.getOrderedTraits(veh, renderer).map(it=>it.rendered || renderer.render(it, 2)).join("")}
		</td></tr>` : "";
    }

    static _getRenderedString_ship(ent, opts) {
        const renderer = Renderer.get();
        const entriesMeta = Renderer.vehicle.getVehicleRenderableEntriesMeta(ent);
        const entriesMetaShip = Renderer.vehicle.ship.getVehicleShipRenderableEntriesMeta(ent);

        const hasToken = ent.tokenUrl || ent.hasToken;
        const extraThClasses = !opts.isCompact && hasToken ? ["veh__name--token"] : null;

        return `
			${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "vehicle",
            page: UrlUtil.PG_VEHICLES
        })}
			${Renderer.utils.getNameTr(ent, {
            extraThClasses,
            page: UrlUtil.PG_VEHICLES
        })}
			<tr class="text"><td colspan="6">${Renderer.get().render(entriesMetaShip.entrySizeDimensions)}</td></tr>
			${Renderer.vehicle.ship.getCrewCargoPaceSection_(ent, {
            entriesMetaShip
        })}
			${Renderer.vehicle._getAbilitySection(ent)}
			${Renderer.vehicle._getResImmVulnSection(ent, {
            entriesMeta
        })}
			${ent.action ? Renderer.vehicle.ship.getSectionTitle_("Actions") : ""}
			${ent.action ? `<tr><td colspan="6" class="mon__sect-row-inner">${Renderer.vehicle.ship.getActionPart_(renderer, ent)}</td></tr>` : ""}
			${(entriesMetaShip.entriesOtherActions || []).map(Renderer.vehicle.ship.getOtherSection_.bind(this, renderer)).join("")}
			${ent.hull ? `${Renderer.vehicle.ship.getSectionTitle_("Hull")}
			<tr><td colspan="6" class="mon__sect-row-inner">
			${Renderer.vehicle.ship.getSectionHpPart_(renderer, ent.hull)}
			</td></tr>` : ""}
			${Renderer.vehicle._getTraitSection(renderer, ent)}
			${(ent.control || []).map(Renderer.vehicle.ship.getControlSection_.bind(this, renderer)).join("")}
			${(ent.movement || []).map(Renderer.vehicle.ship.getMovementSection_.bind(this, renderer)).join("")}
			${(ent.weapon || []).map(Renderer.vehicle.ship.getWeaponSection_.bind(this, renderer)).join("")}
			${(entriesMetaShip.entriesOtherOthers || []).map(Renderer.vehicle.ship.getOtherSection_.bind(this, renderer)).join("")}
		`;
    }

    static getShipCreatureCapacity(veh) {
        return [veh.capCrew ? `${veh.capCrew} crew` : null, veh.capPassenger ? `${veh.capPassenger} passenger${veh.capPassenger === 1 ? "" : "s"}` : null, ].filter(Boolean).join(", ");
    }

    static getShipCargoCapacity(veh) {
        return typeof veh.capCargo === "string" ? veh.capCargo : `${veh.capCargo} ton${veh.capCargo === 1 ? "" : "s"}`;
    }

    static _getRenderedString_spelljammer(veh, opts) {
        const renderer = Renderer.get();

        const hasToken = veh.tokenUrl || veh.hasToken;
        const extraThClasses = !opts.isCompact && hasToken ? ["veh__name--token"] : null;

        return `
			${Renderer.utils.getExcludedTr({
            entity: veh,
            dataProp: "vehicle",
            page: UrlUtil.PG_VEHICLES
        })}
			${Renderer.utils.getNameTr(veh, {
            extraThClasses,
            page: UrlUtil.PG_VEHICLES
        })}
			${Renderer.vehicle.spelljammer.getSummarySection_(renderer, veh)}
			${(veh.weapon || []).map(Renderer.vehicle.spelljammer.getWeaponSection_.bind(this, renderer)).join("")}
		`;
    }

    static infwar = class {
        static PROPS_RENDERABLE_ENTRIES_ATTRIBUTES = ["entryCreatureCapacity", "entryCargoCapacity", "entryArmorClass", "entryHitPoints", "entrySpeed", ];

        static getVehicleInfwarRenderableEntriesMeta(ent) {
            const dexMod = Parser.getAbilityModNumber(ent.dex);

            return {
                entrySizeWeight: `{@i ${Parser.sizeAbvToFull(ent.size)} vehicle (${ent.weight.toLocaleString()} lb.)}`,
                entryCreatureCapacity: `{@b Creature Capacity} ${Renderer.vehicle.getInfwarCreatureCapacity(ent)}`,
                entryCargoCapacity: `{@b Cargo Capacity} ${Parser.weightToFull(ent.capCargo)}`,
                entryArmorClass: `{@b Armor Class} ${dexMod === 0 ? `19` : `${19 + dexMod} (19 while motionless)`}`,
                entryHitPoints: `{@b Hit Points} ${ent.hp.hp} (damage threshold ${ent.hp.dt}, mishap threshold ${ent.hp.mt})`,
                entrySpeed: `{@b Speed} ${ent.speed} ft.`,
                entrySpeedNote: `[{@b Travel Pace} ${Math.floor(ent.speed / 10)} miles per hour (${Math.floor(ent.speed * 24 / 10)} miles per day)]`,
                entrySpeedNoteTitle: `Based on "Special Travel Pace," DMG p242`,
            };
        }
    }
    ;

    static _getRenderedString_infwar(ent, opts) {
        const renderer = Renderer.get();
        const entriesMeta = Renderer.vehicle.getVehicleRenderableEntriesMeta(ent);
        const entriesMetaInfwar = Renderer.vehicle.infwar.getVehicleInfwarRenderableEntriesMeta(ent);

        const hasToken = ent.tokenUrl || ent.hasToken;
        const extraThClasses = !opts.isCompact && hasToken ? ["veh__name--token"] : null;

        return `
			${Renderer.utils.getExcludedTr({
            entity: ent,
            datProp: "vehicle",
            page: UrlUtil.PG_VEHICLES
        })}
			${Renderer.utils.getNameTr(ent, {
            extraThClasses,
            page: UrlUtil.PG_VEHICLES
        })}
			<tr class="text"><td colspan="6">${renderer.render(entriesMetaInfwar.entrySizeWeight)}</td></tr>
			<tr class="text"><td colspan="6">
				${Renderer.vehicle.infwar.PROPS_RENDERABLE_ENTRIES_ATTRIBUTES.map(prop=>`<div>${renderer.render(entriesMetaInfwar[prop])}</div>`).join("")}
				<div class="ve-muted ve-small help-subtle ml-2" title="${entriesMetaInfwar.entrySpeedNoteTitle.qq()}">${renderer.render(entriesMetaInfwar.entrySpeedNote)}</div>
			</td></tr>
			${Renderer.vehicle._getAbilitySection(ent)}
			${Renderer.vehicle._getResImmVulnSection(ent, {
            entriesMeta
        })}
			${Renderer.vehicle._getTraitSection(renderer, ent)}
			${Renderer.monster.getCompactRenderedStringSection(ent, renderer, "Action Stations", "actionStation", 2)}
			${Renderer.monster.getCompactRenderedStringSection(ent, renderer, "Reactions", "reaction", 2)}
		`;
    }

    static getInfwarCreatureCapacity(veh) {
        return `${veh.capCreature} Medium creatures`;
    }

    static pGetFluff(veh) {
        return Renderer.utils.pGetFluff({
            entity: veh,
            fnGetFluffData: DataUtil.vehicleFluff.loadJSON.bind(DataUtil.vehicleFluff),
            fluffProp: "vehicleFluff",
        });
    }

    static getTokenUrl(veh) {
        return veh.tokenUrl || UrlUtil.link(`${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/vehicles/tokens/${Parser.sourceJsonToAbv(veh.source)}/${Parser.nameToTokenName(veh.name)}.png`);
    }
}
;

Renderer.vehicleUpgrade = class {
    static getUpgradeSummary(ent) {
        return [ent.upgradeType ? ent.upgradeType.map(t=>Parser.vehicleTypeToFull(t)) : null, ent.prerequisite ? Renderer.utils.prerequisite.getHtml(ent.prerequisite) : null, ].filter(Boolean).join(", ");
    }

    static getCompactRenderedString(ent, opts) {
        return `${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "vehicleUpgrade",
            page: UrlUtil.PG_VEHICLES
        })}
		${Renderer.utils.getNameTr(ent, {
            page: UrlUtil.PG_VEHICLES
        })}
		<tr><td colspan="6"><i>${Renderer.vehicleUpgrade.getUpgradeSummary(ent)}</i></td></tr>
		<tr><td class="divider" colspan="6"><div></div></td></tr>
		<tr><td colspan="6">${Renderer.get().render({
            entries: ent.entries
        }, 1)}</td></tr>`;
    }
}
;

Renderer.action = class {
    static getCompactRenderedString(it) {
        const cpy = MiscUtil.copyFast(it);
        delete cpy.name;
        return `${Renderer.utils.getExcludedTr({
            entity: it,
            dataProp: "action",
            page: UrlUtil.PG_ACTIONS
        })}
		${Renderer.utils.getNameTr(it, {
            page: UrlUtil.PG_ACTIONS
        })}
		<tr><td colspan="6">${Renderer.get().setFirstSection(true).render(cpy)}</td></tr>`;
    }
}
;

Renderer.language = class {
    static getLanguageRenderableEntriesMeta(ent) {
        const hasMeta = ent.typicalSpeakers || ent.script;

        const entriesContent = [];

        if (ent.entries)
            entriesContent.push(...ent.entries);
        if (ent.dialects) {
            entriesContent.push(`This language is a family which includes the following dialects: ${ent.dialects.sort(SortUtil.ascSortLower).join(", ")}. Creatures that speak different dialects of the same language can communicate with one another.`);
        }

        if (!entriesContent.length && !hasMeta)
            entriesContent.push("{@i No information available.}");

        return {
            entryType: ent.type ? `{@i ${ent.type.toTitleCase()} language}` : null,
            entryTypicalSpeakers: ent.typicalSpeakers ? `{@b Typical Speakers:} ${ent.typicalSpeakers.join(", ")}` : null,
            entryScript: ent.script ? `{@b Script:} ${ent.script}` : null,
            entriesContent: entriesContent.length ? entriesContent : null,
        };
    }

    static getCompactRenderedString(ent) {
        return Renderer.language.getRenderedString(ent);
    }

    static getRenderedString(ent, {isSkipNameRow=false}={}) {
        const entriesMeta = Renderer.language.getLanguageRenderableEntriesMeta(ent);

        return `
		${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "language",
            page: UrlUtil.PG_LANGUAGES
        })}
		${isSkipNameRow ? "" : Renderer.utils.getNameTr(ent, {
            page: UrlUtil.PG_LANGUAGES
        })}
		${entriesMeta.entryType ? `<tr class="text"><td colspan="6" class="pt-0">${Renderer.get().render(entriesMeta.entryType)}</td></tr>` : ""}
		${entriesMeta.entryTypicalSpeakers || entriesMeta.entryScript ? `<tr class="text"><td colspan="6">
		${[entriesMeta.entryTypicalSpeakers, entriesMeta.entryScript].filter(Boolean).map(entry=>`<div>${Renderer.get().render(entry)}</div>`).join("")}
		</td></tr>` : ""}
		${entriesMeta.entriesContent ? `<tr class="text"><td colspan="6">
		${Renderer.get().setFirstSection(true).render({
            entries: entriesMeta.entriesContent
        })}
		</td></tr>` : ""}`;
    }

    static pGetFluff(it) {
        return Renderer.utils.pGetFluff({
            entity: it,
            fnGetFluffData: DataUtil.languageFluff.loadJSON.bind(DataUtil.languageFluff),
            fluffProp: "languageFluff",
        });
    }
}
;

Renderer.adventureBook = class {
    static getEntryIdLookup(bookData, doThrowError=true) {
        const out = {};
        const titlesRel = {};
        const titlesRelChapter = {};

        let chapIx;
        const depthStack = [];
        const handlers = {
            object: (obj)=>{
                Renderer.ENTRIES_WITH_ENUMERATED_TITLES.forEach(meta=>{
                    if (obj.type !== meta.type)
                        return;

                    const curDepth = depthStack.length ? depthStack.last() : 0;
                    const nxtDepth = meta.depth ? meta.depth : meta.depthIncrement ? curDepth + meta.depthIncrement : curDepth;

                    depthStack.push(Math.min(nxtDepth, 2, ), );

                    if (obj.id) {
                        if (out[obj.id]) {
                            (out.__BAD = out.__BAD || []).push(obj.id);
                        } else {
                            out[obj.id] = {
                                chapter: chapIx,
                                entry: obj,
                                depth: depthStack.last(),
                            };

                            if (obj.name) {
                                out[obj.id].name = obj.name;

                                const cleanName = obj.name.toLowerCase();
                                out[obj.id].nameClean = cleanName;

                                titlesRel[cleanName] = titlesRel[cleanName] || 0;
                                out[obj.id].ixTitleRel = titlesRel[cleanName]++;

                                MiscUtil.getOrSet(titlesRelChapter, chapIx, cleanName, -1);
                                out[obj.id].ixTitleRelChapter = ++titlesRelChapter[chapIx][cleanName];
                            }
                        }
                    }
                }
                );

                return obj;
            }
            ,
            postObject: (obj)=>{
                Renderer.ENTRIES_WITH_ENUMERATED_TITLES.forEach(meta=>{
                    if (obj.type !== meta.type)
                        return;

                    depthStack.pop();
                }
                );
            }
            ,
        };

        bookData.forEach((chap,_chapIx)=>{
            chapIx = _chapIx;
            MiscUtil.getWalker({
                isNoModification: true
            }).walk(chap, handlers);
        }
        );

        if (doThrowError)
            if (out.__BAD)
                throw new Error(`IDs were already in storage: ${out.__BAD.map(it=>`"${it}"`).join(", ")}`);

        return out;
    }

    static _isAltMissingCoverUsed = false;
    static getCoverUrl(contents) {
        return contents.coverUrl || `${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/covers/blank${Math.random() <= 0.05 && !Renderer.adventureBook._isAltMissingCoverUsed && (Renderer.adventureBook._isAltMissingCoverUsed = true) ? "-alt" : ""}.webp`;
    }
}
;

Renderer.charoption = class {
    static getCompactRenderedString(ent) {
        const prerequisite = Renderer.utils.prerequisite.getHtml(ent.prerequisite);
        const preText = Renderer.charoption.getOptionTypePreText(ent);
        return `
		${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "charoption",
            page: UrlUtil.PG_CHAR_CREATION_OPTIONS
        })}
		${Renderer.utils.getNameTr(ent, {
            page: UrlUtil.PG_CHAR_CREATION_OPTIONS
        })}
		<tr class="text"><td colspan="6">
		${prerequisite ? `<p>${prerequisite}</p>` : ""}
		${preText || ""}${Renderer.get().setFirstSection(true).render({
            type: "entries",
            entries: ent.entries
        })}
		</td></tr>
		`;
    }

    static getCharoptionRenderableEntriesMeta(ent) {
        const optsMapped = ent.optionType.map(it=>Renderer.charoption._OPTION_TYPE_ENTRIES[it]).filter(Boolean);
        if (!optsMapped.length)
            return null;

        return {
            entryOptionType: {
                type: "entries",
                entries: optsMapped
            },
        };
    }

    static _OPTION_TYPE_ENTRIES = {
        "RF:B": `{@note You may replace the standard feature of your background with this feature.}`,
        "CS": `{@note See the {@adventure Character Secrets|IDRotF|0|character secrets} section for more information.}`,
    };

    static getOptionTypePreText(ent) {
        const meta = Renderer.charoption.getCharoptionRenderableEntriesMeta(ent);
        if (!meta)
            return "";
        return Renderer.get().render(meta.entryOptionType);
    }

    static pGetFluff(it) {
        return Renderer.utils.pGetFluff({
            entity: it,
            fnGetFluffData: DataUtil.charoptionFluff.loadJSON.bind(DataUtil.charoptionFluff),
            fluffProp: "charoptionFluff",
        });
    }
}
;

Renderer.recipe = class {
    static _getEntryMetasTime(ent) {
        if (!Object.keys(ent.time || {}).length)
            return null;

        return ["total", "preparation", "cooking", ...Object.keys(ent.time), ].unique().filter(prop=>ent.time[prop]).map((prop,i,arr)=>{
            const val = ent.time[prop];

            const ptsTime = (val.min != null && val.max != null ? [Parser.getMinutesToFull(val.min), Parser.getMinutesToFull(val.max), ] : [Parser.getMinutesToFull(val)]);

            const suffix = MiscUtil.findCommonSuffix(ptsTime, {
                isRespectWordBoundaries: true
            });
            const ptTime = ptsTime.map(it=>!suffix.length ? it : it.slice(0, -suffix.length)).join(" to ");

            return {
                entryName: `{@b {@style ${prop.toTitleCase()} Time:|small-caps}}`,
                entryContent: `${ptTime}${suffix}`,
            };
        }
        );
    }

    static getRecipeRenderableEntriesMeta(ent) {
        return {
            entryMakes: ent.makes ? `{@b {@style Makes|small-caps}} ${ent._scaleFactor ? `${ent._scaleFactor}× ` : ""}${ent.makes}` : null,
            entryServes: ent.serves ? `{@b {@style Serves|small-caps}} ${ent.serves.min ?? ent.serves.exact}${ent.serves.min != null ? " to " : ""}${ent.serves.max ?? ""}` : null,
            entryMetasTime: Renderer.recipe._getEntryMetasTime(ent),
            entryIngredients: {
                entries: ent._fullIngredients
            },
            entryEquipment: ent._fullEquipment?.length ? {
                entries: ent._fullEquipment
            } : null,
            entryCooksNotes: ent.noteCook ? {
                entries: ent.noteCook
            } : null,
            entryInstructions: {
                entries: ent.instructions
            },
        };
    }

    static getCompactRenderedString(ent) {
        return `${Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: "recipe",
            page: UrlUtil.PG_RECIPES
        })}
		${Renderer.utils.getNameTr(ent, {
            page: UrlUtil.PG_RECIPES
        })}
		<tr><td colspan="6">
		${Renderer.recipe.getBodyHtml(ent)}
		</td></tr>`;
    }

    static getBodyHtml(ent) {
        const entriesMeta = Renderer.recipe.getRecipeRenderableEntriesMeta(ent);

        const ptTime = Renderer.recipe.getTimeHtml(ent, {
            entriesMeta
        });
        const {ptMakes, ptServes} = Renderer.recipe.getMakesServesHtml(ent, {
            entriesMeta
        });

        return `<div class="ve-flex w-100 rd-recipes__wrp-recipe">
			<div class="ve-flex-1 ve-flex-col br-1p pr-2">
				${ptTime || ""}

				${ptMakes || ""}
				${ptServes || ""}

				<div class="rd-recipes__wrp-ingredients ${ptMakes || ptServes ? "mt-1" : ""}">${Renderer.get().render(entriesMeta.entryIngredients, 0)}</div>

				${entriesMeta.entryEquipment ? `<div class="rd-recipes__wrp-ingredients mt-4"><div class="ve-flex-vh-center bold mb-1 small-caps">Equipment</div><div>${Renderer.get().render(entriesMeta.entryEquipment)}</div></div>` : ""}

				${entriesMeta.entryCooksNotes ? `<div class="w-100 ve-flex-col mt-4"><div class="ve-flex-vh-center bold mb-1 small-caps">Cook's Notes</div><div class="italic">${Renderer.get().render(entriesMeta.entryCooksNotes)}</div></div>` : ""}
			</div>

			<div class="pl-2 ve-flex-2 rd-recipes__wrp-instructions overflow-x-auto">
				${Renderer.get().setFirstSection(true).render(entriesMeta.entryInstructions, 2)}
			</div>
		</div>`;
    }

    static getMakesServesHtml(ent, {entriesMeta=null}={}) {
        entriesMeta ||= Renderer.recipe.getRecipeRenderableEntriesMeta(ent);
        const ptMakes = entriesMeta.entryMakes ? `<div class="mb-2">${Renderer.get().render(entriesMeta.entryMakes)}</div>` : null;
        const ptServes = entriesMeta.entryServes ? `<div class="mb-2">${Renderer.get().render(entriesMeta.entryServes)}</div>` : null;
        return {
            ptMakes,
            ptServes
        };
    }

    static getTimeHtml(ent, {entriesMeta=null}={}) {
        entriesMeta ||= Renderer.recipe.getRecipeRenderableEntriesMeta(ent);
        if (!entriesMeta.entryMetasTime)
            return "";

        return entriesMeta.entryMetasTime.map(({entryName, entryContent},i,arr)=>{
            return `<div class="split-v-center ${i === arr.length - 1 ? "mb-2" : "mb-1p"}">
					${Renderer.get().render(entryName)}
					<span>${Renderer.get().render(entryContent)}</span>
				</div>`;
        }
        ).join("");
    }

    static pGetFluff(it) {
        return Renderer.utils.pGetFluff({
            entity: it,
            fnGetFluffData: DataUtil.recipeFluff.loadJSON.bind(DataUtil.recipeFluff),
            fluffProp: "recipeFluff",
        });
    }

    static populateFullIngredients(r) {
        r._fullIngredients = Renderer.applyAllProperties(MiscUtil.copyFast(r.ingredients));
        if (r.equipment)
            r._fullEquipment = Renderer.applyAllProperties(MiscUtil.copyFast(r.equipment));
    }

    static _RE_AMOUNT = /(?<tagAmount>{=amount\d+(?:\/[^}]+)?})/g;
    static _SCALED_PRECISION_LIMIT = 10 ** 6;
    static getScaledRecipe(r, scaleFactor) {
        const cpyR = MiscUtil.copyFast(r);

        ["ingredients", "equipment"].forEach(prop=>{
            if (!cpyR[prop])
                return;

            MiscUtil.getWalker({
                keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST
            }).walk(cpyR[prop], {
                object: (obj)=>{
                    if (obj.type !== "ingredient")
                        return obj;

                    const objOriginal = MiscUtil.copyFast(obj);

                    Object.keys(obj).filter(k=>/^amount\d+/.test(k)).forEach(k=>{
                        let base = obj[k];

                        if (Math.round(base) !== base && base < 20) {
                            const divOneSixth = obj[k] / 0.166;
                            if (Math.abs(divOneSixth - Math.round(divOneSixth)) < 0.05)
                                base = (1 / 6) * Math.round(divOneSixth);
                        }

                        let scaled = base * scaleFactor;
                        obj[k] = Math.round(base * scaleFactor * Renderer.recipe._SCALED_PRECISION_LIMIT) / Renderer.recipe._SCALED_PRECISION_LIMIT;
                    }
                    );

                    const amountsOriginal = Object.keys(objOriginal).filter(k=>/^amount\d+$/.test(k)).map(k=>objOriginal[k]);
                    const amountsScaled = Object.keys(obj).filter(k=>/^amount\d+$/.test(k)).map(k=>obj[k]);

                    const entryParts = obj.entry.split(Renderer.recipe._RE_AMOUNT).filter(Boolean);
                    const entryPartsOut = entryParts.slice(0, entryParts.findIndex(it=>Renderer.recipe._RE_AMOUNT.test(it)) + 1);
                    let ixAmount = 0;
                    for (let i = entryPartsOut.length; i < entryParts.length; ++i) {
                        let pt = entryParts[i];

                        if (Renderer.recipe._RE_AMOUNT.test(pt)) {
                            ixAmount++;
                            entryPartsOut.push(pt);
                            continue;
                        }

                        if (amountsOriginal[ixAmount] == null || amountsScaled[ixAmount] == null) {
                            entryPartsOut.push(pt);
                            continue;
                        }

                        const isSingleToPlural = amountsOriginal[ixAmount] <= 1 && amountsScaled[ixAmount] > 1;
                        const isPluralToSingle = amountsOriginal[ixAmount] > 1 && amountsScaled[ixAmount] <= 1;

                        if (!isSingleToPlural && !isPluralToSingle) {
                            entryPartsOut.push(pt);
                            continue;
                        }

                        if (isSingleToPlural)
                            pt = Renderer.recipe._getPluralizedUnits(pt);
                        else if (isPluralToSingle)
                            pt = Renderer.recipe._getSingleizedUnits(pt);
                        entryPartsOut.push(pt);
                    }

                    obj.entry = entryPartsOut.join("");

                    Renderer.recipe._mutWrapOriginalAmounts({
                        obj,
                        objOriginal
                    });

                    return obj;
                }
                ,
            }, );
        }
        );

        Renderer.recipe.populateFullIngredients(cpyR);

        if (cpyR.serves) {
            if (cpyR.serves.min)
                cpyR.serves.min *= scaleFactor;
            if (cpyR.serves.max)
                cpyR.serves.max *= scaleFactor;
            if (cpyR.serves.exact)
                cpyR.serves.exact *= scaleFactor;
        }

        cpyR._displayName = `${cpyR.name} (×${scaleFactor})`;
        cpyR._scaleFactor = scaleFactor;

        return cpyR;
    }

    static _UNITS_SINGLE_TO_PLURAL_S = ["bundle", "cup", "handful", "ounce", "packet", "piece", "pound", "slice", "sprig", "square", "strip", "tablespoon", "teaspoon", "wedge", ];
    static _UNITS_SINGLE_TO_PLURAL_ES = ["dash", "inch", ];
    static _FNS_SINGLE_TO_PLURAL = [];
    static _FNS_PLURAL_TO_SINGLE = [];

    static _getSingleizedUnits(str) {
        if (!Renderer.recipe._FNS_PLURAL_TO_SINGLE.length) {
            Renderer.recipe._FNS_PLURAL_TO_SINGLE = [...Renderer.recipe._UNITS_SINGLE_TO_PLURAL_S.map(word=>str=>str.replace(new RegExp(`\\b${word.escapeRegexp()}s\\b`,"gi"), (...m)=>m[0].slice(0, -1))), ...Renderer.recipe._UNITS_SINGLE_TO_PLURAL_ES.map(word=>str=>str.replace(new RegExp(`\\b${word.escapeRegexp()}es\\b`,"gi"), (...m)=>m[0].slice(0, -2))), ];
        }

        Renderer.recipe._FNS_PLURAL_TO_SINGLE.forEach(fn=>str = fn(str));

        return str;
    }

    static _getPluralizedUnits(str) {
        if (!Renderer.recipe._FNS_SINGLE_TO_PLURAL.length) {
            Renderer.recipe._FNS_SINGLE_TO_PLURAL = [...Renderer.recipe._UNITS_SINGLE_TO_PLURAL_S.map(word=>str=>str.replace(new RegExp(`\\b${word.escapeRegexp()}\\b`,"gi"), (...m)=>`${m[0]}s`)), ...Renderer.recipe._UNITS_SINGLE_TO_PLURAL_ES.map(word=>str=>str.replace(new RegExp(`\\b${word.escapeRegexp()}\\b`,"gi"), (...m)=>`${m[0]}es`)), ];
        }

        Renderer.recipe._FNS_SINGLE_TO_PLURAL.forEach(fn=>str = fn(str));

        return str;
    }

    static _mutWrapOriginalAmounts({obj, objOriginal}) {
        const parts = [];
        let stack = "";
        let depth = 0;
        for (let i = 0; i < obj.entry.length; ++i) {
            const c = obj.entry[i];
            switch (c) {
            case "{":
                {
                    if (!depth && stack) {
                        parts.push(stack);
                        stack = "";
                    }
                    depth++;
                    stack += c;
                    break;
                }
            case "}":
                {
                    depth--;
                    stack += c;
                    if (!depth && stack) {
                        parts.push(stack);
                        stack = "";
                    }
                    break;
                }
            default:
                stack += c;
            }
        }
        if (stack)
            parts.push(stack);
        obj.entry = parts.map(pt=>pt.replace(Renderer.recipe._RE_AMOUNT, (...m)=>{
            const ixStart = m.slice(-3, -2)[0];
            if (ixStart !== 0 || m[0].length !== pt.length)
                return m[0];

            const originalValue = Renderer.applyProperties(m.last().tagAmount, objOriginal);
            return `{@help ${m.last().tagAmount}|In the original recipe: ${originalValue}}`;
        }
        )).join("");
    }

    static getCustomHashId(it) {
        if (!it._scaleFactor)
            return null;

        const {name, source, _scaleFactor: scaleFactor, } = it;

        return [name, source, scaleFactor ?? "", ].join("__").toLowerCase();
    }

    static getUnpackedCustomHashId(customHashId) {
        if (!customHashId)
            return null;

        const [,,scaleFactor] = customHashId.split("__").map(it=>it.trim());

        if (!scaleFactor)
            return null;

        return {
            _scaleFactor: scaleFactor ? Number(scaleFactor) : null,
            customHashId,
        };
    }

    static async pGetModifiedRecipe(ent, customHashId) {
        if (!customHashId)
            return ent;
        const {_scaleFactor} = Renderer.recipe.getUnpackedCustomHashId(customHashId);
        if (_scaleFactor == null)
            return ent;
        return Renderer.recipe.getScaledRecipe(ent, _scaleFactor);
    }
}
;

Renderer.card = class {
    static getFullEntries(ent) {
        const entries = [...ent.entries || []];
        if (ent.suit && (ent.valueName || ent.value)) {
            const suitAndValue = `${((ent.valueName || "") || Parser.numberToText(ent.value)).toTitleCase()} of ${ent.suit.toTitleCase()}`;
            if (suitAndValue.toLowerCase() !== ent.name.toLowerCase())
                entries.unshift(`{@i ${suitAndValue}}`);
        }
        return entries;
    }

    static getCompactRenderedString(ent) {
        const fullEntries = Renderer.card.getFullEntries(ent);
        return `
			${Renderer.utils.getNameTr(ent)}
			<tr class="text"><td colspan="6">
			${Renderer.get().setFirstSection(true).render({
            ...ent.face,
            maxHeight: 40,
            maxHeightUnits: "vh"
        })}
			${fullEntries?.length ? `<hr class="hr-3">
			${Renderer.get().setFirstSection(true).render({
            type: "entries",
            entries: fullEntries
        }, 1)}` : ""}
			</td></tr>
		`;
    }
}
;

Renderer.deck = class {
    static getCompactRenderedString(ent) {
        const lstCards = {
            name: "Cards",
            entries: [{
                type: "list",
                columns: 3,
                items: ent.cards.map(card=>`{@card ${card.name}|${card.set}|${card.source}}`),
            }, ],
        };

        return `
			${Renderer.utils.getNameTr(ent)}
			<tr class="text"><td colspan="6">
			${Renderer.get().setFirstSection(true).render({
            type: "entries",
            entries: ent.entries
        }, 1)}
			<hr class="hr-3">
			${Renderer.get().setFirstSection(true).render(lstCards, 1)}
			</td></tr>
		`;
    }
}
;

Renderer.skill = class {
    static getCompactRenderedString(ent) {
        return Renderer.generic.getCompactRenderedString(ent);
    }
}
;

Renderer.sense = class {
    static getCompactRenderedString(ent) {
        return Renderer.generic.getCompactRenderedString(ent);
    }
}
;

Renderer.itemMastery = class {
    static getCompactRenderedString(ent) {
        return Renderer.generic.getCompactRenderedString(ent);
    }
}
;

Renderer.generic = class {
    static getCompactRenderedString(ent, opts) {
        opts = opts || {};
        const prerequisite = Renderer.utils.prerequisite.getHtml(ent.prerequisite);

        return `
		${opts.dataProp && opts.page ? Renderer.utils.getExcludedTr({
            entity: ent,
            dataProp: opts.dataProp,
            page: opts.page
        }) : ""}
		${opts.isSkipNameRow ? "" : Renderer.utils.getNameTr(ent, {
            page: opts.page
        })}
		<tr class="text"><td colspan="6">
		${prerequisite ? `<p>${prerequisite}</p>` : ""}
		${Renderer.get().setFirstSection(true).render({
            entries: ent.entries
        })}
		</td></tr>
		${opts.isSkipPageRow ? "" : Renderer.utils.getPageTr(ent)}`;
    }

    static FEATURE__SKILLS_ALL = Object.keys(Parser.SKILL_TO_ATB_ABV).sort(SortUtil.ascSortLower);

    static FEATURE__TOOLS_ARTISANS = ["alchemist's supplies", "brewer's supplies", "calligrapher's supplies", "carpenter's tools", "cartographer's tools", "cobbler's tools", "cook's utensils", "glassblower's tools", "jeweler's tools", "leatherworker's tools", "mason's tools", "painter's supplies", "potter's tools", "smith's tools", "tinker's tools", "weaver's tools", "woodcarver's tools", ];
    static FEATURE__TOOLS_MUSICAL_INSTRUMENTS = ["bagpipes", "drum", "dulcimer", "flute", "horn", "lute", "lyre", "pan flute", "shawm", "viol", ];
    static FEATURE__TOOLS_ALL = ["artisan's tools",
    ...this.FEATURE__TOOLS_ARTISANS, ...this.FEATURE__TOOLS_MUSICAL_INSTRUMENTS,
    "disguise kit", "forgery kit", "gaming set", "herbalism kit", "musical instrument", "navigator's tools", "thieves' tools", "poisoner's kit", "vehicles (land)", "vehicles (water)", "vehicles (air)", "vehicles (space)", ];

    static FEATURE__LANGUAGES_ALL = Parser.LANGUAGES_ALL.map(it=>it.toLowerCase());
    static FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ = {
        from: [...Parser.LANGUAGES_STANDARD.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesStandard",
        })), ...Parser.LANGUAGES_EXOTIC.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesExotic",
        })), ...Parser.LANGUAGES_SECRET.map(it=>({
            name: it.toLowerCase(),
            prop: "languageProficiencies",
            group: "languagesSecret",
        })), ],
        groups: {
            languagesStandard: {
                name: "Standard Languages",
            },
            languagesExotic: {
                name: "Exotic Languages",
                hint: "With your DM's permission, you can choose an exotic language.",
            },
            languagesSecret: {
                name: "Secret Languages",
                hint: "With your DM's permission, you can choose a secret language.",
            },
        },
    };

    static FEATURE__SAVING_THROWS_ALL = [...Parser.ABIL_ABVS];

    static _SKILL_TOOL_LANGUAGE_KEYS__SKILL_ANY = new Set(["anySkill"]);
    static _SKILL_TOOL_LANGUAGE_KEYS__TOOL_ANY = new Set(["anyTool", "anyArtisansTool"]);
    static _SKILL_TOOL_LANGUAGE_KEYS__LANGAUGE_ANY = new Set(["anyLanguage", "anyStandardLanguage", "anyExoticLanguage"]);

    static getSkillSummary({skillProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: skillProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__SKILLS_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__SKILL_ANY,
            isShort,
            hoverTag: "skill",
        });
    }

    static getToolSummary({toolProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: toolProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__TOOLS_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__TOOL_ANY,
            isShort,
        });
    }

    static getLanguageSummary({languageProfs, skillToolLanguageProfs, isShort=false}) {
        return this._summariseProfs({
            profGroupArr: languageProfs,
            skillToolLanguageProfs,
            setValid: new Set(this.FEATURE__LANGUAGES_ALL),
            setValidAny: this._SKILL_TOOL_LANGUAGE_KEYS__LANGAUGE_ANY,
            isShort,
        });
    }

    static _summariseProfs({profGroupArr, skillToolLanguageProfs, setValid, setValidAny, isShort, hoverTag}) {
        if (!profGroupArr?.length && !skillToolLanguageProfs?.length)
            return {
                summary: "",
                collection: []
            };

        const collectionSet = new Set();

        const handleProfGroup = (profGroup,{isValidate=true}={})=>{
            let sep = ", ";

            const toJoin = Object.entries(profGroup).sort(([kA],[kB])=>this._summariseProfs_sortKeys(kA, kB)).filter(([k,v])=>v && (!isValidate || setValid.has(k) || setValidAny.has(k))).map(([k,v],i)=>{
                const vMapped = this.getMappedAnyProficiency({
                    keyAny: k,
                    countRaw: v
                }) ?? v;

                if (k === "choose") {
                    sep = "; ";

                    const chooseProfs = vMapped.from.filter(s=>!isValidate || setValid.has(s)).map(s=>{
                        collectionSet.add(s);
                        return this._summariseProfs_getEntry({
                            str: s,
                            isShort,
                            hoverTag
                        });
                    }
                    );
                    return `${isShort ? `${i === 0 ? "C" : "c"}hoose ` : ""}${v.count || 1} ${isShort ? `of` : `from`} ${chooseProfs.joinConjunct(", ", " or ")}`;
                }

                collectionSet.add(k);
                return this._summariseProfs_getEntry({
                    str: k,
                    isShort,
                    hoverTag
                });
            }
            );

            return toJoin.join(sep);
        }
        ;

        const summary = [...(profGroupArr || []).map(profGroup=>handleProfGroup(profGroup, {
            isValidate: false
        })), ...(skillToolLanguageProfs || []).map(profGroup=>handleProfGroup(profGroup)), ].filter(Boolean).join(` <i>or</i> `);

        return {
            summary,
            collection: [...collectionSet].sort(SortUtil.ascSortLower)
        };
    }

    static _summariseProfs_sortKeys(a, b, {setValidAny=null}={}) {
        if (a === b)
            return 0;
        if (a === "choose")
            return 2;
        if (b === "choose")
            return -2;
        if (setValidAny) {
            if (setValidAny.has(a))
                return 1;
            if (setValidAny.has(b))
                return -1;
        }
        return SortUtil.ascSort(a, b);
    }

    static _summariseProfs_getEntry({str, isShort, hoverTag}) {
        return isShort ? str.toTitleCase() : hoverTag ? `{@${hoverTag} ${str.toTitleCase()}}` : str.toTitleCase();
    }

    static getMappedAnyProficiency({keyAny, countRaw}) {
        const mappedCount = !isNaN(countRaw) ? Number(countRaw) : 1;
        if (mappedCount <= 0)
            return null;

        switch (keyAny) {
        case "anySkill":
            return {
                name: mappedCount === 1 ? `Any Skill` : `Any ${mappedCount} Skills`,
                from: this.FEATURE__SKILLS_ALL.map(it=>({
                    name: it,
                    prop: "skillProficiencies"
                })),
                count: mappedCount,
            };
        case "anyTool":
            return {
                name: mappedCount === 1 ? `Any Tool` : `Any ${mappedCount} Tools`,
                from: this.FEATURE__TOOLS_ALL.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyArtisansTool":
            return {
                name: mappedCount === 1 ? `Any Artisan's Tool` : `Any ${mappedCount} Artisan's Tools`,
                from: this.FEATURE__TOOLS_ARTISANS.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyMusicalInstrument":
            return {
                name: mappedCount === 1 ? `Any Musical Instrument` : `Any ${mappedCount} Musical Instruments`,
                from: this.FEATURE__TOOLS_MUSICAL_INSTRUMENTS.map(it=>({
                    name: it,
                    prop: "toolProficiencies"
                })),
                count: mappedCount,
            };
        case "anyLanguage":
            return {
                name: mappedCount === 1 ? `Any Language` : `Any ${mappedCount} Languages`,
                from: this.FEATURE__LANGUAGES_ALL.map(it=>({
                    name: it,
                    prop: "languageProficiencies"
                })),
                count: mappedCount,
            };
        case "anyStandardLanguage":
            return {
                name: mappedCount === 1 ? `Any Standard Language` : `Any ${mappedCount} Standard Languages`,
                ...MiscUtil.copyFast(this.FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ),
                count: mappedCount,
            };
        case "anyExoticLanguage":
            return {
                name: mappedCount === 1 ? `Any Exotic Language` : `Any ${mappedCount} Exotic Languages`,
                ...MiscUtil.copyFast(this.FEATURE__LANGUAGES_STANDARD__CHOICE_OBJ),
                count: mappedCount,
            };
        case "anySavingThrow":
            return {
                name: mappedCount === 1 ? `Any Saving Throw` : `Any ${mappedCount} Saving Throws`,
                from: this.FEATURE__SAVING_THROWS_ALL.map(it=>({
                    name: it,
                    prop: "savingThrowProficiencies"
                })),
                count: mappedCount,
            };

        case "anyWeapon":
            throw new Error(`Property handling for "anyWeapon" is unimplemented!`);
        case "anyArmor":
            throw new Error(`Property handling for "anyArmor" is unimplemented!`);

        default:
            return null;
        }
    }
}
;

Renderer.hover = {
    LinkMeta: function() {
        this.isHovered = false;
        this.isLoading = false;
        this.isPermanent = false;
        this.windowMeta = null;
    },

    _BAR_HEIGHT: 16,

    _linkCache: {},
    _eleCache: new Map(),
    _entryCache: {},
    _isInit: false,
    _dmScreen: null,
    _lastId: 0,
    _contextMenu: null,
    _contextMenuLastClicked: null,

    bindDmScreen(screen) {
        this._dmScreen = screen;
    },

    _getNextId() {
        return ++Renderer.hover._lastId;
    },

    _doInit() {
        if (!Renderer.hover._isInit) {
            Renderer.hover._isInit = true;

            $(document.body).on("click", ()=>Renderer.hover.cleanTempWindows());

            Renderer.hover._contextMenu = ContextUtil.getMenu([new ContextUtil.Action("Maximize All",()=>{
                const $permWindows = $(`.hoverborder[data-perm="true"]`);
                $permWindows.attr("data-display-title", "false");
            }
            ,), new ContextUtil.Action("Minimize All",()=>{
                const $permWindows = $(`.hoverborder[data-perm="true"]`);
                $permWindows.attr("data-display-title", "true");
            }
            ,), null, new ContextUtil.Action("Close Others",()=>{
                const hoverId = Renderer.hover._contextMenuLastClicked?.hoverId;
                Renderer.hover._doCloseAllWindows({
                    hoverIdBlocklist: new Set([hoverId])
                });
            }
            ,), new ContextUtil.Action("Close All",()=>Renderer.hover._doCloseAllWindows(),), ]);
        }
    },

    cleanTempWindows() {
        for (const [key,meta] of Renderer.hover._eleCache.entries()) {
            if (!meta.isPermanent && meta.windowMeta && typeof key === "number") {
                meta.windowMeta.doClose();
                Renderer.hover._eleCache.delete(key);
                return;
            }

            if (!meta.isPermanent && meta.windowMeta && !document.body.contains(key)) {
                meta.windowMeta.doClose();
                return;
            }

            if (!meta.isPermanent && meta.isHovered && meta.windowMeta) {
                const bounds = key.getBoundingClientRect();
                if (EventUtil._mouseX < bounds.x || EventUtil._mouseY < bounds.y || EventUtil._mouseX > bounds.x + bounds.width || EventUtil._mouseY > bounds.y + bounds.height) {
                    meta.windowMeta.doClose();
                }
            }
        }
    },

    _doCloseAllWindows({hoverIdBlocklist=null}={}) {
        Object.entries(Renderer.hover._WINDOW_METAS).filter(([hoverId,meta])=>hoverIdBlocklist == null || !hoverIdBlocklist.has(Number(hoverId))).forEach(([,meta])=>meta.doClose());
    },

    _getSetMeta(ele) {
        if (!Renderer.hover._eleCache.has(ele))
            Renderer.hover._eleCache.set(ele, new Renderer.hover.LinkMeta());
        return Renderer.hover._eleCache.get(ele);
    },

    _handleGenericMouseOverStart({evt, ele}) {
        if (Renderer.hover.isSmallScreen(evt) && !evt.shiftKey)
            return;

        Renderer.hover.cleanTempWindows();

        const meta = Renderer.hover._getSetMeta(ele);
        if (meta.isHovered || meta.isLoading)
            return;
        ele.style.cursor = "progress";

        meta.isHovered = true;
        meta.isLoading = true;
        meta.isPermanent = evt.shiftKey;

        return meta;
    },

    _doPredefinedShowStart({entryId}) {
        Renderer.hover.cleanTempWindows();

        const meta = Renderer.hover._getSetMeta(entryId);

        meta.isPermanent = true;

        return meta;
    },

    async pHandleLinkMouseOver(evt, ele, opts) {
        Renderer.hover._doInit();

        let page, source, hash, preloadId, customHashId, isFauxPage;
        if (opts) {
            page = opts.page;
            source = opts.source;
            hash = opts.hash;
            preloadId = opts.preloadId;
            customHashId = opts.customHashId;
            isFauxPage = !!opts.isFauxPage;
        } else {
            page = ele.dataset.vetPage;
            source = ele.dataset.vetSource;
            hash = ele.dataset.vetHash;
            preloadId = ele.dataset.vetPreloadId;
            isFauxPage = ele.dataset.vetIsFauxPage;
        }

        let meta = Renderer.hover._handleGenericMouseOverStart({
            evt,
            ele
        });
        if (meta == null)
            return;

        if ((EventUtil.isCtrlMetaKey(evt)) && Renderer.hover._pageToFluffFn(page))
            meta.isFluff = true;

        let toRender;
        if (preloadId != null) {
            switch (page) {
            case UrlUtil.PG_BESTIARY:
                {
                    const {_scaledCr: scaledCr, _scaledSpellSummonLevel: scaledSpellSummonLevel, _scaledClassSummonLevel: scaledClassSummonLevel} = Renderer.monster.getUnpackedCustomHashId(preloadId);

                    const baseMon = await DataLoader.pCacheAndGet(page, source, hash);
                    if (scaledCr != null) {
                        toRender = await ScaleCreature.scale(baseMon, scaledCr);
                    } else if (scaledSpellSummonLevel != null) {
                        toRender = await ScaleSpellSummonedCreature.scale(baseMon, scaledSpellSummonLevel);
                    } else if (scaledClassSummonLevel != null) {
                        toRender = await ScaleClassSummonedCreature.scale(baseMon, scaledClassSummonLevel);
                    }
                    break;
                }
            }
        } else if (customHashId) {
            toRender = await DataLoader.pCacheAndGet(page, source, hash);
            toRender = await Renderer.hover.pApplyCustomHashId(page, toRender, customHashId);
        } else {
            if (meta.isFluff)
                toRender = await Renderer.hover.pGetHoverableFluff(page, source, hash);
            else
                toRender = await DataLoader.pCacheAndGet(page, source, hash);
        }

        meta.isLoading = false;

        if (opts?.isDelay) {
            meta.isDelayed = true;
            ele.style.cursor = "help";
            await MiscUtil.pDelay(1100);
            meta.isDelayed = false;
        }

        ele.style.cursor = "";

        if (!meta || (!meta.isHovered && !meta.isPermanent))
            return;

        const tmpEvt = meta._tmpEvt;
        delete meta._tmpEvt;

        const win = (evt.view || {}).window;

        const $content = meta.isFluff ? Renderer.hover.$getHoverContent_fluff(page, toRender) : Renderer.hover.$getHoverContent_stats(page, toRender);

        const compactReferenceData = {
            page,
            source,
            hash,
        };

        if (meta.windowMeta && !meta.isPermanent) {
            meta.windowMeta.doClose();
            meta.windowMeta = null;
        }

        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(tmpEvt || evt, {
            isPreventFlicker: !meta.isPermanent
        }), {
            title: toRender ? toRender.name : "",
            isPermanent: meta.isPermanent,
            pageUrl: isFauxPage ? null : `${Renderer.get().baseUrl}${page}#${hash}`,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = meta.isFluff = false,
            isBookContent: page === UrlUtil.PG_RECIPES,
            compactReferenceData,
            sourceData: toRender,
        }, );

        if (!meta.isFluff && !win?._IS_POPOUT) {
            const fnBind = Renderer.hover.getFnBindListenersCompact(page);
            if (fnBind)
                fnBind(toRender, $content);
        }
    },

    handleInlineMouseOver(evt, ele, entry, opts) {
        Renderer.hover._doInit();

        entry = entry || JSON.parse(ele.dataset.vetEntry);

        let meta = Renderer.hover._handleGenericMouseOverStart({
            evt,
            ele
        });
        if (meta == null)
            return;

        meta.isLoading = false;

        ele.style.cursor = "";

        if (!meta || (!meta.isHovered && !meta.isPermanent))
            return;

        const tmpEvt = meta._tmpEvt;
        delete meta._tmpEvt;

        const win = (evt.view || {}).window;

        const $content = Renderer.hover.$getHoverContent_generic(entry, opts);

        if (meta.windowMeta && !meta.isPermanent) {
            meta.windowMeta.doClose();
            meta.windowMeta = null;
        }

        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(tmpEvt || evt, {
            isPreventFlicker: !meta.isPermanent
        }), {
            title: entry?.name || "",
            isPermanent: meta.isPermanent,
            pageUrl: null,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = false,
            isBookContent: true,
            sourceData: entry,
        }, );
    },

    async pGetHoverableFluff(page, source, hash, opts) {
        let toRender = await DataLoader.pCacheAndGet(`${page}Fluff`, source, hash, opts);

        if (!toRender) {
            const entity = await DataLoader.pCacheAndGet(page, source, hash, opts);

            const pFnGetFluff = Renderer.hover._pageToFluffFn(page);
            if (!pFnGetFluff && opts?.isSilent)
                return null;

            toRender = await pFnGetFluff(entity);
        }

        if (!toRender)
            return toRender;

        if (toRender && (!toRender.name || !toRender.source)) {
            const toRenderParent = await DataLoader.pCacheAndGet(page, source, hash, opts);
            toRender = MiscUtil.copyFast(toRender);
            toRender.name = toRenderParent.name;
            toRender.source = toRenderParent.source;
        }

        return toRender;
    },

    handleLinkMouseLeave(evt, ele) {
        const meta = Renderer.hover._eleCache.get(ele);
        ele.style.cursor = "";

        if (!meta || meta.isPermanent)
            return;

        if (evt.shiftKey) {
            meta.isPermanent = true;
            meta.windowMeta.setIsPermanent(true);
            return;
        }

        meta.isHovered = false;
        if (meta.windowMeta) {
            meta.windowMeta.doClose();
            meta.windowMeta = null;
        }
    },

    handleLinkMouseMove(evt, ele) {
        const meta = Renderer.hover._eleCache.get(ele);
        if (!meta || meta.isPermanent)
            return;

        if (meta.isDelayed) {
            meta._tmpEvt = evt;
            return;
        }

        if (!meta.windowMeta)
            return;

        meta.windowMeta.setPosition(Renderer.hover.getWindowPositionFromEvent(evt, {
            isPreventFlicker: !evt.shiftKey && !meta.isPermanent
        }));

        if (evt.shiftKey && !meta.isPermanent) {
            meta.isPermanent = true;
            meta.windowMeta.setIsPermanent(true);
        }
    },

    handlePredefinedMouseOver(evt, ele, entryId, opts) {
        opts = opts || {};

        const meta = Renderer.hover._handleGenericMouseOverStart({
            evt,
            ele
        });
        if (meta == null)
            return;

        Renderer.hover.cleanTempWindows();

        const toRender = Renderer.hover._entryCache[entryId];

        meta.isLoading = false;
        if (!meta.isHovered && !meta.isPermanent)
            return;

        const $content = Renderer.hover.$getHoverContent_generic(toRender, opts);
        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(evt, {
            isPreventFlicker: !meta.isPermanent
        }), {
            title: toRender.data && toRender.data.hoverTitle != null ? toRender.data.hoverTitle : toRender.name,
            isPermanent: meta.isPermanent,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = false,
            sourceData: toRender,
        }, );

        ele.style.cursor = "";
    },

    doPredefinedShow(entryId, opts) {
        opts = opts || {};

        const meta = Renderer.hover._doPredefinedShowStart({
            entryId
        });
        if (meta == null)
            return;

        Renderer.hover.cleanTempWindows();

        const toRender = Renderer.hover._entryCache[entryId];

        const $content = Renderer.hover.$getHoverContent_generic(toRender, opts);
        meta.windowMeta = Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionExact((window.innerWidth / 2) - (Renderer.hover._DEFAULT_WIDTH_PX / 2), 100), {
            title: toRender.data && toRender.data.hoverTitle != null ? toRender.data.hoverTitle : toRender.name,
            isPermanent: meta.isPermanent,
            cbClose: ()=>meta.isHovered = meta.isPermanent = meta.isLoading = false,
            sourceData: toRender,
        }, );
    },

    handlePredefinedMouseLeave(evt, ele) {
        return Renderer.hover.handleLinkMouseLeave(evt, ele);
    },

    handlePredefinedMouseMove(evt, ele) {
        return Renderer.hover.handleLinkMouseMove(evt, ele);
    },

    _WINDOW_POSITION_PROPS_FROM_EVENT: ["isFromBottom", "isFromRight", "clientX", "window", "isPreventFlicker", "bcr", ],

    getWindowPositionFromEvent(evt, {isPreventFlicker=false}={}) {
        const ele = evt.target;
        const win = evt?.view?.window || window;

        const bcr = ele.getBoundingClientRect().toJSON();

        const isFromBottom = bcr.top > win.innerHeight / 2;
        const isFromRight = bcr.left > win.innerWidth / 2;

        return {
            mode: "autoFromElement",
            isFromBottom,
            isFromRight,
            clientX: EventUtil.getClientX(evt),
            window: win,
            isPreventFlicker,
            bcr,
        };
    },

    getWindowPositionExact(x, y, evt=null) {
        return {
            window: evt?.view?.window || window,
            mode: "exact",
            x,
            y,
        };
    },

    getWindowPositionExactVisibleBottom(x, y, evt=null) {
        return {
            ...Renderer.hover.getWindowPositionExact(x, y, evt),
            mode: "exactVisibleBottom",
        };
    },

    _WINDOW_METAS: {},
    MIN_Z_INDEX: 200,
    _MAX_Z_INDEX: 300,
    _DEFAULT_WIDTH_PX: 600,
    _BODY_SCROLLER_WIDTH_PX: 15,

    _getZIndex() {
        const zIndices = Object.values(Renderer.hover._WINDOW_METAS).map(it=>it.zIndex);
        if (!zIndices.length)
            return Renderer.hover.MIN_Z_INDEX;
        return Math.max(...zIndices);
    },

    _getNextZIndex(hoverId) {
        const cur = Renderer.hover._getZIndex();
        if (hoverId != null && Renderer.hover._WINDOW_METAS[hoverId].zIndex === cur)
            return cur;
        const out = cur + 1;

        if (out > Renderer.hover._MAX_Z_INDEX) {
            const sortedWindowMetas = Object.entries(Renderer.hover._WINDOW_METAS).sort(([kA,vA],[kB,vB])=>SortUtil.ascSort(vA.zIndex, vB.zIndex));

            if (sortedWindowMetas.length >= (Renderer.hover._MAX_Z_INDEX - Renderer.hover.MIN_Z_INDEX)) {
                sortedWindowMetas.forEach(([k,v])=>{
                    v.setZIndex(Renderer.hover.MIN_Z_INDEX);
                }
                );
            } else {
                sortedWindowMetas.forEach(([k,v],i)=>{
                    v.setZIndex(Renderer.hover.MIN_Z_INDEX + i);
                }
                );
            }

            return Renderer.hover._getNextZIndex(hoverId);
        } else
            return out;
    },

    _isIntersectRect(r1, r2) {
        return r1.left <= r2.right && r2.left <= r1.right && r1.top <= r2.bottom && r2.top <= r1.bottom;
    },

    getShowWindow($content, position, opts) {
        opts = opts || {};

        Renderer.hover._doInit();

        const initialWidth = opts.width == null ? Renderer.hover._DEFAULT_WIDTH_PX : opts.width;
        const initialZIndex = Renderer.hover._getNextZIndex();

        const $body = $(position.window.document.body);
        const $hov = $(`<div class="hwin"></div>`).css({
            "right": -initialWidth,
            "width": initialWidth,
            "zIndex": initialZIndex,
        });
        const $wrpContent = $(`<div class="hwin__wrp-table"></div>`);
        if (opts.height != null)
            $wrpContent.css("height", opts.height);
        const $hovTitle = $(`<span class="window-title min-w-0 overflow-ellipsis" title="${`${opts.title || ""}`.qq()}">${opts.title || ""}</span>`);

        const hoverWindow = {};
        const hoverId = Renderer.hover._getNextId();
        Renderer.hover._WINDOW_METAS[hoverId] = hoverWindow;
        const mouseUpId = `mouseup.${hoverId} touchend.${hoverId}`;
        const mouseMoveId = `mousemove.${hoverId} touchmove.${hoverId}`;
        const resizeId = `resize.${hoverId}`;
        const drag = {};

        const $brdrTopRightResize = $(`<div class="hoverborder__resize-ne"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 1
        }));

        const $brdrRightResize = $(`<div class="hoverborder__resize-e"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 2
        }));

        const $brdrBottomRightResize = $(`<div class="hoverborder__resize-se"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 3
        }));

        const $brdrBtm = $(`<div class="hoverborder hoverborder--btm ${opts.isBookContent ? "hoverborder-book" : ""}"><div class="hoverborder__resize-s"></div></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 4
        }));

        const $brdrBtmLeftResize = $(`<div class="hoverborder__resize-sw"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 5
        }));

        const $brdrLeftResize = $(`<div class="hoverborder__resize-w"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 6
        }));

        const $brdrTopLeftResize = $(`<div class="hoverborder__resize-nw"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 7
        }));

        const $brdrTopResize = $(`<div class="hoverborder__resize-n"></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 8
        }));

        const $brdrTop = $(`<div class="hoverborder hoverborder--top ${opts.isBookContent ? "hoverborder-book" : ""}" ${opts.isPermanent ? `data-perm="true"` : ""}></div>`).on("mousedown touchstart", (evt)=>Renderer.hover._getShowWindow_handleDragMousedown({
            hoverWindow,
            hoverId,
            $hov,
            drag,
            $wrpContent
        }, {
            evt,
            type: 9
        })).on("contextmenu", (evt)=>{
            Renderer.hover._contextMenuLastClicked = {
                hoverId,
            };
            ContextUtil.pOpenMenu(evt, Renderer.hover._contextMenu);
        }
        );

        $(position.window.document).on(mouseUpId, (evt)=>{
            if (drag.type) {
                if (drag.type < 9) {
                    $wrpContent.css("max-height", "");
                    $hov.css("max-width", "");
                }
                Renderer.hover._getShowWindow_adjustPosition({
                    $hov,
                    $wrpContent,
                    position
                });

                if (drag.type === 9) {
                    if (EventUtil.isUsingTouch() && evt.target.classList.contains("hwin__top-border-icon")) {
                        evt.preventDefault();
                        drag.type = 0;
                        $(evt.target).click();
                        return;
                    }

                    if (this._dmScreen && opts.compactReferenceData) {
                        const panel = this._dmScreen.getPanelPx(EventUtil.getClientX(evt), EventUtil.getClientY(evt));
                        if (!panel)
                            return;
                        this._dmScreen.setHoveringPanel(panel);
                        const target = panel.getAddButtonPos();

                        if (Renderer.hover._getShowWindow_isOverHoverTarget({
                            evt,
                            target
                        })) {
                            panel.doPopulate_Stats(opts.compactReferenceData.page, opts.compactReferenceData.source, opts.compactReferenceData.hash);
                            Renderer.hover._getShowWindow_doClose({
                                $hov,
                                position,
                                mouseUpId,
                                mouseMoveId,
                                resizeId,
                                hoverId,
                                opts,
                                hoverWindow
                            });
                        }
                        this._dmScreen.resetHoveringButton();
                    }
                }
                drag.type = 0;
            }
        }
        ).on(mouseMoveId, (evt)=>{
            const args = {
                $wrpContent,
                $hov,
                drag,
                evt
            };
            switch (drag.type) {
            case 1:
                Renderer.hover._getShowWindow_handleNorthDrag(args);
                Renderer.hover._getShowWindow_handleEastDrag(args);
                break;
            case 2:
                Renderer.hover._getShowWindow_handleEastDrag(args);
                break;
            case 3:
                Renderer.hover._getShowWindow_handleSouthDrag(args);
                Renderer.hover._getShowWindow_handleEastDrag(args);
                break;
            case 4:
                Renderer.hover._getShowWindow_handleSouthDrag(args);
                break;
            case 5:
                Renderer.hover._getShowWindow_handleSouthDrag(args);
                Renderer.hover._getShowWindow_handleWestDrag(args);
                break;
            case 6:
                Renderer.hover._getShowWindow_handleWestDrag(args);
                break;
            case 7:
                Renderer.hover._getShowWindow_handleNorthDrag(args);
                Renderer.hover._getShowWindow_handleWestDrag(args);
                break;
            case 8:
                Renderer.hover._getShowWindow_handleNorthDrag(args);
                break;
            case 9:
                {
                    const diffX = drag.startX - EventUtil.getClientX(evt);
                    const diffY = drag.startY - EventUtil.getClientY(evt);
                    $hov.css("left", drag.baseLeft - diffX).css("top", drag.baseTop - diffY);
                    drag.startX = EventUtil.getClientX(evt);
                    drag.startY = EventUtil.getClientY(evt);
                    drag.baseTop = parseFloat($hov.css("top"));
                    drag.baseLeft = parseFloat($hov.css("left"));

                    if (this._dmScreen) {
                        const panel = this._dmScreen.getPanelPx(EventUtil.getClientX(evt), EventUtil.getClientY(evt));
                        if (!panel)
                            return;
                        this._dmScreen.setHoveringPanel(panel);
                        const target = panel.getAddButtonPos();

                        if (Renderer.hover._getShowWindow_isOverHoverTarget({
                            evt,
                            target
                        }))
                            this._dmScreen.setHoveringButton(panel);
                        else
                            this._dmScreen.resetHoveringButton();
                    }
                    break;
                }
            }
        }
        );
        $(position.window).on(resizeId, ()=>Renderer.hover._getShowWindow_adjustPosition({
            $hov,
            $wrpContent,
            position
        }));

        $brdrTop.attr("data-display-title", false);
        $brdrTop.on("dblclick", ()=>Renderer.hover._getShowWindow_doToggleMinimizedMaximized({
            $brdrTop,
            $hov
        }));
        $brdrTop.append($hovTitle);
        const $brdTopRhs = $(`<div class="ve-flex ml-auto no-shrink"></div>`).appendTo($brdrTop);

        if (opts.pageUrl && !position.window._IS_POPOUT && !Renderer.get().isInternalLinksDisabled()) {
            const $btnGotoPage = $(`<a class="hwin__top-border-icon glyphicon glyphicon-modal-window" title="Go to Page" href="${opts.pageUrl}"></a>`).appendTo($brdTopRhs);
        }

        if (!position.window._IS_POPOUT && !opts.isPopout) {
            const $btnPopout = $(`<span class="hwin__top-border-icon glyphicon glyphicon-new-window hvr__popout" title="Open as Popup Window"></span>`).on("click", evt=>{
                evt.stopPropagation();
                return Renderer.hover._getShowWindow_pDoPopout({
                    $hov,
                    position,
                    mouseUpId,
                    mouseMoveId,
                    resizeId,
                    hoverId,
                    opts,
                    hoverWindow,
                    $content
                }, {
                    evt
                });
            }
            ).appendTo($brdTopRhs);
        }

        if (opts.sourceData) {
            const btnPopout = e_({
                tag: "span",
                clazz: `hwin__top-border-icon hwin__top-border-icon--text`,
                title: "Show Source Data",
                text: "{}",
                click: evt=>{
                    evt.stopPropagation();
                    evt.preventDefault();

                    const $content = Renderer.hover.$getHoverContent_statsCode(opts.sourceData);
                    Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(evt), {
                        title: [opts.sourceData._displayName || opts.sourceData.name, "Source Data"].filter(Boolean).join(" \u2014 "),
                        isPermanent: true,
                        isBookContent: true,
                    }, );
                }
                ,
            });
            $brdTopRhs.append(btnPopout);
        }

        const $btnClose = $(`<span class="hwin__top-border-icon glyphicon glyphicon-remove" title="Close (CTRL to Close All)"></span>`).on("click", (evt)=>{
            evt.stopPropagation();

            if (EventUtil.isCtrlMetaKey(evt)) {
                Renderer.hover._doCloseAllWindows();
                return;
            }

            Renderer.hover._getShowWindow_doClose({
                $hov,
                position,
                mouseUpId,
                mouseMoveId,
                resizeId,
                hoverId,
                opts,
                hoverWindow
            });
        }
        ).appendTo($brdTopRhs);

        $wrpContent.append($content);

        $hov.append($brdrTopResize).append($brdrTopRightResize).append($brdrRightResize).append($brdrBottomRightResize).append($brdrBtmLeftResize).append($brdrLeftResize).append($brdrTopLeftResize)
        .append($brdrTop).append($wrpContent).append($brdrBtm);

        $body.append($hov);

        Renderer.hover._getShowWindow_setPosition({
            $hov,
            $wrpContent,
            position
        }, position);

        hoverWindow.$windowTitle = $hovTitle;
        hoverWindow.zIndex = initialZIndex;
        hoverWindow.setZIndex = Renderer.hover._getNextZIndex.bind(this, {
            $hov,
            hoverWindow
        });

        hoverWindow.setPosition = Renderer.hover._getShowWindow_setPosition.bind(this, {
            $hov,
            $wrpContent,
            position
        });
        hoverWindow.setIsPermanent = Renderer.hover._getShowWindow_setIsPermanent.bind(this, {
            opts,
            $brdrTop
        });
        hoverWindow.doClose = Renderer.hover._getShowWindow_doClose.bind(this, {
            $hov,
            position,
            mouseUpId,
            mouseMoveId,
            resizeId,
            hoverId,
            opts,
            hoverWindow
        });
        hoverWindow.doMaximize = Renderer.hover._getShowWindow_doMaximize.bind(this, {
            $brdrTop,
            $hov
        });
        hoverWindow.doZIndexToFront = Renderer.hover._getShowWindow_doZIndexToFront.bind(this, {
            $hov,
            hoverWindow,
            hoverId
        });

        if (opts.isPopout)
            Renderer.hover._getShowWindow_pDoPopout({
                $hov,
                position,
                mouseUpId,
                mouseMoveId,
                resizeId,
                hoverId,
                opts,
                hoverWindow,
                $content
            });

        return hoverWindow;
    },

    _getShowWindow_doClose({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow}) {
        $hov.remove();
        $(position.window.document).off(mouseUpId);
        $(position.window.document).off(mouseMoveId);
        $(position.window).off(resizeId);

        delete Renderer.hover._WINDOW_METAS[hoverId];

        if (opts.cbClose)
            opts.cbClose(hoverWindow);
    },

    _getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type}) {
        if (evt.which === 0 || evt.which === 1)
            evt.preventDefault();
        hoverWindow.zIndex = Renderer.hover._getNextZIndex(hoverId);
        $hov.css({
            "z-index": hoverWindow.zIndex,
            "animation": "initial",
        });
        drag.type = type;
        drag.startX = EventUtil.getClientX(evt);
        drag.startY = EventUtil.getClientY(evt);
        drag.baseTop = parseFloat($hov.css("top"));
        drag.baseLeft = parseFloat($hov.css("left"));
        drag.baseHeight = $wrpContent.height();
        drag.baseWidth = parseFloat($hov.css("width"));
        if (type < 9) {
            $wrpContent.css({
                "height": drag.baseHeight,
                "max-height": "initial",
            });
            $hov.css("max-width", "initial");
        }
    },

    _getShowWindow_isOverHoverTarget({evt, target}) {
        return EventUtil.getClientX(evt) >= target.left && EventUtil.getClientX(evt) <= target.left + target.width && EventUtil.getClientY(evt) >= target.top && EventUtil.getClientY(evt) <= target.top + target.height;
    },

    _getShowWindow_handleNorthDrag({$wrpContent, $hov, drag, evt}) {
        const diffY = Math.max(drag.startY - EventUtil.getClientY(evt), 80 - drag.baseHeight);
        $wrpContent.css("height", drag.baseHeight + diffY);
        $hov.css("top", drag.baseTop - diffY);
        drag.startY = EventUtil.getClientY(evt);
        drag.baseHeight = $wrpContent.height();
        drag.baseTop = parseFloat($hov.css("top"));
    },

    _getShowWindow_handleEastDrag({$wrpContent, $hov, drag, evt}) {
        const diffX = drag.startX - EventUtil.getClientX(evt);
        $hov.css("width", drag.baseWidth - diffX);
        drag.startX = EventUtil.getClientX(evt);
        drag.baseWidth = parseFloat($hov.css("width"));
    },

    _getShowWindow_handleSouthDrag({$wrpContent, $hov, drag, evt}) {
        const diffY = drag.startY - EventUtil.getClientY(evt);
        $wrpContent.css("height", drag.baseHeight - diffY);
        drag.startY = EventUtil.getClientY(evt);
        drag.baseHeight = $wrpContent.height();
    },

    _getShowWindow_handleWestDrag({$wrpContent, $hov, drag, evt}) {
        const diffX = Math.max(drag.startX - EventUtil.getClientX(evt), 150 - drag.baseWidth);
        $hov.css("width", drag.baseWidth + diffX).css("left", drag.baseLeft - diffX);
        drag.startX = EventUtil.getClientX(evt);
        drag.baseWidth = parseFloat($hov.css("width"));
        drag.baseLeft = parseFloat($hov.css("left"));
    },

    _getShowWindow_doToggleMinimizedMaximized({$brdrTop, $hov}) {
        const curState = $brdrTop.attr("data-display-title");
        const isNextMinified = curState === "false";
        $brdrTop.attr("data-display-title", isNextMinified);
        $brdrTop.attr("data-perm", true);
        $hov.toggleClass("hwin--minified", isNextMinified);
    },

    _getShowWindow_doMaximize({$brdrTop, $hov}) {
        $brdrTop.attr("data-display-title", false);
        $hov.toggleClass("hwin--minified", false);
    },

    async _getShowWindow_pDoPopout({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow, $content}, {evt}={}) {
        const dimensions = opts.fnGetPopoutSize ? opts.fnGetPopoutSize() : {
            width: 600,
            height: $content.height()
        };
        const win = window.open("", opts.title || "", `width=${dimensions.width},height=${dimensions.height}location=0,menubar=0,status=0,titlebar=0,toolbar=0`, );

        if (!win._IS_POPOUT) {
            win._IS_POPOUT = true;
            win.document.write(`
				<!DOCTYPE html>
				<html lang="en" class="ve-popwindow ${typeof styleSwitcher !== "undefined" ? styleSwitcher.getDayNightClassNames() : ""}"><head>
					<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
					<title>${opts.title}</title>
					${$(`link[rel="stylesheet"][href]`).map((i,e)=>e.outerHTML).get().join("\n")}
					<!-- Favicons -->
					<link rel="icon" type="image/svg+xml" href="favicon.svg">
					<link rel="icon" type="image/png" sizes="256x256" href="favicon-256x256.png">
					<link rel="icon" type="image/png" sizes="144x144" href="favicon-144x144.png">
					<link rel="icon" type="image/png" sizes="128x128" href="favicon-128x128.png">
					<link rel="icon" type="image/png" sizes="64x64" href="favicon-64x64.png">
					<link rel="icon" type="image/png" sizes="48x48" href="favicon-48x48.png">
					<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
					<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">

					<!-- Chrome Web App Icons -->
					<link rel="manifest" href="manifest.webmanifest">
					<meta name="application-name" content="5etools">
					<meta name="theme-color" content="#006bc4">

					<!-- Windows Start Menu tiles -->
					<meta name="msapplication-config" content="browserconfig.xml"/>
					<meta name="msapplication-TileColor" content="#006bc4">

					<!-- Apple Touch Icons -->
					<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
					<link rel="apple-touch-icon" sizes="360x360" href="apple-touch-icon-360x360.png">
					<link rel="apple-touch-icon" sizes="167x167" href="apple-touch-icon-167x167.png">
					<link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
					<link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120x120.png">
					<meta name="apple-mobile-web-app-title" content="5etools">

					<!-- macOS Safari Pinned Tab and Touch Bar -->
					<link rel="mask-icon" href="safari-pinned-tab.svg" color="#006bc4">

					<style>
						html, body { width: 100%; height: 100%; }
						body { overflow-y: scroll; }
						.hwin--popout { max-width: 100%; max-height: 100%; box-shadow: initial; width: 100%; overflow-y: auto; }
					</style>
				</head><body class="rd__body-popout">
				<div class="hwin hoverbox--popout hwin--popout"></div>
				<script type="text/javascript" src="js/parser.js"></script>
				<script type="text/javascript" src="js/utils.js"></script>
				<script type="text/javascript" src="lib/jquery.js"></script>
				</body></html>
			`);

            win.Renderer = Renderer;

            let ticks = 50;
            while (!win.document.body && ticks-- > 0)
                await MiscUtil.pDelay(5);

            win.$wrpHoverContent = $(win.document).find(`.hoverbox--popout`);
        }

        let $cpyContent;
        if (opts.$pFnGetPopoutContent) {
            $cpyContent = await opts.$pFnGetPopoutContent();
        } else {
            $cpyContent = $content.clone(true, true);
        }

        $cpyContent.appendTo(win.$wrpHoverContent.empty());

        Renderer.hover._getShowWindow_doClose({
            $hov,
            position,
            mouseUpId,
            mouseMoveId,
            resizeId,
            hoverId,
            opts,
            hoverWindow
        });
    },

    _getShowWindow_setPosition({$hov, $wrpContent, position}, positionNxt) {
        switch (positionNxt.mode) {
        case "autoFromElement":
            {
                const bcr = $hov[0].getBoundingClientRect();

                if (positionNxt.isFromBottom)
                    $hov.css("top", positionNxt.bcr.top - (bcr.height + 10));
                else
                    $hov.css("top", positionNxt.bcr.top + positionNxt.bcr.height + 10);

                if (positionNxt.isFromRight)
                    $hov.css("left", (positionNxt.clientX || positionNxt.bcr.left) - (bcr.width + 10));
                else
                    $hov.css("left", (positionNxt.clientX || (positionNxt.bcr.left + positionNxt.bcr.width)) + 10);

                if (position !== positionNxt) {
                    Renderer.hover._WINDOW_POSITION_PROPS_FROM_EVENT.forEach(prop=>{
                        position[prop] = positionNxt[prop];
                    }
                    );
                }

                break;
            }
        case "exact":
            {
                $hov.css({
                    "left": positionNxt.x,
                    "top": positionNxt.y,
                });
                break;
            }
        case "exactVisibleBottom":
            {
                $hov.css({
                    "left": positionNxt.x,
                    "top": positionNxt.y,
                    "animation": "initial",
                });

                let yPos = positionNxt.y;

                const {bottom: posBottom, height: winHeight} = $hov[0].getBoundingClientRect();
                const height = position.window.innerHeight;
                if (posBottom > height) {
                    yPos = position.window.innerHeight - winHeight;
                    $hov.css({
                        "top": yPos,
                        "animation": "",
                    });
                }

                break;
            }
        default:
            throw new Error(`Positiong mode unimplemented: "${positionNxt.mode}"`);
        }

        Renderer.hover._getShowWindow_adjustPosition({
            $hov,
            $wrpContent,
            position
        });
    },

    _getShowWindow_adjustPosition({$hov, $wrpContent, position}) {
        const eleHov = $hov[0];
        const wrpContent = $wrpContent[0];

        const bcr = eleHov.getBoundingClientRect().toJSON();
        const screenHeight = position.window.innerHeight;
        const screenWidth = position.window.innerWidth;

        if (bcr.top < 0) {
            bcr.top = 0;
            bcr.bottom = bcr.top + bcr.height;
            eleHov.style.top = `${bcr.top}px`;
        } else if (bcr.top >= screenHeight - Renderer.hover._BAR_HEIGHT) {
            bcr.top = screenHeight - Renderer.hover._BAR_HEIGHT;
            bcr.bottom = bcr.top + bcr.height;
            eleHov.style.top = `${bcr.top}px`;
        }

        if (bcr.left < 0) {
            bcr.left = 0;
            bcr.right = bcr.left + bcr.width;
            eleHov.style.left = `${bcr.left}px`;
        } else if (bcr.left + bcr.width + Renderer.hover._BODY_SCROLLER_WIDTH_PX > screenWidth) {
            bcr.left = Math.max(screenWidth - bcr.width - Renderer.hover._BODY_SCROLLER_WIDTH_PX, 0);
            bcr.right = bcr.left + bcr.width;
            eleHov.style.left = `${bcr.left}px`;
        }

        if (position.isPreventFlicker && Renderer.hover._isIntersectRect(bcr, position.bcr)) {
            if (position.isFromBottom) {
                bcr.height = position.bcr.top - 5;
                wrpContent.style.height = `${bcr.height}px`;
            } else {
                bcr.height = screenHeight - position.bcr.bottom - 5;
                wrpContent.style.height = `${bcr.height}px`;
            }
        }
    },

    _getShowWindow_setIsPermanent({opts, $brdrTop}, isPermanent) {
        opts.isPermanent = isPermanent;
        $brdrTop.attr("data-perm", isPermanent);
    },

    _getShowWindow_setZIndex({$hov, hoverWindow}, zIndex) {
        $hov.css("z-index", zIndex);
        hoverWindow.zIndex = zIndex;
    },

    _getShowWindow_doZIndexToFront({$hov, hoverWindow, hoverId}) {
        const nxtZIndex = Renderer.hover._getNextZIndex(hoverId);
        Renderer.hover._getNextZIndex({
            $hov,
            hoverWindow
        }, nxtZIndex);
    },

    getMakePredefinedHover(entry, opts) {
        opts = opts || {};

        const id = opts.id ?? Renderer.hover._getNextId();
        Renderer.hover._entryCache[id] = entry;
        return {
            id,
            html: `onmouseover="Renderer.hover.handlePredefinedMouseOver(event, this, ${id}, ${JSON.stringify(opts).escapeQuotes()})" onmousemove="Renderer.hover.handlePredefinedMouseMove(event, this)" onmouseleave="Renderer.hover.handlePredefinedMouseLeave(event, this)" ${Renderer.hover.getPreventTouchString()}`,
            mouseOver: (evt,ele)=>Renderer.hover.handlePredefinedMouseOver(evt, ele, id, opts),
            mouseMove: (evt,ele)=>Renderer.hover.handlePredefinedMouseMove(evt, ele),
            mouseLeave: (evt,ele)=>Renderer.hover.handlePredefinedMouseLeave(evt, ele),
            touchStart: (evt,ele)=>Renderer.hover.handleTouchStart(evt, ele),
            show: ()=>Renderer.hover.doPredefinedShow(id, opts),
        };
    },

    updatePredefinedHover(id, entry) {
        Renderer.hover._entryCache[id] = entry;
    },

    getInlineHover(entry, opts) {
        return {
            html: `onmouseover="Renderer.hover.handleInlineMouseOver(event, this)" onmouseleave="Renderer.hover.handleLinkMouseLeave(event, this)" onmousemove="Renderer.hover.handleLinkMouseMove(event, this)" data-vet-entry="${JSON.stringify(entry).qq()}" ${opts ? `data-vet-opts="${JSON.stringify(opts).qq()}"` : ""} ${Renderer.hover.getPreventTouchString()}`,
        };
    },

    getPreventTouchString() {
        return `ontouchstart="Renderer.hover.handleTouchStart(event, this)"`;
    },

    handleTouchStart(evt, ele) {
        if (!Renderer.hover.isSmallScreen(evt)) {
            $(ele).data("href", $(ele).data("href") || $(ele).attr("href"));
            $(ele).attr("href", "javascript:void(0)");
            setTimeout(()=>{
                const data = $(ele).data("href");
                if (data) {
                    $(ele).attr("href", data);
                    $(ele).data("href", null);
                }
            }
            , 100);
        }
    },

    getEntityLink(ent, {displayText=null, prop=null, isLowerCase=false, isTitleCase=false, }={}, ) {
        if (isLowerCase && isTitleCase)
            throw new Error(`"isLowerCase" and "isTitleCase" are mutually exclusive!`);

        const name = isLowerCase ? ent.name.toLowerCase() : isTitleCase ? ent.name.toTitleCase() : ent.name;

        let parts = [name, ent.source, displayText || "", ];

        switch (prop || ent.__prop) {
        case "monster":
            {
                if (ent._isScaledCr) {
                    parts.push(`${VeCt.HASH_SCALED}=${Parser.numberToCr(ent._scaledCr)}`);
                }

                if (ent._isScaledSpellSummon) {
                    parts.push(`${VeCt.HASH_SCALED_SPELL_SUMMON}=${ent._scaledSpellSummonLevel}`);
                }

                if (ent._isScaledClassSummon) {
                    parts.push(`${VeCt.HASH_SCALED_CLASS_SUMMON}=${ent._scaledClassSummonLevel}`);
                }

                break;
            }

        case "deity":
            {
                parts.splice(1, 0, ent.pantheon);
                break;
            }
        }

        while (parts.length && !parts.last()?.length)
            parts.pop();

        return Renderer.get().render(`{@${Parser.getPropTag(prop || ent.__prop)} ${parts.join("|")}}`);
    },

    getRefMetaFromTag(str) {
        str = str.slice(2, -1);
        const [tag,...refParts] = str.split(" ");
        const ref = refParts.join(" ");
        const type = `ref${tag.uppercaseFirst()}`;
        return {
            type,
            [tag]: ref
        };
    },

    async pApplyCustomHashId(page, ent, customHashId) {
        switch (page) {
        case UrlUtil.PG_BESTIARY:
            {
                const out = await Renderer.monster.pGetModifiedCreature(ent, customHashId);
                Renderer.monster.updateParsed(out);
                return out;
            }

        case UrlUtil.PG_RECIPES:
            return Renderer.recipe.pGetModifiedRecipe(ent, customHashId);

        default:
            return ent;
        }
    },

    getGenericCompactRenderedString(entry, depth=0) {
        return `
			<tr class="text homebrew-hover"><td colspan="6">
			${Renderer.get().setFirstSection(true).render(entry, depth)}
			</td></tr>
		`;
    },

    getFnRenderCompact(page, {isStatic=false}={}) {
        switch (page) {
        case "generic":
        case "hover":
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_QUICKREF:
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_CLASSES:
            return Renderer.class.getCompactRenderedString;
        case UrlUtil.PG_SPELLS:
            return Renderer.spell.getCompactRenderedString;
        case UrlUtil.PG_ITEMS:
            return Renderer.item.getCompactRenderedString;
        case UrlUtil.PG_BESTIARY:
            return it=>Renderer.monster.getCompactRenderedString(it, {
                isShowScalers: !isStatic,
                isScaledCr: it._originalCr != null,
                isScaledSpellSummon: it._isScaledSpellSummon,
                isScaledClassSummon: it._isScaledClassSummon
            });
        case UrlUtil.PG_CONDITIONS_DISEASES:
            return Renderer.condition.getCompactRenderedString;
        case UrlUtil.PG_BACKGROUNDS:
            return Renderer.background.getCompactRenderedString;
        case UrlUtil.PG_FEATS:
            return Renderer.feat.getCompactRenderedString;
        case UrlUtil.PG_OPT_FEATURES:
            return Renderer.optionalfeature.getCompactRenderedString;
        case UrlUtil.PG_PSIONICS:
            return Renderer.psionic.getCompactRenderedString;
        case UrlUtil.PG_REWARDS:
            return Renderer.reward.getCompactRenderedString;
        case UrlUtil.PG_RACES:
            return it=>Renderer.race.getCompactRenderedString(it, {
                isStatic
            });
        case UrlUtil.PG_DEITIES:
            return Renderer.deity.getCompactRenderedString;
        case UrlUtil.PG_OBJECTS:
            return Renderer.object.getCompactRenderedString;
        case UrlUtil.PG_TRAPS_HAZARDS:
            return Renderer.traphazard.getCompactRenderedString;
        case UrlUtil.PG_VARIANTRULES:
            return Renderer.variantrule.getCompactRenderedString;
        case UrlUtil.PG_CULTS_BOONS:
            return Renderer.cultboon.getCompactRenderedString;
        case UrlUtil.PG_TABLES:
            return Renderer.table.getCompactRenderedString;
        case UrlUtil.PG_VEHICLES:
            return Renderer.vehicle.getCompactRenderedString;
        case UrlUtil.PG_ACTIONS:
            return Renderer.action.getCompactRenderedString;
        case UrlUtil.PG_LANGUAGES:
            return Renderer.language.getCompactRenderedString;
        case UrlUtil.PG_CHAR_CREATION_OPTIONS:
            return Renderer.charoption.getCompactRenderedString;
        case UrlUtil.PG_RECIPES:
            return Renderer.recipe.getCompactRenderedString;
        case UrlUtil.PG_CLASS_SUBCLASS_FEATURES:
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_CREATURE_FEATURES:
            return Renderer.hover.getGenericCompactRenderedString;
        case UrlUtil.PG_DECKS:
            return Renderer.deck.getCompactRenderedString;
        case "classfeature":
        case "classFeature":
            return Renderer.hover.getGenericCompactRenderedString;
        case "subclassfeature":
        case "subclassFeature":
            return Renderer.hover.getGenericCompactRenderedString;
        case "citation":
            return Renderer.hover.getGenericCompactRenderedString;
        default:
            if (Renderer[page]?.getCompactRenderedString)
                return Renderer[page].getCompactRenderedString;
            return null;
        }
    },

    getFnBindListenersCompact(page) {
        switch (page) {
        case UrlUtil.PG_BESTIARY:
            return Renderer.monster.bindListenersCompact;
        case UrlUtil.PG_RACES:
            return Renderer.race.bindListenersCompact;
        default:
            return null;
        }
    },

    _pageToFluffFn(page) {
        switch (page) {
        case UrlUtil.PG_BESTIARY:
            return Renderer.monster.pGetFluff;
        case UrlUtil.PG_ITEMS:
            return Renderer.item.pGetFluff;
        case UrlUtil.PG_CONDITIONS_DISEASES:
            return Renderer.condition.pGetFluff;
        case UrlUtil.PG_SPELLS:
            return Renderer.spell.pGetFluff;
        case UrlUtil.PG_RACES:
            return Renderer.race.pGetFluff;
        case UrlUtil.PG_BACKGROUNDS:
            return Renderer.background.pGetFluff;
        case UrlUtil.PG_FEATS:
            return Renderer.feat.pGetFluff;
        case UrlUtil.PG_LANGUAGES:
            return Renderer.language.pGetFluff;
        case UrlUtil.PG_VEHICLES:
            return Renderer.vehicle.pGetFluff;
        case UrlUtil.PG_CHAR_CREATION_OPTIONS:
            return Renderer.charoption.pGetFluff;
        case UrlUtil.PG_RECIPES:
            return Renderer.recipe.pGetFluff;
        default:
            return null;
        }
    },

    isSmallScreen(evt) {
        if (typeof window === "undefined")
            return false;

        evt = evt || {};
        const win = (evt.view || {}).window || window;
        return win.innerWidth <= 768;
    },

    $getHoverContent_stats(page, toRender, opts, renderFnOpts) {
        opts = opts || {};
        if (page === UrlUtil.PG_RECIPES)
            opts = {
                ...MiscUtil.copyFast(opts),
                isBookContent: true
            };

        const fnRender = opts.fnRender || Renderer.hover.getFnRenderCompact(page, {
            isStatic: opts.isStatic
        });
        const $out = $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}">${fnRender(toRender, renderFnOpts)}</table>`;

        if (!opts.isStatic) {
            const fnBind = Renderer.hover.getFnBindListenersCompact(page);
            if (fnBind)
                fnBind(toRender, $out[0]);
        }

        return $out;
    },

    $getHoverContent_fluff(page, toRender, opts, renderFnOpts) {
        opts = opts || {};
        if (page === UrlUtil.PG_RECIPES)
            opts = {
                ...MiscUtil.copyFast(opts),
                isBookContent: true
            };

        if (!toRender) {
            return $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}"><tr class="text"><td colspan="6" class="p-2 ve-text-center">${Renderer.utils.HTML_NO_INFO}</td></tr></table>`;
        }

        toRender = MiscUtil.copyFast(toRender);

        if (toRender.images && toRender.images.length) {
            const cachedImages = MiscUtil.copyFast(toRender.images);
            delete toRender.images;

            toRender.entries = toRender.entries || [];
            const hasText = toRender.entries.length > 0;
            if (hasText)
                toRender.entries.unshift({
                    type: "hr"
                });
            cachedImages[0].maxHeight = 33;
            cachedImages[0].maxHeightUnits = "vh";
            toRender.entries.unshift(cachedImages[0]);

            if (cachedImages.length > 1) {
                if (hasText)
                    toRender.entries.push({
                        type: "hr"
                    });
                toRender.entries.push(...cachedImages.slice(1));
            }
        }

        return $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}">${Renderer.generic.getCompactRenderedString(toRender, renderFnOpts)}</table>`;
    },

    $getHoverContent_statsCode(toRender, {isSkipClean=false, title=null}={}) {
        const cleanCopy = isSkipClean ? toRender : DataUtil.cleanJson(MiscUtil.copyFast(toRender));
        return Renderer.hover.$getHoverContent_miscCode(title || [cleanCopy.name, "Source Data"].filter(Boolean).join(" \u2014 "), JSON.stringify(cleanCopy, null, "\t"), );
    },

    $getHoverContent_miscCode(name, code) {
        const toRenderCode = {
            type: "code",
            name,
            preformatted: code,
        };
        return $$`<table class="w-100 stats stats--book">${Renderer.get().render(toRenderCode)}</table>`;
    },

    $getHoverContent_generic(toRender, opts) {
        opts = opts || {};

        return $$`<table class="w-100 stats ${opts.isBookContent || opts.isLargeBookContent ? "stats--book" : ""} ${opts.isLargeBookContent ? "stats--book-large" : ""}">${Renderer.hover.getGenericCompactRenderedString(toRender, opts.depth || 0)}</table>`;
    },

    doPopoutCurPage(evt, entity) {
        const page = UrlUtil.getCurrentPage();
        const $content = Renderer.hover.$getHoverContent_stats(page, entity);
        Renderer.hover.getShowWindow($content, Renderer.hover.getWindowPositionFromEvent(evt), {
            pageUrl: `#${UrlUtil.autoEncodeHash(entity)}`,
            title: entity._displayName || entity.name,
            isPermanent: true,
            isBookContent: page === UrlUtil.PG_RECIPES,
            sourceData: entity,
        }, );
    },
};

Renderer.getNames = function(nameStack, entry, opts) {
    opts = opts || {};
    if (opts.maxDepth == null)
        opts.maxDepth = false;
    if (opts.depth == null)
        opts.depth = 0;

    if (opts.typeBlocklist && entry.type && opts.typeBlocklist.has(entry.type))
        return;

    if (opts.maxDepth !== false && opts.depth > opts.maxDepth)
        return;
    if (entry.name)
        nameStack.push(Renderer.stripTags(entry.name));
    if (entry.entries) {
        let nextDepth = entry.type === "section" ? -1 : entry.type === "entries" ? opts.depth + 1 : opts.depth;
        for (const eX of entry.entries) {
            const nxtOpts = {
                ...opts
            };
            nxtOpts.depth = nextDepth;
            Renderer.getNames(nameStack, eX, nxtOpts);
        }
    } else if (entry.items) {
        for (const eX of entry.items) {
            Renderer.getNames(nameStack, eX, opts);
        }
    }
}
;

Renderer.getNumberedNames = function(entry) {
    const renderer = new Renderer().setTrackTitles(true);
    renderer.render(entry);
    const titles = renderer.getTrackedTitles();
    const out = {};
    Object.entries(titles).forEach(([k,v])=>{
        v = Renderer.stripTags(v);
        out[v] = Number(k);
    }
    );
    return out;
}
;

Renderer.findName = function(entry) {
    return CollectionUtil.dfs(entry, {
        prop: "name"
    });
}
;
Renderer.findSource = function(entry) {
    return CollectionUtil.dfs(entry, {
        prop: "source"
    });
}
;
Renderer.findEntry = function(entry) {
    return CollectionUtil.dfs(entry, {
        fnMatch: obj=>obj.name && obj?.entries?.length
    });
}
;

Renderer.stripTags = function(str) {
    if (!str)
        return str;
    let nxtStr = Renderer._stripTagLayer(str);
    while (nxtStr.length !== str.length) {
        str = nxtStr;
        nxtStr = Renderer._stripTagLayer(str);
    }
    return nxtStr;
}
;

Renderer._stripTagLayer = function(str) {
    if (str.includes("{@")) {
        const tagSplit = Renderer.splitByTags(str);
        return tagSplit.filter(it=>it).map(it=>{
            if (it.startsWith("{@")) {
                let[tag,text] = Renderer.splitFirstSpace(it.slice(1, -1));
                const tagInfo = Renderer.tag.TAG_LOOKUP[tag];
                if (!tagInfo)
                    throw new Error(`Unhandled tag: "${tag}"`);
                return tagInfo.getStripped(tag, text);
            } else
                return it;
        }
        ).join("");
    }
    return str;
}
;

Renderer.getRollableRow = function(row, opts) {
    opts = opts || {};

    if (row[0]?.type === "cell" && (row[0]?.roll?.exact != null || (row[0]?.roll?.min != null && row[0]?.roll?.max != null)))
        return row;

    row = MiscUtil.copyFast(row);
    try {
        const cleanRow = String(row[0]).trim();

        const mLowHigh = /^(\d+) or (lower|higher)$/i.exec(cleanRow);
        if (mLowHigh) {
            row[0] = {
                type: "cell",
                entry: cleanRow
            };
            if (mLowHigh[2].toLowerCase() === "lower") {
                row[0].roll = {
                    min: -Renderer.dice.POS_INFINITE,
                    max: Number(mLowHigh[1]),
                };
            } else {
                row[0].roll = {
                    min: Number(mLowHigh[1]),
                    max: Renderer.dice.POS_INFINITE,
                };
            }

            return row;
        }

        const m = /^(\d+)([-\u2012\u2013](\d+))?$/.exec(cleanRow);
        if (m) {
            if (m[1] && !m[2]) {
                row[0] = {
                    type: "cell",
                    roll: {
                        exact: Number(m[1]),
                    },
                };
                if (m[1][0] === "0")
                    row[0].roll.pad = true;
                Renderer.getRollableRow._handleInfiniteOpts(row, opts);
            } else {
                row[0] = {
                    type: "cell",
                    roll: {
                        min: Number(m[1]),
                        max: Number(m[3]),
                    },
                };
                if (m[1][0] === "0" || m[3][0] === "0")
                    row[0].roll.pad = true;
                Renderer.getRollableRow._handleInfiniteOpts(row, opts);
            }
        } else {
            const m = /^(\d+)\+$/.exec(row[0]);
            row[0] = {
                type: "cell",
                roll: {
                    min: Number(m[1]),
                    max: Renderer.dice.POS_INFINITE,
                },
            };
        }
    } catch (e) {
        if (opts.cbErr)
            opts.cbErr(row[0], e);
    }
    return row;
}
;
Renderer.getRollableRow._handleInfiniteOpts = function(row, opts) {
    if (!opts.isForceInfiniteResults)
        return;

    const isExact = row[0].roll.exact != null;

    if (opts.isFirstRow) {
        if (!isExact)
            row[0].roll.displayMin = row[0].roll.min;
        row[0].roll.min = -Renderer.dice.POS_INFINITE;
    }

    if (opts.isLastRow) {
        if (!isExact)
            row[0].roll.displayMax = row[0].roll.max;
        row[0].roll.max = Renderer.dice.POS_INFINITE;
    }
}
;

Renderer.initLazyImageLoaders = function() {
    const images = document.querySelectorAll(`img[data-src]`);

    Renderer.utils.lazy.destroyObserver({
        observerId: "images"
    });

    const observer = Renderer.utils.lazy.getCreateObserver({
        observerId: "images",
        fnOnObserve: ({entry})=>{
            const $img = $(entry.target);
            $img.attr("src", $img.attr("data-src")).removeAttr("data-src");
        }
        ,
    });

    images.forEach(img=>observer.track(img));
}
;

Renderer.HEAD_NEG_1 = "rd__b--0";
Renderer.HEAD_0 = "rd__b--1";
Renderer.HEAD_1 = "rd__b--2";
Renderer.HEAD_2 = "rd__b--3";
Renderer.HEAD_2_SUB_VARIANT = "rd__b--4";
Renderer.DATA_NONE = "data-none";

"use strict";

Renderer.dice = {
    SYSTEM_USER: {
        name: "Avandra",
    },
    POS_INFINITE: 100000000000000000000,
    _SYMBOL_PARSE_FAILED: Symbol("parseFailed"),

    _$wrpRoll: null,
    _$minRoll: null,
    _$iptRoll: null,
    _$outRoll: null,
    _$head: null,
    _hist: [],
    _histIndex: null,
    _$lastRolledBy: null,
    _storage: null,

    _isManualMode: false,

    DICE: [4, 6, 8, 10, 12, 20, 100],
    getNextDice(faces) {
        const idx = Renderer.dice.DICE.indexOf(faces);
        if (~idx)
            return Renderer.dice.DICE[idx + 1];
        else
            return null;
    },

    getPreviousDice(faces) {
        const idx = Renderer.dice.DICE.indexOf(faces);
        if (~idx)
            return Renderer.dice.DICE[idx - 1];
        else
            return null;
    },

    _panel: null,
    bindDmScreenPanel(panel, title) {
        if (Renderer.dice._panel) {
            Renderer.dice.unbindDmScreenPanel();
        }
        Renderer.dice._showBox();
        Renderer.dice._panel = panel;
        panel.doPopulate_Rollbox(title);
    },

    unbindDmScreenPanel() {
        if (Renderer.dice._panel) {
            $(`body`).append(Renderer.dice._$wrpRoll);
            Renderer.dice._panel.close$TabContent();
            Renderer.dice._panel = null;
            Renderer.dice._hideBox();
            Renderer.dice._$wrpRoll.removeClass("rollbox-panel");
        }
    },

    get$Roller() {
        return Renderer.dice._$wrpRoll;
    },

    parseRandomise2(str) {
        if (!str || !str.trim())
            return null;
        const wrpTree = Renderer.dice.lang.getTree3(str);
        if (wrpTree)
            return wrpTree.tree.evl({});
        else
            return null;
    },

    parseAverage(str) {
        if (!str || !str.trim())
            return null;
        const wrpTree = Renderer.dice.lang.getTree3(str);
        if (wrpTree)
            return wrpTree.tree.avg({});
        else
            return null;
    },

    _showBox() {
        Renderer.dice._$minRoll.hideVe();
        Renderer.dice._$wrpRoll.showVe();
        Renderer.dice._$iptRoll.prop("placeholder", `${Renderer.dice._getRandomPlaceholder()} or "/help"`);
    },

    _hideBox() {
        Renderer.dice._$minRoll.showVe();
        Renderer.dice._$wrpRoll.hideVe();
    },

    _getRandomPlaceholder() {
        const count = RollerUtil.randomise(10);
        const faces = Renderer.dice.DICE[RollerUtil.randomise(Renderer.dice.DICE.length - 1)];
        const mod = (RollerUtil.randomise(3) - 2) * RollerUtil.randomise(10);
        const drop = (count > 1) && RollerUtil.randomise(5) === 5;
        const dropDir = drop ? RollerUtil.randomise(2) === 2 ? "h" : "l" : "";
        const dropAmount = drop ? RollerUtil.randomise(count - 1) : null;
        return `${count}d${faces}${drop ? `d${dropDir}${dropAmount}` : ""}${mod < 0 ? mod : mod > 0 ? `+${mod}` : ""}`;
    },

    async _pInit() {
        const $wrpRoll = $(`<div class="rollbox ve-flex-col min-h-0"></div>`).hideVe();
        const $minRoll = $(`<button class="rollbox-min"><span class="glyphicon glyphicon-chevron-up"></span></button>`).on("click", ()=>{
            Renderer.dice._showBox();
            Renderer.dice._$iptRoll.focus();
        }
        );
        const $head = $(`<div class="head-roll"><span class="hdr-roll">Dice Roller</span><span class="p-2 glyphicon glyphicon-remove"></span></div>`).on("click", ()=>{
            if (!Renderer.dice._panel)
                Renderer.dice._hideBox();
        }
        );
        const $outRoll = $(`<div class="out-roll">`);
        const $iptRoll = $(`<input class="ipt-roll form-control" autocomplete="off" spellcheck="false">`).on("keypress", async evt=>{
            evt.stopPropagation();
            if (evt.key !== "Enter")
                return;

            const strDice = $iptRoll.val();
            const result = await Renderer.dice.pRoll2(strDice, {
                isUser: true,
                name: "Anon",
            }, );
            $iptRoll.val("");

            if (result === Renderer.dice._SYMBOL_PARSE_FAILED) {
                Renderer.dice._showInvalid();
                $iptRoll.addClass("form-control--error");
            }
        }
        ).on("keydown", (evt)=>{
            $iptRoll.removeClass("form-control--error");

            if (evt.key === "ArrowUp") {
                evt.preventDefault();
                Renderer.dice._prevHistory();
                return;
            }

            if (evt.key === "ArrowDown") {
                evt.preventDefault();
                Renderer.dice._nextHistory();
            }
        }
        );
        $wrpRoll.append($head).append($outRoll).append($iptRoll);

        Renderer.dice._$wrpRoll = $wrpRoll;
        Renderer.dice._$minRoll = $minRoll;
        Renderer.dice._$head = $head;
        Renderer.dice._$outRoll = $outRoll;
        Renderer.dice._$iptRoll = $iptRoll;

        $(`body`).append($minRoll).append($wrpRoll);

        $wrpRoll.on("click", ".out-roll-item-code", (evt)=>Renderer.dice._$iptRoll.val($(evt.target).text()).focus());

        Renderer.dice.storage = await StorageUtil.pGet(VeCt.STORAGE_ROLLER_MACRO) || {};
    },

    _prevHistory() {
        Renderer.dice._histIndex--;
        Renderer.dice._prevNextHistory_load();
    },
    _nextHistory() {
        Renderer.dice._histIndex++;
        Renderer.dice._prevNextHistory_load();
    },

    _prevNextHistory_load() {
        Renderer.dice._cleanHistoryIndex();
        const nxtVal = Renderer.dice._hist[Renderer.dice._histIndex];
        Renderer.dice._$iptRoll.val(nxtVal);
        if (nxtVal)
            Renderer.dice._$iptRoll[0].selectionStart = Renderer.dice._$iptRoll[0].selectionEnd = nxtVal.length;
    },

    _cleanHistoryIndex: ()=>{
        if (!Renderer.dice._hist.length) {
            Renderer.dice._histIndex = null;
        } else {
            Renderer.dice._histIndex = Math.min(Renderer.dice._hist.length, Math.max(Renderer.dice._histIndex, 0));
        }
    }
    ,

    _addHistory: (str)=>{
        Renderer.dice._hist.push(str);
        Renderer.dice._histIndex = Renderer.dice._hist.length;
    }
    ,

    _scrollBottom: ()=>{
        Renderer.dice._$outRoll.scrollTop(1e10);
    }
    ,

    async pRollerClickUseData(evt, ele) {
        evt.stopPropagation();
        evt.preventDefault();

        const $ele = $(ele);
        const rollData = $ele.data("packed-dice");
        let name = $ele.data("roll-name");
        let shiftKey = evt.shiftKey;
        let ctrlKey = EventUtil.isCtrlMetaKey(evt);

        const options = rollData.toRoll.split(";").map(it=>it.trim()).filter(Boolean);

        let chosenRollData;
        if (options.length > 1) {
            const cpyRollData = MiscUtil.copyFast(rollData);
            const menu = ContextUtil.getMenu([new ContextUtil.Action("Choose Roll",null,{
                isDisabled: true
            },), null, ...options.map(it=>new ContextUtil.Action(`Roll ${it}`,evt=>{
                shiftKey = shiftKey || evt.shiftKey;
                ctrlKey = ctrlKey || (EventUtil.isCtrlMetaKey(evt));
                cpyRollData.toRoll = it;
                return cpyRollData;
            }
            ,)), ]);

            chosenRollData = await ContextUtil.pOpenMenu(evt, menu);
        } else
            chosenRollData = rollData;

        if (!chosenRollData)
            return;

        const rePrompt = /#\$prompt_number:?([^$]*)\$#/g;
        const results = [];
        let m;
        while ((m = rePrompt.exec(chosenRollData.toRoll))) {
            const optionsRaw = m[1];
            const opts = {};
            if (optionsRaw) {
                const spl = optionsRaw.split(",");
                spl.map(it=>it.trim()).forEach(part=>{
                    const [k,v] = part.split("=").map(it=>it.trim());
                    switch (k) {
                    case "min":
                    case "max":
                        opts[k] = Number(v);
                        break;
                    default:
                        opts[k] = v;
                        break;
                    }
                }
                );
            }

            if (opts.min == null)
                opts.min = 0;
            if (opts.max == null)
                opts.max = Renderer.dice.POS_INFINITE;
            if (opts.default == null)
                opts.default = 0;

            const input = await InputUiUtil.pGetUserNumber(opts);
            if (input == null)
                return;
            results.push(input);
        }

        const rollDataCpy = MiscUtil.copyFast(chosenRollData);
        rePrompt.lastIndex = 0;
        rollDataCpy.toRoll = rollDataCpy.toRoll.replace(rePrompt, ()=>results.shift());

        let rollDataCpyToRoll;
        if (rollData.prompt) {
            const sortedKeys = Object.keys(rollDataCpy.prompt.options).sort(SortUtil.ascSortLower);
            const menu = ContextUtil.getMenu([new ContextUtil.Action(rollDataCpy.prompt.entry,null,{
                isDisabled: true
            }), null, ...sortedKeys.map(it=>{
                const title = rollDataCpy.prompt.mode === "psi" ? `${it} point${it === "1" ? "" : "s"}` : `${Parser.spLevelToFull(it)} level`;

                return new ContextUtil.Action(title,evt=>{
                    shiftKey = shiftKey || evt.shiftKey;
                    ctrlKey = ctrlKey || (EventUtil.isCtrlMetaKey(evt));

                    const fromScaling = rollDataCpy.prompt.options[it];
                    if (!fromScaling) {
                        name = "";
                        return rollDataCpy;
                    } else {
                        name = rollDataCpy.prompt.mode === "psi" ? `${it} psi activation` : `${Parser.spLevelToFull(it)}-level cast`;
                        rollDataCpy.toRoll += `+${fromScaling}`;
                        return rollDataCpy;
                    }
                }
                ,);
            }
            ), ]);

            rollDataCpyToRoll = await ContextUtil.pOpenMenu(evt, menu);
        } else
            rollDataCpyToRoll = rollDataCpy;

        if (!rollDataCpyToRoll)
            return;
        await Renderer.dice.pRollerClick({
            shiftKey,
            ctrlKey
        }, ele, JSON.stringify(rollDataCpyToRoll), name);
    },

    __rerollNextInlineResult(ele) {
        const $ele = $(ele);
        const $result = $ele.next(`.result`);
        const r = Renderer.dice.__rollPackedData($ele);
        $result.text(r);
    },

    __rollPackedData($ele) {
        const wrpTree = Renderer.dice.lang.getTree3($ele.data("packed-dice").toRoll);
        return wrpTree.tree.evl({});
    },

    $getEleUnknownTableRoll(total) {
        return $(Renderer.dice._pRollerClick_getMsgBug(total));
    },

    _pRollerClick_getMsgBug(total) {
        return `<span class="message">No result found matching roll ${total}?! <span class="help-subtle" title="Bug!">🐛</span></span>`;
    },

    async pRollerClick(evtMock, ele, packed, name) {
        const $ele = $(ele);
        const entry = JSON.parse(packed);
        const additionalData = {
            ...ele.dataset
        };

        const rolledBy = {
            name: Renderer.dice._pRollerClick_attemptToGetNameOfRoller({
                $ele
            }),
            label: name != null ? name : Renderer.dice._pRollerClick_attemptToGetNameOfRoll({
                entry,
                $ele
            }),
        };

        const modRollMeta = Renderer.dice.getEventModifiedRollMeta(evtMock, entry);
        const $parent = $ele.closest("th, p, table");

        const rollResult = await this._pRollerClick_pGetResult({
            $parent,
            $ele,
            entry,
            modRollMeta,
            rolledBy,
            additionalData,
        });

        if (!entry.autoRoll)
            return;

        const $tgt = $ele.next(`[data-rd-is-autodice-result="true"]`);
        const curTxt = $tgt.text();
        $tgt.text(rollResult);
        JqueryUtil.showCopiedEffect($tgt, curTxt, true);
    },

    async _pRollerClick_pGetResult({$parent, $ele, entry, modRollMeta, rolledBy, additionalData}) {
        const sharedRollOpts = {
            rollCount: modRollMeta.rollCount,
            additionalData,
            isHidden: !!entry.autoRoll,
        };

        if ($parent.is("th") && $parent.attr("data-rd-isroller") === "true") {
            if ($parent.attr("data-rd-namegeneratorrolls")) {
                return Renderer.dice._pRollerClick_pRollGeneratorTable({
                    $parent,
                    $ele,
                    rolledBy,
                    modRollMeta,
                    rollOpts: sharedRollOpts,
                });
            }

            return Renderer.dice.pRollEntry(modRollMeta.entry, rolledBy, {
                ...sharedRollOpts,
                fnGetMessage: Renderer.dice._pRollerClick_fnGetMessageTable.bind(Renderer.dice, $ele),
            }, );
        }

        return Renderer.dice.pRollEntry(modRollMeta.entry, rolledBy, {
            ...sharedRollOpts,
        }, );
    },

    _pRollerClick_fnGetMessageTable($ele, total) {
        const elesTd = Renderer.dice._pRollerClick_$getTdsFromTotal($ele, total);
        if (elesTd) {
            const tableRow = elesTd.map(ele=>ele.innerHTML.trim()).filter(it=>it).join(" | ");
            const $row = $(`<span class="message">${tableRow}</span>`);
            Renderer.dice._pRollerClick_rollInlineRollers($ele);
            return $row.html();
        }
        return Renderer.dice._pRollerClick_getMsgBug(total);
    },

    _pRollerClick_attemptToGetNameOfRoll({entry, $ele}) {
        if (entry.name)
            return entry.name;

        let titleMaybe = $ele.closest(`table:not(.stats)`).children(`caption`).text();
        if (titleMaybe)
            return titleMaybe.trim();

        titleMaybe = $ele.parent().children(`.rd__list-item-name`).text();
        if (titleMaybe)
            return titleMaybe.trim().replace(/[.,:]$/, "");

        titleMaybe = $ele.closest(`div`).children(`.rd__h`).first().find(`.entry-title-inner`).text();
        if (titleMaybe) {
            titleMaybe = titleMaybe.trim().replace(/[.,:]$/, "");
            return titleMaybe;
        }

        titleMaybe = $ele.closest(`table.stats`).children(`tbody`).first().children(`tr`).first().find(`.rnd-name .stats-name`).text();
        if (titleMaybe)
            return titleMaybe.trim();

        if (UrlUtil.getCurrentPage() === UrlUtil.PG_CHARACTERS) {
            titleMaybe = ($ele.closest(`.chr-entity__row`).find(".chr-entity__ipt-name").val() || "").trim();
            if (titleMaybe)
                return titleMaybe;
        }

        return titleMaybe;
    },

    _pRollerClick_attemptToGetNameOfRoller({$ele}) {
        const $hov = $ele.closest(`.hwin`);
        if ($hov.length)
            return $hov.find(`.stats-name`).first().text();
        const $roll = $ele.closest(`.out-roll-wrp`);
        if ($roll.length)
            return $roll.data("name");
        const $dispPanelTitle = $ele.closest(`.dm-screen-panel`).children(`.panel-control-title`);
        if ($dispPanelTitle.length)
            return $dispPanelTitle.text().trim();
        let name = document.title.replace("- 5etools", "").trim();
        return name === "DM Screen" ? "Dungeon Master" : name;
    },

    _pRollerClick_$getTdsFromTotal($ele, total) {
        const $table = $ele.closest(`table`);
        const $tdRoll = $table.find(`td`).filter((i,e)=>{
            const $e = $(e);
            if (!$e.closest(`table`).is($table))
                return false;
            return total >= Number($e.data("roll-min")) && total <= Number($e.data("roll-max"));
        }
        );
        if ($tdRoll.length && $tdRoll.nextAll().length) {
            return $tdRoll.nextAll().get();
        }
        return null;
    },

    _pRollerClick_rollInlineRollers($ele) {
        $ele.find(`.render-roller`).each((i,e)=>{
            const $e = $(e);
            const r = Renderer.dice.__rollPackedData($e);
            $e.attr("onclick", `Renderer.dice.__rerollNextInlineResult(this)`);
            $e.after(` (<span class="result">${r}</span>)`);
        }
        );
    },

    _pRollerClick_fnGetMessageGeneratorTable($ele, ix, total) {
        const elesTd = Renderer.dice._pRollerClick_$getTdsFromTotal($ele, total);
        if (elesTd) {
            const $row = $(`<span class="message">${elesTd[ix].innerHTML.trim()}</span>`);
            Renderer.dice._pRollerClick_rollInlineRollers($ele);
            return $row.html();
        }
        return Renderer.dice._pRollerClick_getMsgBug(total);
    },

    async _pRollerClick_pRollGeneratorTable({$parent, $ele, rolledBy, modRollMeta, rollOpts}) {
        Renderer.dice.addElement({
            rolledBy,
            html: `<i>${rolledBy.label}:</i>`,
            isMessage: true
        });

        let total = 0;

        const out = [];
        const numRolls = Number($parent.attr("data-rd-namegeneratorrolls"));
        const $ths = $ele.closest(`table`).find(`th`);
        for (let i = 0; i < numRolls; ++i) {
            const cpyRolledBy = MiscUtil.copyFast(rolledBy);
            cpyRolledBy.label = $($ths.get(i + 1)).text().trim();

            const result = await Renderer.dice.pRollEntry(modRollMeta.entry, cpyRolledBy, {
                ...rollOpts,
                fnGetMessage: Renderer.dice._pRollerClick_fnGetMessageGeneratorTable.bind(Renderer.dice, $ele, i),
            }, );
            total += result;
            const elesTd = Renderer.dice._pRollerClick_$getTdsFromTotal($ele, result);

            if (!elesTd) {
                out.push(`(no result)`);
                continue;
            }

            out.push(elesTd[i].innerHTML.trim());
        }

        Renderer.dice.addElement({
            rolledBy,
            html: `= ${out.join(" ")}`,
            isMessage: true
        });

        return total;
    },

    getEventModifiedRollMeta(evt, entry) {
        const out = {
            rollCount: 1,
            entry
        };

        if (evt.shiftKey) {
            if (entry.subType === "damage") {
                const dice = [];
                entry.toRoll.replace(/\s+/g, "").replace(/\d*?d\d+/gi, m0=>dice.push(m0));
                entry.toRoll = `${entry.toRoll}${dice.length ? `+${dice.join("+")}` : ""}`;
            } else if (entry.subType === "d20") {
                if (entry.d20mod != null)
                    entry.toRoll = `2d20dl1${entry.d20mod}`;
                else
                    entry.toRoll = entry.toRoll.replace(/^\s*1?\s*d\s*20/, "2d20dl1");
            } else
                out.rollCount = 2;
        }

        if (EventUtil.isCtrlMetaKey(evt)) {
            if (entry.subType === "damage") {
                entry.toRoll = `floor((${entry.toRoll}) / 2)`;
            } else if (entry.subType === "d20") {
                if (entry.d20mod != null)
                    entry.toRoll = `2d20dh1${entry.d20mod}`;
                else
                    entry.toRoll = entry.toRoll.replace(/^\s*1?\s*d\s*20/, "2d20dh1");
            } else
                out.rollCount = 2;
        }

        return out;
    },

    async pRoll2(str, rolledBy, opts) {
        opts = opts || {};
        str = str.trim().replace(/\/r(?:oll)? /gi, "").trim();
        if (!str)
            return;
        if (rolledBy.isUser)
            Renderer.dice._addHistory(str);

        if (str.startsWith("/"))
            return Renderer.dice._pHandleCommand(str, rolledBy);
        if (str.startsWith("#"))
            return Renderer.dice._pHandleSavedRoll(str, rolledBy, opts);

        const [head,...tail] = str.split(":");
        if (tail.length) {
            str = tail.join(":");
            rolledBy.label = head;
        }
        const wrpTree = Renderer.dice.lang.getTree3(str);
        if (!wrpTree)
            return Renderer.dice._SYMBOL_PARSE_FAILED;
        return Renderer.dice._pHandleRoll2(wrpTree, rolledBy, opts);
    },

    async pRollEntry(entry, rolledBy, opts) {
        opts = opts || {};

        const rollCount = Math.round(opts.rollCount || 1);
        delete opts.rollCount;
        if (rollCount <= 0)
            throw new Error(`Invalid roll count: ${rollCount} (must be a positive integer)`);

        const wrpTree = Renderer.dice.lang.getTree3(entry.toRoll);
        wrpTree.tree.successThresh = entry.successThresh;
        wrpTree.tree.successMax = entry.successMax;
        wrpTree.tree.chanceSuccessText = entry.chanceSuccessText;
        wrpTree.tree.chanceFailureText = entry.chanceFailureText;
        wrpTree.tree.isColorSuccessFail = entry.isColorSuccessFail;

        const results = [];
        if (rollCount > 1 && !opts.isHidden)
            Renderer.dice._showMessage(`Rolling twice...`, rolledBy);
        for (let i = 0; i < rollCount; ++i) {
            const result = await Renderer.dice._pHandleRoll2(wrpTree, rolledBy, opts);
            if (result == null)
                return null;
            results.push(result);
        }
        return Math.max(...results);
    },

    async _pHandleRoll2(wrpTree, rolledBy, opts) {
        opts = {
            ...opts
        };

        if (wrpTree.meta && wrpTree.meta.hasPb) {
            const userPb = await InputUiUtil.pGetUserNumber({
                min: 0,
                int: true,
                title: "Enter Proficiency Bonus",
                default: 2,
                storageKey_default: "dice.playerProficiencyBonus",
                isGlobal_default: true,
            });
            if (userPb == null)
                return null;
            opts.pb = userPb;
        }

        if (wrpTree.meta && wrpTree.meta.hasSummonSpellLevel) {
            const predefinedSpellLevel = opts.additionalData?.summonedBySpellLevel != null && !isNaN(opts.additionalData?.summonedBySpellLevel) ? Number(opts.additionalData.summonedBySpellLevel) : null;

            const userSummonSpellLevel = await InputUiUtil.pGetUserNumber({
                min: predefinedSpellLevel ?? 0,
                int: true,
                title: "Enter Spell Level",
                default: predefinedSpellLevel ?? 1,
            });
            if (userSummonSpellLevel == null)
                return null;
            opts.summonSpellLevel = userSummonSpellLevel;
        }

        if (wrpTree.meta && wrpTree.meta.hasSummonClassLevel) {
            const predefinedClassLevel = opts.additionalData?.summonedByClassLevel != null && !isNaN(opts.additionalData?.summonedByClassLevel) ? Number(opts.additionalData.summonedByClassLevel) : null;

            const userSummonClassLevel = await InputUiUtil.pGetUserNumber({
                min: predefinedClassLevel ?? 0,
                int: true,
                title: "Enter Class Level",
                default: predefinedClassLevel ?? 1,
            });
            if (userSummonClassLevel == null)
                return null;
            opts.summonClassLevel = userSummonClassLevel;
        }

        if (Renderer.dice._isManualMode)
            return Renderer.dice._pHandleRoll2_manual(wrpTree.tree, rolledBy, opts);
        else
            return Renderer.dice._pHandleRoll2_automatic(wrpTree.tree, rolledBy, opts);
    },

    _pHandleRoll2_automatic(tree, rolledBy, opts) {
        opts = opts || {};

        if (!opts.isHidden)
            Renderer.dice._showBox();
        Renderer.dice._checkHandleName(rolledBy.name);
        const $out = Renderer.dice._$lastRolledBy;

        if (tree) {
            const meta = {};
            if (opts.pb)
                meta.pb = opts.pb;
            if (opts.summonSpellLevel)
                meta.summonSpellLevel = opts.summonSpellLevel;
            if (opts.summonClassLevel)
                meta.summonClassLevel = opts.summonClassLevel;

            const result = tree.evl(meta);
            const fullHtml = (meta.html || []).join("");
            const allMax = meta.allMax && meta.allMax.length && !(meta.allMax.filter(it=>!it).length);
            const allMin = meta.allMin && meta.allMin.length && !(meta.allMin.filter(it=>!it).length);

            const lbl = rolledBy.label && (!rolledBy.name || rolledBy.label.trim().toLowerCase() !== rolledBy.name.trim().toLowerCase()) ? rolledBy.label : null;

            const ptTarget = opts.target != null ? result >= opts.target ? ` <b>&geq;${opts.target}</b>` : ` <span class="ve-muted">&lt;${opts.target}</span>` : "";

            const isThreshSuccess = tree.successThresh != null && result > (tree.successMax || 100) - tree.successThresh;
            const isColorSuccess = tree.isColorSuccessFail || !tree.chanceSuccessText;
            const isColorFail = tree.isColorSuccessFail || !tree.chanceFailureText;
            const totalPart = tree.successThresh != null ? `<span class="roll ${isThreshSuccess && isColorSuccess ? "roll-max" : !isThreshSuccess && isColorFail ? "roll-min" : ""}">${isThreshSuccess ? (tree.chanceSuccessText || "Success!") : (tree.chanceFailureText || "Failure")}</span>` : `<span class="roll ${allMax ? "roll-max" : allMin ? "roll-min" : ""}">${result}</span>`;

            const title = `${rolledBy.name ? `${rolledBy.name} \u2014 ` : ""}${lbl ? `${lbl}: ` : ""}${tree}`;

            const message = opts.fnGetMessage ? opts.fnGetMessage(result) : null;
            ExtensionUtil.doSendRoll({
                dice: tree.toString(),
                result,
                rolledBy: rolledBy.name,
                label: [lbl, message].filter(Boolean).join(" \u2013 "),
            });

            if (!opts.isHidden) {
                $out.append(`
					<div class="out-roll-item" title="${title}">
						<div>
							${lbl ? `<span class="roll-label">${lbl}: </span>` : ""}
							${totalPart}
							${ptTarget}
							<span class="all-rolls ve-muted">${fullHtml}</span>
							${message ? `<span class="message">${message}</span>` : ""}
						</div>
						<div class="out-roll-item-button-wrp">
							<button title="Copy to input" class="btn btn-default btn-xs btn-copy-roll" onclick="Renderer.dice._$iptRoll.val('${tree.toString().replace(/\s+/g, "")}'); Renderer.dice._$iptRoll.focus()"><span class="glyphicon glyphicon-pencil"></span></button>
						</div>
					</div>`);

                Renderer.dice._scrollBottom();
            }

            return result;
        } else {
            if (!opts.isHidden) {
                $out.append(`<div class="out-roll-item">Invalid input! Try &quot;/help&quot;</div>`);
                Renderer.dice._scrollBottom();
            }
            return null;
        }
    },

    _pHandleRoll2_manual(tree, rolledBy, opts) {
        opts = opts || {};

        if (!tree)
            return JqueryUtil.doToast({
                type: "danger",
                content: `Invalid roll input!`
            });

        const title = (rolledBy.label || "").toTitleCase() || "Roll Dice";
        const $dispDice = $(`<div class="p-2 bold ve-flex-vh-center rll__prompt-header">${tree.toString()}</div>`);
        if (opts.isResultUsed) {
            return InputUiUtil.pGetUserNumber({
                title,
                $elePre: $dispDice,
            });
        } else {
            const {$modalInner} = UiUtil.getShowModal({
                title,
                isMinHeight0: true,
            });
            $dispDice.appendTo($modalInner);
            return null;
        }
    },

    _showMessage(message, rolledBy) {
        Renderer.dice._showBox();
        Renderer.dice._checkHandleName(rolledBy.name);
        const $out = Renderer.dice._$lastRolledBy;
        $out.append(`<div class="out-roll-item out-roll-item--message">${message}</div>`);
        Renderer.dice._scrollBottom();
    },

    _showInvalid() {
        Renderer.dice._showMessage("Invalid input! Try &quot;/help&quot;", Renderer.dice.SYSTEM_USER);
    },

    _validCommands: new Set(["/c", "/cls", "/clear", "/iterroll"]),
    async _pHandleCommand(com, rolledBy) {
        Renderer.dice._showMessage(`<span class="out-roll-item-code">${com}</span>`, rolledBy);
        const comParsed = Renderer.dice._getParsedCommand(com);
        const [comOp] = comParsed;

        if (comOp === "/help" || comOp === "/h") {
            Renderer.dice._showMessage(`<ul class="rll__list">
					<li>Keep highest; <span class="out-roll-item-code">4d6kh3</span></li>
					<li>Drop lowest; <span class="out-roll-item-code">4d6dl1</span></li>
					<li>Drop highest; <span class="out-roll-item-code">3d4dh1</span></li>
					<li>Keep lowest; <span class="out-roll-item-code">3d4kl1</span></li>

					<li>Reroll equal; <span class="out-roll-item-code">2d4r1</span></li>
					<li>Reroll less; <span class="out-roll-item-code">2d4r&lt;2</span></li>
					<li>Reroll less or equal; <span class="out-roll-item-code">2d4r&lt;=2</span></li>
					<li>Reroll greater; <span class="out-roll-item-code">2d4r&gt;2</span></li>
					<li>Reroll greater equal; <span class="out-roll-item-code">2d4r&gt;=3</span></li>

					<li>Explode equal; <span class="out-roll-item-code">2d4x4</span></li>
					<li>Explode less; <span class="out-roll-item-code">2d4x&lt;2</span></li>
					<li>Explode less or equal; <span class="out-roll-item-code">2d4x&lt;=2</span></li>
					<li>Explode greater; <span class="out-roll-item-code">2d4x&gt;2</span></li>
					<li>Explode greater equal; <span class="out-roll-item-code">2d4x&gt;=3</span></li>

					<li>Count Successes equal; <span class="out-roll-item-code">2d4cs=4</span></li>
					<li>Count Successes less; <span class="out-roll-item-code">2d4cs&lt;2</span></li>
					<li>Count Successes less or equal; <span class="out-roll-item-code">2d4cs&lt;=2</span></li>
					<li>Count Successes greater; <span class="out-roll-item-code">2d4cs&gt;2</span></li>
					<li>Count Successes greater equal; <span class="out-roll-item-code">2d4cs&gt;=3</span></li>

					<li>Margin of Success; <span class="out-roll-item-code">2d4ms=4</span></li>

					<li>Dice pools; <span class="out-roll-item-code">{2d8, 1d6}</span></li>
					<li>Dice pools with modifiers; <span class="out-roll-item-code">{1d20+7, 10}kh1</span></li>

					<li>Rounding; <span class="out-roll-item-code">floor(1.5)</span>, <span class="out-roll-item-code">ceil(1.5)</span>, <span class="out-roll-item-code">round(1.5)</span></li>

					<li>Average; <span class="out-roll-item-code">avg(8d6)</span></li>
					<li>Maximize dice; <span class="out-roll-item-code">dmax(8d6)</span></li>
					<li>Minimize dice; <span class="out-roll-item-code">dmin(8d6)</span></li>

					<li>Other functions; <span class="out-roll-item-code">sign(1d6-3)</span>, <span class="out-roll-item-code">abs(1d6-3)</span>, ...etc.</li>
				</ul>
				Up and down arrow keys cycle input history.<br>
				Anything before a colon is treated as a label (<span class="out-roll-item-code">Fireball: 8d6</span>)<br>
Use <span class="out-roll-item-code">/macro list</span> to list saved macros.<br>
				Use <span class="out-roll-item-code">/macro add myName 1d2+3</span> to add (or update) a macro. Macro names should not contain spaces or hashes.<br>
				Use <span class="out-roll-item-code">/macro remove myName</span> to remove a macro.<br>
				Use <span class="out-roll-item-code">#myName</span> to roll a macro.<br>
				Use <span class="out-roll-item-code">/iterroll roll count [target]</span> to roll multiple times, optionally against a target.
				Use <span class="out-roll-item-code">/clear</span> to clear the roller.`, Renderer.dice.SYSTEM_USER, );
            return;
        }

        if (comOp === "/macro") {
            const [,mode,...others] = comParsed;

            if (!["list", "add", "remove", "clear"].includes(mode))
                Renderer.dice._showInvalid();
            else {
                switch (mode) {
                case "list":
                    if (!others.length) {
                        Object.keys(Renderer.dice.storage).forEach(name=>{
                            Renderer.dice._showMessage(`<span class="out-roll-item-code">#${name}</span> \u2014 ${Renderer.dice.storage[name]}`, Renderer.dice.SYSTEM_USER);
                        }
                        );
                    } else {
                        Renderer.dice._showInvalid();
                    }
                    break;
                case "add":
                    {
                        if (others.length === 2) {
                            const [name,macro] = others;
                            if (name.includes(" ") || name.includes("#"))
                                Renderer.dice._showInvalid();
                            else {
                                Renderer.dice.storage[name] = macro;
                                await Renderer.dice._pSaveMacros();
                                Renderer.dice._showMessage(`Saved macro <span class="out-roll-item-code">#${name}</span>`, Renderer.dice.SYSTEM_USER);
                            }
                        } else {
                            Renderer.dice._showInvalid();
                        }
                        break;
                    }
                case "remove":
                    if (others.length === 1) {
                        if (Renderer.dice.storage[others[0]]) {
                            delete Renderer.dice.storage[others[0]];
                            await Renderer.dice._pSaveMacros();
                            Renderer.dice._showMessage(`Removed macro <span class="out-roll-item-code">#${others[0]}</span>`, Renderer.dice.SYSTEM_USER);
                        } else {
                            Renderer.dice._showMessage(`Macro <span class="out-roll-item-code">#${others[0]}</span> not found`, Renderer.dice.SYSTEM_USER);
                        }
                    } else {
                        Renderer.dice._showInvalid();
                    }
                    break;
                }
            }
            return;
        }

        if (Renderer.dice._validCommands.has(comOp)) {
            switch (comOp) {
            case "/c":
            case "/cls":
            case "/clear":
                Renderer.dice._$outRoll.empty();
                Renderer.dice._$lastRolledBy.empty();
                Renderer.dice._$lastRolledBy = null;
                return;

            case "/iterroll":
                {
                    let[,exp,count,target] = comParsed;

                    if (!exp)
                        return Renderer.dice._showInvalid();
                    const wrpTree = Renderer.dice.lang.getTree3(exp);
                    if (!wrpTree)
                        return Renderer.dice._showInvalid();

                    count = count && !isNaN(count) ? Number(count) : 1;
                    target = target && !isNaN(target) ? Number(target) : undefined;

                    for (let i = 0; i < count; ++i) {
                        await Renderer.dice.pRoll2(exp, {
                            name: "Anon",
                        }, {
                            target,
                        }, );
                    }
                }
            }
            return;
        }

        Renderer.dice._showInvalid();
    },

    async _pSaveMacros() {
        await StorageUtil.pSet(VeCt.STORAGE_ROLLER_MACRO, Renderer.dice.storage);
    },

    _getParsedCommand(str) {
        return str.split(/\s+/);
    },

    _pHandleSavedRoll(id, rolledBy, opts) {
        id = id.replace(/^#/, "");
        const macro = Renderer.dice.storage[id];
        if (macro) {
            rolledBy.label = id;
            const wrpTree = Renderer.dice.lang.getTree3(macro);
            return Renderer.dice._pHandleRoll2(wrpTree, rolledBy, opts);
        } else
            Renderer.dice._showMessage(`Macro <span class="out-roll-item-code">#${id}</span> not found`, Renderer.dice.SYSTEM_USER);
    },

    addRoll({rolledBy, html, $ele}) {
        if (html && $ele)
            throw new Error(`Must specify one of html or $ele!`);

        if (html != null && !html.trim())
            return;

        Renderer.dice._showBox();
        Renderer.dice._checkHandleName(rolledBy.name);

        if (html) {
            Renderer.dice._$lastRolledBy.append(`<div class="out-roll-item" title="${(rolledBy.name || "").qq()}">${html}</div>`);
        } else {
            $$`<div class="out-roll-item" title="${(rolledBy.name || "").qq()}">${$ele}</div>`.appendTo(Renderer.dice._$lastRolledBy);
        }

        Renderer.dice._scrollBottom();
    },

    addElement({rolledBy, html, $ele}) {
        if (html && $ele)
            throw new Error(`Must specify one of html or $ele!`);

        if (html != null && !html.trim())
            return;

        Renderer.dice._showBox();
        Renderer.dice._checkHandleName(rolledBy.name);

        if (html) {
            Renderer.dice._$lastRolledBy.append(`<div class="out-roll-item out-roll-item--message" title="${(rolledBy.name || "").qq()}">${html}</div>`);
        } else {
            $$`<div class="out-roll-item out-roll-item--message" title="${(rolledBy.name || "").qq()}">${$ele}</div>`.appendTo(Renderer.dice._$lastRolledBy);
        }

        Renderer.dice._scrollBottom();
    },

    _checkHandleName(name) {
        if (!Renderer.dice._$lastRolledBy || Renderer.dice._$lastRolledBy.data("name") !== name) {
            Renderer.dice._$outRoll.prepend(`<div class="ve-muted out-roll-id">${name}</div>`);
            Renderer.dice._$lastRolledBy = $(`<div class="out-roll-wrp"></div>`).data("name", name);
            Renderer.dice._$outRoll.prepend(Renderer.dice._$lastRolledBy);
        }
    },
};

Renderer.dice.util = {
    getReducedMeta(meta) {
        return {
            pb: meta.pb
        };
    },
};

Renderer.dice.lang = {
    validate3(str) {
        str = str.trim();

        let lexed;
        try {
            lexed = Renderer.dice.lang._lex3(str).lexed;
        } catch (e) {
            return e.message;
        }

        try {
            Renderer.dice.lang._parse3(lexed);
        } catch (e) {
            return e.message;
        }

        return null;
    },

    getTree3(str, isSilent=true) {
        str = str.trim();
        if (isSilent) {
            try {
                const {lexed, lexedMeta} = Renderer.dice.lang._lex3(str);
                return {
                    tree: Renderer.dice.lang._parse3(lexed),
                    meta: lexedMeta
                };
            } catch (e) {
                return null;
            }
        } else {
            const {lexed, lexedMeta} = Renderer.dice.lang._lex3(str);
            return {
                tree: Renderer.dice.lang._parse3(lexed),
                meta: lexedMeta
            };
        }
    },

    _M_NUMBER_CHAR: /[0-9.]/,
    _M_SYMBOL_CHAR: /[-+/*^=><florceidhkxunavgsmpbtqw,]/,

    _M_NUMBER: /^[\d.,]+$/,
    _lex3(str) {
        const self = {
            tokenStack: [],
            parenCount: 0,
            braceCount: 0,
            mode: null,
            token: "",
            hasPb: false,
            hasSummonSpellLevel: false,
            hasSummonClassLevel: false,
        };

        str = str.trim().replace(/\bPBd(?=\d)/g, "(PB)d").toLowerCase().replace(/\s*?\bplus\b\s*?/g, " + ").replace(/\s*?\bminus\b\s*?/g, " - ").replace(/\s*?\btimes\b\s*?/g, " * ").replace(/\s*?\bover\b\s*?/g, " / ").replace(/\s*?\bdivided by\b\s*?/g, " / ").replace(/\s+/g, "").replace(/[\u2012\u2013\u2014]/g, "-").replace(/[×]/g, "*").replace(/\*\*/g, "^").replace(/÷/g, "/").replace(/--/g, "+").replace(/\+-|-\+/g, "-");

        if (!str)
            return {
                lexed: [],
                lexedMeta: {}
            };

        this._lex3_lex(self, str);

        return {
            lexed: self.tokenStack,
            lexedMeta: {
                hasPb: self.hasPb,
                hasSummonSpellLevel: self.hasSummonSpellLevel,
                hasSummonClassLevel: self.hasSummonClassLevel
            }
        };
    },

    _lex3_lex(self, l) {
        const len = l.length;

        for (let i = 0; i < len; ++i) {
            const c = l[i];

            switch (c) {
            case "(":
                self.parenCount++;
                this._lex3_outputToken(self);
                self.token = "(";
                this._lex3_outputToken(self);
                break;
            case ")":
                self.parenCount--;
                if (self.parenCount < 0)
                    throw new Error(`Syntax error: closing <code>)</code> without opening <code>(</code>`);
                this._lex3_outputToken(self);
                self.token = ")";
                this._lex3_outputToken(self);
                break;
            case "{":
                self.braceCount++;
                this._lex3_outputToken(self);
                self.token = "{";
                this._lex3_outputToken(self);
                break;
            case "}":
                self.braceCount--;
                if (self.parenCount < 0)
                    throw new Error(`Syntax error: closing <code>}</code> without opening <code>(</code>`);
                this._lex3_outputToken(self);
                self.token = "}";
                this._lex3_outputToken(self);
                break;
            case "+":
            case "-":
            case "*":
            case "/":
            case "^":
            case ",":
                this._lex3_outputToken(self);
                self.token += c;
                this._lex3_outputToken(self);
                break;
            default:
                {
                    if (Renderer.dice.lang._M_NUMBER_CHAR.test(c)) {
                        if (self.mode === "symbol")
                            this._lex3_outputToken(self);
                        self.token += c;
                        self.mode = "text";
                    } else if (Renderer.dice.lang._M_SYMBOL_CHAR.test(c)) {
                        if (self.mode === "text")
                            this._lex3_outputToken(self);
                        self.token += c;
                        self.mode = "symbol";
                    } else
                        throw new Error(`Syntax error: unexpected character <code>${c}</code>`);
                    break;
                }
            }
        }

        this._lex3_outputToken(self);
    },

    _lex3_outputToken(self) {
        if (!self.token)
            return;

        switch (self.token) {
        case "(":
            self.tokenStack.push(Renderer.dice.tk.PAREN_OPEN);
            break;
        case ")":
            self.tokenStack.push(Renderer.dice.tk.PAREN_CLOSE);
            break;
        case "{":
            self.tokenStack.push(Renderer.dice.tk.BRACE_OPEN);
            break;
        case "}":
            self.tokenStack.push(Renderer.dice.tk.BRACE_CLOSE);
            break;
        case ",":
            self.tokenStack.push(Renderer.dice.tk.COMMA);
            break;
        case "+":
            self.tokenStack.push(Renderer.dice.tk.ADD);
            break;
        case "-":
            self.tokenStack.push(Renderer.dice.tk.SUB);
            break;
        case "*":
            self.tokenStack.push(Renderer.dice.tk.MULT);
            break;
        case "/":
            self.tokenStack.push(Renderer.dice.tk.DIV);
            break;
        case "^":
            self.tokenStack.push(Renderer.dice.tk.POW);
            break;
        case "pb":
            self.tokenStack.push(Renderer.dice.tk.PB);
            self.hasPb = true;
            break;
        case "summonspelllevel":
            self.tokenStack.push(Renderer.dice.tk.SUMMON_SPELL_LEVEL);
            self.hasSummonSpellLevel = true;
            break;
        case "summonclasslevel":
            self.tokenStack.push(Renderer.dice.tk.SUMMON_CLASS_LEVEL);
            self.hasSummonClassLevel = true;
            break;
        case "floor":
            self.tokenStack.push(Renderer.dice.tk.FLOOR);
            break;
        case "ceil":
            self.tokenStack.push(Renderer.dice.tk.CEIL);
            break;
        case "round":
            self.tokenStack.push(Renderer.dice.tk.ROUND);
            break;
        case "avg":
            self.tokenStack.push(Renderer.dice.tk.AVERAGE);
            break;
        case "dmax":
            self.tokenStack.push(Renderer.dice.tk.DMAX);
            break;
        case "dmin":
            self.tokenStack.push(Renderer.dice.tk.DMIN);
            break;
        case "sign":
            self.tokenStack.push(Renderer.dice.tk.SIGN);
            break;
        case "abs":
            self.tokenStack.push(Renderer.dice.tk.ABS);
            break;
        case "cbrt":
            self.tokenStack.push(Renderer.dice.tk.CBRT);
            break;
        case "sqrt":
            self.tokenStack.push(Renderer.dice.tk.SQRT);
            break;
        case "exp":
            self.tokenStack.push(Renderer.dice.tk.EXP);
            break;
        case "log":
            self.tokenStack.push(Renderer.dice.tk.LOG);
            break;
        case "random":
            self.tokenStack.push(Renderer.dice.tk.RANDOM);
            break;
        case "trunc":
            self.tokenStack.push(Renderer.dice.tk.TRUNC);
            break;
        case "pow":
            self.tokenStack.push(Renderer.dice.tk.POW);
            break;
        case "max":
            self.tokenStack.push(Renderer.dice.tk.MAX);
            break;
        case "min":
            self.tokenStack.push(Renderer.dice.tk.MIN);
            break;
        case "d":
            self.tokenStack.push(Renderer.dice.tk.DICE);
            break;
        case "dh":
            self.tokenStack.push(Renderer.dice.tk.DROP_HIGHEST);
            break;
        case "kh":
            self.tokenStack.push(Renderer.dice.tk.KEEP_HIGHEST);
            break;
        case "dl":
            self.tokenStack.push(Renderer.dice.tk.DROP_LOWEST);
            break;
        case "kl":
            self.tokenStack.push(Renderer.dice.tk.KEEP_LOWEST);
            break;
        case "r":
            self.tokenStack.push(Renderer.dice.tk.REROLL_EXACT);
            break;
        case "r>":
            self.tokenStack.push(Renderer.dice.tk.REROLL_GT);
            break;
        case "r>=":
            self.tokenStack.push(Renderer.dice.tk.REROLL_GTEQ);
            break;
        case "r<":
            self.tokenStack.push(Renderer.dice.tk.REROLL_LT);
            break;
        case "r<=":
            self.tokenStack.push(Renderer.dice.tk.REROLL_LTEQ);
            break;
        case "x":
            self.tokenStack.push(Renderer.dice.tk.EXPLODE_EXACT);
            break;
        case "x>":
            self.tokenStack.push(Renderer.dice.tk.EXPLODE_GT);
            break;
        case "x>=":
            self.tokenStack.push(Renderer.dice.tk.EXPLODE_GTEQ);
            break;
        case "x<":
            self.tokenStack.push(Renderer.dice.tk.EXPLODE_LT);
            break;
        case "x<=":
            self.tokenStack.push(Renderer.dice.tk.EXPLODE_LTEQ);
            break;
        case "cs=":
            self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_EXACT);
            break;
        case "cs>":
            self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_GT);
            break;
        case "cs>=":
            self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_GTEQ);
            break;
        case "cs<":
            self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_LT);
            break;
        case "cs<=":
            self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_LTEQ);
            break;
        case "ms=":
            self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_EXACT);
            break;
        case "ms>":
            self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_GT);
            break;
        case "ms>=":
            self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_GTEQ);
            break;
        case "ms<":
            self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_LT);
            break;
        case "ms<=":
            self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_LTEQ);
            break;
        default:
            {
                if (Renderer.dice.lang._M_NUMBER.test(self.token)) {
                    if (self.token.split(Parser._decimalSeparator).length > 2)
                        throw new Error(`Syntax error: too many decimal separators <code>${self.token}</code>`);
                    self.tokenStack.push(Renderer.dice.tk.NUMBER(self.token));
                } else
                    throw new Error(`Syntax error: unexpected token <code>${self.token}</code>`);
            }
        }

        self.token = "";
    },

    _parse3(lexed) {
        const self = {
            ixSym: -1,
            syms: lexed,
            sym: null,
            lastAccepted: null,
            isIgnoreCommas: true,
        };

        this._parse3_nextSym(self);
        return this._parse3_expression(self);
    },

    _parse3_nextSym(self) {
        const cur = self.syms[self.ixSym];
        self.ixSym++;
        self.sym = self.syms[self.ixSym];
        return cur;
    },

    _parse3_match(self, symbol) {
        if (self.sym == null)
            return false;
        if (symbol.type)
            symbol = symbol.type;
        return self.sym.type === symbol;
    },

    _parse3_accept(self, symbol) {
        if (this._parse3_match(self, symbol)) {
            const out = self.sym;
            this._parse3_nextSym(self);
            self.lastAccepted = out;
            return out;
        }
        return false;
    },

    _parse3_expect(self, symbol) {
        const accepted = this._parse3_accept(self, symbol);
        if (accepted)
            return accepted;
        if (self.sym)
            throw new Error(`Unexpected input: Expected <code>${symbol}</code> but found <code>${self.sym}</code>`);
        else
            throw new Error(`Unexpected end of input: Expected <code>${symbol}</code>`);
    },

    _parse3_factor(self, {isSilent=false}={}) {
        if (this._parse3_accept(self, Renderer.dice.tk.TYP_NUMBER)) {
            if (self.isIgnoreCommas) {
                const syms = [self.lastAccepted];
                while (this._parse3_accept(self, Renderer.dice.tk.COMMA)) {
                    const sym = this._parse3_expect(self, Renderer.dice.tk.TYP_NUMBER);
                    syms.push(sym);
                }
                const sym = Renderer.dice.tk.NUMBER(syms.map(it=>it.value).join(""));
                return new Renderer.dice.parsed.Factor(sym);
            }

            return new Renderer.dice.parsed.Factor(self.lastAccepted);
        } else if (this._parse3_accept(self, Renderer.dice.tk.PB)) {
            return new Renderer.dice.parsed.Factor(Renderer.dice.tk.PB);
        } else if (this._parse3_accept(self, Renderer.dice.tk.SUMMON_SPELL_LEVEL)) {
            return new Renderer.dice.parsed.Factor(Renderer.dice.tk.SUMMON_SPELL_LEVEL);
        } else if (this._parse3_accept(self, Renderer.dice.tk.SUMMON_CLASS_LEVEL)) {
            return new Renderer.dice.parsed.Factor(Renderer.dice.tk.SUMMON_CLASS_LEVEL);
        } else if (this._parse3_match(self, Renderer.dice.tk.FLOOR) || this._parse3_match(self, Renderer.dice.tk.CEIL) || this._parse3_match(self, Renderer.dice.tk.ROUND) || this._parse3_match(self, Renderer.dice.tk.AVERAGE) || this._parse3_match(self, Renderer.dice.tk.DMAX) || this._parse3_match(self, Renderer.dice.tk.DMIN) || this._parse3_match(self, Renderer.dice.tk.SIGN) || this._parse3_match(self, Renderer.dice.tk.ABS) || this._parse3_match(self, Renderer.dice.tk.CBRT) || this._parse3_match(self, Renderer.dice.tk.SQRT) || this._parse3_match(self, Renderer.dice.tk.EXP) || this._parse3_match(self, Renderer.dice.tk.LOG) || this._parse3_match(self, Renderer.dice.tk.RANDOM) || this._parse3_match(self, Renderer.dice.tk.TRUNC)) {
            const children = [];

            children.push(this._parse3_nextSym(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_OPEN);
            children.push(this._parse3_expression(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);

            return new Renderer.dice.parsed.Function(children);
        } else if (this._parse3_match(self, Renderer.dice.tk.POW)) {
            self.isIgnoreCommas = false;

            const children = [];

            children.push(this._parse3_nextSym(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_OPEN);
            children.push(this._parse3_expression(self));
            this._parse3_expect(self, Renderer.dice.tk.COMMA);
            children.push(this._parse3_expression(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);

            self.isIgnoreCommas = true;

            return new Renderer.dice.parsed.Function(children);
        } else if (this._parse3_match(self, Renderer.dice.tk.MAX) || this._parse3_match(self, Renderer.dice.tk.MIN)) {
            self.isIgnoreCommas = false;

            const children = [];

            children.push(this._parse3_nextSym(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_OPEN);
            children.push(this._parse3_expression(self));
            while (this._parse3_accept(self, Renderer.dice.tk.COMMA))
                children.push(this._parse3_expression(self));
            this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);

            self.isIgnoreCommas = true;

            return new Renderer.dice.parsed.Function(children);
        } else if (this._parse3_accept(self, Renderer.dice.tk.PAREN_OPEN)) {
            const exp = this._parse3_expression(self);
            this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);
            return new Renderer.dice.parsed.Factor(exp,{
                hasParens: true
            });
        } else if (this._parse3_accept(self, Renderer.dice.tk.BRACE_OPEN)) {
            self.isIgnoreCommas = false;

            const children = [];

            children.push(this._parse3_expression(self));
            while (this._parse3_accept(self, Renderer.dice.tk.COMMA))
                children.push(this._parse3_expression(self));

            this._parse3_expect(self, Renderer.dice.tk.BRACE_CLOSE);

            self.isIgnoreCommas = true;

            const modPart = [];
            this._parse3__dice_modifiers(self, modPart);

            return new Renderer.dice.parsed.Pool(children,modPart[0]);
        } else {
            if (isSilent)
                return null;

            if (self.sym)
                throw new Error(`Unexpected input: <code>${self.sym}</code>`);
            else
                throw new Error(`Unexpected end of input`);
        }
    },

    _parse3_dice(self) {
        const children = [];

        if (this._parse3_match(self, Renderer.dice.tk.DICE))
            children.push(new Renderer.dice.parsed.Factor(Renderer.dice.tk.NUMBER(1)));
        else
            children.push(this._parse3_factor(self));

        while (this._parse3_match(self, Renderer.dice.tk.DICE)) {
            this._parse3_nextSym(self);
            children.push(this._parse3_factor(self));
            this._parse3__dice_modifiers(self, children);
        }
        return new Renderer.dice.parsed.Dice(children);
    },

    _parse3__dice_modifiers(self, children) {
        const modsMeta = new Renderer.dice.lang.DiceModMeta();

        while (this._parse3_match(self, Renderer.dice.tk.DROP_HIGHEST) || this._parse3_match(self, Renderer.dice.tk.KEEP_HIGHEST) || this._parse3_match(self, Renderer.dice.tk.DROP_LOWEST) || this._parse3_match(self, Renderer.dice.tk.KEEP_LOWEST) || this._parse3_match(self, Renderer.dice.tk.REROLL_EXACT) || this._parse3_match(self, Renderer.dice.tk.REROLL_GT) || this._parse3_match(self, Renderer.dice.tk.REROLL_GTEQ) || this._parse3_match(self, Renderer.dice.tk.REROLL_LT) || this._parse3_match(self, Renderer.dice.tk.REROLL_LTEQ) || this._parse3_match(self, Renderer.dice.tk.EXPLODE_EXACT) || this._parse3_match(self, Renderer.dice.tk.EXPLODE_GT) || this._parse3_match(self, Renderer.dice.tk.EXPLODE_GTEQ) || this._parse3_match(self, Renderer.dice.tk.EXPLODE_LT) || this._parse3_match(self, Renderer.dice.tk.EXPLODE_LTEQ) || this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_EXACT) || this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_GT) || this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_GTEQ) || this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_LT) || this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_LTEQ) || this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_EXACT) || this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_GT) || this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_GTEQ) || this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_LT) || this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_LTEQ)) {
            const nxtSym = this._parse3_nextSym(self);
            const nxtFactor = this._parse3__dice_modifiers_nxtFactor(self, nxtSym);

            if (nxtSym.isSuccessMode)
                modsMeta.isSuccessMode = true;
            modsMeta.mods.push({
                modSym: nxtSym,
                numSym: nxtFactor
            });
        }

        if (modsMeta.mods.length)
            children.push(modsMeta);
    },

    _parse3__dice_modifiers_nxtFactor(self, nxtSym) {
        if (nxtSym.diceModifierImplicit == null)
            return this._parse3_factor(self, {
                isSilent: true
            });

        const fallback = new Renderer.dice.parsed.Factor(Renderer.dice.tk.NUMBER(nxtSym.diceModifierImplicit));
        if (self.sym == null)
            return fallback;

        const out = this._parse3_factor(self, {
            isSilent: true
        });
        if (out)
            return out;

        return fallback;
    },

    _parse3_exponent(self) {
        const children = [];
        children.push(this._parse3_dice(self));
        while (this._parse3_match(self, Renderer.dice.tk.POW)) {
            this._parse3_nextSym(self);
            children.push(this._parse3_dice(self));
        }
        return new Renderer.dice.parsed.Exponent(children);
    },

    _parse3_term(self) {
        const children = [];
        children.push(this._parse3_exponent(self));
        while (this._parse3_match(self, Renderer.dice.tk.MULT) || this._parse3_match(self, Renderer.dice.tk.DIV)) {
            children.push(this._parse3_nextSym(self));
            children.push(this._parse3_exponent(self));
        }
        return new Renderer.dice.parsed.Term(children);
    },

    _parse3_expression(self) {
        const children = [];
        if (this._parse3_match(self, Renderer.dice.tk.ADD) || this._parse3_match(self, Renderer.dice.tk.SUB))
            children.push(this._parse3_nextSym(self));
        children.push(this._parse3_term(self));
        while (this._parse3_match(self, Renderer.dice.tk.ADD) || this._parse3_match(self, Renderer.dice.tk.SUB)) {
            children.push(this._parse3_nextSym(self));
            children.push(this._parse3_term(self));
        }
        return new Renderer.dice.parsed.Expression(children);
    },

    DiceModMeta: class {
        constructor() {
            this.isDiceModifierGroup = true;
            this.isSuccessMode = false;
            this.mods = [];
        }
    }
    ,
};

Renderer.dice.tk = {
    Token: class {
        constructor(type, value, asString, opts) {
            opts = opts || {};
            this.type = type;
            this.value = value;
            this._asString = asString;
            if (opts.isDiceModifier)
                this.isDiceModifier = true;
            if (opts.diceModifierImplicit)
                this.diceModifierImplicit = true;
            if (opts.isSuccessMode)
                this.isSuccessMode = true;
        }

        eq(other) {
            return other && other.type === this.type;
        }

        toString() {
            if (this._asString)
                return this._asString;
            return this.toDebugString();
        }

        toDebugString() {
            return `${this.type}${this.value ? ` :: ${this.value}` : ""}`;
        }
    }
    ,

    _new(type, asString, opts) {
        return new Renderer.dice.tk.Token(type,null,asString,opts);
    },

    TYP_NUMBER: "NUMBER",
    TYP_DICE: "DICE",
    TYP_SYMBOL: "SYMBOL",
    NUMBER(val) {
        return new Renderer.dice.tk.Token(Renderer.dice.tk.TYP_NUMBER,val);
    },
};
Renderer.dice.tk.PAREN_OPEN = Renderer.dice.tk._new("PAREN_OPEN", "(");
Renderer.dice.tk.PAREN_CLOSE = Renderer.dice.tk._new("PAREN_CLOSE", ")");
Renderer.dice.tk.BRACE_OPEN = Renderer.dice.tk._new("BRACE_OPEN", "{");
Renderer.dice.tk.BRACE_CLOSE = Renderer.dice.tk._new("BRACE_CLOSE", "}");
Renderer.dice.tk.COMMA = Renderer.dice.tk._new("COMMA", ",");
Renderer.dice.tk.ADD = Renderer.dice.tk._new("ADD", "+");
Renderer.dice.tk.SUB = Renderer.dice.tk._new("SUB", "-");
Renderer.dice.tk.MULT = Renderer.dice.tk._new("MULT", "*");
Renderer.dice.tk.DIV = Renderer.dice.tk._new("DIV", "/");
Renderer.dice.tk.POW = Renderer.dice.tk._new("POW", "^");
Renderer.dice.tk.PB = Renderer.dice.tk._new("PB", "pb");
Renderer.dice.tk.SUMMON_SPELL_LEVEL = Renderer.dice.tk._new("SUMMON_SPELL_LEVEL", "summonspelllevel");
Renderer.dice.tk.SUMMON_CLASS_LEVEL = Renderer.dice.tk._new("SUMMON_CLASS_LEVEL", "summonclasslevel");
Renderer.dice.tk.FLOOR = Renderer.dice.tk._new("FLOOR", "floor");
Renderer.dice.tk.CEIL = Renderer.dice.tk._new("CEIL", "ceil");
Renderer.dice.tk.ROUND = Renderer.dice.tk._new("ROUND", "round");
Renderer.dice.tk.AVERAGE = Renderer.dice.tk._new("AVERAGE", "avg");
Renderer.dice.tk.DMAX = Renderer.dice.tk._new("DMAX", "avg");
Renderer.dice.tk.DMIN = Renderer.dice.tk._new("DMIN", "avg");
Renderer.dice.tk.SIGN = Renderer.dice.tk._new("SIGN", "sign");
Renderer.dice.tk.ABS = Renderer.dice.tk._new("ABS", "abs");
Renderer.dice.tk.CBRT = Renderer.dice.tk._new("CBRT", "cbrt");
Renderer.dice.tk.SQRT = Renderer.dice.tk._new("SQRT", "sqrt");
Renderer.dice.tk.EXP = Renderer.dice.tk._new("EXP", "exp");
Renderer.dice.tk.LOG = Renderer.dice.tk._new("LOG", "log");
Renderer.dice.tk.RANDOM = Renderer.dice.tk._new("RANDOM", "random");
Renderer.dice.tk.TRUNC = Renderer.dice.tk._new("TRUNC", "trunc");
Renderer.dice.tk.POW = Renderer.dice.tk._new("POW", "pow");
Renderer.dice.tk.MAX = Renderer.dice.tk._new("MAX", "max");
Renderer.dice.tk.MIN = Renderer.dice.tk._new("MIN", "min");
Renderer.dice.tk.DICE = Renderer.dice.tk._new("DICE", "d");
Renderer.dice.tk.DROP_HIGHEST = Renderer.dice.tk._new("DH", "dh", {
    isDiceModifier: true,
    diceModifierImplicit: 1
});
Renderer.dice.tk.KEEP_HIGHEST = Renderer.dice.tk._new("KH", "kh", {
    isDiceModifier: true,
    diceModifierImplicit: 1
});
Renderer.dice.tk.DROP_LOWEST = Renderer.dice.tk._new("DL", "dl", {
    isDiceModifier: true,
    diceModifierImplicit: 1
});
Renderer.dice.tk.KEEP_LOWEST = Renderer.dice.tk._new("KL", "kl", {
    isDiceModifier: true,
    diceModifierImplicit: 1
});
Renderer.dice.tk.REROLL_EXACT = Renderer.dice.tk._new("REROLL", "r", {
    isDiceModifier: true
});
Renderer.dice.tk.REROLL_GT = Renderer.dice.tk._new("REROLL_GT", "r>", {
    isDiceModifier: true
});
Renderer.dice.tk.REROLL_GTEQ = Renderer.dice.tk._new("REROLL_GTEQ", "r>=", {
    isDiceModifier: true
});
Renderer.dice.tk.REROLL_LT = Renderer.dice.tk._new("REROLL_LT", "r<", {
    isDiceModifier: true
});
Renderer.dice.tk.REROLL_LTEQ = Renderer.dice.tk._new("REROLL_LTEQ", "r<=", {
    isDiceModifier: true
});
Renderer.dice.tk.EXPLODE_EXACT = Renderer.dice.tk._new("EXPLODE", "x", {
    isDiceModifier: true
});
Renderer.dice.tk.EXPLODE_GT = Renderer.dice.tk._new("EXPLODE_GT", "x>", {
    isDiceModifier: true
});
Renderer.dice.tk.EXPLODE_GTEQ = Renderer.dice.tk._new("EXPLODE_GTEQ", "x>=", {
    isDiceModifier: true
});
Renderer.dice.tk.EXPLODE_LT = Renderer.dice.tk._new("EXPLODE_LT", "x<", {
    isDiceModifier: true
});
Renderer.dice.tk.EXPLODE_LTEQ = Renderer.dice.tk._new("EXPLODE_LTEQ", "x<=", {
    isDiceModifier: true
});
Renderer.dice.tk.COUNT_SUCCESS_EXACT = Renderer.dice.tk._new("COUNT_SUCCESS_EXACT", "cs=", {
    isDiceModifier: true,
    isSuccessMode: true
});
Renderer.dice.tk.COUNT_SUCCESS_GT = Renderer.dice.tk._new("COUNT_SUCCESS_GT", "cs>", {
    isDiceModifier: true,
    isSuccessMode: true
});
Renderer.dice.tk.COUNT_SUCCESS_GTEQ = Renderer.dice.tk._new("COUNT_SUCCESS_GTEQ", "cs>=", {
    isDiceModifier: true,
    isSuccessMode: true
});
Renderer.dice.tk.COUNT_SUCCESS_LT = Renderer.dice.tk._new("COUNT_SUCCESS_LT", "cs<", {
    isDiceModifier: true,
    isSuccessMode: true
});
Renderer.dice.tk.COUNT_SUCCESS_LTEQ = Renderer.dice.tk._new("COUNT_SUCCESS_LTEQ", "cs<=", {
    isDiceModifier: true,
    isSuccessMode: true
});
Renderer.dice.tk.MARGIN_SUCCESS_EXACT = Renderer.dice.tk._new("MARGIN_SUCCESS_EXACT", "ms=", {
    isDiceModifier: true
});
Renderer.dice.tk.MARGIN_SUCCESS_GT = Renderer.dice.tk._new("MARGIN_SUCCESS_GT", "ms>", {
    isDiceModifier: true
});
Renderer.dice.tk.MARGIN_SUCCESS_GTEQ = Renderer.dice.tk._new("MARGIN_SUCCESS_GTEQ", "ms>=", {
    isDiceModifier: true
});
Renderer.dice.tk.MARGIN_SUCCESS_LT = Renderer.dice.tk._new("MARGIN_SUCCESS_LT", "ms<", {
    isDiceModifier: true
});
Renderer.dice.tk.MARGIN_SUCCESS_LTEQ = Renderer.dice.tk._new("MARGIN_SUCCESS_LTEQ", "ms<=", {
    isDiceModifier: true
});

Renderer.dice.AbstractSymbol = class {
    constructor() {
        this.type = Renderer.dice.tk.TYP_SYMBOL;
    }
    eq(symbol) {
        return symbol && this.type === symbol.type;
    }
    evl(meta) {
        this.meta = meta;
        return this._evl(meta);
    }
    avg(meta) {
        this.meta = meta;
        return this._avg(meta);
    }
    min(meta) {
        this.meta = meta;
        return this._min(meta);
    }
    max(meta) {
        this.meta = meta;
        return this._max(meta);
    }
    _evl() {
        throw new Error("Unimplemented!");
    }
    _avg() {
        throw new Error("Unimplemented!");
    }
    _min() {
        throw new Error("Unimplemented!");
    }
    _max() {
        throw new Error("Unimplemented!");
    }
    toString() {
        throw new Error("Unimplemented!");
    }
    addToMeta(meta, {text, html=null, md=null}={}) {
        if (!meta)
            return;
        html = html || text;
        md = md || text;
        (meta.html = meta.html || []).push(html);
        (meta.text = meta.text || []).push(text);
        (meta.md = meta.md || []).push(md);
    }
}
;

Renderer.dice.parsed = {
    _PARTITION_EQ: (r,compareTo)=>r === compareTo,
    _PARTITION_GT: (r,compareTo)=>r > compareTo,
    _PARTITION_GTEQ: (r,compareTo)=>r >= compareTo,
    _PARTITION_LT: (r,compareTo)=>r < compareTo,
    _PARTITION_LTEQ: (r,compareTo)=>r <= compareTo,

    _handleModifiers(fnName, meta, vals, nodeMod, opts) {
        opts = opts || {};

        const displayVals = vals.slice();
        const {mods} = nodeMod;

        for (const mod of mods) {
            vals.sort(SortUtil.ascSortProp.bind(null, "val")).reverse();
            const valsAlive = vals.filter(it=>!it.isDropped);

            const modNum = mod.numSym[fnName]();

            switch (mod.modSym.type) {
            case Renderer.dice.tk.DROP_HIGHEST.type:
            case Renderer.dice.tk.KEEP_HIGHEST.type:
            case Renderer.dice.tk.DROP_LOWEST.type:
            case Renderer.dice.tk.KEEP_LOWEST.type:
                {
                    const isHighest = mod.modSym.type.endsWith("H");

                    const splitPoint = isHighest ? modNum : valsAlive.length - modNum;

                    const highSlice = valsAlive.slice(0, splitPoint);
                    const lowSlice = valsAlive.slice(splitPoint, valsAlive.length);

                    switch (mod.modSym.type) {
                    case Renderer.dice.tk.DROP_HIGHEST.type:
                    case Renderer.dice.tk.KEEP_LOWEST.type:
                        highSlice.forEach(val=>val.isDropped = true);
                        break;
                    case Renderer.dice.tk.KEEP_HIGHEST.type:
                    case Renderer.dice.tk.DROP_LOWEST.type:
                        lowSlice.forEach(val=>val.isDropped = true);
                        break;
                    default:
                        throw new Error(`Unimplemented!`);
                    }
                    break;
                }

            case Renderer.dice.tk.REROLL_EXACT.type:
            case Renderer.dice.tk.REROLL_GT.type:
            case Renderer.dice.tk.REROLL_GTEQ.type:
            case Renderer.dice.tk.REROLL_LT.type:
            case Renderer.dice.tk.REROLL_LTEQ.type:
                {
                    let fnPartition;
                    switch (mod.modSym.type) {
                    case Renderer.dice.tk.REROLL_EXACT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_EQ;
                        break;
                    case Renderer.dice.tk.REROLL_GT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GT;
                        break;
                    case Renderer.dice.tk.REROLL_GTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GTEQ;
                        break;
                    case Renderer.dice.tk.REROLL_LT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LT;
                        break;
                    case Renderer.dice.tk.REROLL_LTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LTEQ;
                        break;
                    default:
                        throw new Error(`Unimplemented!`);
                    }

                    const toReroll = valsAlive.filter(val=>fnPartition(val.val, modNum));
                    toReroll.forEach(val=>val.isDropped = true);

                    const nuVals = opts.fnGetRerolls(toReroll);

                    vals.push(...nuVals);
                    displayVals.push(...nuVals);
                    break;
                }

            case Renderer.dice.tk.EXPLODE_EXACT.type:
            case Renderer.dice.tk.EXPLODE_GT.type:
            case Renderer.dice.tk.EXPLODE_GTEQ.type:
            case Renderer.dice.tk.EXPLODE_LT.type:
            case Renderer.dice.tk.EXPLODE_LTEQ.type:
                {
                    let fnPartition;
                    switch (mod.modSym.type) {
                    case Renderer.dice.tk.EXPLODE_EXACT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_EQ;
                        break;
                    case Renderer.dice.tk.EXPLODE_GT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GT;
                        break;
                    case Renderer.dice.tk.EXPLODE_GTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GTEQ;
                        break;
                    case Renderer.dice.tk.EXPLODE_LT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LT;
                        break;
                    case Renderer.dice.tk.EXPLODE_LTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LTEQ;
                        break;
                    default:
                        throw new Error(`Unimplemented!`);
                    }

                    let tries = 999;
                    let lastLen;
                    let toExplodeNext = valsAlive;
                    do {
                        lastLen = vals.length;

                        const [toExplode] = toExplodeNext.partition(roll=>!roll.isExploded && fnPartition(roll.val, modNum));
                        toExplode.forEach(roll=>roll.isExploded = true);

                        const nuVals = opts.fnGetExplosions(toExplode);

                        toExplodeNext = nuVals;

                        vals.push(...nuVals);
                        displayVals.push(...nuVals);
                    } while (tries-- > 0 && vals.length !== lastLen);

                    if (!~tries)
                        JqueryUtil.doToast({
                            type: "warning",
                            content: `Stopped exploding after 999 additional rolls.`
                        });

                    break;
                }

            case Renderer.dice.tk.COUNT_SUCCESS_EXACT.type:
            case Renderer.dice.tk.COUNT_SUCCESS_GT.type:
            case Renderer.dice.tk.COUNT_SUCCESS_GTEQ.type:
            case Renderer.dice.tk.COUNT_SUCCESS_LT.type:
            case Renderer.dice.tk.COUNT_SUCCESS_LTEQ.type:
                {
                    let fnPartition;
                    switch (mod.modSym.type) {
                    case Renderer.dice.tk.COUNT_SUCCESS_EXACT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_EQ;
                        break;
                    case Renderer.dice.tk.COUNT_SUCCESS_GT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GT;
                        break;
                    case Renderer.dice.tk.COUNT_SUCCESS_GTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_GTEQ;
                        break;
                    case Renderer.dice.tk.COUNT_SUCCESS_LT.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LT;
                        break;
                    case Renderer.dice.tk.COUNT_SUCCESS_LTEQ.type:
                        fnPartition = Renderer.dice.parsed._PARTITION_LTEQ;
                        break;
                    default:
                        throw new Error(`Unimplemented!`);
                    }

                    const successes = valsAlive.filter(val=>fnPartition(val.val, modNum));
                    successes.forEach(val=>val.isSuccess = true);

                    break;
                }

            case Renderer.dice.tk.MARGIN_SUCCESS_EXACT.type:
            case Renderer.dice.tk.MARGIN_SUCCESS_GT.type:
            case Renderer.dice.tk.MARGIN_SUCCESS_GTEQ.type:
            case Renderer.dice.tk.MARGIN_SUCCESS_LT.type:
            case Renderer.dice.tk.MARGIN_SUCCESS_LTEQ.type:
                {
                    const total = valsAlive.map(it=>it.val).reduce((valA,valB)=>valA + valB, 0);

                    const subDisplayDice = displayVals.map(r=>`[${Renderer.dice.parsed._rollToNumPart_html(r, opts.faces)}]`).join("+");

                    let delta;
                    let subDisplay;
                    switch (mod.modSym.type) {
                    case Renderer.dice.tk.MARGIN_SUCCESS_EXACT.type:
                    case Renderer.dice.tk.MARGIN_SUCCESS_GT.type:
                    case Renderer.dice.tk.MARGIN_SUCCESS_GTEQ.type:
                        {
                            delta = total - modNum;

                            subDisplay = `(${subDisplayDice})-${modNum}`;

                            break;
                        }
                    case Renderer.dice.tk.MARGIN_SUCCESS_LT.type:
                    case Renderer.dice.tk.MARGIN_SUCCESS_LTEQ.type:
                        {
                            delta = modNum - total;

                            subDisplay = `${modNum}-(${subDisplayDice})`;

                            break;
                        }
                    default:
                        throw new Error(`Unimplemented!`);
                    }

                    while (vals.length) {
                        vals.pop();
                        displayVals.pop();
                    }

                    vals.push({
                        val: delta
                    });
                    displayVals.push({
                        val: delta,
                        htmlDisplay: subDisplay
                    });

                    break;
                }

            default:
                throw new Error(`Unimplemented!`);
            }
        }

        return displayVals;
    },

    _rollToNumPart_html(r, faces) {
        if (faces == null)
            return r.val;
        return r.val === faces ? `<span class="rll__max--muted">${r.val}</span>` : r.val === 1 ? `<span class="rll__min--muted">${r.val}</span>` : r.val;
    },

    Function: class extends Renderer.dice.AbstractSymbol {
        constructor(nodes) {
            super();
            this._nodes = nodes;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            const [symFunc] = this._nodes;
            switch (symFunc.type) {
            case Renderer.dice.tk.FLOOR.type:
            case Renderer.dice.tk.CEIL.type:
            case Renderer.dice.tk.ROUND.type:
            case Renderer.dice.tk.SIGN.type:
            case Renderer.dice.tk.CBRT.type:
            case Renderer.dice.tk.SQRT.type:
            case Renderer.dice.tk.EXP.type:
            case Renderer.dice.tk.LOG.type:
            case Renderer.dice.tk.RANDOM.type:
            case Renderer.dice.tk.TRUNC.type:
            case Renderer.dice.tk.POW.type:
            case Renderer.dice.tk.MAX.type:
            case Renderer.dice.tk.MIN.type:
                {
                    const [,...symExps] = this._nodes;
                    this.addToMeta(meta, {
                        text: `${symFunc.toString()}(`
                    });
                    const args = [];
                    symExps.forEach((symExp,i)=>{
                        if (i !== 0)
                            this.addToMeta(meta, {
                                text: `, `
                            });
                        args.push(symExp[fnName](meta));
                    }
                    );
                    const out = Math[symFunc.toString()](...args);
                    this.addToMeta(meta, {
                        text: ")"
                    });
                    return out;
                }
            case Renderer.dice.tk.AVERAGE.type:
                {
                    const [,symExp] = this._nodes;
                    return symExp.avg(meta);
                }
            case Renderer.dice.tk.DMAX.type:
                {
                    const [,symExp] = this._nodes;
                    return symExp.max(meta);
                }
            case Renderer.dice.tk.DMIN.type:
                {
                    const [,symExp] = this._nodes;
                    return symExp.min(meta);
                }
            default:
                throw new Error(`Unimplemented!`);
            }
        }

        toString() {
            let out;
            const [symFunc,symExp] = this._nodes;
            switch (symFunc.type) {
            case Renderer.dice.tk.FLOOR.type:
            case Renderer.dice.tk.CEIL.type:
            case Renderer.dice.tk.ROUND.type:
            case Renderer.dice.tk.AVERAGE.type:
            case Renderer.dice.tk.DMAX.type:
            case Renderer.dice.tk.DMIN.type:
            case Renderer.dice.tk.SIGN.type:
            case Renderer.dice.tk.ABS.type:
            case Renderer.dice.tk.CBRT.type:
            case Renderer.dice.tk.SQRT.type:
            case Renderer.dice.tk.EXP.type:
            case Renderer.dice.tk.LOG.type:
            case Renderer.dice.tk.RANDOM.type:
            case Renderer.dice.tk.TRUNC.type:
            case Renderer.dice.tk.POW.type:
            case Renderer.dice.tk.MAX.type:
            case Renderer.dice.tk.MIN.type:
                out = symFunc.toString();
                break;
            default:
                throw new Error(`Unimplemented!`);
            }
            out += `(${symExp.toString()})`;
            return out;
        }
    }
    ,

    Pool: class extends Renderer.dice.AbstractSymbol {
        constructor(nodesPool, nodeMod) {
            super();
            this._nodesPool = nodesPool;
            this._nodeMod = nodeMod;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            const vals = this._nodesPool.map(it=>{
                const subMeta = {};
                return {
                    node: it,
                    val: it[fnName](subMeta),
                    meta: subMeta
                };
            }
            );

            if (this._nodeMod && vals.length) {
                const isSuccessMode = this._nodeMod.isSuccessMode;

                const modOpts = {
                    fnGetRerolls: toReroll=>toReroll.map(val=>{
                        const subMeta = {};
                        return {
                            node: val.node,
                            val: val.node[fnName](subMeta),
                            meta: subMeta
                        };
                    }
                    ),
                    fnGetExplosions: toExplode=>toExplode.map(val=>{
                        const subMeta = {};
                        return {
                            node: val.node,
                            val: val.node[fnName](subMeta),
                            meta: subMeta
                        };
                    }
                    ),
                };

                const displayVals = Renderer.dice.parsed._handleModifiers(fnName, meta, vals, this._nodeMod, modOpts);

                const asHtml = displayVals.map(v=>{
                    const html = v.meta.html.join("");
                    if (v.isDropped)
                        return `<span class="rll__dropped">(${html})</span>`;
                    else if (v.isExploded)
                        return `<span class="rll__exploded">(</span>${html}<span class="rll__exploded">)</span>`;
                    else if (v.isSuccess)
                        return `<span class="rll__success">(${html})</span>`;
                    else
                        return `(${html})`;
                }
                ).join("+");

                const asText = displayVals.map(v=>`(${v.meta.text.join("")})`).join("+");
                const asMd = displayVals.map(v=>`(${v.meta.md.join("")})`).join("+");

                this.addToMeta(meta, {
                    html: asHtml,
                    text: asText,
                    md: asMd
                });

                if (isSuccessMode) {
                    return vals.filter(it=>!it.isDropped && it.isSuccess).length;
                } else {
                    return vals.filter(it=>!it.isDropped).map(it=>it.val).sum();
                }
            } else {
                this.addToMeta(meta, ["html", "text", "md"].mergeMap(prop=>({
                    [prop]: `${vals.map(it=>`(${it.meta[prop].join("")})`).join("+")}`,
                })), );
                return vals.map(it=>it.val).sum();
            }
        }

        toString() {
            return `{${this._nodesPool.map(it=>it.toString()).join(", ")}}${this._nodeMod ? this._nodeMod.toString() : ""}`;
        }
    }
    ,

    Factor: class extends Renderer.dice.AbstractSymbol {
        constructor(node, opts) {
            super();
            opts = opts || {};
            this._node = node;
            this._hasParens = !!opts.hasParens;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            switch (this._node.type) {
            case Renderer.dice.tk.TYP_NUMBER:
                {
                    this.addToMeta(meta, {
                        text: this.toString()
                    });
                    return Number(this._node.value);
                }
            case Renderer.dice.tk.TYP_SYMBOL:
                {
                    if (this._hasParens)
                        this.addToMeta(meta, {
                            text: "("
                        });
                    const out = this._node[fnName](meta);
                    if (this._hasParens)
                        this.addToMeta(meta, {
                            text: ")"
                        });
                    return out;
                }
            case Renderer.dice.tk.PB.type:
                {
                    this.addToMeta(meta, {
                        text: this.toString(meta)
                    });
                    return meta.pb == null ? 0 : meta.pb;
                }
            case Renderer.dice.tk.SUMMON_SPELL_LEVEL.type:
                {
                    this.addToMeta(meta, {
                        text: this.toString(meta)
                    });
                    return meta.summonSpellLevel == null ? 0 : meta.summonSpellLevel;
                }
            case Renderer.dice.tk.SUMMON_CLASS_LEVEL.type:
                {
                    this.addToMeta(meta, {
                        text: this.toString(meta)
                    });
                    return meta.summonClassLevel == null ? 0 : meta.summonClassLevel;
                }
            default:
                throw new Error(`Unimplemented!`);
            }
        }

        toString(indent) {
            let out;
            switch (this._node.type) {
            case Renderer.dice.tk.TYP_NUMBER:
                out = this._node.value;
                break;
            case Renderer.dice.tk.TYP_SYMBOL:
                out = this._node.toString();
                break;
            case Renderer.dice.tk.PB.type:
                out = this.meta ? (this.meta.pb || 0) : "PB";
                break;
            case Renderer.dice.tk.SUMMON_SPELL_LEVEL.type:
                out = this.meta ? (this.meta.summonSpellLevel || 0) : "the spell's level";
                break;
            case Renderer.dice.tk.SUMMON_CLASS_LEVEL.type:
                out = this.meta ? (this.meta.summonClassLevel || 0) : "your class level";
                break;
            default:
                throw new Error(`Unimplemented!`);
            }
            return this._hasParens ? `(${out})` : out;
        }
    }
    ,

    Dice: class extends Renderer.dice.AbstractSymbol {
        static _facesToValue(faces, fnName) {
            switch (fnName) {
            case "evl":
                return RollerUtil.randomise(faces);
            case "avg":
                return (faces + 1) / 2;
            case "min":
                return 1;
            case "max":
                return faces;
            }
        }

        constructor(nodes) {
            super();
            this._nodes = nodes;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            if (this._nodes.length === 1)
                return this._nodes[0][fnName](meta);

            const view = this._nodes.slice();
            const numSym = view.shift();
            let tmp = numSym[fnName](Renderer.dice.util.getReducedMeta(meta));

            while (view.length) {
                if (Math.round(tmp) !== tmp)
                    throw new Error(`Number of dice to roll (${tmp}) was not an integer!`);

                const facesSym = view.shift();
                const faces = facesSym[fnName]();
                if (Math.round(faces) !== faces)
                    throw new Error(`Dice face count (${faces}) was not an integer!`);

                const isLast = view.length === 0 || (view.length === 1 && view.last().isDiceModifierGroup);
                tmp = this._invoke_handlePart(fnName, meta, view, tmp, faces, isLast);
            }

            return tmp;
        }

        _invoke_handlePart(fnName, meta, view, num, faces, isLast) {
            const rolls = [...new Array(num)].map(()=>({
                val: Renderer.dice.parsed.Dice._facesToValue(faces, fnName)
            }));
            let displayRolls;
            let isSuccessMode = false;

            if (view.length && view[0].isDiceModifierGroup) {
                const nodeMod = view[0];

                if (fnName === "evl" || fnName === "min" || fnName === "max") {
                    isSuccessMode = nodeMod.isSuccessMode;

                    const modOpts = {
                        faces,
                        fnGetRerolls: toReroll=>[...new Array(toReroll.length)].map(()=>({
                            val: Renderer.dice.parsed.Dice._facesToValue(faces, fnName)
                        })),
                        fnGetExplosions: toExplode=>[...new Array(toExplode.length)].map(()=>({
                            val: Renderer.dice.parsed.Dice._facesToValue(faces, fnName)
                        })),
                    };

                    displayRolls = Renderer.dice.parsed._handleModifiers(fnName, meta, rolls, nodeMod, modOpts);
                }

                view.shift();
            } else
                displayRolls = rolls;

            if (isLast) {
                const asHtml = displayRolls.map(r=>{
                    if (r.htmlDisplay)
                        return r.htmlDisplay;

                    const numPart = Renderer.dice.parsed._rollToNumPart_html(r, faces);

                    if (r.isDropped)
                        return `<span class="rll__dropped">[${numPart}]</span>`;
                    else if (r.isExploded)
                        return `<span class="rll__exploded">[</span>${numPart}<span class="rll__exploded">]</span>`;
                    else if (r.isSuccess)
                        return `<span class="rll__success">[${numPart}]</span>`;
                    else
                        return `[${numPart}]`;
                }
                ).join("+");

                const asText = displayRolls.map(r=>`[${r.val}]`).join("+");

                const asMd = displayRolls.map(r=>{
                    if (r.isDropped)
                        return `~~[${r.val}]~~`;
                    else if (r.isExploded)
                        return `_[${r.val}]_`;
                    else if (r.isSuccess)
                        return `**[${r.val}]**`;
                    else
                        return `[${r.val}]`;
                }
                ).join("+");

                this.addToMeta(meta, {
                    html: asHtml,
                    text: asText,
                    md: asMd,
                }, );
            }

            if (fnName === "evl") {
                const maxRolls = rolls.filter(it=>it.val === faces && !it.isDropped);
                const minRolls = rolls.filter(it=>it.val === 1 && !it.isDropped);
                meta.allMax = meta.allMax || [];
                meta.allMin = meta.allMin || [];
                meta.allMax.push(maxRolls.length && maxRolls.length === rolls.length);
                meta.allMin.push(minRolls.length && minRolls.length === rolls.length);
            }

            if (isSuccessMode) {
                return rolls.filter(it=>!it.isDropped && it.isSuccess).length;
            } else {
                return rolls.filter(it=>!it.isDropped).map(it=>it.val).sum();
            }
        }

        toString() {
            if (this._nodes.length === 1)
                return this._nodes[0].toString();
            const [numSym,facesSym] = this._nodes;
            let out = `${numSym.toString()}d${facesSym.toString()}`;

            for (let i = 2; i < this._nodes.length; ++i) {
                const n = this._nodes[i];
                if (n.isDiceModifierGroup)
                    out += n.mods.map(it=>`${it.modSym.toString()}${it.numSym.toString()}`).join("");
                else
                    out += `d${n.toString()}`;
            }

            return out;
        }
    }
    ,

    Exponent: class extends Renderer.dice.AbstractSymbol {
        constructor(nodes) {
            super();
            this._nodes = nodes;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            const view = this._nodes.slice();
            let val = view.pop()[fnName](meta);
            while (view.length) {
                this.addToMeta(meta, {
                    text: "^"
                });
                val = view.pop()[fnName](meta) ** val;
            }
            return val;
        }

        toString() {
            const view = this._nodes.slice();
            let out = view.pop().toString();
            while (view.length)
                out = `${view.pop().toString()}^${out}`;
            return out;
        }
    }
    ,

    Term: class extends Renderer.dice.AbstractSymbol {
        constructor(nodes) {
            super();
            this._nodes = nodes;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            let out = this._nodes[0][fnName](meta);

            for (let i = 1; i < this._nodes.length; i += 2) {
                if (this._nodes[i].eq(Renderer.dice.tk.MULT)) {
                    this.addToMeta(meta, {
                        text: " × "
                    });
                    out *= this._nodes[i + 1][fnName](meta);
                } else if (this._nodes[i].eq(Renderer.dice.tk.DIV)) {
                    this.addToMeta(meta, {
                        text: " ÷ "
                    });
                    out /= this._nodes[i + 1][fnName](meta);
                } else
                    throw new Error(`Unimplemented!`);
            }

            return out;
        }

        toString() {
            let out = this._nodes[0].toString();
            for (let i = 1; i < this._nodes.length; i += 2) {
                if (this._nodes[i].eq(Renderer.dice.tk.MULT))
                    out += ` * ${this._nodes[i + 1].toString()}`;
                else if (this._nodes[i].eq(Renderer.dice.tk.DIV))
                    out += ` / ${this._nodes[i + 1].toString()}`;
                else
                    throw new Error(`Unimplemented!`);
            }
            return out;
        }
    }
    ,

    Expression: class extends Renderer.dice.AbstractSymbol {
        constructor(nodes) {
            super();
            this._nodes = nodes;
        }

        _evl(meta) {
            return this._invoke("evl", meta);
        }
        _avg(meta) {
            return this._invoke("avg", meta);
        }
        _min(meta) {
            return this._invoke("min", meta);
        }
        _max(meta) {
            return this._invoke("max", meta);
        }

        _invoke(fnName, meta) {
            const view = this._nodes.slice();

            let isNeg = false;
            if (view[0].eq(Renderer.dice.tk.ADD) || view[0].eq(Renderer.dice.tk.SUB)) {
                isNeg = view.shift().eq(Renderer.dice.tk.SUB);
                if (isNeg)
                    this.addToMeta(meta, {
                        text: "-"
                    });
            }

            let out = view[0][fnName](meta);
            if (isNeg)
                out = -out;

            for (let i = 1; i < view.length; i += 2) {
                if (view[i].eq(Renderer.dice.tk.ADD)) {
                    this.addToMeta(meta, {
                        text: " + "
                    });
                    out += view[i + 1][fnName](meta);
                } else if (view[i].eq(Renderer.dice.tk.SUB)) {
                    this.addToMeta(meta, {
                        text: " - "
                    });
                    out -= view[i + 1][fnName](meta);
                } else
                    throw new Error(`Unimplemented!`);
            }

            return out;
        }

        toString(indent=0) {
            let out = "";
            const view = this._nodes.slice();

            let isNeg = false;
            if (view[0].eq(Renderer.dice.tk.ADD) || view[0].eq(Renderer.dice.tk.SUB)) {
                isNeg = view.shift().eq(Renderer.dice.tk.SUB);
                if (isNeg)
                    out += "-";
            }

            out += view[0].toString(indent);
            for (let i = 1; i < view.length; i += 2) {
                if (view[i].eq(Renderer.dice.tk.ADD))
                    out += ` + ${view[i + 1].toString(indent)}`;
                else if (view[i].eq(Renderer.dice.tk.SUB))
                    out += ` - ${view[i + 1].toString(indent)}`;
                else
                    throw new Error(`Unimplemented!`);
            }
            return out;
        }
    }
    ,
};
//#endregion

//#region VeLock
globalThis.VeLock = function({name=null, isDbg=false}={}) {
    this._name = name;
    this._isDbg = isDbg;
    this._lockMeta = null;

    this._getCaller = ()=>{
        return (new Error()).stack.split("\n")[3].trim();
    }
    ;

    this.pLock = async({token=null}={})=>{
        if (token != null && this._lockMeta?.token === token) {
            ++this._lockMeta.depth;
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" add (now ${this._lockMeta.depth}) at ${this._getCaller()}`);
            return token;
        }

        while (this._lockMeta)
            await this._lockMeta.lock;

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" acquired at ${this._getCaller()}`);

        let unlock = null;
        const lock = new Promise(resolve=>unlock = resolve);
        this._lockMeta = {
            lock,
            unlock,
            token: CryptUtil.uid(),
            depth: 0,
        };

        return this._lockMeta.token;
    }
    ;

    this.unlock = ()=>{
        if (!this._lockMeta)
            return;

        if (this._lockMeta.depth > 0) {
            if (this._isDbg)
                console.warn(`Lock "${this._name || "(unnamed)"}" sub (now ${this._lockMeta.depth - 1}) at ${this._getCaller()}`);
            return --this._lockMeta.depth;
        }

        if (this._isDbg)
            console.warn(`Lock "${this._name || "(unnamed)"}" released at ${this._getCaller()}`);

        const lockMeta = this._lockMeta;
        this._lockMeta = null;
        lockMeta.unlock();
    }
    ;
}
;
//#endregion
//#region Config
class Config {
    
    static ["_IS_INIT"] = false;
    static ["_IS_INIT_SAVE_REQUIRED"] = false;
    static get ['backendEndpoint']() {
      const _0xa1e040 = Config.get("misc", "backendEndpoint");
      if (_0xa1e040) {
        return _0xa1e040;
      }
      return ROUTE_PREFIX ? '/' + ROUTE_PREFIX + "/api/plutonium" : "/api/plutonium";
    }
    static get ["isInit"]() {
      return this._IS_INIT;
    }
    static ["prePreInit"]() {
      this._preInit_doLoadConfig();
    }
    static ["_preInit_getLoadedConfig"]() {
      let _0x4eb887 = UtilGameSettings.getSafe(SharedConsts.MODULE_ID, Config._SETTINGS_KEY);
      if (_0x4eb887 == null || !Object.keys(_0x4eb887).length) {
        return {
          'isLoaded': false,
          'config': Config._getDefaultGmConfig()
        };
      }
      return {
        'isLoaded': true,
        'config': ConfigMigration.getMigrated({
          'config': _0x4eb887
        })
      };
    }
    static ['_preInit_doLoadConfig']() {
      this._pPrePreInit_registerSettings();
      const {
        isLoaded: _0xa6ae2f,
        config: _0x2491d4
      } = this._preInit_getLoadedConfig();
      Config._CONFIG = _0x2491d4;
      if (_0xa6ae2f) {
        const _0x4150fc = this._populateMissingConfigValues(Config._CONFIG, {
          'isPlayer': false
        });
        this._IS_INIT_SAVE_REQUIRED = this._IS_INIT_SAVE_REQUIRED || _0x4150fc;
      }
      game.socket.on(this._SOCKET_ID, _0x11513f => {
        switch (_0x11513f.type) {
          case "config.update":
            {
              const _0x2829e6 = _0x11513f.config;
              const _0x218c03 = MiscUtil.copy(Config._CONFIG);
              Object.assign(Config._CONFIG, _0x2829e6);
              if (!UtilPrePreInit.isGM()) {
                ConfigApp.handleGmConfigUpdate(_0x2829e6);
              }
              UtilHooks.callAll(UtilHooks.HK_CONFIG_UPDATE, {
                'previous': _0x218c03,
                'current': MiscUtil.copy(Config._CONFIG)
              });
              break;
            }
        }
      });
      if (!UtilPrePreInit.isGM()) {
        const _0x2f835b = GameStorage.getClient(Config._CLIENT_SETTINGS_KEY);
        if (_0x2f835b == null) {
          Config._CONFIG_PLAYER = Config._getDefaultPlayerConfig();
        } else {
          Config._CONFIG_PLAYER = _0x2f835b;
          const _0x2803d0 = this._populateMissingConfigValues(Config._CONFIG_PLAYER, {
            'isPlayer': true
          });
          this._IS_INIT_SAVE_REQUIRED = this._IS_INIT_SAVE_REQUIRED || _0x2803d0;
        }
      }
      this._pInit_initCompatibilityTempOverrides();
      this._IS_INIT = true;
    }
    static ['_COMPATIBILITY_TEMP_OVERRIDES'] = null;
    static ["_pInit_initCompatibilityTempOverrides"]() {
      ConfigConsts.getDefaultConfigSortedFlat_().forEach(([_0x5f00ec, _0x5379fb]) => {
        Object.entries(_0x5379fb).forEach(([_0x20a13a, _0x3eecc1]) => {
          if (!_0x3eecc1.compatibilityModeValues) {
            return;
          }
          Object.entries(_0x3eecc1.compatibilityModeValues).find(([_0x25d591, _0x5ef870]) => {
            const _0x540a72 = _0x3eecc1.type === "enum" ? ConfigUtilsSettings.getEnumValueValue(_0x5ef870) : _0x5ef870;
            const _0x2883d8 = _0x3eecc1.type === "enum" ? _0x5ef870.name || _0x540a72 : _0x540a72;
            if (!UtilCompat.isModuleActive(_0x25d591)) {
              return false;
            }
            const _0x4a4aec = Config.get(_0x5f00ec, _0x20a13a);
            const _0x486d1b = !CollectionUtil.deepEquals(_0x540a72, _0x4a4aec);
            Config.setTemp(_0x5f00ec, _0x20a13a, _0x540a72, {
              'isSkipPermissionCheck': true
            });
            if (_0x486d1b) {
              const {
                displayGroup: _0x314d1c,
                displayKey: _0x4cabc2
              } = Config._getDisplayLabels(_0x5f00ec, _0x20a13a);
              const _0x5d4132 = _0x4a4aec != null ? JSON.stringify(_0x4a4aec) : _0x4a4aec;
              const _0x4fb80d = _0x2883d8 != null ? JSON.stringify(_0x2883d8) : _0x2883d8;
              this._COMPATIBILITY_TEMP_OVERRIDES = this._COMPATIBILITY_TEMP_OVERRIDES || {};
              MiscUtil.set(this._COMPATIBILITY_TEMP_OVERRIDES, _0x5f00ec, _0x20a13a, {
                'value': _0x540a72,
                'message': "\"" + _0x314d1c + " -&gt; " + _0x4cabc2 + "\" value `" + _0x5d4132 + "` has compatibility issues with module \"" + game.modules.get(_0x25d591).title + "\" (must be set to `" + _0x4fb80d + '`)'
              });
              console.warn(...LGT, game.modules.get(_0x25d591).title + " detected! Setting compatibility config: " + _0x5f00ec + '.' + _0x20a13a + " = " + _0x4fb80d + " (was " + _0x5d4132 + "). If you encounter unexpected issues, consider disabling either module.");
            }
          });
        });
      });
    }
    static ["_hasCompatibilityWarnings"]() {
      return this._COMPATIBILITY_TEMP_OVERRIDES != null;
    }
    static ["_getCompatibilityWarnings"]() {
      if (!this._COMPATIBILITY_TEMP_OVERRIDES) {
        return '';
      }
      const _0x35b741 = Object.values(this._COMPATIBILITY_TEMP_OVERRIDES).map(_0x152dda => Object.values(_0x152dda).map(_0x120f14 => _0x120f14.message)).flat().map(_0xcf5598 => " - " + _0xcf5598).join("\n");
      return "Click to resolve config module compatibility issues. Issues detected:\n" + _0x35b741 + '.';
    }
    static ["_doResolveCompatibility"]() {
      Object.entries(this._COMPATIBILITY_TEMP_OVERRIDES).forEach(([_0xf82a5d, _0x3d417f]) => {
        Object.entries(_0x3d417f).forEach(([_0x10d0e6, _0x5141bd]) => {
          Config.set(_0xf82a5d, _0x10d0e6, _0x5141bd.value);
        });
      });
      this._COMPATIBILITY_TEMP_OVERRIDES = null;
    }
    static ['_pPrePreInit_registerSettings']() {
      game.settings.register(SharedConsts.MODULE_ID, Config._SETTINGS_KEY, {
        'name': 'Config',
        'default': {},
        'type': Object,
        'scope': "world",
        'onChange': _0x2cf485 => {}
      });
    }
    static ["pOpen"]({
      evt = null,
      initialVisibleGroup = null
    } = {}) {
      return ConfigApp.pOpen({
        'evt': evt,
        'initialVisibleGroup': initialVisibleGroup,
        'backend': this
      });
    }
    static ["_populateMissingConfigValues"](_0x269be7, _0x40a182) {
      _0x40a182 = _0x40a182 || {};
      const _0x5ddf60 = !!_0x40a182.isPlayer;
      let _0x811367 = false;
      Object.entries(this._getDefaultConfig({
        'isPlayer': _0x5ddf60
      })).forEach(([_0x159930, _0x40e344]) => {
        if (!_0x269be7[_0x159930]) {
          _0x269be7[_0x159930] = _0x40e344;
          _0x811367 = true;
        } else {
          Object.entries(_0x40e344).forEach(([_0xfb319f, _0x2cb8c5]) => {
            if (_0x269be7[_0x159930][_0xfb319f] === undefined) {
              _0x269be7[_0x159930][_0xfb319f] = _0x2cb8c5;
              _0x811367 = true;
            }
          });
        }
      });
      return _0x811367;
    }
    static async ["pInit"]() {
      if (this._IS_INIT_SAVE_REQUIRED) {
        Config._saveConfigDebounced();
      }
      this._IS_INIT_SAVE_REQUIRED = false;
    }
    static ["_getDefaultGmConfig"]() {
      return this._getDefaultConfig({
        'isPlayer': false
      });
    }
    static ["_getDefaultPlayerConfig"]() {
      return this._getDefaultConfig({
        'isPlayer': true
      });
    }
    static ["_getDefaultConfig"](_0x3ef533) {
      _0x3ef533 = _0x3ef533 || {};
      const _0x3a1d8e = _0x3ef533.isPlayer;
      const _0x1f778c = MiscUtil.copy(ConfigConsts.getDefaultConfigSorted_());
      const _0x39f69c = {};
      _0x1f778c.forEach(([_0x1e3fbb, _0x120dfe]) => {
        const _0x5a892a = _0x39f69c[_0x1e3fbb] = {};
        const _0x2a5160 = _0x1fa78d => Object.entries(_0x1fa78d).forEach(([_0x249b71, _0x38a295]) => {
          if (_0x3a1d8e) {
            if (_0x38a295.isPlayerEditable) {
              _0x5a892a[_0x249b71] = null;
            }
          } else {
            _0x5a892a[_0x249b71] = _0x38a295["default"];
          }
        });
        if (_0x120dfe.settings) {
          _0x2a5160(_0x120dfe.settings);
        }
        if (_0x120dfe.settingsAdvanced) {
          _0x2a5160(_0x120dfe.settingsAdvanced);
        }
        if (_0x120dfe.settingsHacks) {
          _0x2a5160(_0x120dfe.settingsHacks);
        }
      });
      _0x39f69c.version = ConfigMigration.CURRENT_VERSION;
      return _0x39f69c;
    }
    static ['set'](_0x4f9d2a, _0x1112ce, _0xc4fc91) {
      if (!this._isCanSetConfig(_0x4f9d2a, _0x1112ce)) {
        return;
      }
      const _0x122bb6 = Config.get(_0x4f9d2a, _0x1112ce);
      const _0x5ededb = UtilPrePreInit.isGM() ? Config._CONFIG : Config._CONFIG_PLAYER;
      (_0x5ededb[_0x4f9d2a] = _0x5ededb[_0x4f9d2a] || {})[_0x1112ce] = _0xc4fc91;
      Config._saveConfigDebounced();
      this._fireConfigUpdateHook(_0x4f9d2a, _0x1112ce, _0x122bb6, _0xc4fc91);
    }
    static ['setTemp'](_0x43e89c, _0x14b600, _0x30dc13, {
      isSkipPermissionCheck = false
    } = {}) {
      if (!isSkipPermissionCheck && !this._isCanSetConfig(_0x43e89c, _0x14b600)) {
        return;
      }
      const _0x10d336 = Config.get(_0x43e89c, _0x14b600);
      (Config._CONFIG_TEMP[_0x43e89c] = Config._CONFIG_TEMP[_0x43e89c] || {})[_0x14b600] = _0x30dc13;
      this._fireConfigUpdateHook(_0x43e89c, _0x14b600, _0x10d336, _0x30dc13);
    }
    static ["setRivetTargetDocument"]({
      actor: _0x7aa906,
      pack: _0x11cb33
    } = {}) {
      if (_0x7aa906 && _0x11cb33) {
        throw new Error("Only one of \"actor\" or \"pack\" may be specified!");
      }
      if (!_0x7aa906 && !_0x11cb33) {
        ui.notifications.info("Cleared Rivet import target. Rivet will now import to an appropriate directory.");
        Config.set("rivet", "targetDocumentId", null);
        return;
      }
      if (_0x7aa906) {
        const _0x4dae8a = _0x7aa906.isToken ? _0x7aa906.uuid : _0x7aa906.id;
        if (Config.get("rivet", "targetDocumentId") === _0x4dae8a) {
          Config.set("rivet", "targetDocumentId", null);
          ui.notifications.warn("Cleared Rivet import target. Rivet will now import to an appropriate directory.");
          return;
        }
        Config.set("rivet", 'targetDocumentId', _0x4dae8a);
        ui.notifications.info("Set Rivet import target. Rivet will now import to Actor \"" + _0x7aa906.name + "\" (" + _0x4dae8a + "). This can be changed in the Config.");
        return;
      }
      if (_0x11cb33) {
        const _0xef065a = 'Compendium.' + _0x11cb33.metadata.id;
        if (Config.get('rivet', 'targetDocumentId') === _0xef065a) {
          Config.set("rivet", "targetDocumentId", null);
          ui.notifications.warn("Cleared Rivet import target. Rivet will now import to an appropriate directory.");
          return;
        }
        Config.set('rivet', "targetDocumentId", _0xef065a);
        ui.notifications.info("Set Rivet import target. Rivet will now import to Compendium \"" + _0x11cb33.metadata.label + "\" (" + _0x11cb33.metadata.id + "). This can be changed in the Config.");
      }
    }
    static ["_fireConfigUpdateHook"](_0x374034, _0xb156d3, _0x305b29, _0xea010c) {
      UtilHooks.callAll(UtilHooks.HK_CONFIG_UPDATE, {
        'previous': {
          [_0x374034]: {
            [_0xb156d3]: _0x305b29
          }
        },
        'current': {
          [_0x374034]: {
            [_0xb156d3]: _0xea010c
          }
        }
      });
    }
    static ["_isCanSetConfig"](_0x347dfb, _0x3965df) {
      return UtilPrePreInit.isGM() || ConfigUtilsSettings.isPlayerEditable(_0x347dfb, _0x3965df);
    }
    static ["_LOCK_SAVE_CONFIG"] = new VeLock({
      'name': "save config"
    });
    static async ["_pSaveConfig"]() {
      try {
        await this._LOCK_SAVE_CONFIG.pLock();
        await this._pSaveConfig_();
      } finally {
        this._LOCK_SAVE_CONFIG.unlock();
      }
    }
    static async ["_pSaveConfig_"]() {
      if (!UtilPrePreInit.isGM()) {
        await GameStorage.pSetClient(Config._CLIENT_SETTINGS_KEY, MiscUtil.copy(Config._CONFIG_PLAYER));
        return;
      }
      await game.settings.set(SharedConsts.MODULE_ID, Config._SETTINGS_KEY, MiscUtil.copy(Config._CONFIG));
      const _0x473106 = {
        'type': "config.update",
        'config': MiscUtil.copy(this._CONFIG)
      };
      game.socket.emit(Config._SOCKET_ID, _0x473106);
    }
    static ["_saveConfigDebounced"] = MiscUtil.throttle(Config._pSaveConfig, 0x64);
    static get(_0x1f916e, _0x501497, {isIgnorePlayer = false} = {}) {
      if (Config._CONFIG_TEMP[_0x1f916e]?.[_0x501497] !== undefined) {
        return Config._CONFIG_TEMP[_0x1f916e][_0x501497];
      }
      if (!UtilPrePreInit.isGM() && ConfigUtilsSettings.isPlayerEditable(_0x1f916e, _0x501497) && !isIgnorePlayer) {
        const _0x15b827 = (Config._CONFIG_PLAYER[_0x1f916e] || {})[_0x501497];
        if (ConfigUtilsSettings.isNullable(_0x1f916e, _0x501497) && _0x15b827 === null || _0x15b827 != null) {
          return this._get_getValidValue(_0x1f916e, _0x501497, _0x15b827);
        }
      }
      const _0x470979 = (Config._CONFIG[_0x1f916e] || {})[_0x501497];
      return this._get_getValidValue(_0x1f916e, _0x501497, _0x470979);
    }
    static ["_get_getValidValue"](_0x2319bc, _0x734aa3, _0x56c713) {
      const _0x14e622 = ConfigConsts.getDefaultConfigSortedFlat_().find(([_0x35aa58]) => _0x35aa58 === _0x2319bc)[0x1][_0x734aa3];
      if (_0x14e622.type !== "enum") {
        return _0x56c713;
      }
      if (_0x14e622.isNullable && _0x56c713 == null) {
        return _0x56c713;
      }
      const _0x4bd728 = ConfigUtilsSettings.getEnumValues(_0x14e622);
      if (_0x56c713 == null || !_0x4bd728.some(_0x472e97 => (_0x472e97.value ?? _0x472e97) === _0x56c713)) {
        return _0x14e622["default"] ?? _0x4bd728[0x0].value ?? _0x4bd728[0x0];
      }
      return _0x56c713;
    }
    static ["_getDisplayLabels"](_0x288279, _0xf85c74) {
      const _0x6262b3 = ConfigConsts.getDefaultConfig_();
      const _0x5cebfe = _0x6262b3[_0x288279]?.["name"];
      const _0x956382 = _0x6262b3[_0x288279]?.["settings"]?.[_0xf85c74]?.['name'] || _0x6262b3[_0x288279]?.['settingsAdvanced']?.[_0xf85c74]?.["name"] || _0x6262b3[_0x288279]?.['settingsHacks']?.[_0xf85c74]?.['name'];
      return {
        'displayGroup': _0x5cebfe,
        'displayKey': _0x956382
      };
    }
    static ['has'](_0x23c99c, _0x413db8) {
      return !!ConfigConsts.getDefaultConfigSortedFlat_().find(([_0x24a9a0]) => _0x24a9a0 === _0x23c99c)?.[0x1]?.[_0x413db8];
    }
    static ["getSafe"](_0x48e921, _0x55bcb1) {
      try {
        return this.get(_0x48e921, _0x55bcb1);
      } catch (_0x3f1440) {
        return undefined;
      }
    }
    static ["handleFailedInitConfigApplication"](_0x26ed85, _0x525fb9, _0x1a25c6) {
      const {
        displayGroup: _0x576794,
        displayKey: _0x1c32ad
      } = Config._getDisplayLabels(_0x26ed85, _0x525fb9);
      ui.notifications.error("Failed to apply Config \"" + _0x1c32ad + "\" -> \"" + _0x576794 + "\" during initial load! " + VeCt.STR_SEE_CONSOLE);
      if (_0x1a25c6) {
        console.error(...LGT, _0x1a25c6);
      }
    }
    static ["isUseMetricDistance"]({
      configGroup: _0x4095b3,
      configKey = "isMetricDistance"
    }) {
      return Config.get("import", "isGlobalMetricDistance") || Config.has(_0x4095b3, configKey) && Config.get(_0x4095b3, configKey);
    }
    static ["isUseMetricWeight"]({
      configGroup: _0x335df5,
      configKey = "isMetricWeight"
    }) {
      if (UtilGameSettings.getSafe(game.system.id, "metricWeightUnits")) {
        return true;
      }
      return Config.get('import', "isGlobalMetricWeight") || Config.has(_0x335df5, configKey) && Config.get(_0x335df5, configKey);
    }
    static ["getMetricNumberDistance"]({
      configGroup: _0x287496,
      originalValue: _0x2525c8,
      originalUnit: _0x15cbf9,
      configKey = "isMetricDistance",
      toFixed: _0x4780c3
    }) {
      return this._getMetricNumber({
        'configGroup': _0x287496,
        'originalValue': _0x2525c8,
        'originalUnit': _0x15cbf9,
        'configKey': configKey,
        'fnIsUse': Config.isUseMetricDistance.bind(Config),
        'toFixed': _0x4780c3
      });
    }
    static ['getMetricNumberWeight']({
      configGroup: _0x472563,
      originalValue: _0x3bcac6,
      originalUnit: _0x2715b2,
      configKey = "isMetricWeight",
      toFixed: _0x371dc8
    }) {
      return this._getMetricNumber({
        'configGroup': _0x472563,
        'originalValue': _0x3bcac6,
        'originalUnit': _0x2715b2,
        'configKey': configKey,
        'fnIsUse': Config.isUseMetricWeight.bind(Config),
        'toFixed': _0x371dc8
      });
    }
    static ["_getMetricNumber"]({
      configGroup: _0x3f59a7,
      originalValue: _0xb3e2df,
      originalUnit: _0x48ea42,
      configKey: _0x3f6086,
      fnIsUse: _0x4e4c24,
      toFixed: _0x13e977
    }) {
      if (!_0x4e4c24({
        'configGroup': _0x3f59a7,
        'configKey': _0x3f6086
      })) {
        if (_0x13e977) {
          return NumberUtil.toFixedNumber(_0xb3e2df, _0x13e977);
        }
        return _0xb3e2df;
      }
      return Parser.metric.getMetricNumber({
        'originalValue': _0xb3e2df,
        'originalUnit': _0x48ea42,
        'toFixed': _0x13e977 ?? 0x3
      });
    }
    static ['getMetricUnitDistance']({
      configGroup: _0x293bb4,
      originalUnit: _0x3ed5b6,
      configKey = "isMetricDistance",
      isShortForm = true,
      isPlural = false
    }) {
      return this._getMetricUnit({
        'configGroup': _0x293bb4,
        'originalUnit': _0x3ed5b6,
        'configKey': configKey,
        'isShortForm': isShortForm,
        'isPlural': isPlural,
        'fnIsUse': Config.isUseMetricDistance.bind(Config)
      });
    }
    static ["getMetricUnitWeight"]({
      configGroup: _0x486606,
      originalUnit: _0x50698d,
      configKey = "isMetricWeight",
      isShortForm = true,
      isPlural = false
    }) {
      return this._getMetricUnit({
        'configGroup': _0x486606,
        'originalUnit': _0x50698d,
        'configKey': configKey,
        'isShortForm': isShortForm,
        'isPlural': isPlural,
        'fnIsUse': Config.isUseMetricWeight.bind(Config)
      });
    }
    static ["_getMetricUnit"]({
      configGroup: _0x50bdc7,
      originalUnit: _0x5f0dc8,
      configKey: _0x4280fe,
      isShortForm: _0x45e3bf,
      isPlural: _0x44cab6,
      fnIsUse: _0x2933c2
    }) {
      if (!_0x2933c2({
        'configGroup': _0x50bdc7,
        'configKey': _0x4280fe
      })) {
        if (!_0x45e3bf) {
          return _0x5f0dc8;
        }
        switch (_0x5f0dc8) {
          case Parser.UNT_FEET:
            return 'ft';
          case Parser.UNT_YARDS:
            return 'yd';
          case Parser.UNT_MILES:
            return 'mi';
          default:
            return _0x5f0dc8;
        }
      }
      return Parser.metric.getMetricUnit({
        'originalUnit': _0x5f0dc8,
        'isShortForm': _0x45e3bf,
        'isPlural': _0x44cab6
      });
    }
    static ["getSpellPointsKey"]({
      actorType: _0x34101f
    }) {
      return _0x34101f === 'character' ? "spellPointsMode" : "spellPointsModeNpc";
    }
    static ["getSpellPointsResource"]({
      isValueKey = false,
      isMaxKey = false
    } = {}) {
      return this._getSpellPsiPointsResource({
        'configGroup': "importSpell",
        'configKey': "spellPointsResource",
        'configKeyCustom': "spellPointsResourceCustom",
        'isValueKey': isValueKey,
        'isMaxKey': isMaxKey
      });
    }
    static ["getPsiPointsResource"]({
      isValueKey = false,
      isMaxKey = false
    } = {}) {
      return this._getSpellPsiPointsResource({
        'configGroup': "importPsionic",
        'configKey': "psiPointsResource",
        'configKeyCustom': "psiPointsResourceCustom",
        'isValueKey': isValueKey,
        'isMaxKey': isMaxKey
      });
    }
    static ["_getSpellPsiPointsResource"]({
      configGroup: _0x5ff393,
      configKey: _0x61a78,
      configKeyCustom: _0x27b383,
      isValueKey = false,
      isMaxKey = false
    } = {}) {
      if (Config.get(_0x5ff393, _0x61a78) === ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM) {
        return ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM;
      }
      if (isValueKey && isMaxKey) {
        throw new Error("Only one of \"isValue\" and \"isMax\" may be specified!");
      }
      const _0x265e6e = Config.get(_0x5ff393, _0x61a78) === ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM ? Config.get(_0x5ff393, _0x27b383) : Config.get(_0x5ff393, _0x61a78);
      return isValueKey ? _0x265e6e + ".value" : isMaxKey ? _0x265e6e + ".max" : _0x265e6e;
    }
}
Config._SETTINGS_KEY = "config";
Config._CLIENT_SETTINGS_KEY = SharedConsts.MODULE_ID + '_config';
Config._SOCKET_ID = "module." + SharedConsts.MODULE_ID;
Config._CONFIG = {};
Config._CONFIG_PLAYER = {};
Config._CONFIG_TEMP = {};
//#endregion


//#region SourceFilter
let FilterBox$1 = class FilterBox extends ProxyBase {
    static TITLE_BTN_RESET = "Reset filters. SHIFT to reset everything.";

    static selectFirstVisible(entryList) {
        if (Hist.lastLoadedId == null && !Hist.initialLoad) {
            Hist._freshLoad();
        }

    }

    constructor(opts) {
        super();

        this._$iptSearch = opts.$iptSearch;
        this._$wrpFormTop = opts.$wrpFormTop;
        this._$btnReset = opts.$btnReset;
        this._$btnOpen = opts.$btnOpen;
        this._$wrpMiniPills = opts.$wrpMiniPills;
        this._$btnToggleSummaryHidden = opts.$btnToggleSummaryHidden;
        this._filters = opts.filters;
        this._isCompact = opts.isCompact;
        this._namespace = opts.namespace;

        this._doSaveStateThrottled = MiscUtil.throttle(()=>this._pDoSaveState(), 50);
        this.__meta = this._getDefaultMeta();
        if (this._isCompact)
            this.__meta.isSummaryHidden = true;

        this._meta = this._getProxy("meta", this.__meta);
        this.__minisHidden = {};
        this._minisHidden = this._getProxy("minisHidden", this.__minisHidden);
        this.__combineAs = {};
        this._combineAs = this._getProxy("combineAs", this.__combineAs);
        this._modalMeta = null;
        this._isRendered = false;

        this._cachedState = null;

        this._compSearch = BaseComponent.fromObject({
            search: ""
        });
        this._metaIptSearch = null;

        this._filters.forEach(f=>f.filterBox = this);

        this._eventListeners = {};
    }

    get filters() {
        return this._filters;
    }

    teardown() {
        this._filters.forEach(f=>f._doTeardown());
        if (this._modalMeta)
            this._modalMeta.doTeardown();
    }

    on(identifier, fn) {
        const [eventName,namespace] = identifier.split(".");
        (this._eventListeners[eventName] = this._eventListeners[eventName] || []).push({
            namespace,
            fn
        });
        return this;
    }

    off(identifier, fn=null) {
        const [eventName,namespace] = identifier.split(".");
        this._eventListeners[eventName] = (this._eventListeners[eventName] || []).filter(it=>{
            if (fn != null)
                return it.namespace !== namespace || it.fn !== fn;
            return it.namespace !== namespace;
        }
        );
        if (!this._eventListeners[eventName].length)
            delete this._eventListeners[eventName];
        return this;
    }

    fireChangeEvent() {
        this._doSaveStateThrottled();
        this.fireEvent(FilterBox$1.EVNT_VALCHANGE);
    }

    fireEvent(eventName) {
        (this._eventListeners[eventName] || []).forEach(it=>it.fn());
    }

    _getNamespacedStorageKey() {
        return `${FilterBox$1._STORAGE_KEY}${this._namespace ? `.${this._namespace}` : ""}`;
    }
    getNamespacedHashKey(k) {
        return `${k || "_".repeat(FilterUtil.SUB_HASH_PREFIX_LENGTH)}${this._namespace ? `.${this._namespace}` : ""}`;
    }

    async pGetStoredActiveSources() {
        const stored = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
        if (stored) {
            const sourceFilterData = stored.filters[FilterBox$1.SOURCE_HEADER];
            if (sourceFilterData) {
                const state = sourceFilterData.state;
                const blue = [];
                const white = [];
                Object.entries(state).forEach(([src,mode])=>{
                    if (mode === 1)
                        blue.push(src);
                    else if (mode !== -1)
                        white.push(src);
                }
                );
                if (blue.length)
                    return blue;
                else
                    return white;
            }
        }
        return null;
    }

    registerMinisHiddenHook(prop, hook) {
        this._addHook("minisHidden", prop, hook);
    }

    isMinisHidden(header) {
        return !!this._minisHidden[header];
    }

    async pDoLoadState() {
        const toLoad = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
        if (toLoad == null)
            return;
        this._setStateFromLoaded(toLoad, {
            isUserSavedState: true
        });
    }

    _setStateFromLoaded(state, {isUserSavedState=false}={}) {
        state.box = state.box || {};
        this._proxyAssign("meta", "_meta", "__meta", state.box.meta || {}, true);
        this._proxyAssign("minisHidden", "_minisHidden", "__minisHidden", state.box.minisHidden || {}, true);
        this._proxyAssign("combineAs", "_combineAs", "__combineAs", state.box.combineAs || {}, true);
        this._filters.forEach(it=>it.setStateFromLoaded(state.filters, {
            isUserSavedState
        }));
    }

    _getSaveableState() {
        const filterOut = {};
        this._filters.forEach(it=>Object.assign(filterOut, it.getSaveableState()));
        return {
            box: {
                meta: {
                    ...this.__meta
                },
                minisHidden: {
                    ...this.__minisHidden
                },
                combineAs: {
                    ...this.__combineAs
                },
            },
            filters: filterOut,
        };
    }

    async _pDoSaveState() {
        await StorageUtil.pSetForPage(this._getNamespacedStorageKey(), this._getSaveableState());
    }

    trimState_() {
        this._filters.forEach(f=>f.trimState_());
    }

    render() {
        if (this._isRendered) {
            this._filters.map(f=>f.update());
            return;
        }
        this._isRendered = true;

        if (this._$wrpFormTop || this._$wrpMiniPills) {
            if (!this._$wrpMiniPills) {
                this._$wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`).insertAfter(this._$wrpFormTop);
            } else {
                this._$wrpMiniPills.addClass("fltr__mini-view");
            }
        }

        if (this._$btnReset) {
            this._$btnReset.title(FilterBox$1.TITLE_BTN_RESET).click((evt)=>this.reset(evt.shiftKey));
        }

        if (this._$wrpFormTop || this._$btnToggleSummaryHidden) {
            if (!this._$btnToggleSummaryHidden) {
                this._$btnToggleSummaryHidden = $(`<button class="btn btn-default ${this._isCompact ? "p-2" : ""}" title="Toggle Filter Summary"><span class="glyphicon glyphicon-resize-small"></span></button>`).prependTo(this._$wrpFormTop);
            } else if (!this._$btnToggleSummaryHidden.parent().length) {
                this._$btnToggleSummaryHidden.prependTo(this._$wrpFormTop);
            }
            this._$btnToggleSummaryHidden.click(()=>{
                this._meta.isSummaryHidden = !this._meta.isSummaryHidden;
                this._doSaveStateThrottled();
            }
            );
            const summaryHiddenHook = ()=>{
                this._$btnToggleSummaryHidden.toggleClass("active", !!this._meta.isSummaryHidden);
                this._$wrpMiniPills.toggleClass("ve-hidden", !!this._meta.isSummaryHidden);
            }
            ;
            this._addHook("meta", "isSummaryHidden", summaryHiddenHook);
            summaryHiddenHook();
        }

        if (this._$wrpFormTop || this._$btnOpen) {
            if (!this._$btnOpen) {
                this._$btnOpen = $(`<button class="btn btn-default ${this._isCompact ? "px-2" : ""}">Filter</button>`).prependTo(this._$wrpFormTop);
            } else if (!this._$btnOpen.parent().length) {
                this._$btnOpen.prependTo(this._$wrpFormTop);
            }
            this._$btnOpen.click(()=>this.show());
        }

        const sourceFilter = this._filters.find(it=>it.header === FilterBox$1.SOURCE_HEADER);
        if (sourceFilter) {
            const selFnAlt = (val)=>!SourceUtil.isNonstandardSource(val) && !PrereleaseUtil.hasSourceJson(val) && !BrewUtil2.hasSourceJson(val);
            const hkSelFn = ()=>{
                if (this._meta.isBrewDefaultHidden)
                    sourceFilter.setTempFnSel(selFnAlt);
                else
                    sourceFilter.setTempFnSel(null);
                sourceFilter.updateMiniPillClasses();
            }
            ;
            this._addHook("meta", "isBrewDefaultHidden", hkSelFn);
            hkSelFn();
        }

        if (this._$wrpMiniPills)
            this._filters.map((f,i)=>f.$renderMinis({
                filterBox: this,
                isFirst: i === 0,
                $wrpMini: this._$wrpMiniPills
            }));
    }

    async _render_pRenderModal() {
        this._isModalRendered = true;

        this._modalMeta = await UiUtil.pGetShowModal({
            isHeight100: true,
            isWidth100: true,
            isUncappedHeight: true,
            isIndestructible: true,
            isClosed: true,
            isEmpty: true,
            title: "Filter",
            cbClose: (isDataEntered)=>this._pHandleHide(!isDataEntered),
        });

        const $children = this._filters.map((f,i)=>f.$render({
            filterBox: this,
            isFirst: i === 0,
            $wrpMini: this._$wrpMiniPills
        }));

        this._metaIptSearch = ComponentUiUtil.$getIptStr(this._compSearch, "search", {
            decorationRight: "clear",
            asMeta: true,
            html: `<input class="form-control input-xs" placeholder="Search...">`
        }, );
        this._compSearch._addHookBase("search", ()=>{
            const searchTerm = this._compSearch._state.search.toLowerCase();
            this._filters.forEach(f=>f.handleSearch(searchTerm));
        }
        );

        const $btnShowAllFilters = $(`<button class="btn btn-xs btn-default">Show All</button>`).click(()=>this.showAllFilters());
        const $btnHideAllFilters = $(`<button class="btn btn-xs btn-default">Hide All</button>`).click(()=>this.hideAllFilters());

        const $btnReset = $(`<button class="btn btn-xs btn-default mr-3" title="${FilterBox$1.TITLE_BTN_RESET}">Reset</button>`).click(evt=>this.reset(evt.shiftKey));

        const $btnSettings = $(`<button class="btn btn-xs btn-default mr-3"><span class="glyphicon glyphicon-cog"></span></button>`).click(()=>this._pOpenSettingsModal());

        const $btnSaveAlt = $(`<button class="btn btn-xs btn-primary" title="Save"><span class="glyphicon glyphicon-ok"></span></button>`).click(()=>this._modalMeta.doClose(true));

        const $wrpBtnCombineFilters = $(`<div class="btn-group mr-3"></div>`);
        const $btnCombineFilterSettings = $(`<button class="btn btn-xs btn-default"><span class="glyphicon glyphicon-cog"></span></button>`).click(()=>this._pOpenCombineAsModal());

        const btnCombineFiltersAs = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default`,
            click: ()=>this._meta.modeCombineFilters = FilterBox$1._COMBINE_MODES.getNext(this._meta.modeCombineFilters),
            title: `"AND" requires every filter to match. "OR" requires any filter to match. "Custom" allows you to specify a combination (every "AND" filter must match; only one "OR" filter must match) .`,
        }).appendTo($wrpBtnCombineFilters[0]);

        const hook = ()=>{
            btnCombineFiltersAs.innerText = this._meta.modeCombineFilters === "custom" ? this._meta.modeCombineFilters.uppercaseFirst() : this._meta.modeCombineFilters.toUpperCase();
            if (this._meta.modeCombineFilters === "custom")
                $wrpBtnCombineFilters.append($btnCombineFilterSettings);
            else
                $btnCombineFilterSettings.detach();
            this._doSaveStateThrottled();
        }
        ;
        this._addHook("meta", "modeCombineFilters", hook);
        hook();

        const $btnSave = $(`<button class="btn btn-primary fltr__btn-close mr-2">Save</button>`).click(()=>this._modalMeta.doClose(true));

        const $btnCancel = $(`<button class="btn btn-default fltr__btn-close">Cancel</button>`).click(()=>this._modalMeta.doClose(false));

        $$(this._modalMeta.$modal)`<div class="split mb-2 mt-2 ve-flex-v-center mobile__ve-flex-col">
			<div class="ve-flex-v-baseline mobile__ve-flex-col">
				<h4 class="m-0 mr-2 mobile__mb-2">Filters</h4>
				${this._metaIptSearch.$wrp.addClass("mobile__mb-2")}
			</div>
			<div class="ve-flex-v-center mobile__ve-flex-col">
				<div class="ve-flex-v-center mobile__m-1">
					<div class="mr-2">Combine as</div>
					${$wrpBtnCombineFilters}
				</div>
				<div class="ve-flex-v-center mobile__m-1">
					<div class="btn-group mr-2 ve-flex-h-center">
						${$btnShowAllFilters}
						${$btnHideAllFilters}
					</div>
					${$btnReset}
					${$btnSettings}
					${$btnSaveAlt}
				</div>
			</div>
		</div>
		<hr class="w-100 m-0 mb-2">

		<hr class="mt-1 mb-1">
		<div class="ui-modal__scroller smooth-scroll px-1">
			${$children}
		</div>
		<hr class="my-1 w-100">
		<div class="w-100 ve-flex-vh-center my-1">${$btnSave}${$btnCancel}</div>`;
    }

    async _pOpenSettingsModal() {
        const {$modalInner} = await UiUtil.pGetShowModal({
            title: "Settings"
        });

        UiUtil.$getAddModalRowCb($modalInner, "Deselect Homebrew Sources by Default", this._meta, "isBrewDefaultHidden");

        UiUtil.addModalSep($modalInner);

        UiUtil.$getAddModalRowHeader($modalInner, "Hide summary for filter...", {
            helpText: "The summary is the small red and blue button panel which appear below the search bar."
        });
        this._filters.forEach(f=>UiUtil.$getAddModalRowCb($modalInner, f.header, this._minisHidden, f.header));

        UiUtil.addModalSep($modalInner);

        const $rowResetAlwaysSave = UiUtil.$getAddModalRow($modalInner, "div").addClass("pr-2");
        $rowResetAlwaysSave.append(`<span>Always Save on Close</span>`);
        $(`<button class="btn btn-xs btn-default">Reset</button>`).appendTo($rowResetAlwaysSave).click(async()=>{
            await StorageUtil.pRemove(FilterBox$1._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED);
            JqueryUtil.doToast("Saved!");
        }
        );
    }

    async _pOpenCombineAsModal() {
        const {$modalInner} = await UiUtil.pGetShowModal({
            title: "Filter Combination Logic"
        });
        const $btnReset = $(`<button class="btn btn-xs btn-default">Reset</button>`).click(()=>{
            Object.keys(this._combineAs).forEach(k=>this._combineAs[k] = "and");
            $sels.forEach($sel=>$sel.val("0"));
        }
        );
        UiUtil.$getAddModalRowHeader($modalInner, "Combine filters as...", {
            $eleRhs: $btnReset
        });
        const $sels = this._filters.map(f=>UiUtil.$getAddModalRowSel($modalInner, f.header, this._combineAs, f.header, ["and", "or"], {
            fnDisplay: (it)=>it.toUpperCase()
        }));
    }

    getValues({nxtStateOuter=null}={}) {
        const outObj = {};
        this._filters.forEach(f=>Object.assign(outObj, f.getValues({
            nxtState: nxtStateOuter?.filters
        })));
        return outObj;
    }

    addEventListener(type, listener) {
        (this._$wrpFormTop ? this._$wrpFormTop[0] : this._$btnOpen[0]).addEventListener(type, listener);
    }

    _mutNextState_reset_meta({tgt}) {
        Object.assign(tgt, this._getDefaultMeta());
    }

    _mutNextState_minisHidden({tgt}) {
        Object.assign(tgt, this._getDefaultMinisHidden(tgt));
    }

    _mutNextState_combineAs({tgt}) {
        Object.assign(tgt, this._getDefaultCombineAs(tgt));
    }

    _reset_meta() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_reset_meta({
            tgt: nxtBoxState.meta
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    _reset_minisHidden() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_minisHidden({
            tgt: nxtBoxState.minisHidden
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    _reset_combineAs() {
        const nxtBoxState = this._getNextBoxState_base();
        this._mutNextState_combineAs({
            tgt: nxtBoxState.combineAs
        });
        this._setBoxStateFromNextBoxState(nxtBoxState);
    }

    reset(isResetAll) {
        this._filters.forEach(f=>f.reset({
            isResetAll
        }));
        if (isResetAll) {
            this._reset_meta();
            this._reset_minisHidden();
            this._reset_combineAs();
        }
        this.render();
        this.fireChangeEvent();
    }

    async show() {
        if (!this._isModalRendered)
            await this._render_pRenderModal();
        this._cachedState = this._getSaveableState();
        this._modalMeta.doOpen();
        if (this._metaIptSearch?.$ipt)
            this._metaIptSearch.$ipt.focus();
    }

    async _pHandleHide(isCancel=false) {
        if (this._cachedState && isCancel) {
            const curState = this._getSaveableState();
            const hasChanges = !CollectionUtil.deepEquals(curState, this._cachedState);

            if (hasChanges) {
                const isSave = await InputUiUtil.pGetUserBoolean({
                    title: "Unsaved Changes",
                    textYesRemember: "Always Save",
                    textYes: "Save",
                    textNo: "Discard",
                    storageKey: FilterBox$1._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED,
                    isGlobal: true,
                });
                if (isSave) {
                    this._cachedState = null;
                    this.fireChangeEvent();
                    return;
                } else
                    this._setStateFromLoaded(this._cachedState, {
                        isUserSavedState: true
                    });
            }
        } else {
            this.fireChangeEvent();
        }

        this._cachedState = null;
    }

    showAllFilters() {
        this._filters.forEach(f=>f.show());
    }

    hideAllFilters() {
        this._filters.forEach(f=>f.hide());
    }

    unpackSubHashes(subHashes, {force=false}={}) {
        const unpacked = {};
        subHashes.forEach(s=>{
            const unpackedPart = UrlUtil.unpackSubHash(s, true);
            if (Object.keys(unpackedPart).length > 1)
                throw new Error(`Multiple keys in subhash!`);
            const k = Object.keys(unpackedPart)[0];
            unpackedPart[k] = {
                clean: unpackedPart[k],
                raw: s
            };
            Object.assign(unpacked, unpackedPart);
        }
        );

        const urlHeaderToFilter = {};
        this._filters.forEach(f=>{
            const childFilters = f.getChildFilters();
            if (childFilters.length)
                childFilters.forEach(f=>urlHeaderToFilter[f.header.toLowerCase()] = f);
            urlHeaderToFilter[f.header.toLowerCase()] = f;
        }
        );

        const urlHeadersUpdated = new Set();
        const subHashesConsumed = new Set();
        let filterInitialSearch;

        const filterBoxState = {};
        const statePerFilter = {};
        const prefixLen = this.getNamespacedHashKey().length;
        Object.entries(unpacked).forEach(([hashKey,data])=>{
            const rawPrefix = hashKey.substring(0, prefixLen);
            const prefix = rawPrefix.substring(0, FilterUtil.SUB_HASH_PREFIX_LENGTH);

            const urlHeader = hashKey.substring(prefixLen);

            if (FilterUtil.SUB_HASH_PREFIXES.has(prefix) && urlHeaderToFilter[urlHeader]) {
                (statePerFilter[urlHeader] = statePerFilter[urlHeader] || {})[prefix] = data.clean;
                urlHeadersUpdated.add(urlHeader);
                subHashesConsumed.add(data.raw);
                return;
            }

            if (Object.values(FilterBox$1._SUB_HASH_PREFIXES).includes(prefix)) {
                if (prefix === VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX)
                    filterInitialSearch = data.clean[0];
                else
                    filterBoxState[prefix] = data.clean;
                subHashesConsumed.add(data.raw);
                return;
            }

            if (FilterUtil.SUB_HASH_PREFIXES.has(prefix))
                throw new Error(`Could not find filter with header ${urlHeader} for subhash ${data.raw}`);
        }
        );

        if (!subHashesConsumed.size && !force)
            return null;

        return {
            urlHeaderToFilter,
            filterBoxState,
            statePerFilter,
            urlHeadersUpdated,
            unpacked,
            subHashesConsumed,
            filterInitialSearch,
        };
    }

    setFromSubHashes(subHashes, {force=false, $iptSearch=null}={}) {
        const unpackedSubhashes = this.unpackSubHashes(subHashes, {
            force
        });

        if (unpackedSubhashes == null)
            return subHashes;

        const {unpacked, subHashesConsumed, filterInitialSearch, } = unpackedSubhashes;

        const {box: nxtStateBox, filters: nxtStatesFilters} = this.getNextStateFromSubHashes({
            unpackedSubhashes
        });

        this._setBoxStateFromNextBoxState(nxtStateBox);

        this._filters.flatMap(f=>[f, ...f.getChildFilters(), ]).filter(filter=>nxtStatesFilters[filter.header]).forEach(filter=>filter.setStateFromNextState(nxtStatesFilters));

        if (filterInitialSearch && ($iptSearch || this._$iptSearch))
            ($iptSearch || this._$iptSearch).val(filterInitialSearch).change().keydown().keyup().trigger("instantKeyup");

        const [link] = Hist.getHashParts();

        const outSub = [];
        Object.values(unpacked).filter(v=>!subHashesConsumed.has(v.raw)).forEach(v=>outSub.push(v.raw));

        Hist.setSuppressHistory(true);
        Hist.replaceHistoryHash(`${link}${outSub.length ? `${HASH_PART_SEP}${outSub.join(HASH_PART_SEP)}` : ""}`);

        this.fireChangeEvent();
        Hist.hashChange({
            isBlankFilterLoad: true
        });
        return outSub;
    }

    getNextStateFromSubHashes({unpackedSubhashes}) {
        const {urlHeaderToFilter, filterBoxState, statePerFilter, urlHeadersUpdated, } = unpackedSubhashes;

        const nxtStateBox = this._getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState);

        const nxtStateFilters = {};

        Object.entries(statePerFilter).forEach(([urlHeader,state])=>{
            const filter = urlHeaderToFilter[urlHeader];
            Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(state));
        }
        );

        Object.keys(urlHeaderToFilter).filter(k=>!urlHeadersUpdated.has(k)).forEach(k=>{
            const filter = urlHeaderToFilter[k];
            Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(null));
        }
        );

        return {
            box: nxtStateBox,
            filters: nxtStateFilters
        };
    }

    _getNextBoxState_base() {
        return {
            meta: MiscUtil.copyFast(this.__meta),
            minisHidden: MiscUtil.copyFast(this.__minisHidden),
            combineAs: MiscUtil.copyFast(this.__combineAs),
        };
    }

    _getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState) {
        const nxtBoxState = this._getNextBoxState_base();

        let hasMeta = false;
        let hasMinisHidden = false;
        let hasCombineAs = false;

        Object.entries(filterBoxState).forEach(([k,vals])=>{
            const mappedK = this.getNamespacedHashKey(Parser._parse_bToA(FilterBox$1._SUB_HASH_PREFIXES, k));
            switch (mappedK) {
            case "meta":
                {
                    hasMeta = true;
                    const data = vals.map(v=>UrlUtil.mini.decompress(v));
                    Object.keys(this._getDefaultMeta()).forEach((k,i)=>nxtBoxState.meta[k] = data[i]);
                    break;
                }
            case "minisHidden":
                {
                    hasMinisHidden = true;
                    Object.keys(nxtBoxState.minisHidden).forEach(k=>nxtBoxState.minisHidden[k] = false);
                    vals.forEach(v=>{
                        const [urlHeader,isHidden] = v.split("=");
                        const filter = urlHeaderToFilter[urlHeader];
                        if (!filter)
                            throw new Error(`Could not find filter with name "${urlHeader}"`);
                        nxtBoxState.minisHidden[filter.header] = !!Number(isHidden);
                    }
                    );
                    break;
                }
            case "combineAs":
                {
                    hasCombineAs = true;
                    Object.keys(nxtBoxState.combineAs).forEach(k=>nxtBoxState.combineAs[k] = "and");
                    vals.forEach(v=>{
                        const [urlHeader,ixCombineMode] = v.split("=");
                        const filter = urlHeaderToFilter[urlHeader];
                        if (!filter)
                            throw new Error(`Could not find filter with name "${urlHeader}"`);
                        nxtBoxState.combineAs[filter.header] = FilterBox$1._COMBINE_MODES[ixCombineMode] || FilterBox$1._COMBINE_MODES[0];
                    }
                    );
                    break;
                }
            }
        }
        );

        if (!hasMeta)
            this._mutNextState_reset_meta({
                tgt: nxtBoxState.meta
            });
        if (!hasMinisHidden)
            this._mutNextState_minisHidden({
                tgt: nxtBoxState.minisHidden
            });
        if (!hasCombineAs)
            this._mutNextState_combineAs({
                tgt: nxtBoxState.combineAs
            });

        return nxtBoxState;
    }

    _setBoxStateFromNextBoxState(nxtBoxState) {
        this._proxyAssignSimple("meta", nxtBoxState.meta, true);
        this._proxyAssignSimple("minisHidden", nxtBoxState.minisHidden, true);
        this._proxyAssignSimple("combineAs", nxtBoxState.combineAs, true);
    }

    getSubHashes(opts) {
        opts = opts || {};
        const out = [];
        const boxSubHashes = this.getBoxSubHashes();
        if (boxSubHashes)
            out.push(boxSubHashes);
        out.push(...this._filters.map(f=>f.getSubHashes()).filter(Boolean));
        if (opts.isAddSearchTerm && this._$iptSearch) {
            const searchTerm = UrlUtil.encodeForHash(this._$iptSearch.val().trim());
            if (searchTerm)
                out.push(UrlUtil.packSubHash(this._getSubhashPrefix("search"), [searchTerm]));
        }
        return out.flat();
    }

    getBoxSubHashes() {
        const out = [];

        const defaultMeta = this._getDefaultMeta();

        const anyNotDefault = Object.keys(defaultMeta).find(k=>this._meta[k] !== defaultMeta[k]);
        if (anyNotDefault) {
            const serMeta = Object.keys(defaultMeta).map(k=>UrlUtil.mini.compress(this._meta[k] === undefined ? defaultMeta[k] : this._meta[k]));
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("meta"), serMeta));
        }

        const setMinisHidden = Object.entries(this._minisHidden).filter(([k,v])=>!!v).map(([k])=>`${k.toUrlified()}=1`);
        if (setMinisHidden.length) {
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("minisHidden"), setMinisHidden));
        }

        const setCombineAs = Object.entries(this._combineAs).filter(([k,v])=>v !== FilterBox$1._COMBINE_MODES[0]).map(([k,v])=>`${k.toUrlified()}=${FilterBox$1._COMBINE_MODES.indexOf(v)}`);
        if (setCombineAs.length) {
            out.push(UrlUtil.packSubHash(this._getSubhashPrefix("combineAs"), setCombineAs));
        }

        return out.length ? out : null;
    }

    getFilterTag({isAddSearchTerm=false}={}) {
        const parts = this._filters.map(f=>f.getFilterTagPart()).filter(Boolean);
        if (isAddSearchTerm && this._$iptSearch) {
            const term = this._$iptSearch.val().trim();
            if (term)
                parts.push(`search=${term}`);
        }
        return `{@filter |${UrlUtil.getCurrentPage().replace(/\.html$/, "")}|${parts.join("|")}}`;
    }

    getDisplayState({nxtStateOuter=null}={}) {
        return this._filters.map(filter=>filter.getDisplayStatePart({
            nxtState: nxtStateOuter?.filters
        })).filter(Boolean).join("; ");
    }

    setFromValues(values) {
        this._filters.forEach(it=>it.setFromValues(values));
        this.fireChangeEvent();
    }

    toDisplay(boxState, ...entryVals) {
        return this._toDisplay(boxState, this._filters, entryVals);
    }

    toDisplayByFilters(boxState, ...filterToValueTuples) {
        return this._toDisplay(boxState, filterToValueTuples.map(it=>it.filter), filterToValueTuples.map(it=>it.value), );
    }

    _toDisplay(boxState, filters, entryVals) {
        switch (this._meta.modeCombineFilters) {
        case "and":
            return this._toDisplay_isAndDisplay(boxState, filters, entryVals);
        case "or":
            return this._toDisplay_isOrDisplay(boxState, filters, entryVals);
        case "custom":
            {
                if (entryVals.length !== filters.length)
                    throw new Error(`Number of filters and number of values did not match!`);

                const andFilters = [];
                const andValues = [];
                const orFilters = [];
                const orValues = [];

                for (let i = 0; i < filters.length; ++i) {
                    const f = filters[i];
                    if (!this._combineAs[f.header] || this._combineAs[f.header] === "and") {
                        andFilters.push(f);
                        andValues.push(entryVals[i]);
                    } else {
                        orFilters.push(f);
                        orValues.push(entryVals[i]);
                    }
                }

                return this._toDisplay_isAndDisplay(boxState, andFilters, andValues) && this._toDisplay_isOrDisplay(boxState, orFilters, orValues);
            }
        default:
            throw new Error(`Unhandled combining mode "${this._meta.modeCombineFilters}"`);
        }
    }

    _toDisplay_isAndDisplay(boxState, filters, vals) {
        return filters.map((f,i)=>f.toDisplay(boxState, vals[i])).every(it=>it);
    }

    _toDisplay_isOrDisplay(boxState, filters, vals) {
        const res = filters.map((f,i)=>{
            if (!f.isActive(boxState))
                return null;
            return f.toDisplay(boxState, vals[i]);
        }
        ).filter(it=>it != null);
        return res.length === 0 || res.find(it=>it);
    }

    _getSubhashPrefix(prop) {
        if (FilterBox$1._SUB_HASH_PREFIXES[prop])
            return this.getNamespacedHashKey(FilterBox$1._SUB_HASH_PREFIXES[prop]);
        throw new Error(`Unknown property "${prop}"`);
    }

    _getDefaultMeta() {
        const out = MiscUtil.copy(FilterBox$1._DEFAULT_META);
        if (this._isCompact)
            out.isSummaryHidden = true;
        return out;
    }

    _getDefaultMinisHidden(minisHidden) {
        if (!minisHidden)
            throw new Error(`Missing "minisHidden" argument!`);
        return Object.keys(minisHidden).mergeMap(k=>({
            [k]: false
        }));
    }

    _getDefaultCombineAs(combineAs) {
        if (!combineAs)
            throw new Error(`Missing "combineAs" argument!`);
        return Object.keys(combineAs).mergeMap(k=>({
            [k]: "and"
        }));
    }
}
;
FilterBox$1.EVNT_VALCHANGE = "valchange";
FilterBox$1.SOURCE_HEADER = "Source";
FilterBox$1._PILL_STATES = ["ignore", "yes", "no"];
FilterBox$1._COMBINE_MODES = ["and", "or", "custom"];
FilterBox$1._STORAGE_KEY = "filterBoxState";
FilterBox$1._DEFAULT_META = {
    modeCombineFilters: "and",
    isSummaryHidden: false,
    isBrewDefaultHidden: false,
};
FilterBox$1._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED = "filterAlwaysSaveUnchanged";

FilterBox$1._SUB_HASH_BOX_META_PREFIX = "fbmt";
FilterBox$1._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX = "fbmh";
FilterBox$1._SUB_HASH_BOX_COMBINE_AS_PREFIX = "fbca";
FilterBox$1._SUB_HASH_PREFIXES = {
    meta: FilterBox$1._SUB_HASH_BOX_META_PREFIX,
    minisHidden: FilterBox$1._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX,
    combineAs: FilterBox$1._SUB_HASH_BOX_COMBINE_AS_PREFIX,
    search: VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX,
};
let FilterItem$1 = class FilterItem {
    constructor(options) {
        this.item = options.item;
        this.pFnChange = options.pFnChange;
        this.group = options.group;
        this.nest = options.nest;
        this.nestHidden = options.nestHidden;
        this.isIgnoreRed = options.isIgnoreRed;
        this.userData = options.userData;

        this.rendered = null;
        this.searchText = null;
    }
}
;

class FilterBase extends BaseComponent {
    constructor(opts) {
        super();
        this._filterBox = null;

        this.header = opts.header;
        this._headerHelp = opts.headerHelp;

        this.__meta = {
            ...this.getDefaultMeta()
        };
        this._meta = this._getProxy("meta", this.__meta);

        this._hasUserSavedState = false;
    }

    _getRenderedHeader() {
        return `<span ${this._headerHelp ? `title="${this._headerHelp.escapeQuotes()}" class="help-subtle"` : ""}>${this.header}</span>`;
    }

    set filterBox(it) {
        this._filterBox = it;
    }

    show() {
        this._meta.isHidden = false;
    }

    hide() {
        this._meta.isHidden = true;
    }

    getBaseSaveableState() {
        return {
            meta: {
                ...this.__meta
            }
        };
    }

    _getNextState_base() {
        return {
            [this.header]: {
                state: MiscUtil.copyFast(this.__state),
                meta: MiscUtil.copyFast(this.__meta),
            },
        };
    }

    setStateFromNextState(nxtState) {
        this._proxyAssignSimple("state", nxtState[this.header].state, true);
        this._proxyAssignSimple("meta", nxtState[this.header].meta, true);
    }

    reset({isResetAll=false}={}) {
        const nxtState = this._getNextState_base();
        this._mutNextState_reset(nxtState, {
            isResetAll
        });
        this.setStateFromNextState(nxtState);
    }

    _mutNextState_resetBase(nxtState, {isResetAll=false}={}) {
        Object.assign(nxtState[this.header].meta, MiscUtil.copy(this.getDefaultMeta()));
    }

    getMetaSubHashes() {
        const compressedMeta = this._getCompressedMeta();
        if (!compressedMeta)
            return null;
        return [UrlUtil.packSubHash(this.getSubHashPrefix("meta", this.header), compressedMeta)];
    }

    _mutNextState_meta_fromSubHashState(nxtState, subHashState) {
        const hasMeta = this._mutNextState_meta_fromSubHashState_mutGetHasMeta(nxtState, subHashState, this.getDefaultMeta());
        if (!hasMeta)
            this._mutNextState_resetBase(nxtState);
    }

    _mutNextState_meta_fromSubHashState_mutGetHasMeta(nxtState, state, defaultMeta) {
        let hasMeta = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            if (prop !== "meta")
                return;

            hasMeta = true;
            const data = vals.map(v=>UrlUtil.mini.decompress(v));
            Object.keys(defaultMeta).forEach((k,i)=>{
                if (data[i] !== undefined)
                    nxtState[this.header].meta[k] = data[i];
                else
                    nxtState[this.header].meta[k] = defaultMeta[k];
            }
            );
        }
        );

        return hasMeta;
    }

    setBaseStateFromLoaded(toLoad) {
        Object.assign(this._meta, toLoad.meta);
    }

    getSubHashPrefix(prop, header) {
        if (FilterBase._SUB_HASH_PREFIXES[prop]) {
            const prefix = this._filterBox.getNamespacedHashKey(FilterBase._SUB_HASH_PREFIXES[prop]);
            return `${prefix}${header.toUrlified()}`;
        }
        throw new Error(`Unknown property "${prop}"`);
    }

    static getProp(prefix) {
        return Parser._parse_bToA(FilterBase._SUB_HASH_PREFIXES, prefix);
    }

    _getBtnMobToggleControls(wrpControls) {
        const btnMobToggleControls = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default mobile__visible ml-auto px-3 mr-2`,
            html: `<span class="glyphicon glyphicon-option-vertical"></span>`,
            click: ()=>this._meta.isMobileHeaderHidden = !this._meta.isMobileHeaderHidden,
        });
        const hkMobHeaderHidden = ()=>{
            btnMobToggleControls.toggleClass("active", !this._meta.isMobileHeaderHidden);
            wrpControls.toggleClass("mobile__hidden", !!this._meta.isMobileHeaderHidden);
        }
        ;
        this._addHook("meta", "isMobileHeaderHidden", hkMobHeaderHidden);
        hkMobHeaderHidden();

        return btnMobToggleControls;
    }

    getChildFilters() {
        return [];
    }
    getDefaultMeta() {
        return {
            ...FilterBase._DEFAULT_META
        };
    }

    isActive(vals) {
        vals = vals || this.getValues();
        return vals[this.header]._isActive;
    }

    _getCompressedMeta({isStripUiKeys=false}={}) {
        const defaultMeta = this.getDefaultMeta();
        const isAnyNotDefault = Object.keys(defaultMeta).some(k=>this._meta[k] !== defaultMeta[k]);
        if (!isAnyNotDefault)
            return null;

        let keys = Object.keys(defaultMeta);

        if (isStripUiKeys) {
            const popCount = Object.keys(FilterBase._DEFAULT_META).length;
            if (popCount)
                keys = keys.slice(0, -popCount);
        }

        while (keys.length && defaultMeta[keys.last()] === this._meta[keys.last()])
            keys.pop();

        return keys.map(k=>UrlUtil.mini.compress(this._meta[k] === undefined ? defaultMeta[k] : this._meta[k]));
    }

    $render() {
        throw new Error(`Unimplemented!`);
    }
    $renderMinis() {
        throw new Error(`Unimplemented!`);
    }
    getValues({nxtState=null}={}) {
        throw new Error(`Unimplemented!`);
    }
    _mutNextState_reset() {
        throw new Error(`Unimplemented!`);
    }
    update() {
        throw new Error(`Unimplemented!`);
    }
    toDisplay() {
        throw new Error(`Unimplemented!`);
    }
    addItem() {
        throw new Error(`Unimplemented!`);
    }
    getSaveableState() {
        throw new Error(`Unimplemented!`);
    }
    setStateFromLoaded() {
        throw new Error(`Unimplemented!`);
    }
    getSubHashes() {
        throw new Error(`Unimplemented!`);
    }
    getNextStateFromSubhashState() {
        throw new Error(`Unimplemented!`);
    }
    setFromValues() {
        throw new Error(`Unimplemented!`);
    }
    handleSearch() {
        throw new Error(`Unimplemented`);
    }
    getFilterTagPart() {
        throw new Error(`Unimplemented`);
    }
    getDisplayStatePart({nxtState=null}={}) {
        throw new Error(`Unimplemented`);
    }
    _doTeardown() {}
    trimState_() {}
}
FilterBase._DEFAULT_META = {
    isHidden: false,
    isMobileHeaderHidden: true,
};
FilterBase._SUB_HASH_STATE_PREFIX = "flst";
FilterBase._SUB_HASH_META_PREFIX = "flmt";
FilterBase._SUB_HASH_NESTS_HIDDEN_PREFIX = "flnh";
FilterBase._SUB_HASH_OPTIONS_PREFIX = "flop";
FilterBase._SUB_HASH_PREFIXES = {
    state: FilterBase._SUB_HASH_STATE_PREFIX,
    meta: FilterBase._SUB_HASH_META_PREFIX,
    nestsHidden: FilterBase._SUB_HASH_NESTS_HIDDEN_PREFIX,
    options: FilterBase._SUB_HASH_OPTIONS_PREFIX,
};

class Filter extends FilterBase {
    static _getAsFilterItems(items) {
        return items ? items.map(it=>it instanceof FilterItem$1 ? it : new FilterItem$1({
            item: it
        })) : null;
    }

    static _validateItemNests(items, nests) {
        if (!nests)
            return;
        items = items.filter(it=>it.nest);
        const noNest = items.find(it=>!nests[it.nest]);
        if (noNest)
            throw new Error(`Filter does not have matching nest: "${noNest.item}" (call addNest first)`);
        const invalid = items.find(it=>!it.nest || !nests[it.nest]);
        if (invalid)
            throw new Error(`Invalid nest: "${invalid.item}"`);
    }

    static _validateItemNest(item, nests) {
        if (!nests || !item.nest)
            return;
        if (!nests[item.nest])
            throw new Error(`Filter does not have matching nest: "${item.item}" (call addNest first)`);
        if (!item.nest || !nests[item.nest])
            throw new Error(`Invalid nest: "${item.item}"`);
    }

    constructor(opts) {
        super(opts);
        this._items = Filter._getAsFilterItems(opts.items || []);
        this.__itemsSet = new Set(this._items.map(it=>it.item));
        this._nests = opts.nests;
        this._displayFn = opts.displayFn;
        this._displayFnMini = opts.displayFnMini;
        this._displayFnTitle = opts.displayFnTitle;
        this._selFn = opts.selFn;
        this._selFnCache = null;
        this._deselFn = opts.deselFn;
        this._itemSortFn = opts.itemSortFn === undefined ? SortUtil.ascSort : opts.itemSortFn;
        this._itemSortFnMini = opts.itemSortFnMini;
        this._groupFn = opts.groupFn;
        this._minimalUi = opts.minimalUi;
        this._umbrellaItems = Filter._getAsFilterItems(opts.umbrellaItems);
        this._umbrellaExcludes = Filter._getAsFilterItems(opts.umbrellaExcludes);
        this._isSortByDisplayItems = !!opts.isSortByDisplayItems;
        this._isReprintedFilter = !!opts.isMiscFilter && this._items.some(it=>it.item === "Reprinted");
        this._isSrdFilter = !!opts.isMiscFilter && this._items.some(it=>it.item === "SRD");
        this._isBasicRulesFilter = !!opts.isMiscFilter && this._items.some(it=>it.item === "Basic Rules");

        Filter._validateItemNests(this._items, this._nests);

        this._filterBox = null;
        this._items.forEach(it=>this._defaultItemState(it, {
            isForce: true
        }));
        this.__$wrpFilter = null;
        this.__wrpPills = null;
        this.__wrpMiniPills = null;
        this.__$wrpNestHeadInner = null;
        this._updateNestSummary = null;
        this.__nestsHidden = {};
        this._nestsHidden = this._getProxy("nestsHidden", this.__nestsHidden);
        this._isNestsDirty = false;
        this._isItemsDirty = false;
        this._pillGroupsMeta = {};
    }

    get isReprintedFilter() {
        return this._isReprintedFilter;
    }
    get isSrdFilter() {
        return this._isSrdFilter;
    }
    get isBasicRulesFilter() {
        return this._isBasicRulesFilter;
    }

    getSaveableState() {
        return {
            [this.header]: {
                ...this.getBaseSaveableState(),
                state: {
                    ...this.__state
                },
                nestsHidden: {
                    ...this.__nestsHidden
                },
            },
        };
    }

    setStateFromLoaded(filterState, {isUserSavedState=false}={}) {
        if (!filterState?.[this.header])
            return;

        const toLoad = filterState[this.header];
        this._hasUserSavedState = this._hasUserSavedState || isUserSavedState;
        this.setBaseStateFromLoaded(toLoad);
        Object.assign(this._state, toLoad.state);
        Object.assign(this._nestsHidden, toLoad.nestsHidden);
    }

    _getStateNotDefault({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        return Object.entries(state).filter(([k,v])=>{
            if (k.startsWith("_"))
                return false;
            const defState = this._getDefaultState(k);
            return defState !== v;
        }
        );
    }

    getSubHashes() {
        const out = [];

        const baseMeta = this.getMetaSubHashes();
        if (baseMeta)
            out.push(...baseMeta);

        const areNotDefaultState = this._getStateNotDefault();
        if (areNotDefaultState.length) {
            const serPillStates = areNotDefaultState.map(([k,v])=>`${k.toUrlified()}=${v}`);
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serPillStates));
        }

        const areNotDefaultNestsHidden = Object.entries(this._nestsHidden).filter(([k,v])=>this._nests[k] && !(this._nests[k].isHidden === v));
        if (areNotDefaultNestsHidden.length) {
            const nestsHidden = areNotDefaultNestsHidden.map(([k])=>`${k.toUrlified()}=1`);
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("nestsHidden", this.header), nestsHidden));
        }

        if (!out.length)
            return null;

        out.push(UrlUtil.packSubHash(this.getSubHashPrefix("options", this.header), ["extend"]));
        return out;
    }

    getFilterTagPart() {
        const areNotDefaultState = this._getStateNotDefault();
        const compressedMeta = this._getCompressedMeta({
            isStripUiKeys: true
        });

        if (!areNotDefaultState.length && !compressedMeta)
            return null;

        const pt = Object.entries(this._state).filter(([k])=>!k.startsWith("_")).filter(([,v])=>v).map(([k,v])=>`${v === 2 ? "!" : ""}${k}`).join(";").toLowerCase();

        return [this.header.toLowerCase(), pt, compressedMeta ? compressedMeta.join(HASH_SUB_LIST_SEP) : null, ].filter(it=>it != null).join("=");
    }

    getDisplayStatePart({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        const areNotDefaultState = this._getStateNotDefault({
            nxtState
        });

        if (!areNotDefaultState.length)
            return null;

        const ptState = Object.entries(state).filter(([k])=>!k.startsWith("_")).filter(([,v])=>v).map(([k,v])=>{
            const item = this._items.find(item=>`${item.item}` === k);
            if (!item)
                return null;
            return `${v === 2 ? "not " : ""}${this._displayFn ? this._displayFn(item.item, item) : item.item}`;
        }
        ).filter(Boolean).join(", ");

        if (!ptState)
            return null;

        return `${this.header}: ${ptState}`;
    }

    _getOptionsFromSubHashState(state) {
        const opts = {};
        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            switch (prop) {
            case "options":
                {
                    vals.forEach(val=>{
                        switch (val) {
                        case "extend":
                            {
                                opts.isExtendDefaultState = true;
                            }
                        }
                    }
                    );
                }
            }
        }
        );
        return new FilterTransientOptions(opts);
    }

    setStateFromNextState(nxtState) {
        super.setStateFromNextState(nxtState);
        this._proxyAssignSimple("nestsHidden", nxtState[this.header].nestsHidden, true);
    }

    getNextStateFromSubhashState(state) {
        const nxtState = this._getNextState_base();

        if (state == null) {
            this._mutNextState_reset(nxtState);
            return nxtState;
        }

        this._mutNextState_meta_fromSubHashState(nxtState, state);
        const transientOptions = this._getOptionsFromSubHashState(state);

        let hasState = false;
        let hasNestsHidden = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            switch (prop) {
            case "state":
                {
                    hasState = true;
                    if (transientOptions.isExtendDefaultState) {
                        Object.keys(nxtState[this.header].state).forEach(k=>nxtState[this.header].state[k] = this._getDefaultState(k));
                    } else {
                        Object.keys(nxtState[this.header].state).forEach(k=>nxtState[this.header].state[k] = 0);
                    }

                    vals.forEach(v=>{
                        const [statePropLower,state] = v.split("=");
                        const stateProp = Object.keys(nxtState[this.header].state).find(k=>k.toLowerCase() === statePropLower);
                        if (stateProp)
                            nxtState[this.header].state[stateProp] = Number(state);
                    }
                    );
                    break;
                }
            case "nestsHidden":
                {
                    hasNestsHidden = true;
                    Object.keys(nxtState[this.header].nestsHidden).forEach(k=>{
                        const nestKey = Object.keys(this._nests).find(it=>k.toLowerCase() === it.toLowerCase());
                        nxtState[this.header].nestsHidden[k] = this._nests[nestKey] && this._nests[nestKey].isHidden;
                    }
                    );
                    vals.forEach(v=>{
                        const [nestNameLower,state] = v.split("=");
                        const nestName = Object.keys(nxtState[this.header].nestsHidden).find(k=>k.toLowerCase() === nestNameLower);
                        if (nestName)
                            nxtState[this.header].nestsHidden[nestName] = !!Number(state);
                    }
                    );
                    break;
                }
            }
        }
        );

        if (!hasState)
            this._mutNextState_reset(nxtState);
        if (!hasNestsHidden && this._nests)
            this._mutNextState_resetNestsHidden({
                tgt: nxtState[this.header].nestsHidden
            });

        return nxtState;
    }

    setFromValues(values) {
        if (values[this.header]) {
            Object.keys(this._state).forEach(k=>this._state[k] = 0);
            Object.assign(this._state, values[this.header]);
        }
    }

    setValue(k, v) {
        this._state[k] = v;
    }

    _mutNextState_resetNestsHidden({tgt}) {
        if (!this._nests)
            return;
        Object.entries(this._nests).forEach(([nestName,nestMeta])=>tgt[nestName] = !!nestMeta.isHidden);
    }

    _defaultItemState(item, {isForce=false}={}) {
        if (!isForce && this._hasUserSavedState)
            return this._state[item.item] = 0;

        this._state[item.item] = this._getDefaultState(item.item);
    }

    _getDefaultState(k) {
        return this._deselFn && this._deselFn(k) ? 2 : this._selFn && this._selFn(k) ? 1 : 0;
    }

    _getDisplayText(item) {
        return this._displayFn ? this._displayFn(item.item, item) : item.item;
    }

    _getDisplayTextMini(item) {
        return this._displayFnMini ? this._displayFnMini(item.item, item) : this._getDisplayText(item);
    }

    _getPill(item) {
        const displayText = this._getDisplayText(item);

        const btnPill = e_({
            tag: "div",
            clazz: "fltr__pill",
            html: displayText,
            click: evt=>this._getPill_handleClick({
                evt,
                item
            }),
            contextmenu: evt=>this._getPill_handleContextmenu({
                evt,
                item
            }),
        });

        this._getPill_bindHookState({
            btnPill,
            item
        });

        item.searchText = displayText.toLowerCase();

        return btnPill;
    }

    _getPill_handleClick({evt, item}) {
        if (evt.shiftKey) {
            this._doSetPillsClear();
        }

        if (++this._state[item.item] > 2)
            this._state[item.item] = 0;
    }

    _getPill_handleContextmenu({evt, item}) {
        evt.preventDefault();

        if (evt.shiftKey) {
            this._doSetPillsClear();
        }

        if (--this._state[item.item] < 0)
            this._state[item.item] = 2;
    }

    _getPill_bindHookState({btnPill, item}) {
        this._addHook("state", item.item, ()=>{
            const val = FilterBox$1._PILL_STATES[this._state[item.item]];
            btnPill.attr("state", val);
        }
        )();
    }

    setTempFnSel(tempFnSel) {
        this._selFnCache = this._selFnCache || this._selFn;
        if (tempFnSel)
            this._selFn = tempFnSel;
        else
            this._selFn = this._selFnCache;
    }

    updateMiniPillClasses() {
        this._items.filter(it=>it.btnMini).forEach(it=>{
            const isDefaultDesel = this._deselFn && this._deselFn(it.item);
            const isDefaultSel = this._selFn && this._selFn(it.item);
            it.btnMini.toggleClass("fltr__mini-pill--default-desel", isDefaultDesel).toggleClass("fltr__mini-pill--default-sel", isDefaultSel);
        }
        );
    }

    _getBtnMini(item) {
        const toDisplay = this._getDisplayTextMini(item);

        const btnMini = e_({
            tag: "div",
            clazz: `fltr__mini-pill ${this._filterBox.isMinisHidden(this.header) ? "ve-hidden" : ""} ${this._deselFn && this._deselFn(item.item) ? "fltr__mini-pill--default-desel" : ""} ${this._selFn && this._selFn(item.item) ? "fltr__mini-pill--default-sel" : ""}`,
            html: toDisplay,
            title: `${this._displayFnTitle ? `${this._displayFnTitle(item.item, item)} (` : ""}Filter: ${this.header}${this._displayFnTitle ? ")" : ""}`,
            click: ()=>{
                this._state[item.item] = 0;
                this._filterBox.fireChangeEvent();
            }
            ,
        }).attr("state", FilterBox$1._PILL_STATES[this._state[item.item]]);

        const hook = ()=>{
            const val = FilterBox$1._PILL_STATES[this._state[item.item]];
            btnMini.attr("state", val);
            if (item.pFnChange)
                item.pFnChange(item.item, val);
        }
        ;
        this._addHook("state", item.item, hook);

        const hideHook = ()=>btnMini.toggleClass("ve-hidden", this._filterBox.isMinisHidden(this.header));
        this._filterBox.registerMinisHiddenHook(this.header, hideHook);

        return btnMini;
    }

    _doSetPillsAll() {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: 1
        })), true, );
    }

    _doSetPillsClear() {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: 0
        })), true, );
    }

    _doSetPillsNone() {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: 2
        })), true, );
    }

    _doSetPinsDefault() {
        this.reset();
    }

    _getHeaderControls(opts) {
        const btnAll = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--all w-100`,
            click: ()=>this._doSetPillsAll(),
            html: "All",
        });
        const btnClear = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--clear w-100`,
            click: ()=>this._doSetPillsClear(),
            html: "Clear",
        });
        const btnNone = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--none w-100`,
            click: ()=>this._doSetPillsNone(),
            html: "None",
        });
        const btnDefault = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} w-100`,
            click: ()=>this._doSetPinsDefault(),
            html: "Default",
        });

        const wrpStateBtnsOuter = e_({
            tag: "div",
            clazz: "ve-flex-v-center fltr__h-wrp-state-btns-outer",
            children: [e_({
                tag: "div",
                clazz: "btn-group ve-flex-v-center w-100",
                children: [btnAll, btnClear, btnNone, btnDefault, ],
            }), ],
        });
        this._getHeaderControls_addExtraStateBtns(opts, wrpStateBtnsOuter);

        const wrpSummary = e_({
            tag: "div",
            clazz: "ve-flex-vh-center ve-hidden"
        });

        const btnCombineBlue = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn-logic--blue fltr__h-btn-logic w-100`,
            click: ()=>this._meta.combineBlue = Filter._getNextCombineMode(this._meta.combineBlue),
            title: `Blue match mode for this filter. "AND" requires all blues to match, "OR" requires at least one blue to match, "XOR" requires exactly one blue to match.`,
        });
        const hookCombineBlue = ()=>e_({
            ele: btnCombineBlue,
            text: `${this._meta.combineBlue}`.toUpperCase()
        });
        this._addHook("meta", "combineBlue", hookCombineBlue);
        hookCombineBlue();

        const btnCombineRed = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn-logic--red fltr__h-btn-logic w-100`,
            click: ()=>this._meta.combineRed = Filter._getNextCombineMode(this._meta.combineRed),
            title: `Red match mode for this filter. "AND" requires all reds to match, "OR" requires at least one red to match, "XOR" requires exactly one red to match.`,
        });
        const hookCombineRed = ()=>e_({
            ele: btnCombineRed,
            text: `${this._meta.combineRed}`.toUpperCase()
        });
        this._addHook("meta", "combineRed", hookCombineRed);
        hookCombineRed();

        const btnShowHide = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} ml-2`,
            click: ()=>this._meta.isHidden = !this._meta.isHidden,
            html: "Hide",
        });
        const hookShowHide = ()=>{
            e_({
                ele: btnShowHide
            }).toggleClass("active", this._meta.isHidden);
            wrpStateBtnsOuter.toggleVe(!this._meta.isHidden);

            const cur = this.getValues()[this.header];

            const htmlSummary = [cur._totals.yes ? `<span class="fltr__summary_item fltr__summary_item--include" title="${cur._totals.yes} hidden &quot;required&quot; tags">${cur._totals.yes}</span>` : null, cur._totals.yes && cur._totals.no ? `<span class="fltr__summary_item_spacer"></span>` : null, cur._totals.no ? `<span class="fltr__summary_item fltr__summary_item--exclude" title="${cur._totals.no} hidden &quot;excluded&quot; tags">${cur._totals.no}</span>` : null, ].filter(Boolean).join("");
            e_({
                ele: wrpSummary,
                html: htmlSummary
            }).toggleVe(this._meta.isHidden);
        }
        ;
        this._addHook("meta", "isHidden", hookShowHide);
        hookShowHide();

        return e_({
            tag: "div",
            clazz: `ve-flex-v-center fltr__h-wrp-btns-outer`,
            children: [wrpSummary, wrpStateBtnsOuter, e_({
                tag: "span",
                clazz: `btn-group ml-2 ve-flex-v-center`,
                children: [btnCombineBlue, btnCombineRed]
            }), btnShowHide, ],
        });
    }

    _getHeaderControls_addExtraStateBtns() {}

    $render(opts) {
        this._filterBox = opts.filterBox;
        this.__wrpMiniPills = opts.$wrpMini ? e_({
            ele: opts.$wrpMini[0]
        }) : null;

        const wrpControls = this._getHeaderControls(opts);

        if (this._nests) {
            const wrpNestHead = e_({
                tag: "div",
                clazz: "fltr__wrp-pills--sub"
            }).appendTo(this.__wrpPills);
            this.__$wrpNestHeadInner = e_({
                tag: "div",
                clazz: "ve-flex ve-flex-wrap fltr__container-pills"
            }).appendTo(wrpNestHead);

            const wrpNestHeadSummary = e_({
                tag: "div",
                clazz: "fltr__summary_nest"
            }).appendTo(wrpNestHead);

            this._updateNestSummary = ()=>{
                const stats = {
                    high: 0,
                    low: 0
                };
                this._items.filter(it=>this._state[it.item] && this._nestsHidden[it.nest]).forEach(it=>{
                    const key = this._state[it.item] === 1 ? "high" : "low";
                    stats[key]++;
                }
                );

                wrpNestHeadSummary.empty();

                if (stats.high) {
                    e_({
                        tag: "span",
                        clazz: "fltr__summary_item fltr__summary_item--include",
                        text: stats.high,
                        title: `${stats.high} hidden "required" tag${stats.high === 1 ? "" : "s"}`,
                    }).appendTo(wrpNestHeadSummary);
                }

                if (stats.high && stats.low)
                    e_({
                        tag: "span",
                        clazz: "fltr__summary_item_spacer"
                    }).appendTo(wrpNestHeadSummary);

                if (stats.low) {
                    e_({
                        tag: "span",
                        clazz: "fltr__summary_item fltr__summary_item--exclude",
                        text: stats.low,
                        title: `${stats.low} hidden "excluded" tag${stats.low === 1 ? "" : "s"}`,
                    }).appendTo(wrpNestHeadSummary);
                }
            }
            ;

            this._doRenderNests();
        }

        this._doRenderPills();

        const btnMobToggleControls = this._getBtnMobToggleControls(wrpControls);

        this.__$wrpFilter = $$`<div>
			${opts.isFirst ? "" : `<div class="fltr__dropdown-divider ${opts.isMulti ? "fltr__dropdown-divider--indented" : ""} mb-1"></div>`}
			<div class="split fltr__h ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
				<div class="fltr__h-text ve-flex-h-center mobile__w-100">
					${opts.isMulti ? `<span class="mr-2">\u2012</span>` : ""}
					${this._getRenderedHeader()}
					${btnMobToggleControls}
				</div>
				${wrpControls}
			</div>
			${this.__wrpPills}
		</div>`;

        this._doToggleDisplay();

        return this.__$wrpFilter;
    }

    $renderMinis(opts) {
        if (!opts.$wrpMini)
            return;

        this._filterBox = opts.filterBox;
        this.__wrpMiniPills = e_({
            ele: opts.$wrpMini[0]
        });

        this._renderMinis_initWrpPills();

        this._doRenderMiniPills();
    }

    _renderMinis_initWrpPills() {
        this.__wrpPills = e_({
            tag: "div",
            clazz: `fltr__wrp-pills ${this._groupFn ? "fltr__wrp-subs" : "fltr__container-pills"}`
        });
        const hook = ()=>this.__wrpPills.toggleVe(!this._meta.isHidden);
        this._addHook("meta", "isHidden", hook);
        hook();
    }

    getValues({nxtState=null}={}) {
        const state = MiscUtil.copy(nxtState?.[this.header]?.state || this.__state);
        const meta = nxtState?.[this.header]?.meta || this.__meta;

        Object.keys(state).filter(k=>!this._items.some(it=>`${it.item}` === k)).forEach(k=>delete state[k]);
        const out = {
            ...state
        };

        out._isActive = Object.values(state).some(Boolean);
        out._totals = {
            yes: 0,
            no: 0,
            ignored: 0
        };
        Object.values(state).forEach(v=>{
            const totalKey = v === 0 ? "ignored" : v === 1 ? "yes" : "no";
            out._totals[totalKey]++;
        }
        );
        out._combineBlue = meta.combineBlue;
        out._combineRed = meta.combineRed;
        return {
            [this.header]: out
        };
    }

    _getNextState_base() {
        return {
            [this.header]: {
                ...super._getNextState_base()[this.header],
                nestsHidden: MiscUtil.copyFast(this.__nestsHidden),
            },
        };
    }

    _mutNextState_reset(nxtState, {isResetAll=false}={}) {
        if (isResetAll) {
            this._mutNextState_resetBase(nxtState);
            this._mutNextState_resetNestsHidden({
                tgt: nxtState[this.header].nestsHidden
            });
        } else {
            Object.assign(nxtState[this.header].meta, {
                combineBlue: Filter._DEFAULT_META.combineBlue,
                combineRed: Filter._DEFAULT_META.combineRed
            });
        }
        Object.keys(nxtState[this.header].state).forEach(k=>delete nxtState[this.header].state[k]);
        this._items.forEach(item=>nxtState[this.header].state[item.item] = this._getDefaultState(item.item));
    }

    _doRenderPills() {
        if (this._itemSortFn)
            this._items.sort(this._isSortByDisplayItems && this._displayFn ? (a,b)=>this._itemSortFn(this._displayFn(a.item, a), this._displayFn(b.item, b)) : this._itemSortFn);

        this._items.forEach(it=>{
            if (!it.rendered) {
                it.rendered = this._getPill(it);
                if (it.nest) {
                    const hook = ()=>it.rendered.toggleVe(!this._nestsHidden[it.nest]);
                    this._addHook("nestsHidden", it.nest, hook);
                    hook();
                }
            }

            if (this._groupFn) {
                const group = this._groupFn(it);
                this._doRenderPills_doRenderWrpGroup(group);
                this._pillGroupsMeta[group].wrpPills.append(it.rendered);
            } else
                it.rendered.appendTo(this.__wrpPills);
        }
        );
    }

    _doRenderPills_doRenderWrpGroup(group) {
        const existingMeta = this._pillGroupsMeta[group];
        if (existingMeta && !existingMeta.isAttached) {
            existingMeta.hrDivider.appendTo(this.__wrpPills);
            existingMeta.wrpPills.appendTo(this.__wrpPills);
            existingMeta.isAttached = true;
        }
        if (existingMeta)
            return;

        this._pillGroupsMeta[group] = {
            hrDivider: this._doRenderPills_doRenderWrpGroup_getHrDivider(group).appendTo(this.__wrpPills),
            wrpPills: this._doRenderPills_doRenderWrpGroup_getWrpPillsSub(group).appendTo(this.__wrpPills),
            isAttached: true,
        };

        Object.entries(this._pillGroupsMeta).sort((a,b)=>SortUtil.ascSortLower(a[0], b[0])).forEach(([groupKey,groupMeta],i)=>{
            groupMeta.hrDivider.appendTo(this.__wrpPills);
            groupMeta.hrDivider.toggleVe(!this._isGroupDividerHidden(groupKey, i));
            groupMeta.wrpPills.appendTo(this.__wrpPills);
        }
        );

        if (this._nests) {
            this._pillGroupsMeta[group].toggleDividerFromNestVisibility = ()=>{
                this._pillGroupsMeta[group].hrDivider.toggleVe(!this._isGroupDividerHidden(group));
            }
            ;

            Object.keys(this._nests).forEach(nestName=>{
                const hook = ()=>this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
                this._addHook("nestsHidden", nestName, hook);
                hook();
                this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
            }
            );
        }
    }

    _isGroupDividerHidden(group, ixSortedGroups) {
        if (!this._nests) {
            if (ixSortedGroups === undefined)
                return `${group}` === `${Object.keys(this._pillGroupsMeta).sort((a,b)=>SortUtil.ascSortLower(a, b))[0]}`;
            return ixSortedGroups === 0;
        }

        const groupItems = this._items.filter(it=>this._groupFn(it) === group);
        const hiddenGroupItems = groupItems.filter(it=>this._nestsHidden[it.nest]);
        return groupItems.length === hiddenGroupItems.length;
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider() {
        return e_({
            tag: "hr",
            clazz: `fltr__dropdown-divider--sub hr-2 mx-3`
        });
    }
    _doRenderPills_doRenderWrpGroup_getWrpPillsSub() {
        return e_({
            tag: "div",
            clazz: `fltr__wrp-pills--sub fltr__container-pills`
        });
    }

    _doRenderMiniPills() {
        const view = this._items.slice(0);
        if (this._itemSortFnMini || this._itemSortFn) {
            const fnSort = this._itemSortFnMini || this._itemSortFn;
            view.sort(this._isSortByDisplayItems && this._displayFn ? (a,b)=>fnSort(this._displayFn(a.item, a), this._displayFn(b.item, b)) : fnSort);
        }

        if (this.__wrpMiniPills) {
            view.forEach(it=>{
                (it.btnMini = it.btnMini || this._getBtnMini(it)).appendTo(this.__wrpMiniPills);
            }
            );
        }
    }

    _doToggleDisplay() {
        if (this.__$wrpFilter)
            this.__$wrpFilter.toggleClass("fltr__no-items", !this._items.length);
    }

    _doRenderNests() {
        Object.entries(this._nests).sort((a,b)=>SortUtil.ascSort(a[0], b[0])).forEach(([nestName,nestMeta])=>{
            if (nestMeta._$btnNest == null) {
                if (this._nestsHidden[nestName] == null)
                    this._nestsHidden[nestName] = !!nestMeta.isHidden;

                const $btnText = $(`<span>${nestName} [${this._nestsHidden[nestName] ? "+" : "\u2212"}]</span>`);
                nestMeta._$btnNest = $$`<div class="fltr__btn_nest">${$btnText}</div>`.click(()=>this._nestsHidden[nestName] = !this._nestsHidden[nestName]);

                const hook = ()=>{
                    $btnText.text(`${nestName} [${this._nestsHidden[nestName] ? "+" : "\u2212"}]`);

                    const stats = {
                        high: 0,
                        low: 0,
                        total: 0
                    };
                    this._items.filter(it=>it.nest === nestName).find(it=>{
                        const key = this._state[it.item] === 1 ? "high" : this._state[it.item] ? "low" : "ignored";
                        stats[key]++;
                        stats.total++;
                    }
                    );
                    const allHigh = stats.total === stats.high;
                    const allLow = stats.total === stats.low;
                    nestMeta._$btnNest.toggleClass("fltr__btn_nest--include-all", this._nestsHidden[nestName] && allHigh).toggleClass("fltr__btn_nest--exclude-all", this._nestsHidden[nestName] && allLow).toggleClass("fltr__btn_nest--include", this._nestsHidden[nestName] && !!(!allHigh && !allLow && stats.high && !stats.low)).toggleClass("fltr__btn_nest--exclude", this._nestsHidden[nestName] && !!(!allHigh && !allLow && !stats.high && stats.low)).toggleClass("fltr__btn_nest--both", this._nestsHidden[nestName] && !!(!allHigh && !allLow && stats.high && stats.low));

                    if (this._updateNestSummary)
                        this._updateNestSummary();
                }
                ;

                this._items.filter(it=>it.nest === nestName).find(it=>{
                    this._addHook("state", it.item, hook);
                }
                );

                this._addHook("nestsHidden", nestName, hook);
                hook();
            }
            nestMeta._$btnNest.appendTo(this.__$wrpNestHeadInner);
        }
        );

        if (this._updateNestSummary)
            this._updateNestSummary();
    }

    update() {
        if (this._isNestsDirty) {
            this._isNestsDirty = false;

            this._doRenderNests();
        }

        if (this._isItemsDirty) {
            this._isItemsDirty = false;

            this._doRenderPills();
        }

        this._doRenderMiniPills();
        this._doToggleDisplay();
    }

    addItem(item) {
        if (item == null)
            return;

        if (item instanceof Array) {
            const len = item.length;
            for (let i = 0; i < len; ++i)
                this.addItem(item[i]);
            return;
        }

        if (!this.__itemsSet.has(item.item || item)) {
            item = item instanceof FilterItem$1 ? item : new FilterItem$1({
                item
            });
            Filter._validateItemNest(item, this._nests);

            this._isItemsDirty = true;
            this._items.push(item);
            this.__itemsSet.add(item.item);
            if (this._state[item.item] == null)
                this._defaultItemState(item);
        }
    }

    static _isItemsEqual(item1, item2) {
        return (item1 instanceof FilterItem$1 ? item1.item : item1) === (item2 instanceof FilterItem$1 ? item2.item : item2);
    }

    removeItem(item) {
        const ixItem = this._items.findIndex(it=>Filter._isItemsEqual(it, item));
        if (~ixItem) {
            const item = this._items[ixItem];

            this._isItemsDirty = true;
            item.rendered.detach();
            item.btnMini.detach();
            this._items.splice(ixItem, 1);
        }
    }

    addNest(nestName, nestMeta) {
        if (!this._nests)
            throw new Error(`Filter was not nested!`);
        if (!this._nests[nestName]) {
            this._isNestsDirty = true;
            this._nests[nestName] = nestMeta;

            if (this._groupFn) {
                Object.keys(this._pillGroupsMeta).forEach(group=>{
                    const hook = ()=>this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
                    this._addHook("nestsHidden", nestName, hook);
                    hook();
                    this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
                }
                );
            }
        }
    }

    _toDisplay_getMappedEntryVal(entryVal) {
        if (!(entryVal instanceof Array))
            entryVal = [entryVal];
        entryVal = entryVal.map(it=>it instanceof FilterItem$1 ? it : new FilterItem$1({
            item: it
        }));
        return entryVal;
    }

    _toDisplay_getFilterState(boxState) {
        return boxState[this.header];
    }

    toDisplay(boxState, entryVal) {
        const filterState = this._toDisplay_getFilterState(boxState);
        if (!filterState)
            return true;

        const totals = filterState._totals;

        entryVal = this._toDisplay_getMappedEntryVal(entryVal);

        const isUmbrella = ()=>{
            if (this._umbrellaItems) {
                if (!entryVal)
                    return false;

                if (this._umbrellaExcludes && this._umbrellaExcludes.some(it=>filterState[it.item]))
                    return false;

                return this._umbrellaItems.some(u=>entryVal.includes(u.item)) && (this._umbrellaItems.some(u=>filterState[u.item] === 0) || this._umbrellaItems.some(u=>filterState[u.item] === 1));
            }
        }
        ;

        let hide = false;
        let display = false;

        switch (filterState._combineBlue) {
        case "or":
            {
                if (totals.yes === 0)
                    display = true;

                display = display || entryVal.some(fi=>filterState[fi.item] === 1 || isUmbrella());

                break;
            }
        case "xor":
            {
                if (totals.yes === 0)
                    display = true;

                display = display || entryVal.filter(fi=>filterState[fi.item] === 1 || isUmbrella()).length === 1;

                break;
            }
        case "and":
            {
                const totalYes = entryVal.filter(fi=>filterState[fi.item] === 1).length;
                display = !totals.yes || totals.yes === totalYes;

                break;
            }
        default:
            throw new Error(`Unhandled combine mode "${filterState._combineBlue}"`);
        }

        switch (filterState._combineRed) {
        case "or":
            {
                hide = hide || entryVal.filter(fi=>!fi.isIgnoreRed).some(fi=>filterState[fi.item] === 2);

                break;
            }
        case "xor":
            {
                hide = hide || entryVal.filter(fi=>!fi.isIgnoreRed).filter(fi=>filterState[fi.item] === 2).length === 1;

                break;
            }
        case "and":
            {
                const totalNo = entryVal.filter(fi=>!fi.isIgnoreRed).filter(fi=>filterState[fi.item] === 2).length;
                hide = totals.no && totals.no === totalNo;

                break;
            }
        default:
            throw new Error(`Unhandled combine mode "${filterState._combineRed}"`);
        }

        return display && !hide;
    }

    _doInvertPins() {
        const cur = MiscUtil.copy(this._state);
        Object.keys(this._state).forEach(k=>this._state[k] = cur[k] === 1 ? 0 : 1);
    }

    getDefaultMeta() {
        return {
            ...super.getDefaultMeta(),
            ...Filter._DEFAULT_META,
        };
    }

    handleSearch(searchTerm) {
        const isHeaderMatch = this.header.toLowerCase().includes(searchTerm);

        if (isHeaderMatch) {
            this._items.forEach(it=>{
                if (!it.rendered)
                    return;
                it.rendered.toggleClass("fltr__hidden--search", false);
            }
            );

            if (this.__$wrpFilter)
                this.__$wrpFilter.toggleClass("fltr__hidden--search", false);

            return true;
        }

        let visibleCount = 0;
        this._items.forEach(it=>{
            if (!it.rendered)
                return;
            const isVisible = it.searchText.includes(searchTerm);
            it.rendered.toggleClass("fltr__hidden--search", !isVisible);
            if (isVisible)
                visibleCount++;
        }
        );

        if (this.__$wrpFilter)
            this.__$wrpFilter.toggleClass("fltr__hidden--search", visibleCount === 0);

        return visibleCount !== 0;
    }

    static _getNextCombineMode(combineMode) {
        let ix = Filter._COMBINE_MODES.indexOf(combineMode);
        if (ix === -1)
            ix = (Filter._COMBINE_MODES.length - 1);
        if (++ix === Filter._COMBINE_MODES.length)
            ix = 0;
        return Filter._COMBINE_MODES[ix];
    }

    _doTeardown() {
        this._items.forEach(it=>{
            if (it.rendered)
                it.rendered.detach();
            if (it.btnMini)
                it.btnMini.detach();
        }
        );

        Object.values(this._nests || {}).filter(nestMeta=>nestMeta._$btnNest).forEach(nestMeta=>nestMeta._$btnNest.detach());

        Object.values(this._pillGroupsMeta || {}).forEach(it=>{
            it.hrDivider.detach();
            it.wrpPills.detach();
            it.isAttached = false;
        }
        );
    }
}
_DEFAULT_META = {
    combineBlue: "or",
    combineRed: "or",
};
_COMBINE_MODES = ["or", "and", "xor"];

let SourceFilter = class SourceFilter extends Filter {
    static _SORT_ITEMS_MINI(a, b) {
        a = a.item ?? a;
        b = b.item ?? b;
        const valA = BrewUtil2.hasSourceJson(a) ? 2 : (SourceUtil.isNonstandardSource(a) || PrereleaseUtil.hasSourceJson(a)) ? 1 : 0;
        const valB = BrewUtil2.hasSourceJson(b) ? 2 : (SourceUtil.isNonstandardSource(b) || PrereleaseUtil.hasSourceJson(b)) ? 1 : 0;
        return SortUtil.ascSort(valA, valB) || SortUtil.ascSortLower(Parser.sourceJsonToFull(a), Parser.sourceJsonToFull(b));
    }

    static _getDisplayHtmlMini(item) {
        item = item.item || item;
        const isBrewSource = BrewUtil2.hasSourceJson(item);
        const isNonStandardSource = !isBrewSource && (SourceUtil.isNonstandardSource(item) || PrereleaseUtil.hasSourceJson(item));
        return `<span ${isBrewSource ? `title="(Homebrew)"` : isNonStandardSource ? `title="(UA/Etc.)"` : ""} class="glyphicon ${isBrewSource ? `glyphicon-glass` : isNonStandardSource ? `glyphicon-file` : `glyphicon-book`}"></span> ${Parser.sourceJsonToAbv(item)}`;
    }

    constructor(opts) {
        opts = opts || {};

        opts.header = opts.header === undefined ? FilterBox$1.SOURCE_HEADER : opts.header;
        opts.displayFn = opts.displayFn === undefined ? item=>Parser.sourceJsonToFullCompactPrefix(item.item || item) : opts.displayFn;
        opts.displayFnMini = opts.displayFnMini === undefined ? SourceFilter._getDisplayHtmlMini.bind(SourceFilter) : opts.displayFnMini;
        opts.displayFnTitle = opts.displayFnTitle === undefined ? item=>Parser.sourceJsonToFull(item.item || item) : opts.displayFnTitle;
        opts.itemSortFnMini = opts.itemSortFnMini === undefined ? SourceFilter._SORT_ITEMS_MINI.bind(SourceFilter) : opts.itemSortFnMini;
        opts.itemSortFn = opts.itemSortFn === undefined ? (a,b)=>SortUtil.ascSortLower(Parser.sourceJsonToFull(a.item), Parser.sourceJsonToFull(b.item)) : opts.itemSortFn;
        opts.groupFn = opts.groupFn === undefined ? SourceUtil.getFilterGroup : opts.groupFn;
        opts.selFn = opts.selFn === undefined ? PageFilter.defaultSourceSelFn : opts.selFn;

        super(opts);

        this.__tmpState = {
            ixAdded: 0
        };
        this._tmpState = this._getProxy("tmpState", this.__tmpState);
    }

    doSetPillsClear() {
        return this._doSetPillsClear();
    }

    addItem(item) {
        const out = super.addItem(item);
        this._tmpState.ixAdded++;
        return out;
    }

    removeItem(item) {
        const out = super.removeItem(item);
        this._tmpState.ixAdded--;
        return out;
    }

    _getHeaderControls_addExtraStateBtns(opts, wrpStateBtnsOuter) {
        const btnSupplements = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection; CTRL to include UA/etc.`,
            html: `Core/Supplements`,
            click: evt=>this._doSetPinsSupplements({
                isIncludeUnofficial: EventUtil.isCtrlMetaKey(evt),
                isAdditive: evt.shiftKey
            }),
        });

        const btnAdventures = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection; CTRL to include UA`,
            html: `Adventures`,
            click: evt=>this._doSetPinsAdventures({
                isIncludeUnofficial: EventUtil.isCtrlMetaKey(evt),
                isAdditive: evt.shiftKey
            }),
        });

        const btnPartnered = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection`,
            html: `Partnered`,
            click: evt=>this._doSetPinsPartnered({
                isAdditive: evt.shiftKey
            }),
        });

        const btnHomebrew = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            title: `SHIFT to add to existing selection`,
            html: `Homebrew`,
            click: evt=>this._doSetPinsHomebrew({
                isAdditive: evt.shiftKey
            }),
        });

        const hkIsButtonsActive = ()=>{
            const hasPartnered = Object.keys(this.__state).some(src=>SourceUtil.getFilterGroup(src) === SourceUtil.FILTER_GROUP_PARTNERED);
            btnPartnered.toggleClass("ve-hidden", !hasPartnered);

            const hasBrew = Object.keys(this.__state).some(src=>SourceUtil.getFilterGroup(src) === SourceUtil.FILTER_GROUP_HOMEBREW);
            btnHomebrew.toggleClass("ve-hidden", !hasBrew);
        }
        ;
        this._addHook("tmpState", "ixAdded", hkIsButtonsActive);
        hkIsButtonsActive();

        const actionSelectDisplayMode = new ContextUtil.ActionSelect({
            values: Object.keys(SourceFilter._PILL_DISPLAY_MODE_LABELS).map(Number),
            fnGetDisplayValue: val=>SourceFilter._PILL_DISPLAY_MODE_LABELS[val] || SourceFilter._PILL_DISPLAY_MODE_LABELS[0],
            fnOnChange: val=>this._meta.pillDisplayMode = val,
        });
        this._addHook("meta", "pillDisplayMode", ()=>{
            actionSelectDisplayMode.setValue(this._meta.pillDisplayMode);
        }
        )();

        const menu = ContextUtil.getMenu([new ContextUtil.Action("Select All Standard Sources",()=>this._doSetPinsStandard(),), new ContextUtil.Action("Select All Partnered Sources",()=>this._doSetPinsPartnered(),), new ContextUtil.Action("Select All Non-Standard Sources",()=>this._doSetPinsNonStandard(),), new ContextUtil.Action("Select All Homebrew Sources",()=>this._doSetPinsHomebrew(),), null, new ContextUtil.Action(`Select "Vanilla" Sources`,()=>this._doSetPinsVanilla(),{
            title: `Select a baseline set of sources suitable for any campaign.`
        },), new ContextUtil.Action("Select All Non-UA Sources",()=>this._doSetPinsNonUa(),), null, new ContextUtil.Action("Select SRD Sources",()=>this._doSetPinsSrd(),{
            title: `Select System Reference Document Sources.`
        },), new ContextUtil.Action("Select Basic Rules Sources",()=>this._doSetPinsBasicRules(),), null, new ContextUtil.Action("Invert Selection",()=>this._doInvertPins(),), null, actionSelectDisplayMode, ]);
        const btnBurger = e_({
            tag: "button",
            clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            html: `<span class="glyphicon glyphicon-option-vertical"></span>`,
            click: evt=>ContextUtil.pOpenMenu(evt, menu),
            title: "Other Options",
        });

        const btnOnlyPrimary = e_({
            tag: "button",
            clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
            html: `Include References`,
            title: `Consider entities as belonging to every source they appear in (i.e. reprints) as well as their primary source`,
            click: ()=>this._meta.isIncludeOtherSources = !this._meta.isIncludeOtherSources,
        });
        const hkIsIncludeOtherSources = ()=>{
            btnOnlyPrimary.toggleClass("active", !!this._meta.isIncludeOtherSources);
        }
        ;
        hkIsIncludeOtherSources();
        this._addHook("meta", "isIncludeOtherSources", hkIsIncludeOtherSources);

        e_({
            tag: "div",
            clazz: `btn-group mr-2 w-100 ve-flex-v-center mobile__m-1 mobile__mb-2`,
            children: [btnSupplements, btnAdventures, btnPartnered, btnHomebrew, btnBurger, btnOnlyPrimary, ],
        }).prependTo(wrpStateBtnsOuter);
    }

    _doSetPinsStandard() {
        Object.keys(this._state).forEach(k=>this._state[k] = SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_STANDARD ? 1 : 0);
    }

    _doSetPinsPartnered({isAdditive=false}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_PARTNERED ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsNonStandard() {
        Object.keys(this._state).forEach(k=>this._state[k] = SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_NON_STANDARD ? 1 : 0);
    }

    _doSetPinsSupplements({isIncludeUnofficial=false, isAdditive=false}={}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.isCoreOrSupplement(k) && (isIncludeUnofficial || !SourceUtil.isNonstandardSource(k)) ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsAdventures({isIncludeUnofficial=false, isAdditive=false}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.isAdventure(k) && (isIncludeUnofficial || !SourceUtil.isNonstandardSource(k)) ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsHomebrew({isAdditive=false}) {
        this._proxyAssignSimple("state", Object.keys(this._state).mergeMap(k=>({
            [k]: SourceUtil.getFilterGroup(k) === SourceUtil.FILTER_GROUP_HOMEBREW ? 1 : isAdditive ? this._state[k] : 0
        })), );
    }

    _doSetPinsVanilla() {
        Object.keys(this._state).forEach(k=>this._state[k] = Parser.SOURCES_VANILLA.has(k) ? 1 : 0);
    }

    _doSetPinsNonUa() {
        Object.keys(this._state).forEach(k=>this._state[k] = !SourceUtil.isPrereleaseSource(k) ? 1 : 0);
    }

    _doSetPinsSrd() {
        SourceFilter._SRD_SOURCES = SourceFilter._SRD_SOURCES || new Set([Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG]);

        Object.keys(this._state).forEach(k=>this._state[k] = SourceFilter._SRD_SOURCES.has(k) ? 1 : 0);

        const srdFilter = this._filterBox.filters.find(it=>it.isSrdFilter);
        if (srdFilter)
            srdFilter.setValue("SRD", 1);

        const basicRulesFilter = this._filterBox.filters.find(it=>it.isBasicRulesFilter);
        if (basicRulesFilter)
            basicRulesFilter.setValue("Basic Rules", 0);

        const reprintedFilter = this._filterBox.filters.find(it=>it.isReprintedFilter);
        if (reprintedFilter)
            reprintedFilter.setValue("Reprinted", 0);
    }

    _doSetPinsBasicRules() {
        SourceFilter._BASIC_RULES_SOURCES = SourceFilter._BASIC_RULES_SOURCES || new Set([Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG]);

        Object.keys(this._state).forEach(k=>this._state[k] = SourceFilter._BASIC_RULES_SOURCES.has(k) ? 1 : 0);

        const basicRulesFilter = this._filterBox.filters.find(it=>it.isBasicRulesFilter);
        if (basicRulesFilter)
            basicRulesFilter.setValue("Basic Rules", 1);

        const srdFilter = this._filterBox.filters.find(it=>it.isSrdFilter);
        if (srdFilter)
            srdFilter.setValue("SRD", 0);

        const reprintedFilter = this._filterBox.filters.find(it=>it.isReprintedFilter);
        if (reprintedFilter)
            reprintedFilter.setValue("Reprinted", 0);
    }

    static getCompleteFilterSources(ent) {
        if (!ent.otherSources)
            return ent.source;

        const otherSourcesFilt = ent.otherSources.filter(src=>!ExcludeUtil.isExcluded("*", "*", src.source, {
            isNoCount: true
        }));
        if (!otherSourcesFilt.length)
            return ent.source;

        return [ent.source].concat(otherSourcesFilt.map(src=>new SourceFilterItem({
            item: src.source,
            isIgnoreRed: true,
            isOtherSource: true
        })));
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider(group) {
        switch (group) {
        case SourceUtil.FILTER_GROUP_NON_STANDARD:
            return this._doRenderPills_doRenderWrpGroup_getHrDivider_groupNonStandard(group);
        case SourceUtil.FILTER_GROUP_HOMEBREW:
            return this._doRenderPills_doRenderWrpGroup_getHrDivider_groupBrew(group);
        default:
            return super._doRenderPills_doRenderWrpGroup_getHrDivider(group);
        }
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider_groupNonStandard(group) {
        let dates = [];
        const comp = BaseComponent.fromObject({
            min: 0,
            max: 0,
            curMin: 0,
            curMax: 0,
        });

        const wrpSlider = new ComponentUiUtil.RangeSlider({
            comp,
            propMin: "min",
            propMax: "max",
            propCurMin: "curMin",
            propCurMax: "curMax",
            fnDisplay: val=>dates[val]?.str,
        }).get();

        const wrpWrpSlider = e_({
            tag: "div",
            clazz: `"w-100 ve-flex pt-2 pb-5 mb-2 mt-1 fltr-src__wrp-slider`,
            children: [wrpSlider, ],
        }).hideVe();

        const btnCancel = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default px-1`,
            html: "Cancel",
            click: ()=>{
                grpBtnsInactive.showVe();
                wrpWrpSlider.hideVe();
                grpBtnsActive.hideVe();
            }
            ,
        });

        const btnConfirm = e_({
            tag: "button",
            clazz: `btn btn-xs btn-default px-1`,
            html: "Confirm",
            click: ()=>{
                grpBtnsInactive.showVe();
                wrpWrpSlider.hideVe();
                grpBtnsActive.hideVe();

                const min = comp._state.curMin;
                const max = comp._state.curMax;

                const allowedDateSet = new Set(dates.slice(min, max + 1).map(it=>it.str));
                const nxtState = {};
                Object.keys(this._state).filter(k=>SourceUtil.isNonstandardSource(k)).forEach(k=>{
                    const sourceDate = Parser.sourceJsonToDate(k);
                    nxtState[k] = allowedDateSet.has(sourceDate) ? 1 : 0;
                }
                );
                this._proxyAssign("state", "_state", "__state", nxtState);
            }
            ,
        });

        const btnShowSlider = e_({
            tag: "button",
            clazz: `btn btn-xxs btn-default px-1`,
            html: "Select by Date",
            click: ()=>{
                grpBtnsInactive.hideVe();
                wrpWrpSlider.showVe();
                grpBtnsActive.showVe();

                dates = Object.keys(this._state).filter(it=>SourceUtil.isNonstandardSource(it)).map(it=>Parser.sourceJsonToDate(it)).filter(Boolean).unique().map(it=>({
                    str: it,
                    date: new Date(it)
                })).sort((a,b)=>SortUtil.ascSortDate(a.date, b.date)).reverse();

                comp._proxyAssignSimple("state", {
                    min: 0,
                    max: dates.length - 1,
                    curMin: 0,
                    curMax: dates.length - 1,
                }, );
            }
            ,
        });

        const btnClear = e_({
            tag: "button",
            clazz: `btn btn-xxs btn-default px-1`,
            html: "Clear",
            click: ()=>{
                const nxtState = {};
                Object.keys(this._state).filter(k=>SourceUtil.isNonstandardSource(k)).forEach(k=>nxtState[k] = 0);
                this._proxyAssign("state", "_state", "__state", nxtState);
            }
            ,
        });

        const grpBtnsActive = e_({
            tag: "div",
            clazz: `ve-flex-v-center btn-group`,
            children: [btnCancel, btnConfirm, ],
        }).hideVe();

        const grpBtnsInactive = e_({
            tag: "div",
            clazz: `ve-flex-v-center btn-group`,
            children: [btnClear, btnShowSlider, ],
        });

        return e_({
            tag: "div",
            clazz: `ve-flex-col w-100`,
            children: [super._doRenderPills_doRenderWrpGroup_getHrDivider(), e_({
                tag: "div",
                clazz: `mb-1 ve-flex-h-right`,
                children: [grpBtnsActive, grpBtnsInactive, ],
            }), wrpWrpSlider, ],
        });
    }

    _doRenderPills_doRenderWrpGroup_getHrDivider_groupBrew(group) {
        const btnClear = e_({
            tag: "button",
            clazz: `btn btn-xxs btn-default px-1`,
            html: "Clear",
            click: ()=>{
                const nxtState = {};
                Object.keys(this._state).filter(k=>BrewUtil2.hasSourceJson(k)).forEach(k=>nxtState[k] = 0);
                this._proxyAssign("state", "_state", "__state", nxtState);
            }
            ,
        });

        return e_({
            tag: "div",
            clazz: `ve-flex-col w-100`,
            children: [super._doRenderPills_doRenderWrpGroup_getHrDivider(), e_({
                tag: "div",
                clazz: `mb-1 ve-flex-h-right`,
                children: [e_({
                    tag: "div",
                    clazz: `ve-flex-v-center btn-group`,
                    children: [btnClear, ],
                }), ],
            }), ],
        });
    }

    _toDisplay_getMappedEntryVal(entryVal) {
        entryVal = super._toDisplay_getMappedEntryVal(entryVal);
        if (!this._meta.isIncludeOtherSources)
            entryVal = entryVal.filter(it=>!it.isOtherSource);
        return entryVal;
    }

    _getPill(item) {
        const displayText = this._getDisplayText(item);
        const displayTextMini = this._getDisplayTextMini(item);

        const dispName = e_({
            tag: "span",
            html: displayText,
        });

        const spc = e_({
            tag: "span",
            clazz: "px-2 fltr-src__spc-pill",
            text: "|",
        });

        const dispAbbreviation = e_({
            tag: "span",
            html: displayTextMini,
        });

        const btnPill = e_({
            tag: "div",
            clazz: "fltr__pill",
            children: [dispAbbreviation, spc, dispName, ],
            click: evt=>this._getPill_handleClick({
                evt,
                item
            }),
            contextmenu: evt=>this._getPill_handleContextmenu({
                evt,
                item
            }),
        });

        this._getPill_bindHookState({
            btnPill,
            item
        });

        this._addHook("meta", "pillDisplayMode", ()=>{
            dispAbbreviation.toggleVe(this._meta.pillDisplayMode !== 0);
            spc.toggleVe(this._meta.pillDisplayMode === 2);
            dispName.toggleVe(this._meta.pillDisplayMode !== 1);
        }
        )();

        item.searchText = `${Parser.sourceJsonToAbv(item.item || item).toLowerCase()} -- ${displayText.toLowerCase()}`;

        return btnPill;
    }

    getSources() {
        const out = {
            all: [],
        };
        this._items.forEach(it=>{
            out.all.push(it.item);
            const group = this._groupFn(it);
            (out[group] ||= []).push(it.item);
        }
        );
        return out;
    }

    getDefaultMeta() {
        return {
            ...super.getDefaultMeta(),
            ...SourceFilter._DEFAULT_META,
        };
    }
}
;
SourceFilter._DEFAULT_META = {
    isIncludeOtherSources: false,
    pillDisplayMode: 0,
};
SourceFilter._PILL_DISPLAY_MODE_LABELS = {
    "0": "As Names",
    "1": "As Abbreviations",
    "2": "As Names Plus Abbreviations",
};
SourceFilter._SRD_SOURCES = null;
SourceFilter._BASIC_RULES_SOURCES = null;
//#endregion

//#region OptionsFilter
let OptionsFilter$1 = class OptionsFilter extends FilterBase {
    constructor(opts) {
        super(opts);
        this._defaultState = opts.defaultState;
        this._displayFn = opts.displayFn;
        this._displayFnMini = opts.displayFnMini;

        Object.assign(this.__state, MiscUtil.copy(opts.defaultState), );

        this._filterBox = null;
        this.__$wrpMini = null;
    }

    getSaveableState() {
        return {
            [this.header]: {
                ...this.getBaseSaveableState(),
                state: {
                    ...this.__state
                },
            },
        };
    }

    setStateFromLoaded(filterState, {isUserSavedState=false}={}) {
        if (!filterState?.[this.header])
            return;

        const toLoad = filterState[this.header];
        this._hasUserSavedState = this._hasUserSavedState || isUserSavedState;

        this.setBaseStateFromLoaded(toLoad);

        const toAssign = {};
        Object.keys(this._defaultState).forEach(k=>{
            if (toLoad.state[k] == null)
                return;
            if (typeof toLoad.state[k] !== typeof this._defaultState[k])
                return;
            toAssign[k] = toLoad.state[k];
        }
        );

        Object.assign(this._state, toAssign);
    }

    _getStateNotDefault() {
        return Object.entries(this._state).filter(([k,v])=>this._defaultState[k] !== v);
    }

    getSubHashes() {
        const out = [];

        const baseMeta = this.getMetaSubHashes();
        if (baseMeta)
            out.push(...baseMeta);

        const serOptionState = [];
        Object.entries(this._defaultState).forEach(([k,vDefault])=>{
            if (this._state[k] !== vDefault)
                serOptionState.push(`${k.toLowerCase()}=${UrlUtil.mini.compress(this._state[k])}`);
        }
        );
        if (serOptionState.length) {
            out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serOptionState));
        }

        return out.length ? out : null;
    }

    getFilterTagPart() {
        const areNotDefaultState = this._getStateNotDefault();
        if (!areNotDefaultState.length)
            return null;

        const pt = areNotDefaultState.map(([k,v])=>`${v ? "" : "!"}${k}`).join(";").toLowerCase();

        return `${this.header.toLowerCase()}=::${pt}::`;
    }

    getDisplayStatePart({nxtState=null}={}) {
        return null;
    }

    getNextStateFromSubhashState(state) {
        const nxtState = this._getNextState_base();

        if (state == null) {
            this._mutNextState_reset(nxtState);
            return nxtState;
        }

        this._mutNextState_meta_fromSubHashState(nxtState, state);

        let hasState = false;

        Object.entries(state).forEach(([k,vals])=>{
            const prop = FilterBase.getProp(k);
            if (prop !== "state")
                return;

            hasState = true;
            vals.forEach(v=>{
                const [prop,valCompressed] = v.split("=");
                const val = UrlUtil.mini.decompress(valCompressed);

                const casedProp = Object.keys(this._defaultState).find(k=>k.toLowerCase() === prop);
                if (!casedProp)
                    return;

                if (this._defaultState[casedProp] != null && typeof val === typeof this._defaultState[casedProp])
                    nxtState[this.header].state[casedProp] = val;
            }
            );
        }
        );

        if (!hasState)
            this._mutNextState_reset(nxtState);

        return nxtState;
    }

    setFromValues(values) {
        if (!values[this.header])
            return;
        const vals = values[this.header];
        Object.entries(vals).forEach(([k,v])=>{
            if (this._defaultState[k] && typeof this._defaultState[k] === typeof v)
                this._state[k] = v;
        }
        );
    }

    setValue(k, v) {
        this._state[k] = v;
    }

    $render(opts) {
        this._filterBox = opts.filterBox;
        this.__$wrpMini = opts.$wrpMini;

        const $wrpControls = opts.isMulti ? null : this._$getHeaderControls();

        const $btns = Object.keys(this._defaultState).map(k=>this._$render_$getPill(k));
        const $wrpButtons = $$`<div>${$btns}</div>`;

        if (opts.isMulti) {
            return this.__$wrpFilter = $$`<div class="ve-flex">
				<div class="fltr__range-inline-label mr-2">${this._getRenderedHeader()}</div>
				${$wrpButtons}
			</div>`;
        } else {
            return this.__$wrpFilter = $$`<div class="ve-flex-col">
				${opts.isFirst ? "" : `<div class="fltr__dropdown-divider mb-1"></div>`}
				<div class="split fltr__h ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
					<div class="fltr__h-text ve-flex-h-center">${this._getRenderedHeader()}</div>
					${$wrpControls}
				</div>
				${$wrpButtons}
			</div>`;
        }
    }

    $renderMinis(opts) {
        if (!opts.$wrpMini)
            return;

        this._filterBox = opts.filterBox;
        this.__$wrpMini = opts.$wrpMini;

        const $btnsMini = Object.keys(this._defaultState).map(k=>this._$render_$getMiniPill(k));
        $btnsMini.forEach($btn=>$btn.appendTo(this.__$wrpMini));
    }

    _$render_$getPill(key) {
        const displayText = this._displayFn(key);

        const $btnPill = $(`<div class="fltr__pill">${displayText}</div>`).click(()=>{
            this._state[key] = !this._state[key];
        }
        ).contextmenu((evt)=>{
            evt.preventDefault();
            this._state[key] = !this._state[key];
        }
        );
        const hook = ()=>{
            const val = FilterBox$1._PILL_STATES[this._state[key] ? 1 : 2];
            $btnPill.attr("state", val);
        }
        ;
        this._addHook("state", key, hook);
        hook();

        return $btnPill;
    }

    _$render_$getMiniPill(key) {
        const displayTextFull = this._displayFnMini ? this._displayFn(key) : null;
        const displayText = this._displayFnMini ? this._displayFnMini(key) : this._displayFn(key);

        const $btnMini = $(`<div class="fltr__mini-pill ${this._filterBox.isMinisHidden(this.header) ? "ve-hidden" : ""}" state="${FilterBox$1._PILL_STATES[this._defaultState[key] === this._state[key] ? 0 : this._state[key] ? 1 : 2]}">${displayText}</div>`).title(`${displayTextFull ? `${displayTextFull} (` : ""}Filter: ${this.header}${displayTextFull ? ")" : ""}`).click(()=>{
            this._state[key] = this._defaultState[key];
            this._filterBox.fireChangeEvent();
        }
        );

        const hook = ()=>$btnMini.attr("state", FilterBox$1._PILL_STATES[this._defaultState[key] === this._state[key] ? 0 : this._state[key] ? 1 : 2]);
        this._addHook("state", key, hook);

        const hideHook = ()=>$btnMini.toggleClass("ve-hidden", this._filterBox.isMinisHidden(this.header));
        this._filterBox.registerMinisHiddenHook(this.header, hideHook);

        return $btnMini;
    }

    _$getHeaderControls() {
        const $btnReset = $(`<button class="btn btn-default btn-xs">Reset</button>`).click(()=>this.reset());
        const $wrpBtns = $$`<div class="ve-flex-v-center">${$btnReset}</div>`;

        const $wrpSummary = $(`<div class="ve-flex-v-center fltr__summary_item fltr__summary_item--include"></div>`).hideVe();

        const $btnShowHide = $(`<button class="btn btn-default btn-xs ml-2 ${this._meta.isHidden ? "active" : ""}">Hide</button>`).click(()=>this._meta.isHidden = !this._meta.isHidden);
        const hkIsHidden = ()=>{
            $btnShowHide.toggleClass("active", this._meta.isHidden);
            $wrpBtns.toggleVe(!this._meta.isHidden);
            $wrpSummary.toggleVe(this._meta.isHidden);

            const cntNonDefault = Object.entries(this._defaultState).filter(([k,v])=>this._state[k] != null && this._state[k] !== v).length;

            $wrpSummary.title(`${cntNonDefault} non-default option${cntNonDefault === 1 ? "" : "s"} selected`).text(cntNonDefault);
        }
        ;
        this._addHook("meta", "isHidden", hkIsHidden);
        hkIsHidden();

        return $$`
		<div class="ve-flex-v-center">
			${$wrpBtns}
			${$wrpSummary}
			${$btnShowHide}
		</div>`;
    }

    getValues({nxtState=null}={}) {
        const state = nxtState?.[this.header]?.state || this.__state;

        const out = Object.entries(this._defaultState).mergeMap(([k,v])=>({
            [k]: state[k] == null ? v : state[k]
        }));
        out._isActive = Object.entries(this._defaultState).some(([k,v])=>state[k] != null && state[k] !== v);
        return {
            [this.header]: out,
        };
    }

    _mutNextState_reset(nxtState, {isResetAll=false}={}) {
        if (isResetAll)
            this._mutNextState_resetBase(nxtState, {
                isResetAll
            });
        Object.assign(nxtState[this.header].state, MiscUtil.copy(this._defaultState));
    }

    update() {}

    toDisplay(boxState, entryVal) {
        const filterState = boxState[this.header];
        if (!filterState)
            return true;
        if (entryVal == null)
            return true;
        return Object.entries(entryVal).every(([k,v])=>this._state[k] === v);
    }

    getDefaultMeta() {
        return {
            ...super.getDefaultMeta(),
            ...OptionsFilter$1._DEFAULT_META,
        };
    }

    handleSearch(searchTerm) {
        if (this.__$wrpFilter == null)
            return;

        const isVisible = this.header.toLowerCase().includes(searchTerm) || Object.keys(this._defaultState).map(it=>this._displayFn(it).toLowerCase()).some(it=>it.includes(searchTerm));

        this.__$wrpFilter.toggleClass("fltr__hidden--search", !isVisible);

        return isVisible;
    }
}
;
OptionsFilter$1._DEFAULT_META = {};
globalThis.OptionsFilter = OptionsFilter$1;
//#endregion

//#region PageFilterClasseste
class PageFilter {
    static defaultSourceSelFn(val) {
        return SourceUtil.getFilterGroup(val) === SourceUtil.FILTER_GROUP_STANDARD;
    }

    constructor(opts) {
        opts = opts || {};
        this._sourceFilter = new SourceFilter(opts.sourceFilterOpts);
        this._filterBox = null;
    }

    get filterBox() {
        return this._filterBox;
    }
    get sourceFilter() {
        return this._sourceFilter;
    }

    mutateAndAddToFilters(entity, isExcluded, opts) {
        this.constructor.mutateForFilters(entity, opts);
        this.addToFilters(entity, isExcluded, opts);
    }

    static mutateForFilters(entity, opts) {
        throw new Error("Unimplemented!");
    }
    addToFilters(entity, isExcluded, opts) {
        throw new Error("Unimplemented!");
    }
    toDisplay(values, entity) {
        throw new Error("Unimplemented!");
    }
    async _pPopulateBoxOptions() {
        throw new Error("Unimplemented!");
    }

    async pInitFilterBox(opts) {
        opts = opts || {};
        await this._pPopulateBoxOptions(opts);
        this._filterBox = new FilterBox$1(opts);
        await this._filterBox.pDoLoadState();
        return this._filterBox;
    }

    trimState() {
        return this._filterBox.trimState_();
    }

    static _getClassFilterItem({className, classSource, isVariantClass, definedInSource}) {
        const nm = className.split("(")[0].trim();
        const variantSuffix = isVariantClass ? ` [${definedInSource ? Parser.sourceJsonToAbv(definedInSource) : "Unknown"}]` : "";
        const sourceSuffix = (SourceUtil.isNonstandardSource(classSource || Parser.SRC_PHB) || (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(classSource || Parser.SRC_PHB)) || (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(classSource || Parser.SRC_PHB))) ? ` (${Parser.sourceJsonToAbv(classSource)})` : "";
        const name = `${nm}${variantSuffix}${sourceSuffix}`;

        const opts = {
            item: name,
            userData: {
                group: SourceUtil.getFilterGroup(classSource || Parser.SRC_PHB),
            },
        };

        if (isVariantClass) {
            opts.nest = definedInSource ? Parser.sourceJsonToFull(definedInSource) : "Unknown";
            opts.userData.equivalentClassName = `${nm}${sourceSuffix}`;
            opts.userData.definedInSource = definedInSource;
        }

        return new FilterItem$1(opts);
    }

    static _getSubclassFilterItem({className, classSource, subclassShortName, subclassName, subclassSource, subSubclassName, isVariantClass, definedInSource}) {
        const group = SourceUtil.isSubclassReprinted(className, classSource, subclassShortName, subclassSource) || Parser.sourceJsonToFull(subclassSource).startsWith(Parser.UA_PREFIX) || Parser.sourceJsonToFull(subclassSource).startsWith(Parser.PS_PREFIX);

        const classFilterItem = this._getClassFilterItem({
            className: subclassShortName || subclassName,
            classSource: subclassSource,
        });

        return new FilterItem$1({
            item: `${className}: ${classFilterItem.item}${subSubclassName ? `, ${subSubclassName}` : ""}`,
            nest: className,
            userData: {
                group,
            },
        });
    }

    static _isReprinted({reprintedAs, tag, page, prop}) {
        return reprintedAs?.length && reprintedAs.some(it=>{
            const {name, source} = DataUtil.generic.unpackUid(it?.uid ?? it, tag);
            const hash = UrlUtil.URL_TO_HASH_BUILDER[page]({
                name,
                source
            });
            return !ExcludeUtil.isExcluded(hash, prop, source, {
                isNoCount: true
            });
        }
        );
    }

    static getListAliases(ent) {
        return (ent.alias || []).map(it=>`"${it}"`).join(",");
    }
}

let PageFilterClassesBase$1 = class PageFilterClassesBase extends PageFilter {
    constructor() {
        super();

        this._miscFilter = new Filter({
            header: "Miscellaneous",
            items: ["Reprinted", "Sidekick", "SRD", "Basic Rules"],
            deselFn: (it)=>{
                return it === "Reprinted" || it === "Sidekick";
            }
            ,
            displayFnMini: it=>it === "Reprinted" ? "Repr." : it,
            displayFnTitle: it=>it === "Reprinted" ? it : "",
            isMiscFilter: true,
        });

        this._optionsFilter = new OptionsFilter({
            header: "Other/Text Options",
            defaultState: {
                isDisplayClassIfSubclassActive: false,
                isClassFeatureVariant: true,
            },
            displayFn: k=>{
                switch (k) {
                case "isClassFeatureVariant":
                    return "Class Feature Options/Variants";
                case "isDisplayClassIfSubclassActive":
                    return "Display Class if Any Subclass is Visible";
                default:
                    throw new Error(`Unhandled key "${k}"`);
                }
            }
            ,
            displayFnMini: k=>{
                switch (k) {
                case "isClassFeatureVariant":
                    return "C.F.O/V.";
                case "isDisplayClassIfSubclassActive":
                    return "Sc>C";
                default:
                    throw new Error(`Unhandled key "${k}"`);
                }
            }
            ,
        });
    }

    get optionsFilter() {
        return this._optionsFilter;
    }

    static mutateForFilters(cls) {
        cls.source = cls.source || Parser.SRC_PHB;
        cls.subclasses = cls.subclasses || [];

        cls._fSources = SourceFilter.getCompleteFilterSources(cls);

        cls._fSourceSubclass = [...new Set([cls.source, ...cls.subclasses.map(it=>[it.source, ...(it.otherSources || []).map(it=>it.source)]).flat(), ]), ];

        cls._fMisc = [];
        if (cls.isReprinted)
            cls._fMisc.push("Reprinted");
        if (cls.srd)
            cls._fMisc.push("SRD");
        if (cls.basicRules)
            cls._fMisc.push("Basic Rules");
        if (cls.isSidekick)
            cls._fMisc.push("Sidekick");

        cls.subclasses.forEach(sc=>{
            sc.source = sc.source || cls.source;
            sc.shortName = sc.shortName || sc.name;
            sc._fMisc = [];
            if (sc.srd)
                sc._fMisc.push("SRD");
            if (sc.basicRules)
                sc._fMisc.push("Basic Rules");
            if (sc.isReprinted)
                sc._fMisc.push("Reprinted");
        }
        );
    }

    _addEntrySourcesToFilter(entry) {
        this._addEntrySourcesToFilter_walk(entry);
    }

    _addEntrySourcesToFilter_walk = (obj)=>{
        if ((typeof obj !== "object") || obj == null)
            return;

        if (obj instanceof Array)
            return obj.forEach(this._addEntrySourcesToFilter_walk.bind(this));

        if (obj.source)
            this._sourceFilter.addItem(obj.source);
        if (obj.entries)
            this._addEntrySourcesToFilter_walk(obj.entries);
    }
    ;

    addToFilters(cls, isExcluded, opts) {
        if (isExcluded)
            return;
        opts = opts || {};
        const subclassExclusions = opts.subclassExclusions || {};

        this._sourceFilter.addItem(cls.source);

        if (cls.fluff)
            cls.fluff.forEach(it=>this._addEntrySourcesToFilter(it));
        cls.classFeatures.forEach(lvlFeatures=>lvlFeatures.forEach(feature=>this._addEntrySourcesToFilter(feature)));

        cls.subclasses.forEach(sc=>{
            const isScExcluded = (subclassExclusions[sc.source] || {})[sc.name] || false;
            if (!isScExcluded) {
                this._sourceFilter.addItem(sc.source);
                sc.subclassFeatures.forEach(lvlFeatures=>lvlFeatures.forEach(feature=>this._addEntrySourcesToFilter(feature)));
            }
        }
        );
    }

    async _pPopulateBoxOptions(opts) {
        opts.filters = [this._sourceFilter, this._miscFilter, this._optionsFilter, ];
        opts.isCompact = true;
    }

    isClassNaturallyDisplayed(values, cls) {
        return this._filterBox.toDisplay(values, ...this.constructor._getIsClassNaturallyDisplayedToDisplayParams(cls), );
    }

    static _getIsClassNaturallyDisplayedToDisplayParams(cls) {
        return [cls._fSources, cls._fMisc];
    }

    isAnySubclassDisplayed(values, cls) {
        return values[this._optionsFilter.header].isDisplayClassIfSubclassActive && (cls.subclasses || []).some(sc=>{
            if (this._filterBox.toDisplay(values, ...this.constructor._getIsSubclassDisplayedToDisplayParams(cls, sc), ))
                return true;

            return sc.otherSources?.length && sc.otherSources.some(src=>this._filterBox.toDisplay(values, ...this.constructor._getIsSubclassDisplayedToDisplayParams(cls, sc, src), ));
        }
        );
    }

    static _getIsSubclassDisplayedToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, null, ];
    }

    isSubclassVisible(f, cls, sc) {
        if (this.filterBox.toDisplay(f, ...this.constructor._getIsSubclassVisibleToDisplayParams(cls, sc), ))
            return true;

        if (!sc.otherSources?.length)
            return false;

        return sc.otherSources.some(src=>this.filterBox.toDisplay(f, ...this.constructor._getIsSubclassVisibleToDisplayParams(cls, sc, src.source), ));
    }

    static _getIsSubclassVisibleToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, null, ];
    }

    getActiveSource(values) {
        const sourceFilterValues = values[this._sourceFilter.header];
        if (!sourceFilterValues)
            return null;
        return Object.keys(sourceFilterValues).find(it=>this._sourceFilter.toDisplay(values, it));
    }

    toDisplay(values, it) {
        return this._filterBox.toDisplay(values, ...this._getToDisplayParams(values, it), );
    }

    _getToDisplayParams(values, cls) {
        return [this.isAnySubclassDisplayed(values, cls) ? cls._fSourceSubclass : (cls._fSources ?? cls.source), cls._fMisc, null, ];
    }
}
;

globalThis.PageFilterClassesBase = PageFilterClassesBase$1;

let PageFilterClasses$1 = class PageFilterClasses extends PageFilterClassesBase$1 {
    static _getClassSubclassLevelArray(it) {
        return it.classFeatures.map((_,i)=>i + 1);
    }

    constructor() {
        super();

        this._levelFilter = new RangeFilter({
            header: "Feature Level",
            min: 1,
            max: 20,
        });
    }

    get levelFilter() {
        return this._levelFilter;
    }

    static mutateForFilters(cls) {
        super.mutateForFilters(cls);

        cls._fLevelRange = this._getClassSubclassLevelArray(cls);
    }

    addToFilters(cls, isExcluded, opts) {
        super.addToFilters(cls, isExcluded, opts);

        if (isExcluded)
            return;

        this._levelFilter.addItem(cls._fLevelRange);
    }

    async _pPopulateBoxOptions(opts) {
        await super._pPopulateBoxOptions(opts);

        opts.filters = [this._sourceFilter, this._miscFilter, this._levelFilter, this._optionsFilter, ];
    }

    static _getIsClassNaturallyDisplayedToDisplayParams(cls) {
        return [cls._fSources, cls._fMisc, cls._fLevelRange];
    }

    static _getIsSubclassDisplayedToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, cls._fLevelRange];
    }

    static _getIsSubclassVisibleToDisplayParams(cls, sc, otherSourcesSource) {
        return [otherSourcesSource || sc.source, sc._fMisc, cls._fLevelRange, null];
    }

    _getToDisplayParams(values, cls) {
        return [this.isAnySubclassDisplayed(values, cls) ? cls._fSourceSubclass : (cls._fSources ?? cls.source), cls._fMisc, cls._fLevelRange, ];
    }
}
;

globalThis.PageFilterClasses = PageFilterClasses$1;

"use strict";

let PageFilterClassesRaw$1 = class PageFilterClassesRaw extends PageFilterClassesBase {
    static _WALKER = null;
    static _IMPLS_SIDE_DATA = {};

    async _pPopulateBoxOptions(opts) {
        await super._pPopulateBoxOptions(opts);
        opts.isCompact = false;
    }

    addToFilters(cls, isExcluded, opts) {
        if (isExcluded)
            return;
        opts = opts || {};
        const subclassExclusions = opts.subclassExclusions || {};

        this._sourceFilter.addItem(cls.source);

        if (cls.fluff)
            cls.fluff.forEach(it=>this._addEntrySourcesToFilter(it));

        cls.classFeatures.forEach(feature=>feature.loadeds.forEach(ent=>this._addEntrySourcesToFilter(ent.entity)));

        cls.subclasses.forEach(sc=>{
            const isScExcluded = (subclassExclusions[sc.source] || {})[sc.name] || false;
            if (!isScExcluded) {
                this._sourceFilter.addItem(sc.source);
                sc.subclassFeatures.forEach(feature=>feature.loadeds.forEach(ent=>this._addEntrySourcesToFilter(ent.entity)));
            }
        }
        );
    }

    static async _pGetParentClass(sc) {
        let baseClass = (await DataUtil.class.loadRawJSON()).class.find(bc=>bc.name.toLowerCase() === sc.className.toLowerCase() && (bc.source.toLowerCase() || Parser.SRC_PHB) === sc.classSource.toLowerCase());

        baseClass = baseClass || await this._pGetParentClass_pPrerelease({
            sc
        });
        baseClass = baseClass || await this._pGetParentClass_pBrew({
            sc
        });

        return baseClass;
    }

    static async _pGetParentClass_pPrerelease({sc}) {
        await this._pGetParentClass_pPrereleaseBrew({
            sc,
            brewUtil: PrereleaseUtil
        });
    }

    static async _pGetParentClass_pBrew({sc}) {
        await this._pGetParentClass_pPrereleaseBrew({
            sc,
            brewUtil: BrewUtil2
        });
    }

    static async _pGetParentClass_pPrereleaseBrew({sc, brewUtil}) {
        const brew = await brewUtil.pGetBrewProcessed();
        return (brew.class || []).find(bc=>bc.name.toLowerCase() === sc.className.toLowerCase() && (bc.source.toLowerCase() || Parser.SRC_PHB) === sc.classSource.toLowerCase());
    }

    static async pPostLoad(data, {...opts}={}) {
        data = MiscUtil.copy(data);

        await PrereleaseUtil.pGetBrewProcessed();
        await BrewUtil2.pGetBrewProcessed();

        if (!data.class)
            data.class = [];

        if (data.subclass) {
            for (const sc of data.subclass) {
                if (!sc.className)
                    continue;
                sc.classSource = sc.classSource || Parser.SRC_PHB;

                let cls = data.class.find(it=>(it.name || "").toLowerCase() === sc.className.toLowerCase() && (it.source || Parser.SRC_PHB).toLowerCase() === sc.classSource.toLowerCase());

                if (!cls) {
                    cls = await this._pGetParentClass(sc);
                    if (cls) {
                        cls = MiscUtil.copy(cls);
                        cls.subclasses = [];
                        data.class.push(cls);
                    } else {
                        cls = {
                            name: sc.className,
                            source: sc.classSource
                        };
                        data.class.push(cls);
                    }
                }

                (cls.subclasses = cls.subclasses || []).push(sc);
            }

            delete data.subclass;
        }

        data.class.forEach(cls=>{
            cls.source = cls.source || Parser.SRC_PHB;

            cls.subclasses = cls.subclasses || [];

            cls.subclasses.forEach(sc=>{
                sc.name = sc.name || "(Unnamed subclass)";
                sc.source = sc.source || cls.source;
                sc.className = sc.className || cls.name;
                sc.classSource = sc.classSource || cls.source || Parser.SRC_PHB;
            }
            );

            cls.subclasses.sort((a,b)=>SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source || cls.source, b.source || cls.source));

            cls._cntStartingSkillChoices = (MiscUtil.get(cls, "startingProficiencies", "skills") || []).map(it=>it.choose ? (it.choose.count || 1) : 0).reduce((a,b)=>a + b, 0);

            cls._cntStartingSkillChoicesMutliclass = (MiscUtil.get(cls, "multiclassing", "proficienciesGained", "skills") || []).map(it=>it.choose ? (it.choose.count || 1) : 0).reduce((a,b)=>a + b, 0);
        }
        );
        data.class.sort((a,b)=>SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source));

        data.class.forEach(cls=>{
            cls.classFeatures = (cls.classFeatures || []).map(cf=>typeof cf === "string" ? {
                classFeature: cf
            } : cf);

            (cls.subclasses || []).forEach(sc=>{
                sc.subclassFeatures = (sc.subclassFeatures || []).map(cf=>typeof cf === "string" ? {
                    subclassFeature: cf
                } : cf);
            }
            );
        }
        );

        await this._pPreloadSideData();

        for (const cls of data.class) {
            await (cls.classFeatures || []).pSerialAwaitMap(cf=>this.pInitClassFeatureLoadeds({
                ...opts,
                classFeature: cf,
                className: cls.name
            }));

            if (cls.classFeatures)
                cls.classFeatures = cls.classFeatures.filter(it=>!it.isIgnored);

            for (const sc of cls.subclasses || []) {
                await (sc.subclassFeatures || []).pSerialAwaitMap(scf=>this.pInitSubclassFeatureLoadeds({
                    ...opts,
                    subclassFeature: scf,
                    className: cls.name,
                    subclassName: sc.name
                }));

                if (sc.subclassFeatures)
                    sc.subclassFeatures = sc.subclassFeatures.filter(it=>!it.isIgnored);
            }
        }

        return data;
    }

    static async pInitClassFeatureLoadeds({classFeature, className, ...opts}) {
        if (typeof classFeature !== "object")
            throw new Error(`Expected an object of the form {classFeature: "<UID>"}`);

        const unpacked = DataUtil.class.unpackUidClassFeature(classFeature.classFeature);

        classFeature.hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked);

        const {name, level, source} = unpacked;
        classFeature.name = name;
        classFeature.level = level;
        classFeature.source = source;

        const entityRoot = await DataLoader.pCacheAndGet("raw_classFeature", classFeature.source, classFeature.hash, {
            isCopy: true
        });
        const loadedRoot = {
            type: "classFeature",
            entity: entityRoot,
            page: "classFeature",
            source: classFeature.source,
            hash: classFeature.hash,
            className,
        };

        const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, "classFeature");
        if (isIgnored) {
            classFeature.isIgnored = true;
            return;
        }

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: "classFeature",
            ancestorMeta: {
                _ancestorClassName: className,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        classFeature.loadeds = [loadedRoot, ...subLoadeds];
    }

    static async pInitSubclassFeatureLoadeds({subclassFeature, className, subclassName, ...opts}) {
        if (typeof subclassFeature !== "object")
            throw new Error(`Expected an object of the form {subclassFeature: "<UID>"}`);

        const unpacked = DataUtil.class.unpackUidSubclassFeature(subclassFeature.subclassFeature);

        subclassFeature.hash = UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked);

        const {name, level, source} = unpacked;
        subclassFeature.name = name;
        subclassFeature.level = level;
        subclassFeature.source = source;

        const entityRoot = await DataLoader.pCacheAndGet("raw_subclassFeature", subclassFeature.source, subclassFeature.hash, {
            isCopy: true
        });
        const loadedRoot = {
            type: "subclassFeature",
            entity: entityRoot,
            page: "subclassFeature",
            source: subclassFeature.source,
            hash: subclassFeature.hash,
            className,
            subclassName,
        };

        const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, "subclassFeature");
        if (isIgnored) {
            subclassFeature.isIgnored = true;
            return;
        }

        if (entityRoot.isGainAtNextFeatureLevel) {
            subclassFeature.isGainAtNextFeatureLevel = true;
        }

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: "subclassFeature",
            ancestorMeta: {
                _ancestorClassName: className,
                _ancestorSubclassName: subclassName,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        subclassFeature.loadeds = [loadedRoot, ...subLoadeds];
    }

    static async pInitFeatLoadeds({feat, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: feat,
            prop: "feat",
            page: UrlUtil.PG_FEATS,
            propAncestorName: "_ancestorFeatName",
            raw,
        });
    }

    static async pInitOptionalFeatureLoadeds({optionalfeature, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: optionalfeature,
            prop: "optionalfeature",
            page: UrlUtil.PG_OPT_FEATURES,
            propAncestorName: "_ancestorOptionalfeatureName",
            raw,
        });
    }

    static async pInitRewardLoadeds({reward, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: reward,
            prop: "reward",
            page: UrlUtil.PG_REWARDS,
            propAncestorName: "_ancestorRewardName",
            raw,
        });
    }

    static async pInitCharCreationOptionLoadeds({charoption, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: charoption,
            prop: "charoption",
            page: UrlUtil.PG_CHAR_CREATION_OPTIONS,
            propAncestorName: "_ancestorCharoptionName",
            raw,
        });
    }

    static async pInitVehicleUpgradeLoadeds({vehicleUpgrade, raw, ...opts}) {
        return this._pInitGenericLoadeds({
            ...opts,
            ent: vehicleUpgrade,
            prop: "vehicleUpgrade",
            page: UrlUtil.PG_VEHICLES,
            propAncestorName: "_ancestorVehicleUpgradeName",
            raw,
        });
    }

    static async _pInitGenericLoadeds({ent, prop, page, propAncestorName, raw, ...opts}) {
        if (typeof ent !== "object")
            throw new Error(`Expected an object of the form {${prop}: "<UID>"}`);

        const unpacked = DataUtil.generic.unpackUid(ent[prop]);

        ent.hash = UrlUtil.URL_TO_HASH_BUILDER[page](unpacked);

        const {name, source} = unpacked;
        ent.name = name;
        ent.source = source;

        const entityRoot = raw != null ? MiscUtil.copy(raw) : await DataLoader.pCacheAndGet(`raw_${prop}`, ent.source, ent.hash, {
            isCopy: true
        });
        const loadedRoot = {
            type: prop,
            entity: entityRoot,
            page,
            source: ent.source,
            hash: ent.hash,
        };

        const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, prop);
        if (isIgnored) {
            ent.isIgnored = true;
            return;
        }

        const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(this._getPostLoadWalker(), entityRoot, {
            ...opts,
            ancestorType: prop,
            ancestorMeta: {
                [propAncestorName]: entityRoot.name,
            },
        }, );
        loadedRoot.entity = entityRootNxt;

        ent.loadeds = [loadedRoot, ...subLoadeds];
    }

    static async _pPreloadSideData() {
        await Promise.all(Object.values(PageFilterClassesRaw$1._IMPLS_SIDE_DATA).map(Impl=>Impl.pPreloadSideData()));
    }

    static async _pGetIgnoredAndApplySideData(entity, type) {
        if (!PageFilterClassesRaw$1._IMPLS_SIDE_DATA[type])
            throw new Error(`Unhandled type "${type}"`);

        const sideData = await PageFilterClassesRaw$1._IMPLS_SIDE_DATA[type].pGetSideLoaded(entity, {
            isSilent: true
        });

        if (!sideData)
            return false;
        if (sideData.isIgnored)
            return true;

        if (sideData.entries)
            entity.entries = MiscUtil.copy(sideData.entries);
        if (sideData.entryData)
            entity.entryData = MiscUtil.copy(sideData.entryData);

        return false;
    }

    static async _pLoadSubEntries(walker, entityRoot, {ancestorType, ancestorMeta, ...opts}) {
        const out = [];

        const pRecurse = async(parent,toWalk)=>{
            const references = [];
            const path = [];

            toWalk = walker.walk(toWalk, {
                array: (arr)=>{
                    arr = arr.map(it=>this._pLoadSubEntries_getMappedWalkerArrayEntry({
                        ...opts,
                        it,
                        path,
                        references
                    })).filter(Boolean);
                    return arr;
                }
                ,
                preObject: (obj)=>{
                    if (obj.type === "options") {
                        const parentName = (path.last() || {}).name ?? parent.name;

                        if (obj.count != null) {
                            const optionSetId = CryptUtil.uid();
                            obj.entries.forEach(ent=>{
                                ent._optionsMeta = {
                                    setId: optionSetId,
                                    count: obj.count,
                                    name: parentName,
                                };
                            }
                            );
                        }

                        if (parentName) {
                            obj.entries.forEach(ent=>{
                                if (typeof ent !== "object")
                                    return;
                                ent._displayNamePrefix = `${parentName}: `;
                            }
                            );
                        }
                    }

                    if (obj.name)
                        path.push(obj);
                }
                ,
                postObject: (obj)=>{
                    if (obj.name)
                        path.pop();
                }
                ,
            }, );

            for (const ent of references) {
                const isRequiredOption = !!MiscUtil.get(ent, "data", "isRequiredOption");
                switch (ent.type) {
                case "refClassFeature":
                    {
                        const unpacked = DataUtil.class.unpackUidClassFeature(ent.classFeature);
                        const {source} = unpacked;
                        const hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked);

                        let entity = await DataLoader.pCacheAndGet("raw_classFeature", source, hash, {
                            isCopy: true
                        });

                        if (!entity) {
                            this._handleReferenceError(`Failed to load "classFeature" reference "${ent.classFeature}" (not found)`);
                            continue;
                        }

                        if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER["classFeature"](toWalk) === hash) {
                            this._handleReferenceError(`Failed to load "classFeature" reference "${ent.classFeature}" (circular reference)`);
                            continue;
                        }

                        const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "classFeature");
                        if (isIgnored)
                            continue;

                        this.populateEntityTempData({
                            entity,
                            displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
                            ...ancestorMeta,
                        });

                        out.push({
                            type: "classFeature",
                            entry: `{@classFeature ${ent.classFeature}}`,
                            entity,
                            optionsMeta: ent._optionsMeta,
                            page: "classFeature",
                            source,
                            hash,
                            isRequiredOption,
                        });

                        entity = await pRecurse(entity, entity.entries);

                        break;
                    }
                case "refSubclassFeature":
                    {
                        const unpacked = DataUtil.class.unpackUidSubclassFeature(ent.subclassFeature);
                        const {source} = unpacked;
                        const hash = UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked);

                        let entity = await DataLoader.pCacheAndGet("raw_subclassFeature", source, hash, {
                            isCopy: true
                        });

                        if (!entity) {
                            this._handleReferenceError(`Failed to load "subclassFeature" reference "${ent.subclassFeature}" (not found)`);
                            continue;
                        }

                        if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](toWalk) === hash) {
                            this._handleReferenceError(`Failed to load "subclassFeature" reference "${ent.subclassFeature}" (circular reference)`);
                            continue;
                        }

                        const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "subclassFeature");
                        if (isIgnored)
                            continue;

                        this.populateEntityTempData({
                            entity,
                            displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
                            ...ancestorMeta,
                        });

                        out.push({
                            type: "subclassFeature",
                            entry: `{@subclassFeature ${ent.subclassFeature}}`,
                            entity,
                            optionsMeta: ent._optionsMeta,
                            page: "subclassFeature",
                            source,
                            hash,
                            isRequiredOption,
                        });

                        entity = await pRecurse(entity, entity.entries);

                        break;
                    }
                case "refOptionalfeature":
                    {
                        const unpacked = DataUtil.generic.unpackUid(ent.optionalfeature, "optfeature");
                        const page = UrlUtil.PG_OPT_FEATURES;
                        const {source} = unpacked;
                        const hash = UrlUtil.URL_TO_HASH_BUILDER[page](unpacked);

                        const entity = await DataLoader.pCacheAndGet(page, source, hash, {
                            isCopy: true
                        });

                        if (!entity) {
                            this._handleReferenceError(`Failed to load "optfeature" reference "${ent.optionalfeature}" (not found)`);
                            continue;
                        }

                        if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER[page](toWalk) === hash) {
                            this._handleReferenceError(`Failed to load "optfeature" reference "${ent.optionalfeature}" (circular reference)`);
                            continue;
                        }

                        const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "optionalfeature");
                        if (isIgnored)
                            continue;

                        this.populateEntityTempData({
                            entity,
                            ancestorType,
                            displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
                            ...ancestorMeta,
                            foundrySystem: {
                                requirements: entityRoot.className ? `${entityRoot.className} ${entityRoot.level}${entityRoot.subclassShortName ? ` (${entityRoot.subclassShortName})` : ""}` : null,
                            },
                        });

                        out.push({
                            type: "optionalfeature",
                            entry: `{@optfeature ${ent.optionalfeature}}`,
                            entity,
                            optionsMeta: ent._optionsMeta,
                            page,
                            source,
                            hash,
                            isRequiredOption,
                        });

                        break;
                    }
                default:
                    throw new Error(`Unhandled type "${ent.type}"`);
                }
            }

            return toWalk;
        }
        ;

        if (entityRoot.entries) //entityRoot.entryData is already set by this point
            entityRoot.entries = await pRecurse(entityRoot, entityRoot.entries);

        return {
            entityRoot,
            subLoadeds: out
        };
    }

    static _pLoadSubEntries_getMappedWalkerArrayEntry({it, path, references, ...opts}) {
        if (it.type !== "refClassFeature" && it.type !== "refSubclassFeature" && it.type !== "refOptionalfeature")
            return it;

        it.parentName = (path.last() || {}).name;
        references.push(it);

        return null;
    }

    static populateEntityTempData({entity, ancestorType, displayName, foundrySystem, ...others}, ) {
        if (ancestorType)
            entity._ancestorType = ancestorType;
        if (displayName)
            entity._displayName = displayName;
        if (foundrySystem)
            entity._foundrySystem = foundrySystem;
        Object.assign(entity, {
            ...others
        });
    }

    static _handleReferenceError(msg) {
        JqueryUtil.doToast({
            type: "danger",
            content: msg
        });
    }

    static _getPostLoadWalker() {
        PageFilterClassesRaw$1._WALKER = PageFilterClassesRaw$1._WALKER || MiscUtil.getWalker({
            keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
            isDepthFirst: true,
        });
        return PageFilterClassesRaw$1._WALKER;
    }

    static setImplSideData(prop, Impl) {
        PageFilterClassesRaw$1._IMPLS_SIDE_DATA[prop] = Impl;
    }
}
;

globalThis.PageFilterClassesRaw = PageFilterClassesRaw$1;
//#endregion

//#region Modals    

//#region ModalFilter
class ModalFilter {
    static _$getFilterColumnHeaders(btnMeta) {
        return btnMeta.map((it,i)=>$(`<button class="col-${it.width} ${i === 0 ? "pl-0" : i === btnMeta.length ? "pr-0" : ""} ${it.disabled ? "" : "sort"} btn btn-default btn-xs" ${it.disabled ? "" : `data-sort="${it.sort}"`} ${it.title ? `title="${it.title}"` : ""} ${it.disabled ? "disabled" : ""}>${it.text}</button>`));
    }

    constructor(opts) {
        this._modalTitle = opts.modalTitle;
        this._fnSort = opts.fnSort;
        this._pageFilter = opts.pageFilter;
        this._namespace = opts.namespace;
        this._allData = opts.allData || null;
        this._isRadio = !!opts.isRadio;

        this._list = null;
        this._filterCache = null;
    }

    get pageFilter() {
        return this._pageFilter;
    }

    get allData() {
        return this._allData;
    }

    _$getWrpList() {
        return $(`<div class="list ui-list__wrp overflow-x-hidden overflow-y-auto h-100 min-h-0"></div>`);
    }

    _$getColumnHeaderPreviewAll(opts) {
        return $(`<button class="btn btn-default btn-xs ${opts.isBuildUi ? "col-1" : "col-0-5"}">${ListUiUtil.HTML_GLYPHICON_EXPAND}</button>`);
    }

    async pPopulateWrapper($wrp, opts) {
        opts = opts || {};

        await this._pInit();

        const $ovlLoading = $(`<div class="w-100 h-100 ve-flex-vh-center"><i class="dnd-font ve-muted">Loading...</i></div>`).appendTo($wrp);

        const $iptSearch = (opts.$iptSearch || $(`<input class="form-control lst__search lst__search--no-border-h h-100" type="search" placeholder="Search...">`)).disableSpellcheck();
        const $btnReset = opts.$btnReset || $(`<button class="btn btn-default">Reset</button>`);
        const $dispNumVisible = $(`<div class="lst__wrp-search-visible no-events ve-flex-vh-center"></div>`);

        const $wrpIptSearch = $$`<div class="w-100 relative">
			${$iptSearch}
			<div class="lst__wrp-search-glass no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>
			${$dispNumVisible}
		</div>`;

        const $wrpFormTop = $$`<div class="ve-flex input-group btn-group w-100 lst__form-top">${$wrpIptSearch}${$btnReset}</div>`;

        const $wrpFormBottom = opts.$wrpMiniPills || $(`<div class="w-100"></div>`);

        const $wrpFormHeaders = $(`<div class="input-group input-group--bottom ve-flex no-shrink"></div>`);
        const $cbSelAll = opts.isBuildUi || this._isRadio ? null : $(`<input type="checkbox">`);
        const $btnSendAllToRight = opts.isBuildUi ? $(`<button class="btn btn-xxs btn-default col-1" title="Add All"><span class="glyphicon glyphicon-arrow-right"></span></button>`) : null;

        if (!opts.isBuildUi) {
            if (this._isRadio)
                $wrpFormHeaders.append(`<label class="btn btn-default btn-xs col-0-5 ve-flex-vh-center" disabled></label>`);
            else
                $$`<label class="btn btn-default btn-xs col-0-5 ve-flex-vh-center">${$cbSelAll}</label>`.appendTo($wrpFormHeaders);
        }

        const $btnTogglePreviewAll = this._$getColumnHeaderPreviewAll(opts).appendTo($wrpFormHeaders);

        this._$getColumnHeaders().forEach($ele=>$wrpFormHeaders.append($ele));
        if (opts.isBuildUi)
            $btnSendAllToRight.appendTo($wrpFormHeaders);

        const $wrpForm = $$`<div class="ve-flex-col w-100 mb-1">${$wrpFormTop}${$wrpFormBottom}${$wrpFormHeaders}</div>`;
        const $wrpList = this._$getWrpList();

        const $btnConfirm = opts.isBuildUi ? null : $(`<button class="btn btn-default">Confirm</button>`);

        this._list = new List({
            $iptSearch,
            $wrpList,
            fnSort: this._fnSort,
        });
        const listSelectClickHandler = new ListSelectClickHandler({
            list: this._list
        });

        if (!opts.isBuildUi && !this._isRadio)
            listSelectClickHandler.bindSelectAllCheckbox($cbSelAll);
        ListUiUtil.bindPreviewAllButton($btnTogglePreviewAll, this._list);
        SortUtil.initBtnSortHandlers($wrpFormHeaders, this._list);
        this._list.on("updated", ()=>$dispNumVisible.html(`${this._list.visibleItems.length}/${this._list.items.length}`));

        this._allData = this._allData || await this._pLoadAllData();

        await this._pageFilter.pInitFilterBox({
            $wrpFormTop,
            $btnReset,
            $wrpMiniPills: $wrpFormBottom,
            namespace: this._namespace,
            $btnOpen: opts.$btnOpen,
            $btnToggleSummaryHidden: opts.$btnToggleSummaryHidden,
        });

        this._allData.forEach((it,i)=>{
            this._pageFilter.mutateAndAddToFilters(it);
            const filterListItem = this._getListItem(this._pageFilter, it, i);
            this._list.addItem(filterListItem);
            if (!opts.isBuildUi) {
                if (this._isRadio)
                    filterListItem.ele.addEventListener("click", evt=>listSelectClickHandler.handleSelectClickRadio(filterListItem, evt));
                else
                    filterListItem.ele.addEventListener("click", evt=>listSelectClickHandler.handleSelectClick(filterListItem, evt));
            }
        }
        );

        this._list.init();
        this._list.update();

        const handleFilterChange = ()=>{
            const f = this._pageFilter.filterBox.getValues();
            this._list.filter(li=>this._isListItemMatchingFilter(f, li));
        }
        ;

        this._pageFilter.trimState();

        this._pageFilter.filterBox.on(FilterBox$1.EVNT_VALCHANGE, handleFilterChange);
        this._pageFilter.filterBox.render();
        handleFilterChange();

        $ovlLoading.remove();

        const $wrpInner = $$`<div class="ve-flex-col h-100">
			${$wrpForm}
			${$wrpList}
			${opts.isBuildUi ? null : $$`<hr class="hr-1"><div class="ve-flex-vh-center">${$btnConfirm}</div>`}
		</div>`.appendTo($wrp.empty());

        return {
            $wrpIptSearch,
            $iptSearch,
            $wrpInner,
            $btnConfirm,
            pageFilter: this._pageFilter,
            list: this._list,
            $cbSelAll,
            $btnSendAllToRight,
        };
    }

    _isListItemMatchingFilter(f, li) {
        return this._isEntityItemMatchingFilter(f, this._allData[li.ix]);
    }
    _isEntityItemMatchingFilter(f, it) {
        return this._pageFilter.toDisplay(f, it);
    }

    async pPopulateHiddenWrapper() {
        await this._pInit();

        this._allData = this._allData || await this._pLoadAllData();

        await this._pageFilter.pInitFilterBox({
            namespace: this._namespace
        });

        this._allData.forEach(it=>{
            this._pageFilter.mutateAndAddToFilters(it);
        }
        );

        this._pageFilter.trimState();
    }

    handleHiddenOpenButtonClick() {
        this._pageFilter.filterBox.show();
    }

    handleHiddenResetButtonClick(evt) {
        this._pageFilter.filterBox.reset(evt.shiftKey);
    }

    _getStateFromFilterExpression(filterExpression) {
        const filterSubhashMeta = Renderer.getFilterSubhashes(Renderer.splitTagByPipe(filterExpression), this._namespace);
        const subhashes = filterSubhashMeta.subhashes.map(it=>`${it.key}${HASH_SUB_KV_SEP}${it.value}`);
        const unpackedSubhashes = this.pageFilter.filterBox.unpackSubHashes(subhashes, {
            force: true
        });
        return this.pageFilter.filterBox.getNextStateFromSubHashes({
            unpackedSubhashes
        });
    }

    getItemsMatchingFilterExpression({filterExpression}) {
        const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);

        const f = this._pageFilter.filterBox.getValues({
            nxtStateOuter
        });
        const filteredItems = this._filterCache.list.getFilteredItems({
            items: this._filterCache.list.items,
            fnFilter: li=>this._isListItemMatchingFilter(f, li),
        });

        return this._filterCache.list.getSortedItems({
            items: filteredItems
        });
    }

    getEntitiesMatchingFilterExpression({filterExpression}) {
        const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);

        const f = this._pageFilter.filterBox.getValues({
            nxtStateOuter
        });
        return this._allData.filter(this._isEntityItemMatchingFilter.bind(this, f));
    }

    getRenderedFilterExpression({filterExpression}) {
        const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);
        return this.pageFilter.filterBox.getDisplayState({
            nxtStateOuter
        });
    }

    async pGetUserSelection({filterExpression=null}={}) {
        return new Promise(async resolve=>{
            const {$modalInner, doClose} = await this._pGetShowModal(resolve);

            await this.pPreloadHidden($modalInner);

            this._doApplyFilterExpression(filterExpression);

            this._filterCache.$btnConfirm.off("click").click(async()=>{
                const checked = this._filterCache.list.visibleItems.filter(it=>it.data.cbSel.checked);
                resolve(checked);

                doClose(true);

                if (this._filterCache.$cbSelAll)
                    this._filterCache.$cbSelAll.prop("checked", false);
                this._filterCache.list.items.forEach(it=>{
                    if (it.data.cbSel)
                        it.data.cbSel.checked = false;
                    it.ele.classList.remove("list-multi-selected");
                }
                );
            }
            );

            await UiUtil.pDoForceFocus(this._filterCache.$iptSearch[0]);
        }
        );
    }

    async _pGetShowModal(resolve) {
        const {$modalInner, doClose} = await UiUtil.pGetShowModal({
            isHeight100: true,
            isWidth100: true,
            title: `Filter/Search for ${this._modalTitle}`,
            cbClose: (isDataEntered)=>{
                this._filterCache.$wrpModalInner.detach();
                if (!isDataEntered)
                    resolve([]);
            }
            ,
            isUncappedHeight: true,
        });

        return {
            $modalInner,
            doClose
        };
    }

    _doApplyFilterExpression(filterExpression) {
        if (!filterExpression)
            return;

        const filterSubhashMeta = Renderer.getFilterSubhashes(Renderer.splitTagByPipe(filterExpression), this._namespace);
        const subhashes = filterSubhashMeta.subhashes.map(it=>`${it.key}${HASH_SUB_KV_SEP}${it.value}`);
        this.pageFilter.filterBox.setFromSubHashes(subhashes, {
            force: true,
            $iptSearch: this._filterCache.$iptSearch
        });
    }

    _getNameStyle() {
        return `bold`;
    }

    async pPreloadHidden($modalInner) {
        $modalInner = $modalInner || $(`<div></div>`);

        if (this._filterCache) {
            this._filterCache.$wrpModalInner.appendTo($modalInner);
        } else {
            const meta = await this.pPopulateWrapper($modalInner);
            const {$iptSearch, $btnConfirm, pageFilter, list, $cbSelAll} = meta;
            const $wrpModalInner = meta.$wrpInner;

            this._filterCache = {
                $iptSearch,
                $wrpModalInner,
                $btnConfirm,
                pageFilter,
                list,
                $cbSelAll
            };
        }
    }

    _$getColumnHeaders() {
        throw new Error(`Unimplemented!`);
    }
    async _pInit() {}
    async _pLoadAllData() {
        throw new Error(`Unimplemented!`);
    }
    async _getListItem() {
        throw new Error(`Unimplemented!`);
    }
}
class ModalFilterClasses extends ModalFilter {
    constructor(opts) {
        opts = opts || {};

        super({
            ...opts,
            modalTitle: "Class and Subclass",
            pageFilter: new PageFilterClassesRaw$1(),
            fnSort: ModalFilterClasses.fnSort,
        });

        this._pLoadingAllData = null;

        this._ixPrevSelectedClass = null;
        this._isClassDisabled = false;
        this._isSubclassDisabled = false;
    }

    get pageFilter() {
        return this._pageFilter;
    }

    static fnSort(a, b, opts) {
        const out = SortUtil.listSort(a, b, opts);

        if (opts.sortDir === "desc" && a.data.ixClass === b.data.ixClass && (a.data.ixSubclass != null || b.data.ixSubclass != null)) {
            return a.data.ixSubclass != null ? -1 : 1;
        }

        return out;
    }

    async pGetSelection(classSubclassMeta) {
        const {className, classSource, subclassName, subclassSource} = classSubclassMeta;

        const allData = this._allData || await this._pLoadAllData();

        const cls = allData.find(it=>it.name === className && it.source === classSource);
        if (!cls)
            throw new Error(`Could not find class with name "${className}" and source "${classSource}"`);

        const out = {
            class: cls,
        };

        if (subclassName && subclassSource) {
            const sc = cls.subclasses.find(it=>it.name === subclassName && it.source === subclassSource);
            if (!sc)
                throw new Error(`Could not find subclass with name "${subclassName}" and source "${subclassSource}" on class with name "${className}" and source "${classSource}"`);

            out.subclass = sc;
        }

        return out;
    }

    async pGetUserSelection({filterExpression=null, selectedClass=null, selectedSubclass=null, isClassDisabled=false, isSubclassDisabled=false}={}) {
        return new Promise(async resolve=>{
            const {$modalInner, doClose} = await this._pGetShowModal(resolve);

            await this.pPreloadHidden($modalInner);

            this._doApplyFilterExpression(filterExpression);

            this._filterCache.$btnConfirm.off("click").click(async()=>{
                const checked = this._filterCache.list.items.filter(it=>it.data.tglSel.classList.contains("active"));
                const out = {};
                checked.forEach(it=>{
                    if (it.data.ixSubclass == null)
                        out.class = this._filterCache.allData[it.data.ixClass];
                    else
                        out.subclass = this._filterCache.allData[it.data.ixClass].subclasses[it.data.ixSubclass];
                }
                );
                resolve(MiscUtil.copy(out));

                doClose(true);

                ModalFilterClasses$1._doListDeselectAll(this._filterCache.list);
            }
            );

            this._ixPrevSelectedClass = selectedClass != null ? this._filterCache.allData.findIndex(it=>it.name === selectedClass.name && it.source === selectedClass.source) : null;
            this._isClassDisabled = isClassDisabled;
            this._isSubclassDisabled = isSubclassDisabled;
            this._filterCache.list.items.forEach(li=>{
                const isScLi = li.data.ixSubclass != null;
                if (isScLi) {
                    li.data.tglSel.classList.toggle("disabled", this._isSubclassDisabled || (this._isClassDisabled && li.data.ixClass !== this._ixPrevSelectedClass));
                } else {
                    li.data.tglSel.classList.toggle("disabled", this._isClassDisabled);
                }
            }
            );

            if (selectedClass != null) {
                const ixSubclass = ~this._ixPrevSelectedClass && selectedSubclass != null ? this._filterCache.allData[this._ixPrevSelectedClass].subclasses.findIndex(it=>it.name === selectedSubclass.name && it.source === selectedSubclass.source) : -1;

                if (~this._ixPrevSelectedClass) {
                    ModalFilterClasses$1._doListDeselectAll(this._filterCache.list);

                    const clsItem = this._filterCache.list.items.find(it=>it.data.ixClass === this._ixPrevSelectedClass && it.data.ixSubclass == null);
                    if (clsItem) {
                        clsItem.data.tglSel.classList.add("active");
                        clsItem.ele.classList.add("list-multi-selected");
                    }

                    if (~ixSubclass && clsItem) {
                        const scItem = this._filterCache.list.items.find(it=>it.data.ixClass === this._ixPrevSelectedClass && it.data.ixSubclass === ixSubclass);
                        scItem.data.tglSel.classList.add("active");
                        scItem.ele.classList.add("list-multi-selected");
                    }
                }

                this._filterCache.list.setFnSearch((li,searchTerm)=>{
                    if (li.data.ixClass !== this._ixPrevSelectedClass)
                        return false;
                    return List.isVisibleDefaultSearch(li, searchTerm);
                }
                );
            } else {
                this._filterCache.list.setFnSearch(null);
            }

            this._filterCache.list.update();

            await UiUtil.pDoForceFocus(this._filterCache.$iptSearch[0]);
        }
        );
    }

    async pPreloadHidden($modalInner) {
        $modalInner = $modalInner || $(`<div></div>`);

        if (this._filterCache) {
            this._filterCache.$wrpModalInner.appendTo($modalInner);
        } else {
            await this._pInit();

            const $ovlLoading = $(`<div class="w-100 h-100 ve-flex-vh-center"><i class="dnd-font ve-muted">Loading...</i></div>`).appendTo($modalInner);

            const $iptSearch = $(`<input class="form-control h-100" type="search" placeholder="Search...">`);
            const $btnReset = $(`<button class="btn btn-default">Reset</button>`);
            const $wrpFormTop = $$`<div class="ve-flex input-group btn-group w-100 lst__form-top">${$iptSearch}${$btnReset}</div>`;

            const $wrpFormBottom = $(`<div class="w-100"></div>`);

            const $wrpFormHeaders = $(`<div class="input-group input-group--bottom ve-flex no-shrink">
				<div class="btn btn-default disabled col-1 pl-0"></div>
				<button class="col-9 sort btn btn-default btn-xs" data-sort="name">Name</button>
				<button class="col-2 pr-0 sort btn btn-default btn-xs ve-grow" data-sort="source">Source</button>
			</div>`);

            const $wrpForm = $$`<div class="ve-flex-col w-100 mb-2">${$wrpFormTop}${$wrpFormBottom}${$wrpFormHeaders}</div>`;
            const $wrpList = this._$getWrpList();

            const $btnConfirm = $(`<button class="btn btn-default">Confirm</button>`);

            const list = new List({
                $iptSearch,
                $wrpList,
                fnSort: this._fnSort,
            });

            SortUtil.initBtnSortHandlers($wrpFormHeaders, list);

            const allData = this._allData || await this._pLoadAllData();
            const pageFilter = this._pageFilter;

            await pageFilter.pInitFilterBox({
                $wrpFormTop,
                $btnReset,
                $wrpMiniPills: $wrpFormBottom,
                namespace: this._namespace,
            });

            allData.forEach((it,i)=>{
                pageFilter.mutateAndAddToFilters(it);
                const filterListItems = this._getListItems(pageFilter, it, i);
                filterListItems.forEach(li=>{
                    list.addItem(li);
                    li.ele.addEventListener("click", evt=>{
                        const isScLi = li.data.ixSubclass != null;

                        if (isScLi) {
                            if (this._isSubclassDisabled)
                                return;
                            if (this._isClassDisabled && li.data.ixClass !== this._ixPrevSelectedClass)
                                return;
                        } else {
                            if (this._isClassDisabled)
                                return;
                        }

                        this._handleSelectClick({
                            list,
                            filterListItems,
                            filterListItem: li,
                            evt,
                        });
                    }
                    );
                }
                );
            }
            );

            list.init();
            list.update();

            const handleFilterChange = ()=>{
                return this.constructor.handleFilterChange({
                    pageFilter,
                    list,
                    allData
                });
            }
            ;

            pageFilter.trimState();

            pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, handleFilterChange);
            pageFilter.filterBox.render();
            handleFilterChange();

            $ovlLoading.remove();

            const $wrpModalInner = $$`<div class="ve-flex-col h-100">
				${$wrpForm}
				${$wrpList}
				<div class="ve-flex-vh-center">${$btnConfirm}</div>
			</div>`.appendTo($modalInner);

            this._filterCache = {
                $wrpModalInner,
                $btnConfirm,
                pageFilter,
                list,
                allData,
                $iptSearch
            };
        }
    }

    static handleFilterChange({pageFilter, list, allData}) {
        const f = pageFilter.filterBox.getValues();

        list.filter(li=>{
            const cls = allData[li.data.ixClass];

            if (li.data.ixSubclass != null) {
                const sc = cls.subclasses[li.data.ixSubclass];
                if (!pageFilter.toDisplay(f, cls, [], null, ))
                    return false;

                return pageFilter.filterBox.toDisplay(f, sc.source, sc._fMisc, null, );
            }

            return pageFilter.toDisplay(f, cls, [], null);
        }
        );
    }

    static _doListDeselectAll(list, {isSubclassItemsOnly=false}={}) {
        list.items.forEach(it=>{
            if (isSubclassItemsOnly && it.data.ixSubclass == null)
                return;

            if (it.data.tglSel)
                it.data.tglSel.classList.remove("active");
            it.ele.classList.remove("list-multi-selected");
        }
        );
    }

    _handleSelectClick({list, filterListItems, filterListItem, evt}) {
        evt.preventDefault();
        evt.stopPropagation();

        const isScLi = filterListItem.data.ixSubclass != null;

        if (this._isClassDisabled && this._ixPrevSelectedClass != null && isScLi) {
            if (!filterListItem.data.tglSel.classList.contains("active"))
                this.constructor._doListDeselectAll(list, {
                    isSubclassItemsOnly: true
                });
            filterListItem.data.tglSel.classList.toggle("active");
            filterListItem.ele.classList.toggle("list-multi-selected");
            return;
        }

        if (filterListItem.data.tglSel.classList.contains("active")) {
            this.constructor._doListDeselectAll(list);
            return;
        }

        this.constructor._doListDeselectAll(list);

        if (isScLi) {
            const classItem = filterListItems[0];
            classItem.data.tglSel.classList.add("active");
            classItem.ele.classList.add("list-multi-selected");
        }

        filterListItem.data.tglSel.classList.add("active");
        filterListItem.ele.classList.add("list-multi-selected");
    }

    async _pLoadAllData() {
        this._pLoadingAllData = this._pLoadingAllData || (async()=>{
            const [data,prerelease,brew] = await Promise.all([MiscUtil.copy(await DataUtil.class.loadRawJSON()), PrereleaseUtil.pGetBrewProcessed(), BrewUtil2.pGetBrewProcessed(), ]);

            this._pLoadAllData_mutAddPrereleaseBrew({
                data,
                brew: prerelease,
                brewUtil: PrereleaseUtil
            });
            this._pLoadAllData_mutAddPrereleaseBrew({
                data,
                brew: brew,
                brewUtil: BrewUtil2
            });

            this._allData = (await PageFilterClassesRaw$1.pPostLoad(data)).class;
        }
        )();

        await this._pLoadingAllData;
        return this._allData;
    }

    _pLoadAllData_mutAddPrereleaseBrew({data, brew, brewUtil}) {
        const clsProps = brewUtil.getPageProps({
            page: UrlUtil.PG_CLASSES
        });

        if (!clsProps.includes("*")) {
            clsProps.forEach(prop=>data[prop] = [...(data[prop] || []), ...MiscUtil.copy(brew[prop] || [])]);
            return;
        }

        Object.entries(brew).filter(([,brewVal])=>brewVal instanceof Array).forEach(([prop,brewArr])=>data[prop] = [...(data[prop] || []), ...MiscUtil.copy(brewArr)]);
    }

    _getListItems(pageFilter, cls, clsI) {
        return [this._getListItems_getClassItem(pageFilter, cls, clsI), ...cls.subclasses.map((sc,scI)=>this._getListItems_getSubclassItem(pageFilter, cls, clsI, sc, scI)), ];
    }

    _getListItems_getClassItem(pageFilter, cls, clsI) {
        const eleLabel = document.createElement("label");
        eleLabel.className = `w-100 ve-flex lst--border veapp__list-row no-select lst__wrp-cells`;

        const source = Parser.sourceJsonToAbv(cls.source);

        eleLabel.innerHTML = `<div class="col-1 pl-0 ve-flex-vh-center"><div class="fltr-cls__tgl"></div></div>
		<div class="bold col-9 ${cls._versionBase_isVersion ? "italic" : ""}">${cls._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${cls.name}</div>
		<div class="col-2 pr-0 ve-text-center ${Parser.sourceJsonToColor(cls.source)}" title="${Parser.sourceJsonToFull(cls.source)}" ${Parser.sourceJsonToStyle(cls.source)}>${source}</div>`;

        return new ListItem(clsI,eleLabel,`${cls.name} -- ${cls.source}`,{
            source: `${source} -- ${cls.name}`,
        },{
            ixClass: clsI,
            tglSel: eleLabel.firstElementChild.firstElementChild,
        },);
    }

    _getListItems_getSubclassItem(pageFilter, cls, clsI, sc, scI) {
        const eleLabel = document.createElement("label");
        eleLabel.className = `w-100 ve-flex lst--border veapp__list-row no-select lst__wrp-cells`;

        const source = Parser.sourceJsonToAbv(sc.source);

        eleLabel.innerHTML = `<div class="col-1 pl-0 ve-flex-vh-center"><div class="fltr-cls__tgl"></div></div>
		<div class="col-9 pl-1 ve-flex-v-center ${sc._versionBase_isVersion ? "italic" : ""}">${sc._versionBase_isVersion ? `<span class="px-3"></span>` : ""}<span class="mx-3">\u2014</span> ${sc.name}</div>
		<div class="col-2 pr-0 ve-text-center ${Parser.sourceJsonToColor(sc.source)}" title="${Parser.sourceJsonToFull(sc.source)}" ${Parser.sourceJsonToStyle(sc.source)}>${source}</div>`;

        return new ListItem(`${clsI}--${scI}`,eleLabel,`${cls.name} -- ${cls.source} -- ${sc.name} -- ${sc.source}`,{
            source: `${cls.source} -- ${cls.name} -- ${source} -- ${sc.name}`,
        },{
            ixClass: clsI,
            ixSubclass: scI,
            tglSel: eleLabel.firstElementChild.firstElementChild,
        },);
    }
}
//#endregion

class MixedModalFilterFvtt //extends Cls
{
    constructor(...args) {
        //super(...args);

        this._prevApp = null;
    }

    _getNameStyle() {
        return "";
    }

    _getShowModal(resolve) {
        if (this._prevApp)
            this._prevApp.close();

        const self = this;

        const app = new class TempApplication extends Application {
            constructor() {
                super({
                    title: `Filter/Search for ${self._modalTitle}`,
                    template: `${SharedConsts.MODULE_LOCATION}/template/_Generic.hbs`,
                    width: Util.getMaxWindowWidth(900),
                    height: Util.getMaxWindowHeight(),
                    resizable: true,
                });

                this._$wrpHtmlInner = $(`<div class="ve-flex-col w-100 h-100"></div>`);
            }

            get $modalInner() {
                return this._$wrpHtmlInner;
            }

            async close(...args) {
                self._filterCache.$wrpModalInner.detach();
                await super.close(...args);
                resolve([]);
            }

            activateListeners($html) {
                this._$wrpHtmlInner.appendTo($html);
            }
        }
        ();

        app.render(true);
        this._prevApp = app;

        return {
            $modalInner: app.$modalInner,
            doClose: app.close.bind(app)
        };
    }

    getDataFromSelected(selected) {
        return this._allData[selected.ix];
    }
}
//Cls is an input class we choose to extend
function MixinModalFilterFvtt(Cls) {
    class MixedModalFilterFvtt extends Cls {
        constructor(...args) {
            super(...args);

            this._prevApp = null;
        }

        _getNameStyle() {
            return "";
        }

        _getShowModal(resolve) {
            if (this._prevApp)
                this._prevApp.close();

            const self = this;

            const app = new class TempApplication extends Application {
                constructor() {
                    super({
                        title: `Filter/Search for ${self._modalTitle}`,
                        template: `${SharedConsts.MODULE_LOCATION}/template/_Generic.hbs`,
                        width: Util.getMaxWindowWidth(900),
                        height: Util.getMaxWindowHeight(),
                        resizable: true,
                    });

                    this._$wrpHtmlInner = $(`<div class="ve-flex-col w-100 h-100"></div>`);
                }

                get $modalInner() {
                    return this._$wrpHtmlInner;
                }

                async close(...args) {
                    self._filterCache.$wrpModalInner.detach();
                    await super.close(...args);
                    resolve([]);
                }

                activateListeners($html) {
                    this._$wrpHtmlInner.appendTo($html);
                }
            }
            ();

            app.render(true);
            this._prevApp = app;

            return {
                $modalInner: app.$modalInner,
                doClose: app.close.bind(app)
            };
        }

        getDataFromSelected(selected) {
            return this._allData[selected.ix];
        }
    }
    return MixedModalFilterFvtt;
}
class ModalFilterClassesFvtt extends MixinModalFilterFvtt(ModalFilterClasses) {
}
//#endregion


